<!DOCTYPE html><html class="theme-next pisces use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><script src="/lib/pace/pace.min.js?v=1.0.2"></script><link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="Java,JVM,GC,"><link rel="alternate" href="/atom.xml" title="SakuraTears的博客" type="application/atom+xml"><meta name="description" content="前言我们知道在JVM内存模型中，堆是十分重要的一块，堆是内存占用最大，管理最复杂的一个区域，其用途就是存放生成的对象实例，所有的对象都会在堆上进行分配使用。 JDK1.8后，字符串常量池从永久代剥离了出来，也存放在了堆上。 正文堆内存结构我们来看一下堆内存结构，JDK1.8后JVM堆内存结构如下图：  可以看到堆内存分为年轻代（Young Generation）、年老代（Old Generatio"><meta name="keywords" content="Java,JVM,GC"><meta property="og:type" content="article"><meta property="og:title" content="JVM堆内存及垃圾回收简介"><meta property="og:url" content="https://www.sakuratears.top/blog/JVM堆内存及垃圾回收简介.html"><meta property="og:site_name" content="SakuraTears的博客"><meta property="og:description" content="前言我们知道在JVM内存模型中，堆是十分重要的一块，堆是内存占用最大，管理最复杂的一个区域，其用途就是存放生成的对象实例，所有的对象都会在堆上进行分配使用。 JDK1.8后，字符串常量池从永久代剥离了出来，也存放在了堆上。 正文堆内存结构我们来看一下堆内存结构，JDK1.8后JVM堆内存结构如下图：  可以看到堆内存分为年轻代（Young Generation）、年老代（Old Generatio"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-420.png"><meta property="og:image" content="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-421.png"><meta property="og:image" content="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-422.png"><meta property="og:image" content="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-423.png"><meta property="og:image" content="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-424.png"><meta property="og:image" content="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-425.png"><meta property="og:image" content="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-426.png"><meta property="og:image" content="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-427.png"><meta property="og:image" content="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-428.png"><meta property="og:image" content="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-428.gif"><meta property="og:updated_time" content="2019-06-27T14:10:50.304Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="JVM堆内存及垃圾回收简介"><meta name="twitter:description" content="前言我们知道在JVM内存模型中，堆是十分重要的一块，堆是内存占用最大，管理最复杂的一个区域，其用途就是存放生成的对象实例，所有的对象都会在堆上进行分配使用。 JDK1.8后，字符串常量池从永久代剥离了出来，也存放在了堆上。 正文堆内存结构我们来看一下堆内存结构，JDK1.8后JVM堆内存结构如下图：  可以看到堆内存分为年轻代（Young Generation）、年老代（Old Generatio"><meta name="twitter:image" content="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-420.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!0,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://www.sakuratears.top/blog/JVM堆内存及垃圾回收简介.html"><title>JVM堆内存及垃圾回收简介 | SakuraTears的博客</title><link rel="stylesheet" href="/assets/css/APlayer.min.css" class="aplayer-style-marker"><script src="/assets/js/APlayer.min.js" class="aplayer-script-marker"></script></head><body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div> <a href="https://github.com/javazwt" rel="external nofollow noopener noreferrer" target="_blank"><img style="position:absolute;top:0;left:0;border:0" src="https://s3.amazonaws.com/github/ribbons/forkme_left_gray_6d6d6d.png" alt="Fork me on GitHub"></a><header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">SakuraTears的博客</span><span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">越努力越幸运</h1></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> 首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br> 关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br> 归档</a></li><li class="menu-item menu-item-support"><a href="/support/" rel="section"><i class="menu-item-icon fa fa-fw fa-support"></i><br> 开源支持</a></li><li class="menu-item menu-item-photos"><a href="/photos/" rel="section"><i class="menu-item-icon fa fa-fw fa-photo"></i><br> 相册</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br> 搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i></span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"> <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.sakuratears.top/blog/JVM堆内存及垃圾回收简介.html"><span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="name" content="SakuraTears"><meta itemprop="description" content=""><meta itemprop="image" content="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/others/avatar.jpg"></span><span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="SakuraTears的博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">JVM堆内存及垃圾回收简介</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-27T21:48:00+08:00">2019-06-27</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习/" itemprop="url" rel="index"><span itemprop="name">学习</span></a></span></span> <span class="post-comments-count"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i></span><a href="/blog/JVM堆内存及垃圾回收简介.html#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/blog/JVM堆内存及垃圾回收简介.html" itemprop="commentCount"></span></a></span> <span id="/blog/JVM堆内存及垃圾回收简介.html" class="leancloud_visitors" data-flag-title="JVM堆内存及垃圾回收简介"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数&#58;</span><span class="leancloud-visitors-count"></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">10,254</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">43</span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们知道在JVM内存模型中，堆是十分重要的一块，堆是内存占用最大，管理最复杂的一个区域，其用途就是存放生成的对象实例，所有的对象都会在堆上进行分配使用。</p><p>JDK1.8后，字符串常量池从永久代剥离了出来，也存放在了堆上。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="堆内存结构"><a href="#堆内存结构" class="headerlink" title="堆内存结构"></a>堆内存结构</h2><p>我们来看一下堆内存结构，JDK1.8后JVM堆内存结构如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-420.png" alt="upload successful"></p><p>可以看到堆内存分为年轻代（Young Generation）、年老代（Old Generation）及元空间（MetaData Space）。</p><p>PS:JDK8 完全移除永久代(Permanent Generation), 取而代之的是元空间MetaData Space（JVM使用本地内存，存放类的元数据）。</p><p>年轻代（Young Generation）又分为 Eden Space 和 Survivor Space，其中Survivor区有两部分构成 Survivor 1 和 Survivor 2 。</p><p>JVM虚拟机默认Eden区和两块Survivor区的内存比例为8:1:1。</p><h2 id="GC流程"><a href="#GC流程" class="headerlink" title="GC流程"></a>GC流程</h2><p>年轻代内存的大致使用过程为：</p><pre><code>年轻代将内存分为Eden和2块Survivor区（分别叫from和to）。

一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。

对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。

在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。

紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。

经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。

经过Minor GC之后，如果Survivor存放不下存活的对象，对象就会通过分配担保机制进入老年代，而如果老年代空间还不够，就会进行Full GC。

Minor GC会一直重复这样的过程，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。
</code></pre><p>因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。</p><p>因此对象进入年老代有以下4种情况：</p><ul><li><p>经过Minor GC后，Survivor区存放不下存活的对象进入年老代。</p></li><li><p>对象长期存活，当年龄达到一定阈值后进入年老代，默认15。年龄阈值，可以通过-XX:MaxTenuringThreshold来设置。</p></li><li><p>大对象直接进入年老代，通过 -XX:PretenureSizeThreshold 参数可以进行设置多大的对象直接在年老代进行分配，从而避免大对象在年轻代（Eden和Survivor区）发生大量内存赋值操作。</p></li><li><p>如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。（动态对象年龄绑定）</p></li></ul><p>GC的大致回收流程如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-421.png" alt="upload successful"></p><p>GC的回收分为垃圾的收集和回收两部分，收集和回收都涉及到一些算法逻辑，我们来整理下。</p><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p>JVM中常用的垃圾收集算法大致有两种，引用计数法和根搜索法。</p><ol><li><p>引用计数法</p><p> 引用计数法本质是给对象添加引用计数器，当引用对象时计数器+1，引用失效时，计数器-1，当计数器等于0时，对象失效，内存可以被回收。</p><p> 但会有一个问题，如果A对象引用B对象，同时B对象又引用A对象，但它们都不会再被系统使用，则它们可认为为垃圾，但是它们的引用计数是永不为0的，因此该方法永远也不会将其标位垃圾。</p><p> 优点：实现简单高效。</p><p> 缺点：对象之间的互相循环引用问题不好解决。</p></li><li><p>根搜索法</p><p> 通过GC roots可达的对象路径称为引用链（reference chain），当一个对象没有引用链时（即从GC roots不可达）则视为不可用对象，内存可以被回收。</p><p> JVM主要使用根搜索法进行垃圾收集。</p><p> 那在JVM中，哪些对象可以视为GC roots呢？</p><ul><li><p>虚拟机栈中（即栈帧中的本地变量）的引用对象；</p></li><li><p>本地方法栈中的引用对象；</p></li><li><p>方法区中的静态变量引用的对象和常量池中引用的对象。</p></li></ul></li></ol><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><ol><li><p>标记-清除算法</p><p> 分两步进行，第一步标记出可以回收的对象，第二步统一清理可以回收的对象内存。</p><p> 缺点：如果在被标记后直接对对象进行清除，会带来另一个新的问题——内存碎片化。如果下次有比较大的对象实例需要在堆上分配较大的内存空间时，可能会出现无法找到足够的连续内存而不得不再次触发垃圾回收。</p></li><li><p>复制算法</p><p> 此GC算法实际上解决了标记-清除算法带来的“内存碎片化”问题。首先还是先标记处待回收内存和不用回收的内存，下一步将不用回收的内存复制到新的内存区域，这样旧的内存区域就可以全部回收，而新的内存区域则是连续的。</p><p> 缺点：就是会损失掉部分系统内存，因为你总要腾出一部分内存用于复制。</p></li><li><p>标记-整理算法</p><p> 标记-压缩算法首先还是“标记”，标记过后，将不用回收的内存对象压缩到内存一端，此时即可直接清除边界处的内存，这样就能避免复制算法带来的效率问题，同时也能避免内存碎片化的问题。</p></li><li><p>分代收集算法</p><p> 对于JVM堆内存的垃圾回收，可以认为是分代收集算法。</p><p> 对于年轻代，大部分对象都不会存活，所以在新生代中使用复制算法较为高效。</p><p> 而对于年老代来讲，大部分对象可能会继续存活下去，如果此时还是利用复制算法，效率则会降低，此时使用标记-整理算法，不仅提高效率，更节约内存。</p></li></ol><p>当然，具体使用哪种垃圾回收算法，也和垃圾收集器的实现有具体关系。</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>再来看一下JVM的几种垃圾收集器。</p><p>目前JVM有7种作用于不同分代的垃圾收集器。如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-422.png" alt="upload successful"></p><p>上图两个垃圾收集器之间的连线表示它们可以搭配使用。</p><ol><li><p>Serial收集器</p><p>Serial收集器是最基本、发展历史最悠久的收集器。是单线程的收集器。它在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集完成。</p><p>Serial收集器依然是虚拟机运行在Client模式下默认新生代（年轻代）收集器，对于运行在Client模式下的虚拟机来说是一个很好的选择。</p></li><li><p>ParNew收集器</p><p>ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与Serial 收集器完全一样。</p><p>ParNew收集器是许多运行在Server模式下的虚拟机中首选新生代收集器，其中有一个与性能无关但很重要的原因是，除Serial收集器之外，目前只有ParNew它能与CMS收集器配合工作。</p></li><li><p>Parallel Scavenge（并行回收）收集器</p><p>Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器。</p><p>该收集器的目标是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即 吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）。</p><p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可用高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p><p>Parallel Scavenge收集器提供两个参数用于精确控制吞吐量，分别是控制最大垃圾收起停顿时间的 -XX:MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX:GCTimeRatio参数</p><p>Parallel Scavenge收集器还有一个参数：-XX:+UseAdaptiveSizePolicy。这是一个开关参数，当这个参数打开后，就不需要手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数，只需要把基本的内存数据设置好（如-Xmx设置最大堆），然后使用MaxGVPauseMillis参数或GCTimeRation参数给虚拟机设立一个优化目标。</p><p>自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别。</p></li><li><p>Serial Old 收集器</p><p>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记整理算法。这个收集器的主要意义也是在于给Client模式下的虚拟机使用。</p><p>如果在Server模式下，主要两大用途：</p><p> （1）在JDK1.5以及之前的版本中与Parallel Scavenge收集器搭配使用。</p><p> （2）作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。</p></li><li><p>Parallel Old 收集器</p><p> Parallel Old 是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。这个收集器在1.6中才开始提供。</p></li><li><p>CMS收集器</p><p>CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务器的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。</p><p>CMS收集器是基于“标记-清除”算法实现的。它的运作过程相对前面几种收集器来说更复杂一些，整个过程分为4个步骤：</p><p> （1）初始标记</p><p> （2）并发标记</p><p> （3）重新标记</p><p> （4）并发清除</p><p>其中，初始标记、重新标记这两个步骤仍然需要“Stop The World”.</p><p>CMS收集器主要优点：并发收集，低停顿。</p><p>CMS三个明显的缺点：</p><p> （1）CMS收集器对CPU资源非常敏感。CPU个数少于4个时，CMS对于用户程序的影响就可能变得很大，为了应付这种情况，虚拟机提供了一种称为“增量式并发收集器”的CMS收集器变种。所做的事情和单CPU年代PC机操作系统使用抢占式来模拟多任务机制的思想。</p><p> （2）CMS收集器无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。在JDK1.5的默认设置下，CMS收集器当老年代使用了68%的空间后就会被激活，这是一个偏保守的设置，如果在应用中老年代增长不是太快，可以适当调高参数-XX:CMSInitiatingOccupancyFraction的值来提高触发百分比，以便降低内存回收次数从而获取更好的性能，在JDK1.6中，CMS收集器的启动阀值已经提升至92%。</p><p> （3）CMS是基于“标记-清除”算法实现的收集器，收集结束时会有大量空间碎片产生。空间碎片过多，可能会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发FullGC。为了解决这个问题，CMS收集器提供了一个-XX:+UseCMSCompactAtFullCollection开关参数（默认就是开启的），用于在CMS收集器顶不住要进行FullGC时开启内存碎片合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间变长了。虚拟机设计者还提供了另外一个参数-XX:CMSFullGCsBeforeCompaction,这个参数是用于设置执行多少次不压缩的Full GC后，跟着来一次带压缩的Full GC（默认值为0，表示每次进入Full GC时都进行碎片整理）。</p></li><li><p>G1收集器</p><p>G1收集器的优势：</p><p> （1）并行与并发</p><p> （2）分代收集</p><p> （3）空间整理 （标记——整理算法，复制算法）</p><p> （4）可预测的停顿（G1除处理追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经实现Java（RTSJ）的垃圾收集器的特征）</p><p> 备注：</p><blockquote><p> The Real-time Specification for Java (RTSJ) is an open specification that augments the Java language to open the door more widely to using the language to build real-time systems (see Related topics). Implementing the RTSJ requires support in the operating system, the JRE, and the Java Class Library (JCL).</p></blockquote><p> 详见：<a href="https://www.ibm.com/developerworks/library/j-rtj1/index.html" rel="external nofollow noopener noreferrer" target="_blank">RTSJ</a> 中的Garbage collection的规范。</p><p>使用G1收集器时，Java堆的内存布局是整个规划为多个大小相等的独立区域（Region）,虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region的集合。</p><p> G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获取的空间大小以及回收所需要的时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（这也就是Garbage-First名称的又来）。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽量可能高的收集效率。</p><p> G1 内存“化整为零”的思路：</p><p> 在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会遗漏。</p><p> 如果不计算维护Remembered Set的操作，G1收集器的运作大致可划分为一下步骤：</p><p>（1）初始标记</p><p>（2）并发标记</p><p>（3）最终标记</p><p>（4）筛选回收</p></li></ol><p>参考：<a href="https://www.cnblogs.com/chengxuyuanzhilu/p/7088316.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/chengxuyuanzhilu/p/7088316.html</a></p><h2 id="JVM的一些参数"><a href="#JVM的一些参数" class="headerlink" title="JVM的一些参数"></a>JVM的一些参数</h2><p>我们再来看下JVM的一些常用参数设置。</p><h3 id="JVM的基础参数"><a href="#JVM的基础参数" class="headerlink" title="JVM的基础参数"></a>JVM的基础参数</h3><ul><li>-Xmx2048m：设置JVM最大堆内存为2048M。</li><li>-Xms2048m：设置JVM初始堆内存为2048M。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。</li><li>-Xss128k：设置每个线程的栈大小。JDK5.0以后每个线程栈大小为1M，之前每个线程栈大小为256K。应当根据应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。需要注意的是：当这个值被设置的较大（例如&gt;2MB）时将会在很大程度上降低系统的性能。</li><li>-Xmn1g：设置年轻代大小为1G。在整个堆内存大小确定的情况下，增大年轻代将会减小年老代，反之亦然。此值关系到JVM垃圾回收，对系统性能影响较大，官方推荐配置为整个堆大小的3/8。</li><li>-XX:NewSize=1024m：设置年轻代初始值为1024M。</li><li>-XX:MaxNewSize=1024m：设置年轻代最大值为1024M。</li><li>-XX:PermSize=256m：设置持久代初始值为256M。（1.7以下JDK版本有效）</li><li>-XX:MaxPermSize=256m：设置持久代最大值为256M。（1.7以下JDK版本有效）</li><li>-XX:MetaspaceSize=8m：初始元数据空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。（1.7以上JDK版本有效）</li><li>-XX:MaxMetaspaceSize=50m：元数据最大空间大小，默认是没有限制的。（1.7以上JDK版本有效）</li><li>-XX:NewRatio=4：设置年轻代（包括1个Eden和2个Survivor区）与年老代的比值。表示年轻代比年老代为1:4。</li><li>-XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的比值。表示2个Survivor区与1个Eden区的比值为2:4，即1个Survivor区占整个年轻代大小的1/6。</li><li>-XX:MaxTenuringThreshold=7：表示一个对象如果在Survivor区（救助空间）移动了7次还没有被垃圾回收就进入年老代。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代，对于需要大量常驻内存的应用，这样做可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象在年轻代存活时间，增加对象在年轻代被垃圾回收的概率，减少Full GC的频率，这样做可以在某种程度上提高服务稳定性。</li><li>-XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集。（1.7以上JDK版本有效）</li><li>-XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集。（1.7以上JDK版本有效）</li></ul><p>PS:可以看到-Xmn，-XX:NewSize/-XX:MaxNewSize，-XX:NewRatio 3组参数都可以影响年轻代的大小，它们混合使用生效的优先级为：</p><pre><code>高优先级：-XX:NewSize/-XX:MaxNewSize 
中优先级：-Xmn（默认等效  -Xmn=-XX:NewSize=-XX:MaxNewSize=?） 
低优先级：-XX:NewRatio 
</code></pre><p>推荐使用-Xmn参数。</p><h3 id="JVM垃圾回收参数"><a href="#JVM垃圾回收参数" class="headerlink" title="JVM垃圾回收参数"></a>JVM垃圾回收参数</h3><ul><li>-XX:+UseSerialGC：设置串行收集器。</li><li>-XX:+UseParallelGC：设置为并行收集器。此配置仅对年轻代有效。即年轻代使用并行收集，而年老代仍使用串行收集。</li><li>-XX:ParallelGCThreads=20：配置并行收集器的线程数，即：同时有多少个线程一起进行垃圾回收。此值建议配置与CPU数目相等。</li><li>-XX:+UseParallelOldGC：配置年老代垃圾收集方式为并行收集。JDK6.0开始支持对年老代并行收集。</li><li>-XX:MaxGCPauseMillis=100：设置每次年轻代垃圾回收的最长时间（单位毫秒）。如果无法满足此时间，JVM会自动调整年轻代大小，以满足此时间。</li><li>-XX:+UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动调整年轻代Eden区大小和Survivor区大小的比例，以达成目标系统规定的最低响应时间或者收集频率等指标。此参数建议在使用并行收集器时，一直打开。</li><li>-XX:+UseConcMarkSweepGC：即CMS收集，设置年老代为并发收集。CMS收集是JDK1.4后期版本开始引入的新GC算法。它的主要适合场景是对响应时间的重要性需求大于对吞吐量的需求，能够承受垃圾回收线程和应用线程共享CPU资源，并且应用中存在比较多的长生命周期对象。CMS收集的目标是尽量减少应用的暂停时间，减少Full GC发生的几率，利用和应用程序线程并发的垃圾回收线程来标记清除年老代内存。</li><li>-XX:+UseParNewGC：设置年轻代为并发收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此参数。</li><li>-XX:CMSFullGCsBeforeCompaction=0：由于并发收集器不对内存空间进行压缩和整理，所以运行一段时间并行收集以后会产生内存碎片，内存使用效率降低。此参数设置运行0次Full GC后对内存空间进行压缩和整理，即每次Full GC后立刻开始压缩和整理内存。</li><li>-XX:+UseCMSCompactAtFullCollection：打开内存空间的压缩和整理，在Full GC后执行。可能会影响性能，但可以消除内存碎片。</li><li>-XX:+CMSIncrementalMode：设置为增量收集模式。一般适用于单CPU情况。</li><li>-XX:CMSInitiatingOccupancyFraction=70：表示年老代内存空间使用到70%时就开始执行CMS收集，以确保年老代有足够的空间接纳来自年轻代的对象，避免Full GC的发生。</li><li>-XX:+ScavengeBeforeFullGC：年轻代GC优于Full GC执行。</li><li>-XX:+DisableExplicitGC：不响应 System.gc() 代码。</li><li>-XX:+UseThreadPriorities：启用本地线程优先级API。即使 java.lang.Thread.setPriority() 生效，不启用则无效。</li><li>-XX:SoftRefLRUPolicyMSPerMB=0：软引用对象在最后一次被访问后能存活0毫秒（JVM默认为1000毫秒）。</li><li>-XX:TargetSurvivorRatio=90：允许90%的Survivor区被占用（JVM默认为50%）。提高对于Survivor区的使用率。</li><li>-XX:+UseG1GC: 设置使用G1垃圾回收器（1.7以上JDK版本有效）</li><li>-XX:G1HeapRegionSize=n:设置g1 region大小，不设置的话自己会根据堆大小算，目标是根据最小堆内存划分2048个区域（1.7以上JDK版本有效）</li></ul><h3 id="JVM其它参数"><a href="#JVM其它参数" class="headerlink" title="JVM其它参数"></a>JVM其它参数</h3><ul><li>-XX:+CITime：打印消耗在JIT编译的时间。</li><li>-XX:ErrorFile=./hs_err_pid.log：保存错误日志或数据到指定文件中。</li><li>-XX:HeapDumpPath=./java_pid.hprof：指定Dump堆内存时的路径。</li><li>-XX:+HeapDumpOnOutOfMemoryError：当首次遭遇内存溢出时Dump出此时的堆内存。</li><li>-XX:OnError=”;”：出现致命ERROR后运行自定义命令。</li><li>-XX:OnOutOfMemoryError=”;”：当首次遭遇内存溢出时执行自定义命令。</li><li>-XX:+PrintClassHistogram：按下 Ctrl+Break 后打印堆内存中类实例的柱状信息，同JDK的 jmap -histo 命令。</li><li>-XX:+PrintConcurrentLocks：按下 Ctrl+Break 后打印线程栈中并发锁的相关信息，同JDK的 jstack -l 命令。</li><li>-XX:+PrintCompilation：当一个方法被编译时打印相关信息。</li><li>-XX:+PrintGC：每次GC时打印相关信息。</li><li>-XX:+PrintGCDetails：每次GC时打印详细信息。</li><li>-XX:+PrintGCTimeStamps：打印每次GC的时间戳。</li><li>-XX:+TraceClassLoading：跟踪类的加载信息。</li><li>-XX:+TraceClassLoadingPreorder：跟踪被引用到的所有类的加载信息。</li><li>-XX:+TraceClassResolution：跟踪常量池。</li><li>-XX:+TraceClassUnloading：跟踪类的卸载信息。</li><li>-client：设置JVM使用Client模式，特点是启动速度比较快，但运行时性能和内存管理效率不高，通常用于客户端应用程序或开发调试；在32位环境下直接运行Java程序默认启用该模式。</li><li>-server：设置JVM使Server模式，特点是启动速度比较慢，但运行时性能和内存管理效率很高，适用于生产环境。在具有64位能力的JDK环境下默认启用该模式。</li></ul><p>PS：关于参数名称定义如下。</p><pre><code>标准参数（-），所有JVM都必须支持这些参数的功能，而且向后兼容；
非标准参数（-X），默认JVM实现这些参数的功能，但是并不保证所有JVM实现都满足，且不保证向后兼容；
非稳定参数（-XX），此类参数各个JVM实现会有所不同，将来可能会不被支持，需要慎重使用；
</code></pre><p>参考：<a href="https://blog.csdn.net/kthq/article/details/8618052" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/kthq/article/details/8618052</a></p><h2 id="各个区域的OOM"><a href="#各个区域的OOM" class="headerlink" title="各个区域的OOM"></a>各个区域的OOM</h2><p>我们来看下JVM各个区域的OOM。</p><p><strong>堆的OOM</strong></p><p>我们创建如下类，进行测试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">oomTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">		List&lt;JvmTest&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">				list.add(<span class="keyword">new</span> JvmTest());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;  </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> JvmTest().oomTest();</span><br><span class="line">	&#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后可以看到抛出如下异常：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-423.png" alt="upload successful"></p><p>这也是非常常见的一种OOM异常。出现的原因可能是创建了大量大对象、一些流未及时关闭等，导致堆内存溢出。</p><p>出现这种情况，必须考虑程序的优化解决方法。而不是单纯的通过-Xmn参数增大内存来解决。</p><p><strong>栈的OOM</strong></p><p>当栈深度超过虚拟机分配给线程的栈大小时，就会出现栈的溢出异常。</p><p>我们创建测试类，来看一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">stackOverTest</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> stackOverTest(n-<span class="number">1</span>)+<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> JvmTest().stackOverTest(<span class="number">200000</span>);</span><br><span class="line">	&#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后可以看到如下异常：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-424.png" alt="upload successful"></p><p>这种异常一般是调用递归或者死循环等产生的，导致栈深度超过虚拟机分配给线程的栈大小。</p><p>当然可以通过-Xss参数控制每个线程的栈大小来解决，但通常情况下，应检查程序，减少递归的使用。</p><p><strong>关于Metaspace与PermGen（永久代）</strong></p><p>JDK1.8移除了PermGen（永久代），取而代之的是Metaspace（元空间），元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。</p><p>我们在JDK1.8环境下，设置Metaspace的大小，进行测试。(-XX:MetaspaceSize=5M -XX:MaxMetaspaceSize=5M)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MetaSpaceOOMTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">			enhancer.setSuperclass(JvmTest.class);</span><br><span class="line">			enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">			enhancer.setCallback(</span><br><span class="line">					<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">						<span class="meta">@Override</span></span><br><span class="line">						<span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">							<span class="keyword">return</span> methodProxy.invokeSuper(o,objects);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">			);</span><br><span class="line">			enhancer.create();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> JvmTest().MetaSpaceOOMTest();</span><br><span class="line">	&#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后可以看到如下异常：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-425.png" alt="upload successful"></p><p>这种问题出现较少，如果出现一般为动态代理生成大量class类引起的问题。</p><p>我们在JDK1.6环境下，设置PermGen（永久代）大小，进行测试。（-XX:PermSize=10m -XX:MaxPermSize=10m）</p><p>测试方法同上。</p><p>可以看到日志输出如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-426.png" alt="upload successful"></p><p>由于项目大多数JDK版本都在8及以上，故这种OOM异常已经很少在见到了。</p><h2 id="JVM-日志"><a href="#JVM-日志" class="headerlink" title="JVM 日志"></a>JVM 日志</h2><p>我们再来看下JVM的垃圾回收日志，并简单解读下。我们这儿主要来看新的JVM（1.8及其后）的GC日志。</p><p>我们在运行时添加如下参数： -XX:-PrintGCDetails</p><p>我们用上面的 JvmTest类里的oomTest方法来进行测试。</p><p>可以看到如下一些GC运行日志和OOM的dump日志。</p><p>我们先来看下GC的运行日志部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 207268K-&gt;200192K(339968K)] 879015K-&gt;879170K(1489408K), 0.8137540 secs] [Times: user=2.95 sys=0.06, real=0.81 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 339968K-&gt;243200K(339456K)] 1292739K-&gt;1292955K(1488896K), 0.8972164 secs] [Times: user=3.18 sys=0.20, real=0.90 secs] </span><br><span class="line">[Full GC (Ergonomics) [PSYoungGen: 243200K-&gt;0K(339456K)] [ParOldGen: 1049755K-&gt;1110054K(1722880K)] 1292955K-&gt;1110054K(2062336K), [Metaspace: 3502K-&gt;3502K(1056768K)], 7.8097561 secs] [Times: user=16.27 sys=0.19, real=7.81 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 96256K-&gt;96384K(424448K)] 1206310K-&gt;1206438K(2147328K), 0.3838048 secs] [Times: user=1.39 sys=0.05, real=0.38 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 192640K-&gt;192672K(425472K)] 1302694K-&gt;1302726K(2148352K), 0.6567791 secs] [Times: user=2.53 sys=0.00, real=0.66 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 303776K-&gt;303840K(430080K)] 1824520K-&gt;1824584K(2152960K), 1.1635894 secs] [Times: user=4.29 sys=0.00, real=1.16 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 414944K-&gt;347136K(496640K)] 1935688K-&gt;1935808K(2219520K), 1.6472200 secs] [Times: user=5.76 sys=0.19, real=1.65 secs] </span><br><span class="line">[Full GC (Ergonomics) [PSYoungGen: 347136K-&gt;0K(496640K)] [ParOldGen: 1588672K-&gt;1661667K(2083840K)] 1935808K-&gt;1661667K(2580480K), [Metaspace: 3502K-&gt;3502K(1056768K)], 10.5294207 secs] [Times: user=23.63 sys=0.09, real=10.53 secs]</span><br></pre></td></tr></table></figure><ul><li><p>(Allocation Failure)：Allocation Failure表示向young generation(eden)给新对象申请空间，但是young generation(eden)剩余的合适空间不够所需的大小导致的GC。</p></li><li><p>[PSYoungGen: 207268K-&gt;200192K(339968K)] 879015K-&gt;879170K(1489408K), 0.8137540 secs] 这段分别表示 [年轻代: GC前内存容量 -&gt; GC后内存容量 (年轻代总容量)] GC前堆内存大小 -&gt; GC后堆内存大小(堆内存总大小),该内存区域GC耗时（与Times的real相等），单位是秒。</p></li><li><p>[Times: user=2.95 sys=0.06, real=0.81 secs] 这段分别表示用户态耗时，内核态耗时和总耗时。</p></li><li><p>Full GC (Ergonomics) 表明该次发生了Full GC，Ergonomics就是Full GC的原因，可以认为如果晋升到老生代的平均大小大于老生代的剩余大小，则认为需要一次full gc。某些垃圾回收器会负责自动的调解gc暂停时间和吞吐量之间的平衡，然后JVM虚拟机性能更好，因而会出现这种Full GC原因。</p></li><li><p>ParOldGen部分表示年老代的相关GC信息。</p></li><li><p>Metaspace部分表示元空间的相关GC信息。</p></li></ul><p>我们在GC相关源码(openjdk源码中gcCause.cpp文件)中还可以看到多种GC原因，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"precompiled.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"gc/shared/gcCause.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* GCCause::to_string(GCCause::Cause cause) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (cause) &#123;</span><br><span class="line">    <span class="keyword">case</span> _java_lang_system_gc:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"System.gc()"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _full_gc_alot:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"FullGCAlot"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _scavenge_alot:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"ScavengeAlot"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _allocation_profiler:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Allocation Profiler"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _jvmti_force_gc:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"JvmtiEnv ForceGarbageCollection"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _gc_locker:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"GCLocker Initiated GC"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _heap_inspection:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Heap Inspection Initiated GC"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _heap_dump:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Heap Dump Initiated GC"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _wb_young_gc:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"WhiteBox Initiated Young GC"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _wb_conc_mark:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"WhiteBox Initiated Concurrent Mark"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _wb_full_gc:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"WhiteBox Initiated Full GC"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _update_allocation_context_stats_inc:</span><br><span class="line">    <span class="keyword">case</span> _update_allocation_context_stats_full:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Update Allocation Context Stats"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _no_gc:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"No GC"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _allocation_failure:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Allocation Failure"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _tenured_generation_full:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Tenured Generation Full"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _metadata_GC_threshold:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Metadata GC Threshold"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _metadata_GC_clear_soft_refs:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Metadata GC Clear Soft References"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _cms_generation_full:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"CMS Generation Full"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _cms_initial_mark:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"CMS Initial Mark"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _cms_final_remark:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"CMS Final Remark"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _cms_concurrent_mark:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"CMS Concurrent Mark"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _old_generation_expanded_on_last_scavenge:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Old Generation Expanded On Last Scavenge"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _old_generation_too_full_to_scavenge:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Old Generation Too Full To Scavenge"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _adaptive_size_policy:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Ergonomics"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _g1_inc_collection_pause:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"G1 Evacuation Pause"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _g1_humongous_allocation:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"G1 Humongous Allocation"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _dcmd_gc_run:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Diagnostic Command"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _last_gc_cause:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"ILLEGAL VALUE - last gc cause - ILLEGAL VALUE"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"unknown GCCause"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ShouldNotReachHere();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这儿就不在对上面的所有GC情况做详细介绍了，有兴趣的同学可以查阅相关资料了解。</p><p>gcCause相关资料：</p><ul><li><a href="http://hg.openjdk.java.net/jdk8u/hs-dev/hotspot/file/tip/src/share/vm/gc_interface/gcCause.cpp" rel="external nofollow noopener noreferrer" target="_blank">openjdk-gcCause.cpp</a></li><li><a href="http://netflix.github.io/spectator/en/latest/ext/jvm-gc-causes/" rel="external nofollow noopener noreferrer" target="_blank">jvm-gcCause-info</a></li></ul><p>我们再来看下出现OOM后GC的dump日志部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 584192K, used 10301K [0x0000000780700000, 0x00000007ba880000, 0x00000007c0000000)</span><br><span class="line">  eden space 257536K, 3% used [0x0000000780700000,0x000000078110f510,0x0000000790280000)</span><br><span class="line">  from space 326656K, 0% used [0x00000007a6980000,0x00000007a6980000,0x00000007ba880000)</span><br><span class="line">  to   space 347136K, 0% used [0x0000000790280000,0x0000000790280000,0x00000007a5580000)</span><br><span class="line"> ParOldGen       total 2083840K, used 2054113K [0x0000000701400000, 0x0000000780700000, 0x0000000780700000)</span><br><span class="line">  object space 2083840K, 98% used [0x0000000701400000,0x000000077e9f8790,0x0000000780700000)</span><br><span class="line"> Metaspace       used 3535K, capacity 4506K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 392K, capacity 394K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure><p>它们打印的JVM终止时Heap（堆内存）的信息，从该日志中我们能分析出JVM终止的一些原因。</p><p>可以看到PSYoungGen（年轻代） eden区使用了3%，（两个Survivor）from和to区使用了0%，ParOldGen（年老代） object space（对象区）使用了98%，Metaspace（元空间） class space（类加载区）的使用情况。</p><p>因此明显由于创建了大量对象，一直存在，无法被垃圾回收，导致内存空间用尽，出现OOM异常。</p><h2 id="JVM监控Demo"><a href="#JVM监控Demo" class="headerlink" title="JVM监控Demo"></a>JVM监控Demo</h2><p>现在有许多JVM监控工具，如JConsole、Java VisualVM等，我们这里不过多介绍。</p><p>我们自写一个监控Demo来看下JVM在内存使用过程中的一些变化特点。</p><p>来看下<code>java.lang.management</code>包下的一些类。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-427.png" alt="upload successful"></p><ul><li>MemoryMXBean ： 它里面有两个方法 <code>getHeapMemoryUsage</code> （获取堆内存使用情况）和<code>getNonHeapMemoryUsage</code>（获取非堆内存使用情况），返回<code>MemoryUsage</code>对象。</li><li>MemoryUsage：包含<code>init</code>（初始化了多少内存）、<code>used</code>（使用了多少内存）、<code>committed</code>（申请了多少内存）、<code>max</code>（最大内存）信息。</li><li>MemoryPoolMXBean：这里包含young（eden和survivor）、old等内存区的使用情况，我们可以通过 <code>ManagementFactory.getMemoryPoolMXBeans()</code> 获取到一个 <code>MemoryPoolMXBean</code> 列表，<code>MemoryPoolMXBean</code>里还有一个<code>getName</code>方法可以获得当前区域的名称。</li><li>GarbageCollectorMXBean：这个是垃圾收集相关的Bean，可以通过<code>ManagementFactory.getGarbageCollectorMXBeans()</code>获取其列表。其<code>getName</code>方法可以获得垃圾收集器的名称，<code>getCollectionCount</code>可以获得当前已经进行了多少次垃圾收集，<code>getCollectionTime</code>返回垃圾收集时间。</li></ul><p>我们写一个测试类来看一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JVMMonitorMemoryTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定时任务线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ScheduledExecutorService executorService = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> ScheduledFuture future = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> JvmTest jvmTest = <span class="keyword">new</span> JvmTest();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doMonitor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        future = executorService.scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="line">            JSONObject jsonObject = <span class="keyword">new</span> JSONObject();</span><br><span class="line">            MemoryMXBean memoryMXBean = ManagementFactory.getMemoryMXBean();</span><br><span class="line">            jsonObject.put(<span class="string">"totalMaxMemery"</span>, memoryMXBean.getHeapMemoryUsage().getMax()&gt;&gt;<span class="number">10</span>&gt;&gt;<span class="number">10</span>);</span><br><span class="line">            jsonObject.put(<span class="string">"totalUsedMemery"</span>, memoryMXBean.getHeapMemoryUsage().getUsed()&gt;&gt;<span class="number">10</span>&gt;&gt;<span class="number">10</span>);</span><br><span class="line">            jsonObject.put(<span class="string">"totalInitMemery"</span>, memoryMXBean.getHeapMemoryUsage().getInit()&gt;&gt;<span class="number">10</span>&gt;&gt;<span class="number">10</span>);</span><br><span class="line">            <span class="comment">//这里会返回老年代，新生代等内存区的使用情况</span></span><br><span class="line">            List&lt;MemoryPoolMXBean&gt; memoryPoolMXBeans = ManagementFactory.getMemoryPoolMXBeans();</span><br><span class="line">            memoryPoolMXBeans.forEach((pool) -&gt; &#123;</span><br><span class="line">                String poolName = pool.getName().trim();</span><br><span class="line">                <span class="keyword">long</span> max = pool.getUsage().getMax()&gt;&gt;<span class="number">10</span>&gt;&gt;<span class="number">10</span>;</span><br><span class="line">                <span class="keyword">long</span> used = pool.getUsage().getUsed()&gt;&gt;<span class="number">10</span>&gt;&gt;<span class="number">10</span>;</span><br><span class="line">                <span class="keyword">long</span> init = pool.getUsage().getInit()&gt;&gt;<span class="number">10</span>&gt;&gt;<span class="number">10</span>;</span><br><span class="line">                <span class="keyword">long</span> maxPeak = pool.getPeakUsage().getMax()&gt;&gt;<span class="number">10</span>&gt;&gt;<span class="number">10</span>;</span><br><span class="line">                <span class="keyword">long</span> usedPeak = pool.getPeakUsage().getUsed()&gt;&gt;<span class="number">10</span>&gt;&gt;<span class="number">10</span>;</span><br><span class="line">                <span class="keyword">long</span> initPeak = pool.getPeakUsage().getInit()&gt;&gt;<span class="number">10</span>&gt;&gt;<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">                JSONObject poolJSON = <span class="keyword">new</span> JSONObject();</span><br><span class="line">                poolJSON.put(<span class="string">"max"</span>, max);</span><br><span class="line">                poolJSON.put(<span class="string">"used"</span>, used);</span><br><span class="line">                poolJSON.put(<span class="string">"init"</span>, init);</span><br><span class="line">                poolJSON.put(<span class="string">"maxPeak"</span>, maxPeak);</span><br><span class="line">                poolJSON.put(<span class="string">"usedPeak"</span>, usedPeak);</span><br><span class="line">                poolJSON.put(<span class="string">"initPeak"</span>, initPeak);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(<span class="string">"PS Eden Space"</span>.equalsIgnoreCase(poolName))&#123;</span><br><span class="line">                    jsonObject.put(<span class="string">"eden"</span>, poolJSON);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"PS Survivor Space"</span>.equalsIgnoreCase(poolName))&#123;</span><br><span class="line">                    jsonObject.put(<span class="string">"survivor"</span>, poolJSON);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"PS Old Gen"</span>.equalsIgnoreCase(poolName))&#123;</span><br><span class="line">                    jsonObject.put(<span class="string">"old"</span>, poolJSON);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"Metaspace"</span>.equalsIgnoreCase(poolName))&#123;</span><br><span class="line">                    jsonObject.put(<span class="string">"metaspace"</span>,poolJSON);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//垃圾收集相关</span></span><br><span class="line">            List&lt;GarbageCollectorMXBean&gt; garbageCollectorMXBeans = ManagementFactory.getGarbageCollectorMXBeans();</span><br><span class="line">            garbageCollectorMXBeans.forEach(collector -&gt; &#123;</span><br><span class="line">                String gcName = collector.getName();</span><br><span class="line">                <span class="keyword">long</span> gcCount = collector.getCollectionCount();</span><br><span class="line">                <span class="keyword">long</span> gcTime = collector.getCollectionTime();</span><br><span class="line">                JSONObject gcJSON = <span class="keyword">new</span> JSONObject();</span><br><span class="line">                gcJSON.put(<span class="string">"gcCount"</span>, gcCount);</span><br><span class="line">                gcJSON.put(<span class="string">"gcTime"</span>, gcTime);</span><br><span class="line">                <span class="keyword">if</span>(gcName.toLowerCase().contains(<span class="string">"scavenge"</span>))&#123;</span><br><span class="line">                    jsonObject.put(<span class="string">"edenGc"</span>, gcJSON);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(gcName.toLowerCase().contains(<span class="string">"marksweep"</span>))&#123;</span><br><span class="line">                    jsonObject.put(<span class="string">"oldGc"</span>, gcJSON);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            System.out.println(JSON.toJSONString(jsonObject));</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用生成对象的方法</span></span><br><span class="line">        jvmTest.test();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JVMMonitorMemoryTest jvmMonitorMemoryTest = <span class="keyword">new</span> JVMMonitorMemoryTest();</span><br><span class="line">        jvmMonitorMemoryTest.doMonitor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个方法不停生产对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmTest</span> </span>&#123;</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		List&lt;JvmTest&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">				list.add(<span class="keyword">new</span> JvmTest());</span><br><span class="line">				<span class="keyword">if</span>(list.size()&gt;<span class="number">10000</span>)&#123;</span><br><span class="line">					list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">					TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">		    e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们运行后可以看到相关输出信息，即JVM堆内存变化情况及垃圾收集情况。</p><p>数字数据不是很直观，我们结合Echart图表，动态展示JVM相关信息，因此我们把项目改造下，结合WebSocket来实现。</p><p>项目大致结构如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-428.png" alt="upload successful"></p><p>说一下里面的关键部分，MonitorJVMMemory.java（监控JVM内存变化类）和jvm-echart.js（Echart前端动态展示）。</p><p>MonitorJVMMemory相关代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ServerEndpoint</span>(<span class="string">"/websocket/jvm/monitor"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorJVMMemory</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(MonitorJVMMemory.class);</span><br><span class="line">    <span class="comment">//定时任务线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ScheduledExecutorService executorService = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> ScheduledFuture future = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> JvmTest jvmTest = <span class="keyword">new</span> JvmTest();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * websocket会话</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Session session;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.session = session;</span><br><span class="line">        future = executorService.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            JSONObject jsonObject = <span class="keyword">new</span> JSONObject();</span><br><span class="line">            MemoryMXBean memoryMXBean = ManagementFactory.getMemoryMXBean();</span><br><span class="line">            jsonObject.put(<span class="string">"totalMaxMemery"</span>, memoryMXBean.getHeapMemoryUsage().getMax() &gt;&gt; <span class="number">10</span> &gt;&gt; <span class="number">10</span>);</span><br><span class="line">            jsonObject.put(<span class="string">"totalUsedMemery"</span>, memoryMXBean.getHeapMemoryUsage().getUsed() &gt;&gt; <span class="number">10</span> &gt;&gt; <span class="number">10</span>);</span><br><span class="line">            jsonObject.put(<span class="string">"totalInitMemery"</span>, memoryMXBean.getHeapMemoryUsage().getInit() &gt;&gt; <span class="number">10</span> &gt;&gt; <span class="number">10</span>);</span><br><span class="line">            <span class="comment">//这里会返回老年代，新生代等内存区的使用情况，按需自取就好</span></span><br><span class="line">            List&lt;MemoryPoolMXBean&gt; memoryPoolMXBeans = ManagementFactory.getMemoryPoolMXBeans();</span><br><span class="line">            memoryPoolMXBeans.forEach((pool) -&gt; &#123;</span><br><span class="line">                String poolName = pool.getName().trim();</span><br><span class="line">                <span class="keyword">long</span> max = pool.getUsage().getMax() &gt;&gt; <span class="number">10</span> &gt;&gt; <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">long</span> used = pool.getUsage().getUsed() &gt;&gt; <span class="number">10</span> &gt;&gt; <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">long</span> init = pool.getUsage().getInit() &gt;&gt; <span class="number">10</span> &gt;&gt; <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">long</span> maxPeak = pool.getPeakUsage().getMax() &gt;&gt; <span class="number">10</span> &gt;&gt; <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">long</span> usedPeak = pool.getPeakUsage().getUsed() &gt;&gt; <span class="number">10</span> &gt;&gt; <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">long</span> initPeak = pool.getPeakUsage().getInit() &gt;&gt; <span class="number">10</span> &gt;&gt; <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">                JSONObject poolJSON = <span class="keyword">new</span> JSONObject();</span><br><span class="line">                poolJSON.put(<span class="string">"max"</span>, max);</span><br><span class="line">                poolJSON.put(<span class="string">"used"</span>, used);</span><br><span class="line">                poolJSON.put(<span class="string">"init"</span>, init);</span><br><span class="line">                poolJSON.put(<span class="string">"maxPeak"</span>, maxPeak);</span><br><span class="line">                poolJSON.put(<span class="string">"usedPeak"</span>, usedPeak);</span><br><span class="line">                poolJSON.put(<span class="string">"initPeak"</span>, initPeak);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"PS Eden Space"</span>.equalsIgnoreCase(poolName)) &#123;</span><br><span class="line">                    jsonObject.put(<span class="string">"eden"</span>, poolJSON);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"PS Survivor Space"</span>.equalsIgnoreCase(poolName)) &#123;</span><br><span class="line">                    jsonObject.put(<span class="string">"survivor"</span>, poolJSON);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"PS Old Gen"</span>.equalsIgnoreCase(poolName)) &#123;</span><br><span class="line">                    jsonObject.put(<span class="string">"old"</span>, poolJSON);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//垃圾收集</span></span><br><span class="line">            List&lt;GarbageCollectorMXBean&gt; garbageCollectorMXBeans = ManagementFactory.getGarbageCollectorMXBeans();</span><br><span class="line">            garbageCollectorMXBeans.forEach(collector -&gt; &#123;</span><br><span class="line">                String gcName = collector.getName();</span><br><span class="line">                <span class="keyword">long</span> gcCount = collector.getCollectionCount();</span><br><span class="line">                <span class="keyword">long</span> gcTime = collector.getCollectionTime();</span><br><span class="line">                JSONObject gcJSON = <span class="keyword">new</span> JSONObject();</span><br><span class="line">                gcJSON.put(<span class="string">"gcCount"</span>, gcCount);</span><br><span class="line">                gcJSON.put(<span class="string">"gcTime"</span>, gcTime);</span><br><span class="line">                <span class="keyword">if</span> (gcName.toLowerCase().contains(<span class="string">"scavenge"</span>)) &#123;</span><br><span class="line">                    jsonObject.put(<span class="string">"edenGc"</span>, gcJSON);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (gcName.toLowerCase().contains(<span class="string">"marksweep"</span>)) &#123;</span><br><span class="line">                    jsonObject.put(<span class="string">"oldGc"</span>, gcJSON);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                session.getBasicRemote().sendText(jsonObject.toJSONString());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        jvmTest.test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acceptMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"Accept&gt;&gt;&gt;"</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭会话</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeSession</span><span class="params">(CloseReason closeReason)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.destory();</span><br><span class="line">        logger.info(closeReason.getReasonPhrase());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnError</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">errorHandler</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.destory();</span><br><span class="line">        logger.info(<span class="string">"MonitorJVMMemory websocket error ："</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (future != <span class="keyword">null</span> &amp;&amp; !future.isCancelled()) &#123;</span><br><span class="line">                future.cancel(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">                session.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">"destory"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent servletContextEvent)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent servletContextEvent)</span> </span>&#123;</span><br><span class="line">        jvmTest.stop();</span><br><span class="line">        executorService.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们使用了Websocket，当连接Open后，使用定长线程池，里面维护一个每隔1s调用一次的方法，来查看当前内存情况，并使用<code>jvmTest.test()</code>来生成测试对象。</p><p>线程池里运行的线程执行的就是我们上面JVMMonitorMemoryTest类的doMonitor方法。</p><p>再看下jvm-echart.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//echart</span></span><br><span class="line"><span class="keyword">var</span> memoryEchart = echarts.init(<span class="built_in">document</span>.getElementById(<span class="string">'memory_main'</span>));</span><br><span class="line"><span class="keyword">var</span> memoryData = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//定义图表样式</span></span><br><span class="line"><span class="keyword">var</span> memoryOption = &#123;</span><br><span class="line">    tooltip : &#123;</span><br><span class="line">        trigger: <span class="string">'axis'</span>,</span><br><span class="line">        axisPointer : &#123;            <span class="comment">// 坐标轴指示器，坐标轴触发有效</span></span><br><span class="line">            type : <span class="string">'shadow'</span>        <span class="comment">// 默认为直线，可选为：'line' | 'shadow'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        formatter: <span class="function"><span class="keyword">function</span> (<span class="params">params</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> dataIndex = params[<span class="number">0</span>].dataIndex;</span><br><span class="line">            <span class="keyword">var</span> res = params[<span class="number">0</span>].axisValue;</span><br><span class="line">            <span class="keyword">if</span>(dataIndex==<span class="number">0</span> || dataIndex==<span class="number">1</span>)&#123;</span><br><span class="line">                res += <span class="string">'&lt;br/&gt;累计回收次数：'</span> + params[<span class="number">0</span>].data;</span><br><span class="line">                res += <span class="string">'&lt;br/&gt;累计回收时间：'</span> + params[<span class="number">1</span>].data + <span class="string">"ms"</span>;</span><br><span class="line">                res += <span class="string">'&lt;br/&gt;平均回收时间：'</span> + <span class="built_in">parseInt</span>(params[<span class="number">1</span>].data/params[<span class="number">0</span>].data) + <span class="string">"ms"</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res += <span class="string">'&lt;br/&gt;已用内存量：'</span> + params[<span class="number">0</span>].data + <span class="string">"MB"</span>;</span><br><span class="line">                <span class="keyword">if</span>(params[<span class="number">0</span>].axisValue!=<span class="string">'峰值内存消耗'</span>)&#123;</span><br><span class="line">                    <span class="keyword">var</span> maxData = memoryData[<span class="number">2</span>];</span><br><span class="line">                    res += <span class="string">'&lt;br/&gt;可用内存量：'</span> + params[<span class="number">1</span>].data + <span class="string">"MB"</span>;</span><br><span class="line">                    res += <span class="string">'&lt;br/&gt;最大内存量：'</span> + maxData[dataIndex] + <span class="string">"MB"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    color: [<span class="string">'#ff0000'</span>,<span class="string">'#91C7AE'</span>],</span><br><span class="line">    legend: &#123;</span><br><span class="line">        data: [<span class="string">'已用内存(MB)'</span>, <span class="string">'可用内存(MB)'</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    grid: &#123;</span><br><span class="line">        left: <span class="string">'3%'</span>,</span><br><span class="line">        right: <span class="string">'4%'</span>,</span><br><span class="line">        bottom: <span class="string">'3%'</span>,</span><br><span class="line">        containLabel: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    xAxis:  &#123;</span><br><span class="line">        type: <span class="string">'value'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    yAxis: &#123;</span><br><span class="line">        type: <span class="string">'category'</span>,</span><br><span class="line">        data: [<span class="string">'OldGenGC'</span>,<span class="string">'EdenGC'</span>,<span class="string">'Old Gen'</span>,<span class="string">'Survivor Space'</span>,<span class="string">'Eden Space'</span>,<span class="string">'峰值内存消耗'</span>,<span class="string">'JVM总内存'</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    series: [</span><br><span class="line">        &#123;</span><br><span class="line">            name: <span class="string">'已用内存(MB)'</span>,</span><br><span class="line">            type: <span class="string">'bar'</span>,</span><br><span class="line">            stack: <span class="string">'总量'</span>,</span><br><span class="line">            barWidth: <span class="number">60</span>,</span><br><span class="line">            label: &#123;</span><br><span class="line">                normal: &#123;</span><br><span class="line">                    show: <span class="literal">true</span>,</span><br><span class="line">                    position: <span class="string">'insideRight'</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            data: memoryData[<span class="number">0</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            name: <span class="string">'可用内存(MB)'</span>,</span><br><span class="line">            type: <span class="string">'bar'</span>,</span><br><span class="line">            stack: <span class="string">'总量'</span>,</span><br><span class="line">            barWidth: <span class="number">60</span>,</span><br><span class="line">            label: &#123;</span><br><span class="line">                normal: &#123;</span><br><span class="line">                    show: <span class="literal">true</span>,</span><br><span class="line">                    position: <span class="string">'insideRight'</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            data: memoryData[<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">memoryEchart.setOption(memoryOption);</span><br><span class="line"></span><br><span class="line"><span class="comment">//刷新图表数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">refreshMemoryData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    memoryEchart.setOption(&#123;</span><br><span class="line">        series: [&#123;</span><br><span class="line">            data: memoryData[<span class="number">0</span>]</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            data: memoryData[<span class="number">1</span>]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与websocket建立连接</span></span><br><span class="line"><span class="keyword">var</span> memorySocket;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initMemorySocket</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(memorySocket!=<span class="literal">undefined</span> || memorySocket!=<span class="literal">null</span>)&#123;</span><br><span class="line">        memorySocket.close(<span class="string">"3000"</span>, <span class="string">"断开连接"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> wsUrl = <span class="string">'ws://'</span>+$(<span class="string">'#hid_host'</span>).val()+<span class="string">'/websocket/jvm/monitor'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(wsUrl);</span><br><span class="line">    memorySocket = <span class="keyword">new</span> WebSocket(wsUrl);</span><br><span class="line">    memorySocket.onopen = <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Connection the jvm monitor server success!!!"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    memorySocket.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> memory = $.parseJSON(evt.data);</span><br><span class="line">        <span class="keyword">var</span> peakUsed = memory.old.usedPeak + memory.eden.usedPeak;</span><br><span class="line">        <span class="keyword">var</span> usedData = [memory.oldGc.gcCount, memory.edenGc.gcCount, memory.old.used, memory.survivor.used, memory.eden.used, peakUsed, memory.totalUsedMemery];</span><br><span class="line">        <span class="keyword">var</span> peakMax = <span class="built_in">parseInt</span>((memory.old.maxPeak + memory.eden.maxPeak)*<span class="number">0.8</span>);</span><br><span class="line">        <span class="keyword">var</span> usable = [memory.oldGc.gcTime, memory.edenGc.gcTime, memory.old.max-memory.old.used,</span><br><span class="line">            memory.survivor.max-memory.survivor.used, memory.eden.max-memory.eden.used, <span class="number">0</span>, memory.totalMaxMemery-memory.totalUsedMemery];</span><br><span class="line">        <span class="keyword">var</span> maxData = [memory.oldGc.gcTime, memory.edenGc.gcTime, memory.old.max, memory.survivor.max, memory.eden.max, <span class="number">0</span>, memory.totalMaxMemery];</span><br><span class="line">        memoryData[<span class="number">0</span>] = usedData;</span><br><span class="line">        memoryData[<span class="number">1</span>] = usable;</span><br><span class="line">        memoryData[<span class="number">2</span>] = maxData;</span><br><span class="line">        refreshMemoryData();</span><br><span class="line">    &#125;;</span><br><span class="line">    memorySocket.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123;</span><br><span class="line">        memorySocket.close();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//断开监控连接</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">closeMemoryMonitor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(memorySocket!=<span class="literal">undefined</span> || memorySocket!=<span class="literal">null</span>)&#123;</span><br><span class="line">        memorySocket.close(<span class="string">"3000"</span>, <span class="string">"断开连接"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    memoryData[<span class="number">0</span>] = [];</span><br><span class="line">    memoryData[<span class="number">1</span>] = [];</span><br><span class="line">    memoryData[<span class="number">2</span>] = [];</span><br><span class="line">    refreshMemoryData();</span><br><span class="line">    $.messager.show(&#123; <span class="attr">title</span>: <span class="string">'系统提示'</span>, <span class="attr">msg</span>: <span class="string">'已断开监控连接！'</span>&#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Disconnect the jvm monitor server success!!!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    initMemorySocket();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个就是在解析后台数据构造Echart图表，这儿就不详细介绍了。</p><p>详细源码可以在 <a href="https://github.com/JavaZWT/framework-base/tree/master/jvm-monitor-memory" rel="external nofollow noopener noreferrer" target="_blank">jvm-monitor-memory</a> 看到。</p><p>我们可以简单看下运行效果图，可以看到JVM进行垃圾回收后内存的变化情况。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-428.gif" alt="upload successful"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过这篇文章，我们了解了JVM垃圾回收的一些运行原理，对JVM堆内存有了更深入的认识。了解虚拟机内存及垃圾回收的一些特性，有助于我们在工作过程中排查定位问题。</p></div><div><div style="text-align:center;color:#ccc;font-size:15px"><br><br><br> -------------文章结束啦 ~\(≧▽≦)/~ 感谢您的阅读-------------</div><br></div><div><div id="wechat_subscriber" style="display:block;padding:10px 0;margin:20px auto;width:100%;text-align:center"> <img id="wechat_subscriber_qcode" src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/others/qrcode_wechat_subscriber.jpg" alt="SakuraTears wechat" style="width:200px;max-width:100%"><div>扫一扫关注我的公众号</div></div></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>您的支持就是我创作的动力！</div> <button id="rewardButton" disable="enable" onclick='var qr=document.getElementById("QR");"none"===qr.style.display?qr.style.display="block":qr.style.display="none"'> <span>打赏</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"> <img id="wechat_qr" src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/others/wechatpay.png" alt="SakuraTears 微信支付"><p>微信支付</p></div><div id="alipay" style="display:inline-block"> <img id="alipay_qr" src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/others/alipay.jpg" alt="SakuraTears 支付宝"><p>支付宝</p></div></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> SakuraTears</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.sakuratears.top/blog/JVM堆内存及垃圾回收简介.html" title="JVM堆内存及垃圾回收简介">https://www.sakuratears.top/blog/JVM堆内存及垃圾回收简介.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow noopener noreferrer" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a><a href="/tags/JVM/" rel="tag"><i class="fa fa-tag"></i> JVM</a><a href="/tags/GC/" rel="tag"><i class="fa fa-tag"></i> GC</a></div><div class="post-widgets"><div class="wp_rating"><div style="color:rgba(0,0,0,.75);font-size:16px;letter-spacing:8px">(&gt;来评分吧&lt;)</div><div id="wpac-rating"></div></div></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/blog/Spring-Lookup注解.html" rel="next" title="Spring Lookup注解"><i class="fa fa-chevron-left"></i> Spring Lookup注解</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"> <a href="/blog/（转）分布式系统下的CAP理论.html" rel="prev" title="（转）分布式系统下的CAP理论">（转）分布式系统下的CAP理论<i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap"> 站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/others/avatar.jpg" alt="SakuraTears"><p class="site-author-name" itemprop="name">SakuraTears</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">128</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/index.html"><span class="site-state-item-count">3</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/index.html"><span class="site-state-item-count">93</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/JavaZWT" target="_blank" title="GitHub" rel="external nofollow noopener noreferrer"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:971258230@qq.com" target="_blank" title="Email" rel="external nofollow noopener noreferrer"><i class="fa fa-fw fa-envelope"></i> Email</a></span><span class="links-of-author-item"><a href="http://wpa.qq.com/msgrd?v=3&uin=971258230&site=qq&menu=yes" target="_blank" title="QQ" rel="external nofollow noopener noreferrer"><i class="fa fa-fw fa-qq"></i> QQ</a></span><span class="links-of-author-item"><a href="https://blog.csdn.net/JavaZWT" target="_blank" title="CSDN" rel="external nofollow noopener noreferrer"><i class="fa fa-fw fa-copyright"></i> CSDN</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title" style="color:#fc6423"><i class="fa fa-fw fa-link"></i> 友情链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="https://www.sakuratears.top" title="SakuraTears的小乖乖" target="_blank">SakuraTears的小乖乖</a></li><li class="links-of-blogroll-item"> <a href="http://jm.taobao.org/" title="阿里巴巴中间件团队博客" target="_blank" rel="external nofollow noopener noreferrer">阿里巴巴中间件团队博客</a></li><li class="links-of-blogroll-item"> <a href="https://blog.ymfe.org/" title="去哪儿网大前端技术博客" target="_blank" rel="external nofollow noopener noreferrer">去哪儿网大前端技术博客</a></li></ul></div><div class="links-of-blogroll motion-element links-of-blogroll-inline" style="opacity:1;display:block;transform:translateX(0);margin-top:8px"></div><div id="aplayer-rWUYQYrx" class="aplayer aplayer-tag-marker" style="margin:30px 0 30px 0"></div><script>var options={narrow:!1,autoplay:!1,showlrc:0,mutex:!0,theme:"#e6d0b2",preload:"none",listmaxheight:"500px",music:[{title:"Sakura Tears",author:"Nigel Silin",url:"http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/Nigel%20Silin%20-%20Sakura%20Tears.mp3",pic:"http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/music1.jpeg"},{title:"东京不太热",author:"封茗囧菌",url:"http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/%E5%B0%81%E8%8C%97%E5%9B%A7%E8%8F%8C%20-%20%E4%B8%9C%E4%BA%AC%E4%B8%8D%E5%A4%AA%E7%83%AD.mp3",pic:"http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/music2.jpeg"},{title:"春风吹",author:"锦零",url:"http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/%E9%94%A6%E9%9B%B6%20-%20%E6%98%A5%E9%A3%8E%E5%90%B9%EF%BC%88Cover%20%E6%96%B9%E5%A4%A7%E5%90%8C%EF%BC%89.mp3",pic:"http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/music3.jpeg"},{title:"Secret",author:"茶太",url:"https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/%E8%8C%B6%E5%A4%AA%20-%20Secret.mp3",pic:"http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/music4.jpeg"},{title:"secret base ~君がくれたもの~",author:"茅野愛衣,戸松遥,早見沙織",url:"https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/%E8%8C%85%E9%87%8E%E6%84%9B%E8%A1%A3%2C%E6%88%B8%E6%9D%BE%E9%81%A5%2C%E6%97%A9%E8%A6%8B%E6%B2%99%E7%B9%94%20-%20secret%20base%20%7E%E5%90%9B%E3%81%8B%E3%82%99%E3%81%8F%E3%82%8C%E3%81%9F%E3%82%82%E3%81%AE%7E%20%2810%20years%20after%20Ver.%29.mp3",pic:"http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/music5.jpeg"},{title:"ファンファーレ",author:"sumika",url:"https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/sumika%20-%20%E3%83%95%E3%82%A1%E3%83%B3%E3%83%95%E3%82%A1%E3%83%BC%E3%83%AC.mp3",pic:"http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/music6.jpeg"},{title:"心做し",author:"双笙",url:"https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/%E5%8F%8C%E7%AC%99%20-%20%E5%BF%83%E5%81%9A%E3%81%97%EF%BC%88Cover%20GUMI%EF%BC%89.mp3",pic:"https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/music7.jpeg"}]};options.element=document.getElementById("aplayer-rWUYQYrx");var ap=new APlayer(options);window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#正文"><span class="nav-number">2.</span> <span class="nav-text">正文</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#堆内存结构"><span class="nav-number">2.1.</span> <span class="nav-text">堆内存结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GC流程"><span class="nav-number">2.2.</span> <span class="nav-text">GC流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾收集算法"><span class="nav-number">2.3.</span> <span class="nav-text">垃圾收集算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾回收算法"><span class="nav-number">2.4.</span> <span class="nav-text">垃圾回收算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾收集器"><span class="nav-number">2.5.</span> <span class="nav-text">垃圾收集器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM的一些参数"><span class="nav-number">2.6.</span> <span class="nav-text">JVM的一些参数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM的基础参数"><span class="nav-number">2.6.1.</span> <span class="nav-text">JVM的基础参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM垃圾回收参数"><span class="nav-number">2.6.2.</span> <span class="nav-text">JVM垃圾回收参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM其它参数"><span class="nav-number">2.6.3.</span> <span class="nav-text">JVM其它参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#各个区域的OOM"><span class="nav-number">2.7.</span> <span class="nav-text">各个区域的OOM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM-日志"><span class="nav-number">2.8.</span> <span class="nav-text">JVM 日志</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM监控Demo"><span class="nav-number">2.9.</span> <span class="nav-text">JVM监控Demo</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">3.</span> <span class="nav-text">总结</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2020</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">SakuraTears</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-area-chart"></i></span> <span class="post-meta-item-text">Site words total count&#58;</span> <span title="Site words total count">515.3k</span></div> <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("05/20/2018 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="本站已运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",250)</script><div class="footer-custom">Thanks to <a target="_blank" href="https://hexo.io/" rel="external nofollow noopener noreferrer">Hexo</a> | <a target="_blank" href="https://github.com/" rel="external nofollow noopener noreferrer">GitHub</a> | <a target="_blank" href="https://nodejs.org/" rel="external nofollow noopener noreferrer">Node.js</a></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script> <span class="site-uv"><i class="fa fa-user">总访客数</i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span> <i class="fa">人</i></span> <span class="site-pv"><i class="fa fa-eye">总浏览量</i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span> <i class="fa">次</i></span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div><div id="needsharebutton-float"><span class="btn"><i class="fa fa-share-alt" aria-hidden="true"></i></span></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'n81D2zVCOBCRyTrhhwoBjui0-gzGzoHsz',
        appKey: '2II35ez36s8c4KvXJNGVeJ5O',
        placeholder: '(*^_^*)看了这么多，可能你有话想说',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
    //新增以下代码即可，可以移除.info下所有子节点。
    var infoEle = document.querySelector('#comments .info');
      if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0){
        infoEle.childNodes.forEach(function(item) {
          item.parentNode.removeChild(item);
        });
      }
  </script><script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script><script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script><script>AV.initialize("n81D2zVCOBCRyTrhhwoBjui0-gzGzoHsz","2II35ez36s8c4KvXJNGVeJ5O")</script><script>function showTime(e){var t=new AV.Query(e),c=[],u=$(".leancloud_visitors");u.each(function(){c.push($(this).attr("id").trim())}),t.containedIn("url",c),t.find().done(function(e){var t=".leancloud-visitors-count";if(0!==e.length){for(var n=0;n<e.length;n++){var o=e[n],i=o.get("url"),s=o.get("time"),r=document.getElementById(i);$(r).find(t).text(s)}for(n=0;n<c.length;n++){i=c[n],r=document.getElementById(i);var l=$(r).find(t);""==l.text()&&l.text(0)}}else u.find(t).text(0)}).fail(function(e,t){console.log("Error: "+t.code+" "+t.message)})}function addCount(i){var e=$(".leancloud_visitors"),s=e.attr("id").trim(),r=e.attr("data-flag-title").trim(),t=new AV.Query(i);t.equalTo("url",s),t.find({success:function(e){if(0<e.length){var t=e[0];t.fetchWhenSave(!0),t.increment("time"),t.save(null,{success:function(e){$(document.getElementById(s)).find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})}else{var n=new i,o=new AV.ACL;o.setPublicReadAccess(!0),o.setPublicWriteAccess(!0),n.setACL(o),n.set("title",r),n.set("url",s),n.set("time",1),n.save(null,{success:function(e){$(document.getElementById(s)).find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to create")}})}},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}$(function(){var e=AV.Object.extend("Counter");1==$(".leancloud_visitors").length?addCount(e):1<$(".post-title-link").length&&showTime(e)})</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css"><script src="/lib/needsharebutton/needsharebutton.js"></script><script>flOptions={iconStyle:"default",boxForm:"horizontal",position:"topRight",networks:"Weibo,Wechat,Douban,QQZone,Twitter,Facebook"},new needShareButton("#needsharebutton-float",flOptions)</script><script type="text/javascript">wpac_init=window.wpac_init||[],wpac_init.push({widget:"Rating",id:12042,el:"wpac-rating",color:"fc6423"}),function(){if(!("WIDGETPACK_LOADED"in window)){WIDGETPACK_LOADED=!0;var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//embed.widgetpack.com/widget.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t.nextSibling)}}()</script><script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script><script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script><script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/javascript" src="/js/src/click.js"></script><script type="text/javascript" src="/js/src/bored.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({model:{scale:1,hHeadPos:.5,vHeadPos:.618},display:{superSample:2,width:250,height:500,position:"right",hOffset:0,vOffset:-20},mobile:{show:!1,scale:.1,motion:!0},react:{opacityDefault:.9,opacityOnHover:.3},log:!1,pluginJsPath:"lib/",pluginModelPath:"assets/",pluginRootPath:"live2dw/",tagMode:!1})</script></body></html>