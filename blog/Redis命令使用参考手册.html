<!DOCTYPE html><html class="theme-next pisces use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><script src="/lib/pace/pace.min.js?v=1.0.2"></script><link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="Redis,"><link rel="alternate" href="/atom.xml" title="SakuraTears的博客" type="application/atom+xml"><meta name="description" content="前言我们来详细了解下Redis，及其一些命令的具体使用方法，并学会如何使用 Redis 的事务、持久化、复制、Sentinel、集群等功能。 主要命令我们知道Redis支持五种数据类型：string（字符串），hash（哈希表），list（列表），set（集合）及zset(sorted set：有序集合)。先来看下它们的一些操作命令。 字符串SETSET key value [EX seconds"><meta name="keywords" content="Redis"><meta property="og:type" content="article"><meta property="og:title" content="Redis命令使用参考手册"><meta property="og:url" content="https://www.sakuratears.top/blog/Redis命令使用参考手册.html"><meta property="og:site_name" content="SakuraTears的博客"><meta property="og:description" content="前言我们来详细了解下Redis，及其一些命令的具体使用方法，并学会如何使用 Redis 的事务、持久化、复制、Sentinel、集群等功能。 主要命令我们知道Redis支持五种数据类型：string（字符串），hash（哈希表），list（列表），set（集合）及zset(sorted set：有序集合)。先来看下它们的一些操作命令。 字符串SETSET key value [EX seconds"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2019-02-24T14:11:22.346Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Redis命令使用参考手册"><meta name="twitter:description" content="前言我们来详细了解下Redis，及其一些命令的具体使用方法，并学会如何使用 Redis 的事务、持久化、复制、Sentinel、集群等功能。 主要命令我们知道Redis支持五种数据类型：string（字符串），hash（哈希表），list（列表），set（集合）及zset(sorted set：有序集合)。先来看下它们的一些操作命令。 字符串SETSET key value [EX seconds"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!0,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://www.sakuratears.top/blog/Redis命令使用参考手册.html"><title>Redis命令使用参考手册 | SakuraTears的博客</title><link rel="stylesheet" href="/assets/css/APlayer.min.css" class="aplayer-style-marker"><script src="/assets/js/APlayer.min.js" class="aplayer-script-marker"></script></head><body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div> <a href="https://github.com/javazwt" rel="external nofollow noopener noreferrer" target="_blank"><img style="position:absolute;top:0;left:0;border:0" src="https://s3.amazonaws.com/github/ribbons/forkme_left_gray_6d6d6d.png" alt="Fork me on GitHub"></a><header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">SakuraTears的博客</span><span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">越努力越幸运</h1></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> 首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br> 关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br> 归档</a></li><li class="menu-item menu-item-support"><a href="/support/" rel="section"><i class="menu-item-icon fa fa-fw fa-support"></i><br> 开源支持</a></li><li class="menu-item menu-item-photos"><a href="/photos/" rel="section"><i class="menu-item-icon fa fa-fw fa-photo"></i><br> 相册</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br> 搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i></span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"> <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.sakuratears.top/blog/Redis命令使用参考手册.html"><span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="name" content="SakuraTears"><meta itemprop="description" content=""><meta itemprop="image" content="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/others/avatar.jpg"></span><span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="SakuraTears的博客"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">Redis命令使用参考手册</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-21T22:00:00+08:00">2019-02-21</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/学习/" itemprop="url" rel="index"><span itemprop="name">学习</span></a></span></span> <span class="post-comments-count"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i></span><a href="/blog/Redis命令使用参考手册.html#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/blog/Redis命令使用参考手册.html" itemprop="commentCount"></span></a></span> <span id="/blog/Redis命令使用参考手册.html" class="leancloud_visitors" data-flag-title="Redis命令使用参考手册"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数&#58;</span><span class="leancloud-visitors-count"></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">61,226</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">257</span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们来详细了解下Redis，及其一些命令的具体使用方法，并学会如何使用 Redis 的事务、持久化、复制、Sentinel、集群等功能。</p><h1 id="主要命令"><a href="#主要命令" class="headerlink" title="主要命令"></a>主要命令</h1><p>我们知道Redis支持五种数据类型：<a href="#字符串">string（字符串）</a>，<a href="#哈希表">hash（哈希表）</a>，<a href="#列表">list（列表）</a>，<a href="#集合">set（集合）</a>及<a href="#有序集合">zset(sorted set：有序集合)</a>。先来看下它们的一些操作命令。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a><a name="字符串">字符串</a></h2><h3 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h3><h4 id="SET-key-value-EX-seconds-PX-milliseconds-NX-XX"><a href="#SET-key-value-EX-seconds-PX-milliseconds-NX-XX" class="headerlink" title="SET key value [EX seconds] [PX milliseconds] [NX|XX]"></a>SET key value [EX seconds] [PX milliseconds] [NX|XX]</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度： O(1)
</code></pre><p>将字符串值 <code>value</code> 关联到 <code>key</code> 。</p><p>如果 <code>key</code> 已经持有其他值， SET 就覆写旧值， 无视类型。</p><p>当 SET 命令对一个带有生存时间（TTL）的键进行设置之后， 该键原有的 TTL 将被清除。</p><h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><p>从 Redis 2.6.12 版本开始， SET 命令的行为可以通过一系列参数来修改：</p><ul><li>EX seconds ： 将键的过期时间设置为 seconds 秒。 执行 <code>SET key value EX seconds</code> 的效果等同于执行 <code>SETEX key seconds value</code> 。</li><li>PX milliseconds ： 将键的过期时间设置为 milliseconds 毫秒。 执行 <code>SET key value PX milliseconds</code> 的效果等同于执行 <code>PSETEX key milliseconds value</code> 。</li><li>NX ： 只在键不存在时， 才对键进行设置操作。 执行 <code>SET key value NX</code> 的效果等同于执行 <code>SETNX key value</code> 。</li><li>XX ： 只在键已经存在时， 才对键进行设置操作。</li></ul> <font color="red"><strong>Note</strong></font><pre><code>因为 SET 命令可以通过参数来实现 SETNX 、 SETEX 以及 PSETEX 命令的效果， 所以 Redis 将来的版本可能会移除并废弃 SETNX 、 SETEX 和 PSETEX 这三个命令。
</code></pre><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>在 Redis 2.6.12 版本以前， SET 命令总是返回 OK 。</p><p>从 Redis 2.6.12 版本开始， SET 命令只在设置操作成功完成时才返回 OK ； 如果命令使用了 NX 或者 XX 选项， 但是因为条件没达到而造成设置操作未执行， 那么命令将返回空批量回复（NULL Bulk Reply）。</p><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><p>对不存在的键进行设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET key <span class="string">"value"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET key</span><br><span class="line"><span class="string">"value"</span></span><br></pre></td></tr></table></figure><p>对已存在的键进行设置：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET key <span class="string">"new-value"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET key</span><br><span class="line"><span class="string">"new-value"</span></span><br></pre></td></tr></table></figure><p></p><p>使用 EX 选项：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET key-with-expire-time <span class="string">"hello"</span> EX 10086</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET key-with-expire-time</span><br><span class="line"><span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line">redis&gt; TTL key-with-expire-time</span><br><span class="line">(<span class="built_in">integer</span>) 10069</span><br></pre></td></tr></table></figure><p></p><p>使用 PX 选项：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET key-with-pexpire-time <span class="string">"moto"</span> PX 123321</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET key-with-pexpire-time</span><br><span class="line"><span class="string">"moto"</span></span><br><span class="line"></span><br><span class="line">redis&gt; PTTL key-with-pexpire-time</span><br><span class="line">(<span class="built_in">integer</span>) 111939</span><br></pre></td></tr></table></figure><p></p><p>使用 NX 选项：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET not-exists-key <span class="string">"value"</span> NX</span><br><span class="line">OK      <span class="comment"># 键不存在，设置成功</span></span><br><span class="line"></span><br><span class="line">redis&gt; GET not-exists-key</span><br><span class="line"><span class="string">"value"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SET not-exists-key <span class="string">"new-value"</span> NX</span><br><span class="line">(nil)   <span class="comment"># 键已经存在，设置失败</span></span><br><span class="line"></span><br><span class="line">redis&gt; GEt not-exists-key</span><br><span class="line"><span class="string">"value"</span> <span class="comment"># 维持原值不变</span></span><br></pre></td></tr></table></figure><p></p><p>使用 XX 选项：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; EXISTS exists-key</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; SET exists-key <span class="string">"value"</span> XX</span><br><span class="line">(nil)   <span class="comment"># 因为键不存在，设置失败</span></span><br><span class="line"></span><br><span class="line">redis&gt; SET exists-key <span class="string">"value"</span></span><br><span class="line">OK      <span class="comment"># 先给键设置一个值</span></span><br><span class="line"></span><br><span class="line">redis&gt; SET exists-key <span class="string">"new-value"</span> XX</span><br><span class="line">OK      <span class="comment"># 设置新值成功</span></span><br><span class="line"></span><br><span class="line">redis&gt; GET exists-key</span><br><span class="line"><span class="string">"new-value"</span></span><br></pre></td></tr></table></figure><p></p><h3 id="SETNX"><a href="#SETNX" class="headerlink" title="SETNX"></a>SETNX</h3><h4 id="SETNX-key-value"><a href="#SETNX-key-value" class="headerlink" title="SETNX key value"></a>SETNX key value</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度： O(1)
</code></pre><p>只在键 <code>key</code> 不存在的情况下， 将键 <code>key</code> 的值设置为 <code>value</code> 。</p><p>若键 <code>key</code> 已经存在， 则 SETNX 命令不做任何动作。</p><p>SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。</p><h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><p>命令在设置成功时返回 1 ， 设置失败时返回 0 。</p><h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; EXISTS job                <span class="comment"># job 不存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; SETNX job <span class="string">"programmer"</span>    <span class="comment"># job 设置成功</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; SETNX job <span class="string">"code-farmer"</span>   <span class="comment"># 尝试覆盖 job ，失败</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; GET job                   <span class="comment"># 没有被覆盖</span></span><br><span class="line"><span class="string">"programmer"</span></span><br></pre></td></tr></table></figure><h3 id="SETEX"><a href="#SETEX" class="headerlink" title="SETEX"></a>SETEX</h3><h4 id="SETEX-key-seconds-value"><a href="#SETEX-key-seconds-value" class="headerlink" title="SETEX key seconds value"></a>SETEX key seconds value</h4><pre><code>可用版本： &gt;= 2.0.0
时间复杂度： O(1)
</code></pre><p>将键 <code>key</code> 的值设置为 <code>value</code> ， 并将键 <code>key</code> 的生存时间设置为 seconds 秒钟。</p><p>如果键 <code>key</code> 已经存在， 那么 SETEX 命令将覆盖已有的值。</p><p>SETEX 命令的效果和以下两个命令的效果类似：</p><ul><li><code>SET key value</code></li><li><code>EXPIRE key seconds</code> # 设置生存时间</li></ul><p>SETEX 和这两个命令的不同之处在于 SETEX 是一个原子（atomic）操作， 它可以在同一时间内完成设置值和设置过期时间这两个操作， 因此 SETEX 命令在储存缓存的时候非常实用。</p><h4 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h4><p>命令在设置成功时返回 OK 。</p><p>当 seconds 参数不合法时， 命令将返回一个错误。</p><h4 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h4><p>在键 <code>key</code> 不存在的情况下执行 SETEX ：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SETEX cache_user_id 60 10086</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET cache_user_id  <span class="comment"># 值</span></span><br><span class="line"><span class="string">"10086"</span></span><br><span class="line"></span><br><span class="line">redis&gt; TTL cache_user_id  <span class="comment"># 剩余生存时间</span></span><br><span class="line">(<span class="built_in">integer</span>) 49</span><br></pre></td></tr></table></figure><p></p><p>键 <code>key</code> 已经存在， 使用 SETEX 覆盖旧值：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET <span class="built_in">cd</span> <span class="string">"timeless"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SETEX <span class="built_in">cd</span> 3000 <span class="string">"goodbye my love"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET <span class="built_in">cd</span></span><br><span class="line"><span class="string">"goodbye my love"</span></span><br><span class="line"></span><br><span class="line">redis&gt; TTL <span class="built_in">cd</span></span><br><span class="line">(<span class="built_in">integer</span>) 2997</span><br></pre></td></tr></table></figure><p></p><h3 id="PSETEX"><a href="#PSETEX" class="headerlink" title="PSETEX"></a>PSETEX</h3><h4 id="PSETEX-key-milliseconds-value"><a href="#PSETEX-key-milliseconds-value" class="headerlink" title="PSETEX key milliseconds value"></a>PSETEX key milliseconds value</h4><pre><code>可用版本： &gt;= 2.6.0
时间复杂度： O(1)
</code></pre><p>这个命令和 SETEX 命令相似， 但它以毫秒为单位设置 <code>key</code> 的生存时间， 而不是像 SETEX 命令那样以秒为单位进行设置。</p><h4 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h4><p>命令在设置成功时返回 OK 。</p><h4 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; PSETEX mykey 1000 <span class="string">"Hello"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; PTTL mykey</span><br><span class="line">(<span class="built_in">integer</span>) 999</span><br><span class="line"></span><br><span class="line">redis&gt; GET mykey</span><br><span class="line"><span class="string">"Hello"</span></span><br></pre></td></tr></table></figure><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><h4 id="GET-key"><a href="#GET-key" class="headerlink" title="GET key"></a>GET key</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度： O(1)
</code></pre><p>返回与键 <code>key</code> 相关联的字符串值。</p><h4 id="返回值-4"><a href="#返回值-4" class="headerlink" title="返回值"></a>返回值</h4><p>如果键 <code>key</code> 不存在， 那么返回特殊值 <code>nil</code> ； 否则， 返回键 <code>key</code> 的值。</p><p>如果键 <code>key</code> 的值并非字符串类型， 那么返回一个错误， 因为 GET 命令只能用于字符串值。</p><h4 id="代码示例-4"><a href="#代码示例-4" class="headerlink" title="代码示例"></a>代码示例</h4><p>对不存在的键 <code>key</code> 或是字符串类型的键 <code>key</code> 执行 GET 命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GET db</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line">redis&gt; SET db redis</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET db</span><br><span class="line"><span class="string">"redis"</span></span><br></pre></td></tr></table></figure><p></p><p>对不是字符串类型的键 <code>key</code> 执行 GET 命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; DEL db</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; LPUSH db redis mongodb mysql</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis&gt; GET db</span><br><span class="line">(error) ERR Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure><p></p><h3 id="GETSET"><a href="#GETSET" class="headerlink" title="GETSET"></a>GETSET</h3><h4 id="GETSET-key-value"><a href="#GETSET-key-value" class="headerlink" title="GETSET key value"></a>GETSET key value</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度： O(1)
</code></pre><p>将键 <code>key</code> 的值设为 <code>value</code> ， 并返回键 <code>key</code> 在被设置之前的旧值。</p><h4 id="返回值-5"><a href="#返回值-5" class="headerlink" title="返回值"></a>返回值</h4><p>返回给定键 <code>key</code> 的旧值。</p><p>如果键 <code>key</code> 没有旧值， 也即是说， 键 <code>key</code> 在被设置之前并不存在， 那么命令返回 <code>nil</code> 。</p><p>当键 <code>key</code> 存在但不是字符串类型时， 命令返回一个错误。</p><h4 id="代码示例-5"><a href="#代码示例-5" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GETSET db mongodb    <span class="comment"># 没有旧值，返回 nil</span></span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line">redis&gt; GET db</span><br><span class="line"><span class="string">"mongodb"</span></span><br><span class="line"></span><br><span class="line">redis&gt; GETSET db redis      <span class="comment"># 返回旧值 mongodb</span></span><br><span class="line"><span class="string">"mongodb"</span></span><br><span class="line"></span><br><span class="line">redis&gt; GET db</span><br><span class="line"><span class="string">"redis"</span></span><br></pre></td></tr></table></figure><h3 id="STRLEN"><a href="#STRLEN" class="headerlink" title="STRLEN"></a>STRLEN</h3><h4 id="STRLEN-key"><a href="#STRLEN-key" class="headerlink" title="STRLEN key"></a>STRLEN key</h4><pre><code>可用版本： &gt;= 2.2.0
复杂度： O(1)
</code></pre><p>返回键 <code>key</code> 储存的字符串值的长度。</p><h4 id="返回值-6"><a href="#返回值-6" class="headerlink" title="返回值"></a>返回值</h4><p>STRLEN 命令返回字符串值的长度。</p><p>当键 <code>key</code> 不存在时， 命令返回 0 。</p><p>当 <code>key</code> 储存的不是字符串值时， 返回一个错误。</p><h4 id="代码示例-6"><a href="#代码示例-6" class="headerlink" title="代码示例"></a>代码示例</h4><p>获取字符串值的长度：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET mykey <span class="string">"Hello world"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; STRLEN mykey</span><br><span class="line">(<span class="built_in">integer</span>) 11</span><br></pre></td></tr></table></figure><p></p><p>不存在的键的长度为 0 ：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; STRLEN nonexisting</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><p></p><h3 id="APPEND"><a href="#APPEND" class="headerlink" title="APPEND"></a>APPEND</h3><h4 id="APPEND-key-value"><a href="#APPEND-key-value" class="headerlink" title="APPEND key value"></a>APPEND key value</h4><pre><code>可用版本： &gt;= 2.0.0
时间复杂度： 平摊O(1)
</code></pre><p>如果键 <code>key</code> 已经存在并且它的值是一个字符串， APPEND 命令将把 <code>value</code> 追加到键 <code>key</code> 现有值的末尾。</p><p>如果 <code>key</code> 不存在， APPEND 就简单地将键 <code>key</code> 的值设为 <code>value</code> ， 就像执行 <code>SET key value</code> 一样。</p><h4 id="返回值-7"><a href="#返回值-7" class="headerlink" title="返回值"></a>返回值</h4><p>追加 <code>value</code> 之后， 键 <code>key</code> 的值的长度。</p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><p>对不存在的 <code>key</code> 执行 APPEND ：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; EXISTS myphone               <span class="comment"># 确保 myphone 不存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; APPEND myphone <span class="string">"nokia"</span>       <span class="comment"># 对不存在的 key 进行 APPEND ，等同于 SET myphone "nokia"</span></span><br><span class="line">(<span class="built_in">integer</span>) 5                         <span class="comment"># 字符长度</span></span><br></pre></td></tr></table></figure><p></p><p>对已存在的字符串进行 APPEND ：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; APPEND myphone <span class="string">" - 1110"</span>     <span class="comment"># 长度从 5 个字符增加到 12 个字符</span></span><br><span class="line">(<span class="built_in">integer</span>) 12</span><br><span class="line"></span><br><span class="line">redis&gt; GET myphone</span><br><span class="line"><span class="string">"nokia - 1110"</span></span><br></pre></td></tr></table></figure><p></p><h3 id="SETRANGE"><a href="#SETRANGE" class="headerlink" title="SETRANGE"></a>SETRANGE</h3><h4 id="SETRANGE-key-offset-value"><a href="#SETRANGE-key-offset-value" class="headerlink" title="SETRANGE key offset value"></a>SETRANGE key offset value</h4><pre><code>可用版本： &gt;= 2.2.0
时间复杂度：对于长度较短的字符串，命令的平摊复杂度O(1)；对于长度较大的字符串，命令的复杂度为 O(M) ，其中 M 为 value 的长度。
</code></pre><p>从偏移量 <code>offset</code> 开始， 用 <code>value</code> 参数覆写(overwrite)键 <code>key</code> 储存的字符串值。</p><p>不存在的键 <code>key</code> 当作空白字符串处理。</p><p>SETRANGE 命令会确保字符串足够长以便将 <code>value</code> 设置到指定的偏移量上， 如果键 <code>key</code> 原来储存的字符串长度比偏移量小(比如字符串只有 5 个字符长，但你设置的 <code>offset</code> 是 10 )， 那么原字符和偏移量之间的空白将用零字节(zerobytes, “\x00” )进行填充。</p><p>因为 Redis 字符串的大小被限制在 512 兆(megabytes)以内， 所以用户能够使用的最大偏移量为 2^29-1(536870911) ， 如果你需要使用比这更大的空间， 请使用多个 <code>key</code> 。</p> <font color="red"><strong>Warning</strong></font><pre><code>当生成一个很长的字符串时， Redis 需要分配内存空间， 该操作有时候可能会造成服务器阻塞(block)。 在2010年出产的Macbook Pro上， 设置偏移量为 536870911(512MB 内存分配)将耗费约 300 毫秒， 设置偏移量为 134217728(128MB 内存分配)将耗费约 80 毫秒， 设置偏移量 33554432(32MB 内存分配)将耗费约 30 毫秒， 设置偏移量为 8388608(8MB 内存分配)将耗费约 8 毫秒。
</code></pre><h4 id="返回值-8"><a href="#返回值-8" class="headerlink" title="返回值"></a>返回值</h4><p>SETRANGE 命令会返回被修改之后， 字符串值的长度。</p><h4 id="代码示例-7"><a href="#代码示例-7" class="headerlink" title="代码示例"></a>代码示例</h4><p>对非空字符串执行 SETRANGE 命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET greeting <span class="string">"hello world"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SETRANGE greeting 6 <span class="string">"Redis"</span></span><br><span class="line">(<span class="built_in">integer</span>) 11</span><br><span class="line"></span><br><span class="line">redis&gt; GET greeting</span><br><span class="line"><span class="string">"hello Redis"</span></span><br></pre></td></tr></table></figure><p></p><p>对空字符串/不存在的键执行 SETRANGE 命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; EXISTS empty_string</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; SETRANGE empty_string 5 <span class="string">"Redis!"</span>   <span class="comment"># 对不存在的 key 使用 SETRANGE</span></span><br><span class="line">(<span class="built_in">integer</span>) 11</span><br><span class="line"></span><br><span class="line">redis&gt; GET empty_string                   <span class="comment"># 空白处被"\x00"填充</span></span><br><span class="line"><span class="string">"\x00\x00\x00\x00\x00Redis!"</span></span><br></pre></td></tr></table></figure><p></p><h3 id="GETRANGE"><a href="#GETRANGE" class="headerlink" title="GETRANGE"></a>GETRANGE</h3><h4 id="GETRANGE-key-start-end"><a href="#GETRANGE-key-start-end" class="headerlink" title="GETRANGE key start end"></a>GETRANGE key start end</h4><pre><code>可用版本： &gt;= 2.4.0
时间复杂度： O(N)，其中 N 为被返回的字符串的长度。
</code></pre><p>返回键 <code>key</code> 储存的字符串值的指定部分， 字符串的截取范围由 <code>start</code> 和 <code>end</code> 两个偏移量决定 (包括 <code>start</code> 和 <code>end</code> 在内)。</p><p>负数偏移量表示从字符串的末尾开始计数， -1 表示最后一个字符， -2 表示倒数第二个字符， 以此类推。</p><p>GETRANGE 通过保证子字符串的值域(range)不超过实际字符串的值域来处理超出范围的值域请求。</p><p><strong>Note</strong></p><pre><code>GETRANGE 命令在 Redis 2.0 之前的版本里面被称为 SUBSTR 命令。
</code></pre><h4 id="返回值-9"><a href="#返回值-9" class="headerlink" title="返回值"></a>返回值</h4><p>GETRANGE 命令会返回字符串值的指定部分。</p><h4 id="代码示例-8"><a href="#代码示例-8" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET greeting <span class="string">"hello, my friend"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GETRANGE greeting 0 4          <span class="comment"># 返回索引0-4的字符，包括4。</span></span><br><span class="line"><span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line">redis&gt; GETRANGE greeting -1 -5        <span class="comment"># 不支持回绕操作</span></span><br><span class="line"><span class="string">""</span></span><br><span class="line"></span><br><span class="line">redis&gt; GETRANGE greeting -3 -1        <span class="comment"># 负数索引</span></span><br><span class="line"><span class="string">"end"</span></span><br><span class="line"></span><br><span class="line">redis&gt; GETRANGE greeting 0 -1         <span class="comment"># 从第一个到最后一个</span></span><br><span class="line"><span class="string">"hello, my friend"</span></span><br><span class="line"></span><br><span class="line">redis&gt; GETRANGE greeting 0 1008611    <span class="comment"># 值域范围不超过实际字符串，超过部分自动被符略</span></span><br><span class="line"><span class="string">"hello, my friend"</span></span><br></pre></td></tr></table></figure><h3 id="INCRBY"><a href="#INCRBY" class="headerlink" title="INCRBY"></a>INCRBY</h3><h4 id="INCRBY-key-increment"><a href="#INCRBY-key-increment" class="headerlink" title="INCRBY key increment"></a>INCRBY key increment</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度： O(1)
</code></pre><p>为键 <code>key</code> 储存的数字值加上增量 increment 。</p><p>如果键 <code>key</code> 不存在， 那么键 <code>key</code> 的值会先被初始化为 0 ， 然后再执行 INCRBY 命令。</p><p>如果键 <code>key</code> 储存的值不能被解释为数字， 那么 INCRBY 命令将返回一个错误。</p><p>本操作的值限制在 64 位(bit)有符号数字表示之内。</p><h4 id="返回值-10"><a href="#返回值-10" class="headerlink" title="返回值"></a>返回值</h4><p>在加上增量 increment 之后， 键 <code>key</code> 当前的值。</p><h4 id="代码示例-9"><a href="#代码示例-9" class="headerlink" title="代码示例"></a>代码示例</h4><p>键存在，并且值为数字：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET rank 50</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; INCRBY rank 20</span><br><span class="line">(<span class="built_in">integer</span>) 70</span><br><span class="line"></span><br><span class="line">redis&gt; GET rank</span><br><span class="line"><span class="string">"70"</span></span><br></pre></td></tr></table></figure><p></p><p>键不存在：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; EXISTS counter</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; INCRBY counter 30</span><br><span class="line">(<span class="built_in">integer</span>) 30</span><br><span class="line"></span><br><span class="line">redis&gt; GET counter</span><br><span class="line"><span class="string">"30"</span></span><br></pre></td></tr></table></figure><p></p><p>键存在，但值无法被解释为数字：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET book <span class="string">"long long ago..."</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; INCRBY book 200</span><br><span class="line">(error) ERR value is not an <span class="built_in">integer</span> or out of range</span><br></pre></td></tr></table></figure><p></p><h3 id="INCRBYFLOAT"><a href="#INCRBYFLOAT" class="headerlink" title="INCRBYFLOAT"></a>INCRBYFLOAT</h3><h4 id="INCRBYFLOAT-key-increment"><a href="#INCRBYFLOAT-key-increment" class="headerlink" title="INCRBYFLOAT key increment"></a>INCRBYFLOAT key increment</h4><pre><code>可用版本： &gt;= 2.6.0
时间复杂度： O(1)
</code></pre><p>为键 <code>key</code> 储存的值加上浮点数增量 increment 。</p><p>如果键 <code>key</code> 不存在， 那么 INCRBYFLOAT 会先将键 <code>key</code> 的值设为 0 ， 然后再执行加法操作。</p><p>如果命令执行成功， 那么键 <code>key</code> 的值会被更新为执行加法计算之后的新值， 并且新值会以字符串的形式返回给调用者。</p><p>无论是键 <code>key</code> 的值还是增量 increment ， 都可以使用像 2.0e7 、 3e5 、 90e-2 那样的指数符号(exponential notation)来表示， 但是， 执行 INCRBYFLOAT 命令之后的值总是以同样的形式储存， 也即是， 它们总是由一个数字， 一个（可选的）小数点和一个任意长度的小数部分组成（比如 3.14 、 69.768 ，诸如此类)， 小数部分尾随的 0 会被移除， 如果可能的话， 命令还会将浮点数转换为整数（比如 3.0 会被保存成 3 ）。</p><p>此外， 无论加法计算所得的浮点数的实际精度有多长， INCRBYFLOAT 命令的计算结果最多只保留小数点的后十七位。</p><p>当以下任意一个条件发生时， 命令返回一个错误：</p><ul><li>键 <code>key</code> 的值不是字符串类型(因为 Redis 中的数字和浮点数都以字符串的形式保存，所以它们都属于字符串类型）；</li><li>键 <code>key</code> 当前的值或者给定的增量 increment 不能被解释(parse)为双精度浮点数。</li></ul><h4 id="返回值-11"><a href="#返回值-11" class="headerlink" title="返回值"></a>返回值</h4><p>在加上增量 increment 之后， 键 <code>key</code> 的值。</p><h4 id="代码示例-10"><a href="#代码示例-10" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GET decimal</span><br><span class="line"><span class="string">"3.0"</span></span><br><span class="line"></span><br><span class="line">redis&gt; INCRBYFLOAT decimal 2.56</span><br><span class="line"><span class="string">"5.56"</span></span><br><span class="line"></span><br><span class="line">redis&gt; GET decimal</span><br><span class="line"><span class="string">"5.56"</span></span><br></pre></td></tr></table></figure><h3 id="DECR"><a href="#DECR" class="headerlink" title="DECR"></a>DECR</h3><h4 id="DECR-key"><a href="#DECR-key" class="headerlink" title="DECR key"></a>DECR key</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度： O(1)
</code></pre><p>为键 <code>key</code> 储存的数字值减去一。</p><p>如果键 <code>key</code> 不存在， 那么键 <code>key</code> 的值会先被初始化为 0 ， 然后再执行 DECR 操作。</p><p>如果键 <code>key</code> 储存的值不能被解释为数字， 那么 DECR 命令将返回一个错误。</p><p>本操作的值限制在 64 位(bit)有符号数字表示之内。</p><h4 id="返回值-12"><a href="#返回值-12" class="headerlink" title="返回值"></a>返回值</h4><p>DECR 命令会返回键 <code>key</code> 在执行减一操作之后的值。</p><h4 id="代码示例-11"><a href="#代码示例-11" class="headerlink" title="代码示例"></a>代码示例</h4><p>对储存数字值的键 <code>key</code> 执行 DECR 命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET failure_times 10</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; DECR failure_times</span><br><span class="line">(<span class="built_in">integer</span>) 9</span><br></pre></td></tr></table></figure><p></p><p>对不存在的键执行 DECR 命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; EXISTS count</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; DECR count</span><br><span class="line">(<span class="built_in">integer</span>) -1</span><br></pre></td></tr></table></figure><p></p><h3 id="DECRBY"><a href="#DECRBY" class="headerlink" title="DECRBY"></a>DECRBY</h3><h4 id="DECRBY-key-decrement"><a href="#DECRBY-key-decrement" class="headerlink" title="DECRBY key decrement"></a>DECRBY key decrement</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度： O(1)
</code></pre><p>将键 <code>key</code> 储存的整数值减去减量 decrement 。</p><p>如果键 <code>key</code> 不存在， 那么键 <code>key</code> 的值会先被初始化为 0 ， 然后再执行 DECRBY 命令。</p><p>如果键 <code>key</code> 储存的值不能被解释为数字， 那么 DECRBY 命令将返回一个错误。</p><p>本操作的值限制在 64 位(bit)有符号数字表示之内。</p><h4 id="返回值-13"><a href="#返回值-13" class="headerlink" title="返回值"></a>返回值</h4><p>DECRBY 命令会返回键在执行减法操作之后的值。</p><h4 id="代码示例-12"><a href="#代码示例-12" class="headerlink" title="代码示例"></a>代码示例</h4><p>对已经存在的键执行 DECRBY 命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET count 100</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; DECRBY count 20</span><br><span class="line">(<span class="built_in">integer</span>) 80</span><br></pre></td></tr></table></figure><p></p><p>对不存在的键执行 DECRBY 命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; EXISTS pages</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; DECRBY pages 10</span><br><span class="line">(<span class="built_in">integer</span>) -10</span><br></pre></td></tr></table></figure><p></p><h3 id="MSET"><a href="#MSET" class="headerlink" title="MSET"></a>MSET</h3><h4 id="MSET-key-value-key-value-…"><a href="#MSET-key-value-key-value-…" class="headerlink" title="MSET key value [key value …]"></a>MSET key value [key value …]</h4><pre><code>可用版本： &gt;= 1.0.1
时间复杂度： O(N)，其中 N 为被设置的键数量。
</code></pre><p>同时为多个键设置值。</p><p>如果某个给定键已经存在， 那么 MSET 将使用新值去覆盖旧值， 如果这不是你所希望的效果， 请考虑使用 MSETNX 命令， 这个命令只会在所有给定键都不存在的情况下进行设置。</p><p>MSET 是一个原子性(atomic)操作， 所有给定键都会在同一时间内被设置， 不会出现某些键被设置了但是另一些键没有被设置的情况。</p><h4 id="返回值-14"><a href="#返回值-14" class="headerlink" title="返回值"></a>返回值</h4><p>MSET 命令总是返回 OK 。</p><h4 id="代码示例-13"><a href="#代码示例-13" class="headerlink" title="代码示例"></a>代码示例</h4><p>同时对多个键进行设置：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MSET date <span class="string">"2012.3.30"</span> time <span class="string">"11:00 a.m."</span> weather <span class="string">"sunny"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; MGET date time weather</span><br><span class="line">1) <span class="string">"2012.3.30"</span></span><br><span class="line">2) <span class="string">"11:00 a.m."</span></span><br><span class="line">3) <span class="string">"sunny"</span></span><br></pre></td></tr></table></figure><p></p><p>覆盖已有的值：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MGET k1 k2</span><br><span class="line">1) <span class="string">"hello"</span></span><br><span class="line">2) <span class="string">"world"</span></span><br><span class="line"></span><br><span class="line">redis&gt; MSET k1 <span class="string">"good"</span> k2 <span class="string">"bye"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; MGET k1 k2</span><br><span class="line">1) <span class="string">"good"</span></span><br><span class="line">2) <span class="string">"bye"</span></span><br></pre></td></tr></table></figure><p></p><h3 id="MSETNX"><a href="#MSETNX" class="headerlink" title="MSETNX"></a>MSETNX</h3><h4 id="MSETNX-key-value-key-value-…"><a href="#MSETNX-key-value-key-value-…" class="headerlink" title="MSETNX key value [key value …]"></a>MSETNX key value [key value …]</h4><pre><code>可用版本： &gt;= 1.0.1
时间复杂度： O(N)， 其中 N 为被设置的键数量。
</code></pre><p>当且仅当所有给定键都不存在时， 为所有给定键设置值。</p><p>即使只有一个给定键已经存在， MSETNX 命令也会拒绝执行对所有键的设置操作。</p><p>MSETNX 是一个原子性(atomic)操作， 所有给定键要么就全部都被设置， 要么就全部都不设置， 不可能出现第三种状态。</p><h4 id="返回值-15"><a href="#返回值-15" class="headerlink" title="返回值"></a>返回值</h4><p>当所有给定键都设置成功时， 命令返回 1 ；</p><p>如果因为某个给定键已经存在而导致设置未能成功执行， 那么命令返回 0 。</p><h4 id="代码示例-14"><a href="#代码示例-14" class="headerlink" title="代码示例"></a>代码示例</h4><p>对不存在的键执行 MSETNX 命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MSETNX rmdbs <span class="string">"MySQL"</span> nosql <span class="string">"MongoDB"</span> key-value-store <span class="string">"redis"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; MGET rmdbs nosql key-value-store</span><br><span class="line">1) <span class="string">"MySQL"</span></span><br><span class="line">2) <span class="string">"MongoDB"</span></span><br><span class="line">3) <span class="string">"redis"</span></span><br></pre></td></tr></table></figure><p></p><p>对某个已经存在的键进行设置：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MSETNX rmdbs <span class="string">"Sqlite"</span> language <span class="string">"python"</span>  <span class="comment"># rmdbs 键已经存在，操作失败</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; EXISTS language                          <span class="comment"># 因为 MSETNX 命令没有成功执行</span></span><br><span class="line">(<span class="built_in">integer</span>) 0                                     <span class="comment"># 所以 language 键没有被设置</span></span><br><span class="line"></span><br><span class="line">redis&gt; GET rmdbs                                <span class="comment"># rmdbs 键也没有被修改</span></span><br><span class="line"><span class="string">"MySQL"</span></span><br></pre></td></tr></table></figure><p></p><h3 id="MGET"><a href="#MGET" class="headerlink" title="MGET"></a>MGET</h3><h4 id="MGET-key-key-…"><a href="#MGET-key-key-…" class="headerlink" title="MGET key [key …]"></a>MGET key [key …]</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度： O(N) ，其中 N 为给定键的数量。
</code></pre><p>返回给定的一个或多个字符串键的值。</p><ul><li>如果给定的字符串键里面， 有某个键不存在， 那么这个键的值将以特殊值 nil 表示。</li></ul><h4 id="返回值-16"><a href="#返回值-16" class="headerlink" title="返回值"></a>返回值</h4><p>MGET 命令将返回一个列表， 列表中包含了所有给定键的值。</p><h4 id="代码示例-15"><a href="#代码示例-15" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET redis redis.com</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SET mongodb mongodb.org</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; MGET redis mongodb</span><br><span class="line">1) <span class="string">"redis.com"</span></span><br><span class="line">2) <span class="string">"mongodb.org"</span></span><br><span class="line"></span><br><span class="line">redis&gt; MGET redis mongodb mysql     <span class="comment"># 不存在的 mysql 返回 nil</span></span><br><span class="line">1) <span class="string">"redis.com"</span></span><br><span class="line">2) <span class="string">"mongodb.org"</span></span><br><span class="line">3) (nil)</span><br></pre></td></tr></table></figure><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a><a name="哈希表">哈希表</a></h2><h3 id="HSET"><a href="#HSET" class="headerlink" title="HSET"></a>HSET</h3><h4 id="HSET-hash-field-value"><a href="#HSET-hash-field-value" class="headerlink" title="HSET hash field value"></a>HSET hash field value</h4><pre><code>可用版本： &gt;= 2.0.0
时间复杂度： O(1)
</code></pre><p>将哈希表 hash 中域 field 的值设置为 <code>value</code> 。</p><p>如果给定的哈希表并不存在， 那么一个新的哈希表将被创建并执行 HSET 操作。</p><p>如果域 field 已经存在于哈希表中， 那么它的旧值将被新值 <code>value</code> 覆盖。</p><h4 id="返回值-17"><a href="#返回值-17" class="headerlink" title="返回值"></a>返回值</h4><ul><li>当 HSET 命令在哈希表中新创建 field 域并成功为它设置值时， 命令返回 1 ；</li><li>如果域 field 已经存在于哈希表， 并且 HSET 命令成功使用新值覆盖了它的旧值， 那么命令返回 0 。</li></ul><h4 id="代码示例-16"><a href="#代码示例-16" class="headerlink" title="代码示例"></a>代码示例</h4><p>设置一个新域：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSET website google <span class="string">"www.g.cn"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HGET website google</span><br><span class="line"><span class="string">"www.g.cn"</span></span><br></pre></td></tr></table></figure><p></p><p>对一个已存在的域进行更新：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSET website google <span class="string">"www.google.com"</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; HGET website google</span><br><span class="line"><span class="string">"www.google.com"</span></span><br></pre></td></tr></table></figure><p></p><h3 id="HSETNX"><a href="#HSETNX" class="headerlink" title="HSETNX"></a>HSETNX</h3><h4 id="HSETNX-hash-field-value"><a href="#HSETNX-hash-field-value" class="headerlink" title="HSETNX hash field value"></a>HSETNX hash field value</h4><pre><code>可用版本： &gt;= 2.0.0
时间复杂度： O(1)
</code></pre><p>当且仅当域 field 尚未存在于哈希表的情况下， 将它的值设置为 <code>value</code> 。</p><p>如果给定域已经存在于哈希表当中， 那么命令将放弃执行设置操作。</p><p>如果哈希表 hash 不存在， 那么一个新的哈希表将被创建并执行 HSETNX 命令。</p><h4 id="返回值-18"><a href="#返回值-18" class="headerlink" title="返回值"></a>返回值</h4><p>HSETNX 命令在设置成功时返回 1 ， 在给定域已经存在而放弃执行设置操作时返回 0 。</p><h4 id="代码示例-17"><a href="#代码示例-17" class="headerlink" title="代码示例"></a>代码示例</h4><p>域尚未存在， 设置成功：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSETNX database key-value-store Redis</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HGET database key-value-store</span><br><span class="line"><span class="string">"Redis"</span></span><br></pre></td></tr></table></figure><p></p><p>域已经存在， 设置未成功， 域原有的值未被改变：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSETNX database key-value-store Riak</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; HGET database key-value-store</span><br><span class="line"><span class="string">"Redis"</span></span><br></pre></td></tr></table></figure><p></p><h3 id="HGET"><a href="#HGET" class="headerlink" title="HGET"></a>HGET</h3><h4 id="HGET-hash-field"><a href="#HGET-hash-field" class="headerlink" title="HGET hash field"></a>HGET hash field</h4><pre><code>可用版本： &gt;= 2.0.0
时间复杂度： O(1)
</code></pre><p>返回哈希表中给定域的值。</p><h4 id="返回值-19"><a href="#返回值-19" class="headerlink" title="返回值"></a>返回值</h4><p>HGET 命令在默认情况下返回给定域的值。</p><p>如果给定域不存在于哈希表中， 又或者给定的哈希表并不存在， 那么命令返回 nil 。</p><h4 id="代码示例-18"><a href="#代码示例-18" class="headerlink" title="代码示例"></a>代码示例</h4><p>域存在的情况：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSET homepage redis redis.com</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HGET homepage redis</span><br><span class="line"><span class="string">"redis.com"</span></span><br></pre></td></tr></table></figure><p></p><p>域不存在的情况：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HGET site mysql</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p></p><h3 id="HEXISTS"><a href="#HEXISTS" class="headerlink" title="HEXISTS"></a>HEXISTS</h3><h4 id="HEXISTS-hash-field"><a href="#HEXISTS-hash-field" class="headerlink" title="HEXISTS hash field"></a>HEXISTS hash field</h4><pre><code>可用版本： &gt;= 2.0.0
时间复杂度： O(1)
</code></pre><p>检查给定域 field 是否存在于哈希表 hash 当中。</p><h4 id="返回值-20"><a href="#返回值-20" class="headerlink" title="返回值"></a>返回值</h4><p>HEXISTS 命令在给定域存在时返回 1 ， 在给定域不存在时返回 0 。</p><h4 id="代码示例-19"><a href="#代码示例-19" class="headerlink" title="代码示例"></a>代码示例</h4><p>给定域不存在：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HEXISTS phone myphone</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><p></p><p>给定域存在：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSET phone myphone nokia-1110</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HEXISTS phone myphone</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><p></p><h3 id="HDEL"><a href="#HDEL" class="headerlink" title="HDEL"></a>HDEL</h3><h4 id="HDEL-key-field-field-…"><a href="#HDEL-key-field-field-…" class="headerlink" title="HDEL key field [field …]"></a>HDEL key field [field …]</h4><pre><code>可用版本：&gt;= 2.0.0
时间复杂度:O(N)， N 为要删除的域的数量。
</code></pre><p>删除哈希表 <code>key</code> 中的一个或多个指定域，不存在的域将被忽略。</p> <font color="red"><strong>Note</strong></font><pre><code>在Redis2.4以下的版本里， HDEL 每次只能删除单个域，如果你需要在一个原子时间内删除多个域，请将命令包含在 MULTI / EXEC 块内。
</code></pre><h4 id="返回值-21"><a href="#返回值-21" class="headerlink" title="返回值"></a>返回值</h4><p>被成功移除的域的数量，不包括被忽略的域。</p><h4 id="代码示例-20"><a href="#代码示例-20" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试数据</span></span><br><span class="line">redis&gt; HGETALL abbr</span><br><span class="line">1) <span class="string">"a"</span></span><br><span class="line">2) <span class="string">"apple"</span></span><br><span class="line">3) <span class="string">"b"</span></span><br><span class="line">4) <span class="string">"banana"</span></span><br><span class="line">5) <span class="string">"c"</span></span><br><span class="line">6) <span class="string">"cat"</span></span><br><span class="line">7) <span class="string">"d"</span></span><br><span class="line">8) <span class="string">"dog"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除单个域</span></span><br><span class="line">redis&gt; HDEL abbr a</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除不存在的域</span></span><br><span class="line">redis&gt; HDEL abbr not-exists-field</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除多个域</span></span><br><span class="line">redis&gt; HDEL abbr b c</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; HGETALL abbr</span><br><span class="line">1) <span class="string">"d"</span></span><br><span class="line">2) <span class="string">"dog"</span></span><br></pre></td></tr></table></figure><h3 id="HLEN"><a href="#HLEN" class="headerlink" title="HLEN"></a>HLEN</h3><h4 id="HLEN-key"><a href="#HLEN-key" class="headerlink" title="HLEN key"></a>HLEN key</h4><pre><code>时间复杂度：O(1)
</code></pre><p>返回哈希表 key 中域的数量。</p><h4 id="返回值-22"><a href="#返回值-22" class="headerlink" title="返回值"></a>返回值</h4><p>哈希表中域的数量。</p><p>当 key 不存在时，返回 0 。</p><h4 id="代码示例-21"><a href="#代码示例-21" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSET db redis redis.com</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HSET db mysql mysql.com</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HLEN db</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; HSET db mongodb mongodb.org</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HLEN db</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure><h3 id="HSTRLEN"><a href="#HSTRLEN" class="headerlink" title="HSTRLEN"></a>HSTRLEN</h3><h4 id="HSTRLEN-key-field"><a href="#HSTRLEN-key-field" class="headerlink" title="HSTRLEN key field"></a>HSTRLEN key field</h4><pre><code>可用版本：&gt;= 3.2.0
时间复杂度：O(1)
</code></pre><p>返回哈希表 key 中， 与给定域 field 相关联的值的字符串长度（string length）。</p><p>如果给定的键或者域不存在， 那么命令返回 0 。</p><h4 id="返回值-23"><a href="#返回值-23" class="headerlink" title="返回值"></a>返回值</h4><p>一个整数。</p><h4 id="代码示例-22"><a href="#代码示例-22" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HMSET myhash f1 <span class="string">"HelloWorld"</span> f2 <span class="string">"99"</span> f3 <span class="string">"-256"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; HSTRLEN myhash f1</span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line"></span><br><span class="line">redis&gt; HSTRLEN myhash f2</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; HSTRLEN myhash f3</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br></pre></td></tr></table></figure><h3 id="HINCRBY"><a href="#HINCRBY" class="headerlink" title="HINCRBY"></a>HINCRBY</h3><h4 id="HINCRBY-key-field-increment"><a href="#HINCRBY-key-field-increment" class="headerlink" title="HINCRBY key field increment"></a>HINCRBY key field increment</h4><pre><code>可用版本：&gt;= 2.0.0
时间复杂度：O(1)
</code></pre><p>为哈希表 key 中的域 field 的值加上增量 increment 。</p><p>增量也可以为负数，相当于对给定域进行减法操作。</p><p>如果 key 不存在，一个新的哈希表被创建并执行 HINCRBY 命令。</p><p>如果域 field 不存在，那么在执行命令前，域的值被初始化为 0 。</p><p>对一个储存字符串值的域 field 执行 HINCRBY 命令将造成一个错误。</p><p>本操作的值被限制在 64 位(bit)有符号数字表示之内。</p><h4 id="返回值-24"><a href="#返回值-24" class="headerlink" title="返回值"></a>返回值</h4><p>执行 HINCRBY 命令之后，哈希表 key 中域 field 的值。</p><h4 id="代码示例-23"><a href="#代码示例-23" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># increment 为正数</span></span><br><span class="line">redis&gt; HEXISTS counter page_view    <span class="comment"># 对空域进行设置</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; HINCRBY counter page_view 200</span><br><span class="line">(<span class="built_in">integer</span>) 200</span><br><span class="line"></span><br><span class="line">redis&gt; HGET counter page_view</span><br><span class="line"><span class="string">"200"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># increment 为负数</span></span><br><span class="line">redis&gt; HGET counter page_view</span><br><span class="line"><span class="string">"200"</span></span><br><span class="line"></span><br><span class="line">redis&gt; HINCRBY counter page_view -50</span><br><span class="line">(<span class="built_in">integer</span>) 150</span><br><span class="line"></span><br><span class="line">redis&gt; HGET counter page_view</span><br><span class="line"><span class="string">"150"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 尝试对字符串值的域执行HINCRBY命令</span></span><br><span class="line">redis&gt; HSET myhash string hello,world       <span class="comment"># 设定一个字符串值</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HGET myhash string</span><br><span class="line"><span class="string">"hello,world"</span></span><br><span class="line"></span><br><span class="line">redis&gt; HINCRBY myhash string 1              <span class="comment"># 命令执行失败，错误。</span></span><br><span class="line">(error) ERR <span class="built_in">hash</span> value is not an <span class="built_in">integer</span></span><br><span class="line"></span><br><span class="line">redis&gt; HGET myhash string                   <span class="comment"># 原值不变</span></span><br><span class="line"><span class="string">"hello,world"</span></span><br></pre></td></tr></table></figure><h3 id="HINCRBYFLOAT"><a href="#HINCRBYFLOAT" class="headerlink" title="HINCRBYFLOAT"></a>HINCRBYFLOAT</h3><h4 id="HINCRBYFLOAT-key-field-increment"><a href="#HINCRBYFLOAT-key-field-increment" class="headerlink" title="HINCRBYFLOAT key field increment"></a>HINCRBYFLOAT key field increment</h4><pre><code>可用版本：&gt;= 2.6.0
时间复杂度：O(1)
</code></pre><p>为哈希表 key 中的域 field 加上浮点数增量 increment 。</p><p>如果哈希表中没有域 field ，那么 HINCRBYFLOAT 会先将域 field 的值设为 0 ，然后再执行加法操作。</p><p>如果键 key 不存在，那么 HINCRBYFLOAT 会先创建一个哈希表，再创建域 field ，最后再执行加法操作。</p><p>当以下任意一个条件发生时，返回一个错误：</p><ul><li>域 field 的值不是字符串类型(因为 redis 中的数字和浮点数都以字符串的形式保存，所以它们都属于字符串类型）</li><li>域 field 当前的值或给定的增量 increment 不能解释(parse)为双精度浮点数(double precision floating point number)</li></ul><h4 id="返回值-25"><a href="#返回值-25" class="headerlink" title="返回值"></a>返回值</h4><p>执行加法操作之后 field 域的值。</p><h4 id="代码示例-24"><a href="#代码示例-24" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 值和增量都是普通小数</span></span><br><span class="line">redis&gt; HSET mykey field 10.50</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; HINCRBYFLOAT mykey field 0.1</span><br><span class="line"><span class="string">"10.6"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 值和增量都是指数符号</span></span><br><span class="line">redis&gt; HSET mykey field 5.0e3</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; HINCRBYFLOAT mykey field 2.0e2</span><br><span class="line"><span class="string">"5200"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对不存在的键执行 HINCRBYFLOAT</span></span><br><span class="line">redis&gt; EXISTS price</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; HINCRBYFLOAT price milk 3.5</span><br><span class="line"><span class="string">"3.5"</span></span><br><span class="line">redis&gt; HGETALL price</span><br><span class="line">1) <span class="string">"milk"</span></span><br><span class="line">2) <span class="string">"3.5"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对不存在的域进行 HINCRBYFLOAT</span></span><br><span class="line">redis&gt; HGETALL price</span><br><span class="line">1) <span class="string">"milk"</span></span><br><span class="line">2) <span class="string">"3.5"</span></span><br><span class="line">redis&gt; HINCRBYFLOAT price coffee 4.5   <span class="comment"># 新增 coffee 域</span></span><br><span class="line"><span class="string">"4.5"</span></span><br><span class="line">redis&gt; HGETALL price</span><br><span class="line">1) <span class="string">"milk"</span></span><br><span class="line">2) <span class="string">"3.5"</span></span><br><span class="line">3) <span class="string">"coffee"</span></span><br><span class="line">4) <span class="string">"4.5"</span></span><br></pre></td></tr></table></figure><h3 id="HMSET"><a href="#HMSET" class="headerlink" title="HMSET"></a>HMSET</h3><h4 id="HMSET-key-field-value-field-value-…"><a href="#HMSET-key-field-value-field-value-…" class="headerlink" title="HMSET key field value [field value …]"></a>HMSET key field value [field value …]</h4><pre><code>可用版本：&gt;= 2.0.0
时间复杂度：O(N)， N 为 field-value 对的数量。
</code></pre><p>同时将多个 field-value (域-值)对设置到哈希表 key 中。</p><p>此命令会覆盖哈希表中已存在的域。</p><p>如果 key 不存在，一个空哈希表被创建并执行 HMSET 操作。</p><h4 id="返回值-26"><a href="#返回值-26" class="headerlink" title="返回值"></a>返回值</h4><p>如果命令执行成功，返回 OK 。</p><p>当 key 不是哈希表(hash)类型时，返回一个错误。</p><h4 id="代码示例-25"><a href="#代码示例-25" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HMSET website google www.google.com yahoo www.yahoo.com</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; HGET website google</span><br><span class="line"><span class="string">"www.google.com"</span></span><br><span class="line"></span><br><span class="line">redis&gt; HGET website yahoo</span><br><span class="line"><span class="string">"www.yahoo.com"</span></span><br></pre></td></tr></table></figure><h3 id="HMGET"><a href="#HMGET" class="headerlink" title="HMGET"></a>HMGET</h3><h4 id="HMGET-key-field-field-…"><a href="#HMGET-key-field-field-…" class="headerlink" title="HMGET key field [field …]"></a>HMGET key field [field …]</h4><pre><code>可用版本：&gt;= 2.0.0
时间复杂度：O(N)， N 为给定域的数量。
</code></pre><p>返回哈希表 key 中，一个或多个给定域的值。</p><p>如果给定的域不存在于哈希表，那么返回一个 nil 值。</p><p>因为不存在的 key 被当作一个空哈希表来处理，所以对一个不存在的 key 进行 HMGET 操作将返回一个只带有 nil 值的表。</p><h4 id="返回值-27"><a href="#返回值-27" class="headerlink" title="返回值"></a>返回值</h4><p>一个包含多个给定域的关联值的表，表值的排列顺序和给定域参数的请求顺序一样。</p><h4 id="代码示例-26"><a href="#代码示例-26" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HMSET pet dog <span class="string">"doudou"</span> cat <span class="string">"nounou"</span>    <span class="comment"># 一次设置多个域</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; HMGET pet dog cat fake_pet             <span class="comment"># 返回值的顺序和传入参数的顺序一样</span></span><br><span class="line">1) <span class="string">"doudou"</span></span><br><span class="line">2) <span class="string">"nounou"</span></span><br><span class="line">3) (nil)</span><br></pre></td></tr></table></figure><h3 id="HKEYS"><a href="#HKEYS" class="headerlink" title="HKEYS"></a>HKEYS</h3><h4 id="HKEYS-key"><a href="#HKEYS-key" class="headerlink" title="HKEYS key"></a>HKEYS key</h4><pre><code>可用版本：&gt;= 2.0.0
时间复杂度：O(N)， N 为哈希表的大小。
</code></pre><p>返回哈希表 key 中的所有域。</p><h4 id="返回值-28"><a href="#返回值-28" class="headerlink" title="返回值"></a>返回值</h4><p>一个包含哈希表中所有域的表。<br>当 key 不存在时，返回一个空表。</p><h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 哈希表非空</span></span><br><span class="line">redis&gt; HMSET website google www.google.com yahoo www.yahoo.com</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; HKEYS website</span><br><span class="line">1) <span class="string">"google"</span></span><br><span class="line">2) <span class="string">"yahoo"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 空哈希表/key不存在</span></span><br><span class="line">redis&gt; EXISTS fake_key</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; HKEYS fake_key</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br></pre></td></tr></table></figure><h3 id="HVALS"><a href="#HVALS" class="headerlink" title="HVALS"></a>HVALS</h3><h4 id="HVALS-key"><a href="#HVALS-key" class="headerlink" title="HVALS key"></a>HVALS key</h4><pre><code>可用版本：&gt;= 2.0.0
时间复杂度：O(N)， N 为哈希表的大小。
</code></pre><p>返回哈希表 key 中所有域的值。</p><h4 id="返回值-29"><a href="#返回值-29" class="headerlink" title="返回值"></a>返回值</h4><p>一个包含哈希表中所有值的表。</p><p>当 key 不存在时，返回一个空表。</p><h4 id="代码示例-27"><a href="#代码示例-27" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 非空哈希表</span></span><br><span class="line">redis&gt; HMSET website google www.google.com yahoo www.yahoo.com</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; HVALS website</span><br><span class="line">1) <span class="string">"www.google.com"</span></span><br><span class="line">2) <span class="string">"www.yahoo.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 空哈希表/不存在的key</span></span><br><span class="line">redis&gt; EXISTS not_exists</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; HVALS not_exists</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br></pre></td></tr></table></figure><h3 id="HGETALL"><a href="#HGETALL" class="headerlink" title="HGETALL"></a>HGETALL</h3><h4 id="HGETALL-key"><a href="#HGETALL-key" class="headerlink" title="HGETALL key"></a>HGETALL key</h4><pre><code>可用版本：&gt;= 2.0.0
时间复杂度：O(N)， N 为哈希表的大小。
</code></pre><p>返回哈希表 key 中，所有的域和值。</p><p>在返回值里，紧跟每个域名(field name)之后是域的值(value)，所以返回值的长度是哈希表大小的两倍。</p><h4 id="返回值-30"><a href="#返回值-30" class="headerlink" title="返回值"></a>返回值</h4><p>以列表形式返回哈希表的域和域的值。</p><p>若 key 不存在，返回空列表。</p><h4 id="代码示例-28"><a href="#代码示例-28" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSET people jack <span class="string">"Jack Sparrow"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HSET people gump <span class="string">"Forrest Gump"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HGETALL people</span><br><span class="line">1) <span class="string">"jack"</span>          <span class="comment"># 域</span></span><br><span class="line">2) <span class="string">"Jack Sparrow"</span>  <span class="comment"># 值</span></span><br><span class="line">3) <span class="string">"gump"</span></span><br><span class="line">4) <span class="string">"Forrest Gump"</span></span><br></pre></td></tr></table></figure><h3 id="HSCAN"><a href="#HSCAN" class="headerlink" title="HSCAN"></a>HSCAN</h3><h4 id="HSCAN-key-cursor-MATCH-pattern-COUNT-count"><a href="#HSCAN-key-cursor-MATCH-pattern-COUNT-count" class="headerlink" title="HSCAN key cursor [MATCH pattern] [COUNT count]"></a>HSCAN key cursor [MATCH pattern] [COUNT count]</h4><p>具体信息请参考 SCAN cursor [MATCH pattern] [COUNT count] 命令。</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a><a name="列表">列表</a></h2><h3 id="LPUSH"><a href="#LPUSH" class="headerlink" title="LPUSH"></a>LPUSH</h3><h4 id="LPUSH-key-value-value-…"><a href="#LPUSH-key-value-value-…" class="headerlink" title="LPUSH key value [value …]"></a>LPUSH key value [value …]</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度： O(1)
</code></pre><p>将一个或多个值 value 插入到列表 key 的表头</p><p>如果有多个 value 值，那么各个 value 值按从左到右的顺序依次插入到表头： 比如说，对空列表 mylist 执行命令 LPUSH mylist a b c ，列表的值将是 c b a ，这等同于原子性地执行 LPUSH mylist a 、 LPUSH mylist b 和 LPUSH mylist c 三个命令。</p><p>如果 key 不存在，一个空列表会被创建并执行 LPUSH 操作。</p><p>当 key 存在但不是列表类型时，返回一个错误。</p> <font color="red"><strong>Note</strong></font><pre><code>在Redis 2.4版本以前的 LPUSH 命令，都只接受单个 value 值。
</code></pre><h4 id="返回值-31"><a href="#返回值-31" class="headerlink" title="返回值"></a>返回值</h4><p>执行 LPUSH 命令后，列表的长度。</p><h4 id="代码示例-29"><a href="#代码示例-29" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加入单个元素</span></span><br><span class="line">redis&gt; LPUSH languages python</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入重复元素</span></span><br><span class="line">redis&gt; LPUSH languages python</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE languages 0 -1     <span class="comment"># 列表允许重复元素</span></span><br><span class="line">1) <span class="string">"python"</span></span><br><span class="line">2) <span class="string">"python"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入多个元素</span></span><br><span class="line">redis&gt; LPUSH mylist a b c</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">"c"</span></span><br><span class="line">2) <span class="string">"b"</span></span><br><span class="line">3) <span class="string">"a"</span></span><br></pre></td></tr></table></figure><h3 id="LPUSHX"><a href="#LPUSHX" class="headerlink" title="LPUSHX"></a>LPUSHX</h3><h4 id="LPUSHX-key-value"><a href="#LPUSHX-key-value" class="headerlink" title="LPUSHX key value"></a>LPUSHX key value</h4><pre><code>可用版本： &gt;= 2.2.0
时间复杂度： O(1)
</code></pre><p>将值 value 插入到列表 key 的表头，当且仅当 key 存在并且是一个列表。</p><p>和 LPUSH key value [value …] 命令相反，当 key 不存在时， LPUSHX 命令什么也不做。</p><h4 id="返回值-32"><a href="#返回值-32" class="headerlink" title="返回值"></a>返回值</h4><p>LPUSHX 命令执行之后，表的长度。</p><h4 id="代码示例-30"><a href="#代码示例-30" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对空列表执行 LPUSHX</span></span><br><span class="line">redis&gt; LLEN greet                       <span class="comment"># greet 是一个空列表</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; LPUSHX greet <span class="string">"hello"</span>             <span class="comment"># 尝试 LPUSHX，失败，因为列表为空</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对非空列表执行 LPUSHX</span></span><br><span class="line">redis&gt; LPUSH greet <span class="string">"hello"</span>              <span class="comment"># 先用 LPUSH 创建一个有一个元素的列表</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; LPUSHX greet <span class="string">"good morning"</span>      <span class="comment"># 这次 LPUSHX 执行成功</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE greet 0 -1</span><br><span class="line">1) <span class="string">"good morning"</span></span><br><span class="line">2) <span class="string">"hello"</span></span><br></pre></td></tr></table></figure><h3 id="RPUSH"><a href="#RPUSH" class="headerlink" title="RPUSH"></a>RPUSH</h3><h4 id="RPUSH-key-value-value-…"><a href="#RPUSH-key-value-value-…" class="headerlink" title="RPUSH key value [value …]"></a>RPUSH key value [value …]</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度： O(1)
</code></pre><p>将一个或多个值 value 插入到列表 key 的表尾(最右边)。</p><p>如果有多个 value 值，那么各个 value 值按从左到右的顺序依次插入到表尾：比如对一个空列表 mylist 执行 RPUSH mylist a b c ，得出的结果列表为 a b c ，等同于执行命令 RPUSH mylist a 、 RPUSH mylist b 、 RPUSH mylist c 。</p><p>如果 key 不存在，一个空列表会被创建并执行 RPUSH 操作。</p><p>当 key 存在但不是列表类型时，返回一个错误。</p> <font color="red"><strong>Note</strong></font><pre><code>在 Redis 2.4 版本以前的 RPUSH 命令，都只接受单个 value 值。
</code></pre><h4 id="返回值-33"><a href="#返回值-33" class="headerlink" title="返回值"></a>返回值</h4><p>执行 RPUSH 操作后，表的长度。</p><h4 id="代码示例-31"><a href="#代码示例-31" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加单个元素</span></span><br><span class="line">redis&gt; RPUSH languages c</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加重复元素</span></span><br><span class="line">redis&gt; RPUSH languages c</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE languages 0 -1 <span class="comment"># 列表允许重复元素</span></span><br><span class="line">1) <span class="string">"c"</span></span><br><span class="line">2) <span class="string">"c"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加多个元素</span></span><br><span class="line">redis&gt; RPUSH mylist a b c</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">"a"</span></span><br><span class="line">2) <span class="string">"b"</span></span><br><span class="line">3) <span class="string">"c"</span></span><br></pre></td></tr></table></figure><h3 id="RPUSHX"><a href="#RPUSHX" class="headerlink" title="RPUSHX"></a>RPUSHX</h3><h4 id="RPUSHX-key-value"><a href="#RPUSHX-key-value" class="headerlink" title="RPUSHX key value"></a>RPUSHX key value</h4><pre><code>可用版本： &gt;= 2.2.0
时间复杂度： O(1)
</code></pre><p>将值 value 插入到列表 key 的表尾，当且仅当 key 存在并且是一个列表。</p><p>和 RPUSH key value [value …] 命令相反，当 key 不存在时， RPUSHX 命令什么也不做。</p><h4 id="返回值-34"><a href="#返回值-34" class="headerlink" title="返回值"></a>返回值</h4><p>RPUSHX 命令执行之后，表的长度。</p><h4 id="代码示例-32"><a href="#代码示例-32" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># key不存在</span></span><br><span class="line">redis&gt; LLEN greet</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSHX greet <span class="string">"hello"</span>     <span class="comment"># 对不存在的 key 进行 RPUSHX，PUSH 失败。</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># key 存在且是一个非空列表</span></span><br><span class="line">redis&gt; RPUSH greet <span class="string">"hi"</span>         <span class="comment"># 先用 RPUSH 插入一个元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSHX greet <span class="string">"hello"</span>     <span class="comment"># greet 现在是一个列表类型，RPUSHX 操作成功。</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE greet 0 -1</span><br><span class="line">1) <span class="string">"hi"</span></span><br><span class="line">2) <span class="string">"hello"</span></span><br></pre></td></tr></table></figure><h3 id="LPOP"><a href="#LPOP" class="headerlink" title="LPOP"></a>LPOP</h3><h4 id="LPOP-key"><a href="#LPOP-key" class="headerlink" title="LPOP key"></a>LPOP key</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度： O(1)
</code></pre><p>移除并返回列表 key 的头元素。</p><h4 id="返回值-35"><a href="#返回值-35" class="headerlink" title="返回值"></a>返回值</h4><p>列表的头元素。 当 key 不存在时，返回 nil 。</p><h4 id="代码示例-33"><a href="#代码示例-33" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; LLEN course</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH course algorithm001</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH course c++101</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; LPOP course  <span class="comment"># 移除头元素</span></span><br><span class="line"><span class="string">"algorithm001"</span></span><br></pre></td></tr></table></figure><h3 id="RPOP"><a href="#RPOP" class="headerlink" title="RPOP"></a>RPOP</h3><h4 id="RPOP-key"><a href="#RPOP-key" class="headerlink" title="RPOP key"></a>RPOP key</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度： O(1)
</code></pre><p>移除并返回列表 key 的尾元素。</p><h4 id="返回值-36"><a href="#返回值-36" class="headerlink" title="返回值"></a>返回值</h4><p>列表的尾元素。 当 key 不存在时，返回 nil 。</p><h4 id="代码示例-34"><a href="#代码示例-34" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; RPUSH mylist <span class="string">"one"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH mylist <span class="string">"two"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH mylist <span class="string">"three"</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis&gt; RPOP mylist           <span class="comment"># 返回被弹出的元素</span></span><br><span class="line"><span class="string">"three"</span></span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE mylist 0 -1    <span class="comment"># 列表剩下的元素</span></span><br><span class="line">1) <span class="string">"one"</span></span><br><span class="line">2) <span class="string">"two"</span></span><br></pre></td></tr></table></figure><h3 id="RPOPLPUSH"><a href="#RPOPLPUSH" class="headerlink" title="RPOPLPUSH"></a>RPOPLPUSH</h3><h4 id="RPOPLPUSH-source-destination"><a href="#RPOPLPUSH-source-destination" class="headerlink" title="RPOPLPUSH source destination"></a>RPOPLPUSH source destination</h4><pre><code>可用版本： &gt;= 1.2.0
时间复杂度： O(1)
</code></pre><p>命令 RPOPLPUSH 在一个原子时间内，执行以下两个动作：</p><p>将列表 source 中的最后一个元素(尾元素)弹出，并返回给客户端。</p><p>将 source 弹出的元素插入到列表 destination ，作为 destination 列表的的头元素。</p><p>举个例子，你有两个列表 source 和 destination ， source 列表有元素 a, b, c ， destination 列表有元素 x, y, z ，执行 RPOPLPUSH source destination 之后， source 列表包含元素 a, b ， destination 列表包含元素 c, x, y, z ，并且元素 c 会被返回给客户端。</p><p>如果 source 不存在，值 nil 被返回，并且不执行其他动作。</p><p>如果 source 和 destination 相同，则列表中的表尾元素被移动到表头，并返回该元素，可以把这种特殊情况视作列表的旋转(rotation)操作。</p><h4 id="返回值-37"><a href="#返回值-37" class="headerlink" title="返回值"></a>返回值</h4><p>被弹出的元素。</p><h4 id="代码示例-35"><a href="#代码示例-35" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># source 和 destination 不同</span></span><br><span class="line">redis&gt; LRANGE alpha 0 -1         <span class="comment"># 查看所有元素</span></span><br><span class="line">1) <span class="string">"a"</span></span><br><span class="line">2) <span class="string">"b"</span></span><br><span class="line">3) <span class="string">"c"</span></span><br><span class="line">4) <span class="string">"d"</span></span><br><span class="line"></span><br><span class="line">redis&gt; RPOPLPUSH alpha reciver   <span class="comment"># 执行一次 RPOPLPUSH 看看</span></span><br><span class="line"><span class="string">"d"</span></span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE alpha 0 -1</span><br><span class="line">1) <span class="string">"a"</span></span><br><span class="line">2) <span class="string">"b"</span></span><br><span class="line">3) <span class="string">"c"</span></span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE reciver 0 -1</span><br><span class="line">1) <span class="string">"d"</span></span><br><span class="line"></span><br><span class="line">redis&gt; RPOPLPUSH alpha reciver   <span class="comment"># 再执行一次，证实 RPOP 和 LPUSH 的位置正确</span></span><br><span class="line"><span class="string">"c"</span></span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE alpha 0 -1</span><br><span class="line">1) <span class="string">"a"</span></span><br><span class="line">2) <span class="string">"b"</span></span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE reciver 0 -1</span><br><span class="line">1) <span class="string">"c"</span></span><br><span class="line">2) <span class="string">"d"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># source 和 destination 相同</span></span><br><span class="line">redis&gt; LRANGE number 0 -1</span><br><span class="line">1) <span class="string">"1"</span></span><br><span class="line">2) <span class="string">"2"</span></span><br><span class="line">3) <span class="string">"3"</span></span><br><span class="line">4) <span class="string">"4"</span></span><br><span class="line"></span><br><span class="line">redis&gt; RPOPLPUSH number number</span><br><span class="line"><span class="string">"4"</span></span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE number 0 -1           <span class="comment"># 4 被旋转到了表头</span></span><br><span class="line">1) <span class="string">"4"</span></span><br><span class="line">2) <span class="string">"1"</span></span><br><span class="line">3) <span class="string">"2"</span></span><br><span class="line">4) <span class="string">"3"</span></span><br><span class="line"></span><br><span class="line">redis&gt; RPOPLPUSH number number</span><br><span class="line"><span class="string">"3"</span></span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE number 0 -1           <span class="comment"># 这次是 3 被旋转到了表头</span></span><br><span class="line">1) <span class="string">"3"</span></span><br><span class="line">2) <span class="string">"4"</span></span><br><span class="line">3) <span class="string">"1"</span></span><br><span class="line">4) <span class="string">"2"</span></span><br></pre></td></tr></table></figure><h4 id="模式：-安全的队列"><a href="#模式：-安全的队列" class="headerlink" title="模式： 安全的队列"></a>模式： 安全的队列</h4><p>Redis的列表经常被用作队列(queue)，用于在不同程序之间有序地交换消息(message)。一个客户端通过 LPUSH key value [value …] 命令将消息放入队列中，而另一个客户端通过 RPOP key 或者 BRPOP key [key …] timeout 命令取出队列中等待时间最长的消息。</p><p>不幸的是，上面的队列方法是『不安全』的，因为在这个过程中，一个客户端可能在取出一个消息之后崩溃，而未处理完的消息也就因此丢失。</p><p>使用 RPOPLPUSH 命令(或者它的阻塞版本 BRPOPLPUSH source destination timeout )可以解决这个问题：因为它不仅返回一个消息，同时还将这个消息添加到另一个备份列表当中，如果一切正常的话，当一个客户端完成某个消息的处理之后，可以用 LREM key count value 命令将这个消息从备份表删除。</p><p>最后，还可以添加一个客户端专门用于监视备份表，它自动地将超过一定处理时限的消息重新放入队列中去(负责处理该消息的客户端可能已经崩溃)，这样就不会丢失任何消息了。</p><h4 id="模式：循环列表"><a href="#模式：循环列表" class="headerlink" title="模式：循环列表"></a>模式：循环列表</h4><p>通过使用相同的 key 作为 RPOPLPUSH 命令的两个参数，客户端可以用一个接一个地获取列表元素的方式，取得列表的所有元素，而不必像 LRANGE key start stop 命令那样一下子将所有列表元素都从服务器传送到客户端中(两种方式的总复杂度都是 O(N))。</p><p>以上的模式甚至在以下的两个情况下也能正常工作：</p><ul><li>有多个客户端同时对同一个列表进行旋转(rotating)，它们获取不同的元素，直到所有元素都被读取完，之后又从头开始。</li><li>有客户端在向列表尾部(右边)添加新元素。</li></ul><p>这个模式使得我们可以很容易实现这样一类系统：有 N 个客户端，需要连续不断地对一些元素进行处理，而且处理的过程必须尽可能地快。一个典型的例子就是服务器的监控程序：它们需要在尽可能短的时间内，并行地检查一组网站，确保它们的可访问性。</p><p>注意，使用这个模式的客户端是易于扩展(scala)且安全(reliable)的，因为就算接收到元素的客户端失败，元素还是保存在列表里面，不会丢失，等到下个迭代来临的时候，别的客户端又可以继续处理这些元素了。</p><h3 id="LREM"><a href="#LREM" class="headerlink" title="LREM"></a>LREM</h3><h4 id="LREM-key-count-value"><a href="#LREM-key-count-value" class="headerlink" title="LREM key count value"></a>LREM key count value</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度： O(N)， N 为列表的长度。
</code></pre><p>根据参数 count 的值，移除列表中与参数 value 相等的元素。</p><p>count 的值可以是以下几种：</p><ul><li>count &gt; 0 : 从表头开始向表尾搜索，移除与 value 相等的元素，数量为 count 。</li><li>count &lt; 0 : 从表尾开始向表头搜索，移除与 value 相等的元素，数量为 count 的绝对值。</li><li>count = 0 : 移除表中所有与 value 相等的值。</li></ul><h4 id="返回值-38"><a href="#返回值-38" class="headerlink" title="返回值"></a>返回值</h4><p>被移除元素的数量。 因为不存在的 key 被视作空表(empty list)，所以当 key 不存在时， LREM 命令总是返回 0 。</p><h4 id="代码示例-36"><a href="#代码示例-36" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先创建一个表，内容排列是</span></span><br><span class="line"><span class="comment"># morning hello morning helllo morning</span></span><br><span class="line">redis&gt; LPUSH greet <span class="string">"morning"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; LPUSH greet <span class="string">"hello"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis&gt; LPUSH greet <span class="string">"morning"</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">redis&gt; LPUSH greet <span class="string">"hello"</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">redis&gt; LPUSH greet <span class="string">"morning"</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE greet 0 4         <span class="comment"># 查看所有元素</span></span><br><span class="line">1) <span class="string">"morning"</span></span><br><span class="line">2) <span class="string">"hello"</span></span><br><span class="line">3) <span class="string">"morning"</span></span><br><span class="line">4) <span class="string">"hello"</span></span><br><span class="line">5) <span class="string">"morning"</span></span><br><span class="line"></span><br><span class="line">redis&gt; LREM greet 2 morning     <span class="comment"># 移除从表头到表尾，最先发现的两个 morning</span></span><br><span class="line">(<span class="built_in">integer</span>) 2                     <span class="comment"># 两个元素被移除</span></span><br><span class="line"></span><br><span class="line">redis&gt; LLEN greet               <span class="comment"># 还剩 3 个元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE greet 0 2</span><br><span class="line">1) <span class="string">"hello"</span></span><br><span class="line">2) <span class="string">"hello"</span></span><br><span class="line">3) <span class="string">"morning"</span></span><br><span class="line"></span><br><span class="line">redis&gt; LREM greet -1 morning    <span class="comment"># 移除从表尾到表头，第一个 morning</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; LLEN greet               <span class="comment"># 剩下两个元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE greet 0 1</span><br><span class="line">1) <span class="string">"hello"</span></span><br><span class="line">2) <span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line">redis&gt; LREM greet 0 hello      <span class="comment"># 移除表中所有 hello</span></span><br><span class="line">(<span class="built_in">integer</span>) 2                    <span class="comment"># 两个 hello 被移除</span></span><br><span class="line"></span><br><span class="line">redis&gt; LLEN greet</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><h3 id="LLEN"><a href="#LLEN" class="headerlink" title="LLEN"></a>LLEN</h3><h4 id="LLEN-key"><a href="#LLEN-key" class="headerlink" title="LLEN key"></a>LLEN key</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度： O(1)
</code></pre><p>返回列表 key 的长度。</p><p>如果 key 不存在，则 key 被解释为一个空列表，返回 0 .</p><p>如果 key 不是列表类型，返回一个错误。</p><h4 id="返回值-39"><a href="#返回值-39" class="headerlink" title="返回值"></a>返回值</h4><p>列表 key 的长度。</p><h4 id="代码示例-37"><a href="#代码示例-37" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 空列表</span></span><br><span class="line">redis&gt; LLEN job</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 非空列表</span></span><br><span class="line">redis&gt; LPUSH job <span class="string">"cook food"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; LPUSH job <span class="string">"have lunch"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; LLEN job</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure><h3 id="LINDEX"><a href="#LINDEX" class="headerlink" title="LINDEX"></a>LINDEX</h3><h4 id="LINDEX-key-index"><a href="#LINDEX-key-index" class="headerlink" title="LINDEX key index"></a>LINDEX key index</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度：O(N)， N 为到达下标 index 过程中经过的元素数量。因此，对列表的头元素和尾元素执行 LINDEX 命令，复杂度为O(1)。
</code></pre><p>返回列表 key 中，下标为 index 的元素。</p><p>下标(index)参数 start 和 stop 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。</p><p>你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</p><p>如果 key 不是列表类型，返回一个错误。</p><h4 id="返回值-40"><a href="#返回值-40" class="headerlink" title="返回值"></a>返回值</h4><p>列表中下标为 index 的元素。 如果 index 参数的值不在列表的区间范围内(out of range)，返回 nil 。</p><h4 id="代码示例-38"><a href="#代码示例-38" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; LPUSH mylist <span class="string">"World"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; LPUSH mylist <span class="string">"Hello"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; LINDEX mylist 0</span><br><span class="line"><span class="string">"Hello"</span></span><br><span class="line"></span><br><span class="line">redis&gt; LINDEX mylist -1</span><br><span class="line"><span class="string">"World"</span></span><br><span class="line"></span><br><span class="line">redis&gt; LINDEX mylist 3        <span class="comment"># index不在 mylist 的区间范围内</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h3 id="LINSERT"><a href="#LINSERT" class="headerlink" title="LINSERT"></a>LINSERT</h3><h4 id="LINSERT-key-BEFORE-AFTER-pivot-value"><a href="#LINSERT-key-BEFORE-AFTER-pivot-value" class="headerlink" title="LINSERT key BEFORE|AFTER pivot value"></a>LINSERT key BEFORE|AFTER pivot value</h4><pre><code>可用版本： &gt;= 2.2.0
时间复杂度: O(N)， N 为寻找 pivot 过程中经过的元素数量。
</code></pre><p>将值 value 插入到列表 key 当中，位于值 pivot 之前或之后。</p><p>当 pivot 不存在于列表 key 时，不执行任何操作。</p><p>当 key 不存在时， key 被视为空列表，不执行任何操作。</p><p>如果 key 不是列表类型，返回一个错误。</p><h4 id="返回值-41"><a href="#返回值-41" class="headerlink" title="返回值"></a>返回值</h4><p>如果命令执行成功，返回插入操作完成之后，列表的长度。 如果没有找到 pivot ，返回 -1 。 如果 key 不存在或为空列表，返回 0 。</p><h4 id="代码示例-39"><a href="#代码示例-39" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; RPUSH mylist <span class="string">"Hello"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH mylist <span class="string">"World"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; LINSERT mylist BEFORE <span class="string">"World"</span> <span class="string">"There"</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">"Hello"</span></span><br><span class="line">2) <span class="string">"There"</span></span><br><span class="line">3) <span class="string">"World"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对一个非空列表插入，查找一个不存在的 pivot</span></span><br><span class="line">redis&gt; LINSERT mylist BEFORE <span class="string">"go"</span> <span class="string">"let's"</span></span><br><span class="line">(<span class="built_in">integer</span>) -1                                    <span class="comment"># 失败</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对一个空列表执行 LINSERT 命令</span></span><br><span class="line">redis&gt; EXISTS fake_list</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; LINSERT fake_list BEFORE <span class="string">"nono"</span> <span class="string">"gogogog"</span></span><br><span class="line">(<span class="built_in">integer</span>) 0                                      <span class="comment"># 失败</span></span><br></pre></td></tr></table></figure><h3 id="LSET"><a href="#LSET" class="headerlink" title="LSET"></a>LSET</h3><h4 id="LSET-key-index-value"><a href="#LSET-key-index-value" class="headerlink" title="LSET key index value"></a>LSET key index value</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度：对头元素或尾元素进行 LSET 操作，复杂度为 O(1)。其他情况下，为 O(N)， N 为列表的长度。
</code></pre><p>将列表 key 下标为 index 的元素的值设置为 value 。</p><p>当 index 参数超出范围，或对一个空列表( key 不存在)进行 LSET 时，返回一个错误。</p><p>关于列表下标的更多信息，请参考 LINDEX key index 命令。</p><h4 id="返回值-42"><a href="#返回值-42" class="headerlink" title="返回值"></a>返回值</h4><p>操作成功返回 ok ，否则返回错误信息。</p><h4 id="代码示例-40"><a href="#代码示例-40" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对空列表(key 不存在)进行 LSET</span></span><br><span class="line">redis&gt; EXISTS list</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; LSET list 0 item</span><br><span class="line">(error) ERR no such key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对非空列表进行 LSET</span></span><br><span class="line">redis&gt; LPUSH job <span class="string">"cook food"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE job 0 0</span><br><span class="line">1) <span class="string">"cook food"</span></span><br><span class="line"></span><br><span class="line">redis&gt; LSET job 0 <span class="string">"play game"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE job  0 0</span><br><span class="line">1) <span class="string">"play game"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># index 超出范围</span></span><br><span class="line">redis&gt; LLEN list                    <span class="comment"># 列表长度为 1</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; LSET list 3 <span class="string">'out of range'</span></span><br><span class="line">(error) ERR index out of range</span><br></pre></td></tr></table></figure><h3 id="LRANGE"><a href="#LRANGE" class="headerlink" title="LRANGE"></a>LRANGE</h3><h4 id="LRANGE-key-start-stop"><a href="#LRANGE-key-start-stop" class="headerlink" title="LRANGE key start stop"></a>LRANGE key start stop</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度: O(S+N)， S 为偏移量 start ， N 为指定区间内元素的数量。
</code></pre><p>返回列表 key 中指定区间内的元素，区间以偏移量 start 和 stop 指定。</p><p>下标(index)参数 start 和 stop 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。</p><p>你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</p><p><strong>注意LRANGE命令和编程语言区间函数的区别</strong></p><pre><code>假如你有一个包含一百个元素的列表，对该列表执行 LRANGE list 0 10 ，结果是一个包含11个元素的列表，这表明 stop 下标也在 LRANGE 命令的取值范围之内(闭区间)，这和某些语言的区间函数可能不一致，比如Ruby的 Range.new 、 Array#slice 和Python的 range() 函数。
</code></pre><p><strong>超出范围的下标</strong></p><pre><code>超出范围的下标值不会引起错误。
</code></pre><p>如果 start 下标比列表的最大下标 end ( LLEN list 减去 1 )还要大，那么 LRANGE 返回一个空列表。</p><p>如果 stop 下标比 end 下标还要大，Redis将 stop 的值设置为 end 。</p><h4 id="返回值-43"><a href="#返回值-43" class="headerlink" title="返回值"></a>返回值</h4><p>一个列表，包含指定区间内的元素。</p><h4 id="代码示例-41"><a href="#代码示例-41" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; RPUSH fp-language lisp</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE fp-language 0 0</span><br><span class="line">1) <span class="string">"lisp"</span></span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH fp-language scheme</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE fp-language 0 1</span><br><span class="line">1) <span class="string">"lisp"</span></span><br><span class="line">2) <span class="string">"scheme"</span></span><br></pre></td></tr></table></figure><h3 id="LTRIM"><a href="#LTRIM" class="headerlink" title="LTRIM"></a>LTRIM</h3><h4 id="LTRIM-key-start-stop"><a href="#LTRIM-key-start-stop" class="headerlink" title="LTRIM key start stop"></a>LTRIM key start stop</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度: O(N)， N 为被移除的元素的数量。
</code></pre><p>对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</p><pre><code>举个例子，执行命令 LTRIM list 0 2 ，表示只保留列表 list 的前三个元素，其余元素全部删除。
</code></pre><p>下标(index)参数 start 和 stop 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。</p><p>你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</p><p>当 key 不是列表类型时，返回一个错误。</p><p>LTRIM 命令通常和 LPUSH key value [value …] 命令或 RPUSH key value [value …] 命令配合使用，举个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">LPUSH <span class="built_in">log</span> newest_log</span><br><span class="line">LTRIM <span class="built_in">log</span> 0 99</span><br><span class="line">```bash</span><br><span class="line"></span><br><span class="line">这个例子模拟了一个日志程序，每次将最新日志 newest_log 放到 <span class="built_in">log</span> 列表中，并且只保留最新的 100 项。注意当这样使用 LTRIM 命令时，时间复杂度是O(1)，因为平均情况下，每次只有一个元素被移除。</span><br><span class="line"></span><br><span class="line">**注意LTRIM命令和编程语言区间函数的区别**</span><br><span class="line"></span><br><span class="line">    假如你有一个包含一百个元素的列表 list ，对该列表执行 LTRIM list 0 10 ，结果是一个包含11个元素的列表，这表明 stop 下标也在 LTRIM 命令的取值范围之内(闭区间)，这和某些语言的区间函数可能不一致，比如Ruby的 Range.new 、 Array<span class="comment">#slice 和Python的 range() 函数。</span></span><br><span class="line"></span><br><span class="line">**超出范围的下标**</span><br><span class="line"></span><br><span class="line">    超出范围的下标值不会引起错误。</span><br><span class="line"></span><br><span class="line">如果 start 下标比列表的最大下标 end ( LLEN list 减去 1 )还要大，或者 start &gt; stop ， LTRIM 返回一个空列表(因为 LTRIM 已经将整个列表清空)。</span><br><span class="line"></span><br><span class="line">如果 stop 下标比 end 下标还要大，Redis将 stop 的值设置为 end 。</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 返回值</span></span><br><span class="line">命令执行成功时，返回 ok 。</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 代码示例</span></span><br><span class="line">```bash</span><br><span class="line"><span class="comment"># 情况 1： 常见情况， start 和 stop 都在列表的索引范围之内</span></span><br><span class="line">redis&gt; LRANGE alpha 0 -1       <span class="comment"># alpha 是一个包含 5 个字符串的列表</span></span><br><span class="line">1) <span class="string">"h"</span></span><br><span class="line">2) <span class="string">"e"</span></span><br><span class="line">3) <span class="string">"l"</span></span><br><span class="line">4) <span class="string">"l"</span></span><br><span class="line">5) <span class="string">"o"</span></span><br><span class="line"></span><br><span class="line">redis&gt; LTRIM alpha 1 -1        <span class="comment"># 删除 alpha 列表索引为 0 的元素</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE alpha 0 -1       <span class="comment"># "h" 被删除了</span></span><br><span class="line">1) <span class="string">"e"</span></span><br><span class="line">2) <span class="string">"l"</span></span><br><span class="line">3) <span class="string">"l"</span></span><br><span class="line">4) <span class="string">"o"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 情况 2： stop 比列表的最大下标还要大</span></span><br><span class="line">redis&gt; LTRIM alpha 1 10086     <span class="comment"># 保留 alpha 列表索引 1 至索引 10086 上的元素</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE alpha 0 -1       <span class="comment"># 只有索引 0 上的元素 "e" 被删除了，其他元素还在</span></span><br><span class="line">1) <span class="string">"l"</span></span><br><span class="line">2) <span class="string">"l"</span></span><br><span class="line">3) <span class="string">"o"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 情况 3： start 和 stop 都比列表的最大下标要大，并且 start &lt; stop</span></span><br><span class="line">redis&gt; LTRIM alpha 10086 123321</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE alpha 0 -1        <span class="comment"># 列表被清空</span></span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 情况 4： start 和 stop 都比列表的最大下标要大，并且 start &gt; stop</span></span><br><span class="line">redis&gt; RPUSH new-alpha <span class="string">"h"</span> <span class="string">"e"</span> <span class="string">"l"</span> <span class="string">"l"</span> <span class="string">"o"</span>     <span class="comment"># 重新建立一个新列表</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE new-alpha 0 -1</span><br><span class="line">1) <span class="string">"h"</span></span><br><span class="line">2) <span class="string">"e"</span></span><br><span class="line">3) <span class="string">"l"</span></span><br><span class="line">4) <span class="string">"l"</span></span><br><span class="line">5) <span class="string">"o"</span></span><br><span class="line"></span><br><span class="line">redis&gt; LTRIM new-alpha 123321 10086    <span class="comment"># 执行 LTRIM</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE new-alpha 0 -1           <span class="comment"># 同样被清空</span></span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br></pre></td></tr></table></figure><h3 id="BLPOP"><a href="#BLPOP" class="headerlink" title="BLPOP"></a>BLPOP</h3><h4 id="BLPOP-key-key-…-timeout"><a href="#BLPOP-key-key-…-timeout" class="headerlink" title="BLPOP key [key …] timeout"></a>BLPOP key [key …] timeout</h4><pre><code>可用版本： &gt;= 2.0.0
时间复杂度： O(1)
</code></pre><p>BLPOP 是列表的阻塞式(blocking)弹出原语。</p><p>它是 LPOP key 命令的阻塞版本，当给定列表内没有任何元素可供弹出的时候，连接将被 BLPOP 命令阻塞，直到等待超时或发现可弹出元素为止。</p><p>当给定多个 key 参数时，按参数 key 的先后顺序依次检查各个列表，弹出第一个非空列表的头元素。</p><h4 id="非阻塞行为"><a href="#非阻塞行为" class="headerlink" title="非阻塞行为"></a>非阻塞行为</h4><p>当 BLPOP 被调用时，如果给定 key 内至少有一个非空列表，那么弹出遇到的第一个非空列表的头元素，并和被弹出元素所属的列表的名字一起，组成结果返回给调用者。</p><p>当存在多个给定 key 时， BLPOP 按给定 key 参数排列的先后顺序，依次检查各个列表。</p><p>假设现在有 job 、 command 和 request 三个列表，其中 job 不存在， command 和 request 都持有非空列表。考虑以下命令：</p><p>BLPOP job command request 0</p><p>BLPOP 保证返回的元素来自 command ，因为它是按”查找 job -&gt; 查找 command -&gt; 查找 request “这样的顺序，第一个找到的非空列表。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; DEL job <span class="built_in">command</span> request           <span class="comment"># 确保key都被删除</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; LPUSH <span class="built_in">command</span> <span class="string">"update system..."</span>  <span class="comment"># 为command列表增加一个值</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; LPUSH request <span class="string">"visit page"</span>        <span class="comment"># 为request列表增加一个值</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; BLPOP job <span class="built_in">command</span> request 0       <span class="comment"># job 列表为空，被跳过，紧接着 command 列表的第一个元素被弹出。</span></span><br><span class="line">1) <span class="string">"command"</span>                             <span class="comment"># 弹出元素所属的列表</span></span><br><span class="line">2) <span class="string">"update system..."</span>                    <span class="comment"># 弹出元素所属的值</span></span><br></pre></td></tr></table></figure><h4 id="阻塞行为"><a href="#阻塞行为" class="headerlink" title="阻塞行为"></a>阻塞行为</h4><p>如果所有给定 key 都不存在或包含空列表，那么 BLPOP 命令将阻塞连接，直到等待超时，或有另一个客户端对给定 key 的任意一个执行 LPUSH key value [value …] 或 RPUSH key value [value …] 命令为止。</p><p>超时参数 timeout 接受一个以秒为单位的数字作为值。超时参数设为 0 表示阻塞时间可以无限期延长(block indefinitely) 。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; EXISTS job                <span class="comment"># 确保两个 key 都不存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; EXISTS <span class="built_in">command</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; BLPOP job <span class="built_in">command</span> 300     <span class="comment"># 因为key一开始不存在，所以操作会被阻塞，直到另一客户端对 job 或者 command 列表进行 PUSH 操作。</span></span><br><span class="line">1) <span class="string">"job"</span>                         <span class="comment"># 这里被 push 的是 job</span></span><br><span class="line">2) <span class="string">"do my home work"</span>             <span class="comment"># 被弹出的值</span></span><br><span class="line">(26.26s)                         <span class="comment"># 等待的秒数</span></span><br><span class="line"></span><br><span class="line">redis&gt; BLPOP job <span class="built_in">command</span> 5       <span class="comment"># 等待超时的情况</span></span><br><span class="line">(nil)</span><br><span class="line">(5.66s)                          <span class="comment"># 等待的秒数</span></span><br></pre></td></tr></table></figure><p></p><p>相同的key被多个客户端同时阻塞</p><pre><code>相同的 key 可以被多个客户端同时阻塞。
</code></pre><p>不同的客户端被放进一个队列中，按『先阻塞先服务』(first-BLPOP，first-served)的顺序为 key 执行 BLPOP 命令。</p><h4 id="在MULTI-EXEC事务中的BLPOP"><a href="#在MULTI-EXEC事务中的BLPOP" class="headerlink" title="在MULTI/EXEC事务中的BLPOP"></a>在MULTI/EXEC事务中的BLPOP</h4><p>BLPOP 可以用于流水线(pipline,批量地发送多个命令并读入多个回复)，但把它用在 MULTI / EXEC 块当中没有意义。因为这要求整个服务器被阻塞以保证块执行时的原子性，该行为阻止了其他客户端执行 LPUSH key value [value …] 或 RPUSH key value [value …] 命令。</p><p>因此，一个被包裹在 MULTI / EXEC 块内的 BLPOP 命令，行为表现得就像 LPOP key 一样，对空列表返回 nil ，对非空列表弹出列表元素，不进行任何阻塞操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对非空列表进行操作</span></span><br><span class="line">redis&gt; RPUSH job programming</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; BLPOP job 30</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; EXEC           <span class="comment"># 不阻塞，立即返回</span></span><br><span class="line">1) 1) <span class="string">"job"</span></span><br><span class="line">   2) <span class="string">"programming"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对空列表进行操作</span></span><br><span class="line">redis&gt; LLEN job      <span class="comment"># 空列表</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; BLPOP job 30</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; EXEC         <span class="comment"># 不阻塞，立即返回</span></span><br><span class="line">1) (nil)</span><br></pre></td></tr></table></figure><h4 id="返回值-44"><a href="#返回值-44" class="headerlink" title="返回值"></a>返回值</h4><p>如果列表为空，返回一个 nil 。 否则，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 key ，第二个元素是被弹出元素的值。</p><h4 id="模式：事件提醒"><a href="#模式：事件提醒" class="headerlink" title="模式：事件提醒"></a>模式：事件提醒</h4><p>有时候，为了等待一个新元素到达数据中，需要使用轮询的方式对数据进行探查。</p><p>另一种更好的方式是，使用系统提供的阻塞原语，在新元素到达时立即进行处理，而新元素还没到达时，就一直阻塞住，避免轮询占用资源。</p><p>对于 Redis ，我们似乎需要一个阻塞版的 SPOP key 命令，但实际上，使用 BLPOP 或者 BRPOP key [key …] timeout 就能很好地解决这个问题。</p><p>使用元素的客户端(消费者)可以执行类似以下的代码：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LOOP forever</span><br><span class="line">    WHILE SPOP(key) returns elements</span><br><span class="line">        ... process elements ...</span><br><span class="line">    END</span><br><span class="line">    BRPOP helper_key</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p></p><p>添加元素的客户端(生产者)则执行以下代码：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MULTI</span><br><span class="line">    SADD key element</span><br><span class="line">    LPUSH helper_key x</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure><p></p><h3 id="BRPOP"><a href="#BRPOP" class="headerlink" title="BRPOP"></a>BRPOP</h3><h4 id="BRPOP-key-key-…-timeout"><a href="#BRPOP-key-key-…-timeout" class="headerlink" title="BRPOP key [key …] timeout"></a>BRPOP key [key …] timeout</h4><pre><code>可用版本： &gt;= 2.0.0
时间复杂度： O(1)
</code></pre><p>BRPOP 是列表的阻塞式(blocking)弹出原语。</p><p>它是 RPOP key 命令的阻塞版本，当给定列表内没有任何元素可供弹出的时候，连接将被 BRPOP 命令阻塞，直到等待超时或发现可弹出元素为止。</p><p>当给定多个 key 参数时，按参数 key 的先后顺序依次检查各个列表，弹出第一个非空列表的尾部元素。</p><p>关于阻塞操作的更多信息，请查看 BLPOP key [key …] timeout 命令， BRPOP 除了弹出元素的位置和 BLPOP key [key …] timeout 不同之外，其他表现一致。</p><h4 id="返回值-45"><a href="#返回值-45" class="headerlink" title="返回值"></a>返回值</h4><p>假如在指定时间内没有任何元素被弹出，则返回一个 nil 和等待时长。 反之，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 key ，第二个元素是被弹出元素的值。</p><h4 id="代码示例-42"><a href="#代码示例-42" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; LLEN course</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH course algorithm001</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH course c++101</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; BRPOP course 30</span><br><span class="line">1) <span class="string">"course"</span>             <span class="comment"># 被弹出元素所属的列表键</span></span><br><span class="line">2) <span class="string">"c++101"</span>             <span class="comment"># 被弹出的元素</span></span><br></pre></td></tr></table></figure><h3 id="BRPOPLPUSH"><a href="#BRPOPLPUSH" class="headerlink" title="BRPOPLPUSH"></a>BRPOPLPUSH</h3><h4 id="BRPOPLPUSH-source-destination-timeout"><a href="#BRPOPLPUSH-source-destination-timeout" class="headerlink" title="BRPOPLPUSH source destination timeout"></a>BRPOPLPUSH source destination timeout</h4><pre><code>可用版本： &gt;= 2.2.0
时间复杂度： O(1)
</code></pre><p>BRPOPLPUSH 是 RPOPLPUSH source destination 的阻塞版本，当给定列表 source 不为空时， BRPOPLPUSH 的表现和 RPOPLPUSH source destination 一样。</p><p>当列表 source 为空时， BRPOPLPUSH 命令将阻塞连接，直到等待超时，或有另一个客户端对 source 执行 LPUSH key value [value …] 或 RPUSH key value [value …] 命令为止。</p><p>超时参数 timeout 接受一个以秒为单位的数字作为值。超时参数设为 0 表示阻塞时间可以无限期延长(block indefinitely) 。</p><p>更多相关信息，请参考 RPOPLPUSH source destination 命令。</p><h4 id="返回值-46"><a href="#返回值-46" class="headerlink" title="返回值"></a>返回值</h4><p>假如在指定时间内没有任何元素被弹出，则返回一个 nil 和等待时长。 反之，返回一个含有两个元素的列表，第一个元素是被弹出元素的值，第二个元素是等待时长。</p><h4 id="代码示例-43"><a href="#代码示例-43" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 非空列表</span></span><br><span class="line">redis&gt; BRPOPLPUSH msg reciver 500</span><br><span class="line"><span class="string">"hello moto"</span>                        <span class="comment"># 弹出元素的值</span></span><br><span class="line">(3.38s)                             <span class="comment"># 等待时长</span></span><br><span class="line"></span><br><span class="line">redis&gt; LLEN reciver</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE reciver 0 0</span><br><span class="line">1) <span class="string">"hello moto"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 空列表</span></span><br><span class="line">redis&gt; BRPOPLPUSH msg reciver 1</span><br><span class="line">(nil)</span><br><span class="line">(1.34s)</span><br></pre></td></tr></table></figure><h4 id="模式：安全队列"><a href="#模式：安全队列" class="headerlink" title="模式：安全队列"></a>模式：安全队列</h4><p>参考 RPOPLPUSH source destination 命令的《安全队列》一节。</p><h4 id="模式：循环列表-1"><a href="#模式：循环列表-1" class="headerlink" title="模式：循环列表"></a>模式：循环列表</h4><p>参考 RPOPLPUSH source destination 命令的《循环列表》一节。</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a><a name="集合">集合</a></h2><h3 id="SADD"><a href="#SADD" class="headerlink" title="SADD"></a>SADD</h3><h4 id="SADD-key-member-member-…"><a href="#SADD-key-member-member-…" class="headerlink" title="SADD key member [member …]"></a>SADD key member [member …]</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度: O(N)， N 是被添加的元素的数量。
</code></pre><p>将一个或多个 member 元素加入到集合 key 当中，已经存在于集合的 member 元素将被忽略。</p><p>假如 key 不存在，则创建一个只包含 member 元素作成员的集合。</p><p>当 key 不是集合类型时，返回一个错误。</p><h4 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h4><p>在Redis2.4版本以前， SADD 只接受单个 member 值。</p><h4 id="返回值-47"><a href="#返回值-47" class="headerlink" title="返回值"></a>返回值</h4><p>被添加到集合中的新元素的数量，不包括被忽略的元素。</p><h4 id="代码示例-44"><a href="#代码示例-44" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加单个元素</span></span><br><span class="line">redis&gt; SADD bbs <span class="string">"discuz.net"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加重复元素</span></span><br><span class="line">redis&gt; SADD bbs <span class="string">"discuz.net"</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加多个元素</span></span><br><span class="line">redis&gt; SADD bbs <span class="string">"tianya.cn"</span> <span class="string">"groups.google.com"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS bbs</span><br><span class="line">1) <span class="string">"discuz.net"</span></span><br><span class="line">2) <span class="string">"groups.google.com"</span></span><br><span class="line">3) <span class="string">"tianya.cn"</span></span><br></pre></td></tr></table></figure><h3 id="SISMEMBER"><a href="#SISMEMBER" class="headerlink" title="SISMEMBER"></a>SISMEMBER</h3><h4 id="SISMEMBER-key-member"><a href="#SISMEMBER-key-member" class="headerlink" title="SISMEMBER key member"></a>SISMEMBER key member</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度: O(1)
</code></pre><p>判断 member 元素是否集合 key 的成员。</p><h4 id="返回值-48"><a href="#返回值-48" class="headerlink" title="返回值"></a>返回值</h4><p>如果 member 元素是集合的成员，返回 1 。 如果 member 元素不是集合的成员，或 key 不存在，返回 0 。</p><h4 id="代码示例-45"><a href="#代码示例-45" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SMEMBERS joe<span class="string">'s_movies</span></span><br><span class="line"><span class="string">1) "hi, lady"</span></span><br><span class="line"><span class="string">2) "Fast Five"</span></span><br><span class="line"><span class="string">3) "2012"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">redis&gt; SISMEMBER joe'</span>s_movies <span class="string">"bet man"</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; SISMEMBER joe<span class="string">'s_movies "Fast Five"</span></span><br><span class="line"><span class="string">(integer) 1</span></span><br></pre></td></tr></table></figure><h3 id="SPOP"><a href="#SPOP" class="headerlink" title="SPOP"></a>SPOP</h3><h4 id="SPOP-key"><a href="#SPOP-key" class="headerlink" title="SPOP key"></a>SPOP key</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度: O(1)
</code></pre><p>移除并返回集合中的一个随机元素。</p><p>如果只想获取一个随机元素，但不想该元素从集合中被移除的话，可以使用 SRANDMEMBER key [count] 命令。</p><h4 id="返回值-49"><a href="#返回值-49" class="headerlink" title="返回值"></a>返回值</h4><p>被移除的随机元素。 当 key 不存在或 key 是空集时，返回 nil 。</p><h4 id="代码示例-46"><a href="#代码示例-46" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SMEMBERS db</span><br><span class="line">1) <span class="string">"MySQL"</span></span><br><span class="line">2) <span class="string">"MongoDB"</span></span><br><span class="line">3) <span class="string">"Redis"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SPOP db</span><br><span class="line"><span class="string">"Redis"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS db</span><br><span class="line">1) <span class="string">"MySQL"</span></span><br><span class="line">2) <span class="string">"MongoDB"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SPOP db</span><br><span class="line"><span class="string">"MySQL"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS db</span><br><span class="line">1) <span class="string">"MongoDB"</span></span><br></pre></td></tr></table></figure><h3 id="SRANDMEMBER"><a href="#SRANDMEMBER" class="headerlink" title="SRANDMEMBER"></a>SRANDMEMBER</h3><h4 id="SRANDMEMBER-key-count"><a href="#SRANDMEMBER-key-count" class="headerlink" title="SRANDMEMBER key [count]"></a>SRANDMEMBER key [count]</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度: 只提供 key 参数时为 O(1) 。如果提供了 count 参数，那么为 O(N) ，N 为返回数组的元素个数。
</code></pre><p>如果命令执行时，只提供了 key 参数，那么返回集合中的一个随机元素。</p><p>从 Redis 2.6 版本开始， SRANDMEMBER 命令接受可选的 count 参数：</p><p>如果 count 为正数，且小于集合基数，那么命令返回一个包含 count 个元素的数组，数组中的元素各不相同。如果 count 大于等于集合基数，那么返回整个集合。<br>如果 count 为负数，那么命令返回一个数组，数组中的元素可能会重复出现多次，而数组的长度为 count 的绝对值。<br>该操作和 SPOP key 相似，但 SPOP key 将随机元素从集合中移除并返回，而 SRANDMEMBER 则仅仅返回随机元素，而不对集合进行任何改动。</p><h4 id="返回值-50"><a href="#返回值-50" class="headerlink" title="返回值"></a>返回值</h4><p>只提供 key 参数时，返回一个元素；如果集合为空，返回 nil 。 如果提供了 count 参数，那么返回一个数组；如果集合为空，返回空数组。</p><h4 id="代码示例-47"><a href="#代码示例-47" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加元素</span></span><br><span class="line">redis&gt; SADD fruit apple banana cherry</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只给定 key 参数，返回一个随机元素</span></span><br><span class="line">redis&gt; SRANDMEMBER fruit</span><br><span class="line"><span class="string">"cherry"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SRANDMEMBER fruit</span><br><span class="line"><span class="string">"apple"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给定 3 为 count 参数，返回 3 个随机元素</span></span><br><span class="line"><span class="comment"># 每个随机元素都不相同</span></span><br><span class="line">redis&gt; SRANDMEMBER fruit 3</span><br><span class="line">1) <span class="string">"apple"</span></span><br><span class="line">2) <span class="string">"banana"</span></span><br><span class="line">3) <span class="string">"cherry"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给定 -3 为 count 参数，返回 3 个随机元素</span></span><br><span class="line"><span class="comment"># 元素可能会重复出现多次</span></span><br><span class="line">redis&gt; SRANDMEMBER fruit -3</span><br><span class="line">1) <span class="string">"banana"</span></span><br><span class="line">2) <span class="string">"cherry"</span></span><br><span class="line">3) <span class="string">"apple"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SRANDMEMBER fruit -3</span><br><span class="line">1) <span class="string">"apple"</span></span><br><span class="line">2) <span class="string">"apple"</span></span><br><span class="line">3) <span class="string">"cherry"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果 count 是整数，且大于等于集合基数，那么返回整个集合</span></span><br><span class="line">redis&gt; SRANDMEMBER fruit 10</span><br><span class="line">1) <span class="string">"apple"</span></span><br><span class="line">2) <span class="string">"banana"</span></span><br><span class="line">3) <span class="string">"cherry"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果 count 是负数，且 count 的绝对值大于集合的基数</span></span><br><span class="line"><span class="comment"># 那么返回的数组的长度为 count 的绝对值</span></span><br><span class="line">redis&gt; SRANDMEMBER fruit -10</span><br><span class="line">1) <span class="string">"banana"</span></span><br><span class="line">2) <span class="string">"apple"</span></span><br><span class="line">3) <span class="string">"banana"</span></span><br><span class="line">4) <span class="string">"cherry"</span></span><br><span class="line">5) <span class="string">"apple"</span></span><br><span class="line">6) <span class="string">"apple"</span></span><br><span class="line">7) <span class="string">"cherry"</span></span><br><span class="line">8) <span class="string">"apple"</span></span><br><span class="line">9) <span class="string">"apple"</span></span><br><span class="line">10) <span class="string">"banana"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SRANDMEMBER 并不会修改集合内容</span></span><br><span class="line">redis&gt; SMEMBERS fruit</span><br><span class="line">1) <span class="string">"apple"</span></span><br><span class="line">2) <span class="string">"cherry"</span></span><br><span class="line">3) <span class="string">"banana"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 集合为空时返回 nil 或者空数组</span></span><br><span class="line">redis&gt; SRANDMEMBER not-exists</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line">redis&gt; SRANDMEMBER not-eixsts 10</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br></pre></td></tr></table></figure><h3 id="SREM"><a href="#SREM" class="headerlink" title="SREM"></a>SREM</h3><h4 id="SREM-key-member-member-…"><a href="#SREM-key-member-member-…" class="headerlink" title="SREM key member [member …]"></a>SREM key member [member …]</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度: O(N)， N 为给定 member 元素的数量。
</code></pre><p>移除集合 key 中的一个或多个 member 元素，不存在的 member 元素会被忽略。</p><p>当 key 不是集合类型，返回一个错误。</p><h4 id="Note-1"><a href="#Note-1" class="headerlink" title="Note"></a>Note</h4><p>在 Redis 2.4 版本以前， SREM 只接受单个 member 值。</p><h4 id="返回值-51"><a href="#返回值-51" class="headerlink" title="返回值"></a>返回值</h4><p>被成功移除的元素的数量，不包括被忽略的元素。</p><h4 id="代码示例-48"><a href="#代码示例-48" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试数据</span></span><br><span class="line">redis&gt; SMEMBERS languages</span><br><span class="line">1) <span class="string">"c"</span></span><br><span class="line">2) <span class="string">"lisp"</span></span><br><span class="line">3) <span class="string">"python"</span></span><br><span class="line">4) <span class="string">"ruby"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除单个元素</span></span><br><span class="line">redis&gt; SREM languages ruby</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除不存在元素</span></span><br><span class="line">redis&gt; SREM languages non-exists-language</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除多个元素</span></span><br><span class="line">redis&gt; SREM languages lisp python c</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS languages</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br></pre></td></tr></table></figure><h3 id="SMOVE"><a href="#SMOVE" class="headerlink" title="SMOVE"></a>SMOVE</h3><h4 id="SMOVE-source-destination-member"><a href="#SMOVE-source-destination-member" class="headerlink" title="SMOVE source destination member"></a>SMOVE source destination member</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度: O(1)
</code></pre><p>将 member 元素从 source 集合移动到 destination 集合。</p><p>SMOVE 是原子性操作。</p><p>如果 source 集合不存在或不包含指定的 member 元素，则 SMOVE 命令不执行任何操作，仅返回 0 。否则， member 元素从 source 集合中被移除，并添加到 destination 集合中去。</p><p>当 destination 集合已经包含 member 元素时， SMOVE 命令只是简单地将 source 集合中的 member 元素删除。</p><p>当 source 或 destination 不是集合类型时，返回一个错误。</p><h4 id="返回值-52"><a href="#返回值-52" class="headerlink" title="返回值"></a>返回值</h4><p>如果 member 元素被成功移除，返回 1 。 如果 member 元素不是 source 集合的成员，并且没有任何操作对 destination 集合执行，那么返回 0 。</p><h4 id="代码示例-49"><a href="#代码示例-49" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SMEMBERS songs</span><br><span class="line">1) <span class="string">"Billie Jean"</span></span><br><span class="line">2) <span class="string">"Believe Me"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS my_songs</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line"></span><br><span class="line">redis&gt; SMOVE songs my_songs <span class="string">"Believe Me"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS songs</span><br><span class="line">1) <span class="string">"Billie Jean"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS my_songs</span><br><span class="line">1) <span class="string">"Believe Me"</span></span><br></pre></td></tr></table></figure><h3 id="SCARD"><a href="#SCARD" class="headerlink" title="SCARD"></a>SCARD</h3><h4 id="SCARD-key"><a href="#SCARD-key" class="headerlink" title="SCARD key"></a>SCARD key</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度: O(1)
</code></pre><p>返回集合 key 的基数(集合中元素的数量)。</p><h4 id="返回值-53"><a href="#返回值-53" class="headerlink" title="返回值"></a>返回值</h4><p>集合的基数。 当 key 不存在时，返回 0 。</p><h4 id="代码示例-50"><a href="#代码示例-50" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SADD tool pc printer phone</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis&gt; SCARD tool   <span class="comment"># 非空集合</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis&gt; DEL tool</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; SCARD tool   <span class="comment"># 空集合</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><h3 id="SMEMBERS"><a href="#SMEMBERS" class="headerlink" title="SMEMBERS"></a>SMEMBERS</h3><h4 id="SMEMBERS-key"><a href="#SMEMBERS-key" class="headerlink" title="SMEMBERS key"></a>SMEMBERS key</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度: O(N)， N 为集合的基数。
</code></pre><p>返回集合 key 中的所有成员。</p><p>不存在的 key 被视为空集合。</p><h4 id="返回值-54"><a href="#返回值-54" class="headerlink" title="返回值"></a>返回值</h4><p>集合中的所有成员。</p><h4 id="代码示例-51"><a href="#代码示例-51" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># key 不存在或集合为空</span></span><br><span class="line">redis&gt; EXISTS not_exists_key</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS not_exists_key</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 非空集合</span></span><br><span class="line">redis&gt; SADD language Ruby Python Clojure</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS language</span><br><span class="line">1) <span class="string">"Python"</span></span><br><span class="line">2) <span class="string">"Ruby"</span></span><br><span class="line">3) <span class="string">"Clojure"</span></span><br></pre></td></tr></table></figure><h3 id="SSCAN"><a href="#SSCAN" class="headerlink" title="SSCAN"></a>SSCAN</h3><h4 id="SSCAN-key-cursor-MATCH-pattern-COUNT-count"><a href="#SSCAN-key-cursor-MATCH-pattern-COUNT-count" class="headerlink" title="SSCAN key cursor [MATCH pattern] [COUNT count]"></a>SSCAN key cursor [MATCH pattern] [COUNT count]</h4><p>详细信息请参考 SCAN cursor [MATCH pattern] [COUNT count] 命令。</p><h3 id="SINTER"><a href="#SINTER" class="headerlink" title="SINTER"></a>SINTER</h3><h4 id="SINTER-key-key-…"><a href="#SINTER-key-key-…" class="headerlink" title="SINTER key [key …]"></a>SINTER key [key …]</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度: O(N * M)， N 为给定集合当中基数最小的集合， M 为给定集合的个数。
</code></pre><p>返回一个集合的全部成员，该集合是所有给定集合的交集。</p><p>不存在的 key 被视为空集。</p><p>当给定集合当中有一个空集时，结果也为空集(根据集合运算定律)。</p><h4 id="返回值-55"><a href="#返回值-55" class="headerlink" title="返回值"></a>返回值</h4><p>交集成员的列表。</p><h4 id="代码示例-52"><a href="#代码示例-52" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SMEMBERS group_1</span><br><span class="line">1) <span class="string">"LI LEI"</span></span><br><span class="line">2) <span class="string">"TOM"</span></span><br><span class="line">3) <span class="string">"JACK"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS group_2</span><br><span class="line">1) <span class="string">"HAN MEIMEI"</span></span><br><span class="line">2) <span class="string">"JACK"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SINTER group_1 group_2</span><br><span class="line">1) <span class="string">"JACK"</span></span><br></pre></td></tr></table></figure><h3 id="SINTERSTORE"><a href="#SINTERSTORE" class="headerlink" title="SINTERSTORE"></a>SINTERSTORE</h3><h4 id="SINTERSTORE-destination-key-key-…"><a href="#SINTERSTORE-destination-key-key-…" class="headerlink" title="SINTERSTORE destination key [key …]"></a>SINTERSTORE destination key [key …]</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度: O(N * M)， N 为给定集合当中基数最小的集合， M 为给定集合的个数。
</code></pre><p>这个命令类似于 SINTER key [key …] 命令，但它将结果保存到 destination 集合，而不是简单地返回结果集。</p><p>如果 destination 集合已经存在，则将其覆盖。</p><p>destination 可以是 key 本身。</p><h4 id="返回值-56"><a href="#返回值-56" class="headerlink" title="返回值"></a>返回值</h4><p>结果集中的成员数量。</p><h4 id="代码示例-53"><a href="#代码示例-53" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SMEMBERS songs</span><br><span class="line">1) <span class="string">"good bye joe"</span></span><br><span class="line">2) <span class="string">"hello,peter"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS my_songs</span><br><span class="line">1) <span class="string">"good bye joe"</span></span><br><span class="line">2) <span class="string">"falling"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SINTERSTORE song_interset songs my_songs</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS song_interset</span><br><span class="line">1) <span class="string">"good bye joe"</span></span><br></pre></td></tr></table></figure><h3 id="SUNION"><a href="#SUNION" class="headerlink" title="SUNION"></a>SUNION</h3><h4 id="SUNION-key-key-…"><a href="#SUNION-key-key-…" class="headerlink" title="SUNION key [key …]"></a>SUNION key [key …]</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度: O(N)， N 是所有给定集合的成员数量之和。
</code></pre><p>返回一个集合的全部成员，该集合是所有给定集合的并集。</p><p>不存在的 key 被视为空集。</p><h4 id="返回值-57"><a href="#返回值-57" class="headerlink" title="返回值"></a>返回值</h4><p>并集成员的列表。</p><h4 id="代码示例-54"><a href="#代码示例-54" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SMEMBERS songs</span><br><span class="line">1) <span class="string">"Billie Jean"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS my_songs</span><br><span class="line">1) <span class="string">"Believe Me"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SUNION songs my_songs</span><br><span class="line">1) <span class="string">"Billie Jean"</span></span><br><span class="line">2) <span class="string">"Believe Me"</span></span><br></pre></td></tr></table></figure><h3 id="SUNIONSTORE"><a href="#SUNIONSTORE" class="headerlink" title="SUNIONSTORE"></a>SUNIONSTORE</h3><h4 id="SUNIONSTORE-destination-key-key-…"><a href="#SUNIONSTORE-destination-key-key-…" class="headerlink" title="SUNIONSTORE destination key [key …]"></a>SUNIONSTORE destination key [key …]</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度: O(N)， N 是所有给定集合的成员数量之和。
</code></pre><p>这个命令类似于 SUNION key [key …] 命令，但它将结果保存到 destination 集合，而不是简单地返回结果集。</p><p>如果 destination 已经存在，则将其覆盖。</p><p>destination 可以是 key 本身。</p><h4 id="返回值-58"><a href="#返回值-58" class="headerlink" title="返回值"></a>返回值</h4><p>结果集中的元素数量。</p><h4 id="代码示例-55"><a href="#代码示例-55" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SMEMBERS NoSQL</span><br><span class="line">1) <span class="string">"MongoDB"</span></span><br><span class="line">2) <span class="string">"Redis"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS SQL</span><br><span class="line">1) <span class="string">"sqlite"</span></span><br><span class="line">2) <span class="string">"MySQL"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SUNIONSTORE db NoSQL SQL</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS db</span><br><span class="line">1) <span class="string">"MySQL"</span></span><br><span class="line">2) <span class="string">"sqlite"</span></span><br><span class="line">3) <span class="string">"MongoDB"</span></span><br><span class="line">4) <span class="string">"Redis"</span></span><br></pre></td></tr></table></figure><h3 id="SDIFF"><a href="#SDIFF" class="headerlink" title="SDIFF"></a>SDIFF</h3><h4 id="SDIFF-key-key-…"><a href="#SDIFF-key-key-…" class="headerlink" title="SDIFF key [key …]"></a>SDIFF key [key …]</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度: O(N)， N 是所有给定集合的成员数量之和。
</code></pre><p>返回一个集合的全部成员，该集合是所有给定集合之间的差集。</p><p>不存在的 key 被视为空集。</p><h4 id="返回值-59"><a href="#返回值-59" class="headerlink" title="返回值"></a>返回值</h4><p>一个包含差集成员的列表。</p><h4 id="代码示例-56"><a href="#代码示例-56" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SMEMBERS peter<span class="string">'s_movies</span></span><br><span class="line"><span class="string">1) "bet man"</span></span><br><span class="line"><span class="string">2) "start war"</span></span><br><span class="line"><span class="string">3) "2012"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">redis&gt; SMEMBERS joe'</span>s_movies</span><br><span class="line">1) <span class="string">"hi, lady"</span></span><br><span class="line">2) <span class="string">"Fast Five"</span></span><br><span class="line">3) <span class="string">"2012"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SDIFF peter<span class="string">'s_movies joe'</span>s_movies</span><br><span class="line">1) <span class="string">"bet man"</span></span><br><span class="line">2) <span class="string">"start war"</span></span><br></pre></td></tr></table></figure><h3 id="SDIFFSTORE"><a href="#SDIFFSTORE" class="headerlink" title="SDIFFSTORE"></a>SDIFFSTORE</h3><h4 id="SDIFFSTORE-destination-key-key-…"><a href="#SDIFFSTORE-destination-key-key-…" class="headerlink" title="SDIFFSTORE destination key [key …]"></a>SDIFFSTORE destination key [key …]</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度: O(N)， N 是所有给定集合的成员数量之和。
</code></pre><p>这个命令的作用和 SDIFF key [key …] 类似，但它将结果保存到 destination 集合，而不是简单地返回结果集。</p><p>如果 destination 集合已经存在，则将其覆盖。</p><p>destination 可以是 key 本身。</p><h4 id="返回值-60"><a href="#返回值-60" class="headerlink" title="返回值"></a>返回值</h4><p>结果集中的元素数量。</p><h4 id="代码示例-57"><a href="#代码示例-57" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SMEMBERS joe<span class="string">'s_movies</span></span><br><span class="line"><span class="string">1) "hi, lady"</span></span><br><span class="line"><span class="string">2) "Fast Five"</span></span><br><span class="line"><span class="string">3) "2012"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">redis&gt; SMEMBERS peter'</span>s_movies</span><br><span class="line">1) <span class="string">"bet man"</span></span><br><span class="line">2) <span class="string">"start war"</span></span><br><span class="line">3) <span class="string">"2012"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SDIFFSTORE joe_diff_peter joe<span class="string">'s_movies peter'</span>s_movies</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS joe_diff_peter</span><br><span class="line">1) <span class="string">"hi, lady"</span></span><br><span class="line">2) <span class="string">"Fast Five"</span></span><br></pre></td></tr></table></figure><h2 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a><a name="有序集合">有序集合</a></h2><h3 id="ZADD"><a href="#ZADD" class="headerlink" title="ZADD"></a>ZADD</h3><h4 id="ZADD-key-score-member-score-member-score-member-…"><a href="#ZADD-key-score-member-score-member-score-member-…" class="headerlink" title="ZADD key score member [[score member] [score member] …]"></a>ZADD key score member [[score member] [score member] …]</h4><pre><code>可用版本： &gt;= 1.2.0
时间复杂度: O(M*log(N))， N 是有序集的基数， M 为成功添加的新成员的数量。
</code></pre><p>将一个或多个 member 元素及其 score 值加入到有序集 key 当中。</p><p>如果某个 member 已经是有序集的成员，那么更新这个 member 的 score 值，并通过重新插入这个 member 元素，来保证该 member 在正确的位置上。</p><p>score 值可以是整数值或双精度浮点数。</p><p>如果 key 不存在，则创建一个空的有序集并执行 ZADD 操作。</p><p>当 key 存在但不是有序集类型时，返回一个错误。</p><h4 id="Note-2"><a href="#Note-2" class="headerlink" title="Note"></a>Note</h4><p>在 Redis 2.4 版本以前， ZADD 每次只能添加一个元素。</p><h4 id="返回值-61"><a href="#返回值-61" class="headerlink" title="返回值"></a>返回值</h4><p>被成功添加的新成员的数量，不包括那些被更新的、已经存在的成员。</p><h4 id="代码示例-58"><a href="#代码示例-58" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加单个元素</span></span><br><span class="line">redis&gt; ZADD page_rank 10 google.com</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加多个元素</span></span><br><span class="line">redis&gt; ZADD page_rank 9 baidu.com 8 bing.com</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES</span><br><span class="line">1) <span class="string">"bing.com"</span></span><br><span class="line">2) <span class="string">"8"</span></span><br><span class="line">3) <span class="string">"baidu.com"</span></span><br><span class="line">4) <span class="string">"9"</span></span><br><span class="line">5) <span class="string">"google.com"</span></span><br><span class="line">6) <span class="string">"10"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加已存在元素，且 score 值不变</span></span><br><span class="line">redis&gt; ZADD page_rank 10 google.com</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES  <span class="comment"># 没有改变</span></span><br><span class="line">1) <span class="string">"bing.com"</span></span><br><span class="line">2) <span class="string">"8"</span></span><br><span class="line">3) <span class="string">"baidu.com"</span></span><br><span class="line">4) <span class="string">"9"</span></span><br><span class="line">5) <span class="string">"google.com"</span></span><br><span class="line">6) <span class="string">"10"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加已存在元素，但是改变 score 值</span></span><br><span class="line">redis&gt; ZADD page_rank 6 bing.com</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES  <span class="comment"># bing.com 元素的 score 值被改变</span></span><br><span class="line">1) <span class="string">"bing.com"</span></span><br><span class="line">2) <span class="string">"6"</span></span><br><span class="line">3) <span class="string">"baidu.com"</span></span><br><span class="line">4) <span class="string">"9"</span></span><br><span class="line">5) <span class="string">"google.com"</span></span><br><span class="line">6) <span class="string">"10"</span></span><br></pre></td></tr></table></figure><h3 id="ZSCORE"><a href="#ZSCORE" class="headerlink" title="ZSCORE"></a>ZSCORE</h3><h4 id="ZSCORE-key-member"><a href="#ZSCORE-key-member" class="headerlink" title="ZSCORE key member"></a>ZSCORE key member</h4><pre><code>可用版本： &gt;= 1.2.0
时间复杂度: O(1)
</code></pre><p>返回有序集 key 中，成员 member 的 score 值。</p><p>如果 member 元素不是有序集 key 的成员，或 key 不存在，返回 nil 。</p><h4 id="返回值-62"><a href="#返回值-62" class="headerlink" title="返回值"></a>返回值</h4><p>member 成员的 score 值，以字符串形式表示。</p><h4 id="代码示例-59"><a href="#代码示例-59" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZRANGE salary 0 -1 WITHSCORES    <span class="comment"># 测试数据</span></span><br><span class="line">1) <span class="string">"tom"</span></span><br><span class="line">2) <span class="string">"2000"</span></span><br><span class="line">3) <span class="string">"peter"</span></span><br><span class="line">4) <span class="string">"3500"</span></span><br><span class="line">5) <span class="string">"jack"</span></span><br><span class="line">6) <span class="string">"5000"</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZSCORE salary peter              <span class="comment"># 注意返回值是字符串</span></span><br><span class="line"><span class="string">"3500"</span></span><br></pre></td></tr></table></figure><h3 id="ZINCRBY"><a href="#ZINCRBY" class="headerlink" title="ZINCRBY"></a>ZINCRBY</h3><h4 id="ZINCRBY-key-increment-member"><a href="#ZINCRBY-key-increment-member" class="headerlink" title="ZINCRBY key increment member"></a>ZINCRBY key increment member</h4><pre><code>可用版本： &gt;= 1.2.0
时间复杂度: O(log(N))
</code></pre><p>为有序集 key 的成员 member 的 score 值加上增量 increment 。</p><p>可以通过传递一个负数值 increment ，让 score 减去相应的值，比如 ZINCRBY key -5 member ，就是让 member 的 score 值减去 5 。</p><p>当 key 不存在，或 member 不是 key 的成员时， ZINCRBY key increment member 等同于 ZADD key increment member 。</p><p>当 key 不是有序集类型时，返回一个错误。</p><p>score 值可以是整数值或双精度浮点数。</p><h4 id="返回值-63"><a href="#返回值-63" class="headerlink" title="返回值"></a>返回值</h4><p>member 成员的新 score 值，以字符串形式表示。</p><h4 id="代码示例-60"><a href="#代码示例-60" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZSCORE salary tom</span><br><span class="line"><span class="string">"2000"</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZINCRBY salary 2000 tom   <span class="comment"># tom 加薪啦！</span></span><br><span class="line"><span class="string">"4000"</span></span><br></pre></td></tr></table></figure><h3 id="ZCARD"><a href="#ZCARD" class="headerlink" title="ZCARD"></a>ZCARD</h3><h4 id="ZCARD-key"><a href="#ZCARD-key" class="headerlink" title="ZCARD key"></a>ZCARD key</h4><pre><code>可用版本： &gt;= 1.2.0
时间复杂度: O(1)
</code></pre><p>返回有序集 key 的基数。</p><h4 id="返回值-64"><a href="#返回值-64" class="headerlink" title="返回值"></a>返回值</h4><p>当 key 存在且是有序集类型时，返回有序集的基数。 当 key 不存在时，返回 0 。</p><h4 id="代码示例-61"><a href="#代码示例-61" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">redis &gt; ZADD salary 2000 tom    <span class="comment"># 添加一个成员</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis &gt; ZCARD salary</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis &gt; ZADD salary 5000 jack   <span class="comment"># 再添加一个成员</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis &gt; ZCARD salary</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis &gt; EXISTS non_exists_key   <span class="comment"># 对不存在的 key 进行 ZCARD 操作</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis &gt; ZCARD non_exists_key</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><h3 id="ZCOUNT"><a href="#ZCOUNT" class="headerlink" title="ZCOUNT"></a>ZCOUNT</h3><h4 id="ZCOUNT-key-min-max"><a href="#ZCOUNT-key-min-max" class="headerlink" title="ZCOUNT key min max"></a>ZCOUNT key min max</h4><pre><code>可用版本： &gt;= 2.0.0
时间复杂度: O(log(N))， N 为有序集的基数。
</code></pre><p>返回有序集 key 中， score 值在 min 和 max 之间(默认包括 score 值等于 min 或 max )的成员的数量。</p><p>关于参数 min 和 max 的详细使用方法，请参考 ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] 命令。</p><h4 id="返回值-65"><a href="#返回值-65" class="headerlink" title="返回值"></a>返回值</h4><p>score 值在 min 和 max 之间的成员的数量。</p><h4 id="代码示例-62"><a href="#代码示例-62" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZRANGE salary 0 -1 WITHSCORES    <span class="comment"># 测试数据</span></span><br><span class="line">1) <span class="string">"jack"</span></span><br><span class="line">2) <span class="string">"2000"</span></span><br><span class="line">3) <span class="string">"peter"</span></span><br><span class="line">4) <span class="string">"3500"</span></span><br><span class="line">5) <span class="string">"tom"</span></span><br><span class="line">6) <span class="string">"5000"</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZCOUNT salary 2000 5000          <span class="comment"># 计算薪水在 2000-5000 之间的人数</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis&gt; ZCOUNT salary 3000 5000          <span class="comment"># 计算薪水在 3000-5000 之间的人数</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure><h3 id="ZRANGE"><a href="#ZRANGE" class="headerlink" title="ZRANGE"></a>ZRANGE</h3><h4 id="ZRANGE-key-start-stop-WITHSCORES"><a href="#ZRANGE-key-start-stop-WITHSCORES" class="headerlink" title="ZRANGE key start stop [WITHSCORES]"></a>ZRANGE key start stop [WITHSCORES]</h4><pre><code>可用版本： &gt;= 1.2.0
时间复杂度: O(log(N)+M)， N 为有序集的基数，而 M 为结果集的基数。
</code></pre><p>返回有序集 key 中，指定区间内的成员。</p><p>其中成员的位置按 score 值递增(从小到大)来排序。</p><p>具有相同 score 值的成员按字典序(lexicographical order )来排列。</p><p>如果你需要成员按 score 值递减(从大到小)来排列，请使用 ZREVRANGE key start stop [WITHSCORES] 命令。</p><p>下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。 你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。</p><p>超出范围的下标并不会引起错误。 比如说，当 start 的值比有序集的最大下标还要大，或是 start &gt; stop 时， ZRANGE 命令只是简单地返回一个空列表。 另一方面，假如 stop 参数的值比有序集的最大下标还要大，那么 Redis 将 stop 当作最大下标来处理。</p><p>可以通过使用 WITHSCORES 选项，来让成员和它的 score 值一并返回，返回列表以 value1,score1, …, valueN,scoreN 的格式表示。 客户端库可能会返回一些更复杂的数据类型，比如数组、元组等。</p><h4 id="返回值-66"><a href="#返回值-66" class="headerlink" title="返回值"></a>返回值</h4><p>指定区间内，带有 score 值(可选)的有序集成员的列表。</p><h4 id="代码示例-63"><a href="#代码示例-63" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">redis &gt; ZRANGE salary 0 -1 WITHSCORES             <span class="comment"># 显示整个有序集成员</span></span><br><span class="line">1) <span class="string">"jack"</span></span><br><span class="line">2) <span class="string">"3500"</span></span><br><span class="line">3) <span class="string">"tom"</span></span><br><span class="line">4) <span class="string">"5000"</span></span><br><span class="line">5) <span class="string">"boss"</span></span><br><span class="line">6) <span class="string">"10086"</span></span><br><span class="line"></span><br><span class="line">redis &gt; ZRANGE salary 1 2 WITHSCORES              <span class="comment"># 显示有序集下标区间 1 至 2 的成员</span></span><br><span class="line">1) <span class="string">"tom"</span></span><br><span class="line">2) <span class="string">"5000"</span></span><br><span class="line">3) <span class="string">"boss"</span></span><br><span class="line">4) <span class="string">"10086"</span></span><br><span class="line"></span><br><span class="line">redis &gt; ZRANGE salary 0 200000 WITHSCORES         <span class="comment"># 测试 end 下标超出最大下标时的情况</span></span><br><span class="line">1) <span class="string">"jack"</span></span><br><span class="line">2) <span class="string">"3500"</span></span><br><span class="line">3) <span class="string">"tom"</span></span><br><span class="line">4) <span class="string">"5000"</span></span><br><span class="line">5) <span class="string">"boss"</span></span><br><span class="line">6) <span class="string">"10086"</span></span><br><span class="line"></span><br><span class="line">redis &gt; ZRANGE salary 200000 3000000 WITHSCORES   <span class="comment"># 测试当给定区间不存在于有序集时的情况</span></span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br></pre></td></tr></table></figure><h3 id="ZREVRANGE"><a href="#ZREVRANGE" class="headerlink" title="ZREVRANGE"></a>ZREVRANGE</h3><h4 id="ZREVRANGE-key-start-stop-WITHSCORES"><a href="#ZREVRANGE-key-start-stop-WITHSCORES" class="headerlink" title="ZREVRANGE key start stop [WITHSCORES]"></a>ZREVRANGE key start stop [WITHSCORES]</h4><pre><code>可用版本： &gt;= 1.2.0
时间复杂度: O(log(N)+M)， N 为有序集的基数，而 M 为结果集的基数。
</code></pre><p>返回有序集 key 中，指定区间内的成员。</p><p>其中成员的位置按 score 值递减(从大到小)来排列。 具有相同 score 值的成员按字典序的逆序(reverse lexicographical order)排列。</p><p>除了成员按 score 值递减的次序排列这一点外， ZREVRANGE 命令的其他方面和 ZRANGE key start stop [WITHSCORES] 命令一样。</p><h4 id="返回值-67"><a href="#返回值-67" class="headerlink" title="返回值"></a>返回值</h4><p>指定区间内，带有 score 值(可选)的有序集成员的列表。</p><h4 id="代码示例-64"><a href="#代码示例-64" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZRANGE salary 0 -1 WITHSCORES        <span class="comment"># 递增排列</span></span><br><span class="line">1) <span class="string">"peter"</span></span><br><span class="line">2) <span class="string">"3500"</span></span><br><span class="line">3) <span class="string">"tom"</span></span><br><span class="line">4) <span class="string">"4000"</span></span><br><span class="line">5) <span class="string">"jack"</span></span><br><span class="line">6) <span class="string">"5000"</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZREVRANGE salary 0 -1 WITHSCORES     <span class="comment"># 递减排列</span></span><br><span class="line">1) <span class="string">"jack"</span></span><br><span class="line">2) <span class="string">"5000"</span></span><br><span class="line">3) <span class="string">"tom"</span></span><br><span class="line">4) <span class="string">"4000"</span></span><br><span class="line">5) <span class="string">"peter"</span></span><br><span class="line">6) <span class="string">"3500"</span></span><br></pre></td></tr></table></figure><h3 id="ZRANGEBYSCORE"><a href="#ZRANGEBYSCORE" class="headerlink" title="ZRANGEBYSCORE"></a>ZRANGEBYSCORE</h3><h4 id="ZRANGEBYSCORE-key-min-max-WITHSCORES-LIMIT-offset-count"><a href="#ZRANGEBYSCORE-key-min-max-WITHSCORES-LIMIT-offset-count" class="headerlink" title="ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]"></a>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</h4><pre><code>可用版本： &gt;= 1.0.5
时间复杂度: O(log(N)+M)， N 为有序集的基数， M 为被结果集的基数。
</code></pre><p>返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。</p><p>具有相同 score 值的成员按字典序(lexicographical order)来排列(该属性是有序集提供的，不需要额外的计算)。</p><p>可选的 LIMIT 参数指定返回结果的数量及区间(就像SQL中的 SELECT LIMIT offset, count )，注意当 offset 很大时，定位 offset 的操作可能需要遍历整个有序集，此过程最坏复杂度为 O(N) 时间。</p><p>可选的 WITHSCORES 参数决定结果集是单单返回有序集的成员，还是将有序集成员及其 score 值一起返回。 该选项自 Redis 2.0 版本起可用。</p><h4 id="区间及无限"><a href="#区间及无限" class="headerlink" title="区间及无限"></a>区间及无限</h4><p>min 和 max 可以是 -inf 和 +inf ，这样一来，你就可以在不知道有序集的最低和最高 score 值的情况下，使用 ZRANGEBYSCORE 这类命令。</p><p>默认情况下，区间的取值使用闭区间 (小于等于或大于等于)，你也可以通过给参数前增加 ( 符号来使用可选的开区间 (小于或大于)。</p><h4 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a>举个例子：</h4><p>ZRANGEBYSCORE zset (1 5<br>返回所有符合条件 1 &lt; score &lt;= 5 的成员，而</p><p>ZRANGEBYSCORE zset (5 (10<br>则返回所有符合条件 5 &lt; score &lt; 10 的成员。</p><h4 id="返回值-68"><a href="#返回值-68" class="headerlink" title="返回值"></a>返回值</h4><p>指定区间内，带有 score 值(可选)的有序集成员的列表。</p><h4 id="代码示例-65"><a href="#代码示例-65" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD salary 2500 jack                        <span class="comment"># 测试数据</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; ZADD salary 5000 tom</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; ZADD salary 12000 peter</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGEBYSCORE salary -inf +inf               <span class="comment"># 显示整个有序集</span></span><br><span class="line">1) <span class="string">"jack"</span></span><br><span class="line">2) <span class="string">"tom"</span></span><br><span class="line">3) <span class="string">"peter"</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGEBYSCORE salary -inf +inf WITHSCORES    <span class="comment"># 显示整个有序集及成员的 score 值</span></span><br><span class="line">1) <span class="string">"jack"</span></span><br><span class="line">2) <span class="string">"2500"</span></span><br><span class="line">3) <span class="string">"tom"</span></span><br><span class="line">4) <span class="string">"5000"</span></span><br><span class="line">5) <span class="string">"peter"</span></span><br><span class="line">6) <span class="string">"12000"</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGEBYSCORE salary -inf 5000 WITHSCORES    <span class="comment"># 显示工资 &lt;=5000 的所有成员</span></span><br><span class="line">1) <span class="string">"jack"</span></span><br><span class="line">2) <span class="string">"2500"</span></span><br><span class="line">3) <span class="string">"tom"</span></span><br><span class="line">4) <span class="string">"5000"</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGEBYSCORE salary (5000 400000            <span class="comment"># 显示工资大于 5000 小于等于 400000 的成员</span></span><br><span class="line">1) <span class="string">"peter"</span></span><br></pre></td></tr></table></figure><h3 id="ZREVRANGEBYSCORE"><a href="#ZREVRANGEBYSCORE" class="headerlink" title="ZREVRANGEBYSCORE"></a>ZREVRANGEBYSCORE</h3><h4 id="ZREVRANGEBYSCORE-key-max-min-WITHSCORES-LIMIT-offset-count"><a href="#ZREVRANGEBYSCORE-key-max-min-WITHSCORES-LIMIT-offset-count" class="headerlink" title="ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]"></a>ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</h4><pre><code>可用版本： &gt;= 2.2.0
时间复杂度: O(log(N)+M)， N 为有序集的基数， M 为结果集的基数。
</code></pre><p>返回有序集 key 中， score 值介于 max 和 min 之间(默认包括等于 max 或 min )的所有的成员。有序集成员按 score 值递减(从大到小)的次序排列。</p><p>具有相同 score 值的成员按字典序的逆序(reverse lexicographical order )排列。</p><p>除了成员按 score 值递减的次序排列这一点外， ZREVRANGEBYSCORE 命令的其他方面和 ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] 命令一样。</p><h4 id="返回值-69"><a href="#返回值-69" class="headerlink" title="返回值"></a>返回值</h4><p>指定区间内，带有 score 值(可选)的有序集成员的列表。</p><h4 id="代码示例-66"><a href="#代码示例-66" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">redis &gt; ZADD salary 10086 jack</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis &gt; ZADD salary 5000 tom</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis &gt; ZADD salary 7500 peter</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis &gt; ZADD salary 3500 joe</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis &gt; ZREVRANGEBYSCORE salary +inf -inf   <span class="comment"># 逆序排列所有成员</span></span><br><span class="line">1) <span class="string">"jack"</span></span><br><span class="line">2) <span class="string">"peter"</span></span><br><span class="line">3) <span class="string">"tom"</span></span><br><span class="line">4) <span class="string">"joe"</span></span><br><span class="line"></span><br><span class="line">redis &gt; ZREVRANGEBYSCORE salary 10000 2000  <span class="comment"># 逆序排列薪水介于 10000 和 2000 之间的成员</span></span><br><span class="line">1) <span class="string">"peter"</span></span><br><span class="line">2) <span class="string">"tom"</span></span><br><span class="line">3) <span class="string">"joe"</span></span><br></pre></td></tr></table></figure><h3 id="ZRANK"><a href="#ZRANK" class="headerlink" title="ZRANK"></a>ZRANK</h3><h4 id="ZRANK-key-member"><a href="#ZRANK-key-member" class="headerlink" title="ZRANK key member"></a>ZRANK key member</h4><pre><code>可用版本： &gt;= 2.0.0
时间复杂度: O(log(N))
</code></pre><p>返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递增(从小到大)顺序排列。</p><p>排名以 0 为底，也就是说， score 值最小的成员排名为 0 。</p><p>使用 ZREVRANK key member 命令可以获得成员按 score 值递减(从大到小)排列的排名。</p><h4 id="返回值-70"><a href="#返回值-70" class="headerlink" title="返回值"></a>返回值</h4><p>如果 member 是有序集 key 的成员，返回 member 的排名。 如果 member 不是有序集 key 的成员，返回 nil 。</p><h4 id="代码示例-67"><a href="#代码示例-67" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZRANGE salary 0 -1 WITHSCORES        <span class="comment"># 显示所有成员及其 score 值</span></span><br><span class="line">1) <span class="string">"peter"</span></span><br><span class="line">2) <span class="string">"3500"</span></span><br><span class="line">3) <span class="string">"tom"</span></span><br><span class="line">4) <span class="string">"4000"</span></span><br><span class="line">5) <span class="string">"jack"</span></span><br><span class="line">6) <span class="string">"5000"</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZRANK salary tom                     <span class="comment"># 显示 tom 的薪水排名，第二</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><h3 id="ZREVRANK"><a href="#ZREVRANK" class="headerlink" title="ZREVRANK"></a>ZREVRANK</h3><h4 id="ZREVRANK-key-member"><a href="#ZREVRANK-key-member" class="headerlink" title="ZREVRANK key member"></a>ZREVRANK key member</h4><pre><code>可用版本： &gt;= 2.0.0
时间复杂度: O(log(N))
</code></pre><p>返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递减(从大到小)排序。</p><p>排名以 0 为底，也就是说， score 值最大的成员排名为 0 。</p><p>使用 ZRANK key member 命令可以获得成员按 score 值递增(从小到大)排列的排名。</p><h4 id="返回值-71"><a href="#返回值-71" class="headerlink" title="返回值"></a>返回值</h4><p>如果 member 是有序集 key 的成员，返回 member 的排名。 如果 member 不是有序集 key 的成员，返回 nil 。</p><h4 id="代码示例-68"><a href="#代码示例-68" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; ZRANGE salary 0 -1 WITHSCORES     <span class="comment"># 测试数据</span></span><br><span class="line">1) <span class="string">"jack"</span></span><br><span class="line">2) <span class="string">"2000"</span></span><br><span class="line">3) <span class="string">"peter"</span></span><br><span class="line">4) <span class="string">"3500"</span></span><br><span class="line">5) <span class="string">"tom"</span></span><br><span class="line">6) <span class="string">"5000"</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZREVRANK salary peter     <span class="comment"># peter 的工资排第二</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; ZREVRANK salary tom       <span class="comment"># tom 的工资最高</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><h3 id="ZREM"><a href="#ZREM" class="headerlink" title="ZREM"></a>ZREM</h3><h4 id="ZREM-key-member-member-…"><a href="#ZREM-key-member-member-…" class="headerlink" title="ZREM key member [member …]"></a>ZREM key member [member …]</h4><pre><code>可用版本： &gt;= 1.2.0
时间复杂度: O(M*log(N))， N 为有序集的基数， M 为被成功移除的成员的数量。
</code></pre><p>移除有序集 key 中的一个或多个成员，不存在的成员将被忽略。</p><p>当 key 存在但不是有序集类型时，返回一个错误。</p><h4 id="Note-3"><a href="#Note-3" class="headerlink" title="Note"></a>Note</h4><p>在 Redis 2.4 版本以前， ZREM 每次只能删除一个元素。</p><h4 id="返回值-72"><a href="#返回值-72" class="headerlink" title="返回值"></a>返回值</h4><p>被成功移除的成员的数量，不包括被忽略的成员。</p><h4 id="代码示例-69"><a href="#代码示例-69" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试数据</span></span><br><span class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES</span><br><span class="line">1) <span class="string">"bing.com"</span></span><br><span class="line">2) <span class="string">"8"</span></span><br><span class="line">3) <span class="string">"baidu.com"</span></span><br><span class="line">4) <span class="string">"9"</span></span><br><span class="line">5) <span class="string">"google.com"</span></span><br><span class="line">6) <span class="string">"10"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除单个元素</span></span><br><span class="line">redis&gt; ZREM page_rank google.com</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES</span><br><span class="line">1) <span class="string">"bing.com"</span></span><br><span class="line">2) <span class="string">"8"</span></span><br><span class="line">3) <span class="string">"baidu.com"</span></span><br><span class="line">4) <span class="string">"9"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除多个元素</span></span><br><span class="line">redis&gt; ZREM page_rank baidu.com bing.com</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除不存在元素</span></span><br><span class="line">redis&gt; ZREM page_rank non-exists-element</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><h3 id="ZREMRANGEBYRANK"><a href="#ZREMRANGEBYRANK" class="headerlink" title="ZREMRANGEBYRANK"></a>ZREMRANGEBYRANK</h3><h4 id="ZREMRANGEBYRANK-key-start-stop"><a href="#ZREMRANGEBYRANK-key-start-stop" class="headerlink" title="ZREMRANGEBYRANK key start stop"></a>ZREMRANGEBYRANK key start stop</h4><pre><code>可用版本： &gt;= 2.0.0
时间复杂度: O(log(N)+M)， N 为有序集的基数，而 M 为被移除成员的数量。
</code></pre><p>移除有序集 key 中，指定排名(rank)区间内的所有成员。</p><p>区间分别以下标参数 start 和 stop 指出，包含 start 和 stop 在内。</p><p>下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。 你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。</p><h4 id="返回值-73"><a href="#返回值-73" class="headerlink" title="返回值"></a>返回值</h4><p>被移除成员的数量。</p><h4 id="代码示例-70"><a href="#代码示例-70" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD salary 2000 jack</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZADD salary 5000 tom</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZADD salary 3500 peter</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; ZREMRANGEBYRANK salary 0 1       <span class="comment"># 移除下标 0 至 1 区间内的成员</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE salary 0 -1 WITHSCORES    <span class="comment"># 有序集只剩下一个成员</span></span><br><span class="line">1) <span class="string">"tom"</span></span><br><span class="line">2) <span class="string">"5000"</span></span><br></pre></td></tr></table></figure><h3 id="ZREMRANGEBYSCORE"><a href="#ZREMRANGEBYSCORE" class="headerlink" title="ZREMRANGEBYSCORE"></a>ZREMRANGEBYSCORE</h3><h4 id="ZREMRANGEBYSCORE-key-min-max"><a href="#ZREMRANGEBYSCORE-key-min-max" class="headerlink" title="ZREMRANGEBYSCORE key min max"></a>ZREMRANGEBYSCORE key min max</h4><pre><code>可用版本： &gt;= 1.2.0
时间复杂度： O(log(N)+M)， N 为有序集的基数，而 M 为被移除成员的数量。
</code></pre><p>移除有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。</p><p>自版本2.1.6开始， score 值等于 min 或 max 的成员也可以不包括在内，详情请参见 ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] 命令。</p><h4 id="返回值-74"><a href="#返回值-74" class="headerlink" title="返回值"></a>返回值</h4><p>被移除成员的数量。</p><h4 id="代码示例-71"><a href="#代码示例-71" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZRANGE salary 0 -1 WITHSCORES          <span class="comment"># 显示有序集内所有成员及其 score 值</span></span><br><span class="line">1) <span class="string">"tom"</span></span><br><span class="line">2) <span class="string">"2000"</span></span><br><span class="line">3) <span class="string">"peter"</span></span><br><span class="line">4) <span class="string">"3500"</span></span><br><span class="line">5) <span class="string">"jack"</span></span><br><span class="line">6) <span class="string">"5000"</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZREMRANGEBYSCORE salary 1500 3500      <span class="comment"># 移除所有薪水在 1500 到 3500 内的员工</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE salary 0 -1 WITHSCORES          <span class="comment"># 剩下的有序集成员</span></span><br><span class="line">1) <span class="string">"jack"</span></span><br><span class="line">2) <span class="string">"5000"</span></span><br></pre></td></tr></table></figure><h3 id="ZRANGEBYLEX"><a href="#ZRANGEBYLEX" class="headerlink" title="ZRANGEBYLEX"></a>ZRANGEBYLEX</h3><h4 id="ZRANGEBYLEX-key-min-max-LIMIT-offset-count"><a href="#ZRANGEBYLEX-key-min-max-LIMIT-offset-count" class="headerlink" title="ZRANGEBYLEX key min max [LIMIT offset count]"></a>ZRANGEBYLEX key min max [LIMIT offset count]</h4><pre><code>可用版本： &gt;= 2.8.9
时间复杂度：O(log(N)+M)， 其中 N 为有序集合的元素数量， 而 M 则是命令返回的元素数量。 如果 M 是一个常数（比如说，用户总是使用 LIMIT 参数来返回最先的 10 个元素）， 那么命令的复杂度也可以看作是 O(log(N)) 。
</code></pre><p>当有序集合的所有成员都具有相同的分值时， 有序集合的元素会根据成员的字典序（lexicographical ordering）来进行排序， 而这个命令则可以返回给定的有序集合键 key 中， 值介于 min 和 max 之间的成员。</p><p>如果有序集合里面的成员带有不同的分值， 那么命令返回的结果是未指定的（unspecified）。</p><p>命令会使用 C 语言的 memcmp() 函数， 对集合中的每个成员进行逐个字节的对比（byte-by-byte compare）， 并按照从低到高的顺序， 返回排序后的集合成员。 如果两个字符串有一部分内容是相同的话， 那么命令会认为较长的字符串比较短的字符串要大。</p><p>可选的 LIMIT offset count 参数用于获取指定范围内的匹配元素 （就像 SQL 中的 SELECT LIMIT offset count 语句）。 需要注意的一点是， 如果 offset 参数的值非常大的话， 那么命令在返回结果之前， 需要先遍历至 offset 所指定的位置， 这个操作会为命令加上最多 O(N) 复杂度。</p><h4 id="如何指定范围区间"><a href="#如何指定范围区间" class="headerlink" title="如何指定范围区间"></a>如何指定范围区间</h4><p>合法的 min 和 max 参数必须包含 ( 或者 [ ， 其中 ( 表示开区间（指定的值不会被包含在范围之内）， 而 [ 则表示闭区间（指定的值会被包含在范围之内）。</p><p>特殊值 + 和 - 在 min 参数以及 max 参数中具有特殊的意义， 其中 + 表示正无限， 而 - 表示负无限。 因此， 向一个所有成员的分值都相同的有序集合发送命令 ZRANGEBYLEX \&lt;zset> - + ， 命令将返回有序集合中的所有元素。</p><h4 id="返回值-75"><a href="#返回值-75" class="headerlink" title="返回值"></a>返回值</h4><p>数组回复：一个列表，列表里面包含了有序集合在指定范围内的成员。</p><h4 id="代码示例-72"><a href="#代码示例-72" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD myzset 0 a 0 b 0 c 0 d 0 e 0 f 0 g</span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGEBYLEX myzset - [c</span><br><span class="line">1) <span class="string">"a"</span></span><br><span class="line">2) <span class="string">"b"</span></span><br><span class="line">3) <span class="string">"c"</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGEBYLEX myzset - (c</span><br><span class="line">1) <span class="string">"a"</span></span><br><span class="line">2) <span class="string">"b"</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGEBYLEX myzset [aaa (g</span><br><span class="line">1) <span class="string">"b"</span></span><br><span class="line">2) <span class="string">"c"</span></span><br><span class="line">3) <span class="string">"d"</span></span><br><span class="line">4) <span class="string">"e"</span></span><br><span class="line">5) <span class="string">"f"</span></span><br></pre></td></tr></table></figure><h3 id="ZLEXCOUNT"><a href="#ZLEXCOUNT" class="headerlink" title="ZLEXCOUNT"></a>ZLEXCOUNT</h3><h4 id="ZLEXCOUNT-key-min-max"><a href="#ZLEXCOUNT-key-min-max" class="headerlink" title="ZLEXCOUNT key min max"></a>ZLEXCOUNT key min max</h4><pre><code>可用版本： &gt;= 2.8.9
时间复杂度： O(log(N))，其中 N 为有序集合包含的元素数量。
</code></pre><p>对于一个所有成员的分值都相同的有序集合键 key 来说， 这个命令会返回该集合中， 成员介于 min 和 max 范围内的元素数量。</p><p>这个命令的 min 参数和 max 参数的意义和 ZRANGEBYLEX key min max [LIMIT offset count] 命令的 min 参数和 max 参数的意义一样。</p><h4 id="返回值-76"><a href="#返回值-76" class="headerlink" title="返回值"></a>返回值</h4><p>整数回复：指定范围内的元素数量。</p><h4 id="代码示例-73"><a href="#代码示例-73" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD myzset 0 a 0 b 0 c 0 d 0 e</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line"></span><br><span class="line">redis&gt; ZADD myzset 0 f 0 g</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; ZLEXCOUNT myzset - +</span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line"></span><br><span class="line">redis&gt; ZLEXCOUNT myzset [b [f</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br></pre></td></tr></table></figure><h3 id="ZREMRANGEBYLEX"><a href="#ZREMRANGEBYLEX" class="headerlink" title="ZREMRANGEBYLEX"></a>ZREMRANGEBYLEX</h3><h4 id="ZREMRANGEBYLEX-key-min-max"><a href="#ZREMRANGEBYLEX-key-min-max" class="headerlink" title="ZREMRANGEBYLEX key min max"></a>ZREMRANGEBYLEX key min max</h4><pre><code>可用版本： &gt;= 2.8.9
时间复杂度： O(log(N)+M)， 其中 N 为有序集合的元素数量， 而 M 则为被移除的元素数量。
</code></pre><p>对于一个所有成员的分值都相同的有序集合键 key 来说， 这个命令会移除该集合中， 成员介于 min 和 max 范围内的所有元素。</p><p>这个命令的 min 参数和 max 参数的意义和 ZRANGEBYLEX key min max [LIMIT offset count] 命令的 min 参数和 max 参数的意义一样。</p><h4 id="返回值-77"><a href="#返回值-77" class="headerlink" title="返回值"></a>返回值</h4><p>整数回复：被移除的元素数量。</p><h4 id="代码示例-74"><a href="#代码示例-74" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD myzset 0 aaaa 0 b 0 c 0 d 0 e</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line"></span><br><span class="line">redis&gt; ZADD myzset 0 foo 0 zap 0 zip 0 ALPHA 0 alpha</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE myzset 0 -1</span><br><span class="line">1) <span class="string">"ALPHA"</span></span><br><span class="line">2) <span class="string">"aaaa"</span></span><br><span class="line">3) <span class="string">"alpha"</span></span><br><span class="line">4) <span class="string">"b"</span></span><br><span class="line">5) <span class="string">"c"</span></span><br><span class="line">6) <span class="string">"d"</span></span><br><span class="line">7) <span class="string">"e"</span></span><br><span class="line">8) <span class="string">"foo"</span></span><br><span class="line">9) <span class="string">"zap"</span></span><br><span class="line">10) <span class="string">"zip"</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZREMRANGEBYLEX myzset [alpha [omega</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE myzset 0 -1</span><br><span class="line">1) <span class="string">"ALPHA"</span></span><br><span class="line">2) <span class="string">"aaaa"</span></span><br><span class="line">3) <span class="string">"zap"</span></span><br><span class="line">4) <span class="string">"zip"</span></span><br></pre></td></tr></table></figure><h3 id="ZSCAN"><a href="#ZSCAN" class="headerlink" title="ZSCAN"></a>ZSCAN</h3><h4 id="ZSCAN-key-cursor-MATCH-pattern-COUNT-count"><a href="#ZSCAN-key-cursor-MATCH-pattern-COUNT-count" class="headerlink" title="ZSCAN key cursor [MATCH pattern] [COUNT count]"></a>ZSCAN key cursor [MATCH pattern] [COUNT count]</h4><p>详细信息请参考 SCAN cursor [MATCH pattern] [COUNT count] 命令。</p><h3 id="ZUNIONSTORE"><a href="#ZUNIONSTORE" class="headerlink" title="ZUNIONSTORE"></a>ZUNIONSTORE</h3><h4 id="ZUNIONSTORE-destination-numkeys-key-key-…-WEIGHTS-weight-weight-…-AGGREGATE-SUM-MIN-MAX"><a href="#ZUNIONSTORE-destination-numkeys-key-key-…-WEIGHTS-weight-weight-…-AGGREGATE-SUM-MIN-MAX" class="headerlink" title="ZUNIONSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX]"></a>ZUNIONSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX]</h4><pre><code>可用版本：&gt;= 2.0.0
时间复杂度: O(N)+O(M log(M))， N 为给定有序集基数的总和， M 为结果集的基数。
</code></pre><p>计算给定的一个或多个有序集的并集，其中给定 key 的数量必须以 numkeys 参数指定，并将该并集(结果集)储存到 destination 。</p><p>默认情况下，结果集中某个成员的 score 值是所有给定集下该成员 score 值之 和 。</p><h4 id="WEIGHTS"><a href="#WEIGHTS" class="headerlink" title="WEIGHTS"></a>WEIGHTS</h4><p>使用 WEIGHTS 选项，你可以为 每个 给定有序集 分别 指定一个乘法因子(multiplication factor)，每个给定有序集的所有成员的 score 值在传递给聚合函数(aggregation function)之前都要先乘以该有序集的因子。</p><p>如果没有指定 WEIGHTS 选项，乘法因子默认设置为 1 。</p><h4 id="AGGREGATE"><a href="#AGGREGATE" class="headerlink" title="AGGREGATE"></a>AGGREGATE</h4><p>使用 AGGREGATE 选项，你可以指定并集的结果集的聚合方式。</p><p>默认使用的参数 SUM ，可以将所有集合中某个成员的 score 值之 和 作为结果集中该成员的 score 值；使用参数 MIN ，可以将所有集合中某个成员的 最小 score 值作为结果集中该成员的 score 值；而参数 MAX 则是将所有集合中某个成员的 最大 score 值作为结果集中该成员的 score 值。</p><h4 id="返回值-78"><a href="#返回值-78" class="headerlink" title="返回值"></a>返回值</h4><p>保存到 destination 的结果集的基数。</p><h4 id="代码示例-75"><a href="#代码示例-75" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZRANGE programmer 0 -1 WITHSCORES</span><br><span class="line">1) <span class="string">"peter"</span></span><br><span class="line">2) <span class="string">"2000"</span></span><br><span class="line">3) <span class="string">"jack"</span></span><br><span class="line">4) <span class="string">"3500"</span></span><br><span class="line">5) <span class="string">"tom"</span></span><br><span class="line">6) <span class="string">"5000"</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE manager 0 -1 WITHSCORES</span><br><span class="line">1) <span class="string">"herry"</span></span><br><span class="line">2) <span class="string">"2000"</span></span><br><span class="line">3) <span class="string">"mary"</span></span><br><span class="line">4) <span class="string">"3500"</span></span><br><span class="line">5) <span class="string">"bob"</span></span><br><span class="line">6) <span class="string">"4000"</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZUNIONSTORE salary 2 programmer manager WEIGHTS 1 3   <span class="comment"># 公司决定加薪。。。除了程序员。。。</span></span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE salary 0 -1 WITHSCORES</span><br><span class="line">1) <span class="string">"peter"</span></span><br><span class="line">2) <span class="string">"2000"</span></span><br><span class="line">3) <span class="string">"jack"</span></span><br><span class="line">4) <span class="string">"3500"</span></span><br><span class="line">5) <span class="string">"tom"</span></span><br><span class="line">6) <span class="string">"5000"</span></span><br><span class="line">7) <span class="string">"herry"</span></span><br><span class="line">8) <span class="string">"6000"</span></span><br><span class="line">9) <span class="string">"mary"</span></span><br><span class="line">10) <span class="string">"10500"</span></span><br><span class="line">11) <span class="string">"bob"</span></span><br><span class="line">12) <span class="string">"12000"</span></span><br></pre></td></tr></table></figure><h3 id="ZINTERSTORE"><a href="#ZINTERSTORE" class="headerlink" title="ZINTERSTORE"></a>ZINTERSTORE</h3><h4 id="ZINTERSTORE-destination-numkeys-key-key-…-WEIGHTS-weight-weight-…-AGGREGATE-SUM-MIN-MAX"><a href="#ZINTERSTORE-destination-numkeys-key-key-…-WEIGHTS-weight-weight-…-AGGREGATE-SUM-MIN-MAX" class="headerlink" title="ZINTERSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX]"></a>ZINTERSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX]</h4><pre><code>可用版本： &gt;= 2.0.0
时间复杂度: O(N*K)+O(M*log(M))， N 为给定 key 中基数最小的有序集， K 为给定有序集的数量， M 为结果集的基数。
</code></pre><p>计算给定的一个或多个有序集的交集，其中给定 key 的数量必须以 numkeys 参数指定，并将该交集(结果集)储存到 destination 。</p><p>默认情况下，结果集中某个成员的 score 值是所有给定集下该成员 score 值之和.</p><p>关于 WEIGHTS 和 AGGREGATE 选项的描述，参见 ZUNIONSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX] 命令。</p><h4 id="返回值-79"><a href="#返回值-79" class="headerlink" title="返回值"></a>返回值</h4><p>保存到 destination 的结果集的基数。</p><h4 id="代码示例-76"><a href="#代码示例-76" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">redis &gt; ZADD mid_test 70 <span class="string">"Li Lei"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis &gt; ZADD mid_test 70 <span class="string">"Han Meimei"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis &gt; ZADD mid_test 99.5 <span class="string">"Tom"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis &gt; ZADD fin_test 88 <span class="string">"Li Lei"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis &gt; ZADD fin_test 75 <span class="string">"Han Meimei"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis &gt; ZADD fin_test 99.5 <span class="string">"Tom"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis &gt; ZINTERSTORE sum_point 2 mid_test fin_test</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis &gt; ZRANGE sum_point 0 -1 WITHSCORES     <span class="comment"># 显示有序集内所有成员及其 score 值</span></span><br><span class="line">1) <span class="string">"Han Meimei"</span></span><br><span class="line">2) <span class="string">"145"</span></span><br><span class="line">3) <span class="string">"Li Lei"</span></span><br><span class="line">4) <span class="string">"158"</span></span><br><span class="line">5) <span class="string">"Tom"</span></span><br><span class="line">6) <span class="string">"199"</span></span><br></pre></td></tr></table></figure><h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><h3 id="PFADD"><a href="#PFADD" class="headerlink" title="PFADD"></a>PFADD</h3><h4 id="PFADD-key-element-element-…"><a href="#PFADD-key-element-element-…" class="headerlink" title="PFADD key element [element …]"></a>PFADD key element [element …]</h4><pre><code>可用版本： &gt;= 2.8.9
时间复杂度： 每添加一个元素的复杂度为 O(1) 。
</code></pre><p>将任意数量的元素添加到指定的 HyperLogLog 里面。</p><p>作为这个命令的副作用， HyperLogLog 内部可能会被更新， 以便反映一个不同的唯一元素估计数量（也即是集合的基数）。</p><p>如果 HyperLogLog 估计的近似基数（approximated cardinality）在命令执行之后出现了变化， 那么命令返回 1 ， 否则返回 0 。 如果命令执行时给定的键不存在， 那么程序将先创建一个空的 HyperLogLog 结构， 然后再执行命令。</p><p>调用 PFADD key element [element …] 命令时可以只给定键名而不给定元素：</p><p>如果给定键已经是一个 HyperLogLog ， 那么这种调用不会产生任何效果；<br>但如果给定的键不存在， 那么命令会创建一个空的 HyperLogLog ， 并向客户端返回 1 。<br>要了解更多关于 HyperLogLog 数据结构的介绍知识， 请查阅 PFCOUNT key [key …] 命令的文档。</p><h4 id="返回值-80"><a href="#返回值-80" class="headerlink" title="返回值"></a>返回值</h4><p>整数回复： 如果 HyperLogLog 的内部储存被修改了， 那么返回 1 ， 否则返回 0 。</p><h4 id="代码示例-77"><a href="#代码示例-77" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; PFADD  databases  <span class="string">"Redis"</span>  <span class="string">"MongoDB"</span>  <span class="string">"MySQL"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; PFCOUNT  databases</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis&gt; PFADD  databases  <span class="string">"Redis"</span>    <span class="comment"># Redis 已经存在，不必对估计数量进行更新</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; PFCOUNT  databases    <span class="comment"># 元素估计数量没有变化</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis&gt; PFADD  databases  <span class="string">"PostgreSQL"</span>    <span class="comment"># 添加一个不存在的元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; PFCOUNT  databases    <span class="comment"># 估计数量增一</span></span><br><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="PFCOUNT"><a href="#PFCOUNT" class="headerlink" title="PFCOUNT"></a>PFCOUNT</h3><h4 id="PFCOUNT-key-key-…"><a href="#PFCOUNT-key-key-…" class="headerlink" title="PFCOUNT key [key …]"></a>PFCOUNT key [key …]</h4><pre><code>可用版本： &gt;= 2.8.9
时间复杂度： 当命令作用于单个 HyperLogLog 时， 复杂度为 O(1) ， 并且具有非常低的平均常数时间。 当命令作用于 N 个 HyperLogLog 时， 复杂度为 O(N) ， 常数时间也比处理单个 HyperLogLog 时要大得多。
</code></pre><p>当 PFCOUNT key [key …] 命令作用于单个键时， 返回储存在给定键的 HyperLogLog 的近似基数， 如果键不存在， 那么返回 0 。</p><p>当 PFCOUNT key [key …] 命令作用于多个键时， 返回所有给定 HyperLogLog 的并集的近似基数， 这个近似基数是通过将所有给定 HyperLogLog 合并至一个临时 HyperLogLog 来计算得出的。</p><p>通过 HyperLogLog 数据结构， 用户可以使用少量固定大小的内存， 来储存集合中的唯一元素 （每个 HyperLogLog 只需使用 12k 字节内存，以及几个字节的内存来储存键本身）。</p><p>命令返回的可见集合（observed set）基数并不是精确值， 而是一个带有 0.81% 标准错误（standard error）的近似值。</p><p>举个例子， 为了记录一天会执行多少次各不相同的搜索查询， 一个程序可以在每次执行搜索查询时调用一次 PFADD key element [element …] ， 并通过调用 PFCOUNT key [key …] 命令来获取这个记录的近似结果。</p><h4 id="返回值-81"><a href="#返回值-81" class="headerlink" title="返回值"></a>返回值</h4><p>整数回复： 给定 HyperLogLog 包含的唯一元素的近似数量。</p><h4 id="代码示例-78"><a href="#代码示例-78" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; PFADD  databases  <span class="string">"Redis"</span>  <span class="string">"MongoDB"</span>  <span class="string">"MySQL"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; PFCOUNT  databases</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis&gt; PFADD  databases  <span class="string">"Redis"</span>    <span class="comment"># Redis 已经存在，不必对估计数量进行更新</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; PFCOUNT  databases    <span class="comment"># 元素估计数量没有变化</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis&gt; PFADD  databases  <span class="string">"PostgreSQL"</span>    <span class="comment"># 添加一个不存在的元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; PFCOUNT  databases    <span class="comment"># 估计数量增一</span></span><br><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="PFMERGE"><a href="#PFMERGE" class="headerlink" title="PFMERGE"></a>PFMERGE</h3><h4 id="PFMERGE-destkey-sourcekey-sourcekey-…"><a href="#PFMERGE-destkey-sourcekey-sourcekey-…" class="headerlink" title="PFMERGE destkey sourcekey [sourcekey …]"></a>PFMERGE destkey sourcekey [sourcekey …]</h4><pre><code>可用版本： &gt;= 2.8.9
时间复杂度： O(N) ， 其中 N 为被合并的 HyperLogLog 数量， 不过这个命令的常数复杂度比较高。
</code></pre><p>将多个 HyperLogLog 合并（merge）为一个 HyperLogLog ， 合并后的 HyperLogLog 的基数接近于所有输入 HyperLogLog 的可见集合（observed set）的并集。</p><p>合并得出的 HyperLogLog 会被储存在 destkey 键里面， 如果该键并不存在， 那么命令在执行之前， 会先为该键创建一个空的 HyperLogLog 。</p><h4 id="返回值-82"><a href="#返回值-82" class="headerlink" title="返回值"></a>返回值</h4><p>字符串回复：返回 OK 。</p><h4 id="代码示例-79"><a href="#代码示例-79" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; PFADD  nosql  <span class="string">"Redis"</span>  <span class="string">"MongoDB"</span>  <span class="string">"Memcached"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; PFADD  RDBMS  <span class="string">"MySQL"</span> <span class="string">"MSSQL"</span> <span class="string">"PostgreSQL"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; PFMERGE  databases  nosql  RDBMS</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; PFCOUNT  databases</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br></pre></td></tr></table></figure><h2 id="地理位置"><a href="#地理位置" class="headerlink" title="地理位置"></a>地理位置</h2><h3 id="GEOADD"><a href="#GEOADD" class="headerlink" title="GEOADD"></a>GEOADD</h3><h4 id="GEOADD-key-longitude-latitude-member-longitude-latitude-member-…"><a href="#GEOADD-key-longitude-latitude-member-longitude-latitude-member-…" class="headerlink" title="GEOADD key longitude latitude member [longitude latitude member …]"></a>GEOADD key longitude latitude member [longitude latitude member …]</h4><pre><code>可用版本： &gt;= 3.2.0
时间复杂度： 每添加一个元素的复杂度为 O(log(N)) ， 其中 N 为键里面包含的位置元素数量。
</code></pre><p>将给定的空间元素（纬度、经度、名字）添加到指定的键里面。 这些数据会以有序集合的形式被储存在键里面， 从而使得像 GEORADIUS 和 GEORADIUSBYMEMBER 这样的命令可以在之后通过位置查询取得这些元素。</p><p>GEOADD 命令以标准的 x,y 格式接受参数， 所以用户必须先输入经度， 然后再输入纬度。 GEOADD 能够记录的坐标是有限的： 非常接近两极的区域是无法被索引的。 精确的坐标限制由 EPSG:900913 / EPSG:3785 / OSGEO:41001 等坐标系统定义， 具体如下：</p><p>有效的经度介于 -180 度至 180 度之间。<br>有效的纬度介于 -85.05112878 度至 85.05112878 度之间。<br>当用户尝试输入一个超出范围的经度或者纬度时， GEOADD 命令将返回一个错误。</p><h4 id="返回值-83"><a href="#返回值-83" class="headerlink" title="返回值"></a>返回值</h4><p>新添加到键里面的空间元素数量， 不包括那些已经存在但是被更新的元素。</p><h4 id="代码示例-80"><a href="#代码示例-80" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GEOADD Sicily 13.361389 38.115556 <span class="string">"Palermo"</span> 15.087269 37.502669 <span class="string">"Catania"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; GEODIST Sicily Palermo Catania</span><br><span class="line"><span class="string">"166274.15156960039"</span></span><br><span class="line"></span><br><span class="line">redis&gt; GEORADIUS Sicily 15 37 100 km</span><br><span class="line">1) <span class="string">"Catania"</span></span><br><span class="line"></span><br><span class="line">redis&gt; GEORADIUS Sicily 15 37 200 km</span><br><span class="line">1) <span class="string">"Palermo"</span></span><br><span class="line">2) <span class="string">"Catania"</span></span><br></pre></td></tr></table></figure><h3 id="GEOPOS"><a href="#GEOPOS" class="headerlink" title="GEOPOS"></a>GEOPOS</h3><h4 id="GEOPOS-key-member-member-…"><a href="#GEOPOS-key-member-member-…" class="headerlink" title="GEOPOS key member [member …]"></a>GEOPOS key member [member …]</h4><pre><code>可用版本： &gt;= 3.2.0
时间复杂度： 获取每个位置元素的复杂度为 O(log(N)) ， 其中 N 为键里面包含的位置元素数量。
</code></pre><p>从键里面返回所有给定位置元素的位置（经度和纬度）。</p><p>因为 GEOPOS 命令接受可变数量的位置元素作为输入， 所以即使用户只给定了一个位置元素， 命令也会返回数组回复。</p><h4 id="返回值-84"><a href="#返回值-84" class="headerlink" title="返回值"></a>返回值</h4><p>GEOPOS 命令返回一个数组， 数组中的每个项都由两个元素组成： 第一个元素为给定位置元素的经度， 而第二个元素则为给定位置元素的纬度。 当给定的位置元素不存在时， 对应的数组项为空值。</p><h4 id="代码示例-81"><a href="#代码示例-81" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GEOADD Sicily 13.361389 38.115556 <span class="string">"Palermo"</span> 15.087269 37.502669 <span class="string">"Catania"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; GEOPOS Sicily Palermo Catania NonExisting</span><br><span class="line">1) 1) <span class="string">"13.361389338970184"</span></span><br><span class="line">   2) <span class="string">"38.115556395496299"</span></span><br><span class="line">2) 1) <span class="string">"15.087267458438873"</span></span><br><span class="line">   2) <span class="string">"37.50266842333162"</span></span><br><span class="line">3) (nil)</span><br></pre></td></tr></table></figure><h3 id="GEODIST"><a href="#GEODIST" class="headerlink" title="GEODIST"></a>GEODIST</h3><h4 id="GEODIST-key-member1-member2-unit"><a href="#GEODIST-key-member1-member2-unit" class="headerlink" title="GEODIST key member1 member2 [unit]"></a>GEODIST key member1 member2 [unit]</h4><pre><code>可用版本： &gt;= 3.2.0
复杂度： O(log(N))
</code></pre><p>返回两个给定位置之间的距离。</p><p>如果两个位置之间的其中一个不存在， 那么命令返回空值。</p><p>指定单位的参数 unit 必须是以下单位的其中一个：</p><pre><code>m 表示单位为米。
km 表示单位为千米。
mi 表示单位为英里。
ft 表示单位为英尺。
</code></pre><p>如果用户没有显式地指定单位参数， 那么 GEODIST 默认使用米作为单位。</p><p>GEODIST 命令在计算距离时会假设地球为完美的球形， 在极限情况下， 这一假设最大会造成 0.5% 的误差。</p><h4 id="返回值-85"><a href="#返回值-85" class="headerlink" title="返回值"></a>返回值</h4><p>计算出的距离会以双精度浮点数的形式被返回。 如果给定的位置元素不存在， 那么命令返回空值。</p><h4 id="代码示例-82"><a href="#代码示例-82" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GEOADD Sicily 13.361389 38.115556 <span class="string">"Palermo"</span> 15.087269 37.502669 <span class="string">"Catania"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; GEODIST Sicily Palermo Catania</span><br><span class="line"><span class="string">"166274.15156960039"</span></span><br><span class="line"></span><br><span class="line">redis&gt; GEODIST Sicily Palermo Catania km</span><br><span class="line"><span class="string">"166.27415156960038"</span></span><br><span class="line"></span><br><span class="line">redis&gt; GEODIST Sicily Palermo Catania mi</span><br><span class="line"><span class="string">"103.31822459492736"</span></span><br><span class="line"></span><br><span class="line">redis&gt; GEODIST Sicily Foo Bar</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h3 id="GEORADIUS"><a href="#GEORADIUS" class="headerlink" title="GEORADIUS"></a>GEORADIUS</h3><h4 id="GEORADIUS-key-longitude-latitude-radius-m-km-ft-mi-WITHCOORD-WITHDIST-WITHHASH-ASC-DESC-COUNT-count"><a href="#GEORADIUS-key-longitude-latitude-radius-m-km-ft-mi-WITHCOORD-WITHDIST-WITHHASH-ASC-DESC-COUNT-count" class="headerlink" title="GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [ASC|DESC] [COUNT count]"></a>GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [ASC|DESC] [COUNT count]</h4><pre><code>可用版本： &gt;= 3.2.0
时间复杂度： O(N+log(M))， 其中 N 为指定半径范围内的位置元素数量， 而 M 则是被返回位置元素的数量。
</code></pre><p>以给定的经纬度为中心， 返回键包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素。</p><p>范围可以使用以下其中一个单位：</p><pre><code>m 表示单位为米。
km 表示单位为千米。
mi 表示单位为英里。
ft 表示单位为英尺。
</code></pre><p>在给定以下可选项时， 命令会返回额外的信息：</p><pre><code>WITHDIST ： 在返回位置元素的同时， 将位置元素与中心之间的距离也一并返回。 距离的单位和用户给定的范围单位保持一致。
WITHCOORD ： 将位置元素的经度和维度也一并返回。
WITHHASH ： 以 52 位有符号整数的形式， 返回位置元素经过原始 geohash 编码的有序集合分值。 这个选项主要用于底层应用或者调试， 实际中的作用并不大。
</code></pre><p>命令默认返回未排序的位置元素。 通过以下两个参数， 用户可以指定被返回位置元素的排序方式：</p><pre><code>ASC ： 根据中心的位置， 按照从近到远的方式返回位置元素。
DESC ： 根据中心的位置， 按照从远到近的方式返回位置元素。
</code></pre><p>在默认情况下， GEORADIUS 命令会返回所有匹配的位置元素。 虽然用户可以使用 COUNT \&lt;count> 选项去获取前 N 个匹配元素， 但是因为命令在内部可能会需要对所有被匹配的元素进行处理， 所以在对一个非常大的区域进行搜索时， 即使只使用 COUNT 选项去获取少量元素， 命令的执行速度也可能会非常慢。 但是从另一方面来说， 使用 COUNT 选项去减少需要返回的元素数量， 对于减少带宽来说仍然是非常有用的。</p><h4 id="返回值-86"><a href="#返回值-86" class="headerlink" title="返回值"></a>返回值</h4><p>GEORADIUS 命令返回一个数组， 具体来说：</p><ol><li><p>在没有给定任何 WITH 选项的情况下， 命令只会返回一个像 [“New York”,”Milan”,”Paris”] 这样的线性（linear）列表。</p></li><li><p>在指定了 WITHCOORD 、 WITHDIST 、 WITHHASH 等选项的情况下， 命令返回一个二层嵌套数组， 内层的每个子数组就表示一个元素。</p></li></ol><p>在返回嵌套数组时， 子数组的第一个元素总是位置元素的名字。 至于额外的信息， 则会作为子数组的后续元素， 按照以下顺序被返回：</p><ol><li>以浮点数格式返回的中心与位置元素之间的距离， 单位与用户指定范围时的单位一致。</li><li>geohash 整数。</li><li>由两个元素组成的坐标，分别为经度和纬度。</li></ol><p>举个例子， GEORADIUS Sicily 15 37 200 km withcoord withdist 这样的命令返回的每个子数组都是类似以下格式的：</p><p>[“Palermo”,”190.4424”,[“13.361389338970184”,”38.115556395496299”]]</p><h4 id="代码示例-83"><a href="#代码示例-83" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GEOADD Sicily 13.361389 38.115556 <span class="string">"Palermo"</span> 15.087269 37.502669 <span class="string">"Catania"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; GEORADIUS Sicily 15 37 200 km WITHDIST</span><br><span class="line">1) 1) <span class="string">"Palermo"</span></span><br><span class="line">   2) <span class="string">"190.4424"</span></span><br><span class="line">2) 1) <span class="string">"Catania"</span></span><br><span class="line">   2) <span class="string">"56.4413"</span></span><br><span class="line"></span><br><span class="line">redis&gt; GEORADIUS Sicily 15 37 200 km WITHCOORD</span><br><span class="line">1) 1) <span class="string">"Palermo"</span></span><br><span class="line">   2) 1) <span class="string">"13.361389338970184"</span></span><br><span class="line">      2) <span class="string">"38.115556395496299"</span></span><br><span class="line">2) 1) <span class="string">"Catania"</span></span><br><span class="line">   2) 1) <span class="string">"15.087267458438873"</span></span><br><span class="line">      2) <span class="string">"37.50266842333162"</span></span><br><span class="line"></span><br><span class="line">redis&gt; GEORADIUS Sicily 15 37 200 km WITHDIST WITHCOORD</span><br><span class="line">1) 1) <span class="string">"Palermo"</span></span><br><span class="line">   2) <span class="string">"190.4424"</span></span><br><span class="line">   3) 1) <span class="string">"13.361389338970184"</span></span><br><span class="line">      2) <span class="string">"38.115556395496299"</span></span><br><span class="line">2) 1) <span class="string">"Catania"</span></span><br><span class="line">   2) <span class="string">"56.4413"</span></span><br><span class="line">   3) 1) <span class="string">"15.087267458438873"</span></span><br><span class="line">      2) <span class="string">"37.50266842333162"</span></span><br></pre></td></tr></table></figure><h3 id="GEORADIUSBYMEMBER"><a href="#GEORADIUSBYMEMBER" class="headerlink" title="GEORADIUSBYMEMBER"></a>GEORADIUSBYMEMBER</h3><h4 id="GEORADIUSBYMEMBER-key-member-radius-m-km-ft-mi-WITHCOORD-WITHDIST-WITHHASH-ASC-DESC-COUNT-count"><a href="#GEORADIUSBYMEMBER-key-member-radius-m-km-ft-mi-WITHCOORD-WITHDIST-WITHHASH-ASC-DESC-COUNT-count" class="headerlink" title="GEORADIUSBYMEMBER key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [ASC|DESC] [COUNT count]"></a>GEORADIUSBYMEMBER key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [ASC|DESC] [COUNT count]</h4><pre><code>可用版本： &gt;= 3.2.0
时间复杂度： O(log(N)+M)， 其中 N 为指定范围之内的元素数量， 而 M 则是被返回的元素数量。
</code></pre><p>这个命令和 GEORADIUS 命令一样， 都可以找出位于指定范围内的元素， 但是 GEORADIUSBYMEMBER 的中心点是由给定的位置元素决定的， 而不是像 GEORADIUS 那样， 使用输入的经度和纬度来决定中心点。</p><h4 id="返回值-87"><a href="#返回值-87" class="headerlink" title="返回值"></a>返回值</h4><p>一个数组， 数组中的每个项表示一个范围之内的位置元素。</p><h4 id="代码示例-84"><a href="#代码示例-84" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GEOADD Sicily 13.583333 37.316667 <span class="string">"Agrigento"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; GEOADD Sicily 13.361389 38.115556 <span class="string">"Palermo"</span> 15.087269 37.502669 <span class="string">"Catania"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; GEORADIUSBYMEMBER Sicily Agrigento 100 km</span><br><span class="line">1) <span class="string">"Agrigento"</span></span><br><span class="line">2) <span class="string">"Palermo"</span></span><br></pre></td></tr></table></figure><h3 id="GEOHASH"><a href="#GEOHASH" class="headerlink" title="GEOHASH"></a>GEOHASH</h3><h4 id="GEOHASH-key-member-member-…"><a href="#GEOHASH-key-member-member-…" class="headerlink" title="GEOHASH key member [member …]"></a>GEOHASH key member [member …]</h4><pre><code>可用版本： &gt;= 3.2.0
时间复杂度： 寻找每个位置元素的复杂度为 O(log(N)) ， 其中 N 为给定键包含的位置元素数量。
</code></pre><p>返回一个或多个位置元素的 Geohash 表示。</p><h4 id="返回值-88"><a href="#返回值-88" class="headerlink" title="返回值"></a>返回值</h4><p>一个数组， 数组的每个项都是一个 geohash 。 命令返回的 geohash 的位置与用户给定的位置元素的位置一一对应。</p><h4 id="代码示例-85"><a href="#代码示例-85" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GEOADD Sicily 13.361389 38.115556 <span class="string">"Palermo"</span> 15.087269 37.502669 <span class="string">"Catania"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; GEOHASH Sicily Palermo Catania</span><br><span class="line">1) <span class="string">"sqc8b49rny0"</span></span><br><span class="line">2) <span class="string">"sqdtr74hyu0"</span></span><br></pre></td></tr></table></figure><h2 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h2><h3 id="SETBIT"><a href="#SETBIT" class="headerlink" title="SETBIT"></a>SETBIT</h3><h4 id="SETBIT-key-offset-value"><a href="#SETBIT-key-offset-value" class="headerlink" title="SETBIT key offset value"></a>SETBIT key offset value</h4><pre><code>可用版本： &gt;= 2.2.0
时间复杂度: O(1)
</code></pre><p>对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。</p><p>位的设置或清除取决于 value 参数，可以是 0 也可以是 1 。</p><p>当 key 不存在时，自动生成一个新的字符串值。</p><p>字符串会进行伸展(grown)以确保它可以将 value 保存在指定的偏移量上。当字符串值进行伸展时，空白位置以 0 填充。</p><p>offset 参数必须大于或等于 0 ，小于 2^32 (bit 映射被限制在 512 MB 之内)。</p><h4 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h4><p>对使用大的 offset 的 SETBIT 操作来说，内存分配可能造成 Redis 服务器被阻塞。具体参考 SETRANGE key offset value 命令，warning(警告)部分。</p><h4 id="返回值-89"><a href="#返回值-89" class="headerlink" title="返回值"></a>返回值</h4><p>指定偏移量原来储存的位。</p><h4 id="代码示例-86"><a href="#代码示例-86" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SETBIT bit 10086 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; GETBIT bit 10086</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; GETBIT bit 100   <span class="comment"># bit 默认被初始化为 0</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><h3 id="GETBIT"><a href="#GETBIT" class="headerlink" title="GETBIT"></a>GETBIT</h3><h4 id="GETBIT-key-offset"><a href="#GETBIT-key-offset" class="headerlink" title="GETBIT key offset"></a>GETBIT key offset</h4><pre><code>可用版本： &gt;= 2.2.0
时间复杂度： O(1)
</code></pre><p>对 key 所储存的字符串值，获取指定偏移量上的位(bit)。</p><p>当 offset 比字符串值的长度大，或者 key 不存在时，返回 0 。</p><h4 id="返回值-90"><a href="#返回值-90" class="headerlink" title="返回值"></a>返回值</h4><p>字符串值指定偏移量上的位(bit)。</p><h4 id="代码示例-87"><a href="#代码示例-87" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对不存在的 key 或者不存在的 offset 进行 GETBIT， 返回 0</span></span><br><span class="line">redis&gt; EXISTS bit</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; GETBIT bit 10086</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对已存在的 offset 进行 GETBIT</span></span><br><span class="line">redis&gt; SETBIT bit 10086 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; GETBIT bit 10086</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><h3 id="BITCOUNT"><a href="#BITCOUNT" class="headerlink" title="BITCOUNT"></a>BITCOUNT</h3><h4 id="BITCOUNT-key-start-end"><a href="#BITCOUNT-key-start-end" class="headerlink" title="BITCOUNT key [start] [end]"></a>BITCOUNT key [start] [end]</h4><pre><code>可用版本： &gt;= 2.6.0
时间复杂度： O(N)
</code></pre><p>计算给定字符串中，被设置为 1 的比特位的数量。</p><p>一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。</p><p>start 和 end 参数的设置和 GETRANGE key start end 命令类似，都可以使用负数值： 比如 -1 表示最后一个字节， -2 表示倒数第二个字节，以此类推。</p><p>不存在的 key 被当成是空字符串来处理，因此对一个不存在的 key 进行 BITCOUNT 操作，结果为 0 。</p><h4 id="返回值-91"><a href="#返回值-91" class="headerlink" title="返回值"></a>返回值</h4><p>被设置为 1 的位的数量。</p><h4 id="代码示例-88"><a href="#代码示例-88" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; BITCOUNT bits</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; SETBIT bits 0 1          <span class="comment"># 0001</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; BITCOUNT bits</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; SETBIT bits 3 1          <span class="comment"># 1001</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; BITCOUNT bits</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure><h4 id="模式：使用-bitmap-实现用户上线次数统计"><a href="#模式：使用-bitmap-实现用户上线次数统计" class="headerlink" title="模式：使用 bitmap 实现用户上线次数统计"></a>模式：使用 bitmap 实现用户上线次数统计</h4><p>Bitmap 对于一些特定类型的计算非常有效。</p><p>假设现在我们希望记录自己网站上的用户的上线频率，比如说，计算用户 A 上线了多少天，用户 B 上线了多少天，诸如此类，以此作为数据，从而决定让哪些用户参加 beta 测试等活动 —— 这个模式可以使用 SETBIT key offset value 和 BITCOUNT key [start] [end] 来实现。</p><p>比如说，每当用户在某一天上线的时候，我们就使用 SETBIT key offset value ，以用户名作为 key ，将那天所代表的网站的上线日作为 offset 参数，并将这个 offset 上的为设置为 1 。</p><p>举个例子，如果今天是网站上线的第 100 天，而用户 peter 在今天阅览过网站，那么执行命令 SETBIT peter 100 1 ；如果明天 peter 也继续阅览网站，那么执行命令 SETBIT peter 101 1 ，以此类推。</p><p>当要计算 peter 总共以来的上线次数时，就使用 BITCOUNT key [start] [end] 命令：执行 BITCOUNT peter ，得出的结果就是 peter 上线的总天数。</p><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>前面的上线次数统计例子，即使运行 10 年，占用的空间也只是每个用户 10*365 比特位(bit)，也即是每个用户 456 字节。对于这种大小的数据来说， BITCOUNT key [start] [end] 的处理速度就像 GET key 和 INCR key 这种 O(1) 复杂度的操作一样快。</p><p>如果你的 bitmap 数据非常大，那么可以考虑使用以下两种方法：</p><ol><li>将一个大的 bitmap 分散到不同的 key 中，作为小的 bitmap 来处理。使用 Lua 脚本可以很方便地完成这一工作。</li><li>使用 BITCOUNT key [start] [end] 的 start 和 end 参数，每次只对所需的部分位进行计算，将位的累积工作(accumulating)放到客户端进行，并且对结果进行缓存 (caching)。</li></ol><h3 id="BITPOS"><a href="#BITPOS" class="headerlink" title="BITPOS"></a>BITPOS</h3><h4 id="BITPOS-key-bit-start-end"><a href="#BITPOS-key-bit-start-end" class="headerlink" title="BITPOS key bit [start] [end]"></a>BITPOS key bit [start] [end]</h4><pre><code>可用版本： &gt;= 2.8.7
时间复杂度： O(N)，其中 N 为位图包含的二进制位数量
</code></pre><p>返回位图中第一个值为 bit 的二进制位的位置。</p><p>在默认情况下， 命令将检测整个位图， 但用户也可以通过可选的 start 参数和 end 参数指定要检测的范围。</p><h4 id="返回值-92"><a href="#返回值-92" class="headerlink" title="返回值"></a>返回值</h4><p>整数回复。</p><h4 id="代码示例-89"><a href="#代码示例-89" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SETBIT bits 3 1    <span class="comment"># 1000</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; BITPOS bits 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; BITPOS bits 1</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure><h3 id="BITOP"><a href="#BITOP" class="headerlink" title="BITOP"></a>BITOP</h3><h4 id="BITOP-operation-destkey-key-key-…"><a href="#BITOP-operation-destkey-key-key-…" class="headerlink" title="BITOP operation destkey key [key …]"></a>BITOP operation destkey key [key …]</h4><p> 可用版本： &gt;= 2.6.0<br> 时间复杂度： O(N)<br>对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。</p><p>operation 可以是 AND 、 OR 、 NOT 、 XOR 这四种操作中的任意一种：</p><pre><code>BITOP AND destkey key [key ...] ，对一个或多个 key 求逻辑并，并将结果保存到 destkey 。
BITOP OR destkey key [key ...] ，对一个或多个 key 求逻辑或，并将结果保存到 destkey 。
BITOP XOR destkey key [key ...] ，对一个或多个 key 求逻辑异或，并将结果保存到 destkey 。
BITOP NOT destkey key ，对给定 key 求逻辑非，并将结果保存到 destkey 。
</code></pre><p>除了 NOT 操作之外，其他操作都可以接受一个或多个 key 作为输入。</p><p>处理不同长度的字符串</p><pre><code>当 BITOP 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 0 。
空的 key 也被看作是包含 0 的字符串序列。
</code></pre><h4 id="返回值-93"><a href="#返回值-93" class="headerlink" title="返回值"></a>返回值</h4><p>保存到 destkey 的字符串的长度，和输入 key 中最长的字符串长度相等。</p><h4 id="Note-4"><a href="#Note-4" class="headerlink" title="Note"></a>Note</h4><p>BITOP 的复杂度为 O(N) ，当处理大型矩阵(matrix)或者进行大数据量的统计时，最好将任务指派到附属节点(slave)进行，避免阻塞主节点。</p><h4 id="代码示例-90"><a href="#代码示例-90" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SETBIT bits-1 0 1        <span class="comment"># bits-1 = 1001</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; SETBIT bits-1 3 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; SETBIT bits-2 0 1        <span class="comment"># bits-2 = 1011</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; SETBIT bits-2 1 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; SETBIT bits-2 3 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; BITOP AND and-result bits-1 bits-2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; GETBIT and-result 0      <span class="comment"># and-result = 1001</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; GETBIT and-result 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; GETBIT and-result 2</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; GETBIT and-result 3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><h3 id="BITFIELD"><a href="#BITFIELD" class="headerlink" title="BITFIELD"></a>BITFIELD</h3><h4 id="BITFIELD-key-GET-type-offset-SET-type-offset-value-INCRBY-type-offset-increment-OVERFLOW-WRAP-SAT-FAIL"><a href="#BITFIELD-key-GET-type-offset-SET-type-offset-value-INCRBY-type-offset-increment-OVERFLOW-WRAP-SAT-FAIL" class="headerlink" title="BITFIELD key [GET type offset] [SET type offset value] [INCRBY type offset increment] [OVERFLOW WRAP|SAT|FAIL]"></a>BITFIELD key [GET type offset] [SET type offset value] [INCRBY type offset increment] [OVERFLOW WRAP|SAT|FAIL]</h4><pre><code>可用版本： &gt;= 3.2.0
时间复杂度： 每个子命令的复杂度为 O(1) 。
</code></pre><p>BITFIELD 命令可以将一个 Redis 字符串看作是一个由二进制位组成的数组， 并对这个数组中储存的长度不同的整数进行访问 （被储存的整数无需进行对齐）。 换句话说， 通过这个命令， 用户可以执行诸如 “对偏移量 1234 上的 5 位长有符号整数进行设置”、 “获取偏移量 4567 上的 31 位长无符号整数”等操作。 此外， BITFIELD 命令还可以对指定的整数执行加法操作和减法操作， 并且这些操作可以通过设置妥善地处理计算时出现的溢出情况。</p><p>BITFIELD 命令可以在一次调用中同时对多个位范围进行操作： 它接受一系列待执行的操作作为参数， 并返回一个数组作为回复， 数组中的每个元素就是对应操作的执行结果。</p><p>比如以下命令就展示了如何对位于偏移量 100 的 8 位长有符号整数执行加法操作， 并获取位于偏移量 0 上的 4 位长无符号整数：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; BITFIELD mykey INCRBY i8 100 1 GET u4 0</span><br><span class="line">1) (<span class="built_in">integer</span>) 1</span><br><span class="line">2) (<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><p></p><p>注意：</p><pre><code>使用 GET 子命令对超出字符串当前范围的二进制位进行访问（包括键不存在的情况）， 超出部分的二进制位的值将被当做是 0 。
使用 SET 子命令或者 INCRBY 子命令对超出字符串当前范围的二进制位进行访问将导致字符串被扩大， 被扩大的部分会使用值为 0 的二进制位进行填充。 在对字符串进行扩展时， 命令会根据字符串目前已有的最远端二进制位， 计算出执行操作所需的最小长度。
</code></pre><h4 id="支持的子命令以及数字类型"><a href="#支持的子命令以及数字类型" class="headerlink" title="支持的子命令以及数字类型"></a>支持的子命令以及数字类型</h4><p>以下是 BITFIELD 命令支持的子命令：</p><pre><code>GET &lt;type&gt; &lt;offset&gt; —— 返回指定的二进制位范围。
SET &lt;type&gt; &lt;offset&gt; &lt;value&gt; —— 对指定的二进制位范围进行设置，并返回它的旧值。
INCRBY &lt;type&gt; &lt;offset&gt; &lt;increment&gt; —— 对指定的二进制位范围执行加法操作，并返回它的旧值。用户可以通过向 increment 参数传入负值来实现相应的减法操作。
</code></pre><p>除了以上三个子命令之外， 还有一个子命令， 它可以改变之后执行的 INCRBY 子命令在发生溢出情况时的行为：</p><pre><code>OVERFLOW [WRAP|SAT|FAIL]
</code></pre><p>当被设置的二进制位范围值为整数时， 用户可以在类型参数的前面添加 i 来表示有符号整数， 或者使用 u 来表示无符号整数。 比如说， 我们可以使用 u8 来表示 8 位长的无符号整数， 也可以使用 i16 来表示 16 位长的有符号整数。</p><p>BITFIELD 命令最大支持 64 位长的有符号整数以及 63 位长的无符号整数， 其中无符号整数的 63 位长度限制是由于 Redis 协议目前还无法返回 64 位长的无符号整数而导致的。</p><h4 id="二进制位和位置偏移量"><a href="#二进制位和位置偏移量" class="headerlink" title="二进制位和位置偏移量"></a>二进制位和位置偏移量</h4><p>在二进制位范围命令中， 用户有两种方法来设置偏移量：</p><pre><code>如果用户给定的是一个没有任何前缀的数字， 那么这个数字指示的就是字符串以零为开始（zero-base）的偏移量。
另一方面， 如果用户给定的是一个带有 # 前缀的偏移量， 那么命令将使用这个偏移量与被设置的数字类型的位长度相乘， 从而计算出真正的偏移量。
</code></pre><p>比如说， 对于以下这个命令来说：</p><pre><code>BITFIELD mystring SET i8 #0 100 i8 #1 200
</code></pre><p>命令会把 mystring 键里面， 第一个 i8 长度的二进制位的值设置为 100 ， 并把第二个 i8 长度的二进制位的值设置为 200 。 当我们把一个字符串键当成数组来使用， 并且数组中储存的都是同等长度的整数时， 使用 # 前缀可以让我们免去手动计算被设置二进制位所在位置的麻烦。</p><h4 id="溢出控制"><a href="#溢出控制" class="headerlink" title="溢出控制"></a>溢出控制</h4><p>用户可以通过 OVERFLOW 命令以及以下展示的三个参数， 指定 BITFIELD 命令在执行自增或者自减操作时， 碰上向上溢出（overflow）或者向下溢出（underflow）情况时的行为：</p><pre><code>WRAP ： 使用回绕（wrap around）方法处理有符号整数和无符号整数的溢出情况。 对于无符号整数来说， 回绕就像使用数值本身与能够被储存的最大无符号整数执行取模计算， 这也是 C 语言的标准行为。 对于有符号整数来说， 上溢将导致数字重新从最小的负数开始计算， 而下溢将导致数字重新从最大的正数开始计算。 比如说， 如果我们对一个值为 127 的 i8 整数执行加一操作， 那么将得到结果 -128 。
SAT ： 使用饱和计算（saturation arithmetic）方法处理溢出， 也即是说， 下溢计算的结果为最小的整数值， 而上溢计算的结果为最大的整数值。 举个例子， 如果我们对一个值为 120 的 i8 整数执行加 10 计算， 那么命令的结果将为 i8 类型所能储存的最大整数值 127 。 与此相反， 如果一个针对 i8 值的计算造成了下溢， 那么这个 i8 值将被设置为 -127 。
FAIL ： 在这一模式下， 命令将拒绝执行那些会导致上溢或者下溢情况出现的计算， 并向用户返回空值表示计算未被执行。
</code></pre><p>需要注意的是， OVERFLOW 子命令只会对紧随着它之后被执行的 INCRBY 命令产生效果， 这一效果将一直持续到与它一同被执行的下一个 OVERFLOW 命令为止。 在默认情况下， INCRBY 命令使用 WRAP 方式来处理溢出计算。</p><p>以下是一个使用 OVERFLOW 子命令来控制溢出行为的例子：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1</span><br><span class="line">1) (<span class="built_in">integer</span>) 1</span><br><span class="line">2) (<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">&gt; BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1</span><br><span class="line">1) (<span class="built_in">integer</span>) 2</span><br><span class="line">2) (<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">&gt; BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1</span><br><span class="line">1) (<span class="built_in">integer</span>) 3</span><br><span class="line">2) (<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">&gt; BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1</span><br><span class="line">1) (<span class="built_in">integer</span>) 0  -- 使用默认的 WRAP 方式处理溢出</span><br><span class="line">2) (<span class="built_in">integer</span>) 3  -- 使用 SAT 方式处理溢出</span><br></pre></td></tr></table></figure><p></p><p>而以下则是一个因为 OVERFLOW FAIL 行为而导致子命令返回空值的例子：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; BITFIELD mykey OVERFLOW FAIL incrby u2 102 1</span><br><span class="line">1) (nil)</span><br></pre></td></tr></table></figure><p></p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>BITFIELD 命令的作用在于它能够将很多小的整数储存到一个长度较大的位图中， 又或者将一个非常庞大的键分割为多个较小的键来进行储存， 从而非常高效地使用内存， 使得 Redis 能够得到更多不同的应用 —— 特别是在实时分析领域： BITFIELD 能够以指定的方式对计算溢出进行控制的能力， 使得它可以被应用于这一领域。</p><h4 id="性能注意事项"><a href="#性能注意事项" class="headerlink" title="性能注意事项"></a>性能注意事项</h4><p>BITFIELD 在一般情况下都是一个快速的命令， 需要注意的是， 访问一个长度较短的字符串的远端二进制位将引发一次内存分配操作， 这一操作花费的时间可能会比命令访问已有的字符串花费的时间要长。</p><h4 id="二进制位的排列"><a href="#二进制位的排列" class="headerlink" title="二进制位的排列"></a>二进制位的排列</h4><p>BITFIELD 把位图第一个字节偏移量 0 上的二进制位看作是 most significant 位， 以此类推。 举个例子， 如果我们对一个已经预先被全部设置为 0 的位图进行设置， 将它在偏移量 7 的值设置为 5 位无符号整数值 23 （二进制位为 10111 ）， 那么命令将生产出以下这个位图表示：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+--------+--------+</span><br><span class="line">|00000001|01110000|</span><br><span class="line">+--------+--------+</span><br></pre></td></tr></table></figure><p></p><p>当偏移量和整数长度与字节边界进行对齐时， BITFIELD 表示二进制位的方式跟大端表示法（big endian）一致， 但是在没有对齐的情况下， 理解这些二进制位是如何进行排列也是非常重要的。</p><h4 id="返回值-94"><a href="#返回值-94" class="headerlink" title="返回值"></a>返回值</h4><p>BITFIELD 命令的返回值是一个数组， 数组中的每个元素对应一个被执行的子命令。 需要注意的是， OVERFLOW 子命令本身并不产生任何回复。</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="EXISTS"><a href="#EXISTS" class="headerlink" title="EXISTS"></a>EXISTS</h3><h4 id="EXISTS-key"><a href="#EXISTS-key" class="headerlink" title="EXISTS key"></a>EXISTS key</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度： O(1)
</code></pre><p>检查给定 key 是否存在。</p><h4 id="返回值-95"><a href="#返回值-95" class="headerlink" title="返回值"></a>返回值</h4><p>若 key 存在，返回 1 ，否则返回 0 。</p><h4 id="代码示例-91"><a href="#代码示例-91" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET db <span class="string">"redis"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; EXISTS db</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; DEL db</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; EXISTS db</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><h3 id="TYPE"><a href="#TYPE" class="headerlink" title="TYPE"></a>TYPE</h3><h4 id="TYPE-key"><a href="#TYPE-key" class="headerlink" title="TYPE key"></a>TYPE key</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度： O(1)
</code></pre><p>返回 key 所储存的值的类型。</p><h4 id="返回值-96"><a href="#返回值-96" class="headerlink" title="返回值"></a>返回值</h4><pre><code>none (key不存在)
string (字符串)
list (列表)
set (集合)
zset (有序集)
hash (哈希表)
stream （流）
</code></pre><h4 id="代码示例-92"><a href="#代码示例-92" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字符串</span></span><br><span class="line">redis&gt; SET weather <span class="string">"sunny"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; TYPE weather</span><br><span class="line">string</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表</span></span><br><span class="line">redis&gt; LPUSH book_list <span class="string">"programming in scala"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; TYPE book_list</span><br><span class="line">list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 集合</span></span><br><span class="line">redis&gt; SADD pat <span class="string">"dog"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; TYPE pat</span><br><span class="line"><span class="built_in">set</span></span><br></pre></td></tr></table></figure><h3 id="RENAME"><a href="#RENAME" class="headerlink" title="RENAME"></a>RENAME</h3><h4 id="RENAME-key-newkey"><a href="#RENAME-key-newkey" class="headerlink" title="RENAME key newkey"></a>RENAME key newkey</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度： O(1)
</code></pre><p>将 key 改名为 newkey 。</p><p>当 key 和 newkey 相同，或者 key 不存在时，返回一个错误。</p><p>当 newkey 已经存在时， RENAME 命令将覆盖旧值。</p><h4 id="返回值-97"><a href="#返回值-97" class="headerlink" title="返回值"></a>返回值</h4><p>改名成功时提示 OK ，失败时候返回一个错误。</p><h4 id="代码示例-93"><a href="#代码示例-93" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># key 存在且 newkey 不存在</span></span><br><span class="line">redis&gt; SET message <span class="string">"hello world"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; RENAME message greeting</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; EXISTS message               <span class="comment"># message 不复存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; EXISTS greeting              <span class="comment"># greeting 取而代之</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当 key 不存在时，返回错误</span></span><br><span class="line">redis&gt; RENAME fake_key never_exists</span><br><span class="line">(error) ERR no such key</span><br><span class="line"></span><br><span class="line"><span class="comment"># newkey 已存在时， RENAME 会覆盖旧 newkey</span></span><br><span class="line">redis&gt; SET pc <span class="string">"lenovo"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SET personal_computer <span class="string">"dell"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; RENAME pc personal_computer</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET pc</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line">redis:1&gt; GET personal_computer      <span class="comment"># 原来的值 dell 被覆盖了</span></span><br><span class="line"><span class="string">"lenovo"</span></span><br></pre></td></tr></table></figure><h3 id="RENAMENX"><a href="#RENAMENX" class="headerlink" title="RENAMENX"></a>RENAMENX</h3><h4 id="RENAMENX-key-newkey"><a href="#RENAMENX-key-newkey" class="headerlink" title="RENAMENX key newkey"></a>RENAMENX key newkey</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度： O(1)
</code></pre><p>当且仅当 newkey 不存在时，将 key 改名为 newkey 。</p><p>当 key 不存在时，返回一个错误。</p><h4 id="返回值-98"><a href="#返回值-98" class="headerlink" title="返回值"></a>返回值</h4><p>修改成功时，返回 1 ； 如果 newkey 已经存在，返回 0 。</p><h4 id="代码示例-94"><a href="#代码示例-94" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># newkey 不存在，改名成功</span></span><br><span class="line">redis&gt; SET player <span class="string">"MPlyaer"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; EXISTS best_player</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; RENAMENX player best_player</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># newkey存在时，失败</span></span><br><span class="line">redis&gt; SET animal <span class="string">"bear"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SET favorite_animal <span class="string">"butterfly"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; RENAMENX animal favorite_animal</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; get animal</span><br><span class="line"><span class="string">"bear"</span></span><br><span class="line"></span><br><span class="line">redis&gt; get favorite_animal</span><br><span class="line"><span class="string">"butterfly"</span></span><br></pre></td></tr></table></figure><h3 id="MOVE"><a href="#MOVE" class="headerlink" title="MOVE"></a>MOVE</h3><h4 id="MOVE-key-db"><a href="#MOVE-key-db" class="headerlink" title="MOVE key db"></a>MOVE key db</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度： O(1)
</code></pre><p>将当前数据库的 key 移动到给定的数据库 db 当中。</p><p>如果当前数据库(源数据库)和给定数据库(目标数据库)有相同名字的给定 key ，或者 key 不存在于当前数据库，那么 MOVE 没有任何效果。</p><p>因此，也可以利用这一特性，将 MOVE 当作锁(locking)原语(primitive)。</p><h4 id="返回值-99"><a href="#返回值-99" class="headerlink" title="返回值"></a>返回值</h4><p>移动成功返回 1 ，失败则返回 0 。</p><h4 id="代码示例-95"><a href="#代码示例-95" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># key 存在于当前数据库</span></span><br><span class="line">redis&gt; SELECT 0                             <span class="comment"># redis默认使用数据库 0，为了清晰起见，这里再显式指定一次。</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SET song <span class="string">"secret base - Zone"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; MOVE song 1                          <span class="comment"># 将 song 移动到数据库 1</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; EXISTS song                          <span class="comment"># song 已经被移走</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; SELECT 1                             <span class="comment"># 使用数据库 1</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis:1&gt; EXISTS song                        <span class="comment"># 证实 song 被移到了数据库 1 (注意命令提示符变成了"redis:1"，表明正在使用数据库 1)</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当 key 不存在的时候</span></span><br><span class="line">redis:1&gt; EXISTS fake_key</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis:1&gt; MOVE fake_key 0                    <span class="comment"># 试图从数据库 1 移动一个不存在的 key 到数据库 0，失败</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis:1&gt; select 0                           <span class="comment"># 使用数据库0</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; EXISTS fake_key                      <span class="comment"># 证实 fake_key 不存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当源数据库和目标数据库有相同的 key 时</span></span><br><span class="line">redis&gt; SELECT 0                             <span class="comment"># 使用数据库0</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; SET favorite_fruit <span class="string">"banana"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SELECT 1                             <span class="comment"># 使用数据库1</span></span><br><span class="line">OK</span><br><span class="line">redis:1&gt; SET favorite_fruit <span class="string">"apple"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis:1&gt; SELECT 0                           <span class="comment"># 使用数据库0，并试图将 favorite_fruit 移动到数据库 1</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; MOVE favorite_fruit 1                <span class="comment"># 因为两个数据库有相同的 key，MOVE 失败</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; GET favorite_fruit                   <span class="comment"># 数据库 0 的 favorite_fruit 没变</span></span><br><span class="line"><span class="string">"banana"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SELECT 1</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis:1&gt; GET favorite_fruit                 <span class="comment"># 数据库 1 的 favorite_fruit 也是</span></span><br><span class="line"><span class="string">"apple"</span></span><br></pre></td></tr></table></figure><h3 id="DEL"><a href="#DEL" class="headerlink" title="DEL"></a>DEL</h3><h4 id="DEL-key-key-…"><a href="#DEL-key-key-…" class="headerlink" title="DEL key [key …]"></a>DEL key [key …]</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度：O(N)， N 为被删除的 key 的数量，其中删除单个字符串类型的 key ，时间复杂度为O(1)；删除单个列表、集合、有序集合或哈希表类型的 key ，时间复杂度为O(M)， M 为以上数据结构内的元素数量。
</code></pre><p>删除给定的一个或多个 key 。</p><p>不存在的 key 会被忽略。</p><h4 id="返回值-100"><a href="#返回值-100" class="headerlink" title="返回值"></a>返回值</h4><p>被删除 key 的数量。</p><h4 id="代码示例-96"><a href="#代码示例-96" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  删除单个 key</span></span><br><span class="line">redis&gt; SET name huangz</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; DEL name</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除一个不存在的 key</span></span><br><span class="line">redis&gt; EXISTS phone</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; DEL phone <span class="comment"># 失败，没有 key 被删除</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时删除多个 key</span></span><br><span class="line">redis&gt; SET name <span class="string">"redis"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SET <span class="built_in">type</span> <span class="string">"key-value store"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SET website <span class="string">"redis.com"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; DEL name <span class="built_in">type</span> website</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure><h3 id="RANDOMKEY"><a href="#RANDOMKEY" class="headerlink" title="RANDOMKEY"></a>RANDOMKEY</h3><h4 id="RANDOMKEY-1"><a href="#RANDOMKEY-1" class="headerlink" title="RANDOMKEY"></a>RANDOMKEY</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度： O(1)
</code></pre><p>从当前数据库中随机返回(不删除)一个 key 。</p><h4 id="返回值-101"><a href="#返回值-101" class="headerlink" title="返回值"></a>返回值</h4><p>当数据库不为空时，返回一个 key 。 当数据库为空时，返回 nil 。</p><h4 id="代码示例-97"><a href="#代码示例-97" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据库不为空</span></span><br><span class="line">redis&gt; MSET fruit <span class="string">"apple"</span> drink <span class="string">"beer"</span> food <span class="string">"cookies"</span>   <span class="comment"># 设置多个 key</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; RANDOMKEY</span><br><span class="line"><span class="string">"fruit"</span></span><br><span class="line"></span><br><span class="line">redis&gt; RANDOMKEY</span><br><span class="line"><span class="string">"food"</span></span><br><span class="line"></span><br><span class="line">redis&gt; KEYS *    <span class="comment"># 查看数据库内所有key，证明 RANDOMKEY 并不删除 key</span></span><br><span class="line">1) <span class="string">"food"</span></span><br><span class="line">2) <span class="string">"drink"</span></span><br><span class="line">3) <span class="string">"fruit"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库为空</span></span><br><span class="line">redis&gt; FLUSHDB  <span class="comment"># 删除当前数据库所有 key</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; RANDOMKEY</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h3 id="DBSIZE"><a href="#DBSIZE" class="headerlink" title="DBSIZE"></a>DBSIZE</h3><h4 id="DBSIZE-1"><a href="#DBSIZE-1" class="headerlink" title="DBSIZE"></a>DBSIZE</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度： O(1)
</code></pre><p>返回当前数据库的 key 的数量。</p><h4 id="返回值-102"><a href="#返回值-102" class="headerlink" title="返回值"></a>返回值</h4><p>当前数据库的 key 的数量。</p><h4 id="代码示例-98"><a href="#代码示例-98" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; DBSIZE</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line"></span><br><span class="line">redis&gt; SET new_key <span class="string">"hello_moto"</span>     <span class="comment"># 增加一个 key 试试</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; DBSIZE</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br></pre></td></tr></table></figure><h3 id="KEYS"><a href="#KEYS" class="headerlink" title="KEYS"></a>KEYS</h3><h4 id="KEYS-pattern"><a href="#KEYS-pattern" class="headerlink" title="KEYS pattern"></a>KEYS pattern</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度： O(N)， N 为数据库中 key 的数量。
</code></pre><p>查找所有符合给定模式 pattern 的 key ， 比如说：</p><pre><code>KEYS * 匹配数据库中所有 key 。
KEYS h?llo 匹配 hello ， hallo 和 hxllo 等。
KEYS h*llo 匹配 hllo 和 heeeeello 等。
KEYS h[ae]llo 匹配 hello 和 hallo ，但不匹配 hillo 。
</code></pre><p>特殊符号用 \ 隔开。</p><h4 id="Warning-1"><a href="#Warning-1" class="headerlink" title="Warning"></a>Warning</h4><p>KEYS 的速度非常快，但在一个大的数据库中使用它仍然可能造成性能问题，如果你需要从一个数据集中查找特定的 key ，你最好还是用 Redis 的集合结构(set)来代替。</p><h4 id="返回值-103"><a href="#返回值-103" class="headerlink" title="返回值"></a>返回值</h4><p>符合给定模式的 key 列表。</p><h4 id="代码示例-99"><a href="#代码示例-99" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MSET one 1 two 2 three 3 four 4  <span class="comment"># 一次设置 4 个 key</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; KEYS *o*</span><br><span class="line">1) <span class="string">"four"</span></span><br><span class="line">2) <span class="string">"two"</span></span><br><span class="line">3) <span class="string">"one"</span></span><br><span class="line"></span><br><span class="line">redis&gt; KEYS t??</span><br><span class="line">1) <span class="string">"two"</span></span><br><span class="line"></span><br><span class="line">redis&gt; KEYS t[w]*</span><br><span class="line">1) <span class="string">"two"</span></span><br><span class="line"></span><br><span class="line">redis&gt; KEYS *  <span class="comment"># 匹配数据库内所有 key</span></span><br><span class="line">1) <span class="string">"four"</span></span><br><span class="line">2) <span class="string">"three"</span></span><br><span class="line">3) <span class="string">"two"</span></span><br><span class="line">4) <span class="string">"one"</span></span><br></pre></td></tr></table></figure><h3 id="SCAN"><a href="#SCAN" class="headerlink" title="SCAN"></a>SCAN</h3><h4 id="SCAN-cursor-MATCH-pattern-COUNT-count"><a href="#SCAN-cursor-MATCH-pattern-COUNT-count" class="headerlink" title="SCAN cursor [MATCH pattern] [COUNT count]"></a>SCAN cursor [MATCH pattern] [COUNT count]</h4><pre><code>可用版本： &gt;= 2.8.0
时间复杂度：增量式迭代命令每次执行的复杂度为 O(1) ， 对数据集进行一次完整迭代的复杂度为 O(N) ， 其中 N 为数据集中的元素数量。
</code></pre><p>SCAN 命令及其相关的 SSCAN 命令、 HSCAN 命令和 ZSCAN 命令都用于增量地迭代（incrementally iterate）一集元素（a collection of elements）：</p><pre><code>SCAN 命令用于迭代当前数据库中的数据库键。
SSCAN 命令用于迭代集合键中的元素。
HSCAN 命令用于迭代哈希键中的键值对。
ZSCAN 命令用于迭代有序集合中的元素（包括元素成员和元素分值）。
</code></pre><p>以上列出的四个命令都支持增量式迭代， 它们每次执行都只会返回少量元素， 所以这些命令可以用于生产环境， 而不会出现像 KEYS 命令、 SMEMBERS 命令带来的问题 —— 当 KEYS 命令被用于处理一个大的数据库时， 又或者 SMEMBERS 命令被用于处理一个大的集合键时， 它们可能会阻塞服务器达数秒之久。</p><p>不过， 增量式迭代命令也不是没有缺点的： 举个例子， 使用 SMEMBERS 命令可以返回集合键当前包含的所有元素， 但是对于 SCAN 这类增量式迭代命令来说， 因为在对键进行增量式迭代的过程中， 键可能会被修改， 所以增量式迭代命令只能对被返回的元素提供有限的保证 （offer limited guarantees about the returned elements）。</p><p>因为 SCAN 、 SSCAN 、 HSCAN 和 ZSCAN 四个命令的工作方式都非常相似， 所以这个文档会一并介绍这四个命令， 但是要记住：</p><ul><li>SSCAN 命令、 HSCAN 命令和 ZSCAN 命令的第一个参数总是一个数据库键。</li><li>而 SCAN 命令则不需要在第一个参数提供任何数据库键 —— 因为它迭代的是当前数据库中的所有数据库键。<h4 id="SCAN-命令的基本用法"><a href="#SCAN-命令的基本用法" class="headerlink" title="SCAN 命令的基本用法"></a>SCAN 命令的基本用法</h4>SCAN 命令是一个基于游标的迭代器（cursor based iterator）： SCAN 命令每次被调用之后， 都会向用户返回一个新的游标， 用户在下次迭代时需要使用这个新游标作为 SCAN 命令的游标参数， 以此来延续之前的迭代过程。</li></ul><p>当 SCAN 命令的游标参数被设置为 0 时， 服务器将开始一次新的迭代， 而当服务器向用户返回值为 0 的游标时， 表示迭代已结束。</p><p>以下是一个 SCAN 命令的迭代过程示例：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; scan 0</span><br><span class="line">1) <span class="string">"17"</span></span><br><span class="line">2)  1) <span class="string">"key:12"</span></span><br><span class="line">    2) <span class="string">"key:8"</span></span><br><span class="line">    3) <span class="string">"key:4"</span></span><br><span class="line">    4) <span class="string">"key:14"</span></span><br><span class="line">    5) <span class="string">"key:16"</span></span><br><span class="line">    6) <span class="string">"key:17"</span></span><br><span class="line">    7) <span class="string">"key:15"</span></span><br><span class="line">    8) <span class="string">"key:10"</span></span><br><span class="line">    9) <span class="string">"key:3"</span></span><br><span class="line">    10) <span class="string">"key:7"</span></span><br><span class="line">    11) <span class="string">"key:1"</span></span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; scan 17</span><br><span class="line">1) <span class="string">"0"</span></span><br><span class="line">2) 1) <span class="string">"key:5"</span></span><br><span class="line">   2) <span class="string">"key:18"</span></span><br><span class="line">   3) <span class="string">"key:0"</span></span><br><span class="line">   4) <span class="string">"key:2"</span></span><br><span class="line">   5) <span class="string">"key:19"</span></span><br><span class="line">   6) <span class="string">"key:13"</span></span><br><span class="line">   7) <span class="string">"key:6"</span></span><br><span class="line">   8) <span class="string">"key:9"</span></span><br><span class="line">   9) <span class="string">"key:11"</span></span><br></pre></td></tr></table></figure><p></p><p>在上面这个例子中， 第一次迭代使用 0 作为游标， 表示开始一次新的迭代。</p><p>第二次迭代使用的是第一次迭代时返回的游标， 也即是命令回复第一个元素的值 —— 17 。</p><p>从上面的示例可以看到， SCAN 命令的回复是一个包含两个元素的数组， 第一个数组元素是用于进行下一次迭代的新游标， 而第二个数组元素则是一个数组， 这个数组中包含了所有被迭代的元素。</p><p>在第二次调用 SCAN 命令时， 命令返回了游标 0 ， 这表示迭代已经结束， 整个数据集（collection）已经被完整遍历过了。</p><p>以 0 作为游标开始一次新的迭代， 一直调用 SCAN 命令， 直到命令返回游标 0 ， 我们称这个过程为一次完整遍历（full iteration）。</p><h4 id="SCAN-命令的保证（guarantees）"><a href="#SCAN-命令的保证（guarantees）" class="headerlink" title="SCAN 命令的保证（guarantees）"></a>SCAN 命令的保证（guarantees）</h4><p>SCAN 命令， 以及其他增量式迭代命令， 在进行完整遍历的情况下可以为用户带来以下保证： 从完整遍历开始直到完整遍历结束期间， 一直存在于数据集内的所有元素都会被完整遍历返回； 这意味着， 如果有一个元素， 它从遍历开始直到遍历结束期间都存在于被遍历的数据集当中， 那么 SCAN 命令总会在某次迭代中将这个元素返回给用户。</p><p>然而因为增量式命令仅仅使用游标来记录迭代状态， 所以这些命令带有以下缺点：</p><ul><li>同一个元素可能会被返回多次。 处理重复元素的工作交由应用程序负责， 比如说， 可以考虑将迭代返回的元素仅仅用于可以安全地重复执行多次的操作上。</li><li>如果一个元素是在迭代过程中被添加到数据集的， 又或者是在迭代过程中从数据集中被删除的， 那么这个元素可能会被返回， 也可能不会， 这是未定义的（undefined）。<br>SCAN 命令每次执行返回的元素数量<br>增量式迭代命令并不保证每次执行都返回某个给定数量的元素。</li></ul><p>增量式命令甚至可能会返回零个元素， 但只要命令返回的游标不是 0 ， 应用程序就不应该将迭代视作结束。</p><p>不过命令返回的元素数量总是符合一定规则的， 在实际中：</p><ul><li>对于一个大数据集来说， 增量式迭代命令每次最多可能会返回数十个元素；</li><li>而对于一个足够小的数据集来说， 如果这个数据集的底层表示为编码数据结构（encoded data structure，适用于是小集合键、小哈希键和小有序集合键）， 那么增量迭代命令将在一次调用中返回数据集中的所有元素。<br>最后， 用户可以通过增量式迭代命令提供的 COUNT 选项来指定每次迭代返回元素的最大值。</li></ul><h4 id="COUNT-选项"><a href="#COUNT-选项" class="headerlink" title="COUNT 选项"></a>COUNT 选项</h4><p>虽然增量式迭代命令不保证每次迭代所返回的元素数量， 但我们可以使用 COUNT 选项， 对命令的行为进行一定程度上的调整。</p><p>基本上， COUNT 选项的作用就是让用户告知迭代命令， 在每次迭代中应该从数据集里返回多少元素。</p><p>虽然 COUNT 选项只是对增量式迭代命令的一种提示（hint）， 但是在大多数情况下， 这种提示都是有效的。</p><ul><li>COUNT 参数的默认值为 10 。</li><li>在迭代一个足够大的、由哈希表实现的数据库、集合键、哈希键或者有序集合键时， 如果用户没有使用 MATCH 选项， 那么命令返回的元素数量通常和 COUNT 选项指定的一样， 或者比 COUNT 选项指定的数量稍多一些。</li><li>在迭代一个编码为整数集合（intset，一个只由整数值构成的小集合）、 或者编码为压缩列表（ziplist，由不同值构成的一个小哈希或者一个小有序集合）时， 增量式迭代命令通常会无视 COUNT 选项指定的值， 在第一次迭代就将数据集包含的所有元素都返回给用户。<h4 id="Note-5"><a href="#Note-5" class="headerlink" title="Note"></a>Note</h4></li></ul><p>并非每次迭代都要使用相同的 COUNT 值。</p><p>用户可以在每次迭代中按自己的需要随意改变 COUNT 值， 只要记得将上次迭代返回的游标用到下次迭代里面就可以了。</p><h4 id="MATCH-选项"><a href="#MATCH-选项" class="headerlink" title="MATCH 选项"></a>MATCH 选项</h4><p>和 KEYS 命令一样， 增量式迭代命令也可以通过提供一个 glob 风格的模式参数， 让命令只返回和给定模式相匹配的元素， 这一点可以通过在执行增量式迭代命令时， 通过给定 MATCH \&lt;pattern> 参数来实现。</p><p>以下是一个使用 MATCH 选项进行迭代的示例：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; sadd myset 1 2 3 foo foobar feelsgood</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; sscan myset 0 match f*</span><br><span class="line">1) <span class="string">"0"</span></span><br><span class="line">2) 1) <span class="string">"foo"</span></span><br><span class="line">   2) <span class="string">"feelsgood"</span></span><br><span class="line">   3) <span class="string">"foobar"</span></span><br></pre></td></tr></table></figure><p></p><p>需要注意的是， 对元素的模式匹配工作是在命令从数据集中取出元素之后， 向客户端返回元素之前的这段时间内进行的， 所以如果被迭代的数据集中只有少量元素和模式相匹配， 那么迭代命令或许会在多次执行中都不返回任何元素。</p><p>以下是这种情况的一个例子：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; scan 0 MATCH *11*</span><br><span class="line">1) <span class="string">"288"</span></span><br><span class="line">2) 1) <span class="string">"key:911"</span></span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; scan 288 MATCH *11*</span><br><span class="line">1) <span class="string">"224"</span></span><br><span class="line">2) (empty list or <span class="built_in">set</span>)</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; scan 224 MATCH *11*</span><br><span class="line">1) <span class="string">"80"</span></span><br><span class="line">2) (empty list or <span class="built_in">set</span>)</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; scan 80 MATCH *11*</span><br><span class="line">1) <span class="string">"176"</span></span><br><span class="line">2) (empty list or <span class="built_in">set</span>)</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; scan 176 MATCH *11* COUNT 1000</span><br><span class="line">1) <span class="string">"0"</span></span><br><span class="line">2)  1) <span class="string">"key:611"</span></span><br><span class="line">    2) <span class="string">"key:711"</span></span><br><span class="line">    3) <span class="string">"key:118"</span></span><br><span class="line">    4) <span class="string">"key:117"</span></span><br><span class="line">    5) <span class="string">"key:311"</span></span><br><span class="line">    6) <span class="string">"key:112"</span></span><br><span class="line">    7) <span class="string">"key:111"</span></span><br><span class="line">    8) <span class="string">"key:110"</span></span><br><span class="line">    9) <span class="string">"key:113"</span></span><br><span class="line">   10) <span class="string">"key:211"</span></span><br><span class="line">   11) <span class="string">"key:411"</span></span><br><span class="line">   12) <span class="string">"key:115"</span></span><br><span class="line">   13) <span class="string">"key:116"</span></span><br><span class="line">   14) <span class="string">"key:114"</span></span><br><span class="line">   15) <span class="string">"key:119"</span></span><br><span class="line">   16) <span class="string">"key:811"</span></span><br><span class="line">   17) <span class="string">"key:511"</span></span><br><span class="line">   18) <span class="string">"key:11"</span></span><br></pre></td></tr></table></figure><p></p><p>如你所见， 以上的大部分迭代都不返回任何元素。</p><p>在最后一次迭代， 我们通过将 COUNT 选项的参数设置为 1000 ， 强制命令为本次迭代扫描更多元素， 从而使得命令返回的元素也变多了。</p><h4 id="并发执行多个迭代"><a href="#并发执行多个迭代" class="headerlink" title="并发执行多个迭代"></a>并发执行多个迭代</h4><p>在同一时间， 可以有任意多个客户端对同一数据集进行迭代， 客户端每次执行迭代都需要传入一个游标， 并在迭代执行之后获得一个新的游标， 而这个游标就包含了迭代的所有状态， 因此， 服务器无须为迭代记录任何状态。</p><h4 id="中途停止迭代"><a href="#中途停止迭代" class="headerlink" title="中途停止迭代"></a>中途停止迭代</h4><p>因为迭代的所有状态都保存在游标里面， 而服务器无须为迭代保存任何状态， 所以客户端可以在中途停止一个迭代， 而无须对服务器进行任何通知。</p><p>即使有任意数量的迭代在中途停止， 也不会产生任何问题。</p><h4 id="使用错误的游标进行增量式迭代"><a href="#使用错误的游标进行增量式迭代" class="headerlink" title="使用错误的游标进行增量式迭代"></a>使用错误的游标进行增量式迭代</h4><p>使用间断的（broken）、负数、超出范围或者其他非正常的游标来执行增量式迭代并不会造成服务器崩溃， 但可能会让命令产生未定义的行为。</p><p>未定义行为指的是， 增量式命令对返回值所做的保证可能会不再为真。</p><p>只有两种游标是合法的：</p><ol><li>在开始一个新的迭代时， 游标必须为 0 。</li><li>增量式迭代命令在执行之后返回的， 用于延续（continue）迭代过程的游标。<h4 id="迭代终结的保证"><a href="#迭代终结的保证" class="headerlink" title="迭代终结的保证"></a>迭代终结的保证</h4>增量式迭代命令所使用的算法只保证在数据集的大小有界（bounded）的情况下， 迭代才会停止， 换句话说， 如果被迭代数据集的大小不断地增长的话， 增量式迭代命令可能永远也无法完成一次完整迭代。</li></ol><p>从直觉上可以看出， 当一个数据集不断地变大时， 想要访问这个数据集中的所有元素就需要做越来越多的工作， 能否结束一个迭代取决于用户执行迭代的速度是否比数据集增长的速度更快。</p><h4 id="返回值-104"><a href="#返回值-104" class="headerlink" title="返回值"></a>返回值</h4><p>SCAN 命令、 SSCAN 命令、 HSCAN 命令和 ZSCAN 命令都返回一个包含两个元素的 multi-bulk 回复： 回复的第一个元素是字符串表示的无符号 64 位整数（游标）， 回复的第二个元素是另一个 multi-bulk 回复， 这个 multi-bulk 回复包含了本次被迭代的元素。</p><pre><code>SCAN 命令返回的每个元素都是一个数据库键。

SSCAN 命令返回的每个元素都是一个集合成员。

HSCAN 命令返回的每个元素都是一个键值对，一个键值对由一个键和一个值组成。

ZSCAN 命令返回的每个元素都是一个有序集合元素，一个有序集合元素由一个成员（member）和一个分值（score）组成。
</code></pre><h3 id="SORT"><a href="#SORT" class="headerlink" title="SORT"></a>SORT</h3><h4 id="SORT-key-BY-pattern-LIMIT-offset-count-GET-pattern-GET-pattern-…-ASC-DESC-ALPHA-STORE-destination"><a href="#SORT-key-BY-pattern-LIMIT-offset-count-GET-pattern-GET-pattern-…-ASC-DESC-ALPHA-STORE-destination" class="headerlink" title="SORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern …]] [ASC | DESC] [ALPHA] [STORE destination]"></a>SORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern …]] [ASC | DESC] [ALPHA] [STORE destination]</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度： O(N+M*log(M))， N 为要排序的列表或集合内的元素数量， M 为要返回的元素数量。如果只是使用 SORT 命令的 GET 选项获取数据而没有进行排序，时间复杂度 O(N)。
</code></pre><p>返回或保存给定列表、集合、有序集合 key 中经过排序的元素。</p><p>排序默认以数字作为对象，值被解释为双精度浮点数，然后进行比较。</p><h4 id="一般-SORT-用法"><a href="#一般-SORT-用法" class="headerlink" title="一般 SORT 用法"></a>一般 SORT 用法</h4><p>最简单的 SORT 使用方法是 SORT key 和 SORT key DESC ：</p><ul><li>SORT key 返回键值从小到大排序的结果。</li><li>SORT key DESC 返回键值从大到小排序的结果。<br>假设 today_cost 列表保存了今日的开销金额， 那么可以用 SORT 命令对它进行排序：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开销金额列表</span></span><br><span class="line">redis&gt; LPUSH today_cost 30 1.5 10 8</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 排序</span></span><br><span class="line">redis&gt; SORT today_cost</span><br><span class="line">1) <span class="string">"1.5"</span></span><br><span class="line">2) <span class="string">"8"</span></span><br><span class="line">3) <span class="string">"10"</span></span><br><span class="line">4) <span class="string">"30"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 逆序排序</span></span><br><span class="line">redis 127.0.0.1:6379&gt; SORT today_cost DESC</span><br><span class="line">1) <span class="string">"30"</span></span><br><span class="line">2) <span class="string">"10"</span></span><br><span class="line">3) <span class="string">"8"</span></span><br><span class="line">4) <span class="string">"1.5"</span></span><br></pre></td></tr></table></figure><h4 id="使用-ALPHA-修饰符对字符串进行排序"><a href="#使用-ALPHA-修饰符对字符串进行排序" class="headerlink" title="使用 ALPHA 修饰符对字符串进行排序"></a>使用 ALPHA 修饰符对字符串进行排序</h4><p>因为 SORT 命令默认排序对象为数字， 当需要对字符串进行排序时， 需要显式地在 SORT 命令之后添加 ALPHA 修饰符：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 网址</span></span><br><span class="line">redis&gt; LPUSH website <span class="string">"www.reddit.com"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; LPUSH website <span class="string">"www.slashdot.com"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; LPUSH website <span class="string">"www.infoq.com"</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认（按数字）排序</span></span><br><span class="line">redis&gt; SORT website</span><br><span class="line">1) <span class="string">"www.infoq.com"</span></span><br><span class="line">2) <span class="string">"www.slashdot.com"</span></span><br><span class="line">3) <span class="string">"www.reddit.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按字符排序</span></span><br><span class="line">redis&gt; SORT website ALPHA</span><br><span class="line">1) <span class="string">"www.infoq.com"</span></span><br><span class="line">2) <span class="string">"www.reddit.com"</span></span><br><span class="line">3) <span class="string">"www.slashdot.com"</span></span><br></pre></td></tr></table></figure><p></p><p>如果系统正确地设置了 LC_COLLATE 环境变量的话，Redis能识别 UTF-8 编码。</p><h4 id="使用-LIMIT-修饰符限制返回结果"><a href="#使用-LIMIT-修饰符限制返回结果" class="headerlink" title="使用 LIMIT 修饰符限制返回结果"></a>使用 LIMIT 修饰符限制返回结果</h4><p>排序之后返回元素的数量可以通过 LIMIT 修饰符进行限制， 修饰符接受 offset 和 count 两个参数：</p><ul><li>offset 指定要跳过的元素数量。</li><li>count 指定跳过 offset 个指定的元素之后，要返回多少个对象。<br>以下例子返回排序结果的前 5 个对象( offset 为 0 表示没有元素被跳过)。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加测试数据，列表值为 1 指 10</span></span><br><span class="line">redis 127.0.0.1:6379&gt; RPUSH rank 1 3 5 7 9</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; RPUSH rank 2 4 6 8 10</span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回列表中最小的 5 个值</span></span><br><span class="line">redis 127.0.0.1:6379&gt; SORT rank LIMIT 0 5</span><br><span class="line">1) <span class="string">"1"</span></span><br><span class="line">2) <span class="string">"2"</span></span><br><span class="line">3) <span class="string">"3"</span></span><br><span class="line">4) <span class="string">"4"</span></span><br><span class="line">5) <span class="string">"5"</span></span><br></pre></td></tr></table></figure></li></ul><p>可以组合使用多个修饰符。以下例子返回从大到小排序的前 5 个对象。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SORT rank LIMIT 0 5 DESC</span><br><span class="line">1) <span class="string">"10"</span></span><br><span class="line">2) <span class="string">"9"</span></span><br><span class="line">3) <span class="string">"8"</span></span><br><span class="line">4) <span class="string">"7"</span></span><br><span class="line">5) <span class="string">"6"</span></span><br></pre></td></tr></table></figure><p></p><h4 id="使用外部-key-进行排序"><a href="#使用外部-key-进行排序" class="headerlink" title="使用外部 key 进行排序"></a>使用外部 key 进行排序</h4><p>可以使用外部 key 的数据作为权重，代替默认的直接对比键值的方式来进行排序。</p><p>假设现在有用户数据如下：</p><p>以下代码将数据输入到 Redis 中：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># admin</span></span><br><span class="line">redis 127.0.0.1:6379&gt; LPUSH uid 1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SET user_name_1 admin</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SET user_level_1 9999</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># jack</span></span><br><span class="line">redis 127.0.0.1:6379&gt; LPUSH uid 2</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SET user_name_2 jack</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SET user_level_2 10</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># peter</span></span><br><span class="line">redis 127.0.0.1:6379&gt; LPUSH uid 3</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SET user_name_3 peter</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SET user_level_3 25</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># mary</span></span><br><span class="line">redis 127.0.0.1:6379&gt; LPUSH uid 4</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SET user_name_4 mary</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SET user_level_4 70</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p></p><h5 id="BY-选项"><a href="#BY-选项" class="headerlink" title="BY 选项"></a>BY 选项</h5><p>默认情况下， SORT uid 直接按 uid 中的值排序：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SORT uid</span><br><span class="line">1) <span class="string">"1"</span>      <span class="comment"># admin</span></span><br><span class="line">2) <span class="string">"2"</span>      <span class="comment"># jack</span></span><br><span class="line">3) <span class="string">"3"</span>      <span class="comment"># peter</span></span><br><span class="line">4) <span class="string">"4"</span>      <span class="comment"># mary</span></span><br></pre></td></tr></table></figure><p></p><p>通过使用 BY 选项，可以让 uid 按其他键的元素来排序。</p><p>比如说， 以下代码让 uid 键按照 user_level_{uid} 的大小来排序：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SORT uid BY user_level_*</span><br><span class="line">1) <span class="string">"2"</span>      <span class="comment"># jack , level = 10</span></span><br><span class="line">2) <span class="string">"3"</span>      <span class="comment"># peter, level = 25</span></span><br><span class="line">3) <span class="string">"4"</span>      <span class="comment"># mary, level = 70</span></span><br><span class="line">4) <span class="string">"1"</span>      <span class="comment"># admin, level = 9999</span></span><br></pre></td></tr></table></figure><p></p><p>user_level_* 是一个占位符， 它先取出 uid 中的值， 然后再用这个值来查找相应的键。</p><p>比如在对 uid 列表进行排序时， 程序就会先取出 uid 的值 1 、 2 、 3 、 4 ， 然后使用 user_level_1 、 user_level_2 、 user_level_3 和 user_level_4 的值作为排序 uid 的权重。</p><h5 id="GET-选项"><a href="#GET-选项" class="headerlink" title="GET 选项"></a>GET 选项</h5><p>使用 GET 选项， 可以根据排序的结果来取出相应的键值。</p><p>比如说， 以下代码先排序 uid ， 再取出键 user_name_{uid} 的值：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SORT uid GET user_name_*</span><br><span class="line">1) <span class="string">"admin"</span></span><br><span class="line">2) <span class="string">"jack"</span></span><br><span class="line">3) <span class="string">"peter"</span></span><br><span class="line">4) <span class="string">"mary"</span></span><br></pre></td></tr></table></figure><p></p><h5 id="组合使用-BY-和-GET"><a href="#组合使用-BY-和-GET" class="headerlink" title="组合使用 BY 和 GET"></a>组合使用 BY 和 GET</h5><p>通过组合使用 BY 和 GET ， 可以让排序结果以更直观的方式显示出来。</p><p>比如说， 以下代码先按 user_level_{uid} 来排序 uid 列表， 再取出相应的 user_name_{uid} 的值：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SORT uid BY user_level_* GET user_name_*</span><br><span class="line">1) <span class="string">"jack"</span>       <span class="comment"># level = 10</span></span><br><span class="line">2) <span class="string">"peter"</span>      <span class="comment"># level = 25</span></span><br><span class="line">3) <span class="string">"mary"</span>       <span class="comment"># level = 70</span></span><br><span class="line">4) <span class="string">"admin"</span>      <span class="comment"># level = 9999</span></span><br></pre></td></tr></table></figure><p></p><p>现在的排序结果要比只使用 SORT uid BY user_level_* 要直观得多。</p><h5 id="获取多个外部键"><a href="#获取多个外部键" class="headerlink" title="获取多个外部键"></a>获取多个外部键</h5><p>可以同时使用多个 GET 选项， 获取多个外部键的值。</p><p>以下代码就按 uid 分别获取 user_level_{uid} 和 user_name_{uid} ：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SORT uid GET user_level_* GET user_name_*</span><br><span class="line">1) <span class="string">"9999"</span>       <span class="comment"># level</span></span><br><span class="line">2) <span class="string">"admin"</span>      <span class="comment"># name</span></span><br><span class="line">3) <span class="string">"10"</span></span><br><span class="line">4) <span class="string">"jack"</span></span><br><span class="line">5) <span class="string">"25"</span></span><br><span class="line">6) <span class="string">"peter"</span></span><br><span class="line">7) <span class="string">"70"</span></span><br><span class="line">8) <span class="string">"mary"</span></span><br></pre></td></tr></table></figure><p></p><p>GET 有一个额外的参数规则，那就是 —— 可以用 # 获取被排序键的值。</p><p>以下代码就将 uid 的值、及其相应的 user_level_ <em>和 user_name_</em> 都返回为结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SORT uid GET <span class="comment"># GET user_level_* GET user_name_*</span></span><br><span class="line">1) <span class="string">"1"</span>          <span class="comment"># uid</span></span><br><span class="line">2) <span class="string">"9999"</span>       <span class="comment"># level</span></span><br><span class="line">3) <span class="string">"admin"</span>      <span class="comment"># name</span></span><br><span class="line">4) <span class="string">"2"</span></span><br><span class="line">5) <span class="string">"10"</span></span><br><span class="line">6) <span class="string">"jack"</span></span><br><span class="line">7) <span class="string">"3"</span></span><br><span class="line">8) <span class="string">"25"</span></span><br><span class="line">9) <span class="string">"peter"</span></span><br><span class="line">10) <span class="string">"4"</span></span><br><span class="line">11) <span class="string">"70"</span></span><br><span class="line">12) <span class="string">"mary"</span></span><br></pre></td></tr></table></figure><p></p><h5 id="获取外部键，但不进行排序"><a href="#获取外部键，但不进行排序" class="headerlink" title="获取外部键，但不进行排序"></a>获取外部键，但不进行排序</h5><p>通过将一个不存在的键作为参数传给 BY 选项， 可以让 SORT 跳过排序操作， 直接返回结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SORT uid BY not-exists-key</span><br><span class="line">1) <span class="string">"4"</span></span><br><span class="line">2) <span class="string">"3"</span></span><br><span class="line">3) <span class="string">"2"</span></span><br><span class="line">4) <span class="string">"1"</span></span><br></pre></td></tr></table></figure><p></p><p>这种用法在单独使用时，没什么实际用处。</p><p>不过，通过将这种用法和 GET 选项配合， 就可以在不排序的情况下， 获取多个外部键， 相当于执行一个整合的获取操作（类似于 SQL 数据库的 join 关键字）。</p><p>以下代码演示了，如何在不引起排序的情况下，使用 SORT 、 BY 和 GET 获取多个外部键：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SORT uid BY not-exists-key GET <span class="comment"># GET user_level_* GET user_name_*</span></span><br><span class="line">1) <span class="string">"4"</span>      <span class="comment"># id</span></span><br><span class="line">2) <span class="string">"70"</span>     <span class="comment"># level</span></span><br><span class="line">3) <span class="string">"mary"</span>   <span class="comment"># name</span></span><br><span class="line">4) <span class="string">"3"</span></span><br><span class="line">5) <span class="string">"25"</span></span><br><span class="line">6) <span class="string">"peter"</span></span><br><span class="line">7) <span class="string">"2"</span></span><br><span class="line">8) <span class="string">"10"</span></span><br><span class="line">9) <span class="string">"jack"</span></span><br><span class="line">10) <span class="string">"1"</span></span><br><span class="line">11) <span class="string">"9999"</span></span><br><span class="line">12) <span class="string">"admin"</span></span><br></pre></td></tr></table></figure><p></p><h5 id="将哈希表作为-GET-或-BY-的参数"><a href="#将哈希表作为-GET-或-BY-的参数" class="headerlink" title="将哈希表作为 GET 或 BY 的参数"></a>将哈希表作为 GET 或 BY 的参数</h5><p>除了可以将字符串键之外， 哈希表也可以作为 GET 或 BY 选项的参数来使用。</p><p>比如说，对于前面给出的用户信息表：</p><p>我们可以不将用户的名字和级别保存在 user_name_{uid} 和 user_level_{uid} 两个字符串键中， 而是用一个带有 name 域和 level 域的哈希表 user_info_{uid} 来保存用户的名字和级别信息：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; HMSET user_info_1 name admin level 9999</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; HMSET user_info_2 name jack level 10</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; HMSET user_info_3 name peter level 25</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; HMSET user_info_4 name mary level 70</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p></p><p>之后， BY 和 GET 选项都可以用 key-&gt;field 的格式来获取哈希表中的域的值， 其中 key 表示哈希表键， 而 field 则表示哈希表的域：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SORT uid BY user_info_*-&gt;level</span><br><span class="line">1) <span class="string">"2"</span></span><br><span class="line">2) <span class="string">"3"</span></span><br><span class="line">3) <span class="string">"4"</span></span><br><span class="line">4) <span class="string">"1"</span></span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SORT uid BY user_info_*-&gt;level GET user_info_*-&gt;name</span><br><span class="line">1) <span class="string">"jack"</span></span><br><span class="line">2) <span class="string">"peter"</span></span><br><span class="line">3) <span class="string">"mary"</span></span><br><span class="line">4) <span class="string">"admin"</span></span><br></pre></td></tr></table></figure><p></p><h4 id="保存排序结果"><a href="#保存排序结果" class="headerlink" title="保存排序结果"></a>保存排序结果</h4><p>默认情况下， SORT 操作只是简单地返回排序结果，并不进行任何保存操作。</p><p>通过给 STORE 选项指定一个 key 参数，可以将排序结果保存到给定的键上。</p><p>如果被指定的 key 已存在，那么原有的值将被排序结果覆盖。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试数据</span></span><br><span class="line">redis 127.0.0.1:6379&gt; RPUSH numbers 1 3 5 7 9</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; RPUSH numbers 2 4 6 8 10</span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; LRANGE numbers 0 -1</span><br><span class="line">1) <span class="string">"1"</span></span><br><span class="line">2) <span class="string">"3"</span></span><br><span class="line">3) <span class="string">"5"</span></span><br><span class="line">4) <span class="string">"7"</span></span><br><span class="line">5) <span class="string">"9"</span></span><br><span class="line">6) <span class="string">"2"</span></span><br><span class="line">7) <span class="string">"4"</span></span><br><span class="line">8) <span class="string">"6"</span></span><br><span class="line">9) <span class="string">"8"</span></span><br><span class="line">10) <span class="string">"10"</span></span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SORT numbers STORE sorted-numbers</span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 排序后的结果</span></span><br><span class="line">redis 127.0.0.1:6379&gt; LRANGE sorted-numbers 0 -1</span><br><span class="line">1) <span class="string">"1"</span></span><br><span class="line">2) <span class="string">"2"</span></span><br><span class="line">3) <span class="string">"3"</span></span><br><span class="line">4) <span class="string">"4"</span></span><br><span class="line">5) <span class="string">"5"</span></span><br><span class="line">6) <span class="string">"6"</span></span><br><span class="line">7) <span class="string">"7"</span></span><br><span class="line">8) <span class="string">"8"</span></span><br><span class="line">9) <span class="string">"9"</span></span><br><span class="line">10) <span class="string">"10"</span></span><br></pre></td></tr></table></figure><p></p><p>可以通过将 SORT 命令的执行结果保存，并用 EXPIRE key seconds 为结果设置生存时间，以此来产生一个 SORT 操作的结果缓存。</p><p>这样就可以避免对 SORT 操作的频繁调用：只有当结果集过期时，才需要再调用一次 SORT 操作。</p><p>另外，为了正确实现这一用法，你可能需要加锁以避免多个客户端同时进行缓存重建(也就是多个客户端，同一时间进行 SORT 操作，并保存为结果集)，具体参见 SETNX key value 命令。</p><h4 id="返回值-105"><a href="#返回值-105" class="headerlink" title="返回值"></a>返回值</h4><p>没有使用 STORE 参数，返回列表形式的排序结果。 使用 STORE 参数，返回排序结果的元素数量。</p><h3 id="FLUSHDB"><a href="#FLUSHDB" class="headerlink" title="FLUSHDB"></a>FLUSHDB</h3><h4 id="FLUSHDB-1"><a href="#FLUSHDB-1" class="headerlink" title="FLUSHDB"></a>FLUSHDB</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度： O(1)
</code></pre><p>清空当前数据库中的所有 key。</p><p>此命令从不失败。</p><h4 id="返回值-106"><a href="#返回值-106" class="headerlink" title="返回值"></a>返回值</h4><p>总是返回 OK 。</p><h4 id="代码示例-100"><a href="#代码示例-100" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; DBSIZE    <span class="comment"># 清空前的 key 数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line"></span><br><span class="line">redis&gt; FLUSHDB</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; DBSIZE    <span class="comment"># 清空后的 key 数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><h3 id="FLUSHALL"><a href="#FLUSHALL" class="headerlink" title="FLUSHALL"></a>FLUSHALL</h3><h4 id="FLUSHALL-1"><a href="#FLUSHALL-1" class="headerlink" title="FLUSHALL"></a>FLUSHALL</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度： O(N)
</code></pre><p>清空整个 Redis 服务器的数据(删除所有数据库的所有 key )。</p><p>此命令从不失败。</p><h4 id="返回值-107"><a href="#返回值-107" class="headerlink" title="返回值"></a>返回值</h4><p>总是返回 OK 。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; DBSIZE            <span class="comment"># 0 号数据库的 key 数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 9</span><br><span class="line"></span><br><span class="line">redis&gt; SELECT 1          <span class="comment"># 切换到 1 号数据库</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis[1]&gt; DBSIZE         <span class="comment"># 1 号数据库的 key 数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line"></span><br><span class="line">redis[1]&gt; flushall       <span class="comment"># 清空所有数据库的所有 key</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis[1]&gt; DBSIZE         <span class="comment"># 不但 1 号数据库被清空了</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis[1]&gt; SELECT 0       <span class="comment"># 0 号数据库(以及其他所有数据库)也一样</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; DBSIZE</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><p></p><h3 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h3><h4 id="SELECT-index"><a href="#SELECT-index" class="headerlink" title="SELECT index"></a>SELECT index</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度： O(1)
</code></pre><p>切换到指定的数据库，数据库索引号 index 用数字值指定，以 0 作为起始索引值。</p><p>默认使用 0 号数据库。</p><h4 id="返回值-108"><a href="#返回值-108" class="headerlink" title="返回值"></a>返回值</h4><p>OK</p><h4 id="代码示例-101"><a href="#代码示例-101" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET db_number 0         <span class="comment"># 默认使用 0 号数据库</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SELECT 1                <span class="comment"># 使用 1 号数据库</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis[1]&gt; GET db_number        <span class="comment"># 已经切换到 1 号数据库，注意 Redis 现在的命令提示符多了个 [1]</span></span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line">redis[1]&gt; SET db_number 1</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis[1]&gt; GET db_number</span><br><span class="line"><span class="string">"1"</span></span><br><span class="line"></span><br><span class="line">redis[1]&gt; SELECT 3             <span class="comment"># 再切换到 3 号数据库</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis[3]&gt;                      <span class="comment"># 提示符从 [1] 改变成了 [3]</span></span><br></pre></td></tr></table></figure><h3 id="SWAPDB"><a href="#SWAPDB" class="headerlink" title="SWAPDB"></a>SWAPDB</h3><h4 id="SWAPDB-db1-db2"><a href="#SWAPDB-db1-db2" class="headerlink" title="SWAPDB db1 db2"></a>SWAPDB db1 db2</h4><pre><code>版本要求： &gt;= 4.0.0
时间复杂度： O(1)
</code></pre><p>对换指定的两个数据库， 使得两个数据库的数据立即互换。</p><h4 id="返回值-109"><a href="#返回值-109" class="headerlink" title="返回值"></a>返回值</h4><p>OK</p><h4 id="代码示例-102"><a href="#代码示例-102" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对换数据库 0 和数据库 1</span></span><br><span class="line">redis&gt; SWAPDB 0 1</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h2 id="自动过期"><a href="#自动过期" class="headerlink" title="自动过期"></a>自动过期</h2><h3 id="EXPIRE"><a href="#EXPIRE" class="headerlink" title="EXPIRE"></a>EXPIRE</h3><h4 id="EXPIRE-key-seconds"><a href="#EXPIRE-key-seconds" class="headerlink" title="EXPIRE key seconds"></a>EXPIRE key seconds</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度： O(1)
</code></pre><p>为给定 key 设置生存时间，当 key 过期时(生存时间为 0 )，它会被自动删除。</p><p>在 Redis 中，带有生存时间的 key 被称为『易失的』(volatile)。</p><p>生存时间可以通过使用 DEL 命令来删除整个 key 来移除，或者被 SET 和 GETSET 命令覆写(overwrite)，这意味着，如果一个命令只是修改(alter)一个带生存时间的 key 的值而不是用一个新的 key 值来代替(replace)它的话，那么生存时间不会被改变。</p><p>比如说，对一个 key 执行 INCR 命令，对一个列表进行 LPUSH 命令，或者对一个哈希表执行 HSET 命令，这类操作都不会修改 key 本身的生存时间。</p><p>另一方面，如果使用 RENAME 对一个 key 进行改名，那么改名后的 key 的生存时间和改名前一样。</p><p>RENAME 命令的另一种可能是，尝试将一个带生存时间的 key 改名成另一个带生存时间的 another_key ，这时旧的 another_key (以及它的生存时间)会被删除，然后旧的 key 会改名为 another_key ，因此，新的 another_key 的生存时间也和原本的 key 一样。</p><p>使用 PERSIST 命令可以在不删除 key 的情况下，移除 key 的生存时间，让 key 重新成为一个『持久的』(persistent) key 。</p><h4 id="更新生存时间"><a href="#更新生存时间" class="headerlink" title="更新生存时间"></a>更新生存时间</h4><p>可以对一个已经带有生存时间的 key 执行 EXPIRE 命令，新指定的生存时间会取代旧的生存时间。</p><h4 id="过期时间的精确度"><a href="#过期时间的精确度" class="headerlink" title="过期时间的精确度"></a>过期时间的精确度</h4><p>在 Redis 2.4 版本中，过期时间的延迟在 1 秒钟之内 —— 也即是，就算 key 已经过期，但它还是可能在过期之后一秒钟之内被访问到，而在新的 Redis 2.6 版本中，延迟被降低到 1 毫秒之内。</p><h4 id="Redis-2-1-3-之前的不同之处"><a href="#Redis-2-1-3-之前的不同之处" class="headerlink" title="Redis 2.1.3 之前的不同之处"></a>Redis 2.1.3 之前的不同之处</h4><p>在 Redis 2.1.3 之前的版本中，修改一个带有生存时间的 key 会导致整个 key 被删除，这一行为是受当时复制(replication)层的限制而作出的，现在这一限制已经被修复。</p><h4 id="返回值-110"><a href="#返回值-110" class="headerlink" title="返回值"></a>返回值</h4><p>设置成功返回 1 。 当 key 不存在或者不能为 key 设置生存时间时(比如在低于 2.1.3 版本的 Redis 中你尝试更新 key 的生存时间)，返回 0 。</p><h4 id="代码示例-103"><a href="#代码示例-103" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET cache_page <span class="string">"www.google.com"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; EXPIRE cache_page 30  <span class="comment"># 设置过期时间为 30 秒</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; TTL cache_page    <span class="comment"># 查看剩余生存时间</span></span><br><span class="line">(<span class="built_in">integer</span>) 23</span><br><span class="line"></span><br><span class="line">redis&gt; EXPIRE cache_page 30000   <span class="comment"># 更新过期时间</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; TTL cache_page</span><br><span class="line">(<span class="built_in">integer</span>) 29996</span><br></pre></td></tr></table></figure><h4 id="模式：导航会话"><a href="#模式：导航会话" class="headerlink" title="模式：导航会话"></a>模式：导航会话</h4><p>假设你有一项 web 服务，打算根据用户最近访问的 N 个页面来进行物品推荐，并且假设用户停止阅览超过 60 秒，那么就清空阅览记录(为了减少物品推荐的计算量，并且保持推荐物品的新鲜度)。</p><p>这些最近访问的页面记录，我们称之为『导航会话』(Navigation session)，可以用 INCR 和 RPUSH 命令在 Redis 中实现它：每当用户阅览一个网页的时候，执行以下代码：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MULTI</span><br><span class="line">    RPUSH pagewviews.user:&lt;userid&gt; http://.....</span><br><span class="line">    EXPIRE pagewviews.user:&lt;userid&gt; 60</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure><p></p><p>如果用户停止阅览超过 60 秒，那么它的导航会话就会被清空，当用户重新开始阅览的时候，系统又会重新记录导航会话，继续进行物品推荐。</p><h3 id="EXPIREAT"><a href="#EXPIREAT" class="headerlink" title="EXPIREAT"></a>EXPIREAT</h3><h4 id="EXPIREAT-key-timestamp"><a href="#EXPIREAT-key-timestamp" class="headerlink" title="EXPIREAT key timestamp"></a>EXPIREAT key timestamp</h4><pre><code>可用版本： &gt;= 1.2.0
时间复杂度： O(1)
</code></pre><p>EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置生存时间。</p><p>不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。</p><h4 id="返回值-111"><a href="#返回值-111" class="headerlink" title="返回值"></a>返回值</h4><p>如果生存时间设置成功，返回 1 ； 当 key 不存在或没办法设置生存时间，返回 0 。</p><h4 id="代码示例-104"><a href="#代码示例-104" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET cache www.google.com</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; EXPIREAT cache 1355292000     <span class="comment"># 这个 key 将在 2012.12.12 过期</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; TTL cache</span><br><span class="line">(<span class="built_in">integer</span>) 45081860</span><br></pre></td></tr></table></figure><h3 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h3><h4 id="TTL-key"><a href="#TTL-key" class="headerlink" title="TTL key"></a>TTL key</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度： O(1)
</code></pre><p>以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。</p><h4 id="返回值-112"><a href="#返回值-112" class="headerlink" title="返回值"></a>返回值</h4><p>当 key 不存在时，返回 -2 。 当 key 存在但没有设置剩余生存时间时，返回 -1 。 否则，以秒为单位，返回 key 的剩余生存时间。</p><h4 id="Note-6"><a href="#Note-6" class="headerlink" title="Note"></a>Note</h4><p>在 Redis 2.8 以前，当 key 不存在，或者 key 没有设置剩余生存时间时，命令都返回 -1 。</p><h4 id="代码示例-105"><a href="#代码示例-105" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不存在的 key</span></span><br><span class="line">redis&gt; FLUSHDB</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; TTL key</span><br><span class="line">(<span class="built_in">integer</span>) -2</span><br><span class="line"></span><br><span class="line"><span class="comment"># key 存在，但没有设置剩余生存时间</span></span><br><span class="line">redis&gt; SET key value</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; TTL key</span><br><span class="line">(<span class="built_in">integer</span>) -1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有剩余生存时间的 key</span></span><br><span class="line">redis&gt; EXPIRE key 10086</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; TTL key</span><br><span class="line">(<span class="built_in">integer</span>) 10084</span><br></pre></td></tr></table></figure><h3 id="PERSIST"><a href="#PERSIST" class="headerlink" title="PERSIST"></a>PERSIST</h3><h4 id="PERSIST-key"><a href="#PERSIST-key" class="headerlink" title="PERSIST key"></a>PERSIST key</h4><pre><code>可用版本： &gt;= 2.2.0
时间复杂度： O(1)
</code></pre><p>移除给定 key 的生存时间，将这个 key 从“易失的”(带生存时间 key )转换成“持久的”(一个不带生存时间、永不过期的 key )。</p><h4 id="返回值-113"><a href="#返回值-113" class="headerlink" title="返回值"></a>返回值</h4><p>当生存时间移除成功时，返回 1 . 如果 key 不存在或 key 没有设置生存时间，返回 0 。</p><h4 id="代码示例-106"><a href="#代码示例-106" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET mykey <span class="string">"Hello"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; EXPIRE mykey 10  <span class="comment"># 为 key 设置生存时间</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; TTL mykey</span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line"></span><br><span class="line">redis&gt; PERSIST mykey    <span class="comment"># 移除 key 的生存时间</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; TTL mykey</span><br><span class="line">(<span class="built_in">integer</span>) -1</span><br></pre></td></tr></table></figure><h3 id="PEXPIRE"><a href="#PEXPIRE" class="headerlink" title="PEXPIRE"></a>PEXPIRE</h3><h4 id="PEXPIRE-key-milliseconds"><a href="#PEXPIRE-key-milliseconds" class="headerlink" title="PEXPIRE key milliseconds"></a>PEXPIRE key milliseconds</h4><pre><code>可用版本： &gt;= 2.6.0
时间复杂度： O(1)
</code></pre><p>这个命令和 EXPIRE 命令的作用类似，但是它以毫秒为单位设置 key 的生存时间，而不像 EXPIRE 命令那样，以秒为单位。</p><h4 id="返回值-114"><a href="#返回值-114" class="headerlink" title="返回值"></a>返回值</h4><p>设置成功，返回 1 key 不存在或设置失败，返回 0</p><h4 id="代码示例-107"><a href="#代码示例-107" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET mykey <span class="string">"Hello"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; PEXPIRE mykey 1500</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; TTL mykey    <span class="comment"># TTL 的返回值以秒为单位</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; PTTL mykey   <span class="comment"># PTTL 可以给出准确的毫秒数</span></span><br><span class="line">(<span class="built_in">integer</span>) 1499</span><br></pre></td></tr></table></figure><h3 id="PEXPIREAT"><a href="#PEXPIREAT" class="headerlink" title="PEXPIREAT"></a>PEXPIREAT</h3><h4 id="PEXPIREAT-key-milliseconds-timestamp"><a href="#PEXPIREAT-key-milliseconds-timestamp" class="headerlink" title="PEXPIREAT key milliseconds-timestamp"></a>PEXPIREAT key milliseconds-timestamp</h4><pre><code>可用版本： &gt;= 2.6.0
时间复杂度： O(1)
</code></pre><p>这个命令和 expireat 命令类似，但它以毫秒为单位设置 key 的过期 unix 时间戳，而不是像 expireat 那样，以秒为单位。</p><h4 id="返回值-115"><a href="#返回值-115" class="headerlink" title="返回值"></a>返回值</h4><p>如果生存时间设置成功，返回 1 。 当 key 不存在或没办法设置生存时间时，返回 0 。(查看 EXPIRE key seconds 命令获取更多信息)</p><h4 id="代码示例-108"><a href="#代码示例-108" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET mykey <span class="string">"Hello"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; PEXPIREAT mykey 1555555555005</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; TTL mykey           <span class="comment"># TTL 返回秒</span></span><br><span class="line">(<span class="built_in">integer</span>) 223157079</span><br><span class="line"></span><br><span class="line">redis&gt; PTTL mykey          <span class="comment"># PTTL 返回毫秒</span></span><br><span class="line">(<span class="built_in">integer</span>) 223157079318</span><br></pre></td></tr></table></figure><h3 id="PTTL"><a href="#PTTL" class="headerlink" title="PTTL"></a>PTTL</h3><h4 id="PTTL-key"><a href="#PTTL-key" class="headerlink" title="PTTL key"></a>PTTL key</h4><pre><code>可用版本： &gt;= 2.6.0
复杂度： O(1)
</code></pre><p>这个命令类似于 TTL 命令，但它以毫秒为单位返回 key 的剩余生存时间，而不是像 TTL 命令那样，以秒为单位。</p><h4 id="返回值-116"><a href="#返回值-116" class="headerlink" title="返回值"></a>返回值</h4><ul><li>当 key 不存在时，返回 -2 。</li><li>当 key 存在但没有设置剩余生存时间时，返回 -1 。</li><li>否则，以毫秒为单位，返回 key 的剩余生存时间。<h4 id="Note-7"><a href="#Note-7" class="headerlink" title="Note"></a>Note</h4></li></ul><p>在 Redis 2.8 以前，当 key 不存在，或者 key 没有设置剩余生存时间时，命令都返回 -1 。</p><h4 id="代码示例-109"><a href="#代码示例-109" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不存在的 key</span></span><br><span class="line">redis&gt; FLUSHDB</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; PTTL key</span><br><span class="line">(<span class="built_in">integer</span>) -2</span><br><span class="line"></span><br><span class="line"><span class="comment"># key 存在，但没有设置剩余生存时间</span></span><br><span class="line">redis&gt; SET key value</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; PTTL key</span><br><span class="line">(<span class="built_in">integer</span>) -1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有剩余生存时间的 key</span></span><br><span class="line">redis&gt; PEXPIRE key 10086</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; PTTL key</span><br><span class="line">(<span class="built_in">integer</span>) 6179</span><br></pre></td></tr></table></figure><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="MULTI"><a href="#MULTI" class="headerlink" title="MULTI"></a>MULTI</h3><h4 id="MULTI-1"><a href="#MULTI-1" class="headerlink" title="MULTI"></a>MULTI</h4><pre><code>可用版本：&gt;= 1.2.0
时间复杂度：O(1)。
</code></pre><p>标记一个事务块的开始。</p><p>事务块内的多条命令会按照先后顺序被放进一个队列当中，最后由 EXEC 命令原子性(atomic)地执行。</p><h4 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a>返回值：</h4><p>总是返回 OK 。</p><h4 id="代码示例-110"><a href="#代码示例-110" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MULTI            <span class="comment"># 标记事务开始</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; INCR user_id     <span class="comment"># 多条命令按顺序入队</span></span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; INCR user_id</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; INCR user_id</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; PING</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; EXEC             <span class="comment"># 执行</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 1</span><br><span class="line">2) (<span class="built_in">integer</span>) 2</span><br><span class="line">3) (<span class="built_in">integer</span>) 3</span><br><span class="line">4) PONG</span><br></pre></td></tr></table></figure><h3 id="EXEC"><a href="#EXEC" class="headerlink" title="EXEC"></a>EXEC</h3><h4 id="EXEC-1"><a href="#EXEC-1" class="headerlink" title="EXEC"></a>EXEC</h4><pre><code>可用版本：&gt;= 1.2.0
时间复杂度：事务块内所有命令的时间复杂度的总和。
</code></pre><p>执行所有事务块内的命令。</p><p>假如某个(或某些) key 正处于 WATCH 命令的监视之下，且事务块中有和这个(或这些) key 相关的命令，那么 EXEC 命令只在这个(或这些) key 没有被其他命令所改动的情况下执行并生效，否则该事务被打断(abort)。</p><h4 id="返回值：-1"><a href="#返回值：-1" class="headerlink" title="返回值："></a>返回值：</h4><p>事务块内所有命令的返回值，按命令执行的先后顺序排列。<br>当操作被打断时，返回空值 nil 。</p><h4 id="代码示例-111"><a href="#代码示例-111" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 事务被成功执行</span></span><br><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; INCR user_id</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; INCR user_id</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; INCR user_id</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; PING</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; EXEC</span><br><span class="line">1) (<span class="built_in">integer</span>) 1</span><br><span class="line">2) (<span class="built_in">integer</span>) 2</span><br><span class="line">3) (<span class="built_in">integer</span>) 3</span><br><span class="line">4) PONG</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监视 key ，且事务成功执行</span></span><br><span class="line">redis&gt; WATCH lock lock_times</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SET lock <span class="string">"huangz"</span></span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; INCR lock_times</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; EXEC</span><br><span class="line">1) OK</span><br><span class="line">2) (<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监视 key ，且事务被打断</span></span><br><span class="line">redis&gt; WATCH lock lock_times</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SET lock <span class="string">"joe"</span>        <span class="comment"># 就在这时，另一个客户端修改了 lock_times 的值</span></span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; INCR lock_times</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; EXEC                  <span class="comment"># 因为 lock_times 被修改， joe 的事务执行失败</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h3 id="DISCARD"><a href="#DISCARD" class="headerlink" title="DISCARD"></a>DISCARD</h3><h4 id="DISCARD-1"><a href="#DISCARD-1" class="headerlink" title="DISCARD"></a>DISCARD</h4><pre><code>可用版本： &gt;= 2.0.0
时间复杂度： O(1)。
</code></pre><p>取消事务，放弃执行事务块内的所有命令。</p><p>如果正在使用 WATCH 命令监视某个(或某些) key，那么取消所有监视，等同于执行命令 UNWATCH 。</p><h4 id="返回值-117"><a href="#返回值-117" class="headerlink" title="返回值"></a>返回值</h4><p>总是返回 OK 。</p><h4 id="代码示例-112"><a href="#代码示例-112" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; PING</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; SET greeting <span class="string">"hello"</span></span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; DISCARD</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h3 id="WATCH"><a href="#WATCH" class="headerlink" title="WATCH"></a>WATCH</h3><h4 id="WATCH-key-key-…"><a href="#WATCH-key-key-…" class="headerlink" title="WATCH key [key …]"></a>WATCH key [key …]</h4><pre><code>可用版本：&gt;= 2.2.0
时间复杂度：O(1)。
</code></pre><p>监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</p><h4 id="返回值：-2"><a href="#返回值：-2" class="headerlink" title="返回值："></a>返回值：</h4><p>总是返回 OK 。</p><h4 id="代码示例-113"><a href="#代码示例-113" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; WATCH lock lock_times</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h3 id="UNWATCH"><a href="#UNWATCH" class="headerlink" title="UNWATCH"></a>UNWATCH</h3><h4 id="UNWATCH-1"><a href="#UNWATCH-1" class="headerlink" title="UNWATCH"></a>UNWATCH</h4><pre><code>可用版本：&gt;= 2.2.0
时间复杂度：O(1)
</code></pre><p>取消 WATCH 命令对所有 key 的监视。</p><p>如果在执行 WATCH 命令之后， EXEC 命令或 DISCARD 命令先被执行了的话，那么就不需要再执行 UNWATCH 了。</p><p>因为 EXEC 命令会执行事务，因此 WATCH 命令的效果已经产生了；而 DISCARD 命令在取消事务的同时也会取消所有对 key 的监视，因此这两个命令执行之后，就没有必要执行 UNWATCH 了。</p><h4 id="返回值：-3"><a href="#返回值：-3" class="headerlink" title="返回值："></a>返回值：</h4><p>总是 OK 。</p><h4 id="代码示例-114"><a href="#代码示例-114" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; WATCH lock lock_times</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; UNWATCH</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h2 id="Lua-脚本"><a href="#Lua-脚本" class="headerlink" title="Lua 脚本"></a>Lua 脚本</h2><h3 id="EVAL"><a href="#EVAL" class="headerlink" title="EVAL"></a>EVAL</h3><h4 id="EVAL-script-numkeys-key-key-…-arg-arg-…"><a href="#EVAL-script-numkeys-key-key-…-arg-arg-…" class="headerlink" title="EVAL script numkeys key [key …] arg [arg …]"></a>EVAL script numkeys key [key …] arg [arg …]</h4><pre><code>可用版本： &gt;= 2.6.0
时间复杂度： EVAL 和 EVALSHA 可以在 O(1) 复杂度内找到要被执行的脚本，其余的复杂度取决于执行的脚本本身。
</code></pre><p>从 Redis 2.6.0 版本开始，通过内置的 Lua 解释器，可以使用 EVAL 命令对 Lua 脚本进行求值。</p><p>script 参数是一段 Lua 5.1 脚本程序，它会被运行在 Redis 服务器上下文中，这段脚本不必(也不应该)定义为一个 Lua 函数。</p><p>numkeys 参数用于指定键名参数的个数。</p><p>键名参数 key [key …] 从 EVAL 的第三个参数开始算起，表示在脚本中所用到的那些 Redis 键(key)，这些键名参数可以在 Lua 中通过全局变量 KEYS 数组，用 1 为基址的形式访问( KEYS[1] ， KEYS[2] ，以此类推)。</p><p>在命令的最后，那些不是键名参数的附加参数 arg [arg …] ，可以在 Lua 中通过全局变量 ARGV 数组访问，访问的形式和 KEYS 变量类似( ARGV[1] 、 ARGV[2] ，诸如此类)。</p><p>上面这几段长长的说明可以用一个简单的例子来概括：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">eval</span> <span class="string">"return &#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;"</span> 2 key1 key2 first second</span><br><span class="line">1) <span class="string">"key1"</span></span><br><span class="line">2) <span class="string">"key2"</span></span><br><span class="line">3) <span class="string">"first"</span></span><br><span class="line">4) <span class="string">"second"</span></span><br></pre></td></tr></table></figure><p></p><p>其中 “return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}” 是被求值的 Lua 脚本，数字 2 指定了键名参数的数量， key1 和 key2 是键名参数，分别使用 KEYS[1] 和 KEYS[2] 访问，而最后的 first 和 second 则是附加参数，可以通过 ARGV[1] 和 ARGV[2] 访问它们。</p><p>在 Lua 脚本中，可以使用两个不同函数来执行 Redis 命令，它们分别是：</p><ul><li>redis.call()</li><li>redis.pcall()<br>这两个函数的唯一区别在于它们使用不同的方式处理执行命令所产生的错误，在后面的『错误处理』部分会讲到这一点。</li></ul><p>redis.call() 和 redis.pcall() 两个函数的参数可以是任何格式良好(well formed)的 Redis 命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">eval</span> <span class="string">"return redis.call('set','foo','bar')"</span> 0</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p></p><p>需要注意的是，上面这段脚本的确实现了将键 foo 的值设为 bar 的目的，但是，它违反了 EVAL 命令的语义，因为脚本里使用的所有键都应该由 KEYS 数组来传递，就像这样：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">eval</span> <span class="string">"return redis.call('set',KEYS[1],'bar')"</span> 1 foo</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p></p><p>要求使用正确的形式来传递键(key)是有原因的，因为不仅仅是 EVAL 这个命令，所有的 Redis 命令，在执行之前都会被分析，籍此来确定命令会对哪些键进行操作。</p><p>因此，对于 EVAL 命令来说，必须使用正确的形式来传递键，才能确保分析工作正确地执行。除此之外，使用正确的形式来传递键还有很多其他好处，它的一个特别重要的用途就是确保 Redis 集群可以将你的请求发送到正确的集群节点。(对 Redis 集群的工作还在进行当中，但是脚本功能被设计成可以与集群功能保持兼容。)不过，这条规矩并不是强制性的，从而使得用户有机会滥用(abuse) Redis 单实例配置(single instance configuration)，代价是这样写出的脚本不能被 Redis 集群所兼容。</p><h4 id="在-Lua-数据类型和-Redis-数据类型之间转换"><a href="#在-Lua-数据类型和-Redis-数据类型之间转换" class="headerlink" title="在 Lua 数据类型和 Redis 数据类型之间转换"></a>在 Lua 数据类型和 Redis 数据类型之间转换</h4><p>当 Lua 通过 call() 或 pcall() 函数执行 Redis 命令的时候，命令的返回值会被转换成 Lua 数据结构。同样地，当 Lua 脚本在 Redis 内置的解释器里运行时，Lua 脚本的返回值也会被转换成 Redis 协议(protocol)，然后由 EVAL 将值返回给客户端。</p><p>数据类型之间的转换遵循这样一个设计原则：如果将一个 Redis 值转换成 Lua 值，之后再将转换所得的 Lua 值转换回 Redis 值，那么这个转换所得的 Redis 值应该和最初时的 Redis 值一样。</p><p>换句话说， Lua 类型和 Redis 类型之间存在着一一对应的转换关系。</p><p>以下列出的是详细的转换规则：</p><p>从 Redis 转换到 Lua ：</p><ul><li>Redis integer reply -&gt; Lua number / Redis 整数转换成 Lua 数字</li><li>Redis bulk reply -&gt; Lua string / Redis bulk 回复转换成 Lua 字符串</li><li>Redis multi bulk reply -&gt; Lua table (may have other Redis data types nested) / Redis 多条 bulk 回复转换成 Lua 表，表内可能有其他别的 Redis 数据类型</li><li>Redis status reply -&gt; Lua table with a single ok field containing the status / Redis 状态回复转换成 Lua 表，表内的 ok 域包含了状态信息</li><li>Redis error reply -&gt; Lua table with a single err field containing the error / Redis 错误回复转换成 Lua 表，表内的 err 域包含了错误信息</li><li><p>Redis Nil bulk reply and Nil multi bulk reply -&gt; Lua false boolean type / Redis 的 Nil 回复和 Nil 多条回复转换成 Lua 的布尔值 false<br>从 Lua 转换到 Redis：</p></li><li><p>Lua number -&gt; Redis integer reply / Lua 数字转换成 Redis 整数</p></li><li>Lua string -&gt; Redis bulk reply / Lua 字符串转换成 Redis bulk 回复</li><li>Lua table (array) -&gt; Redis multi bulk reply / Lua 表(数组)转换成 Redis 多条 bulk 回复</li><li>Lua table with a single ok field -&gt; Redis status reply / 一个带单个 ok 域的 Lua 表，转换成 Redis 状态回复</li><li>Lua table with a single err field -&gt; Redis error reply / 一个带单个 err 域的 Lua 表，转换成 Redis 错误回复</li><li><p>Lua boolean false -&gt; Redis Nil bulk reply / Lua 的布尔值 false 转换成 Redis 的 Nil bulk 回复<br>从 Lua 转换到 Redis 有一条额外的规则，这条规则没有和它对应的从 Redis 转换到 Lua 的规则：</p></li><li><p>Lua boolean true -&gt; Redis integer reply with value of 1 / Lua 布尔值 true 转换成 Redis 整数回复中的 1<br>以下是几个类型转换的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">eval</span> <span class="string">"return 10"</span> 0</span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line"></span><br><span class="line">&gt; <span class="built_in">eval</span> <span class="string">"return &#123;1,2,&#123;3,'Hello World!'&#125;&#125;"</span> 0</span><br><span class="line">1) (<span class="built_in">integer</span>) 1</span><br><span class="line">2) (<span class="built_in">integer</span>) 2</span><br><span class="line">3) 1) (<span class="built_in">integer</span>) 3</span><br><span class="line">   2) <span class="string">"Hello World!"</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="built_in">eval</span> <span class="string">"return redis.call('get','foo')"</span> 0</span><br><span class="line"><span class="string">"bar"</span></span><br></pre></td></tr></table></figure></li></ul><p>在上面的三个代码示例里，前两个演示了如何将 Lua 值转换成 Redis 值，最后一个例子更复杂一些，它演示了一个将 Redis 值转换成 Lua 值，然后再将 Lua 值转换成 Redis 值的类型转过程。</p><h4 id="脚本的原子性"><a href="#脚本的原子性" class="headerlink" title="脚本的原子性"></a>脚本的原子性</h4><p>Redis 使用单个 Lua 解释器去运行所有脚本，并且， Redis 也保证脚本会以原子性(atomic)的方式执行：当某个脚本正在运行的时候，不会有其他脚本或 Redis 命令被执行。这和使用 MULTI / EXEC 包围的事务很类似。在其他别的客户端看来，脚本的效果(effect)要么是不可见的(not visible)，要么就是已完成的(already completed)。</p><p>另一方面，这也意味着，执行一个运行缓慢的脚本并不是一个好主意。写一个跑得很快很顺溜的脚本并不难，因为脚本的运行开销(overhead)非常少，但是当你不得不使用一些跑得比较慢的脚本时，请小心，因为当这些蜗牛脚本在慢吞吞地运行的时候，其他客户端会因为服务器正忙而无法执行命令。</p><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>前面的命令介绍部分说过， redis.call() 和 redis.pcall() 的唯一区别在于它们对错误处理的不同。</p><p>当 redis.call() 在执行命令的过程中发生错误时，脚本会停止执行，并返回一个脚本错误，错误的输出信息会说明错误造成的原因：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; lpush foo a</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; <span class="built_in">eval</span> <span class="string">"return redis.call('get', 'foo')"</span> 0</span><br><span class="line">(error) ERR Error running script (call to f_282297a0228f48cd3fc6a55de6316f31422f5d17): ERR Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure><p></p><p>和 redis.call() 不同， redis.pcall() 出错时并不引发(raise)错误，而是返回一个带 err 域的 Lua 表(table)，用于表示错误：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; EVAL <span class="string">"return redis.pcall('get', 'foo')"</span> 0</span><br><span class="line">(error) ERR Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure><p></p><h4 id="带宽和-EVALSHA"><a href="#带宽和-EVALSHA" class="headerlink" title="带宽和 EVALSHA"></a>带宽和 EVALSHA</h4><p>EVAL 命令要求你在每次执行脚本的时候都发送一次脚本主体(script body)。Redis 有一个内部的缓存机制，因此它不会每次都重新编译脚本，不过在很多场合，付出无谓的带宽来传送脚本主体并不是最佳选择。</p><p>为了减少带宽的消耗， Redis 实现了 EVALSHA 命令，它的作用和 EVAL 一样，都用于对脚本求值，但它接受的第一个参数不是脚本，而是脚本的 SHA1 校验和(sum)。</p><h4 id="EVALSHA-命令的表现如下："><a href="#EVALSHA-命令的表现如下：" class="headerlink" title="EVALSHA 命令的表现如下："></a>EVALSHA 命令的表现如下：</h4><ul><li>如果服务器还记得给定的 SHA1 校验和所指定的脚本，那么执行这个脚本</li><li>如果服务器不记得给定的 SHA1 校验和所指定的脚本，那么它返回一个特殊的错误，提醒用户使用 EVAL 代替 EVALSHA<br>以下是示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">set</span> foo bar</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">&gt; <span class="built_in">eval</span> <span class="string">"return redis.call('get','foo')"</span> 0</span><br><span class="line"><span class="string">"bar"</span></span><br><span class="line"></span><br><span class="line">&gt; evalsha 6b1bf486c81ceb7edf3c093f4c48582e38c0e791 0</span><br><span class="line"><span class="string">"bar"</span></span><br><span class="line"></span><br><span class="line">&gt; evalsha ffffffffffffffffffffffffffffffffffffffff 0</span><br><span class="line">(error) `NOSCRIPT` No matching script. Please use [EVAL](/commands/<span class="built_in">eval</span>).</span><br></pre></td></tr></table></figure></li></ul><p>客户端库的底层实现可以一直乐观地使用 EVALSHA 来代替 EVAL ，并期望着要使用的脚本已经保存在服务器上了，只有当 NOSCRIPT 错误发生时，才使用 EVAL 命令重新发送脚本，这样就可以最大限度地节省带宽。</p><p>这也说明了执行 EVAL 命令时，使用正确的格式来传递键名参数和附加参数的重要性：因为如果将参数硬写在脚本中，那么每次当参数改变的时候，都要重新发送脚本，即使脚本的主体并没有改变，相反，通过使用正确的格式来传递键名参数和附加参数，就可以在脚本主体不变的情况下，直接使用 EVALSHA 命令对脚本进行复用，免去了无谓的带宽消耗。</p><h4 id="脚本缓存"><a href="#脚本缓存" class="headerlink" title="脚本缓存"></a>脚本缓存</h4><p>Redis 保证所有被运行过的脚本都会被永久保存在脚本缓存当中，这意味着，当 EVAL 命令在一个 Redis 实例上成功执行某个脚本之后，随后针对这个脚本的所有 EVALSHA 命令都会成功执行。</p><p>刷新脚本缓存的唯一办法是显式地调用 SCRIPT FLUSH 命令，这个命令会清空运行过的所有脚本的缓存。通常只有在云计算环境中，Redis 实例被改作其他客户或者别的应用程序的实例时，才会执行这个命令。</p><p>缓存可以长时间储存而不产生内存问题的原因是，它们的体积非常小，而且数量也非常少，即使脚本在概念上类似于实现一个新命令，即使在一个大规模的程序里有成百上千的脚本，即使这些脚本会经常修改，即便如此，储存这些脚本的内存仍然是微不足道的。</p><p>事实上，用户会发现 Redis 不移除缓存中的脚本实际上是一个好主意。比如说，对于一个和 Redis 保持持久化链接(persistent connection)的程序来说，它可以确信，执行过一次的脚本会一直保留在内存当中，因此它可以在流水线中使用 EVALSHA 命令而不必担心因为找不到所需的脚本而产生错误(稍候我们会看到在流水线中执行脚本的相关问题)。</p><h4 id="SCRIPT-命令"><a href="#SCRIPT-命令" class="headerlink" title="SCRIPT 命令"></a>SCRIPT 命令</h4><p>Redis 提供了以下几个 SCRIPT 命令，用于对脚本子系统(scripting subsystem)进行控制：</p><ul><li>SCRIPT FLUSH ：清除所有脚本缓存</li><li>SCRIPT EXISTS sha1 [sha1 …] ：根据给定的脚本校验和，检查指定的脚本是否存在于脚本缓存</li><li>SCRIPT LOAD script ：将一个脚本装入脚本缓存，但并不立即运行它</li><li>SCRIPT KILL ：杀死当前正在运行的脚本<h4 id="纯函数脚本"><a href="#纯函数脚本" class="headerlink" title="纯函数脚本"></a>纯函数脚本</h4>在编写脚本方面，一个重要的要求就是，脚本应该被写成纯函数(pure function)。</li></ul><p>也就是说，脚本应该具有以下属性：</p><ul><li>对于同样的数据集输入，给定相同的参数，脚本执行的 Redis 写命令总是相同的。脚本执行的操作不能依赖于任何隐藏(非显式)数据，不能依赖于脚本在执行过程中、或脚本在不同执行时期之间可能变更的状态，并且它也不能依赖于任何来自 I/O 设备的外部输入。</li></ul><p>使用系统时间(system time)，调用像 RANDOMKEY 那样的随机命令，或者使用 Lua 的随机数生成器，类似以上的这些操作，都会造成脚本的求值无法每次都得出同样的结果。</p><p>为了确保脚本符合上面所说的属性， Redis 做了以下工作：</p><ul><li>Lua 没有访问系统时间或者其他内部状态的命令</li><li>Redis 会返回一个错误，阻止这样的脚本运行： 这些脚本在执行随机命令之后(比如 RANDOMKEY 、 SRANDMEMBER key [count] 或 TIME 等)，还会执行可以修改数据集的 Redis 命令。如果脚本只是执行只读操作，那么就没有这一限制。注意，随机命令并不一定就指那些带 RAND 字眼的命令，任何带有非确定性的命令都会被认为是随机命令，比如 TIME 命令就是这方面的一个很好的例子。</li><li>每当从 Lua 脚本中调用那些返回无序元素的命令时，执行命令所得的数据在返回给 Lua 之前会先执行一个静默(slient)的字典序排序(lexicographical sorting)。举个例子，因为 Redis 的 Set 保存的是无序的元素，所以在 Redis 命令行客户端中直接执行 SMEMBERS key ，返回的元素是无序的，但是，假如在脚本中执行 redis.call(“smembers”, KEYS[1]) ，那么返回的总是排过序的元素。</li><li>对 Lua 的伪随机数生成函数 math.random 和 math.randomseed 进行修改，使得每次在运行新脚本的时候，总是拥有同样的 seed 值。这意味着，每次运行脚本时，只要不使用 math.randomseed ，那么 math.random 产生的随机数序列总是相同的。</li><li>尽管有那么多的限制，但用户还是可以用一个简单的技巧写出带随机行为的脚本(如果他们需要的话)。</li></ul><p>假设现在我们要编写一个 Redis 脚本，这个脚本从列表中弹出 N 个随机数。一个 Ruby 写的例子如下：<br></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'rubygems'</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'redis'</span></span><br><span class="line"></span><br><span class="line">r = Redis.new</span><br><span class="line"></span><br><span class="line">RandomPushScript = <span class="string">&lt;&lt;EOF</span></span><br><span class="line"><span class="string">    local i = tonumber(ARGV[1])</span></span><br><span class="line"><span class="string">    local res</span></span><br><span class="line"><span class="string">    while (i &gt; 0) do</span></span><br><span class="line"><span class="string">        res = redis.call('lpush',KEYS[1],math.random())</span></span><br><span class="line"><span class="string">        i = i-1</span></span><br><span class="line"><span class="string">    end</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">r.del(<span class="symbol">:mylist</span>)</span><br><span class="line">puts r.eval(RandomPushScript,[<span class="symbol">:mylist</span>],[<span class="number">10</span>,rand(<span class="number">2</span>**<span class="number">32</span>)])</span><br></pre></td></tr></table></figure><p></p><p>这个程序每次运行都会生成带有以下元素的列表：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; lrange mylist 0 -1</span><br><span class="line">1) <span class="string">"0.74509509873814"</span></span><br><span class="line">2) <span class="string">"0.87390407681181"</span></span><br><span class="line">3) <span class="string">"0.36876626981831"</span></span><br><span class="line">4) <span class="string">"0.6921941534114"</span></span><br><span class="line">5) <span class="string">"0.7857992587545"</span></span><br><span class="line">6) <span class="string">"0.57730350670279"</span></span><br><span class="line">7) <span class="string">"0.87046522734243"</span></span><br><span class="line">8) <span class="string">"0.09637165539729"</span></span><br><span class="line">9) <span class="string">"0.74990198051087"</span></span><br><span class="line">10) <span class="string">"0.17082803611217"</span></span><br></pre></td></tr></table></figure><p></p><p>上面的 Ruby 程序每次都只生成同样的列表，用途并不是太大。那么，该怎样修改这个脚本，使得它仍然是一个纯函数(符合 Redis 的要求)，但是每次调用都可以产生不同的随机元素呢？</p><p>一个简单的办法是，为脚本添加一个额外的参数，让这个参数作为 Lua 的随机数生成器的 seed 值，这样的话，只要给脚本传入不同的 seed ，脚本就会生成不同的列表元素。</p><p>以下是修改后的脚本：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RandomPushScript = &lt;&lt;EOF</span><br><span class="line">    <span class="built_in">local</span> i = tonumber(ARGV[1])</span><br><span class="line">    <span class="built_in">local</span> res</span><br><span class="line">    math.randomseed(tonumber(ARGV[2]))</span><br><span class="line">    <span class="keyword">while</span> (i &gt; 0) <span class="keyword">do</span></span><br><span class="line">        res = redis.call(<span class="string">'lpush'</span>,KEYS[1],math.random())</span><br><span class="line">        i = i-1</span><br><span class="line">    end</span><br><span class="line">    <span class="built_in">return</span> res</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">r.del(:mylist)</span><br><span class="line">puts r.eval(RandomPushScript,1,:mylist,10,rand(2**32))</span><br></pre></td></tr></table></figure><p></p><p>尽管对于同样的 seed ，上面的脚本产生的列表元素是一样的(因为它是一个纯函数)，但是只要每次在执行脚本的时候传入不同的 seed ，我们就可以得到带有不同随机元素的列表。</p><p>Seed 会在复制(replication link)和写 AOF 文件时作为一个参数来传播，保证在载入 AOF 文件或附属节点(slave)处理脚本时， seed 仍然可以及时得到更新。</p><p>注意，Redis 实现保证 math.random 和 math.randomseed 的输出和运行 Redis 的系统架构无关，无论是 32 位还是 64 位系统，无论是小端(little endian)还是大端(big endian)系统，这两个函数的输出总是相同的。</p><h4 id="全局变量保护"><a href="#全局变量保护" class="headerlink" title="全局变量保护"></a>全局变量保护</h4><p>为了防止不必要的数据泄漏进 Lua 环境， Redis 脚本不允许创建全局变量。如果一个脚本需要在多次执行之间维持某种状态，它应该使用 Redis key 来进行状态保存。</p><p>企图在脚本中访问一个全局变量(不论这个变量是否存在)将引起脚本停止， EVAL 命令会返回一个错误：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; <span class="built_in">eval</span> <span class="string">'a=10'</span> 0</span><br><span class="line">(error) ERR Error running script (call to f_933044db579a2f8fd45d8065f04a8d0249383e57): user_script:1: Script attempted to create global variable <span class="string">'a'</span></span><br></pre></td></tr></table></figure><p></p><p>Lua 的 debug 工具，或者其他设施，比如打印（alter）用于实现全局保护的 meta table ，都可以用于实现全局变量保护。</p><p>实现全局变量保护并不难，不过有时候还是会不小心而为之。一旦用户在脚本中混入了 Lua 全局状态，那么 AOF 持久化和复制（replication）都会无法保证，所以，请不要使用全局变量。</p><p>避免引入全局变量的一个诀窍是：将脚本中用到的所有变量都使用 local 关键字定义为局部变量。</p><h4 id="库"><a href="#库" class="headerlink" title="库"></a>库</h4><p>Redis 内置的 Lua 解释器加载了以下 Lua 库：</p><ul><li>base</li><li>table</li><li>string</li><li>math</li><li>debug</li><li>cjson</li><li>cmsgpack<br>其中 cjson 库可以让 Lua 以非常快的速度处理 JSON 数据，除此之外，其他别的都是 Lua 的标准库。</li></ul><p>每个 Redis 实例都保证会加载上面列举的库，从而确保每个 Redis 脚本的运行环境都是相同的。</p><h4 id="使用脚本散发-Redis-日志"><a href="#使用脚本散发-Redis-日志" class="headerlink" title="使用脚本散发 Redis 日志"></a>使用脚本散发 Redis 日志</h4><p>在 Lua 脚本中，可以通过调用 redis.log 函数来写 Redis 日志(log)：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis.log(loglevel, message)</span><br></pre></td></tr></table></figure><p></p><p>其中， message 参数是一个字符串，而 loglevel 参数可以是以下任意一个值：</p><ul><li>redis.LOG_DEBUG</li><li>redis.LOG_VERBOSE</li><li>redis.LOG_NOTICE</li><li>redis.LOG_WARNING<br>上面的这些等级(level)和标准 Redis 日志的等级相对应。</li></ul><p>对于脚本散发(emit)的日志，只有那些和当前 Redis 实例所设置的日志等级相同或更高级的日志才会被散发。</p><p>以下是一个日志示例：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis.log(redis.LOG_WARNING, <span class="string">"Something is wrong with this script."</span>)</span><br></pre></td></tr></table></figure><p></p><p>执行上面的函数会产生这样的信息：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[32343] 22 Mar 15:21:39 # Something is wrong with this script.</span><br></pre></td></tr></table></figure><p></p><h4 id="沙箱-sandbox-和最大执行时间"><a href="#沙箱-sandbox-和最大执行时间" class="headerlink" title="沙箱(sandbox)和最大执行时间"></a>沙箱(sandbox)和最大执行时间</h4><p>脚本应该仅仅用于传递参数和对 Redis 数据进行处理，它不应该尝试去访问外部系统(比如文件系统)，或者执行任何系统调用。</p><p>除此之外，脚本还有一个最大执行时间限制，它的默认值是 5 秒钟，一般正常运作的脚本通常可以在几分之几毫秒之内完成，花不了那么多时间，这个限制主要是为了防止因编程错误而造成的无限循环而设置的。</p><p>最大执行时间的长短由 lua-time-limit 选项来控制(以毫秒为单位)，可以通过编辑 redis.conf 文件或者使用 CONFIG GET parameter 和 CONFIG SET parameter value 命令来修改它。</p><p>当一个脚本达到最大执行时间的时候，它并不会自动被 Redis 结束，因为 Redis 必须保证脚本执行的原子性，而中途停止脚本的运行意味着可能会留下未处理完的数据在数据集(data set)里面。</p><p>因此，当脚本运行的时间超过最大执行时间后，以下动作会被执行：</p><ul><li>Redis 记录一个脚本正在超时运行</li><li>Redis 开始重新接受其他客户端的命令请求，但是只有 SCRIPT KILL 和 SHUTDOWN NOSAVE 两个命令会被处理，对于其他命令请求， Redis 服务器只是简单地返回 BUSY 错误。</li><li>可以使用 SCRIPT KILL 命令将一个仅执行只读命令的脚本杀死，因为只读命令并不修改数据，因此杀死这个脚本并不破坏数据的完整性</li><li>如果脚本已经执行过写命令，那么唯一允许执行的操作就是 SHUTDOWN NOSAVE ，它通过停止服务器来阻止当前数据集写入磁盘<h4 id="流水线-pipeline-上下文-context-中的-EVALSHA"><a href="#流水线-pipeline-上下文-context-中的-EVALSHA" class="headerlink" title="流水线(pipeline)上下文(context)中的 EVALSHA"></a>流水线(pipeline)上下文(context)中的 EVALSHA</h4>在流水线请求的上下文中使用 EVALSHA 命令时，要特别小心，因为在流水线中，必须保证命令的执行顺序。</li></ul><p>一旦在流水线中因为 EVALSHA 命令而发生 NOSCRIPT 错误，那么这个流水线就再也没有办法重新执行了，否则的话，命令的执行顺序就会被打乱。</p><p>为了防止出现以上所说的问题，客户端库实现应该实施以下的其中一项措施：</p><ul><li>总是在流水线中使用 EVAL 命令</li><li>检查流水线中要用到的所有命令，找到其中的 EVAL 命令，并使用 SCRIPT EXISTS sha1 [sha1 …] 命令检查要用到的脚本是不是全都已经保存在缓存里面了。如果所需的全部脚本都可以在缓存里找到，那么就可以放心地将所有 EVAL 命令改成 EVALSHA 命令，否则的话，就要在流水线的顶端(top)将缺少的脚本用 SCRIPT LOAD script 命令加上去。</li></ul><h3 id="EVALSHA"><a href="#EVALSHA" class="headerlink" title="EVALSHA"></a>EVALSHA</h3><h4 id="EVALSHA-sha1-numkeys-key-key-…-arg-arg-…"><a href="#EVALSHA-sha1-numkeys-key-key-…-arg-arg-…" class="headerlink" title="EVALSHA sha1 numkeys key [key …] arg [arg …]"></a>EVALSHA sha1 numkeys key [key …] arg [arg …]</h4><pre><code>可用版本： &gt;= 2.6.0
时间复杂度： 根据脚本的复杂度而定。
</code></pre><p>根据给定的 sha1 校验码，对缓存在服务器中的脚本进行求值。</p><p>将脚本缓存到服务器的操作可以通过 SCRIPT LOAD script 命令进行。</p><p>这个命令的其他地方，比如参数的传入方式，都和 EVAL script numkeys key [key …] arg [arg …] 命令一样。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SCRIPT LOAD <span class="string">"return 'hello moto'"</span></span><br><span class="line"><span class="string">"232fd51614574cf0867b83d384a5e898cfd24e5a"</span></span><br><span class="line"></span><br><span class="line">redis&gt; EVALSHA <span class="string">"232fd51614574cf0867b83d384a5e898cfd24e5a"</span> 0</span><br><span class="line"><span class="string">"hello moto"</span></span><br></pre></td></tr></table></figure><p></p><h3 id="SCRIPT-LOAD"><a href="#SCRIPT-LOAD" class="headerlink" title="SCRIPT LOAD"></a>SCRIPT LOAD</h3><h4 id="SCRIPT-LOAD-script"><a href="#SCRIPT-LOAD-script" class="headerlink" title="SCRIPT LOAD script"></a>SCRIPT LOAD script</h4><pre><code>可用版本： &gt;= 2.6.0
时间复杂度： O(N) , N 为脚本的长度(以字节为单位)。
</code></pre><p>将脚本 script 添加到脚本缓存中，但并不立即执行这个脚本。</p><p>EVAL script numkeys key [key …] arg [arg …] 命令也会将脚本添加到脚本缓存中，但是它会立即对输入的脚本进行求值。</p><p>如果给定的脚本已经在缓存里面了，那么不做动作。</p><p>在脚本被加入到缓存之后，通过 EVALSHA 命令，可以使用脚本的 SHA1 校验和来调用这个脚本。</p><p>脚本可以在缓存中保留无限长的时间，直到执行 SCRIPT FLUSH 为止。</p><p>关于使用 Redis 对 Lua 脚本进行求值的更多信息，请参见 EVAL script numkeys key [key …] arg [arg …] 命令。</p><h4 id="返回值-118"><a href="#返回值-118" class="headerlink" title="返回值"></a>返回值</h4><p>给定 script 的 SHA1 校验和。</p><h4 id="代码示例-115"><a href="#代码示例-115" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SCRIPT LOAD <span class="string">"return 'hello moto'"</span></span><br><span class="line"><span class="string">"232fd51614574cf0867b83d384a5e898cfd24e5a"</span></span><br><span class="line"></span><br><span class="line">redis&gt; EVALSHA 232fd51614574cf0867b83d384a5e898cfd24e5a 0</span><br><span class="line"><span class="string">"hello moto"</span></span><br></pre></td></tr></table></figure><h3 id="SCRIPT-EXISTS"><a href="#SCRIPT-EXISTS" class="headerlink" title="SCRIPT EXISTS"></a>SCRIPT EXISTS</h3><h4 id="SCRIPT-EXISTS-sha1-sha1-…"><a href="#SCRIPT-EXISTS-sha1-sha1-…" class="headerlink" title="SCRIPT EXISTS sha1 [sha1 …]"></a>SCRIPT EXISTS sha1 [sha1 …]</h4><pre><code>可用版本： &gt;= 2.6.0
时间复杂度： O(N) , N 为给定的 SHA1 校验和的数量。
</code></pre><p>给定一个或多个脚本的 SHA1 校验和，返回一个包含 0 和 1 的列表，表示校验和所指定的脚本是否已经被保存在缓存当中。</p><p>关于使用 Redis 对 Lua 脚本进行求值的更多信息，请参见 EVAL script numkeys key [key …] arg [arg …] 命令。</p><h4 id="返回值-119"><a href="#返回值-119" class="headerlink" title="返回值"></a>返回值</h4><p>一个列表，包含 0 和 1 ，前者表示脚本不存在于缓存，后者表示脚本已经在缓存里面了。 列表中的元素和给定的 SHA1 校验和保持对应关系，比如列表的第三个元素的值就表示第三个 SHA1 校验和所指定的脚本在缓存中的状态。</p><h4 id="代码示例-116"><a href="#代码示例-116" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SCRIPT LOAD <span class="string">"return 'hello moto'"</span>    <span class="comment"># 载入一个脚本</span></span><br><span class="line"><span class="string">"232fd51614574cf0867b83d384a5e898cfd24e5a"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SCRIPT EXISTS 232fd51614574cf0867b83d384a5e898cfd24e5a</span><br><span class="line">1) (<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; SCRIPT FLUSH     <span class="comment"># 清空缓存</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SCRIPT EXISTS 232fd51614574cf0867b83d384a5e898cfd24e5a</span><br><span class="line">1) (<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><h3 id="SCRIPT-FLUSH"><a href="#SCRIPT-FLUSH" class="headerlink" title="SCRIPT FLUSH"></a>SCRIPT FLUSH</h3><h4 id="SCRIPT-FLUSH-1"><a href="#SCRIPT-FLUSH-1" class="headerlink" title="SCRIPT FLUSH"></a>SCRIPT FLUSH</h4><pre><code>可用版本： &gt;= 2.6.0
复杂度： O(N) ， N 为缓存中脚本的数量。
</code></pre><p>清除所有 Lua 脚本缓存。</p><p>关于使用 Redis 对 Lua 脚本进行求值的更多信息，请参见 EVAL script numkeys key [key …] arg [arg …] 命令。</p><h4 id="返回值-120"><a href="#返回值-120" class="headerlink" title="返回值"></a>返回值</h4><p>总是返回 OK</p><h4 id="代码示例-117"><a href="#代码示例-117" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SCRIPT FLUSH</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h3 id="SCRIPT-KILL"><a href="#SCRIPT-KILL" class="headerlink" title="SCRIPT KILL"></a>SCRIPT KILL</h3><h4 id="SCRIPT-KILL-1"><a href="#SCRIPT-KILL-1" class="headerlink" title="SCRIPT KILL"></a>SCRIPT KILL</h4><pre><code>可用版本： &gt;= 2.6.0
时间复杂度： O(1)
</code></pre><p>杀死当前正在运行的 Lua 脚本，当且仅当这个脚本没有执行过任何写操作时，这个命令才生效。</p><p>这个命令主要用于终止运行时间过长的脚本，比如一个因为 BUG 而发生无限 loop 的脚本，诸如此类。</p><p>SCRIPT KILL 执行之后，当前正在运行的脚本会被杀死，执行这个脚本的客户端会从 EVAL script numkeys key [key …] arg [arg …] 命令的阻塞当中退出，并收到一个错误作为返回值。</p><p>另一方面，假如当前正在运行的脚本已经执行过写操作，那么即使执行 SCRIPT KILL ，也无法将它杀死，因为这是违反 Lua 脚本的原子性执行原则的。在这种情况下，唯一可行的办法是使用 SHUTDOWN NOSAVE 命令，通过停止整个 Redis 进程来停止脚本的运行，并防止不完整(half-written)的信息被写入数据库中。</p><p>关于使用 Redis 对 Lua 脚本进行求值的更多信息，请参见 EVAL script numkeys key [key …] arg [arg …] 命令。</p><h4 id="返回值-121"><a href="#返回值-121" class="headerlink" title="返回值"></a>返回值</h4><p>执行成功返回 OK ，否则返回一个错误。</p><h4 id="代码示例-118"><a href="#代码示例-118" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 没有脚本在执行时</span></span><br><span class="line">redis&gt; SCRIPT KILL</span><br><span class="line">(error) ERR No scripts <span class="keyword">in</span> execution right now.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 成功杀死脚本时</span></span><br><span class="line">redis&gt; SCRIPT KILL</span><br><span class="line">OK</span><br><span class="line">(1.30s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 尝试杀死一个已经执行过写操作的脚本，失败</span></span><br><span class="line">redis&gt; SCRIPT KILL</span><br><span class="line">(error) ERR Sorry the script already executed write commands against the dataset. You can either <span class="built_in">wait</span> the script termination or <span class="built_in">kill</span> the server <span class="keyword">in</span> an hard way using the SHUTDOWN NOSAVE <span class="built_in">command</span>.</span><br><span class="line">(1.69s)</span><br></pre></td></tr></table></figure><p>以下是脚本被杀死之后，返回给执行脚本的客户端的错误：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; EVAL <span class="string">"while true do end"</span> 0</span><br><span class="line">(error) ERR Error running script (call to f_694a5fe1ddb97a4c6a1bf299d9537c7d3d0f84e7): Script killed by user with SCRIPT KILL...</span><br><span class="line">(5.00s)</span><br></pre></td></tr></table></figure><p></p><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h3 id="SAVE"><a href="#SAVE" class="headerlink" title="SAVE"></a>SAVE</h3><h4 id="SAVE-1"><a href="#SAVE-1" class="headerlink" title="SAVE"></a>SAVE</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度： O(N)， N 为要保存到数据库中的 key 的数量。
</code></pre><p>SAVE 命令执行一个同步保存操作，将当前 Redis 实例的所有数据快照(snapshot)以 RDB 文件的形式保存到硬盘。</p><p>一般来说，在生产环境很少执行 SAVE 操作，因为它会阻塞所有客户端，保存数据库的任务通常由 BGSAVE 命令异步地执行。然而，如果负责保存数据的后台子进程不幸出现问题时， SAVE 可以作为保存数据的最后手段来使用。</p><h4 id="返回值-122"><a href="#返回值-122" class="headerlink" title="返回值"></a>返回值</h4><p>保存成功时返回 OK 。</p><h4 id="代码示例-119"><a href="#代码示例-119" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SAVE</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h3 id="BGSAVE"><a href="#BGSAVE" class="headerlink" title="BGSAVE"></a>BGSAVE</h3><h4 id="BGSAVE-1"><a href="#BGSAVE-1" class="headerlink" title="BGSAVE"></a>BGSAVE</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度： O(N)， N 为要保存到数据库中的 key 的数量。
</code></pre><p>在后台异步(Asynchronously)保存当前数据库的数据到磁盘。</p><p>BGSAVE 命令执行之后立即返回 OK ，然后 Redis fork 出一个新子进程，原来的 Redis 进程(父进程)继续处理客户端请求，而子进程则负责将数据保存到磁盘，然后退出。</p><p>客户端可以通过 LASTSAVE 命令查看相关信息，判断 BGSAVE 命令是否执行成功。</p><p>请移步 持久化文档 查看更多相关细节。</p><h4 id="返回值-123"><a href="#返回值-123" class="headerlink" title="返回值"></a>返回值</h4><p>反馈信息。</p><h4 id="代码示例-120"><a href="#代码示例-120" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; BGSAVE</span><br><span class="line">Background saving started</span><br></pre></td></tr></table></figure><h3 id="BGREWRITEAOF"><a href="#BGREWRITEAOF" class="headerlink" title="BGREWRITEAOF"></a>BGREWRITEAOF</h3><h4 id="BGREWRITEAOF-1"><a href="#BGREWRITEAOF-1" class="headerlink" title="BGREWRITEAOF"></a>BGREWRITEAOF</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度： O(N)， N 为要追加到 AOF 文件中的数据数量。
</code></pre><p>执行一个 AOF文件 重写操作。重写会创建一个当前 AOF 文件的体积优化版本。</p><p>即使 BGREWRITEAOF 执行失败，也不会有任何数据丢失，因为旧的 AOF 文件在 BGREWRITEAOF 成功之前不会被修改。</p><p>重写操作只会在没有其他持久化工作在后台执行时被触发，也就是说：</p><p>如果 Redis 的子进程正在执行快照的保存工作，那么 AOF 重写的操作会被预定(scheduled)，等到保存工作完成之后再执行 AOF 重写。在这种情况下， BGREWRITEAOF 的返回值仍然是 OK ，但还会加上一条额外的信息，说明 BGREWRITEAOF 要等到保存操作完成之后才能执行。在 Redis 2.6 或以上的版本，可以使用 INFO [section] 命令查看 BGREWRITEAOF 是否被预定。<br>如果已经有别的 AOF 文件重写在执行，那么 BGREWRITEAOF 返回一个错误，并且这个新的 BGREWRITEAOF 请求也不会被预定到下次执行。<br>从 Redis 2.4 开始， AOF 重写由 Redis 自行触发， BGREWRITEAOF 仅仅用于手动触发重写操作。</p><p>请移步 持久化文档(英文) 查看更多相关细节。</p><h4 id="返回值-124"><a href="#返回值-124" class="headerlink" title="返回值"></a>返回值</h4><p>反馈信息。</p><h4 id="代码示例-121"><a href="#代码示例-121" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; BGREWRITEAOF</span><br><span class="line">Background append only file rewriting started</span><br></pre></td></tr></table></figure><h3 id="LASTSAVE"><a href="#LASTSAVE" class="headerlink" title="LASTSAVE"></a>LASTSAVE</h3><h4 id="LASTSAVE-1"><a href="#LASTSAVE-1" class="headerlink" title="LASTSAVE"></a>LASTSAVE</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度： O(1)
</code></pre><p>返回最近一次 Redis 成功将数据保存到磁盘上的时间，以 UNIX 时间戳格式表示。</p><h4 id="返回值-125"><a href="#返回值-125" class="headerlink" title="返回值"></a>返回值</h4><p>一个 UNIX 时间戳。</p><h4 id="代码示例-122"><a href="#代码示例-122" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; LASTSAVE</span><br><span class="line">(<span class="built_in">integer</span>) 1324043588</span><br></pre></td></tr></table></figure><h2 id="发布与订阅"><a href="#发布与订阅" class="headerlink" title="发布与订阅"></a>发布与订阅</h2><h3 id="PUBLISH"><a href="#PUBLISH" class="headerlink" title="PUBLISH"></a>PUBLISH</h3><h4 id="PUBLISH-channel-message"><a href="#PUBLISH-channel-message" class="headerlink" title="PUBLISH channel message"></a>PUBLISH channel message</h4><pre><code>可用版本： &gt;= 2.0.0
时间复杂度： O(N+M)，其中 N 是频道 channel 的订阅者数量，而 M 则是使用模式订阅(subscribed patterns)的客户端的数量。
</code></pre><p>将信息 message 发送到指定的频道 channel 。</p><h4 id="返回值-126"><a href="#返回值-126" class="headerlink" title="返回值"></a>返回值</h4><p>接收到信息 message 的订阅者数量。</p><h4 id="代码示例-123"><a href="#代码示例-123" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对没有订阅者的频道发送信息</span></span><br><span class="line">redis&gt; publish bad_channel <span class="string">"can any body hear me?"</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向有一个订阅者的频道发送信息</span></span><br><span class="line">redis&gt; publish msg <span class="string">"good morning"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向有多个订阅者的频道发送信息</span></span><br><span class="line">redis&gt; publish chat_room <span class="string">"hello~ everyone"</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure><h3 id="SUBSCRIBE"><a href="#SUBSCRIBE" class="headerlink" title="SUBSCRIBE"></a>SUBSCRIBE</h3><h4 id="SUBSCRIBE-channel-channel-…"><a href="#SUBSCRIBE-channel-channel-…" class="headerlink" title="SUBSCRIBE channel [channel …]"></a>SUBSCRIBE channel [channel …]</h4><pre><code>可用版本： &gt;= 2.0.0
时间复杂度： O(N)，其中 N 是订阅的频道的数量。
</code></pre><p>订阅给定的一个或多个频道的信息。</p><h4 id="返回值-127"><a href="#返回值-127" class="headerlink" title="返回值"></a>返回值</h4><p>接收到的信息(请参见下面的代码说明)。</p><h4 id="代码示例-124"><a href="#代码示例-124" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 订阅 msg 和 chat_room 两个频道</span></span><br><span class="line"><span class="comment"># 1 - 6 行是执行 subscribe 之后的反馈信息</span></span><br><span class="line"><span class="comment"># 第 7 - 9 行才是接收到的第一条信息</span></span><br><span class="line"><span class="comment"># 第 10 - 12 行是第二条</span></span><br><span class="line">redis&gt; subscribe msg chat_room</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">"subscribe"</span>       <span class="comment"># 返回值的类型：显示订阅成功</span></span><br><span class="line">2) <span class="string">"msg"</span>             <span class="comment"># 订阅的频道名字</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1       <span class="comment"># 目前已订阅的频道数量</span></span><br><span class="line"></span><br><span class="line">1) <span class="string">"subscribe"</span></span><br><span class="line">2) <span class="string">"chat_room"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">1) <span class="string">"message"</span>         <span class="comment"># 返回值的类型：信息</span></span><br><span class="line">2) <span class="string">"msg"</span>             <span class="comment"># 来源(从那个频道发送过来)</span></span><br><span class="line">3) <span class="string">"hello moto"</span>      <span class="comment"># 信息内容</span></span><br><span class="line"></span><br><span class="line">1) <span class="string">"message"</span></span><br><span class="line">2) <span class="string">"chat_room"</span></span><br><span class="line">3) <span class="string">"testing...haha"</span></span><br></pre></td></tr></table></figure><h3 id="PSUBSCRIBE"><a href="#PSUBSCRIBE" class="headerlink" title="PSUBSCRIBE"></a>PSUBSCRIBE</h3><h4 id="PSUBSCRIBE-pattern-pattern-…"><a href="#PSUBSCRIBE-pattern-pattern-…" class="headerlink" title="PSUBSCRIBE pattern [pattern …]"></a>PSUBSCRIBE pattern [pattern …]</h4><pre><code>可用版本： &gt;= 2.0.0
时间复杂度： O(N)， N 是订阅的模式的数量。
</code></pre><p>订阅一个或多个符合给定模式的频道。</p><p>每个模式以 <em>作为匹配符，比如 it</em> 匹配所有以 it 开头的频道( it.news 、 it.blog 、 it.tweets 等等)， news.* 匹配所有以 news. 开头的频道( news.it 、 news.global.today 等等)，诸如此类。</p><h4 id="返回值-128"><a href="#返回值-128" class="headerlink" title="返回值"></a>返回值</h4><p>接收到的信息(请参见下面的代码说明)。</p><h4 id="代码示例-125"><a href="#代码示例-125" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 订阅 news.* 和 tweet.* 两个模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第 1 - 6 行是执行 psubscribe 之后的反馈信息</span></span><br><span class="line"><span class="comment"># 第 7 - 10 才是接收到的第一条信息</span></span><br><span class="line"><span class="comment"># 第 11 - 14 是第二条</span></span><br><span class="line"><span class="comment"># 以此类推。。。</span></span><br><span class="line">redis&gt; psubscribe news.* tweet.*</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">"psubscribe"</span>                  <span class="comment"># 返回值的类型：显示订阅成功</span></span><br><span class="line">2) <span class="string">"news.*"</span>                      <span class="comment"># 订阅的模式</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1                   <span class="comment"># 目前已订阅的模式的数量</span></span><br><span class="line"></span><br><span class="line">1) <span class="string">"psubscribe"</span></span><br><span class="line">2) <span class="string">"tweet.*"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">1) <span class="string">"pmessage"</span>                    <span class="comment"># 返回值的类型：信息</span></span><br><span class="line">2) <span class="string">"news.*"</span>                      <span class="comment"># 信息匹配的模式</span></span><br><span class="line">3) <span class="string">"news.it"</span>                     <span class="comment"># 信息本身的目标频道</span></span><br><span class="line">4) <span class="string">"Google buy Motorola"</span>         <span class="comment"># 信息的内容</span></span><br><span class="line"></span><br><span class="line">1) <span class="string">"pmessage"</span></span><br><span class="line">2) <span class="string">"tweet.*"</span></span><br><span class="line">3) <span class="string">"tweet.huangz"</span></span><br><span class="line">4) <span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line">1) <span class="string">"pmessage"</span></span><br><span class="line">2) <span class="string">"tweet.*"</span></span><br><span class="line">3) <span class="string">"tweet.joe"</span></span><br><span class="line">4) <span class="string">"@huangz morning"</span></span><br><span class="line"></span><br><span class="line">1) <span class="string">"pmessage"</span></span><br><span class="line">2) <span class="string">"news.*"</span></span><br><span class="line">3) <span class="string">"news.life"</span></span><br><span class="line">4) <span class="string">"An apple a day, keep doctors away"</span></span><br></pre></td></tr></table></figure><h3 id="UNSUBSCRIBE"><a href="#UNSUBSCRIBE" class="headerlink" title="UNSUBSCRIBE"></a>UNSUBSCRIBE</h3><h4 id="UNSUBSCRIBE-channel-channel-…"><a href="#UNSUBSCRIBE-channel-channel-…" class="headerlink" title="UNSUBSCRIBE [channel [channel …]]"></a>UNSUBSCRIBE [channel [channel …]]</h4><pre><code>可用版本： &gt;= 2.0.0
时间复杂度： O(N) ， N 是客户端已订阅的频道的数量。
</code></pre><p>指示客户端退订给定的频道。</p><p>如果没有频道被指定，也即是，一个无参数的 UNSUBSCRIBE 调用被执行，那么客户端使用 SUBSCRIBE 命令订阅的所有频道都会被退订。在这种情况下，命令会返回一个信息，告知客户端所有被退订的频道。</p><h4 id="返回值-129"><a href="#返回值-129" class="headerlink" title="返回值"></a>返回值</h4><p>这个命令在不同的客户端中有不同的表现。</p><h3 id="PUNSUBSCRIBE"><a href="#PUNSUBSCRIBE" class="headerlink" title="PUNSUBSCRIBE"></a>PUNSUBSCRIBE</h3><h4 id="PUNSUBSCRIBE-pattern-pattern-…"><a href="#PUNSUBSCRIBE-pattern-pattern-…" class="headerlink" title="PUNSUBSCRIBE [pattern [pattern …]]"></a>PUNSUBSCRIBE [pattern [pattern …]]</h4><pre><code>可用版本： &gt;= 2.0.0
时间复杂度： O(N+M) ，其中 N 是客户端已订阅的模式的数量， M 则是系统中所有客户端订阅的模式的数量。
</code></pre><p>指示客户端退订所有给定模式。</p><p>如果没有模式被指定，也即是，一个无参数的 PUNSUBSCRIBE 调用被执行，那么客户端使用 PSUBSCRIBE pattern [pattern …] 命令订阅的所有模式都会被退订。在这种情况下，命令会返回一个信息，告知客户端所有被退订的模式。</p><h4 id="返回值-130"><a href="#返回值-130" class="headerlink" title="返回值"></a>返回值</h4><p>这个命令在不同的客户端中有不同的表现。</p><h3 id="PUBSUB"><a href="#PUBSUB" class="headerlink" title="PUBSUB"></a>PUBSUB</h3><h4 id="PUBSUB-argument-argument-…"><a href="#PUBSUB-argument-argument-…" class="headerlink" title="PUBSUB  [argument [argument …]]"></a>PUBSUB<subcommand> [argument [argument …]]</subcommand></h4><pre><code>可用版本：&gt;= 2.8.0
</code></pre><p>PUBSUB 是一个查看订阅与发布系统状态的内省命令， 它由数个不同格式的子命令组成， 以下将分别对这些子命令进行介绍。</p><h4 id="PUBSUB-CHANNELS-pattern"><a href="#PUBSUB-CHANNELS-pattern" class="headerlink" title="PUBSUB CHANNELS [pattern]"></a>PUBSUB CHANNELS [pattern]</h4><p>复杂度： O(N) ， N 为活跃频道的数量（对于长度较短的频道和模式来说，将进行模式匹配的复杂度视为常数）。<br>列出当前的活跃频道。</p><p>活跃频道指的是那些至少有一个订阅者的频道， 订阅模式的客户端不计算在内。</p><p>pattern 参数是可选的：</p><ul><li>如果不给出 pattern 参数，那么列出订阅与发布系统中的所有活跃频道。</li><li>如果给出 pattern 参数，那么只列出和给定模式 pattern 相匹配的那些活跃频道。<h5 id="返回值-131"><a href="#返回值-131" class="headerlink" title="返回值"></a>返回值</h5>一个由活跃频道组成的列表。</li></ul><h5 id="代码示例-126"><a href="#代码示例-126" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># client-1 订阅 news.it 和 news.sport 两个频道</span></span><br><span class="line">client-1&gt; SUBSCRIBE news.it news.sport</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">"subscribe"</span></span><br><span class="line">2) <span class="string">"news.it"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line">1) <span class="string">"subscribe"</span></span><br><span class="line">2) <span class="string">"news.sport"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># client-2 订阅 news.it 和 news.internet 两个频道</span></span><br><span class="line">client-2&gt; SUBSCRIBE news.it news.internet</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">"subscribe"</span></span><br><span class="line">2) <span class="string">"news.it"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line">1) <span class="string">"subscribe"</span></span><br><span class="line">2) <span class="string">"news.internet"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先， client-3 打印所有活跃频道</span></span><br><span class="line"><span class="comment"># 注意，即使一个频道有多个订阅者，它也只输出一次，比如 news.it</span></span><br><span class="line">client-3&gt; PUBSUB CHANNELS</span><br><span class="line">1) <span class="string">"news.sport"</span></span><br><span class="line">2) <span class="string">"news.internet"</span></span><br><span class="line">3) <span class="string">"news.it"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来， client-3 打印那些与模式 news.i* 相匹配的活跃频道</span></span><br><span class="line"><span class="comment"># 因为 news.sport 不匹配 news.i* ，所以它没有被打印</span></span><br><span class="line">redis&gt; PUBSUB CHANNELS news.i*</span><br><span class="line">1) <span class="string">"news.internet"</span></span><br><span class="line">2) <span class="string">"news.it"</span></span><br></pre></td></tr></table></figure><h4 id="PUBSUB-NUMSUB-channel-1-…-channel-N"><a href="#PUBSUB-NUMSUB-channel-1-…-channel-N" class="headerlink" title="PUBSUB NUMSUB [channel-1 … channel-N]"></a>PUBSUB NUMSUB [channel-1 … channel-N]</h4><pre><code>复杂度： O(N) ， N 为给定频道的数量。
</code></pre><p>返回给定频道的订阅者数量， 订阅模式的客户端不计算在内。</p><h5 id="返回值-132"><a href="#返回值-132" class="headerlink" title="返回值"></a>返回值</h5><p>一个多条批量回复（Multi-bulk reply），回复中包含给定的频道，以及频道的订阅者数量。 格式为：频道 channel-1 ， channel-1 的订阅者数量，频道 channel-2 ， channel-2 的订阅者数量，诸如此类。 回复中频道的排列顺序和执行命令时给定频道的排列顺序一致。 不给定任何频道而直接调用这个命令也是可以的， 在这种情况下， 命令只返回一个空列表。</p><h5 id="代码示例-127"><a href="#代码示例-127" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># client-1 订阅 news.it 和 news.sport 两个频道</span></span><br><span class="line">client-1&gt; SUBSCRIBE news.it news.sport</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">"subscribe"</span></span><br><span class="line">2) <span class="string">"news.it"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line">1) <span class="string">"subscribe"</span></span><br><span class="line">2) <span class="string">"news.sport"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># client-2 订阅 news.it 和 news.internet 两个频道</span></span><br><span class="line">client-2&gt; SUBSCRIBE news.it news.internet</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">"subscribe"</span></span><br><span class="line">2) <span class="string">"news.it"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line">1) <span class="string">"subscribe"</span></span><br><span class="line">2) <span class="string">"news.internet"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># client-3 打印各个频道的订阅者数量</span></span><br><span class="line">client-3&gt; PUBSUB NUMSUB news.it news.internet news.sport news.music</span><br><span class="line">1) <span class="string">"news.it"</span>    <span class="comment"># 频道</span></span><br><span class="line">2) <span class="string">"2"</span>          <span class="comment"># 订阅该频道的客户端数量</span></span><br><span class="line">3) <span class="string">"news.internet"</span></span><br><span class="line">4) <span class="string">"1"</span></span><br><span class="line">5) <span class="string">"news.sport"</span></span><br><span class="line">6) <span class="string">"1"</span></span><br><span class="line">7) <span class="string">"news.music"</span> <span class="comment"># 没有任何订阅者</span></span><br><span class="line">8) <span class="string">"0"</span></span><br></pre></td></tr></table></figure><h4 id="PUBSUB-NUMPAT"><a href="#PUBSUB-NUMPAT" class="headerlink" title="PUBSUB NUMPAT"></a>PUBSUB NUMPAT</h4><pre><code>复杂度： O(1) 。
</code></pre><p>返回订阅模式的数量。</p><p>注意， 这个命令返回的不是订阅模式的客户端的数量， 而是客户端订阅的所有模式的数量总和。</p><h5 id="返回值-133"><a href="#返回值-133" class="headerlink" title="返回值"></a>返回值</h5><p>一个整数回复（Integer reply）。</p><h5 id="代码示例-128"><a href="#代码示例-128" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># client-1 订阅 news.* 和 discount.* 两个模式</span></span><br><span class="line">client-1&gt; PSUBSCRIBE news.* discount.*</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">"psubscribe"</span></span><br><span class="line">2) <span class="string">"news.*"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line">1) <span class="string">"psubscribe"</span></span><br><span class="line">2) <span class="string">"discount.*"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># client-2 订阅 tweet.* 一个模式</span></span><br><span class="line">client-2&gt; PSUBSCRIBE tweet.*</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">"psubscribe"</span></span><br><span class="line">2) <span class="string">"tweet.*"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># client-3 返回当前订阅模式的数量为 3</span></span><br><span class="line">client-3&gt; PUBSUB NUMPAT</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意，当有多个客户端订阅相同的模式时，相同的订阅也被计算在 PUBSUB NUMPAT 之内</span></span><br><span class="line"><span class="comment"># 比如说，再新建一个客户端 client-4 ，让它也订阅 news.* 频道</span></span><br><span class="line">client-4&gt; PSUBSCRIBE news.*</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">"psubscribe"</span></span><br><span class="line">2) <span class="string">"news.*"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这时再计算被订阅模式的数量，就会得到数量为 4</span></span><br><span class="line">client-3&gt; PUBSUB NUMPAT</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br></pre></td></tr></table></figure><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><h3 id="SLAVEOF"><a href="#SLAVEOF" class="headerlink" title="SLAVEOF"></a>SLAVEOF</h3><h4 id="SLAVEOF-host-port"><a href="#SLAVEOF-host-port" class="headerlink" title="SLAVEOF host port"></a>SLAVEOF host port</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度： SLAVEOF host port 的复杂度为 O(N)，其中 N 为要同步的数据数量； SLAVEOF NO ONE 命令的复杂度为 O(1) 。
</code></pre><p>SLAVEOF 命令用于在 Redis 运行时动态地修改复制(replication)功能的行为。</p><p>通过执行 SLAVEOF host port 命令，可以将当前服务器转变为指定服务器的从属服务器(slave server)。</p><p>如果当前服务器已经是某个主服务器(master server)的从属服务器，那么执行 SLAVEOF host port 将使当前服务器停止对旧主服务器的同步，丢弃旧数据集，转而开始对新主服务器进行同步。</p><p>另外，对一个从属服务器执行命令 SLAVEOF NO ONE 将使得这个从属服务器关闭复制功能，并从从属服务器转变回主服务器，原来同步所得的数据集不会被丢弃。</p><p>利用“SLAVEOF NO ONE 不会丢弃同步所得数据集”这个特性，可以在主服务器失败的时候，将从属服务器用作新的主服务器，从而实现无间断运行。</p><h4 id="返回值-134"><a href="#返回值-134" class="headerlink" title="返回值"></a>返回值</h4><p>总是返回 OK 。</p><h4 id="代码示例-129"><a href="#代码示例-129" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SLAVEOF 127.0.0.1 6379</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SLAVEOF NO ONE</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h3 id="ROLE"><a href="#ROLE" class="headerlink" title="ROLE"></a>ROLE</h3><h4 id="ROLE-1"><a href="#ROLE-1" class="headerlink" title="ROLE"></a>ROLE</h4><pre><code>可用版本： &gt;= 2.8.12
时间复杂度： O(1)
</code></pre><p>返回实例在复制中担任的角色， 这个角色可以是 master 、 slave 或者 sentinel 。 除了角色之外， 命令还会返回与该角色相关的其他信息， 其中：</p><ul><li>主服务器将返回属下从服务器的 IP 地址和端口。</li><li>从服务器将返回自己正在复制的主服务器的 IP 地址、端口、连接状态以及复制偏移量。</li><li>Sentinel 将返回自己正在监视的主服务器列表。<h3 id="返回值-135"><a href="#返回值-135" class="headerlink" title="返回值"></a>返回值</h3>ROLE 命令将返回一个数组。</li></ul><h3 id="代码示例-130"><a href="#代码示例-130" class="headerlink" title="代码示例"></a>代码示例</h3><p>主服务器<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1) <span class="string">"master"</span></span><br><span class="line">2) (<span class="built_in">integer</span>) 3129659</span><br><span class="line">3) 1) 1) <span class="string">"127.0.0.1"</span></span><br><span class="line">      2) <span class="string">"9001"</span></span><br><span class="line">      3) <span class="string">"3129242"</span></span><br><span class="line">   2) 1) <span class="string">"127.0.0.1"</span></span><br><span class="line">      2) <span class="string">"9002"</span></span><br><span class="line">      3) <span class="string">"3129543"</span></span><br></pre></td></tr></table></figure><p></p><p>从服务器<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1) <span class="string">"slave"</span></span><br><span class="line">2) <span class="string">"127.0.0.1"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 9000</span><br><span class="line">4) <span class="string">"connected"</span></span><br><span class="line">5) (<span class="built_in">integer</span>) 3167038</span><br></pre></td></tr></table></figure><p></p><p>Sentinel<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1) <span class="string">"sentinel"</span></span><br><span class="line">2) 1) <span class="string">"resque-master"</span></span><br><span class="line">   2) <span class="string">"html-fragments-master"</span></span><br><span class="line">   3) <span class="string">"stats-master"</span></span><br><span class="line">   4) <span class="string">"metadata-master"</span></span><br></pre></td></tr></table></figure><p></p><h2 id="客户端与服务器"><a href="#客户端与服务器" class="headerlink" title="客户端与服务器"></a>客户端与服务器</h2><h3 id="AUTH"><a href="#AUTH" class="headerlink" title="AUTH"></a>AUTH</h3><h4 id="AUTH-password"><a href="#AUTH-password" class="headerlink" title="AUTH password"></a>AUTH password</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度： O(1)
</code></pre><p>通过设置配置文件中 requirepass 项的值(使用命令 CONFIG SET requirepass password )，可以使用密码来保护 Redis 服务器。</p><p>如果开启了密码保护的话，在每次连接 Redis 服务器之后，就要使用 AUTH 命令解锁，解锁之后才能使用其他 Redis 命令。</p><p>如果 AUTH 命令给定的密码 password 和配置文件中的密码相符的话，服务器会返回 OK 并开始接受命令输入。</p><p>另一方面，假如密码不匹配的话，服务器将返回一个错误，并要求客户端需重新输入密码。</p><h4 id="Warning-2"><a href="#Warning-2" class="headerlink" title="Warning"></a>Warning</h4><p>因为 Redis 高性能的特点，在很短时间内尝试猜测非常多个密码是有可能的，因此请确保使用的密码足够复杂和足够长，以免遭受密码猜测攻击。</p><h4 id="返回值-136"><a href="#返回值-136" class="headerlink" title="返回值"></a>返回值</h4><p>密码匹配时返回 OK ，否则返回一个错误。</p><h4 id="代码示例-131"><a href="#代码示例-131" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置密码</span></span><br><span class="line">redis&gt; CONFIG SET requirepass secret_password   <span class="comment"># 将密码设置为 secret_password</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; QUIT                                     <span class="comment"># 退出再连接，让新密码对客户端生效</span></span><br><span class="line"></span><br><span class="line">[huangz@mypad]$ redis</span><br><span class="line"></span><br><span class="line">redis&gt; PING                                     <span class="comment"># 未验证密码，操作被拒绝</span></span><br><span class="line">(error) ERR operation not permitted</span><br><span class="line"></span><br><span class="line">redis&gt; AUTH wrong_password_testing              <span class="comment"># 尝试输入错误的密码</span></span><br><span class="line">(error) ERR invalid password</span><br><span class="line"></span><br><span class="line">redis&gt; AUTH secret_password                     <span class="comment"># 输入正确的密码</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; PING                                     <span class="comment"># 密码验证成功，可以正常操作命令了</span></span><br><span class="line">PONG</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空密码</span></span><br><span class="line">redis&gt; CONFIG SET requirepass <span class="string">""</span>   <span class="comment"># 通过将密码设为空字符来清空密码</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; QUIT</span><br><span class="line">$ redis                            <span class="comment"># 重新进入客户端</span></span><br><span class="line">redis&gt; PING                        <span class="comment"># 执行命令不再需要密码，清空密码操作成功</span></span><br><span class="line">PONG</span><br></pre></td></tr></table></figure><h3 id="QUIT"><a href="#QUIT" class="headerlink" title="QUIT"></a>QUIT</h3><h4 id="QUIT-1"><a href="#QUIT-1" class="headerlink" title="QUIT"></a>QUIT</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度： O(1)
</code></pre><p>请求服务器关闭与当前客户端的连接。</p><p>一旦所有等待中的回复(如果有的话)顺利写入到客户端，连接就会被关闭。</p><h4 id="返回值-137"><a href="#返回值-137" class="headerlink" title="返回值"></a>返回值</h4><p>总是返回 OK (但是不会被打印显示，因为当时 Redis-cli 已经退出)。</p><h4 id="代码示例-132"><a href="#代码示例-132" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ redis</span><br><span class="line">redis&gt; QUIT</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h3 id="INFO"><a href="#INFO" class="headerlink" title="INFO"></a>INFO</h3><h4 id="INFO-section"><a href="#INFO-section" class="headerlink" title="INFO [section]"></a>INFO [section]</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度： O(1)
</code></pre><p>以一种易于解释（parse）且易于阅读的格式，返回关于 Redis 服务器的各种信息和统计数值。</p><p>通过给定可选的参数 section ，可以让命令只返回某一部分的信息：</p><ul><li><p>server 部分记录了 Redis 服务器的信息，它包含以下域：</p><ul><li>redis_version : Redis 服务器版本</li><li>redis_git_sha1 : Git SHA1</li><li>redis_git_dirty : Git dirty flag</li><li>os : Redis 服务器的宿主操作系统</li><li>arch_bits : 架构（32 或 64 位）</li><li>multiplexing_api : Redis 所使用的事件处理机制</li><li>gcc_version : 编译 Redis 时所使用的 GCC 版本</li><li>process_id : 服务器进程的 PID</li><li>run_id : Redis 服务器的随机标识符（用于 Sentinel 和集群）</li><li>tcp_port : TCP/IP 监听端口</li><li>uptime_in_seconds : 自 Redis 服务器启动以来，经过的秒数</li><li>uptime_in_days : 自 Redis 服务器启动以来，经过的天数</li><li>lru_clock : 以分钟为单位进行自增的时钟，用于 LRU 管理</li></ul></li><li><p>clients 部分记录了已连接客户端的信息，它包含以下域：</p><ul><li>connected_clients : 已连接客户端的数量（不包括通过从属服务器连接的客户端）</li><li>client_longest_output_list : 当前连接的客户端当中，最长的输出列表</li><li>client_longest_input_buf : 当前连接的客户端当中，最大输入缓存</li><li>blocked_clients : 正在等待阻塞命令（BLPOP、BRPOP、BRPOPLPUSH）的客户端的数量</li></ul></li><li><p>memory 部分记录了服务器的内存信息，它包含以下域：</p><ul><li>used_memory : 由 Redis 分配器分配的内存总量，以字节（byte）为单位</li><li>used_memory_human : 以人类可读的格式返回 Redis 分配的内存总量</li><li>used_memory_rss : 从操作系统的角度，返回 Redis 已分配的内存总量（俗称常驻集大小）。这个值和 top 、 ps 等命令的输出一致。</li><li>used_memory_peak : Redis 的内存消耗峰值（以字节为单位）</li><li>used_memory_peak_human : 以人类可读的格式返回 Redis 的内存消耗峰值</li><li>used_memory_lua : Lua 引擎所使用的内存大小（以字节为单位）</li><li>mem_fragmentation_ratio : used_memory_rss 和 used_memory 之间的比率</li><li><p>mem_allocator : 在编译时指定的， Redis 所使用的内存分配器。可以是 libc 、 jemalloc 或者 tcmalloc 。</p><p>在理想情况下， used_memory_rss 的值应该只比 used_memory 稍微高一点儿。</p><p>当 rss &gt; used ，且两者的值相差较大时，表示存在（内部或外部的）内存碎片。</p><p>内存碎片的比率可以通过 mem_fragmentation_ratio 的值看出。</p><p>当 used &gt; rss 时，表示 Redis 的部分内存被操作系统换出到交换空间了，在这种情况下，操作可能会产生明显的延迟。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Because Redis does not have control over how its allocations are mapped to memory pages, high used_memory_rss is often the result of a spike in memory usage.</span><br></pre></td></tr></table></figure><p>当 Redis 释放内存时，分配器可能会，也可能不会，将内存返还给操作系统。</p><p>如果 Redis 释放了内存，却没有将内存返还给操作系统，那么 used_memory 的值可能和操作系统显示的 Redis 内存占用并不一致。</p><p>查看 used_memory_peak 的值可以验证这种情况是否发生。</p></li></ul></li><li><p>persistence 部分记录了跟 RDB 持久化和 AOF 持久化有关的信息，它包含以下域：</p><ul><li>loading : 一个标志值，记录了服务器是否正在载入持久化文件。</li><li>rdb_changes_since_last_save : 距离最近一次成功创建持久化文件之后，经过了多少秒。</li><li>rdb_bgsave_in_progress : 一个标志值，记录了服务器是否正在创建 RDB 文件。</li><li>rdb_last_save_time : 最近一次成功创建 RDB 文件的 UNIX 时间戳。</li><li>rdb_last_bgsave_status : 一个标志值，记录了最近一次创建 RDB 文件的结果是成功还是失败。</li><li>rdb_last_bgsave_time_sec : 记录了最近一次创建 RDB 文件耗费的秒数。</li><li>rdb_current_bgsave_time_sec : 如果服务器正在创建 RDB 文件，那么这个域记录的就是当前的创建操作已经耗费的秒数。</li><li>aof_enabled : 一个标志值，记录了 AOF 是否处于打开状态。</li><li>aof_rewrite_in_progress : 一个标志值，记录了服务器是否正在创建 AOF 文件。</li><li>aof_rewrite_scheduled : 一个标志值，记录了在 RDB 文件创建完毕之后，是否需要执行预约的 AOF 重写操作。</li><li>aof_last_rewrite_time_sec : 最近一次创建 AOF 文件耗费的时长。</li><li>aof_current_rewrite_time_sec : 如果服务器正在创建 AOF 文件，那么这个域记录的就是当前的创建操作已经耗费的秒数。</li><li><p>aof_last_bgrewrite_status : 一个标志值，记录了最近一次创建 AOF 文件的结果是成功还是失败。</p><p>如果 AOF 持久化功能处于开启状态，那么这个部分还会加上以下域：</p></li><li><p>aof_current_size : AOF 文件目前的大小。</p></li><li>aof_base_size : 服务器启动时或者 AOF 重写最近一次执行之后，AOF 文件的大小。</li><li>aof_pending_rewrite : 一个标志值，记录了是否有 AOF 重写操作在等待 RDB 文件创建完毕之后执行。</li><li>aof_buffer_length : AOF 缓冲区的大小。</li><li>aof_rewrite_buffer_length : AOF 重写缓冲区的大小。</li><li>aof_pending_bio_fsync : 后台 I/O 队列里面，等待执行的 fsync 调用数量。</li><li>aof_delayed_fsync : 被延迟的 fsync 调用数量。</li><li></li></ul></li><li><p>stats 部分记录了一般统计信息，它包含以下域：</p><ul><li>total_connections_received : 服务器已接受的连接请求数量。</li><li>total_commands_processed : 服务器已执行的命令数量。</li><li>instantaneous_ops_per_sec : 服务器每秒钟执行的命令数量。</li><li>rejected_connections : 因为最大客户端数量限制而被拒绝的连接请求数量。</li><li>expired_keys : 因为过期而被自动删除的数据库键数量。</li><li>evicted_keys : 因为最大内存容量限制而被驱逐（evict）的键数量。</li><li>keyspace_hits : 查找数据库键成功的次数。</li><li>keyspace_misses : 查找数据库键失败的次数。</li><li>pubsub_channels : 目前被订阅的频道数量。</li><li>pubsub_patterns : 目前被订阅的模式数量。</li><li>latest_fork_usec : 最近一次 fork() 操作耗费的毫秒数。</li><li>replication : 主/从复制信息</li></ul></li><li><p>role : 如果当前服务器没有在复制任何其他服务器，那么这个域的值就是 master ；否则的话，这个域的值就是 slave 。注意，在创建复制链的时候，一个从服务器也可能是另一个服务器的主服务器。</p><p> 如果当前服务器是一个从服务器的话，那么这个部分还会加上以下域：</p><ul><li>master_host : 主服务器的 IP 地址。</li><li>master_port : 主服务器的 TCP 监听端口号。</li><li>master_link_status : 复制连接当前的状态， up 表示连接正常， down 表示连接断开。</li><li>master_last_io_seconds_ago : 距离最近一次与主服务器进行通信已经过去了多少秒钟。</li><li><p>master_sync_in_progress : 一个标志值，记录了主服务器是否正在与这个从服务器进行同步。</p><p>如果同步操作正在进行，那么这个部分还会加上以下域：</p></li><li><p>master_sync_left_bytes : 距离同步完成还缺少多少字节数据。</p></li><li><p>master_sync_last_io_seconds_ago : 距离最近一次因为 SYNC 操作而进行 I/O 已经过去了多少秒。</p><p>如果主从服务器之间的连接处于断线状态，那么这个部分还会加上以下域：</p></li><li><p>master_link_down_since_seconds : 主从服务器连接断开了多少秒。</p><p>以下是一些总会出现的域：</p></li><li><p>connected_slaves : 已连接的从服务器数量。</p><p>对于每个从服务器，都会添加以下一行信息：</p></li><li><p>slaveXXX : ID、IP 地址、端口号、连接状态</p></li></ul></li><li><p>cpu 部分记录了 CPU 的计算量统计信息，它包含以下域：</p><ul><li>used_cpu_sys : Redis 服务器耗费的系统 CPU 。</li><li>used_cpu_user : Redis 服务器耗费的用户 CPU 。</li><li>used_cpu_sys_children : 后台进程耗费的系统 CPU 。</li><li>used_cpu_user_children : 后台进程耗费的用户 CPU 。</li></ul></li><li><p>commandstats 部分记录了各种不同类型的命令的执行统计信息，比如命令执行的次数、命令耗费的 CPU 时间、执行每个命令耗费的平均 CPU 时间等等。对于每种类型的命令，这个部分都会添加一行以下格式的信息：</p><ul><li>cmdstat_XXX:calls=XXX,usec=XXX,usecpercall=XXX</li><li><p>cluster 部分记录了和集群有关的信息，它包含以下域：</p></li><li><p>cluster_enabled : 一个标志值，记录集群功能是否已经开启。</p></li></ul></li><li><p>keyspace 部分记录了数据库相关的统计信息，比如数据库的键数量、数据库已经被删除的过期键数量等。对于每个数据库，这个部分都会添加一行以下格式的信息：</p><ul><li>dbXXX:keys=XXX,expires=XXX</li></ul></li></ul><p>除上面给出的这些值以外， section 参数的值还可以是下面这两个：</p><ul><li>all : 返回所有信息</li><li>default : 返回默认选择的信息</li></ul><p>当不带参数直接调用 INFO 命令时，使用 default 作为默认参数。</p><h4 id="Note-8"><a href="#Note-8" class="headerlink" title="Note"></a>Note</h4><p>不同版本的 Redis 可能对返回的一些域进行了增加或删减。</p><p>因此，一个健壮的客户端程序在对 INFO [section] 命令的输出进行分析时，应该能够跳过不认识的域，并且妥善地处理丢失不见的域。</p><h4 id="返回值-138"><a href="#返回值-138" class="headerlink" title="返回值"></a>返回值</h4><p>具体请参见下面的测试代码。</p><h4 id="代码示例-133"><a href="#代码示例-133" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; INFO</span><br><span class="line"><span class="comment"># Server</span></span><br><span class="line">redis_version:2.9.11</span><br><span class="line">redis_git_sha1:937384d0</span><br><span class="line">redis_git_dirty:0</span><br><span class="line">redis_build_id:8e9509442863f22</span><br><span class="line">redis_mode:standalone</span><br><span class="line">os:Linux 3.13.0-35-generic x86_64</span><br><span class="line">arch_bits:64</span><br><span class="line">multiplexing_api:epoll</span><br><span class="line">gcc_version:4.8.2</span><br><span class="line">process_id:4716</span><br><span class="line">run_id:26186aac3f2380aaee9eef21cc50aecd542d97dc</span><br><span class="line">tcp_port:6379</span><br><span class="line">uptime_in_seconds:362</span><br><span class="line">uptime_in_days:0</span><br><span class="line">hz:10</span><br><span class="line">lru_clock:1725349</span><br><span class="line">config_file:</span><br><span class="line"></span><br><span class="line"><span class="comment"># Clients</span></span><br><span class="line">connected_clients:1</span><br><span class="line">client_longest_output_list:0</span><br><span class="line">client_biggest_input_buf:0</span><br><span class="line">blocked_clients:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Memory</span></span><br><span class="line">used_memory:508536</span><br><span class="line">used_memory_human:496.62K</span><br><span class="line">used_memory_rss:7974912</span><br><span class="line">used_memory_peak:508536</span><br><span class="line">used_memory_peak_human:496.62K</span><br><span class="line">used_memory_lua:33792</span><br><span class="line">mem_fragmentation_ratio:15.68</span><br><span class="line">mem_allocator:jemalloc-3.2.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Persistence</span></span><br><span class="line">loading:0</span><br><span class="line">rdb_changes_since_last_save:6</span><br><span class="line">rdb_bgsave_in_progress:0</span><br><span class="line">rdb_last_save_time:1411011131</span><br><span class="line">rdb_last_bgsave_status:ok</span><br><span class="line">rdb_last_bgsave_time_sec:-1</span><br><span class="line">rdb_current_bgsave_time_sec:-1</span><br><span class="line">aof_enabled:0</span><br><span class="line">aof_rewrite_in_progress:0</span><br><span class="line">aof_rewrite_scheduled:0</span><br><span class="line">aof_last_rewrite_time_sec:-1</span><br><span class="line">aof_current_rewrite_time_sec:-1</span><br><span class="line">aof_last_bgrewrite_status:ok</span><br><span class="line">aof_last_write_status:ok</span><br><span class="line"></span><br><span class="line"><span class="comment"># Stats</span></span><br><span class="line">total_connections_received:2</span><br><span class="line">total_commands_processed:4</span><br><span class="line">instantaneous_ops_per_sec:0</span><br><span class="line">rejected_connections:0</span><br><span class="line">sync_full:0</span><br><span class="line">sync_partial_ok:0</span><br><span class="line">sync_partial_err:0</span><br><span class="line">expired_keys:0</span><br><span class="line">evicted_keys:0</span><br><span class="line">keyspace_hits:0</span><br><span class="line">keyspace_misses:0</span><br><span class="line">pubsub_channels:0</span><br><span class="line">pubsub_patterns:0</span><br><span class="line">latest_fork_usec:0</span><br><span class="line">migrate_cached_sockets:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_repl_offset:0</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># CPU</span></span><br><span class="line">used_cpu_sys:0.21</span><br><span class="line">used_cpu_user:0.17</span><br><span class="line">used_cpu_sys_children:0.00</span><br><span class="line">used_cpu_user_children:0.00</span><br><span class="line"></span><br><span class="line"><span class="comment"># Cluster</span></span><br><span class="line">cluster_enabled:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Keyspace</span></span><br><span class="line">db0:keys=2,expires=0,avg_ttl=0</span><br></pre></td></tr></table></figure><h3 id="SHUTDOWN"><a href="#SHUTDOWN" class="headerlink" title="SHUTDOWN"></a>SHUTDOWN</h3><h4 id="SHUTDOWN-SAVE-NOSAVE"><a href="#SHUTDOWN-SAVE-NOSAVE" class="headerlink" title="SHUTDOWN [SAVE|NOSAVE]"></a>SHUTDOWN [SAVE|NOSAVE]</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度： O(N)，其中 N 为关机时需要保存的数据库键数量。
</code></pre><p>SHUTDOWN 命令执行以下操作：</p><h4 id="停止所有客户端"><a href="#停止所有客户端" class="headerlink" title="停止所有客户端"></a>停止所有客户端</h4><ul><li>如果有至少一个保存点在等待，执行 SAVE 命令</li><li>如果 AOF 选项被打开，更新 AOF 文件</li><li>关闭 redis 服务器(server)</li><li>如果持久化被打开的话， SHUTDOWN 命令会保证服务器正常关闭而不丢失任何数据。</li></ul><p>另一方面，假如只是单纯地执行 SAVE 命令，然后再执行 QUIT 命令，则没有这一保证 —— 因为在执行 SAVE 之后、执行 QUIT 之前的这段时间中间，其他客户端可能正在和服务器进行通讯，这时如果执行 QUIT 就会造成数据丢失。</p><h4 id="SAVE-和-NOSAVE-修饰符"><a href="#SAVE-和-NOSAVE-修饰符" class="headerlink" title="SAVE 和 NOSAVE 修饰符"></a>SAVE 和 NOSAVE 修饰符</h4><p>通过使用可选的修饰符，可以修改 SHUTDOWN 命令的表现。比如说：</p><ul><li>执行 SHUTDOWN SAVE 会强制让数据库执行保存操作，即使没有设定(configure)保存点</li><li>执行 SHUTDOWN NOSAVE 会阻止数据库执行保存操作，即使已经设定有一个或多个保存点(你可以将这一用法看作是强制停止服务器的一个假想的 ABORT 命令)<h4 id="返回值-139"><a href="#返回值-139" class="headerlink" title="返回值"></a>返回值</h4>执行失败时返回错误。 执行成功时不返回任何信息，服务器和客户端的连接断开，客户端自动退出。</li></ul><h4 id="代码示例-134"><a href="#代码示例-134" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; PING</span><br><span class="line">PONG</span><br><span class="line"></span><br><span class="line">redis&gt; SHUTDOWN</span><br><span class="line"></span><br><span class="line">$</span><br><span class="line">$ redis</span><br><span class="line">Could not connect to Redis at: Connection refused</span><br><span class="line">not connected&gt;</span><br></pre></td></tr></table></figure><h3 id="TIME"><a href="#TIME" class="headerlink" title="TIME"></a>TIME</h3><h4 id="TIME-1"><a href="#TIME-1" class="headerlink" title="TIME"></a>TIME</h4><pre><code>可用版本： &gt;= 2.6.0
时间复杂度： O(1)
</code></pre><p>返回当前服务器时间。</p><h4 id="返回值-140"><a href="#返回值-140" class="headerlink" title="返回值"></a>返回值</h4><p>一个包含两个字符串的列表： 第一个字符串是当前时间(以 UNIX 时间戳格式表示)，而第二个字符串是当前这一秒钟已经逝去的微秒数。</p><h4 id="代码示例-135"><a href="#代码示例-135" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; TIME</span><br><span class="line">1) <span class="string">"1332395997"</span></span><br><span class="line">2) <span class="string">"952581"</span></span><br><span class="line"></span><br><span class="line">redis&gt; TIME</span><br><span class="line">1) <span class="string">"1332395997"</span></span><br><span class="line">2) <span class="string">"953148"</span></span><br></pre></td></tr></table></figure><h3 id="CLIENT"><a href="#CLIENT" class="headerlink" title="CLIENT"></a>CLIENT</h3><h4 id="CLIENT-GETNAME"><a href="#CLIENT-GETNAME" class="headerlink" title="CLIENT GETNAME"></a>CLIENT GETNAME</h4><pre><code>可用版本： &gt;= 2.6.9
时间复杂度： O(1)
</code></pre><p>返回 CLIENT SETNAME 命令为连接设置的名字。</p><p>因为新创建的连接默认是没有名字的， 对于没有名字的连接， CLIENT GETNAME 返回空白回复。</p><h5 id="返回值-141"><a href="#返回值-141" class="headerlink" title="返回值"></a>返回值</h5><p>如果连接没有设置名字，那么返回空白回复； 如果有设置名字，那么返回名字。</p><h5 id="代码示例-136"><a href="#代码示例-136" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新连接默认没有名字</span></span><br><span class="line">redis 127.0.0.1:6379&gt; CLIENT GETNAME</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置名字</span></span><br><span class="line">redis 127.0.0.1:6379&gt; CLIENT SETNAME hello-world-connection</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回名字</span></span><br><span class="line">redis 127.0.0.1:6379&gt; CLIENT GETNAME</span><br><span class="line"><span class="string">"hello-world-connection"</span></span><br></pre></td></tr></table></figure><h4 id="CLIENT-KILL-ip-port"><a href="#CLIENT-KILL-ip-port" class="headerlink" title="CLIENT KILL ip:port"></a>CLIENT KILL ip:port</h4><pre><code>可用版本： &gt;= 2.4.0
时间复杂度： O(N) ， N 为已连接的客户端数量。
</code></pre><p>关闭地址为 ip:port 的客户端。</p><p>ip:port 应该和 CLIENT LIST 命令输出的其中一行匹配。</p><p>因为 Redis 使用单线程设计，所以当 Redis 正在执行命令的时候，不会有客户端被断开连接。</p><p>如果要被断开连接的客户端正在执行命令，那么当这个命令执行之后，在发送下一个命令的时候，它就会收到一个网络错误，告知它自身的连接已被关闭。</p><h5 id="返回值-142"><a href="#返回值-142" class="headerlink" title="返回值"></a>返回值</h5><p>当指定的客户端存在，且被成功关闭时，返回 OK 。</p><h5 id="代码示例-137"><a href="#代码示例-137" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有已连接客户端</span></span><br><span class="line">redis 127.0.0.1:6379&gt; CLIENT LIST</span><br><span class="line">addr=127.0.0.1:43501 fd=5 age=10 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=32768 obl=0 oll=0 omem=0 events=r cmd=client</span><br><span class="line"></span><br><span class="line"><span class="comment"># 杀死当前客户端的连接</span></span><br><span class="line">redis 127.0.0.1:6379&gt; CLIENT KILL 127.0.0.1:43501</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 之前的连接已经被关闭，CLI 客户端又重新建立了连接</span></span><br><span class="line"><span class="comment"># 之前的端口是 43501 ，现在是 43504</span></span><br><span class="line">redis 127.0.0.1:6379&gt; CLIENT LIST</span><br><span class="line">addr=127.0.0.1:43504 fd=5 age=0 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=32768 obl=0 oll=0 omem=0 events=r cmd=client</span><br></pre></td></tr></table></figure><h4 id="CLIENT-LIST"><a href="#CLIENT-LIST" class="headerlink" title="CLIENT LIST"></a>CLIENT LIST</h4><pre><code>可用版本： &gt;= 2.4.0
时间复杂度： O(N) ， N 为连接到服务器的客户端数量。
</code></pre><p>以人类可读的格式，返回所有连接到服务器的客户端信息和统计数据。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; CLIENT LIST</span><br><span class="line">addr=127.0.0.1:43143 fd=6 age=183 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=32768 obl=0 oll=0 omem=0 events=r cmd=client</span><br><span class="line">addr=127.0.0.1:43163 fd=5 age=35 idle=15 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=ping</span><br><span class="line">addr=127.0.0.1:43167 fd=7 age=24 idle=6 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=get</span><br></pre></td></tr></table></figure><p></p><h5 id="返回值-143"><a href="#返回值-143" class="headerlink" title="返回值"></a>返回值</h5><p>命令返回多行字符串，这些字符串按以下形式被格式化：</p><p>每个已连接客户端对应一行（以 LF 分割）</p><p>每行字符串由一系列 属性=值 形式的域组成，每个域之间以空格分开</p><p>以下是域的含义：</p><ul><li>addr ： 客户端的地址和端口</li><li>fd ： 套接字所使用的文件描述符</li><li>age ： 以秒计算的已连接时长</li><li>idle ： 以秒计算的空闲时长</li><li>flags ： 客户端 flag （见下文）</li><li>db ： 该客户端正在使用的数据库 ID</li><li>sub ： 已订阅频道的数量</li><li>psub ： 已订阅模式的数量</li><li>multi ： 在事务中被执行的命令数量</li><li>qbuf ： 查询缓冲区的长度（字节为单位， 0 表示没有分配查询缓冲区）</li><li>qbuf-free ： 查询缓冲区剩余空间的长度（字节为单位， 0 表示没有剩余空间）</li><li>obl ： 输出缓冲区的长度（字节为单位， 0 表示没有分配输出缓冲区）</li><li>oll ： 输出列表包含的对象数量（当输出缓冲区没有剩余空间时，命令回复会以字符串对象的形式被入队到这个队列里）</li><li>omem ： 输出缓冲区和输出列表占用的内存总量</li><li>events ： 文件描述符事件（见下文）</li><li>cmd ： 最近一次执行的命令</li></ul><p>客户端 flag 可以由以下部分组成：</p><ul><li>O ： 客户端是 MONITOR 模式下的附属节点（slave）</li><li>S ： 客户端是一般模式下（normal）的附属节点</li><li>M ： 客户端是主节点（master）</li><li>x ： 客户端正在执行事务</li><li>b ： 客户端正在等待阻塞事件</li><li>i ： 客户端正在等待 VM I/O 操作（已废弃）</li><li>d ： 一个受监视（watched）的键已被修改， EXEC 命令将失败</li><li>c : 在将回复完整地写出之后，关闭链接</li><li>u : 客户端未被阻塞（unblocked）</li><li>A : 尽可能快地关闭连接</li><li>N : 未设置任何 flag</li></ul><p>文件描述符事件可以是：</p><ul><li>r : 客户端套接字（在事件 loop 中）是可读的（readable）</li><li>w : 客户端套接字（在事件 loop 中）是可写的（writeable）<h5 id="Note-9"><a href="#Note-9" class="headerlink" title="Note"></a>Note</h5></li></ul><p>为了 debug 的需要，经常会对域进行添加和删除，一个安全的 Redis 客户端应该可以对 CLIENT LIST 的输出进行相应的处理（parse），比如忽略不存在的域，跳过未知域，诸如此类。</p><h4 id="CLIENT-SETNAME-connection-name"><a href="#CLIENT-SETNAME-connection-name" class="headerlink" title="CLIENT SETNAME connection-name"></a>CLIENT SETNAME connection-name</h4><pre><code>可用版本： &gt;= 2.6.9
时间复杂度： O(1)
</code></pre><p>为当前连接分配一个名字。</p><p>这个名字会显示在 CLIENT LIST 命令的结果中， 用于识别当前正在与服务器进行连接的客户端。</p><p>举个例子， 在使用 Redis 构建队列（queue）时， 可以根据连接负责的任务（role）， 为信息生产者（producer）和信息消费者（consumer）分别设置不同的名字。</p><p>名字使用 Redis 的字符串类型来保存， 最大可以占用 512 MB 。 另外， 为了避免和 CLIENT LIST 命令的输出格式发生冲突， 名字里不允许使用空格。</p><p>要移除一个连接的名字， 可以将连接的名字设为空字符串 “” 。</p><p>使用 CLIENT GETNAME 命令可以取出连接的名字。</p><p>新创建的连接默认是没有名字的。</p><h5 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h5><p>在 Redis 应用程序发生连接泄漏时，为连接设置名字是一种很好的 debug 手段。</p><h5 id="返回值-144"><a href="#返回值-144" class="headerlink" title="返回值"></a>返回值</h5><p>设置成功时返回 OK 。</p><h5 id="代码示例-138"><a href="#代码示例-138" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新连接默认没有名字</span></span><br><span class="line">redis 127.0.0.1:6379&gt; CLIENT GETNAME</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置名字</span></span><br><span class="line">redis 127.0.0.1:6379&gt; CLIENT SETNAME hello-world-connection</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回名字</span></span><br><span class="line">redis 127.0.0.1:6379&gt; CLIENT GETNAME</span><br><span class="line"><span class="string">"hello-world-connection"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在客户端列表中查看</span></span><br><span class="line">redis 127.0.0.1:6379&gt; CLIENT LIST</span><br><span class="line">addr=127.0.0.1:36851</span><br><span class="line">fd=5</span><br><span class="line">name=hello-world-connection     <span class="comment"># &lt;- 名字</span></span><br><span class="line">age=51</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除名字</span></span><br><span class="line">redis 127.0.0.1:6379&gt; CLIENT SETNAME        <span class="comment"># 只用空格是不行的！</span></span><br><span class="line">(error) ERR Syntax error, try CLIENT (LIST | KILL ip:port)</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; CLIENT SETNAME <span class="string">""</span>     <span class="comment"># 必须双引号显示包围</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; CLIENT GETNAME        <span class="comment"># 清除完毕</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h2 id="配置选项"><a href="#配置选项" class="headerlink" title="配置选项"></a>配置选项</h2><h3 id="CONFIG-SET"><a href="#CONFIG-SET" class="headerlink" title="CONFIG SET"></a>CONFIG SET</h3><h4 id="CONFIG-SET-parameter-value"><a href="#CONFIG-SET-parameter-value" class="headerlink" title="CONFIG SET parameter value"></a>CONFIG SET parameter value</h4><pre><code>可用版本： &gt;= 2.0.0
时间复杂度：O(1)
</code></pre><p>CONFIG SET 命令可以动态地调整 Redis 服务器的配置(configuration)而无须重启。</p><p>你可以使用它修改配置参数，或者改变 Redis 的持久化(Persistence)方式。</p><p>CONFIG SET 可以修改的配置参数可以使用命令 CONFIG GET * 来列出，所有被 CONFIG SET 修改的配置参数都会立即生效。</p><p>关于 CONFIG SET 命令的更多消息，请参见命令 CONFIG GET 的说明。</p><p>关于如何使用 CONFIG SET 命令修改 Redis 持久化方式，请参见 Redis Persistence 。</p><h4 id="返回值-145"><a href="#返回值-145" class="headerlink" title="返回值"></a>返回值</h4><p>当设置成功时返回 OK ，否则返回一个错误。</p><h4 id="代码示例-139"><a href="#代码示例-139" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; CONFIG GET slowlog-max-len</span><br><span class="line">1) <span class="string">"slowlog-max-len"</span></span><br><span class="line">2) <span class="string">"1024"</span></span><br><span class="line"></span><br><span class="line">redis&gt; CONFIG SET slowlog-max-len 10086</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; CONFIG GET slowlog-max-len</span><br><span class="line">1) <span class="string">"slowlog-max-len"</span></span><br><span class="line">2) <span class="string">"10086"</span></span><br></pre></td></tr></table></figure><h3 id="CONFIG-GET"><a href="#CONFIG-GET" class="headerlink" title="CONFIG GET"></a>CONFIG GET</h3><h4 id="CONFIG-GET-parameter"><a href="#CONFIG-GET-parameter" class="headerlink" title="CONFIG GET parameter"></a>CONFIG GET parameter</h4><pre><code>可用版本： &gt;= 2.0.0
时间复杂度： O(N)，其中 N 为命令返回的配置选项数量。
</code></pre><p>CONFIG GET 命令用于取得运行中的 Redis 服务器的配置参数(configuration parameters)，在 Redis 2.4 版本中， 有部分参数没有办法用 CONFIG GET 访问，但是在最新的 Redis 2.6 版本中，所有配置参数都已经可以用 CONFIG GET 访问了。</p><p>CONFIG GET 接受单个参数 parameter 作为搜索关键字，查找所有匹配的配置参数，其中参数和值以“键-值对”(key-value pairs)的方式排列。</p><p>比如执行 CONFIG GET s* 命令，服务器就会返回所有以 s 开头的配置参数及参数的值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; CONFIG GET s*</span><br><span class="line">1) <span class="string">"save"</span>                       <span class="comment"># 参数名：save</span></span><br><span class="line">2) <span class="string">"900 1 300 10 60 10000"</span>      <span class="comment"># save 参数的值</span></span><br><span class="line">3) <span class="string">"slave-serve-stale-data"</span>     <span class="comment"># 参数名： slave-serve-stale-data</span></span><br><span class="line">4) <span class="string">"yes"</span>                        <span class="comment"># slave-serve-stale-data 参数的值</span></span><br><span class="line">5) <span class="string">"set-max-intset-entries"</span>     <span class="comment"># ...</span></span><br><span class="line">6) <span class="string">"512"</span></span><br><span class="line">7) <span class="string">"slowlog-log-slower-than"</span></span><br><span class="line">8) <span class="string">"1000"</span></span><br><span class="line">9) <span class="string">"slowlog-max-len"</span></span><br><span class="line">10) <span class="string">"1000"</span></span><br></pre></td></tr></table></figure><p>如果你只是寻找特定的某个参数的话，你当然也可以直接指定参数的名字：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; CONFIG GET slowlog-max-len</span><br><span class="line">1) <span class="string">"slowlog-max-len"</span></span><br><span class="line">2) <span class="string">"1000"</span></span><br></pre></td></tr></table></figure><p>使用命令 CONFIG GET * ，可以列出 CONFIG GET 命令支持的所有参数：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; CONFIG GET *</span><br><span class="line">1) <span class="string">"dir"</span></span><br><span class="line">2) <span class="string">"/var/lib/redis"</span></span><br><span class="line">3) <span class="string">"dbfilename"</span></span><br><span class="line">4) <span class="string">"dump.rdb"</span></span><br><span class="line">5) <span class="string">"requirepass"</span></span><br><span class="line">6) (nil)</span><br><span class="line">7) <span class="string">"masterauth"</span></span><br><span class="line">8) (nil)</span><br><span class="line">9) <span class="string">"maxmemory"</span></span><br><span class="line">10) <span class="string">"0"</span></span><br><span class="line">11) <span class="string">"maxmemory-policy"</span></span><br><span class="line">12) <span class="string">"volatile-lru"</span></span><br><span class="line">13) <span class="string">"maxmemory-samples"</span></span><br><span class="line">14) <span class="string">"3"</span></span><br><span class="line">15) <span class="string">"timeout"</span></span><br><span class="line">16) <span class="string">"0"</span></span><br><span class="line">17) <span class="string">"appendonly"</span></span><br><span class="line">18) <span class="string">"no"</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line">49) <span class="string">"loglevel"</span></span><br><span class="line">50) <span class="string">"verbose"</span></span><br></pre></td></tr></table></figure><p></p><p>所有被 CONFIG SET 所支持的配置参数都可以在配置文件 redis.conf 中找到，不过 CONFIG GET 和 CONFIG SET 使用的格式和 redis.conf 文件所使用的格式有以下两点不同：</p><p>10kb 、 2gb 这些在配置文件中所使用的储存单位缩写，不可以用在 CONFIG 命令中， CONFIG SET 的值只能通过数字值显式地设定。</p><p>像 CONFIG SET xxx 1k 这样的命令是错误的，正确的格式是 CONFIG SET xxx 1000 。<br>save 选项在 redis.conf 中是用多行文字储存的，但在 CONFIG GET 命令中，它只打印一行文字。</p><p>以下是 save 选项在 redis.conf 文件中的表示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure><p></p><p>但是 CONFIG GET 命令的输出只有一行：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; CONFIG GET save</span><br><span class="line">1) <span class="string">"save"</span></span><br><span class="line">2) <span class="string">"900 1 300 10 60 10000"</span></span><br></pre></td></tr></table></figure><p></p><p>上面 save 参数的三个值表示：在 900 秒内最少有 1 个 key 被改动，或者 300 秒内最少有 10 个 key 被改动，又或者 60 秒内最少有 1000 个 key 被改动，以上三个条件随便满足一个，就触发一次保存操作。</p><h4 id="返回值-146"><a href="#返回值-146" class="headerlink" title="返回值"></a>返回值</h4><p>给定配置参数的值。</p><h3 id="CONFIG-RESETSTAT"><a href="#CONFIG-RESETSTAT" class="headerlink" title="CONFIG RESETSTAT"></a>CONFIG RESETSTAT</h3><h4 id="CONFIG-RESETSTAT-1"><a href="#CONFIG-RESETSTAT-1" class="headerlink" title="CONFIG RESETSTAT"></a>CONFIG RESETSTAT</h4><pre><code>可用版本： &gt;= 2.0.0
时间复杂度： O(1)
</code></pre><p>重置 INFO 命令中的某些统计数据，包括：</p><ul><li>Keyspace hits (键空间命中次数)</li><li>Keyspace misses (键空间不命中次数)</li><li>Number of commands processed (执行命令的次数)</li><li>Number of connections received (连接服务器的次数)</li><li>Number of expired keys (过期key的数量)</li><li>Number of rejected connections (被拒绝的连接数量)</li><li>Latest fork(2) time(最后执行 fork(2) 的时间)</li><li>The aof_delayed_fsync counter(aof_delayed_fsync 计数器的值)<h4 id="返回值-147"><a href="#返回值-147" class="headerlink" title="返回值"></a>返回值</h4>总是返回 OK 。</li></ul><h4 id="代码示例-140"><a href="#代码示例-140" class="headerlink" title="代码示例"></a>代码示例</h4><p>重置前<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; INFO</span><br><span class="line"><span class="comment"># Server</span></span><br><span class="line">redis_version:2.5.3</span><br><span class="line">redis_git_sha1:d0407c2d</span><br><span class="line">redis_git_dirty:0</span><br><span class="line">arch_bits:32</span><br><span class="line">multiplexing_api:epoll</span><br><span class="line">gcc_version:4.6.3</span><br><span class="line">process_id:11095</span><br><span class="line">run_id:ef1f6b6c7392e52d6001eaf777acbe547d1192e2</span><br><span class="line">tcp_port:6379</span><br><span class="line">uptime_in_seconds:6</span><br><span class="line">uptime_in_days:0</span><br><span class="line">lru_clock:1205426</span><br><span class="line"></span><br><span class="line"><span class="comment"># Clients</span></span><br><span class="line">connected_clients:1</span><br><span class="line">client_longest_output_list:0</span><br><span class="line">client_biggest_input_buf:0</span><br><span class="line">blocked_clients:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Memory</span></span><br><span class="line">used_memory:331076</span><br><span class="line">used_memory_human:323.32K</span><br><span class="line">used_memory_rss:1568768</span><br><span class="line">used_memory_peak:293424</span><br><span class="line">used_memory_peak_human:286.55K</span><br><span class="line">used_memory_lua:16384</span><br><span class="line">mem_fragmentation_ratio:4.74</span><br><span class="line">mem_allocator:jemalloc-2.2.5</span><br><span class="line"></span><br><span class="line"><span class="comment"># Persistence</span></span><br><span class="line">loading:0</span><br><span class="line">aof_enabled:0</span><br><span class="line">changes_since_last_save:0</span><br><span class="line">bgsave_in_progress:0</span><br><span class="line">last_save_time:1333260015</span><br><span class="line">last_bgsave_status:ok</span><br><span class="line">bgrewriteaof_in_progress:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Stats</span></span><br><span class="line">total_connections_received:1</span><br><span class="line">total_commands_processed:0</span><br><span class="line">instantaneous_ops_per_sec:0</span><br><span class="line">rejected_connections:0</span><br><span class="line">expired_keys:0</span><br><span class="line">evicted_keys:0</span><br><span class="line">keyspace_hits:0</span><br><span class="line">keyspace_misses:0</span><br><span class="line">pubsub_channels:0</span><br><span class="line">pubsub_patterns:0</span><br><span class="line">latest_fork_usec:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># CPU</span></span><br><span class="line">used_cpu_sys:0.01</span><br><span class="line">used_cpu_user:0.00</span><br><span class="line">used_cpu_sys_children:0.00</span><br><span class="line">used_cpu_user_children:0.00</span><br><span class="line"></span><br><span class="line"><span class="comment"># Keyspace</span></span><br><span class="line">db0:keys=20,expires=0</span><br></pre></td></tr></table></figure><p></p><p>重置<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; CONFIG RESETSTAT</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p></p><p>重置后<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; INFO</span><br><span class="line"><span class="comment"># Server</span></span><br><span class="line">redis_version:2.5.3</span><br><span class="line">redis_git_sha1:d0407c2d</span><br><span class="line">redis_git_dirty:0</span><br><span class="line">arch_bits:32</span><br><span class="line">multiplexing_api:epoll</span><br><span class="line">gcc_version:4.6.3</span><br><span class="line">process_id:11095</span><br><span class="line">run_id:ef1f6b6c7392e52d6001eaf777acbe547d1192e2</span><br><span class="line">tcp_port:6379</span><br><span class="line">uptime_in_seconds:134</span><br><span class="line">uptime_in_days:0</span><br><span class="line">lru_clock:1205438</span><br><span class="line"></span><br><span class="line"><span class="comment"># Clients</span></span><br><span class="line">connected_clients:1</span><br><span class="line">client_longest_output_list:0</span><br><span class="line">client_biggest_input_buf:0</span><br><span class="line">blocked_clients:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Memory</span></span><br><span class="line">used_memory:331076</span><br><span class="line">used_memory_human:323.32K</span><br><span class="line">used_memory_rss:1568768</span><br><span class="line">used_memory_peak:330280</span><br><span class="line">used_memory_peak_human:322.54K</span><br><span class="line">used_memory_lua:16384</span><br><span class="line">mem_fragmentation_ratio:4.74</span><br><span class="line">mem_allocator:jemalloc-2.2.5</span><br><span class="line"></span><br><span class="line"><span class="comment"># Persistence</span></span><br><span class="line">loading:0</span><br><span class="line">aof_enabled:0</span><br><span class="line">changes_since_last_save:0</span><br><span class="line">bgsave_in_progress:0</span><br><span class="line">last_save_time:1333260015</span><br><span class="line">last_bgsave_status:ok</span><br><span class="line">bgrewriteaof_in_progress:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Stats</span></span><br><span class="line">total_connections_received:0</span><br><span class="line">total_commands_processed:1</span><br><span class="line">instantaneous_ops_per_sec:0</span><br><span class="line">rejected_connections:0</span><br><span class="line">expired_keys:0</span><br><span class="line">evicted_keys:0</span><br><span class="line">keyspace_hits:0</span><br><span class="line">keyspace_misses:0</span><br><span class="line">pubsub_channels:0</span><br><span class="line">pubsub_patterns:0</span><br><span class="line">latest_fork_usec:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># CPU</span></span><br><span class="line">used_cpu_sys:0.05</span><br><span class="line">used_cpu_user:0.02</span><br><span class="line">used_cpu_sys_children:0.00</span><br><span class="line">used_cpu_user_children:0.00</span><br><span class="line"></span><br><span class="line"><span class="comment"># Keyspace</span></span><br><span class="line">db0:keys=20,expires=0</span><br></pre></td></tr></table></figure><p></p><h3 id="CONFIG-REWRITE"><a href="#CONFIG-REWRITE" class="headerlink" title="CONFIG REWRITE"></a>CONFIG REWRITE</h3><h4 id="CONFIG-REWRITE-1"><a href="#CONFIG-REWRITE-1" class="headerlink" title="CONFIG REWRITE"></a>CONFIG REWRITE</h4><pre><code>可用版本： &gt;= 2.8.0
时间复杂度：O(N)，其中 N 为被重写的配置选项数量。
</code></pre><p>CONFIG REWRITE 命令对启动 Redis 服务器时所指定的 redis.conf 文件进行改写： 因为 CONFIG_SET 命令可以对服务器的当前配置进行修改， 而修改后的配置可能和 redis.conf 文件中所描述的配置不一样， CONFIG REWRITE 的作用就是通过尽可能少的修改， 将服务器当前所使用的配置记录到 redis.conf 文件中。</p><p>重写会以非常保守的方式进行：</p><ul><li>原有 redis.conf 文件的整体结构和注释会被尽可能地保留。</li><li>如果一个选项已经存在于原有 redis.conf 文件中 ， 那么对该选项的重写会在选项原本所在的位置（行号）上进行。</li><li>如果一个选项不存在于原有 redis.conf 文件中， 并且该选项被设置为默认值， 那么重写程序不会将这个选项添加到重写后的 redis.conf 文件中。</li><li>如果一个选项不存在于原有 redis.conf 文件中， 并且该选项被设置为非默认值， 那么这个选项将被添加到重写后的 redis.conf 文件的末尾。</li><li>未使用的行会被留白。 比如说， 如果你在原有 redis.conf 文件上设置了数个关于 save 选项的参数， 但现在你将这些 save 参数的一个或全部都关闭了， 那么这些不再使用的参数原本所在的行就会变成空白的。</li></ul><p>即使启动服务器时所指定的 redis.conf 文件已经不再存在， CONFIG REWRITE 命令也可以重新构建并生成出一个新的 redis.conf 文件。</p><p>另一方面， 如果启动服务器时没有载入 redis.conf 文件， 那么执行 CONFIG REWRITE 命令将引发一个错误。</p><h4 id="原子性重写"><a href="#原子性重写" class="headerlink" title="原子性重写"></a>原子性重写</h4><p>对 redis.conf 文件的重写是原子性的， 并且是一致的： 如果重写出错或重写期间服务器崩溃， 那么重写失败， 原有 redis.conf 文件不会被修改。 如果重写成功， 那么 redis.conf 文件为重写后的新文件。</p><h4 id="返回值-148"><a href="#返回值-148" class="headerlink" title="返回值"></a>返回值</h4><p>一个状态值：如果配置重写成功则返回 OK ，失败则返回一个错误。</p><h4 id="代码示例-141"><a href="#代码示例-141" class="headerlink" title="代码示例"></a>代码示例</h4><p>以下是执行 CONFIG REWRITE 前， 被载入到 Redis 服务器的 redis.conf 文件中关于 appendonly 选项的设置：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ... 其他选项</span></span><br><span class="line">appendonly no</span><br><span class="line"><span class="comment"># ... 其他选项</span></span><br><span class="line">在执行以下命令之后：</span><br><span class="line"></span><br><span class="line">redis&gt; CONFIG GET appendonly           <span class="comment"># appendonly 处于关闭状态</span></span><br><span class="line">1) <span class="string">"appendonly"</span></span><br><span class="line">2) <span class="string">"no"</span></span><br><span class="line"></span><br><span class="line">redis&gt; CONFIG SET appendonly yes       <span class="comment"># 打开 appendonly</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; CONFIG GET appendonly</span><br><span class="line">1) <span class="string">"appendonly"</span></span><br><span class="line">2) <span class="string">"yes"</span></span><br><span class="line"></span><br><span class="line">redis&gt; CONFIG REWRITE                  <span class="comment"># 将 appendonly 的修改写入到 redis.conf 中</span></span><br><span class="line">OK</span><br><span class="line">重写后的 redis.conf 文件中的 appendonly 选项将被改写：</span><br><span class="line"></span><br><span class="line"><span class="comment"># ... 其他选项</span></span><br><span class="line">appendonly yes</span><br><span class="line"><span class="comment"># ... 其他选项</span></span><br></pre></td></tr></table></figure><p></p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="PING"><a href="#PING" class="headerlink" title="PING"></a>PING</h3><h4 id="PING-1"><a href="#PING-1" class="headerlink" title="PING"></a>PING</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度： O(1)
</code></pre><p>使用客户端向 Redis 服务器发送一个 PING ，如果服务器运作正常的话，会返回一个 PONG 。</p><p>通常用于测试与服务器的连接是否仍然生效，或者用于测量延迟值。</p><h4 id="返回值-149"><a href="#返回值-149" class="headerlink" title="返回值"></a>返回值</h4><p>如果连接正常就返回一个 PONG ，否则返回一个连接错误。</p><h4 id="代码示例-142"><a href="#代码示例-142" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 客户端和服务器连接正常</span></span><br><span class="line">redis&gt; PING</span><br><span class="line">PONG</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端和服务器连接不正常(网络不正常或服务器未能正常运行)</span></span><br><span class="line">redis 127.0.0.1:6379&gt; PING</span><br><span class="line">Could not connect to Redis at 127.0.0.1:6379: Connection refused</span><br></pre></td></tr></table></figure><h3 id="ECHO"><a href="#ECHO" class="headerlink" title="ECHO"></a>ECHO</h3><h4 id="ECHO-message"><a href="#ECHO-message" class="headerlink" title="ECHO message"></a>ECHO message</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度： O(1)
</code></pre><p>打印一个特定的信息 message ，测试时使用。</p><h4 id="返回值-150"><a href="#返回值-150" class="headerlink" title="返回值"></a>返回值</h4><p>message 自身。</p><h4 id="代码示例-143"><a href="#代码示例-143" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ECHO <span class="string">"Hello Moto"</span></span><br><span class="line"><span class="string">"Hello Moto"</span></span><br><span class="line"></span><br><span class="line">redis&gt; ECHO <span class="string">"Goodbye Moto"</span></span><br><span class="line"><span class="string">"Goodbye Moto"</span></span><br></pre></td></tr></table></figure><h3 id="OBJECT"><a href="#OBJECT" class="headerlink" title="OBJECT"></a>OBJECT</h3><h4 id="OBJECT-subcommand-arguments-arguments"><a href="#OBJECT-subcommand-arguments-arguments" class="headerlink" title="OBJECT subcommand [arguments [arguments]]"></a>OBJECT subcommand [arguments [arguments]]</h4><pre><code>可用版本： &gt;= 2.2.3
时间复杂度： O(1)
</code></pre><p>OBJECT 命令允许从内部察看给定 key 的 Redis 对象， 它通常用在除错(debugging)或者了解为了节省空间而对 key 使用特殊编码的情况。 当将Redis用作缓存程序时，你也可以通过 OBJECT 命令中的信息，决定 key 的驱逐策略(eviction policies)。</p><p>OBJECT 命令有多个子命令：</p><ul><li>OBJECT REFCOUNT \&lt;key> 返回给定 key 引用所储存的值的次数。此命令主要用于除错。</li><li>OBJECT ENCODING \&lt;key> 返回给定 key 锁储存的值所使用的内部表示(representation)。</li><li><p>OBJECT IDLETIME \&lt;key> 返回给定 key 自储存以来的空闲时间(idle， 没有被读取也没有被写入)，以秒为单位。<br>对象可以以多种方式编码：</p></li><li><p>字符串可以被编码为 raw (一般字符串)或 int (为了节约内存，Redis 会将字符串表示的 64 位有符号整数编码为整数来进行储存）。</p></li><li>列表可以被编码为 ziplist 或 linkedlist 。 ziplist 是为节约大小较小的列表空间而作的特殊表示。</li><li>集合可以被编码为 intset 或者 hashtable 。 intset 是只储存数字的小集合的特殊表示。</li><li>哈希表可以编码为 zipmap 或者 hashtable 。 zipmap 是小哈希表的特殊表示。</li><li>有序集合可以被编码为 ziplist 或者 skiplist 格式。 ziplist 用于表示小的有序集合，而 skiplist 则用于表示任何大小的有序集合。</li></ul><p>假如你做了什么让 Redis 没办法再使用节省空间的编码时(比如将一个只有 1 个元素的集合扩展为一个有 100 万个元素的集合)，特殊编码类型(specially encoded types)会自动转换成通用类型(general type)。</p><h4 id="返回值-151"><a href="#返回值-151" class="headerlink" title="返回值"></a>返回值</h4><p>REFCOUNT 和 IDLETIME 返回数字。 ENCODING 返回相应的编码类型。</p><h4 id="代码示例-144"><a href="#代码示例-144" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET game <span class="string">"COD"</span>           <span class="comment"># 设置一个字符串</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT REFCOUNT game     <span class="comment"># 只有一个引用</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT IDLETIME game     <span class="comment"># 等待一阵。。。然后查看空闲时间</span></span><br><span class="line">(<span class="built_in">integer</span>) 90</span><br><span class="line"></span><br><span class="line">redis&gt; GET game                 <span class="comment"># 提取game， 让它处于活跃(active)状态</span></span><br><span class="line"><span class="string">"COD"</span></span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT IDLETIME game     <span class="comment"># 不再处于空闲状态</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING game     <span class="comment"># 字符串的编码方式</span></span><br><span class="line"><span class="string">"raw"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SET big-number 23102930128301091820391092019203810281029831092  <span class="comment"># 非常长的数字会被编码为字符串</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING big-number</span><br><span class="line"><span class="string">"raw"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SET small-number 12345  <span class="comment"># 而短的数字则会被编码为整数</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING small-number</span><br><span class="line"><span class="string">"int"</span></span><br></pre></td></tr></table></figure><h3 id="SLOWLOG"><a href="#SLOWLOG" class="headerlink" title="SLOWLOG"></a>SLOWLOG</h3><h4 id="SLOWLOG-subcommand-argument"><a href="#SLOWLOG-subcommand-argument" class="headerlink" title="SLOWLOG subcommand [argument]"></a>SLOWLOG subcommand [argument]</h4><pre><code>可用版本： &gt;= 2.2.12
时间复杂度： O(1)
</code></pre><h4 id="什么是-SLOWLOG"><a href="#什么是-SLOWLOG" class="headerlink" title="什么是 SLOWLOG"></a>什么是 SLOWLOG</h4><p>Slow log 是 Redis 用来记录查询执行时间的日志系统。</p><p>查询执行时间指的是不包括像客户端响应(talking)、发送回复等 IO 操作，而单单是执行一个查询命令所耗费的时间。</p><p>另外，slow log 保存在内存里面，读写速度非常快，因此你可以放心地使用它，不必担心因为开启 slow log 而损害 Redis 的速度。</p><h4 id="设置-SLOWLOG"><a href="#设置-SLOWLOG" class="headerlink" title="设置 SLOWLOG"></a>设置 SLOWLOG</h4><p>Slow log 的行为由两个配置参数(configuration parameter)指定，可以通过改写 redis.conf 文件或者用 CONFIG GET 和 CONFIG SET 命令对它们动态地进行修改。</p><p>第一个选项是 slowlog-log-slower-than ，它决定要对执行时间大于多少微秒(microsecond，1秒 = 1,000,000 微秒)的查询进行记录。</p><p>比如执行以下命令将让 slow log 记录所有查询时间大于等于 100 微秒的查询：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET slowlog-log-slower-than 100</span><br></pre></td></tr></table></figure><p></p><p>而以下命令记录所有查询时间大于 1000 微秒的查询：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET slowlog-log-slower-than 1000</span><br></pre></td></tr></table></figure><p></p><p>另一个选项是 slowlog-max-len ，它决定 slow log 最多能保存多少条日志， slow log 本身是一个 FIFO 队列，当队列大小超过 slowlog-max-len 时，最旧的一条日志将被删除，而最新的一条日志加入到 slow log ，以此类推。</p><p>以下命令让 slow log 最多保存 1000 条日志：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET slowlog-max-len 1000</span><br></pre></td></tr></table></figure><p></p><p>使用 CONFIG GET 命令可以查询两个选项的当前值：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; CONFIG GET slowlog-log-slower-than</span><br><span class="line">1) <span class="string">"slowlog-log-slower-than"</span></span><br><span class="line">2) <span class="string">"1000"</span></span><br><span class="line"></span><br><span class="line">redis&gt; CONFIG GET slowlog-max-len</span><br><span class="line">1) <span class="string">"slowlog-max-len"</span></span><br><span class="line">2) <span class="string">"1000"</span></span><br></pre></td></tr></table></figure><p></p><h4 id="查看-slow-log"><a href="#查看-slow-log" class="headerlink" title="查看 slow log"></a>查看 slow log</h4><p>要查看 slow log ，可以使用 SLOWLOG GET 或者 SLOWLOG GET number 命令，前者打印所有 slow log ，最大长度取决于 slowlog-max-len 选项的值，而 SLOWLOG GET number 则只打印指定数量的日志。</p><p>最新的日志会最先被打印：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为测试需要，将 slowlog-log-slower-than 设成了 10 微秒</span></span><br><span class="line"></span><br><span class="line">redis&gt; SLOWLOG GET</span><br><span class="line">1) 1) (<span class="built_in">integer</span>) 12                      <span class="comment"># 唯一性(unique)的日志标识符</span></span><br><span class="line">   2) (<span class="built_in">integer</span>) 1324097834              <span class="comment"># 被记录命令的执行时间点，以 UNIX 时间戳格式表示</span></span><br><span class="line">   3) (<span class="built_in">integer</span>) 16                      <span class="comment"># 查询执行时间，以微秒为单位</span></span><br><span class="line">   4) 1) <span class="string">"CONFIG"</span>                       <span class="comment"># 执行的命令，以数组的形式排列</span></span><br><span class="line">      2) <span class="string">"GET"</span>                          <span class="comment"># 这里完整的命令是 CONFIG GET slowlog-log-slower-than</span></span><br><span class="line">      3) <span class="string">"slowlog-log-slower-than"</span></span><br><span class="line"></span><br><span class="line">2) 1) (<span class="built_in">integer</span>) 11</span><br><span class="line">   2) (<span class="built_in">integer</span>) 1324097825</span><br><span class="line">   3) (<span class="built_in">integer</span>) 42</span><br><span class="line">   4) 1) <span class="string">"CONFIG"</span></span><br><span class="line">      2) <span class="string">"GET"</span></span><br><span class="line">      3) <span class="string">"*"</span></span><br><span class="line"></span><br><span class="line">3) 1) (<span class="built_in">integer</span>) 10</span><br><span class="line">   2) (<span class="built_in">integer</span>) 1324097820</span><br><span class="line">   3) (<span class="built_in">integer</span>) 11</span><br><span class="line">   4) 1) <span class="string">"CONFIG"</span></span><br><span class="line">      2) <span class="string">"GET"</span></span><br><span class="line">      3) <span class="string">"slowlog-log-slower-than"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p></p><p>日志的唯一 id 只有在 Redis 服务器重启的时候才会重置，这样可以避免对日志的重复处理(比如你可能会想在每次发现新的慢查询时发邮件通知你)。</p><h4 id="查看当前日志的数量"><a href="#查看当前日志的数量" class="headerlink" title="查看当前日志的数量"></a>查看当前日志的数量</h4><p>使用命令 SLOWLOG LEN 可以查看当前日志的数量。</p><p>请注意这个值和 slower-max-len 的区别，它们一个是当前日志的数量，一个是允许记录的最大日志的数量。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SLOWLOG LEN</span><br><span class="line">(<span class="built_in">integer</span>) 14</span><br></pre></td></tr></table></figure><p></p><h4 id="清空日志"><a href="#清空日志" class="headerlink" title="清空日志"></a>清空日志</h4><p>使用命令 SLOWLOG RESET 可以清空 slow log 。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SLOWLOG LEN</span><br><span class="line">(<span class="built_in">integer</span>) 14</span><br><span class="line"></span><br><span class="line">redis&gt; SLOWLOG RESET</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SLOWLOG LEN</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><p></p><h4 id="返回值-152"><a href="#返回值-152" class="headerlink" title="返回值"></a>返回值</h4><p>取决于不同命令，返回不同的值。</p><h3 id="MONITOR"><a href="#MONITOR" class="headerlink" title="MONITOR"></a>MONITOR</h3><h4 id="MONITOR-1"><a href="#MONITOR-1" class="headerlink" title="MONITOR"></a>MONITOR</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度： O(N)
</code></pre><p>实时打印出 Redis 服务器接收到的命令，调试用。</p><h4 id="返回值-153"><a href="#返回值-153" class="headerlink" title="返回值"></a>返回值</h4><p>总是返回 OK 。</p><h4 id="代码示例-145"><a href="#代码示例-145" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MONITOR</span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 以第一个打印值为例</span></span><br><span class="line"><span class="comment"># 1378822099.421623 是时间戳</span></span><br><span class="line"><span class="comment"># [0 127.0.0.1:56604] 中的 0 是数据库号码， 127... 是 IP 地址和端口</span></span><br><span class="line"><span class="comment"># "PING" 是被执行的命令</span></span><br><span class="line">1378822099.421623 [0 127.0.0.1:56604] <span class="string">"PING"</span></span><br><span class="line">1378822105.089572 [0 127.0.0.1:56604] <span class="string">"SET"</span> <span class="string">"msg"</span> <span class="string">"hello world"</span></span><br><span class="line">1378822109.036925 [0 127.0.0.1:56604] <span class="string">"SET"</span> <span class="string">"number"</span> <span class="string">"123"</span></span><br><span class="line">1378822140.649496 [0 127.0.0.1:56604] <span class="string">"SADD"</span> <span class="string">"fruits"</span> <span class="string">"Apple"</span> <span class="string">"Banana"</span> <span class="string">"Cherry"</span></span><br><span class="line">1378822154.117160 [0 127.0.0.1:56604] <span class="string">"EXPIRE"</span> <span class="string">"msg"</span> <span class="string">"10086"</span></span><br><span class="line">1378822257.329412 [0 127.0.0.1:56604] <span class="string">"KEYS"</span> <span class="string">"*"</span></span><br><span class="line">1378822258.690131 [0 127.0.0.1:56604] <span class="string">"DBSIZE"</span></span><br></pre></td></tr></table></figure><h3 id="DEBUG-OBJECT"><a href="#DEBUG-OBJECT" class="headerlink" title="DEBUG OBJECT"></a>DEBUG OBJECT</h3><h4 id="DEBUG-OBJECT-key"><a href="#DEBUG-OBJECT-key" class="headerlink" title="DEBUG OBJECT key"></a>DEBUG OBJECT key</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度： O(1)
</code></pre><p>DEBUG OBJECT 是一个调试命令，它不应被客户端所使用。</p><p>查看 OBJECT 命令获取更多信息。</p><h4 id="返回值-154"><a href="#返回值-154" class="headerlink" title="返回值"></a>返回值</h4><p>当 key 存在时，返回有关信息。 当 key 不存在时，返回一个错误。</p><h4 id="代码示例-146"><a href="#代码示例-146" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; DEBUG OBJECT my_pc</span><br><span class="line">Value at:0xb6838d20 refcount:1 encoding:raw serializedlength:9 lru:283790 lru_seconds_idle:150</span><br><span class="line"></span><br><span class="line">redis&gt; DEBUG OBJECT your_mac</span><br><span class="line">(error) ERR no such key</span><br></pre></td></tr></table></figure><h3 id="DEBUG-SEGFAULT"><a href="#DEBUG-SEGFAULT" class="headerlink" title="DEBUG SEGFAULT"></a>DEBUG SEGFAULT</h3><h4 id="DEBUG-SEGFAULT-1"><a href="#DEBUG-SEGFAULT-1" class="headerlink" title="DEBUG SEGFAULT"></a>DEBUG SEGFAULT</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度： O(1)
</code></pre><p>执行一个不合法的内存访问从而让 Redis 崩溃，仅在开发时用于 BUG 模拟。</p><h4 id="返回值-155"><a href="#返回值-155" class="headerlink" title="返回值"></a>返回值</h4><p>无</p><h4 id="代码示例-147"><a href="#代码示例-147" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; DEBUG SEGFAULT</span><br><span class="line">Could not connect to Redis at: Connection refused</span><br><span class="line"></span><br><span class="line">not connected&gt;</span><br></pre></td></tr></table></figure><h2 id="内部命令"><a href="#内部命令" class="headerlink" title="内部命令"></a>内部命令</h2><h3 id="MIGRATE"><a href="#MIGRATE" class="headerlink" title="MIGRATE"></a>MIGRATE</h3><h4 id="MIGRATE-host-port-key-destination-db-timeout-COPY-REPLACE"><a href="#MIGRATE-host-port-key-destination-db-timeout-COPY-REPLACE" class="headerlink" title="MIGRATE host port key destination-db timeout [COPY] [REPLACE]"></a>MIGRATE host port key destination-db timeout [COPY] [REPLACE]</h4><pre><code>可用版本： &gt;= 2.6.0
时间复杂度： 这个命令在源实例上实际执行 DUMP 命令和 DEL 命令，在目标实例执行 RESTORE 命令，查看以上命令的文档可以看到详细的复杂度说明。 key 数据在两个实例之间传输的复杂度为 O(N) 。
</code></pre><p>将 key 原子性地从当前实例传送到目标实例的指定数据库上，一旦传送成功， key 保证会出现在目标实例上，而当前实例上的 key 会被删除。</p><p>这个命令是一个原子操作，它在执行的时候会阻塞进行迁移的两个实例，直到以下任意结果发生：迁移成功，迁移失败，等待超时。</p><p>命令的内部实现是这样的：它在当前实例对给定 key 执行 DUMP 命令 ，将它序列化，然后传送到目标实例，目标实例再使用 RESTORE 对数据进行反序列化，并将反序列化所得的数据添加到数据库中；当前实例就像目标实例的客户端那样，只要看到 RESTORE 命令返回 OK ，它就会调用 DEL 删除自己数据库上的 key 。</p><p>timeout 参数以毫秒为格式，指定当前实例和目标实例进行沟通的最大间隔时间。这说明操作并不一定要在 timeout 毫秒内完成，只是说数据传送的时间不能超过这个 timeout 数。</p><p>MIGRATE 命令需要在给定的时间规定内完成 IO 操作。如果在传送数据时发生 IO 错误，或者达到了超时时间，那么命令会停止执行，并返回一个特殊的错误： IOERR 。</p><p>当 IOERR 出现时，有以下两种可能：</p><ul><li>key 可能存在于两个实例</li><li>key 可能只存在于当前实例</li></ul><p>唯一不可能发生的情况就是丢失 key ，因此，如果一个客户端执行 MIGRATE 命令，并且不幸遇上 IOERR 错误，那么这个客户端唯一要做的就是检查自己数据库上的 key 是否已经被正确地删除。</p><p>如果有其他错误发生，那么 MIGRATE 保证 key 只会出现在当前实例中。（当然，目标实例的给定数据库上可能有和 key 同名的键，不过这和 MIGRATE 命令没有关系）。</p><h4 id="可选项"><a href="#可选项" class="headerlink" title="可选项"></a>可选项</h4><pre><code>COPY ：不移除源实例上的 key 。
REPLACE ：替换目标实例上已存在的 key 。
</code></pre><h4 id="返回值-156"><a href="#返回值-156" class="headerlink" title="返回值"></a>返回值</h4><p>迁移成功时返回 OK ，否则返回相应的错误。</p><h4 id="代码示例-148"><a href="#代码示例-148" class="headerlink" title="代码示例"></a>代码示例</h4><p>先启动两个 Redis 实例，一个使用默认的 6379 端口，一个使用 7777 端口。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-server &amp;</span><br><span class="line">[1] 3557</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">$ ./redis-server --port 7777 &amp;</span><br><span class="line">[2] 3560</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p></p><p>然后用客户端连上 6379 端口的实例，设置一个键，然后将它迁移到 7777 端口的实例上：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-cli</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; flushdb</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SET greeting <span class="string">"Hello from 6379 instance"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; MIGRATE 127.0.0.1 7777 greeting 0 1000</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; EXISTS greeting                           <span class="comment"># 迁移成功后 key 被删除</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><p></p><p>使用另一个客户端，查看 7777 端口上的实例：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-cli -p 7777</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:7777&gt; GET greeting</span><br><span class="line"><span class="string">"Hello from 6379 instance"</span></span><br></pre></td></tr></table></figure><p></p><h3 id="DUMP"><a href="#DUMP" class="headerlink" title="DUMP"></a>DUMP</h3><h4 id="DUMP-key"><a href="#DUMP-key" class="headerlink" title="DUMP key"></a>DUMP key</h4><pre><code>可用版本： &gt;= 2.6.0
时间复杂度：查找给定键的复杂度为 O(1) ，对键进行序列化的复杂度为 O(N*M) ，其中 N 是构成 key 的 Redis 对象的数量，而 M 则是这些对象的平均大小。如果序列化的对象是比较小的字符串，那么复杂度为 O(1) 。
</code></pre><p>序列化给定 key ，并返回被序列化的值，使用 RESTORE 命令可以将这个值反序列化为 Redis 键。</p><p>序列化生成的值有以下几个特点：</p><ul><li>它带有 64 位的校验和，用于检测错误， RESTORE 在进行反序列化之前会先检查校验和。</li><li>值的编码格式和 RDB 文件保持一致。</li><li>RDB 版本会被编码在序列化值当中，如果因为 Redis 的版本不同造成 RDB 格式不兼容，那么 Redis 会拒绝对这个值进行反序列化操作。</li></ul><p>序列化的值不包括任何生存时间信息。</p><h4 id="返回值-157"><a href="#返回值-157" class="headerlink" title="返回值"></a>返回值</h4><p>如果 key 不存在，那么返回 nil 。 否则，返回序列化之后的值。</p><h4 id="代码示例-149"><a href="#代码示例-149" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET greeting <span class="string">"hello, dumping world!"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; DUMP greeting</span><br><span class="line"><span class="string">"\x00\x15hello, dumping world!\x06\x00E\xa0Z\x82\xd8r\xc1\xde"</span></span><br><span class="line"></span><br><span class="line">redis&gt; DUMP not-exists-key</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h3 id="RESTORE"><a href="#RESTORE" class="headerlink" title="RESTORE"></a>RESTORE</h3><h4 id="RESTORE-key-ttl-serialized-value-REPLACE"><a href="#RESTORE-key-ttl-serialized-value-REPLACE" class="headerlink" title="RESTORE key ttl serialized-value [REPLACE]"></a>RESTORE key ttl serialized-value [REPLACE]</h4><pre><code>可用版本： &gt;= 2.6.0
时间复杂度： 查找给定键的复杂度为 O(1) ，对键进行反序列化的复杂度为 O(N*M) ，其中 N 是构成 key 的 Redis 对象的数量，而 M 则是这些对象的平均大小。 有序集合(sorted set)的反序列化复杂度为 O(N*M*log(N)) ，因为有序集合每次插入的复杂度为 O(log(N)) 。 如果反序列化的对象是比较小的字符串，那么复杂度为 O(1) 。
</code></pre><p>反序列化给定的序列化值，并将它和给定的 key 关联。</p><p>参数 ttl 以毫秒为单位为 key 设置生存时间；如果 ttl 为 0 ，那么不设置生存时间。</p><p>RESTORE 在执行反序列化之前会先对序列化值的 RDB 版本和数据校验和进行检查，如果 RDB 版本不相同或者数据不完整的话，那么 RESTORE 会拒绝进行反序列化，并返回一个错误。</p><p>如果键 key 已经存在， 并且给定了 REPLACE 选项， 那么使用反序列化得出的值来代替键 key 原有的值； 相反地， 如果键 key 已经存在， 但是没有给定 REPLACE 选项， 那么命令返回一个错误。</p><p>更多信息可以参考 DUMP 命令。</p><h4 id="返回值-158"><a href="#返回值-158" class="headerlink" title="返回值"></a>返回值</h4><p>如果反序列化成功那么返回 OK ，否则返回一个错误。</p><h4 id="代码示例-150"><a href="#代码示例-150" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个键，作为 DUMP 命令的输入</span></span><br><span class="line">redis&gt; SET greeting <span class="string">"hello, dumping world!"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; DUMP greeting</span><br><span class="line"><span class="string">"\x00\x15hello, dumping world!\x06\x00E\xa0Z\x82\xd8r\xc1\xde"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将序列化数据 RESTORE 到另一个键上面</span></span><br><span class="line">redis&gt; RESTORE greeting-again 0 <span class="string">"\x00\x15hello, dumping world!\x06\x00E\xa0Z\x82\xd8r\xc1\xde"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET greeting-again</span><br><span class="line"><span class="string">"hello, dumping world!"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在没有给定 REPLACE 选项的情况下，再次尝试反序列化到同一个键，失败</span></span><br><span class="line">redis&gt; RESTORE greeting-again 0 <span class="string">"\x00\x15hello, dumping world!\x06\x00E\xa0Z\x82\xd8r\xc1\xde"</span></span><br><span class="line">(error) ERR Target key name is busy.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给定 REPLACE 选项，对同一个键进行反序列化成功</span></span><br><span class="line">redis&gt; RESTORE greeting-again 0 <span class="string">"\x00\x15hello, dumping world!\x06\x00E\xa0Z\x82\xd8r\xc1\xde"</span> REPLACE</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 尝试使用无效的值进行反序列化，出错</span></span><br><span class="line">redis&gt; RESTORE fake-message 0 <span class="string">"hello moto moto blah blah"</span></span><br><span class="line">(error) ERR DUMP payload version or checksum are wrong</span><br></pre></td></tr></table></figure><h3 id="SYNC"><a href="#SYNC" class="headerlink" title="SYNC"></a>SYNC</h3><h4 id="SYNC-1"><a href="#SYNC-1" class="headerlink" title="SYNC"></a>SYNC</h4><pre><code>可用版本： &gt;= 1.0.0
时间复杂度： O(N)
</code></pre><p>用于复制功能(replication)的内部命令。</p><p>更多信息请参考 Redis 官网的 Replication 章节 。</p><h4 id="返回值-159"><a href="#返回值-159" class="headerlink" title="返回值"></a>返回值</h4><p>序列化数据。</p><h4 id="代码示例-151"><a href="#代码示例-151" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SYNC</span><br><span class="line"><span class="string">"REDIS0002\xfe\x00\x00\auser_id\xc0\x03\x00\anumbers\xc2\xf3\xe0\x01\x00\x00\tdb_number\xc0\x00\x00\x04name\x06huangz\x00\anew_key\nhello_moto\x00\bgreeting\nhello moto\x00\x05my_pc\bthinkpad\x00\x04lock\xc0\x01\x00\nlock_times\xc0\x04\xfe\x01\t\x04info\x19\x02\x04name\b\x00zhangyue\x03age\x02\x0022\xff\t\aooredis,\x03\x04name\a\x00ooredis\aversion\x03\x001.0\x06author\x06\x00huangz\xff\x00\tdb_number\xc0\x01\x00\x05greet\x0bhello world\x02\nmy_friends\x02\x05marry\x04jack\x00\x04name\x05value\xfe\x02\x0c\x01s\x12\x12\x00\x00\x00\r\x00\x00\x00\x02\x00\x00\x01a\x03\xc0f'\xff\xff"</span></span><br><span class="line">(1.90s)</span><br></pre></td></tr></table></figure><h3 id="PSYNC"><a href="#PSYNC" class="headerlink" title="PSYNC"></a>PSYNC</h3><h4 id="PSYNC-master-run-id-offset"><a href="#PSYNC-master-run-id-offset" class="headerlink" title="PSYNC master_run_id offset"></a>PSYNC master_run_id offset</h4><pre><code>可用版本： &gt;= 2.8.0
时间复杂度： 不明确
</code></pre><p>用于复制功能(replication)的内部命令。</p><p>更多信息请参考 复制（Replication） 文档。</p><h4 id="返回值-160"><a href="#返回值-160" class="headerlink" title="返回值"></a>返回值</h4><p>序列化数据。</p><h4 id="代码示例-152"><a href="#代码示例-152" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PSYNC ? -1</span><br><span class="line"><span class="string">"REDIS0006\xfe\x00\x00\x02kk\x02vv\x00\x03msg\x05hello\xff\xc3\x96P\x12h\bK\xef"</span></span><br></pre></td></tr></table></figure><h1 id="转载出处"><a href="#转载出处" class="headerlink" title="转载出处"></a>转载出处</h1><p><a href="http://redisdoc.com/index.html" rel="external nofollow noopener noreferrer" target="_blank">Redis命令参考</a></p></div><div><div style="text-align:center;color:#ccc;font-size:15px"><br><br><br> -------------文章结束啦 ~\(≧▽≦)/~ 感谢您的阅读-------------</div><br></div><div><div id="wechat_subscriber" style="display:block;padding:10px 0;margin:20px auto;width:100%;text-align:center"> <img id="wechat_subscriber_qcode" src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/others/qrcode_wechat_subscriber.jpg" alt="SakuraTears wechat" style="width:200px;max-width:100%"><div>扫一扫关注我的公众号</div></div></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>您的支持就是我创作的动力！</div> <button id="rewardButton" disable="enable" onclick='var qr=document.getElementById("QR");"none"===qr.style.display?qr.style.display="block":qr.style.display="none"'> <span>打赏</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"> <img id="wechat_qr" src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/others/wechatpay.png" alt="SakuraTears 微信支付"><p>微信支付</p></div><div id="alipay" style="display:inline-block"> <img id="alipay_qr" src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/others/alipay.jpg" alt="SakuraTears 支付宝"><p>支付宝</p></div></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> SakuraTears</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.sakuratears.top/blog/Redis命令使用参考手册.html" title="Redis命令使用参考手册">https://www.sakuratears.top/blog/Redis命令使用参考手册.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow noopener noreferrer" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Redis/" rel="tag"><i class="fa fa-tag"></i> Redis</a></div><div class="post-widgets"><div class="wp_rating"><div style="color:rgba(0,0,0,.75);font-size:16px;letter-spacing:8px">(&gt;来评分吧&lt;)</div><div id="wpac-rating"></div></div></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/blog/使用Java发送邮件.html" rel="next" title="使用Java发送邮件"><i class="fa fa-chevron-left"></i> 使用Java发送邮件</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"> <a href="/blog/MySql数据库知识点总结(1).html" rel="prev" title="MySql数据库知识点总结(1)">MySql数据库知识点总结(1)<i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap"> 站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/others/avatar.jpg" alt="SakuraTears"><p class="site-author-name" itemprop="name">SakuraTears</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">91</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/index.html"><span class="site-state-item-count">3</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/index.html"><span class="site-state-item-count">61</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/JavaZWT" target="_blank" title="GitHub" rel="external nofollow noopener noreferrer"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="mailto:971258230@qq.com" target="_blank" title="Email" rel="external nofollow noopener noreferrer"><i class="fa fa-fw fa-envelope"></i> Email</a></span><span class="links-of-author-item"><a href="http://wpa.qq.com/msgrd?v=3&uin=971258230&site=qq&menu=yes" target="_blank" title="QQ" rel="external nofollow noopener noreferrer"><i class="fa fa-fw fa-qq"></i> QQ</a></span><span class="links-of-author-item"><a href="https://blog.csdn.net/JavaZWT" target="_blank" title="CSDN" rel="external nofollow noopener noreferrer"><i class="fa fa-fw fa-copyright"></i> CSDN</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title" style="color:#fc6423"><i class="fa fa-fw fa-link"></i> 友情链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="https://www.sakuratears.top" title="SakuraTears的小乖乖" target="_blank">SakuraTears的小乖乖</a></li><li class="links-of-blogroll-item"> <a href="http://jm.taobao.org/" title="阿里巴巴中间件团队博客" target="_blank" rel="external nofollow noopener noreferrer">阿里巴巴中间件团队博客</a></li><li class="links-of-blogroll-item"> <a href="https://blog.ymfe.org/" title="去哪儿网大前端技术博客" target="_blank" rel="external nofollow noopener noreferrer">去哪儿网大前端技术博客</a></li></ul></div><div class="links-of-blogroll motion-element links-of-blogroll-inline" style="opacity:1;display:block;transform:translateX(0);margin-top:8px"></div><div id="aplayer-rWUYQYrx" class="aplayer aplayer-tag-marker" style="margin:30px 0 30px 0"></div><script>var options={narrow:!1,autoplay:!1,showlrc:0,mutex:!0,theme:"#e6d0b2",preload:"none",listmaxheight:"500px",music:[{title:"Sakura Tears",author:"Nigel Silin",url:"http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/Nigel%20Silin%20-%20Sakura%20Tears.mp3",pic:"http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/music1.jpeg"},{title:"东京不太热",author:"封茗囧菌",url:"http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/%E5%B0%81%E8%8C%97%E5%9B%A7%E8%8F%8C%20-%20%E4%B8%9C%E4%BA%AC%E4%B8%8D%E5%A4%AA%E7%83%AD.mp3",pic:"http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/music2.jpeg"},{title:"春风吹",author:"锦零",url:"http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/%E9%94%A6%E9%9B%B6%20-%20%E6%98%A5%E9%A3%8E%E5%90%B9%EF%BC%88Cover%20%E6%96%B9%E5%A4%A7%E5%90%8C%EF%BC%89.mp3",pic:"http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/music3.jpeg"},{title:"Secret",author:"茶太",url:"https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/%E8%8C%B6%E5%A4%AA%20-%20Secret.mp3",pic:"http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/music4.jpeg"},{title:"secret base ~君がくれたもの~",author:"茅野愛衣,戸松遥,早見沙織",url:"https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/%E8%8C%85%E9%87%8E%E6%84%9B%E8%A1%A3%2C%E6%88%B8%E6%9D%BE%E9%81%A5%2C%E6%97%A9%E8%A6%8B%E6%B2%99%E7%B9%94%20-%20secret%20base%20%7E%E5%90%9B%E3%81%8B%E3%82%99%E3%81%8F%E3%82%8C%E3%81%9F%E3%82%82%E3%81%AE%7E%20%2810%20years%20after%20Ver.%29.mp3",pic:"http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/music5.jpeg"},{title:"ファンファーレ",author:"sumika",url:"https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/sumika%20-%20%E3%83%95%E3%82%A1%E3%83%B3%E3%83%95%E3%82%A1%E3%83%BC%E3%83%AC.mp3",pic:"http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/music6.jpeg"}]};options.element=document.getElementById("aplayer-rWUYQYrx");var ap=new APlayer(options);window.aplayers||(window.aplayers=[]),window.aplayers.push(ap)</script></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#主要命令"><span class="nav-number">2.</span> <span class="nav-text">主要命令</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串"><span class="nav-number">2.1.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SET"><span class="nav-number">2.1.1.</span> <span class="nav-text">SET</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SET-key-value-EX-seconds-PX-milliseconds-NX-XX"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">SET key value [EX seconds] [PX milliseconds] [NX|XX]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可选参数"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">可选参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值"><span class="nav-number">2.1.1.3.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例"><span class="nav-number">2.1.1.4.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SETNX"><span class="nav-number">2.1.2.</span> <span class="nav-text">SETNX</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SETNX-key-value"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">SETNX key value</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-1"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-1"><span class="nav-number">2.1.2.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SETEX"><span class="nav-number">2.1.3.</span> <span class="nav-text">SETEX</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SETEX-key-seconds-value"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">SETEX key seconds value</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-2"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-2"><span class="nav-number">2.1.3.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PSETEX"><span class="nav-number">2.1.4.</span> <span class="nav-text">PSETEX</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#PSETEX-key-milliseconds-value"><span class="nav-number">2.1.4.1.</span> <span class="nav-text">PSETEX key milliseconds value</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-3"><span class="nav-number">2.1.4.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-3"><span class="nav-number">2.1.4.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GET"><span class="nav-number">2.1.5.</span> <span class="nav-text">GET</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GET-key"><span class="nav-number">2.1.5.1.</span> <span class="nav-text">GET key</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-4"><span class="nav-number">2.1.5.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-4"><span class="nav-number">2.1.5.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GETSET"><span class="nav-number">2.1.6.</span> <span class="nav-text">GETSET</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GETSET-key-value"><span class="nav-number">2.1.6.1.</span> <span class="nav-text">GETSET key value</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-5"><span class="nav-number">2.1.6.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-5"><span class="nav-number">2.1.6.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#STRLEN"><span class="nav-number">2.1.7.</span> <span class="nav-text">STRLEN</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#STRLEN-key"><span class="nav-number">2.1.7.1.</span> <span class="nav-text">STRLEN key</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-6"><span class="nav-number">2.1.7.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-6"><span class="nav-number">2.1.7.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#APPEND"><span class="nav-number">2.1.8.</span> <span class="nav-text">APPEND</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#APPEND-key-value"><span class="nav-number">2.1.8.1.</span> <span class="nav-text">APPEND key value</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-7"><span class="nav-number">2.1.8.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例代码"><span class="nav-number">2.1.8.3.</span> <span class="nav-text">示例代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SETRANGE"><span class="nav-number">2.1.9.</span> <span class="nav-text">SETRANGE</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SETRANGE-key-offset-value"><span class="nav-number">2.1.9.1.</span> <span class="nav-text">SETRANGE key offset value</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-8"><span class="nav-number">2.1.9.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-7"><span class="nav-number">2.1.9.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GETRANGE"><span class="nav-number">2.1.10.</span> <span class="nav-text">GETRANGE</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GETRANGE-key-start-end"><span class="nav-number">2.1.10.1.</span> <span class="nav-text">GETRANGE key start end</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-9"><span class="nav-number">2.1.10.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-8"><span class="nav-number">2.1.10.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#INCRBY"><span class="nav-number">2.1.11.</span> <span class="nav-text">INCRBY</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#INCRBY-key-increment"><span class="nav-number">2.1.11.1.</span> <span class="nav-text">INCRBY key increment</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-10"><span class="nav-number">2.1.11.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-9"><span class="nav-number">2.1.11.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#INCRBYFLOAT"><span class="nav-number">2.1.12.</span> <span class="nav-text">INCRBYFLOAT</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#INCRBYFLOAT-key-increment"><span class="nav-number">2.1.12.1.</span> <span class="nav-text">INCRBYFLOAT key increment</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-11"><span class="nav-number">2.1.12.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-10"><span class="nav-number">2.1.12.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DECR"><span class="nav-number">2.1.13.</span> <span class="nav-text">DECR</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DECR-key"><span class="nav-number">2.1.13.1.</span> <span class="nav-text">DECR key</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-12"><span class="nav-number">2.1.13.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-11"><span class="nav-number">2.1.13.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DECRBY"><span class="nav-number">2.1.14.</span> <span class="nav-text">DECRBY</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DECRBY-key-decrement"><span class="nav-number">2.1.14.1.</span> <span class="nav-text">DECRBY key decrement</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-13"><span class="nav-number">2.1.14.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-12"><span class="nav-number">2.1.14.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MSET"><span class="nav-number">2.1.15.</span> <span class="nav-text">MSET</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MSET-key-value-key-value-…"><span class="nav-number">2.1.15.1.</span> <span class="nav-text">MSET key value [key value …]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-14"><span class="nav-number">2.1.15.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-13"><span class="nav-number">2.1.15.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MSETNX"><span class="nav-number">2.1.16.</span> <span class="nav-text">MSETNX</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MSETNX-key-value-key-value-…"><span class="nav-number">2.1.16.1.</span> <span class="nav-text">MSETNX key value [key value …]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-15"><span class="nav-number">2.1.16.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-14"><span class="nav-number">2.1.16.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MGET"><span class="nav-number">2.1.17.</span> <span class="nav-text">MGET</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MGET-key-key-…"><span class="nav-number">2.1.17.1.</span> <span class="nav-text">MGET key [key …]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-16"><span class="nav-number">2.1.17.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-15"><span class="nav-number">2.1.17.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#哈希表"><span class="nav-number">2.2.</span> <span class="nav-text">哈希表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HSET"><span class="nav-number">2.2.1.</span> <span class="nav-text">HSET</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HSET-hash-field-value"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">HSET hash field value</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-17"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-16"><span class="nav-number">2.2.1.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HSETNX"><span class="nav-number">2.2.2.</span> <span class="nav-text">HSETNX</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HSETNX-hash-field-value"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">HSETNX hash field value</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-18"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-17"><span class="nav-number">2.2.2.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HGET"><span class="nav-number">2.2.3.</span> <span class="nav-text">HGET</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HGET-hash-field"><span class="nav-number">2.2.3.1.</span> <span class="nav-text">HGET hash field</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-19"><span class="nav-number">2.2.3.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-18"><span class="nav-number">2.2.3.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HEXISTS"><span class="nav-number">2.2.4.</span> <span class="nav-text">HEXISTS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HEXISTS-hash-field"><span class="nav-number">2.2.4.1.</span> <span class="nav-text">HEXISTS hash field</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-20"><span class="nav-number">2.2.4.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-19"><span class="nav-number">2.2.4.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HDEL"><span class="nav-number">2.2.5.</span> <span class="nav-text">HDEL</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HDEL-key-field-field-…"><span class="nav-number">2.2.5.1.</span> <span class="nav-text">HDEL key field [field …]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-21"><span class="nav-number">2.2.5.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-20"><span class="nav-number">2.2.5.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HLEN"><span class="nav-number">2.2.6.</span> <span class="nav-text">HLEN</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HLEN-key"><span class="nav-number">2.2.6.1.</span> <span class="nav-text">HLEN key</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-22"><span class="nav-number">2.2.6.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-21"><span class="nav-number">2.2.6.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HSTRLEN"><span class="nav-number">2.2.7.</span> <span class="nav-text">HSTRLEN</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HSTRLEN-key-field"><span class="nav-number">2.2.7.1.</span> <span class="nav-text">HSTRLEN key field</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-23"><span class="nav-number">2.2.7.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-22"><span class="nav-number">2.2.7.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HINCRBY"><span class="nav-number">2.2.8.</span> <span class="nav-text">HINCRBY</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HINCRBY-key-field-increment"><span class="nav-number">2.2.8.1.</span> <span class="nav-text">HINCRBY key field increment</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-24"><span class="nav-number">2.2.8.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-23"><span class="nav-number">2.2.8.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HINCRBYFLOAT"><span class="nav-number">2.2.9.</span> <span class="nav-text">HINCRBYFLOAT</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HINCRBYFLOAT-key-field-increment"><span class="nav-number">2.2.9.1.</span> <span class="nav-text">HINCRBYFLOAT key field increment</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-25"><span class="nav-number">2.2.9.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-24"><span class="nav-number">2.2.9.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HMSET"><span class="nav-number">2.2.10.</span> <span class="nav-text">HMSET</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HMSET-key-field-value-field-value-…"><span class="nav-number">2.2.10.1.</span> <span class="nav-text">HMSET key field value [field value …]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-26"><span class="nav-number">2.2.10.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-25"><span class="nav-number">2.2.10.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HMGET"><span class="nav-number">2.2.11.</span> <span class="nav-text">HMGET</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HMGET-key-field-field-…"><span class="nav-number">2.2.11.1.</span> <span class="nav-text">HMGET key field [field …]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-27"><span class="nav-number">2.2.11.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-26"><span class="nav-number">2.2.11.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HKEYS"><span class="nav-number">2.2.12.</span> <span class="nav-text">HKEYS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HKEYS-key"><span class="nav-number">2.2.12.1.</span> <span class="nav-text">HKEYS key</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-28"><span class="nav-number">2.2.12.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例代码-1"><span class="nav-number">2.2.12.3.</span> <span class="nav-text">示例代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HVALS"><span class="nav-number">2.2.13.</span> <span class="nav-text">HVALS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HVALS-key"><span class="nav-number">2.2.13.1.</span> <span class="nav-text">HVALS key</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-29"><span class="nav-number">2.2.13.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-27"><span class="nav-number">2.2.13.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HGETALL"><span class="nav-number">2.2.14.</span> <span class="nav-text">HGETALL</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HGETALL-key"><span class="nav-number">2.2.14.1.</span> <span class="nav-text">HGETALL key</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-30"><span class="nav-number">2.2.14.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-28"><span class="nav-number">2.2.14.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HSCAN"><span class="nav-number">2.2.15.</span> <span class="nav-text">HSCAN</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HSCAN-key-cursor-MATCH-pattern-COUNT-count"><span class="nav-number">2.2.15.1.</span> <span class="nav-text">HSCAN key cursor [MATCH pattern] [COUNT count]</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#列表"><span class="nav-number">2.3.</span> <span class="nav-text">列表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LPUSH"><span class="nav-number">2.3.1.</span> <span class="nav-text">LPUSH</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#LPUSH-key-value-value-…"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">LPUSH key value [value …]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-31"><span class="nav-number">2.3.1.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-29"><span class="nav-number">2.3.1.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LPUSHX"><span class="nav-number">2.3.2.</span> <span class="nav-text">LPUSHX</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#LPUSHX-key-value"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">LPUSHX key value</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-32"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-30"><span class="nav-number">2.3.2.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RPUSH"><span class="nav-number">2.3.3.</span> <span class="nav-text">RPUSH</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RPUSH-key-value-value-…"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">RPUSH key value [value …]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-33"><span class="nav-number">2.3.3.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-31"><span class="nav-number">2.3.3.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RPUSHX"><span class="nav-number">2.3.4.</span> <span class="nav-text">RPUSHX</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RPUSHX-key-value"><span class="nav-number">2.3.4.1.</span> <span class="nav-text">RPUSHX key value</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-34"><span class="nav-number">2.3.4.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-32"><span class="nav-number">2.3.4.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LPOP"><span class="nav-number">2.3.5.</span> <span class="nav-text">LPOP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#LPOP-key"><span class="nav-number">2.3.5.1.</span> <span class="nav-text">LPOP key</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-35"><span class="nav-number">2.3.5.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-33"><span class="nav-number">2.3.5.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RPOP"><span class="nav-number">2.3.6.</span> <span class="nav-text">RPOP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RPOP-key"><span class="nav-number">2.3.6.1.</span> <span class="nav-text">RPOP key</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-36"><span class="nav-number">2.3.6.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-34"><span class="nav-number">2.3.6.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RPOPLPUSH"><span class="nav-number">2.3.7.</span> <span class="nav-text">RPOPLPUSH</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RPOPLPUSH-source-destination"><span class="nav-number">2.3.7.1.</span> <span class="nav-text">RPOPLPUSH source destination</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-37"><span class="nav-number">2.3.7.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-35"><span class="nav-number">2.3.7.3.</span> <span class="nav-text">代码示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#模式：-安全的队列"><span class="nav-number">2.3.7.4.</span> <span class="nav-text">模式： 安全的队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#模式：循环列表"><span class="nav-number">2.3.7.5.</span> <span class="nav-text">模式：循环列表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LREM"><span class="nav-number">2.3.8.</span> <span class="nav-text">LREM</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#LREM-key-count-value"><span class="nav-number">2.3.8.1.</span> <span class="nav-text">LREM key count value</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-38"><span class="nav-number">2.3.8.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-36"><span class="nav-number">2.3.8.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LLEN"><span class="nav-number">2.3.9.</span> <span class="nav-text">LLEN</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#LLEN-key"><span class="nav-number">2.3.9.1.</span> <span class="nav-text">LLEN key</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-39"><span class="nav-number">2.3.9.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-37"><span class="nav-number">2.3.9.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LINDEX"><span class="nav-number">2.3.10.</span> <span class="nav-text">LINDEX</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#LINDEX-key-index"><span class="nav-number">2.3.10.1.</span> <span class="nav-text">LINDEX key index</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-40"><span class="nav-number">2.3.10.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-38"><span class="nav-number">2.3.10.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LINSERT"><span class="nav-number">2.3.11.</span> <span class="nav-text">LINSERT</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#LINSERT-key-BEFORE-AFTER-pivot-value"><span class="nav-number">2.3.11.1.</span> <span class="nav-text">LINSERT key BEFORE|AFTER pivot value</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-41"><span class="nav-number">2.3.11.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-39"><span class="nav-number">2.3.11.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LSET"><span class="nav-number">2.3.12.</span> <span class="nav-text">LSET</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#LSET-key-index-value"><span class="nav-number">2.3.12.1.</span> <span class="nav-text">LSET key index value</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-42"><span class="nav-number">2.3.12.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-40"><span class="nav-number">2.3.12.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LRANGE"><span class="nav-number">2.3.13.</span> <span class="nav-text">LRANGE</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#LRANGE-key-start-stop"><span class="nav-number">2.3.13.1.</span> <span class="nav-text">LRANGE key start stop</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-43"><span class="nav-number">2.3.13.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-41"><span class="nav-number">2.3.13.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LTRIM"><span class="nav-number">2.3.14.</span> <span class="nav-text">LTRIM</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#LTRIM-key-start-stop"><span class="nav-number">2.3.14.1.</span> <span class="nav-text">LTRIM key start stop</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BLPOP"><span class="nav-number">2.3.15.</span> <span class="nav-text">BLPOP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#BLPOP-key-key-…-timeout"><span class="nav-number">2.3.15.1.</span> <span class="nav-text">BLPOP key [key …] timeout</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#非阻塞行为"><span class="nav-number">2.3.15.2.</span> <span class="nav-text">非阻塞行为</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#阻塞行为"><span class="nav-number">2.3.15.3.</span> <span class="nav-text">阻塞行为</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在MULTI-EXEC事务中的BLPOP"><span class="nav-number">2.3.15.4.</span> <span class="nav-text">在MULTI/EXEC事务中的BLPOP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-44"><span class="nav-number">2.3.15.5.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#模式：事件提醒"><span class="nav-number">2.3.15.6.</span> <span class="nav-text">模式：事件提醒</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BRPOP"><span class="nav-number">2.3.16.</span> <span class="nav-text">BRPOP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#BRPOP-key-key-…-timeout"><span class="nav-number">2.3.16.1.</span> <span class="nav-text">BRPOP key [key …] timeout</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-45"><span class="nav-number">2.3.16.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-42"><span class="nav-number">2.3.16.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BRPOPLPUSH"><span class="nav-number">2.3.17.</span> <span class="nav-text">BRPOPLPUSH</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#BRPOPLPUSH-source-destination-timeout"><span class="nav-number">2.3.17.1.</span> <span class="nav-text">BRPOPLPUSH source destination timeout</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-46"><span class="nav-number">2.3.17.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-43"><span class="nav-number">2.3.17.3.</span> <span class="nav-text">代码示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#模式：安全队列"><span class="nav-number">2.3.17.4.</span> <span class="nav-text">模式：安全队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#模式：循环列表-1"><span class="nav-number">2.3.17.5.</span> <span class="nav-text">模式：循环列表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集合"><span class="nav-number">2.4.</span> <span class="nav-text">集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SADD"><span class="nav-number">2.4.1.</span> <span class="nav-text">SADD</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SADD-key-member-member-…"><span class="nav-number">2.4.1.1.</span> <span class="nav-text">SADD key member [member …]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Note"><span class="nav-number">2.4.1.2.</span> <span class="nav-text">Note</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-47"><span class="nav-number">2.4.1.3.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-44"><span class="nav-number">2.4.1.4.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SISMEMBER"><span class="nav-number">2.4.2.</span> <span class="nav-text">SISMEMBER</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SISMEMBER-key-member"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">SISMEMBER key member</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-48"><span class="nav-number">2.4.2.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-45"><span class="nav-number">2.4.2.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SPOP"><span class="nav-number">2.4.3.</span> <span class="nav-text">SPOP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SPOP-key"><span class="nav-number">2.4.3.1.</span> <span class="nav-text">SPOP key</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-49"><span class="nav-number">2.4.3.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-46"><span class="nav-number">2.4.3.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SRANDMEMBER"><span class="nav-number">2.4.4.</span> <span class="nav-text">SRANDMEMBER</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SRANDMEMBER-key-count"><span class="nav-number">2.4.4.1.</span> <span class="nav-text">SRANDMEMBER key [count]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-50"><span class="nav-number">2.4.4.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-47"><span class="nav-number">2.4.4.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SREM"><span class="nav-number">2.4.5.</span> <span class="nav-text">SREM</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SREM-key-member-member-…"><span class="nav-number">2.4.5.1.</span> <span class="nav-text">SREM key member [member …]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Note-1"><span class="nav-number">2.4.5.2.</span> <span class="nav-text">Note</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-51"><span class="nav-number">2.4.5.3.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-48"><span class="nav-number">2.4.5.4.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SMOVE"><span class="nav-number">2.4.6.</span> <span class="nav-text">SMOVE</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SMOVE-source-destination-member"><span class="nav-number">2.4.6.1.</span> <span class="nav-text">SMOVE source destination member</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-52"><span class="nav-number">2.4.6.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-49"><span class="nav-number">2.4.6.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SCARD"><span class="nav-number">2.4.7.</span> <span class="nav-text">SCARD</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SCARD-key"><span class="nav-number">2.4.7.1.</span> <span class="nav-text">SCARD key</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-53"><span class="nav-number">2.4.7.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-50"><span class="nav-number">2.4.7.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SMEMBERS"><span class="nav-number">2.4.8.</span> <span class="nav-text">SMEMBERS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SMEMBERS-key"><span class="nav-number">2.4.8.1.</span> <span class="nav-text">SMEMBERS key</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-54"><span class="nav-number">2.4.8.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-51"><span class="nav-number">2.4.8.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SSCAN"><span class="nav-number">2.4.9.</span> <span class="nav-text">SSCAN</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SSCAN-key-cursor-MATCH-pattern-COUNT-count"><span class="nav-number">2.4.9.1.</span> <span class="nav-text">SSCAN key cursor [MATCH pattern] [COUNT count]</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SINTER"><span class="nav-number">2.4.10.</span> <span class="nav-text">SINTER</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SINTER-key-key-…"><span class="nav-number">2.4.10.1.</span> <span class="nav-text">SINTER key [key …]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-55"><span class="nav-number">2.4.10.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-52"><span class="nav-number">2.4.10.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SINTERSTORE"><span class="nav-number">2.4.11.</span> <span class="nav-text">SINTERSTORE</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SINTERSTORE-destination-key-key-…"><span class="nav-number">2.4.11.1.</span> <span class="nav-text">SINTERSTORE destination key [key …]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-56"><span class="nav-number">2.4.11.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-53"><span class="nav-number">2.4.11.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SUNION"><span class="nav-number">2.4.12.</span> <span class="nav-text">SUNION</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SUNION-key-key-…"><span class="nav-number">2.4.12.1.</span> <span class="nav-text">SUNION key [key …]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-57"><span class="nav-number">2.4.12.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-54"><span class="nav-number">2.4.12.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SUNIONSTORE"><span class="nav-number">2.4.13.</span> <span class="nav-text">SUNIONSTORE</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SUNIONSTORE-destination-key-key-…"><span class="nav-number">2.4.13.1.</span> <span class="nav-text">SUNIONSTORE destination key [key …]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-58"><span class="nav-number">2.4.13.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-55"><span class="nav-number">2.4.13.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SDIFF"><span class="nav-number">2.4.14.</span> <span class="nav-text">SDIFF</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SDIFF-key-key-…"><span class="nav-number">2.4.14.1.</span> <span class="nav-text">SDIFF key [key …]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-59"><span class="nav-number">2.4.14.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-56"><span class="nav-number">2.4.14.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SDIFFSTORE"><span class="nav-number">2.4.15.</span> <span class="nav-text">SDIFFSTORE</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SDIFFSTORE-destination-key-key-…"><span class="nav-number">2.4.15.1.</span> <span class="nav-text">SDIFFSTORE destination key [key …]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-60"><span class="nav-number">2.4.15.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-57"><span class="nav-number">2.4.15.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#有序集合"><span class="nav-number">2.5.</span> <span class="nav-text">有序集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ZADD"><span class="nav-number">2.5.1.</span> <span class="nav-text">ZADD</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ZADD-key-score-member-score-member-score-member-…"><span class="nav-number">2.5.1.1.</span> <span class="nav-text">ZADD key score member [[score member] [score member] …]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Note-2"><span class="nav-number">2.5.1.2.</span> <span class="nav-text">Note</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-61"><span class="nav-number">2.5.1.3.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-58"><span class="nav-number">2.5.1.4.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZSCORE"><span class="nav-number">2.5.2.</span> <span class="nav-text">ZSCORE</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ZSCORE-key-member"><span class="nav-number">2.5.2.1.</span> <span class="nav-text">ZSCORE key member</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-62"><span class="nav-number">2.5.2.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-59"><span class="nav-number">2.5.2.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZINCRBY"><span class="nav-number">2.5.3.</span> <span class="nav-text">ZINCRBY</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ZINCRBY-key-increment-member"><span class="nav-number">2.5.3.1.</span> <span class="nav-text">ZINCRBY key increment member</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-63"><span class="nav-number">2.5.3.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-60"><span class="nav-number">2.5.3.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZCARD"><span class="nav-number">2.5.4.</span> <span class="nav-text">ZCARD</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ZCARD-key"><span class="nav-number">2.5.4.1.</span> <span class="nav-text">ZCARD key</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-64"><span class="nav-number">2.5.4.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-61"><span class="nav-number">2.5.4.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZCOUNT"><span class="nav-number">2.5.5.</span> <span class="nav-text">ZCOUNT</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ZCOUNT-key-min-max"><span class="nav-number">2.5.5.1.</span> <span class="nav-text">ZCOUNT key min max</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-65"><span class="nav-number">2.5.5.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-62"><span class="nav-number">2.5.5.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZRANGE"><span class="nav-number">2.5.6.</span> <span class="nav-text">ZRANGE</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ZRANGE-key-start-stop-WITHSCORES"><span class="nav-number">2.5.6.1.</span> <span class="nav-text">ZRANGE key start stop [WITHSCORES]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-66"><span class="nav-number">2.5.6.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-63"><span class="nav-number">2.5.6.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZREVRANGE"><span class="nav-number">2.5.7.</span> <span class="nav-text">ZREVRANGE</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ZREVRANGE-key-start-stop-WITHSCORES"><span class="nav-number">2.5.7.1.</span> <span class="nav-text">ZREVRANGE key start stop [WITHSCORES]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-67"><span class="nav-number">2.5.7.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-64"><span class="nav-number">2.5.7.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZRANGEBYSCORE"><span class="nav-number">2.5.8.</span> <span class="nav-text">ZRANGEBYSCORE</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ZRANGEBYSCORE-key-min-max-WITHSCORES-LIMIT-offset-count"><span class="nav-number">2.5.8.1.</span> <span class="nav-text">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#区间及无限"><span class="nav-number">2.5.8.2.</span> <span class="nav-text">区间及无限</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#举个例子："><span class="nav-number">2.5.8.3.</span> <span class="nav-text">举个例子：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-68"><span class="nav-number">2.5.8.4.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-65"><span class="nav-number">2.5.8.5.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZREVRANGEBYSCORE"><span class="nav-number">2.5.9.</span> <span class="nav-text">ZREVRANGEBYSCORE</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ZREVRANGEBYSCORE-key-max-min-WITHSCORES-LIMIT-offset-count"><span class="nav-number">2.5.9.1.</span> <span class="nav-text">ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-69"><span class="nav-number">2.5.9.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-66"><span class="nav-number">2.5.9.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZRANK"><span class="nav-number">2.5.10.</span> <span class="nav-text">ZRANK</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ZRANK-key-member"><span class="nav-number">2.5.10.1.</span> <span class="nav-text">ZRANK key member</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-70"><span class="nav-number">2.5.10.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-67"><span class="nav-number">2.5.10.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZREVRANK"><span class="nav-number">2.5.11.</span> <span class="nav-text">ZREVRANK</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ZREVRANK-key-member"><span class="nav-number">2.5.11.1.</span> <span class="nav-text">ZREVRANK key member</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-71"><span class="nav-number">2.5.11.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-68"><span class="nav-number">2.5.11.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZREM"><span class="nav-number">2.5.12.</span> <span class="nav-text">ZREM</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ZREM-key-member-member-…"><span class="nav-number">2.5.12.1.</span> <span class="nav-text">ZREM key member [member …]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Note-3"><span class="nav-number">2.5.12.2.</span> <span class="nav-text">Note</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-72"><span class="nav-number">2.5.12.3.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-69"><span class="nav-number">2.5.12.4.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZREMRANGEBYRANK"><span class="nav-number">2.5.13.</span> <span class="nav-text">ZREMRANGEBYRANK</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ZREMRANGEBYRANK-key-start-stop"><span class="nav-number">2.5.13.1.</span> <span class="nav-text">ZREMRANGEBYRANK key start stop</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-73"><span class="nav-number">2.5.13.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-70"><span class="nav-number">2.5.13.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZREMRANGEBYSCORE"><span class="nav-number">2.5.14.</span> <span class="nav-text">ZREMRANGEBYSCORE</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ZREMRANGEBYSCORE-key-min-max"><span class="nav-number">2.5.14.1.</span> <span class="nav-text">ZREMRANGEBYSCORE key min max</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-74"><span class="nav-number">2.5.14.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-71"><span class="nav-number">2.5.14.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZRANGEBYLEX"><span class="nav-number">2.5.15.</span> <span class="nav-text">ZRANGEBYLEX</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ZRANGEBYLEX-key-min-max-LIMIT-offset-count"><span class="nav-number">2.5.15.1.</span> <span class="nav-text">ZRANGEBYLEX key min max [LIMIT offset count]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何指定范围区间"><span class="nav-number">2.5.15.2.</span> <span class="nav-text">如何指定范围区间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-75"><span class="nav-number">2.5.15.3.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-72"><span class="nav-number">2.5.15.4.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZLEXCOUNT"><span class="nav-number">2.5.16.</span> <span class="nav-text">ZLEXCOUNT</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ZLEXCOUNT-key-min-max"><span class="nav-number">2.5.16.1.</span> <span class="nav-text">ZLEXCOUNT key min max</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-76"><span class="nav-number">2.5.16.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-73"><span class="nav-number">2.5.16.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZREMRANGEBYLEX"><span class="nav-number">2.5.17.</span> <span class="nav-text">ZREMRANGEBYLEX</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ZREMRANGEBYLEX-key-min-max"><span class="nav-number">2.5.17.1.</span> <span class="nav-text">ZREMRANGEBYLEX key min max</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-77"><span class="nav-number">2.5.17.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-74"><span class="nav-number">2.5.17.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZSCAN"><span class="nav-number">2.5.18.</span> <span class="nav-text">ZSCAN</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ZSCAN-key-cursor-MATCH-pattern-COUNT-count"><span class="nav-number">2.5.18.1.</span> <span class="nav-text">ZSCAN key cursor [MATCH pattern] [COUNT count]</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZUNIONSTORE"><span class="nav-number">2.5.19.</span> <span class="nav-text">ZUNIONSTORE</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ZUNIONSTORE-destination-numkeys-key-key-…-WEIGHTS-weight-weight-…-AGGREGATE-SUM-MIN-MAX"><span class="nav-number">2.5.19.1.</span> <span class="nav-text">ZUNIONSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WEIGHTS"><span class="nav-number">2.5.19.2.</span> <span class="nav-text">WEIGHTS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AGGREGATE"><span class="nav-number">2.5.19.3.</span> <span class="nav-text">AGGREGATE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-78"><span class="nav-number">2.5.19.4.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-75"><span class="nav-number">2.5.19.5.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZINTERSTORE"><span class="nav-number">2.5.20.</span> <span class="nav-text">ZINTERSTORE</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ZINTERSTORE-destination-numkeys-key-key-…-WEIGHTS-weight-weight-…-AGGREGATE-SUM-MIN-MAX"><span class="nav-number">2.5.20.1.</span> <span class="nav-text">ZINTERSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-79"><span class="nav-number">2.5.20.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-76"><span class="nav-number">2.5.20.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HyperLogLog"><span class="nav-number">2.6.</span> <span class="nav-text">HyperLogLog</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#PFADD"><span class="nav-number">2.6.1.</span> <span class="nav-text">PFADD</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#PFADD-key-element-element-…"><span class="nav-number">2.6.1.1.</span> <span class="nav-text">PFADD key element [element …]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-80"><span class="nav-number">2.6.1.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-77"><span class="nav-number">2.6.1.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PFCOUNT"><span class="nav-number">2.6.2.</span> <span class="nav-text">PFCOUNT</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#PFCOUNT-key-key-…"><span class="nav-number">2.6.2.1.</span> <span class="nav-text">PFCOUNT key [key …]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-81"><span class="nav-number">2.6.2.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-78"><span class="nav-number">2.6.2.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PFMERGE"><span class="nav-number">2.6.3.</span> <span class="nav-text">PFMERGE</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#PFMERGE-destkey-sourcekey-sourcekey-…"><span class="nav-number">2.6.3.1.</span> <span class="nav-text">PFMERGE destkey sourcekey [sourcekey …]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-82"><span class="nav-number">2.6.3.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-79"><span class="nav-number">2.6.3.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#地理位置"><span class="nav-number">2.7.</span> <span class="nav-text">地理位置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GEOADD"><span class="nav-number">2.7.1.</span> <span class="nav-text">GEOADD</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GEOADD-key-longitude-latitude-member-longitude-latitude-member-…"><span class="nav-number">2.7.1.1.</span> <span class="nav-text">GEOADD key longitude latitude member [longitude latitude member …]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-83"><span class="nav-number">2.7.1.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-80"><span class="nav-number">2.7.1.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GEOPOS"><span class="nav-number">2.7.2.</span> <span class="nav-text">GEOPOS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GEOPOS-key-member-member-…"><span class="nav-number">2.7.2.1.</span> <span class="nav-text">GEOPOS key member [member …]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-84"><span class="nav-number">2.7.2.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-81"><span class="nav-number">2.7.2.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GEODIST"><span class="nav-number">2.7.3.</span> <span class="nav-text">GEODIST</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GEODIST-key-member1-member2-unit"><span class="nav-number">2.7.3.1.</span> <span class="nav-text">GEODIST key member1 member2 [unit]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-85"><span class="nav-number">2.7.3.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-82"><span class="nav-number">2.7.3.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GEORADIUS"><span class="nav-number">2.7.4.</span> <span class="nav-text">GEORADIUS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GEORADIUS-key-longitude-latitude-radius-m-km-ft-mi-WITHCOORD-WITHDIST-WITHHASH-ASC-DESC-COUNT-count"><span class="nav-number">2.7.4.1.</span> <span class="nav-text">GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [ASC|DESC] [COUNT count]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-86"><span class="nav-number">2.7.4.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-83"><span class="nav-number">2.7.4.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GEORADIUSBYMEMBER"><span class="nav-number">2.7.5.</span> <span class="nav-text">GEORADIUSBYMEMBER</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GEORADIUSBYMEMBER-key-member-radius-m-km-ft-mi-WITHCOORD-WITHDIST-WITHHASH-ASC-DESC-COUNT-count"><span class="nav-number">2.7.5.1.</span> <span class="nav-text">GEORADIUSBYMEMBER key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [ASC|DESC] [COUNT count]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-87"><span class="nav-number">2.7.5.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-84"><span class="nav-number">2.7.5.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GEOHASH"><span class="nav-number">2.7.6.</span> <span class="nav-text">GEOHASH</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GEOHASH-key-member-member-…"><span class="nav-number">2.7.6.1.</span> <span class="nav-text">GEOHASH key member [member …]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-88"><span class="nav-number">2.7.6.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-85"><span class="nav-number">2.7.6.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#位图"><span class="nav-number">2.8.</span> <span class="nav-text">位图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SETBIT"><span class="nav-number">2.8.1.</span> <span class="nav-text">SETBIT</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SETBIT-key-offset-value"><span class="nav-number">2.8.1.1.</span> <span class="nav-text">SETBIT key offset value</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Warning"><span class="nav-number">2.8.1.2.</span> <span class="nav-text">Warning</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-89"><span class="nav-number">2.8.1.3.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-86"><span class="nav-number">2.8.1.4.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GETBIT"><span class="nav-number">2.8.2.</span> <span class="nav-text">GETBIT</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GETBIT-key-offset"><span class="nav-number">2.8.2.1.</span> <span class="nav-text">GETBIT key offset</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-90"><span class="nav-number">2.8.2.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-87"><span class="nav-number">2.8.2.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BITCOUNT"><span class="nav-number">2.8.3.</span> <span class="nav-text">BITCOUNT</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#BITCOUNT-key-start-end"><span class="nav-number">2.8.3.1.</span> <span class="nav-text">BITCOUNT key [start] [end]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-91"><span class="nav-number">2.8.3.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-88"><span class="nav-number">2.8.3.3.</span> <span class="nav-text">代码示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#模式：使用-bitmap-实现用户上线次数统计"><span class="nav-number">2.8.3.4.</span> <span class="nav-text">模式：使用 bitmap 实现用户上线次数统计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#性能"><span class="nav-number">2.8.3.5.</span> <span class="nav-text">性能</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BITPOS"><span class="nav-number">2.8.4.</span> <span class="nav-text">BITPOS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#BITPOS-key-bit-start-end"><span class="nav-number">2.8.4.1.</span> <span class="nav-text">BITPOS key bit [start] [end]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-92"><span class="nav-number">2.8.4.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-89"><span class="nav-number">2.8.4.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BITOP"><span class="nav-number">2.8.5.</span> <span class="nav-text">BITOP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#BITOP-operation-destkey-key-key-…"><span class="nav-number">2.8.5.1.</span> <span class="nav-text">BITOP operation destkey key [key …]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-93"><span class="nav-number">2.8.5.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Note-4"><span class="nav-number">2.8.5.3.</span> <span class="nav-text">Note</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-90"><span class="nav-number">2.8.5.4.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BITFIELD"><span class="nav-number">2.8.6.</span> <span class="nav-text">BITFIELD</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#BITFIELD-key-GET-type-offset-SET-type-offset-value-INCRBY-type-offset-increment-OVERFLOW-WRAP-SAT-FAIL"><span class="nav-number">2.8.6.1.</span> <span class="nav-text">BITFIELD key [GET type offset] [SET type offset value] [INCRBY type offset increment] [OVERFLOW WRAP|SAT|FAIL]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#支持的子命令以及数字类型"><span class="nav-number">2.8.6.2.</span> <span class="nav-text">支持的子命令以及数字类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二进制位和位置偏移量"><span class="nav-number">2.8.6.3.</span> <span class="nav-text">二进制位和位置偏移量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#溢出控制"><span class="nav-number">2.8.6.4.</span> <span class="nav-text">溢出控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#作用"><span class="nav-number">2.8.6.5.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#性能注意事项"><span class="nav-number">2.8.6.6.</span> <span class="nav-text">性能注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二进制位的排列"><span class="nav-number">2.8.6.7.</span> <span class="nav-text">二进制位的排列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-94"><span class="nav-number">2.8.6.8.</span> <span class="nav-text">返回值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库"><span class="nav-number">2.9.</span> <span class="nav-text">数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#EXISTS"><span class="nav-number">2.9.1.</span> <span class="nav-text">EXISTS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#EXISTS-key"><span class="nav-number">2.9.1.1.</span> <span class="nav-text">EXISTS key</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-95"><span class="nav-number">2.9.1.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-91"><span class="nav-number">2.9.1.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TYPE"><span class="nav-number">2.9.2.</span> <span class="nav-text">TYPE</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TYPE-key"><span class="nav-number">2.9.2.1.</span> <span class="nav-text">TYPE key</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-96"><span class="nav-number">2.9.2.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-92"><span class="nav-number">2.9.2.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RENAME"><span class="nav-number">2.9.3.</span> <span class="nav-text">RENAME</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RENAME-key-newkey"><span class="nav-number">2.9.3.1.</span> <span class="nav-text">RENAME key newkey</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-97"><span class="nav-number">2.9.3.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-93"><span class="nav-number">2.9.3.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RENAMENX"><span class="nav-number">2.9.4.</span> <span class="nav-text">RENAMENX</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RENAMENX-key-newkey"><span class="nav-number">2.9.4.1.</span> <span class="nav-text">RENAMENX key newkey</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-98"><span class="nav-number">2.9.4.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-94"><span class="nav-number">2.9.4.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MOVE"><span class="nav-number">2.9.5.</span> <span class="nav-text">MOVE</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MOVE-key-db"><span class="nav-number">2.9.5.1.</span> <span class="nav-text">MOVE key db</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-99"><span class="nav-number">2.9.5.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-95"><span class="nav-number">2.9.5.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DEL"><span class="nav-number">2.9.6.</span> <span class="nav-text">DEL</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DEL-key-key-…"><span class="nav-number">2.9.6.1.</span> <span class="nav-text">DEL key [key …]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-100"><span class="nav-number">2.9.6.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-96"><span class="nav-number">2.9.6.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RANDOMKEY"><span class="nav-number">2.9.7.</span> <span class="nav-text">RANDOMKEY</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RANDOMKEY-1"><span class="nav-number">2.9.7.1.</span> <span class="nav-text">RANDOMKEY</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-101"><span class="nav-number">2.9.7.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-97"><span class="nav-number">2.9.7.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DBSIZE"><span class="nav-number">2.9.8.</span> <span class="nav-text">DBSIZE</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DBSIZE-1"><span class="nav-number">2.9.8.1.</span> <span class="nav-text">DBSIZE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-102"><span class="nav-number">2.9.8.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-98"><span class="nav-number">2.9.8.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KEYS"><span class="nav-number">2.9.9.</span> <span class="nav-text">KEYS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#KEYS-pattern"><span class="nav-number">2.9.9.1.</span> <span class="nav-text">KEYS pattern</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Warning-1"><span class="nav-number">2.9.9.2.</span> <span class="nav-text">Warning</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-103"><span class="nav-number">2.9.9.3.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-99"><span class="nav-number">2.9.9.4.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SCAN"><span class="nav-number">2.9.10.</span> <span class="nav-text">SCAN</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SCAN-cursor-MATCH-pattern-COUNT-count"><span class="nav-number">2.9.10.1.</span> <span class="nav-text">SCAN cursor [MATCH pattern] [COUNT count]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SCAN-命令的基本用法"><span class="nav-number">2.9.10.2.</span> <span class="nav-text">SCAN 命令的基本用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SCAN-命令的保证（guarantees）"><span class="nav-number">2.9.10.3.</span> <span class="nav-text">SCAN 命令的保证（guarantees）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#COUNT-选项"><span class="nav-number">2.9.10.4.</span> <span class="nav-text">COUNT 选项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Note-5"><span class="nav-number">2.9.10.5.</span> <span class="nav-text">Note</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MATCH-选项"><span class="nav-number">2.9.10.6.</span> <span class="nav-text">MATCH 选项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#并发执行多个迭代"><span class="nav-number">2.9.10.7.</span> <span class="nav-text">并发执行多个迭代</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#中途停止迭代"><span class="nav-number">2.9.10.8.</span> <span class="nav-text">中途停止迭代</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用错误的游标进行增量式迭代"><span class="nav-number">2.9.10.9.</span> <span class="nav-text">使用错误的游标进行增量式迭代</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#迭代终结的保证"><span class="nav-number">2.9.10.10.</span> <span class="nav-text">迭代终结的保证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-104"><span class="nav-number">2.9.10.11.</span> <span class="nav-text">返回值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SORT"><span class="nav-number">2.9.11.</span> <span class="nav-text">SORT</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SORT-key-BY-pattern-LIMIT-offset-count-GET-pattern-GET-pattern-…-ASC-DESC-ALPHA-STORE-destination"><span class="nav-number">2.9.11.1.</span> <span class="nav-text">SORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern …]] [ASC | DESC] [ALPHA] [STORE destination]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#一般-SORT-用法"><span class="nav-number">2.9.11.2.</span> <span class="nav-text">一般 SORT 用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用-ALPHA-修饰符对字符串进行排序"><span class="nav-number">2.9.11.3.</span> <span class="nav-text">使用 ALPHA 修饰符对字符串进行排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用-LIMIT-修饰符限制返回结果"><span class="nav-number">2.9.11.4.</span> <span class="nav-text">使用 LIMIT 修饰符限制返回结果</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用外部-key-进行排序"><span class="nav-number">2.9.11.5.</span> <span class="nav-text">使用外部 key 进行排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#BY-选项"><span class="nav-number">2.9.11.5.1.</span> <span class="nav-text">BY 选项</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#GET-选项"><span class="nav-number">2.9.11.5.2.</span> <span class="nav-text">GET 选项</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#组合使用-BY-和-GET"><span class="nav-number">2.9.11.5.3.</span> <span class="nav-text">组合使用 BY 和 GET</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#获取多个外部键"><span class="nav-number">2.9.11.5.4.</span> <span class="nav-text">获取多个外部键</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#获取外部键，但不进行排序"><span class="nav-number">2.9.11.5.5.</span> <span class="nav-text">获取外部键，但不进行排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#将哈希表作为-GET-或-BY-的参数"><span class="nav-number">2.9.11.5.6.</span> <span class="nav-text">将哈希表作为 GET 或 BY 的参数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#保存排序结果"><span class="nav-number">2.9.11.6.</span> <span class="nav-text">保存排序结果</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-105"><span class="nav-number">2.9.11.7.</span> <span class="nav-text">返回值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FLUSHDB"><span class="nav-number">2.9.12.</span> <span class="nav-text">FLUSHDB</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#FLUSHDB-1"><span class="nav-number">2.9.12.1.</span> <span class="nav-text">FLUSHDB</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-106"><span class="nav-number">2.9.12.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-100"><span class="nav-number">2.9.12.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FLUSHALL"><span class="nav-number">2.9.13.</span> <span class="nav-text">FLUSHALL</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#FLUSHALL-1"><span class="nav-number">2.9.13.1.</span> <span class="nav-text">FLUSHALL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-107"><span class="nav-number">2.9.13.2.</span> <span class="nav-text">返回值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SELECT"><span class="nav-number">2.9.14.</span> <span class="nav-text">SELECT</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SELECT-index"><span class="nav-number">2.9.14.1.</span> <span class="nav-text">SELECT index</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-108"><span class="nav-number">2.9.14.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-101"><span class="nav-number">2.9.14.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SWAPDB"><span class="nav-number">2.9.15.</span> <span class="nav-text">SWAPDB</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SWAPDB-db1-db2"><span class="nav-number">2.9.15.1.</span> <span class="nav-text">SWAPDB db1 db2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-109"><span class="nav-number">2.9.15.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-102"><span class="nav-number">2.9.15.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自动过期"><span class="nav-number">2.10.</span> <span class="nav-text">自动过期</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#EXPIRE"><span class="nav-number">2.10.1.</span> <span class="nav-text">EXPIRE</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#EXPIRE-key-seconds"><span class="nav-number">2.10.1.1.</span> <span class="nav-text">EXPIRE key seconds</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#更新生存时间"><span class="nav-number">2.10.1.2.</span> <span class="nav-text">更新生存时间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#过期时间的精确度"><span class="nav-number">2.10.1.3.</span> <span class="nav-text">过期时间的精确度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis-2-1-3-之前的不同之处"><span class="nav-number">2.10.1.4.</span> <span class="nav-text">Redis 2.1.3 之前的不同之处</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-110"><span class="nav-number">2.10.1.5.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-103"><span class="nav-number">2.10.1.6.</span> <span class="nav-text">代码示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#模式：导航会话"><span class="nav-number">2.10.1.7.</span> <span class="nav-text">模式：导航会话</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EXPIREAT"><span class="nav-number">2.10.2.</span> <span class="nav-text">EXPIREAT</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#EXPIREAT-key-timestamp"><span class="nav-number">2.10.2.1.</span> <span class="nav-text">EXPIREAT key timestamp</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-111"><span class="nav-number">2.10.2.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-104"><span class="nav-number">2.10.2.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TTL"><span class="nav-number">2.10.3.</span> <span class="nav-text">TTL</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TTL-key"><span class="nav-number">2.10.3.1.</span> <span class="nav-text">TTL key</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-112"><span class="nav-number">2.10.3.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Note-6"><span class="nav-number">2.10.3.3.</span> <span class="nav-text">Note</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-105"><span class="nav-number">2.10.3.4.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PERSIST"><span class="nav-number">2.10.4.</span> <span class="nav-text">PERSIST</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#PERSIST-key"><span class="nav-number">2.10.4.1.</span> <span class="nav-text">PERSIST key</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-113"><span class="nav-number">2.10.4.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-106"><span class="nav-number">2.10.4.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PEXPIRE"><span class="nav-number">2.10.5.</span> <span class="nav-text">PEXPIRE</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#PEXPIRE-key-milliseconds"><span class="nav-number">2.10.5.1.</span> <span class="nav-text">PEXPIRE key milliseconds</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-114"><span class="nav-number">2.10.5.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-107"><span class="nav-number">2.10.5.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PEXPIREAT"><span class="nav-number">2.10.6.</span> <span class="nav-text">PEXPIREAT</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#PEXPIREAT-key-milliseconds-timestamp"><span class="nav-number">2.10.6.1.</span> <span class="nav-text">PEXPIREAT key milliseconds-timestamp</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-115"><span class="nav-number">2.10.6.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-108"><span class="nav-number">2.10.6.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PTTL"><span class="nav-number">2.10.7.</span> <span class="nav-text">PTTL</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#PTTL-key"><span class="nav-number">2.10.7.1.</span> <span class="nav-text">PTTL key</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-116"><span class="nav-number">2.10.7.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Note-7"><span class="nav-number">2.10.7.3.</span> <span class="nav-text">Note</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-109"><span class="nav-number">2.10.7.4.</span> <span class="nav-text">代码示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事务"><span class="nav-number">2.11.</span> <span class="nav-text">事务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MULTI"><span class="nav-number">2.11.1.</span> <span class="nav-text">MULTI</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MULTI-1"><span class="nav-number">2.11.1.1.</span> <span class="nav-text">MULTI</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值："><span class="nav-number">2.11.1.2.</span> <span class="nav-text">返回值：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-110"><span class="nav-number">2.11.1.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EXEC"><span class="nav-number">2.11.2.</span> <span class="nav-text">EXEC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#EXEC-1"><span class="nav-number">2.11.2.1.</span> <span class="nav-text">EXEC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值：-1"><span class="nav-number">2.11.2.2.</span> <span class="nav-text">返回值：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-111"><span class="nav-number">2.11.2.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DISCARD"><span class="nav-number">2.11.3.</span> <span class="nav-text">DISCARD</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DISCARD-1"><span class="nav-number">2.11.3.1.</span> <span class="nav-text">DISCARD</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-117"><span class="nav-number">2.11.3.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-112"><span class="nav-number">2.11.3.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WATCH"><span class="nav-number">2.11.4.</span> <span class="nav-text">WATCH</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#WATCH-key-key-…"><span class="nav-number">2.11.4.1.</span> <span class="nav-text">WATCH key [key …]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值：-2"><span class="nav-number">2.11.4.2.</span> <span class="nav-text">返回值：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-113"><span class="nav-number">2.11.4.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UNWATCH"><span class="nav-number">2.11.5.</span> <span class="nav-text">UNWATCH</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#UNWATCH-1"><span class="nav-number">2.11.5.1.</span> <span class="nav-text">UNWATCH</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值：-3"><span class="nav-number">2.11.5.2.</span> <span class="nav-text">返回值：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-114"><span class="nav-number">2.11.5.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lua-脚本"><span class="nav-number">2.12.</span> <span class="nav-text">Lua 脚本</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#EVAL"><span class="nav-number">2.12.1.</span> <span class="nav-text">EVAL</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#EVAL-script-numkeys-key-key-…-arg-arg-…"><span class="nav-number">2.12.1.1.</span> <span class="nav-text">EVAL script numkeys key [key …] arg [arg …]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在-Lua-数据类型和-Redis-数据类型之间转换"><span class="nav-number">2.12.1.2.</span> <span class="nav-text">在 Lua 数据类型和 Redis 数据类型之间转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#脚本的原子性"><span class="nav-number">2.12.1.3.</span> <span class="nav-text">脚本的原子性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#错误处理"><span class="nav-number">2.12.1.4.</span> <span class="nav-text">错误处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#带宽和-EVALSHA"><span class="nav-number">2.12.1.5.</span> <span class="nav-text">带宽和 EVALSHA</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#EVALSHA-命令的表现如下："><span class="nav-number">2.12.1.6.</span> <span class="nav-text">EVALSHA 命令的表现如下：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#脚本缓存"><span class="nav-number">2.12.1.7.</span> <span class="nav-text">脚本缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SCRIPT-命令"><span class="nav-number">2.12.1.8.</span> <span class="nav-text">SCRIPT 命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#纯函数脚本"><span class="nav-number">2.12.1.9.</span> <span class="nav-text">纯函数脚本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#全局变量保护"><span class="nav-number">2.12.1.10.</span> <span class="nav-text">全局变量保护</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#库"><span class="nav-number">2.12.1.11.</span> <span class="nav-text">库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用脚本散发-Redis-日志"><span class="nav-number">2.12.1.12.</span> <span class="nav-text">使用脚本散发 Redis 日志</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#沙箱-sandbox-和最大执行时间"><span class="nav-number">2.12.1.13.</span> <span class="nav-text">沙箱(sandbox)和最大执行时间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#流水线-pipeline-上下文-context-中的-EVALSHA"><span class="nav-number">2.12.1.14.</span> <span class="nav-text">流水线(pipeline)上下文(context)中的 EVALSHA</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EVALSHA"><span class="nav-number">2.12.2.</span> <span class="nav-text">EVALSHA</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#EVALSHA-sha1-numkeys-key-key-…-arg-arg-…"><span class="nav-number">2.12.2.1.</span> <span class="nav-text">EVALSHA sha1 numkeys key [key …] arg [arg …]</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SCRIPT-LOAD"><span class="nav-number">2.12.3.</span> <span class="nav-text">SCRIPT LOAD</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SCRIPT-LOAD-script"><span class="nav-number">2.12.3.1.</span> <span class="nav-text">SCRIPT LOAD script</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-118"><span class="nav-number">2.12.3.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-115"><span class="nav-number">2.12.3.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SCRIPT-EXISTS"><span class="nav-number">2.12.4.</span> <span class="nav-text">SCRIPT EXISTS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SCRIPT-EXISTS-sha1-sha1-…"><span class="nav-number">2.12.4.1.</span> <span class="nav-text">SCRIPT EXISTS sha1 [sha1 …]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-119"><span class="nav-number">2.12.4.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-116"><span class="nav-number">2.12.4.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SCRIPT-FLUSH"><span class="nav-number">2.12.5.</span> <span class="nav-text">SCRIPT FLUSH</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SCRIPT-FLUSH-1"><span class="nav-number">2.12.5.1.</span> <span class="nav-text">SCRIPT FLUSH</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-120"><span class="nav-number">2.12.5.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-117"><span class="nav-number">2.12.5.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SCRIPT-KILL"><span class="nav-number">2.12.6.</span> <span class="nav-text">SCRIPT KILL</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SCRIPT-KILL-1"><span class="nav-number">2.12.6.1.</span> <span class="nav-text">SCRIPT KILL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-121"><span class="nav-number">2.12.6.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-118"><span class="nav-number">2.12.6.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#持久化"><span class="nav-number">2.13.</span> <span class="nav-text">持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SAVE"><span class="nav-number">2.13.1.</span> <span class="nav-text">SAVE</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SAVE-1"><span class="nav-number">2.13.1.1.</span> <span class="nav-text">SAVE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-122"><span class="nav-number">2.13.1.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-119"><span class="nav-number">2.13.1.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BGSAVE"><span class="nav-number">2.13.2.</span> <span class="nav-text">BGSAVE</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#BGSAVE-1"><span class="nav-number">2.13.2.1.</span> <span class="nav-text">BGSAVE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-123"><span class="nav-number">2.13.2.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-120"><span class="nav-number">2.13.2.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BGREWRITEAOF"><span class="nav-number">2.13.3.</span> <span class="nav-text">BGREWRITEAOF</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#BGREWRITEAOF-1"><span class="nav-number">2.13.3.1.</span> <span class="nav-text">BGREWRITEAOF</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-124"><span class="nav-number">2.13.3.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-121"><span class="nav-number">2.13.3.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LASTSAVE"><span class="nav-number">2.13.4.</span> <span class="nav-text">LASTSAVE</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#LASTSAVE-1"><span class="nav-number">2.13.4.1.</span> <span class="nav-text">LASTSAVE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-125"><span class="nav-number">2.13.4.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-122"><span class="nav-number">2.13.4.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#发布与订阅"><span class="nav-number">2.14.</span> <span class="nav-text">发布与订阅</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#PUBLISH"><span class="nav-number">2.14.1.</span> <span class="nav-text">PUBLISH</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#PUBLISH-channel-message"><span class="nav-number">2.14.1.1.</span> <span class="nav-text">PUBLISH channel message</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-126"><span class="nav-number">2.14.1.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-123"><span class="nav-number">2.14.1.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SUBSCRIBE"><span class="nav-number">2.14.2.</span> <span class="nav-text">SUBSCRIBE</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SUBSCRIBE-channel-channel-…"><span class="nav-number">2.14.2.1.</span> <span class="nav-text">SUBSCRIBE channel [channel …]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-127"><span class="nav-number">2.14.2.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-124"><span class="nav-number">2.14.2.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PSUBSCRIBE"><span class="nav-number">2.14.3.</span> <span class="nav-text">PSUBSCRIBE</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#PSUBSCRIBE-pattern-pattern-…"><span class="nav-number">2.14.3.1.</span> <span class="nav-text">PSUBSCRIBE pattern [pattern …]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-128"><span class="nav-number">2.14.3.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-125"><span class="nav-number">2.14.3.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UNSUBSCRIBE"><span class="nav-number">2.14.4.</span> <span class="nav-text">UNSUBSCRIBE</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#UNSUBSCRIBE-channel-channel-…"><span class="nav-number">2.14.4.1.</span> <span class="nav-text">UNSUBSCRIBE [channel [channel …]]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-129"><span class="nav-number">2.14.4.2.</span> <span class="nav-text">返回值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PUNSUBSCRIBE"><span class="nav-number">2.14.5.</span> <span class="nav-text">PUNSUBSCRIBE</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#PUNSUBSCRIBE-pattern-pattern-…"><span class="nav-number">2.14.5.1.</span> <span class="nav-text">PUNSUBSCRIBE [pattern [pattern …]]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-130"><span class="nav-number">2.14.5.2.</span> <span class="nav-text">返回值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PUBSUB"><span class="nav-number">2.14.6.</span> <span class="nav-text">PUBSUB</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#PUBSUB-argument-argument-…"><span class="nav-number">2.14.6.1.</span> <span class="nav-text">PUBSUB [argument [argument …]]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PUBSUB-CHANNELS-pattern"><span class="nav-number">2.14.6.2.</span> <span class="nav-text">PUBSUB CHANNELS [pattern]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#返回值-131"><span class="nav-number">2.14.6.2.1.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#代码示例-126"><span class="nav-number">2.14.6.2.2.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PUBSUB-NUMSUB-channel-1-…-channel-N"><span class="nav-number">2.14.6.3.</span> <span class="nav-text">PUBSUB NUMSUB [channel-1 … channel-N]</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#返回值-132"><span class="nav-number">2.14.6.3.1.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#代码示例-127"><span class="nav-number">2.14.6.3.2.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PUBSUB-NUMPAT"><span class="nav-number">2.14.6.4.</span> <span class="nav-text">PUBSUB NUMPAT</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#返回值-133"><span class="nav-number">2.14.6.4.1.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#代码示例-128"><span class="nav-number">2.14.6.4.2.</span> <span class="nav-text">代码示例</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#复制"><span class="nav-number">2.15.</span> <span class="nav-text">复制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SLAVEOF"><span class="nav-number">2.15.1.</span> <span class="nav-text">SLAVEOF</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SLAVEOF-host-port"><span class="nav-number">2.15.1.1.</span> <span class="nav-text">SLAVEOF host port</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-134"><span class="nav-number">2.15.1.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-129"><span class="nav-number">2.15.1.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ROLE"><span class="nav-number">2.15.2.</span> <span class="nav-text">ROLE</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ROLE-1"><span class="nav-number">2.15.2.1.</span> <span class="nav-text">ROLE</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#返回值-135"><span class="nav-number">2.15.3.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码示例-130"><span class="nav-number">2.15.4.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#客户端与服务器"><span class="nav-number">2.16.</span> <span class="nav-text">客户端与服务器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AUTH"><span class="nav-number">2.16.1.</span> <span class="nav-text">AUTH</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#AUTH-password"><span class="nav-number">2.16.1.1.</span> <span class="nav-text">AUTH password</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Warning-2"><span class="nav-number">2.16.1.2.</span> <span class="nav-text">Warning</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-136"><span class="nav-number">2.16.1.3.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-131"><span class="nav-number">2.16.1.4.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#QUIT"><span class="nav-number">2.16.2.</span> <span class="nav-text">QUIT</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#QUIT-1"><span class="nav-number">2.16.2.1.</span> <span class="nav-text">QUIT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-137"><span class="nav-number">2.16.2.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-132"><span class="nav-number">2.16.2.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#INFO"><span class="nav-number">2.16.3.</span> <span class="nav-text">INFO</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#INFO-section"><span class="nav-number">2.16.3.1.</span> <span class="nav-text">INFO [section]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Note-8"><span class="nav-number">2.16.3.2.</span> <span class="nav-text">Note</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-138"><span class="nav-number">2.16.3.3.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-133"><span class="nav-number">2.16.3.4.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SHUTDOWN"><span class="nav-number">2.16.4.</span> <span class="nav-text">SHUTDOWN</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SHUTDOWN-SAVE-NOSAVE"><span class="nav-number">2.16.4.1.</span> <span class="nav-text">SHUTDOWN [SAVE|NOSAVE]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#停止所有客户端"><span class="nav-number">2.16.4.2.</span> <span class="nav-text">停止所有客户端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SAVE-和-NOSAVE-修饰符"><span class="nav-number">2.16.4.3.</span> <span class="nav-text">SAVE 和 NOSAVE 修饰符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-139"><span class="nav-number">2.16.4.4.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-134"><span class="nav-number">2.16.4.5.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TIME"><span class="nav-number">2.16.5.</span> <span class="nav-text">TIME</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TIME-1"><span class="nav-number">2.16.5.1.</span> <span class="nav-text">TIME</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-140"><span class="nav-number">2.16.5.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-135"><span class="nav-number">2.16.5.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CLIENT"><span class="nav-number">2.16.6.</span> <span class="nav-text">CLIENT</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CLIENT-GETNAME"><span class="nav-number">2.16.6.1.</span> <span class="nav-text">CLIENT GETNAME</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#返回值-141"><span class="nav-number">2.16.6.1.1.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#代码示例-136"><span class="nav-number">2.16.6.1.2.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CLIENT-KILL-ip-port"><span class="nav-number">2.16.6.2.</span> <span class="nav-text">CLIENT KILL ip:port</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#返回值-142"><span class="nav-number">2.16.6.2.1.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#代码示例-137"><span class="nav-number">2.16.6.2.2.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CLIENT-LIST"><span class="nav-number">2.16.6.3.</span> <span class="nav-text">CLIENT LIST</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#返回值-143"><span class="nav-number">2.16.6.3.1.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Note-9"><span class="nav-number">2.16.6.3.2.</span> <span class="nav-text">Note</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CLIENT-SETNAME-connection-name"><span class="nav-number">2.16.6.4.</span> <span class="nav-text">CLIENT SETNAME connection-name</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Tip"><span class="nav-number">2.16.6.4.1.</span> <span class="nav-text">Tip</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#返回值-144"><span class="nav-number">2.16.6.4.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#代码示例-138"><span class="nav-number">2.16.6.4.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#配置选项"><span class="nav-number">2.17.</span> <span class="nav-text">配置选项</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CONFIG-SET"><span class="nav-number">2.17.1.</span> <span class="nav-text">CONFIG SET</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CONFIG-SET-parameter-value"><span class="nav-number">2.17.1.1.</span> <span class="nav-text">CONFIG SET parameter value</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-145"><span class="nav-number">2.17.1.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-139"><span class="nav-number">2.17.1.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CONFIG-GET"><span class="nav-number">2.17.2.</span> <span class="nav-text">CONFIG GET</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CONFIG-GET-parameter"><span class="nav-number">2.17.2.1.</span> <span class="nav-text">CONFIG GET parameter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-146"><span class="nav-number">2.17.2.2.</span> <span class="nav-text">返回值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CONFIG-RESETSTAT"><span class="nav-number">2.17.3.</span> <span class="nav-text">CONFIG RESETSTAT</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CONFIG-RESETSTAT-1"><span class="nav-number">2.17.3.1.</span> <span class="nav-text">CONFIG RESETSTAT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-147"><span class="nav-number">2.17.3.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-140"><span class="nav-number">2.17.3.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CONFIG-REWRITE"><span class="nav-number">2.17.4.</span> <span class="nav-text">CONFIG REWRITE</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CONFIG-REWRITE-1"><span class="nav-number">2.17.4.1.</span> <span class="nav-text">CONFIG REWRITE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原子性重写"><span class="nav-number">2.17.4.2.</span> <span class="nav-text">原子性重写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-148"><span class="nav-number">2.17.4.3.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-141"><span class="nav-number">2.17.4.4.</span> <span class="nav-text">代码示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#调试"><span class="nav-number">2.18.</span> <span class="nav-text">调试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#PING"><span class="nav-number">2.18.1.</span> <span class="nav-text">PING</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#PING-1"><span class="nav-number">2.18.1.1.</span> <span class="nav-text">PING</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-149"><span class="nav-number">2.18.1.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-142"><span class="nav-number">2.18.1.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ECHO"><span class="nav-number">2.18.2.</span> <span class="nav-text">ECHO</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ECHO-message"><span class="nav-number">2.18.2.1.</span> <span class="nav-text">ECHO message</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-150"><span class="nav-number">2.18.2.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-143"><span class="nav-number">2.18.2.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OBJECT"><span class="nav-number">2.18.3.</span> <span class="nav-text">OBJECT</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#OBJECT-subcommand-arguments-arguments"><span class="nav-number">2.18.3.1.</span> <span class="nav-text">OBJECT subcommand [arguments [arguments]]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-151"><span class="nav-number">2.18.3.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-144"><span class="nav-number">2.18.3.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SLOWLOG"><span class="nav-number">2.18.4.</span> <span class="nav-text">SLOWLOG</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SLOWLOG-subcommand-argument"><span class="nav-number">2.18.4.1.</span> <span class="nav-text">SLOWLOG subcommand [argument]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是-SLOWLOG"><span class="nav-number">2.18.4.2.</span> <span class="nav-text">什么是 SLOWLOG</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#设置-SLOWLOG"><span class="nav-number">2.18.4.3.</span> <span class="nav-text">设置 SLOWLOG</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查看-slow-log"><span class="nav-number">2.18.4.4.</span> <span class="nav-text">查看 slow log</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查看当前日志的数量"><span class="nav-number">2.18.4.5.</span> <span class="nav-text">查看当前日志的数量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#清空日志"><span class="nav-number">2.18.4.6.</span> <span class="nav-text">清空日志</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-152"><span class="nav-number">2.18.4.7.</span> <span class="nav-text">返回值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MONITOR"><span class="nav-number">2.18.5.</span> <span class="nav-text">MONITOR</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MONITOR-1"><span class="nav-number">2.18.5.1.</span> <span class="nav-text">MONITOR</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-153"><span class="nav-number">2.18.5.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-145"><span class="nav-number">2.18.5.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DEBUG-OBJECT"><span class="nav-number">2.18.6.</span> <span class="nav-text">DEBUG OBJECT</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DEBUG-OBJECT-key"><span class="nav-number">2.18.6.1.</span> <span class="nav-text">DEBUG OBJECT key</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-154"><span class="nav-number">2.18.6.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-146"><span class="nav-number">2.18.6.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DEBUG-SEGFAULT"><span class="nav-number">2.18.7.</span> <span class="nav-text">DEBUG SEGFAULT</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DEBUG-SEGFAULT-1"><span class="nav-number">2.18.7.1.</span> <span class="nav-text">DEBUG SEGFAULT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-155"><span class="nav-number">2.18.7.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-147"><span class="nav-number">2.18.7.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内部命令"><span class="nav-number">2.19.</span> <span class="nav-text">内部命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MIGRATE"><span class="nav-number">2.19.1.</span> <span class="nav-text">MIGRATE</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MIGRATE-host-port-key-destination-db-timeout-COPY-REPLACE"><span class="nav-number">2.19.1.1.</span> <span class="nav-text">MIGRATE host port key destination-db timeout [COPY] [REPLACE]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可选项"><span class="nav-number">2.19.1.2.</span> <span class="nav-text">可选项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-156"><span class="nav-number">2.19.1.3.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-148"><span class="nav-number">2.19.1.4.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DUMP"><span class="nav-number">2.19.2.</span> <span class="nav-text">DUMP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DUMP-key"><span class="nav-number">2.19.2.1.</span> <span class="nav-text">DUMP key</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-157"><span class="nav-number">2.19.2.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-149"><span class="nav-number">2.19.2.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RESTORE"><span class="nav-number">2.19.3.</span> <span class="nav-text">RESTORE</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RESTORE-key-ttl-serialized-value-REPLACE"><span class="nav-number">2.19.3.1.</span> <span class="nav-text">RESTORE key ttl serialized-value [REPLACE]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-158"><span class="nav-number">2.19.3.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-150"><span class="nav-number">2.19.3.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SYNC"><span class="nav-number">2.19.4.</span> <span class="nav-text">SYNC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SYNC-1"><span class="nav-number">2.19.4.1.</span> <span class="nav-text">SYNC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-159"><span class="nav-number">2.19.4.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-151"><span class="nav-number">2.19.4.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PSYNC"><span class="nav-number">2.19.5.</span> <span class="nav-text">PSYNC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#PSYNC-master-run-id-offset"><span class="nav-number">2.19.5.1.</span> <span class="nav-text">PSYNC master_run_id offset</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回值-160"><span class="nav-number">2.19.5.2.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码示例-152"><span class="nav-number">2.19.5.3.</span> <span class="nav-text">代码示例</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#转载出处"><span class="nav-number">3.</span> <span class="nav-text">转载出处</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2019</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">SakuraTears</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-area-chart"></i></span> <span class="post-meta-item-text">Site words total count&#58;</span> <span title="Site words total count">334.8k</span></div> <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("05/20/2018 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="本站已运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",250)</script><div class="footer-custom">Thanks to <a target="_blank" href="https://hexo.io/" rel="external nofollow noopener noreferrer">Hexo</a> | <a target="_blank" href="https://github.com/" rel="external nofollow noopener noreferrer">GitHub</a> | <a target="_blank" href="https://nodejs.org/" rel="external nofollow noopener noreferrer">Node.js</a></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script> <span class="site-uv"><i class="fa fa-user">总访客数</i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span> <i class="fa">人</i></span> <span class="site-pv"><i class="fa fa-eye">总浏览量</i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span> <i class="fa">次</i></span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div><div id="needsharebutton-float"><span class="btn"><i class="fa fa-share-alt" aria-hidden="true"></i></span></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'n81D2zVCOBCRyTrhhwoBjui0-gzGzoHsz',
        appKey: '2II35ez36s8c4KvXJNGVeJ5O',
        placeholder: '(*^_^*)看了这么多，可能你有话想说',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
    //新增以下代码即可，可以移除.info下所有子节点。
    var infoEle = document.querySelector('#comments .info');
      if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0){
        infoEle.childNodes.forEach(function(item) {
          item.parentNode.removeChild(item);
        });
      }
  </script><script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script><script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script><script>AV.initialize("n81D2zVCOBCRyTrhhwoBjui0-gzGzoHsz","2II35ez36s8c4KvXJNGVeJ5O")</script><script>function showTime(e){var t=new AV.Query(e),c=[],u=$(".leancloud_visitors");u.each(function(){c.push($(this).attr("id").trim())}),t.containedIn("url",c),t.find().done(function(e){var t=".leancloud-visitors-count";if(0!==e.length){for(var n=0;n<e.length;n++){var o=e[n],i=o.get("url"),s=o.get("time"),r=document.getElementById(i);$(r).find(t).text(s)}for(n=0;n<c.length;n++){i=c[n],r=document.getElementById(i);var l=$(r).find(t);""==l.text()&&l.text(0)}}else u.find(t).text(0)}).fail(function(e,t){console.log("Error: "+t.code+" "+t.message)})}function addCount(i){var e=$(".leancloud_visitors"),s=e.attr("id").trim(),r=e.attr("data-flag-title").trim(),t=new AV.Query(i);t.equalTo("url",s),t.find({success:function(e){if(0<e.length){var t=e[0];t.fetchWhenSave(!0),t.increment("time"),t.save(null,{success:function(e){$(document.getElementById(s)).find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})}else{var n=new i,o=new AV.ACL;o.setPublicReadAccess(!0),o.setPublicWriteAccess(!0),n.setACL(o),n.set("title",r),n.set("url",s),n.set("time",1),n.save(null,{success:function(e){$(document.getElementById(s)).find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to create")}})}},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}$(function(){var e=AV.Object.extend("Counter");1==$(".leancloud_visitors").length?addCount(e):1<$(".post-title-link").length&&showTime(e)})</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css"><script src="/lib/needsharebutton/needsharebutton.js"></script><script>flOptions={iconStyle:"default",boxForm:"horizontal",position:"topRight",networks:"Weibo,Wechat,Douban,QQZone,Twitter,Facebook"},new needShareButton("#needsharebutton-float",flOptions)</script><script type="text/javascript">wpac_init=window.wpac_init||[],wpac_init.push({widget:"Rating",id:12042,el:"wpac-rating",color:"fc6423"}),function(){if(!("WIDGETPACK_LOADED"in window)){WIDGETPACK_LOADED=!0;var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//embed.widgetpack.com/widget.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t.nextSibling)}}()</script><script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script><script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script><script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/javascript" src="/js/src/click.js"></script><script type="text/javascript" src="/js/src/bored.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({model:{scale:1,hHeadPos:.5,vHeadPos:.618},display:{superSample:2,width:250,height:500,position:"right",hOffset:0,vOffset:-20},mobile:{show:!1,scale:.1,motion:!0},react:{opacityDefault:.9,opacityOnHover:.3},log:!1,pluginJsPath:"lib/",pluginModelPath:"assets/",pluginRootPath:"live2dw/",tagMode:!1})</script></body></html>