<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SakuraTears的博客</title>
  
  <subtitle>越努力越幸运</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.sakuratears.top/"/>
  <updated>2020-04-21T08:34:38.200Z</updated>
  <id>https://www.sakuratears.top/</id>
  
  <author>
    <name>SakuraTears</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java 10 局部变量类型推断</title>
    <link href="https://www.sakuratears.top/blog/Java-10-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD.html"/>
    <id>https://www.sakuratears.top/blog/Java-10-局部变量类型推断.html</id>
    <published>2020-04-21T08:31:00.000Z</published>
    <updated>2020-04-21T08:34:38.200Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java一直在逐步减少语法上的冗长。首先是Diamond操作符，现在是var(局部变量类型- <a href="https://openjdk.java.net/jeps/286" rel="external nofollow noopener noreferrer" target="_blank">JEP 286</a>)来在Java中声明变量。</p><p>当我们使用var来声明变量时，不是声明一个变量类型，而是假设它的类型来自它被设置的值。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var str = <span class="string">"Hello world"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"> </span><br><span class="line">String str = <span class="string">"Hello world"</span>;</span><br></pre></td></tr></table></figure><p>在上面的例子中，在第一个语句中，我们将一个字符串设置为变量str，因此它被隐式地假定为字符串类型。第一个语句本质上等价于上面例子中的第二个语句。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="需要同时声明和初始化var"><a href="#需要同时声明和初始化var" class="headerlink" title="需要同时声明和初始化var"></a>需要同时声明和初始化var</h2><p>使用var时，必须在相同的位置初始化变量。</p><p>不能将声明和初始化放在不同的位置。</p><p>如果我们没有在适当的地方初始化变量，那么将会得到编译错误 - <code>Cannot use ‘var’ on variable without initializer</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var i;  <span class="comment">//错误声明定义 - - Cannot use 'var' on variable without initializer</span></span><br><span class="line">         </span><br><span class="line">var j = <span class="number">10</span>; <span class="comment">//正确声明定义</span></span><br><span class="line"> </span><br><span class="line">System.out.println(i);</span><br></pre></td></tr></table></figure><h2 id="var不是关键字"><a href="#var不是关键字" class="headerlink" title="var不是关键字"></a>var不是关键字</h2><p>看起来像，但实际上var不是Java的关键字，所以我们可以命名叫var的变量，这是允许的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var var = <span class="number">10</span>;   <span class="comment">//正确</span></span><br><span class="line">         </span><br><span class="line"><span class="keyword">int</span> var = <span class="number">10</span>;   <span class="comment">//正确</span></span><br></pre></td></tr></table></figure><h2 id="var用法"><a href="#var用法" class="headerlink" title="var用法"></a>var用法</h2><p>var的使用是有限制的，它可以应用在局部变量与初始化参数、for循环等，它不适用于方法参数、构造函数参数、方法返回类型、字段、捕获参数或任何其他类型的变量声明。</p><p>允许使用范围：</p><ul><li>初始化的局部变量</li><li>增强for循环</li><li>普通for循环</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var blogName = <span class="string">"howtodoinjava.com"</span>;</span><br><span class="line">         </span><br><span class="line"><span class="keyword">for</span> ( var object : dataList)&#123;</span><br><span class="line">    System.out.println( object );</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> ( var i = <span class="number">0</span> ; i &lt; dataList.size(); i++ )&#123;</span><br><span class="line">    System.out.println( dataList.get(i) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不允许使用的范围：</p><ul><li>方法参数</li><li>构造函数参数</li><li>方法返回类型</li><li>类字段</li><li>异常捕获参数或者其他类型的变量声明</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//var firstName;    //不允许定义在类里</span></span><br><span class="line">         </span><br><span class="line">    <span class="comment">//public Application(var param)&#123;    //不允许作为构造函数参数</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*try&#123;</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">    &#125; catch(var ex)&#123;    //不允许作为异常捕获参数</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*public var demoMethod()&#123;  //不允许作为方法返回参数</span></span><br><span class="line"><span class="comment">        return null;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*public Integer demoMethod2( var input )&#123;  //不允许作为方法入参</span></span><br><span class="line"><span class="comment">        return null;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="var不是向后兼容的"><a href="#var不是向后兼容的" class="headerlink" title="var不是向后兼容的"></a>var不是向后兼容的</h2><p>由于这是一种新的语言特性，所以使用var编写的代码不会在较低的JDK版本(少于10)中编译。</p><p>所以，只有我们确定要使用它时，才建议使用。</p><h2 id="var不影响性能"><a href="#var不影响性能" class="headerlink" title="var不影响性能"></a>var不影响性能</h2><p>要知道，在Java中，类型不是在运行时推断的，而是在编译时推断的。这意味着生成的字节码与显式类型声明相同 - 它确实包含了关于类型的信息。这意味着在运行时没有进行额外的处理。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>以上就是关于var的全部内容。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java 10" scheme="https://www.sakuratears.top/tags/Java-10/"/>
    
  </entry>
  
  <entry>
    <title>Java 10 基于时间的发布版本</title>
    <link href="https://www.sakuratears.top/blog/Java-10-%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E7%9A%84%E5%8F%91%E5%B8%83%E7%89%88%E6%9C%AC.html"/>
    <id>https://www.sakuratears.top/blog/Java-10-基于时间的发布版本.html</id>
    <published>2020-04-21T08:29:00.000Z</published>
    <updated>2020-04-21T08:30:05.669Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从Java 10开始，Oracle已经适应了基于时间的版本字符串方案[JEP 322]。新的基于时间的模型已经取代了过去基于特性的多年发布模型。与旧版本不同的是，基于时间的新版本不会延迟发布，新功能将每六个月发布一次，对新版本中可以发布哪些功能没有限制。</p><p>更新版本将在每个季度(1月、4月、7月、10月)发布。更新版本将严格限制在新特性的安全问题、回归和bug的修复上。根据计划安排，我们可以说每个特性发布在下一次特性发布之前会收到两次更新。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Java版本格式化"><a href="#Java版本格式化" class="headerlink" title="Java版本格式化"></a>Java版本格式化</h2><p>如果我们在终端运行<code>java -version</code>命令，那么将会得到如下的版本信息输出：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\<span class="title">Lokesh</span>&gt;<span class="title">java</span> -<span class="title">version</span></span></span><br><span class="line"><span class="function"><span class="title">java</span> <span class="title">version</span> "10.0.1" 2018-04-17</span></span><br><span class="line"><span class="function"><span class="title">Java</span>(<span class="title">TM</span>) <span class="title">SE</span> <span class="title">Runtime</span> <span class="title">Environment</span> 18.3 (<span class="title">build</span> 10.0.1+10)</span></span><br><span class="line"><span class="function"><span class="title">Java</span> <span class="title">HotSpot</span>(<span class="title">TM</span>) 64-<span class="title">Bit</span> <span class="title">Server</span> <span class="title">VM</span> 18.3 (<span class="title">build</span> 10.0.1+10, <span class="title">mixed</span> <span class="title">mode</span>)</span></span><br></pre></td></tr></table></figure><p>新的版本号格式是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$FEATURE.$INTERIM.$UPDATE.$PATCH</span><br></pre></td></tr></table></figure><table><thead><tr><th>COUNTER NAME</th><th>DESCRIPTION</th></tr></thead><tbody><tr><td>$FEATURE</td><td>每6个月将增加，如下：JDK 10, JDK 11. (旧称 $MAJOR.)</td></tr><tr><td>$INTERIM</td><td>这个通常是0，在6个月期限内。对于包含兼容的bug修复和增强，但没有不兼容的更改、没有删除特性和对标准api没有更改的非特性发布，它将增加。(旧称：$MINOR)</td></tr><tr><td>$UPDATE</td><td>在处理兼容的更新版本，以修复新特性中的安全问题、倒退和bug时，它将会增加.(旧称：$SECURITY)</td></tr><tr><td>$PATCH</td><td>只有在需要生成紧急版本来修复关键问题时，才会增加它。</td></tr></tbody></table><blockquote><p>将一个版本号中的数字序列与另一个版本号中的数字序列进行逐点比较;例如，10.0.4小于10.1.2。如果一个序列短于另一个序列，则认为短序列缺少的元素小于长序列相应的元素;例如，10.0.2小于10.0.2.1。</p></blockquote><h2 id="Java-Version-API"><a href="#Java-Version-API" class="headerlink" title="Java Version API"></a>Java Version API</h2><p><code>Runtime.version()</code> 使我们可以通过代码去获取版本信息。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Version version = Runtime.version();</span><br><span class="line">version.feature();</span><br><span class="line">version.interim();</span><br><span class="line">version.update();</span><br><span class="line">version.patch();</span><br><span class="line"> </span><br><span class="line">Output:</span><br><span class="line"> </span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>版本的转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Version version = Runtime.Version.parse(<span class="string">"10.0.1"</span>);</span><br><span class="line"> </span><br><span class="line">version.feature();</span><br><span class="line">version.interim();</span><br><span class="line">version.update();</span><br><span class="line">version.patch();</span><br></pre></td></tr></table></figure><h2 id="长期版本支持-LTS"><a href="#长期版本支持-LTS" class="headerlink" title="长期版本支持 (LTS)"></a>长期版本支持 (LTS)</h2><p>主要面向企业客户。Oracle将为LTS版本的产品将提供卓越和持续的支持。此外，这些版本的更新将至少在三年内可用。</p><p>“LTS”在<code>java -version</code>的输出中会突出显示。例如: <code>11.0.2 + 13-LTS</code></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>以上就是关于Java 10 版本的全部内容。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java 10" scheme="https://www.sakuratears.top/tags/Java-10/"/>
    
  </entry>
  
  <entry>
    <title>[转] Java 9特性及增强</title>
    <link href="https://www.sakuratears.top/blog/%5B%E8%BD%AC%5DJava-9%E7%89%B9%E6%80%A7%E5%8F%8A%E5%A2%9E%E5%BC%BA.html"/>
    <id>https://www.sakuratears.top/blog/[转]Java-9特性及增强.html</id>
    <published>2020-04-13T02:54:00.000Z</published>
    <updated>2020-04-13T03:01:32.963Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://howtodoinjava.com/java9/java9-new-features-enhancements/" rel="external nofollow noopener noreferrer" target="_blank">原文链接</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java 9带来了很多新的增强，这些增强将在很大程度上影响我们的编程风格和习惯。最大的变化是Java的模块化。这是Java 8中的Lambdas之后的另一个重大变化。</p><p>本文中，我们将介绍JDK 9的新特性及增强。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="模块化（Java-platform-module-system）"><a href="#模块化（Java-platform-module-system）" class="headerlink" title="模块化（Java platform module system）"></a>模块化（Java platform module system）</h2><p>JPMS (Java平台模块系统)是新版Java 9的核心亮点。它也被称为<a href="https://openjdk.java.net/projects/jigsaw/" rel="external nofollow noopener noreferrer" target="_blank">“Jigshaw计划”</a>。模块是新的结构，就像我们已经有了包一样。使用新的模块化编程开发的应用程序可以看作是具有定义良好的边界和这些模块之间的依赖关系的交互模块的集合。</p><p>JPMS包括对编写模块化应用程序的支持，以及对JDK源代码的模块化。JDK 9附带了大约92个模块(在GA版本中可以进行更改)。Java 9模块系统有一个“Java”。它被称为基模块。它是一个独立的模块，不依赖于任何其他模块。默认情况下，所有其他模块都依赖于“java.base”。</p><p>java模块化编程要点：</p><ol><li>模块通常只是一个jar文件，在根目录下有一个module-info.class文件。</li><li>要使用模块，请将jar文件包含到modulepath中，而不是classpath中。添加到classpath中的模块jar文件是普通的jar文件，而module-info.class文件将被忽略。</li></ol><p>典型的module-info.java类是这样的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> helloworld &#123;</span><br><span class="line">    <span class="keyword">exports</span> com.howtodoinjava.demo;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">module</span> test &#123;</span><br><span class="line">    <span class="keyword">requires</span> helloworld;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于模块化的更多介绍可以查看 <a href="https://www.sakuratears.top/blog/Java-9%E6%A8%A1%E5%9D%97%E5%8C%96.html#more">Java 9模块化</a></p><h2 id="接口私有方法（Interface-Private-Methods）"><a href="#接口私有方法（Interface-Private-Methods）" class="headerlink" title="接口私有方法（Interface Private Methods）"></a>接口私有方法（Interface Private Methods）</h2><p>Java 8允许在接口中编写默认方法，这是一个广受好评的特性。因此，在这之后，接口中缺少的只有私有方法了。从Java 9开始，我们可以在接口中声明私有方法。</p><p>这些私有方法将提高接口内部的代码可重用性。例如，如果两个默认方法需要共享代码，一个私有接口方法将允许它们这样做，但是不会将这个私有方法暴露给它的实现类。</p><p>在接口中使用私有方法有四个规则:</p><ol><li>私有接口方法不能是抽象的。</li><li>私有方法只能在接口内部使用。</li><li>私有静态方法可以在其他静态和非静态接口方法中使用。</li><li>私有非静态方法不能在私有静态方法中使用。</li></ol><p>一个使用私有方法接口的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomCalculator</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">addEvenNumbers</span><span class="params">(<span class="keyword">int</span>... nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> add(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">addOddNumbers</span><span class="params">(<span class="keyword">int</span>... nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> add(n -&gt; n % <span class="number">2</span> != <span class="number">0</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(IntPredicate predicate, <span class="keyword">int</span>... nums)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> IntStream.of(nums)</span><br><span class="line">                .filter(predicate)</span><br><span class="line">                .sum();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于接口私有方法的更多内容可以查看 <a href="https://www.sakuratears.top/blog/Java-9%E6%8E%A5%E5%8F%A3%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95.html#more">Java 9接口私有方法</a></p><h2 id="HTTP-2-Client"><a href="#HTTP-2-Client" class="headerlink" title="HTTP/2 Client"></a>HTTP/2 Client</h2><p>HTTP/1.1客户端在1997年发布。从那以后发生了很大的变化。因此，Java 9引入了一个新的API，它使用起来更干净、更清晰，并且还增加了对HTTP/2的支持。</p><p>新的API使用了3个主要的类:<code>HttpClient</code>, <code>HttpRequest</code>和<code>HttpResponse</code>。</p><p>要发出请求，只需获取客户端、构建请求并发送请求，如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HttpClient httpClient = HttpClient.newHttpClient(); </span><br><span class="line">HttpRequest httpRequest = HttpRequest.newBuilder().uri(<span class="keyword">new</span> URI(<span class="string">"//howtodoinjava.com/"</span>)).GET().build(); </span><br><span class="line">HttpResponse&lt;String&gt; httpResponse = httpClient.send(httpRequest, HttpResponse.BodyHandler.asString()); </span><br><span class="line">System.out.println( httpResponse.body() );</span><br></pre></td></tr></table></figure><p>上面的代码看起来更清晰可读了。</p><p>新的API还支持使用<code>httpClient.sendAsync()</code>方法的异步HTTP请求。它返回<code>CompletableFuture</code>对象，该对象可用于确定请求是否已完成。它还提供了在请求完成后对<code>HttpResponse</code>的访问。最好的一点是，如果你想，你甚至可以在请求完成之前取消它。</p><p>我们来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(httpResponse.isDone()) &#123;</span><br><span class="line">    System.out.println(httpResponse.get().statusCode());</span><br><span class="line">    System.out.println(httpResponse.get().body());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    httpResponse.cancel(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JShell-工具（JShell-–-REPL-Tool）"><a href="#JShell-工具（JShell-–-REPL-Tool）" class="headerlink" title="JShell 工具（JShell – REPL Tool）"></a>JShell 工具（JShell – REPL Tool）</h2><p>JShell是JDK 9发行版附带的新的命令行交互工具[JEP 222]，用于评估用Java编写的声明、语句和表达式。JShell允许我们执行Java代码片段并立即获得结果，而不必创建解决方案或项目。</p><p>Jshell很像linux操作系统中的命令窗口。不同之处在于JShell是特定于Java的。除了执行简单的代码片段外，它还有许多其他功能。如：</p><ol><li>在单独的窗口中启动内建代码编辑器</li><li>在单独的窗口中启动您选择的代码编辑器</li><li>当保存操作在这些外部编辑器中发生时执行代码</li><li>从文件系统加载预先编写的类</li></ol><p>关于JShell的更多内容，请查看 <a href="https://www.sakuratears.top/blog/Java-9-JShell.html#more">Java 9 JShell</a>。</p><h2 id="平台和JVM日志（Platform-and-JVM-Logging）"><a href="#平台和JVM日志（Platform-and-JVM-Logging）" class="headerlink" title="平台和JVM日志（Platform and JVM Logging）"></a>平台和JVM日志（Platform and JVM Logging）</h2><p>JDK 9通过一个新的loging API改进了平台类(JDK类)和JVM组件的日志记录。它允许我们指定自己选择的日志记录框架(例如Log4J2)作为来自JDK类的日志记录消息的日志记录后端。</p><p>关于这个API，我们需要知道以下几点:</p><ol><li>API应该由JDK中的类使用，而不是由应用程序类使用。</li><li>对于我们的应用程序代码，我们将像以前一样继续使用其他日志api。</li><li>该API不允许我们以编程方式配置日志记录器。</li></ol><p>API包含以下内容:</p><ol><li>一个服务接口，<code>java.lang.System.LoggerFinder</code>，它是一个抽象的静态类</li><li>一个接口<code>java.lang.System.Logger</code>，它提供了日志API</li><li>一个重载方法<code>getLogger()</code>位于<code>java.lang.System</code>类，它返回一个logger实例。</li></ol><p>JDK 9还添加了一个新的命令行选项<code>-Xlog</code>，它为我们提供了一个访问所有JVM类中记录的所有消息的单点访问点。</p><p>下面是使用<code>-Xlog</code>选项的语法:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xlog [:][:[][:[][:]]]</span><br></pre></td></tr></table></figure><p>所有选项都是可选的。如果缺少<code>-Xlog</code>中的前一部分，则必须为该部分使用冒号。</p><p>例如，<code>-Xlog::stderr</code>表示所有部件都是默认的，其中输出设置为stderr。</p><p>关于JVM Logging的更多内容，我们后面讨论。</p><h2 id="进程API更新（Process-API-Updates）"><a href="#进程API更新（Process-API-Updates）" class="headerlink" title="进程API更新（Process API Updates）"></a>进程API更新（Process API Updates）</h2><p>在Java 5之前，生成新进程的惟一方法是使用Runtime.getRuntime().exec()方法。然后在Java 5中引入了ProcessBuilder API，它支持一种更干净的生成新进程的方式。现在Java 9增加了一种获取当前进程和任何衍生进程信息的新方法。</p><p>要获取任何进程的信息，现在应该使用<code>java.lang.ProcessHandle.Info</code>接口。这个接口在获取进程较多信息时很有用。如以下进程信息：</p><ol><li>用于启动进程的命令</li><li>命令的参数</li><li>启动过程的时间瞬间</li><li>它和创建它的用户所花费的总时间</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ProcessHandle processHandle = ProcessHandle.current();</span><br><span class="line">ProcessHandle.Info processInfo = processHandle.info();</span><br><span class="line"> </span><br><span class="line">System.out.println( processHandle.getPid() );</span><br><span class="line">System.out.println( processInfo.arguments().isPresent() );</span><br><span class="line">System.out.println( pprocessInfo.command().isPresent() );</span><br><span class="line">System.out.println( processInfo.command().get().contains(<span class="string">"java"</span>) );</span><br><span class="line">System.out.println( processInfo.startInstant().isPresent() );</span><br></pre></td></tr></table></figure><p>要获取新派生进程的信息，请使用<code>process.toHandle()</code>方法获取<code>ProcessHandle</code>实例。剩下的事情如上所述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String javaPrompt = ProcessUtils.getJavaCmd().getAbsolutePath();</span><br><span class="line">ProcessBuilder processBuilder = <span class="keyword">new</span> ProcessBuilder(javaPrompt, <span class="string">"-version"</span>);</span><br><span class="line">Process process = processBuilder.inheritIO().start();</span><br><span class="line">ProcessHandle processHandle = process.toHandle();</span><br></pre></td></tr></table></figure><p>还可以使用<code>ProcessHandle.allProcesses()</code>获取系统中所有可用进程的<code>ProcessHandle</code>流。</p><p>要获得所有子进程的列表(一级的和n级深度的)，可以使用<code>children()</code> 和 <code>descendants()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;ProcessHandle&gt; children    = ProcessHandle.current().children();</span><br><span class="line">Stream&lt;ProcessHandle&gt; descendants = ProcessHandle.current().descendants();</span><br></pre></td></tr></table></figure><h2 id="集合API更新（Collection-API-Updates）"><a href="#集合API更新（Collection-API-Updates）" class="headerlink" title="集合API更新（Collection API Updates）"></a>集合API更新（Collection API Updates）</h2><p>从Java 9开始，我们可以使用新的工厂方法创建不可变集合，如不可变list、不可变set和不可变map。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableCollections</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;String&gt; namesList = List.of(<span class="string">"Lokesh"</span>, <span class="string">"Amit"</span>, <span class="string">"John"</span>);</span><br><span class="line"> </span><br><span class="line">        Set&lt;String&gt; namesSet = Set.of(<span class="string">"Lokesh"</span>, <span class="string">"Amit"</span>, <span class="string">"John"</span>);</span><br><span class="line"> </span><br><span class="line">        Map&lt;String, String&gt; namesMap = Map.ofEntries(</span><br><span class="line">                                    Map.entry(<span class="string">"1"</span>, <span class="string">"Lokesh"</span>),</span><br><span class="line">                                    Map.entry(<span class="string">"2"</span>, <span class="string">"Amit"</span>),</span><br><span class="line">                                    Map.entry(<span class="string">"3"</span>, <span class="string">"Brian"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于更多的集合API更新内容请查看 <a href="https://www.sakuratears.top/blog/Java-9%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E5%8F%98%E6%9B%B4.html#more">Java 9集合相关更新</a></p><h2 id="Stream-API相关更新（Stream-API-Improvements）"><a href="#Stream-API相关更新（Stream-API-Improvements）" class="headerlink" title="Stream API相关更新（Stream API Improvements）"></a>Stream API相关更新（Stream API Improvements）</h2><p>Java 9引入了两种与流交互的新方法，即<code>takeWhile</code>/<code>dropWhile</code>方法。此外，它还添加了两个重载方法，即<code>ofNullable</code>和<code>iterate</code>方法。</p><p>新的方法<code>takeWhile</code>和<code>dropWhile</code>允许我们根据谓词获取流的一部分。</p><ol><li>在一个有序的流上，<code>takeWhile</code>返回从流中取出的与给定谓词匹配的元素的“最长前缀”，从流的开头开始。<code>dropWhile</code>返回未被<code>takeWhile</code>匹配的剩余项。</li><li>在一个无序流上，<code>takeWhile</code>从流的开头开始返回匹配给定谓词(但不是全部)的流元素的子集。<code>dropWhile</code>在删除匹配给定谓词的元素子集后返回剩余的流元素。</li></ol><p>类似地，在Java 8之前，流中不能有<code>null</code>值。它会导致<code>NullPointerException</code>。自Java 9以来，<code>Stream.ofnullable()</code>方法允许我们创建一个单元素流，它包装一个值(如果不是<code>null</code>)，或者是一个空流。从技术上讲，<code>Stream.ofnullable()</code>与在流API上下文中使用<code>null</code>条件检查非常相似。</p><p>关于Stream API更新更多内容，可以查看 <a href="https://www.sakuratears.top/blog/Java-9-Stream-API%E5%8F%98%E6%9B%B4.html#more">Java 9 Stream API更新</a></p><h2 id="多版本JAR引用增强（Multi-Release-JAR-Files）"><a href="#多版本JAR引用增强（Multi-Release-JAR-Files）" class="headerlink" title="多版本JAR引用增强（Multi-Release JAR Files）"></a>多版本JAR引用增强（Multi-Release JAR Files）</h2><p>这个增强与我们如何在jar文件中打包应用程序类有关。在此之前，我们必须将所有类打包到一个jar文件中，并放入另一个希望使用它的应用程序的类路径中。</p><p>使用多版本特性，现在jar可以包含一个类的不同版本——兼容于不同的JDK版本。类的不同版本的信息，以及在哪个JDK版本中哪个类应该被类加载，都存储在<code>MANIFEST.MF</code>文件中。在本例中，<code>MANIFEST.MF</code>文件主要部分包含了条目<code>Multi-Release: true</code>。</p><p>而且，<code>META-INF</code>包含一个版本子目录，它的整数命名的子目录(从9开始(对于Java 9))存储特定于版本的类和资源文件。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">JAR content root</span><br><span class="line">  A.class</span><br><span class="line">  B.class</span><br><span class="line">  C.class</span><br><span class="line">  D.class</span><br><span class="line">  META-INF</span><br><span class="line">     MANIFEST.MF</span><br><span class="line">     versions</span><br><span class="line">        <span class="number">9</span></span><br><span class="line">           A.class</span><br><span class="line">           B.class</span><br></pre></td></tr></table></figure><p>让我们假设在JDK 10中，A.class被更新以利用一些Java 10特性，然后这个Jar文件可以这样更新:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">JAR content root</span><br><span class="line">  A.class</span><br><span class="line">  B.class</span><br><span class="line">  C.class</span><br><span class="line">  D.class</span><br><span class="line">  META-INF</span><br><span class="line">     MANIFEST.MF</span><br><span class="line">     versions</span><br><span class="line">        <span class="number">9</span></span><br><span class="line">           A.class</span><br><span class="line">           B.class</span><br><span class="line">        <span class="number">10</span></span><br><span class="line">           A.class</span><br></pre></td></tr></table></figure><p>这看起来是一个很有用的增强，它解决了在大型应用程序中经常出现的依赖问题，在这些应用程序中，具有不同版本的jar彼此不兼容。这个特性对解决这些场景有很大的帮助。</p><h2 id="Deprecated标签（-Deprecated-Tag-Changes）"><a href="#Deprecated标签（-Deprecated-Tag-Changes）" class="headerlink" title="@Deprecated标签（@Deprecated Tag Changes）"></a>@Deprecated标签（@Deprecated Tag Changes）</h2><p>从Java 9开始，<code>@Deprecated</code>注释将有两个属性，即<code>forRemoval</code>和<code>since</code>。</p><ol><li><code>forRemoval</code>：指示所注释的元素在将来的版本中是否要被删除。</li><li><code>since</code>：它返回注释元素被弃用的版本。</li></ol><p>强烈建议在文档中使用<code>@deprecated</code> javadoc标记解释弃用该API的原因。文档还应该建议并链接到推荐的替换API(如果适用的话)。替换API通常有一些与原API不同的地方，因此也应该作出说明。</p><h2 id="堆栈相关（Stack-Walking）"><a href="#堆栈相关（Stack-Walking）" class="headerlink" title="堆栈相关（Stack Walking）"></a>堆栈相关（Stack Walking）</h2><p>堆栈是后进先出(LIFO)数据结构。在JVM级别，堆栈存储帧。每次调用一个方法时，都会创建一个新帧并将其推到堆栈的顶部。当方法调用完成时，帧将被销毁(从堆栈中弹出)。堆栈上的每个帧都包含自己的局部变量数组，以及自己的操作数堆栈、返回值和对当前方法类的运行时常量池的引用。</p><p>在给定的线程中，在任何点上都只有一个帧是活动的。活动帧称为当前帧，其方法称为当前方法。(<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.2" rel="external nofollow noopener noreferrer" target="_blank">了解更多</a>)</p><p>在Java 8之前，<code>StackTraceElement</code>表示一个堆栈帧。要获得完整的堆栈，必须使用<code>Thread.getStackTrace()</code>和<code>Throwable.getStackTrace()</code>。它返回一个<code>StackTraceElement</code>数组，我们可以迭代该数组以获得所需的信息。</p><p>在Java 9中，引入了一个新的类<code>StackWalker</code>。该类使用当前线程的连续堆栈帧流提供了简单而有效的堆栈遍历。<code>StackWalker</code>类非常高效，因为它对堆栈帧的计算是延迟的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印当前线程的所有堆栈帧的详细信息</span></span><br><span class="line">StackWalker.getInstance () .forEach (system . out:: println);</span><br></pre></td></tr></table></figure><p>我们还可以用这个流做很多其他的事情，我们将在其他的文章中讨论。</p><h2 id="Java-Docs-相关更新（Java-Docs-Updates）"><a href="#Java-Docs-相关更新（Java-Docs-Updates）" class="headerlink" title="Java Docs 相关更新（Java Docs Updates）"></a>Java Docs 相关更新（Java Docs Updates）</h2><p>Java 9增强了<code>javadoc</code>工具来生成HTML5标记。它当前在HTML 4.01中生成页面。</p><p>为了生成HTML5 Javadoc，需要在命令行参数中加入参数<code>-html5</code>。要在命令行生成文档，可以运行以下命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javadoc [options] [packagenames] [sourcefile] [@files]</span><br></pre></td></tr></table></figure></p><p>使用HTML5带来了更简单的HTML5结构的好处。它还实现了<a href="https://www.w3.org/WAI/standards-guidelines/aria/" rel="external nofollow noopener noreferrer" target="_blank">WAI-ARIA standard </a>可访问性标准。这样做的目的是让有生理或视觉缺陷的人更容易使用屏幕阅读器之类的工具访问<code>javadocs</code>页面。</p><p><a href="https://openjdk.java.net/jeps/225" rel="external nofollow noopener noreferrer" target="_blank">JEP 225</a>允许在<code>javadoc</code>中搜索程序元素和带标记的单词和短语。</p><p>以下将被索引和搜索:</p><ul><li>模块的声明名称(Declared names of modules)</li><li>包(Packages)</li><li>类型和成员(Types and members)</li><li>方法参数类型的简单名称(The simple name of method parameter types)</li></ul><p>这是在客户端实现的，带有一个新的<code>search.js</code> Javascript文件，以及在生成<code>javadoc</code>时生成的索引。在生成的HTML5 API页面上有一个搜索框可用。</p><p>请注意，搜索选项将默认添加，但可以关闭参数:<code>-noindex</code>。</p><h2 id="其它特性及增强（Miscellaneous-Other-Features）"><a href="#其它特性及增强（Miscellaneous-Other-Features）" class="headerlink" title="其它特性及增强（Miscellaneous Other Features）"></a>其它特性及增强（Miscellaneous Other Features）</h2><p>在Java 9中还有其他特性，我把它们列在下面以供快速参考。我们将在以后的文章中讨论所有这些特性。</p><ul><li>Reactive Streams API</li><li>GC改进（GC (Garbage Collector) Improvements）</li><li>Filter Incoming Serialization Data</li><li>弃用Applet（Deprecate the Applet API）</li><li>Indify String Concatenation</li><li>Enhanced Method Handles</li><li>Compact Strings</li><li>Nashorn解析器（Parser API for Nashorn）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java 9" scheme="https://www.sakuratears.top/tags/Java-9/"/>
    
  </entry>
  
  <entry>
    <title>Java 9 JShell</title>
    <link href="https://www.sakuratears.top/blog/Java-9-JShell.html"/>
    <id>https://www.sakuratears.top/blog/Java-9-JShell.html</id>
    <published>2020-04-13T02:15:00.000Z</published>
    <updated>2020-04-13T02:32:26.143Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>JShell是JDK 9发行版[JEP 222]附带的新命令行交互式REPL (Read-Evaluate-Print-Loop)控制台，用于计算用Java编写的声明、语句和表达式。JShell允许我们执行Java代码片段并立即获得结果，而不必创建解决方案或项目。</p><p>在本文中，我们将通过示例学习在JShell中可以完成的各种任务。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="运行JShell"><a href="#运行JShell" class="headerlink" title="运行JShell"></a>运行JShell</h2><p>首先要做的是将JDK 9安装到您的计算机中。从这个链接下载<a href="https://jdk.java.net/9/" rel="external nofollow noopener noreferrer" target="_blank">JDK 9</a>并安装它。</p><p>进入安装位置，查看/jdk-9/bin文件夹。我们将在这里找到jshell.exe文件。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-615.png" alt="upload successful"></p><p>现在启动一个新的命令窗口并检查java版本。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; java -version</span><br></pre></td></tr></table></figure><p>它应该指向JDK 9版本。如果不是，则使用相应的值更新环境属性<code>JAVA_HOME</code>和<code>PATH</code>。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME=C:\Program Files\Java\jdk-<span class="number">9</span></span><br><span class="line"><span class="built_in">PATH</span>=C:\Program Files\Java\jdk-<span class="number">9</span>\bin    //<span class="built_in">Path</span> till bin folder</span><br></pre></td></tr></table></figure><p>现在再次启动新的命令提示窗口并输入命令jshell。它将把游标更改为jshell。如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-616.png" alt="upload successful"></p><p>接下来我们来看下如何在JShell REPL中运行了Java相关代码。</p><h2 id="在REPL里编写和运行一段Java代码"><a href="#在REPL里编写和运行一段Java代码" class="headerlink" title="在REPL里编写和运行一段Java代码"></a>在REPL里编写和运行一段Java代码</h2><p>Jshell允许创建小的代码片段并对它们进行测试，而不需要创建和构建复杂的项目。这就是它的用法。</p><p>在JShell上运行代码片段非常容易，我们来看一下。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>我们可以像在实际编程中那样定义变量。唯一不同的是，我们不必一开始就编写一个类或方法。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; int i = <span class="number">10</span>;</span><br><span class="line">i ==&gt; <span class="number">10</span></span><br></pre></td></tr></table></figure><p>要输出变量的值，只需输入变量名并回车。它将输出变量的值。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; i</span><br><span class="line">i ==&gt; <span class="number">10</span></span><br></pre></td></tr></table></figure><p>要将变量重新赋值给新值，只需按常规方式执行即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; i=<span class="number">20</span>;</span><br><span class="line">i ==&gt; <span class="number">20</span></span><br></pre></td></tr></table></figure><p>要列出所有定义的变量，使用 <code>/vars</code> 命令。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; /vars</span><br><span class="line">|    int i = <span class="number">20</span></span><br><span class="line">|    int j = <span class="number">30</span></span><br></pre></td></tr></table></figure><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-617.png" alt="upload successful"></p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>和变量一样，方法也很简单。</p><p>要在JShell中创建方法，需要定义retrun类型、方法名称、参数和方法体定义方法。不需要访问修饰符。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; int sum (int a, int b) &#123;</span><br><span class="line">   ...&gt; return a+b;</span><br><span class="line">   ...&gt; &#125;</span><br><span class="line">|  created method sum(int,int)</span><br></pre></td></tr></table></figure><p>列出所有定义的方法，使用<code>/methods</code> 命令。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; /methods</span><br><span class="line">|    int sum(int,int)</span><br></pre></td></tr></table></figure><p>要使用方法，像普通编程那样调用即可。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; sum(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">$<span class="number">6</span> ==&gt; <span class="number">4</span></span><br></pre></td></tr></table></figure><p>如果我们想查看方法源码，使用<code>/list</code>命令即可，它将展示指定方法的源码。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; /list sum</span><br><span class="line"> </span><br><span class="line"><span class="number">1</span> : int sum (int a, int b) &#123;</span><br><span class="line">   return a+b;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如果想更改方法代码，需要用相同的方法名重写新修改的代码。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; int sum (int a, int b) &#123;</span><br><span class="line">   ...&gt; int c = a+b;</span><br><span class="line">   ...&gt; return c;</span><br><span class="line">   ...&gt; &#125;</span><br><span class="line">|  modified method sum(int,int)</span><br><span class="line"> </span><br><span class="line">jshell&gt; /list sum</span><br><span class="line"> </span><br><span class="line">   <span class="number">3</span> : int sum (int a, int b) &#123;</span><br><span class="line">       int c = a+b;</span><br><span class="line">       return c;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-618.png" alt="upload successful"></p><blockquote><p>请牢记方法重载规则。如果更改了方法参数数量或它们的数据类型，那么它将是一个新方法，并且将有两个方法在JShell中注册。</p></blockquote><h2 id="在JShell编辑器上编写代码"><a href="#在JShell编辑器上编写代码" class="headerlink" title="在JShell编辑器上编写代码"></a>在JShell编辑器上编写代码</h2><p>当只有几行代码时，JShell内联编辑器已经足够好了。但是当代码量开始变大时，我们可能需要一个文件编辑器来修改代码。</p><p>这里我们可以使用JShell编辑器。要启动编辑器，使用 <code>/edit</code>命令 + 要编辑的方法名。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-619.png" alt="upload successful"></p><p>在这里，根据需要更改方法代码并单击Accept按钮。修改后的代码将在Jshell中更新，我们将在提示中收到确认消息。我们可以随时更改代码，保存它，然后退出窗口。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-620.png" alt="upload successful"></p><h2 id="在外部编辑器中编辑代码"><a href="#在外部编辑器中编辑代码" class="headerlink" title="在外部编辑器中编辑代码"></a>在外部编辑器中编辑代码</h2><p>自带的编辑器可以满足大多数需要，但如果你喜欢在任何特定的编辑器上编码，你也可以使用它。</p><p>JShell允许轻松地配置任何外部编辑器来编辑代码片段。只需要获得我们想要使用的编辑器的完整路径，并在JShell中运行<code>/set editor</code>命令来配置编辑器。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/<span class="built_in">set</span> editor "C:\\Program Files\\Sublime Text <span class="number">3</span>\\sublime_text.exe"</span><br></pre></td></tr></table></figure><p>再次执行<code>/edit</code>命令。它将在sublime编辑器中打开代码。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-621.png" alt="upload successful"></p><p>自由编辑代码，并保存。</p><h2 id="将外部Java文件加载到REPL"><a href="#将外部Java文件加载到REPL" class="headerlink" title="将外部Java文件加载到REPL"></a>将外部Java文件加载到REPL</h2><p>很多时候，我们可能已经在任何java文件中编写了一些代码，希望将其执行到JShell中。</p><p>要在JShell中加载文件，使用<code>/open</code>命令。</p><p>假设我在<code>c://temp</code>文件夹中有一个<code>Demo.java</code>文件。它的内容是:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> i2 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> i3 = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">int</span> i4 = <span class="number">40</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在让我们把它加载到JShell。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/open c:\\temp\\demo.java</span><br></pre></td></tr></table></figure><p>可以看到代码被加载到了JShell。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-622.png" alt="upload successful"></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>以上就是在使用Java 9中JShell我们需要了解的内容。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java 9" scheme="https://www.sakuratears.top/tags/Java-9/"/>
    
  </entry>
  
  <entry>
    <title>Java 9 Stream API变更</title>
    <link href="https://www.sakuratears.top/blog/Java-9-Stream-API%E5%8F%98%E6%9B%B4.html"/>
    <id>https://www.sakuratears.top/blog/Java-9-Stream-API变更.html</id>
    <published>2020-04-13T02:12:00.000Z</published>
    <updated>2020-04-13T02:13:11.734Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java 9 Stream API新增了 <code>takeWhile</code> / <code>dropWhile</code>, <code>ofNullable</code> ,<code>iterate</code> 等方法。</p><p>我们通过例子来了解下它们。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="使用takeWhile-和dropWhile-方法对流进行限制"><a href="#使用takeWhile-和dropWhile-方法对流进行限制" class="headerlink" title="使用takeWhile()和dropWhile()方法对流进行限制"></a>使用takeWhile()和dropWhile()方法对流进行限制</h2><p>新的方法<code>takeWhile</code>和<code>dropWhile</code>允许我们根据谓词获取流的一部分。</p><p>这里的流可以是有序的，也可以是无序的，所以:</p><ol><li>在一个有序的流上，<code>takeWhile</code>返回从流中取出的与给定谓词匹配的元素的“最长前缀”，从流的开头开始。</li><li>在一个无序流上，<code>takeWhile</code>从流的开头开始返回匹配给定谓词(但不是全部)的流元素的子集。</li></ol><p><code>dropWhile</code>方法与<code>takeWhile</code>方法相反。</p><ol><li>在一个有序的流中，<code>dropWhile</code>返回与给定谓词匹配的“最长前缀”之后的剩余项。</li><li>在一个无序的流上，<code>dropWhile</code>在删除匹配给定谓词的元素子集后返回剩余的流元素。</li></ol><h2 id="takeWhile和dropWhile的例子"><a href="#takeWhile和dropWhile的例子" class="headerlink" title="takeWhile和dropWhile的例子"></a>takeWhile和dropWhile的例子</h2><p>在本例中，我们有一个从’a’到’i’的字符List。我想要在迭代中获取出现在’d’之前的所有字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; alphabets = List.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>, <span class="string">"g"</span>, <span class="string">"h"</span>, <span class="string">"i"</span>);</span><br><span class="line"> </span><br><span class="line">List&lt;String&gt; subset1 = alphabets</span><br><span class="line">        .stream()</span><br><span class="line">        .takeWhile(s -&gt; !s.equals(<span class="string">"d"</span>))</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line"> </span><br><span class="line">System.out.println(subset1);</span><br><span class="line"> </span><br><span class="line">Output:</span><br><span class="line"> </span><br><span class="line">[a, b, c]</span><br></pre></td></tr></table></figure><p>如前所述，<code>dropWhile</code>的作用与<code>takeWhile</code>方法相反，因此在上面的例子中，如果使用<code>dropWhile</code>方法，它将返回<code>takeWhile</code>谓词所留下的所有字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; alphabets = List.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>, <span class="string">"g"</span>, <span class="string">"h"</span>, <span class="string">"i"</span>);</span><br><span class="line"> </span><br><span class="line">List&lt;String&gt; subset2 = alphabets</span><br><span class="line">        .stream()</span><br><span class="line">        .dropWhile(s -&gt; !s.equals(<span class="string">"d"</span>))</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line"> </span><br><span class="line">System.out.println(subset2);</span><br><span class="line"> </span><br><span class="line">Output:</span><br><span class="line"> </span><br><span class="line">[d, e, f, g, h, i]</span><br></pre></td></tr></table></figure><h2 id="重载流的iterate方法"><a href="#重载流的iterate方法" class="headerlink" title="重载流的iterate方法"></a>重载流的iterate方法</h2><p><code>iterate()</code>方法，用于创建以单个元素(the seed)开始的流，并通过连续应用一元运算符生成后续元素，结果是一个无限的流。</p><p>要终止流，需要使用限制或其他一些短路函数，如<code>findFirst</code>或<code>findAny</code>。</p><p>Java 8中的<code>iterate</code>方法有这样的签名:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Stream <span class="title">iterate</span><span class="params">(<span class="keyword">final</span> T seed, <span class="keyword">final</span> UnaryOperator f)</span></span></span><br></pre></td></tr></table></figure><p>在Java 9中，新的重载版本的iterate将一个谓词作为第二个参数:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Stream <span class="title">iterate</span><span class="params">(T seed, Predicate hasNext, UnaryOperator next)</span></span></span><br></pre></td></tr></table></figure><p>让我们看看Java 8和Java 9之间<code>iterate</code>方法使用的不同之处。</p><p><em>iterate method in Java 8</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Stream.iterate(<span class="number">1</span>, i -&gt; i+<span class="number">1</span>)</span><br><span class="line">                            .limit(<span class="number">10</span>)</span><br><span class="line">                            .collect(Collectors.toList());</span><br><span class="line">         </span><br><span class="line">System.out.println(numbers);</span><br><span class="line"> </span><br><span class="line">Output:</span><br><span class="line"> </span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><p><em>iterate method in Java 9</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Stream.iterate(<span class="number">1</span>, i -&gt; i &lt;= <span class="number">10</span> ,i -&gt; i+<span class="number">1</span>)</span><br><span class="line">                                .collect(Collectors.toList());</span><br><span class="line"> </span><br><span class="line">System.out.println(numbers);</span><br><span class="line"> </span><br><span class="line">Output:</span><br><span class="line"> </span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><p>在上面的例子中，第一个流是使用带有限制的<code>iterate</code>的Java 8方式。第二个使用谓词作为第二个参数。</p><h2 id="新方法ofNullable"><a href="#新方法ofNullable" class="headerlink" title="新方法ofNullable()"></a>新方法ofNullable()</h2><p>在Java 8之前，流中不能有<code>null</code>值。它会导致<code>NullPointerException</code>。</p><p>在Java 9中，<code>ofNullable</code>方法允许我们创建一个单元素流，该流包装一个值(如果不是null)，或者是一个空流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.ofNullable(<span class="string">"123"</span>);</span><br><span class="line">System.out.println(stream.count());</span><br><span class="line"> </span><br><span class="line">stream = Stream.ofNullable(<span class="keyword">null</span>);</span><br><span class="line">System.out.println(stream.count());</span><br><span class="line"> </span><br><span class="line">Output:</span><br><span class="line"> </span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>这里，<code>count</code>方法返回流中非空元素的数量。</p><p>从技术上讲，<code>Stream.ofnullable()</code>与在流API上下文中使用<code>null</code>条件检查非常相似。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java 9" scheme="https://www.sakuratears.top/tags/Java-9/"/>
    
  </entry>
  
  <entry>
    <title>Java 9集合相关变更</title>
    <link href="https://www.sakuratears.top/blog/Java-9%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E5%8F%98%E6%9B%B4.html"/>
    <id>https://www.sakuratears.top/blog/Java-9集合相关变更.html</id>
    <published>2020-04-13T02:10:00.000Z</published>
    <updated>2020-04-13T02:11:30.393Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java 9 对于不可变集合可以使用工厂模式进行创建，我们来看一下，如何来创建不可变List、不可变Map、不可变Set。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="创建不可变List（Immutable-List）"><a href="#创建不可变List（Immutable-List）" class="headerlink" title="创建不可变List（Immutable List）"></a>创建不可变List（Immutable List）</h2><p>使用<code>List.of()</code>静态工厂方法创建不可变列表。它有以下不同的重载版本:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;E&gt; <span class="function">List&lt;E&gt;  <span class="title">of</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt;  <span class="title">of</span><span class="params">(E e1)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt;  <span class="title">of</span><span class="params">(E e1, E e2)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt;  <span class="title">of</span><span class="params">(E e1, E e2, E e3)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt;  <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt;  <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt;  <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5, E e6)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt;  <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5, E e6, E e7)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt;  <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt;  <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt;  <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10)</span></span></span><br><span class="line"><span class="function"><span class="comment">//varargs</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt;  <span class="title">of</span><span class="params">(E... elements)</span></span></span><br></pre></td></tr></table></figure><p>这些方法创建的<code>List</code>实例具有以下特征:</p><ol><li>这些<code>List</code>是不可变的。在这些<code>List</code>中不能添加、删除或替换元素。调用任何<code>mutator</code>方法(即<code>add</code>、<code>addAll</code>、<code>clear</code>、<code>remove</code>、<code>removeAll</code>、<code>replaceAll</code>)总是会引发<code>UnsupportedOperationException</code>。</li><li>它们不允许空元素。尝试添加空元素会导致<code>NullPointerException</code>。</li><li>如果所有元素都是可序列化的，则它们是可序列化的。</li><li>列表中元素的顺序与提供的参数或提供的数组中的元素的顺序相同。</li></ol><p>让我们来看几个使用不可变列表的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.howtodoinjava;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableCollections</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;String&gt; names = List.of(<span class="string">"Lokesh"</span>, <span class="string">"Amit"</span>, <span class="string">"John"</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//Preserve the elements order</span></span><br><span class="line">        System.out.println(names);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//names.add("Brian"); //UnsupportedOperationException occured</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//java.lang.NullPointerException</span></span><br><span class="line">        <span class="comment">//List&lt;String&gt; names2 = List.of("Lokesh", "Amit", "John", null); </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Output:</span><br><span class="line"> </span><br><span class="line">[Lokesh, Amit, John]</span><br></pre></td></tr></table></figure><h2 id="创建不可变Set（Immutable-Set）"><a href="#创建不可变Set（Immutable-Set）" class="headerlink" title="创建不可变Set（Immutable Set）"></a>创建不可变Set（Immutable Set）</h2><p><code>Set</code>的行为与<code>List</code>非常相似，只有很少的区别。如：</p><ol><li>设置不允许重复的元素。传递的任何重复元素都会导致<code>IllegalArgumentException</code>。</li><li>集合元素的迭代顺序是未指定的，可能会发生变化。</li></ol><p>所有的<code>Set</code>工厂方法都具有与<code>List</code>相同的签名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;E&gt; <span class="function">Set&lt;E&gt;   <span class="title">of</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt;   <span class="title">of</span><span class="params">(E e1)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt;   <span class="title">of</span><span class="params">(E e1, E e2)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt;   <span class="title">of</span><span class="params">(E e1, E e2, E e3)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt;   <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt;   <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt;   <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5, E e6)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt;   <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5, E e6, E e7)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt;   <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt;   <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt;   <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10)</span></span></span><br><span class="line"><span class="function"><span class="comment">//varargs</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt;   <span class="title">of</span><span class="params">(E... elements)</span></span></span><br></pre></td></tr></table></figure><p>我们来看几个不可变<code>Set</code>的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableCollections</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; names = Set.of(<span class="string">"Lokesh"</span>, <span class="string">"Amit"</span>, <span class="string">"John"</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//Elements order not fixed</span></span><br><span class="line">        System.out.println(names);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//names.add("Brian"); //UnsupportedOperationException occured</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//java.lang.NullPointerException</span></span><br><span class="line">        <span class="comment">//Set&lt;String&gt; names2 = Set.of("Lokesh", "Amit", "John", null); </span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//java.lang.IllegalArgumentException</span></span><br><span class="line">        <span class="comment">//Set&lt;String&gt; names3 = Set.of("Lokesh", "Amit", "John", "Amit"); </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建不可变Map（Immutable-Map）"><a href="#创建不可变Map（Immutable-Map）" class="headerlink" title="创建不可变Map（Immutable Map）"></a>创建不可变Map（Immutable Map）</h2><p><code>Map</code>工厂方法与<code>List</code>或<code>Set</code>重载工厂方法相同。唯一的区别是方法的签名采用交替的键和值作为参数。如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">Map&lt;K,V&gt;   <span class="title">of</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;K,V&gt; Map&lt;K,V&gt;   <span class="title">of</span><span class="params">(K k1, V v1)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;K,V&gt; Map&lt;K,V&gt;   <span class="title">of</span><span class="params">(K k1, V v1, K k2, V v2)</span></span></span><br><span class="line"><span class="function">...</span></span><br><span class="line"><span class="function">...</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;K,V&gt; Map&lt;K,V&gt;   <span class="title">ofEntries</span><span class="params">(Map.Entry&lt;? extends K,? extends V&gt;... entries)</span></span></span><br></pre></td></tr></table></figure><p>Java 9 还提供了一个特殊的方法来创建<code>Map</code>实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; Map.Entry&lt;K,V&gt; entry​(K k, V v)</span><br></pre></td></tr></table></figure><p>我们来看几个Java 9 创建不可变<code>Map</code>的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableCollections</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; names = Map.ofEntries(</span><br><span class="line">                Map.entry(<span class="string">"1"</span>, <span class="string">"Lokesh"</span>),</span><br><span class="line">                Map.entry(<span class="string">"2"</span>, <span class="string">"Amit"</span>),</span><br><span class="line">                Map.entry(<span class="string">"3"</span>, <span class="string">"Brian"</span>));</span><br><span class="line">         </span><br><span class="line">        System.out.println(names);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//UnsupportedOperationException</span></span><br><span class="line">        <span class="comment">//names.put("2", "Ravi");</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Output:</span><br><span class="line"> </span><br><span class="line">&#123;<span class="number">1</span>=Lokesh, <span class="number">2</span>=Amit, <span class="number">3</span>=Brian&#125;</span><br></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>可以看到在Java 9中创建不可变集合的新工厂方法非常易读且易于使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java 9" scheme="https://www.sakuratears.top/tags/Java-9/"/>
    
  </entry>
  
  <entry>
    <title>Java 9接口私有方法</title>
    <link href="https://www.sakuratears.top/blog/Java-9%E6%8E%A5%E5%8F%A3%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95.html"/>
    <id>https://www.sakuratears.top/blog/Java-9接口私有方法.html</id>
    <published>2020-04-13T02:08:00.000Z</published>
    <updated>2020-04-13T02:10:08.591Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从Java 9开始，我们可以在接口中包含私有方法。使用私有方法，现在在接口中也可以进行封装。</p><p>在本文中，我们将详细了解接口私有方法。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Java-7之前的接口"><a href="#Java-7之前的接口" class="headerlink" title="Java 7之前的接口"></a>Java 7之前的接口</h2><p>在Java 7和所有早期版本中，接口非常简单。它们只能包含公共抽象方法（public abstract method）。这些接口方法必须由选择实现接口的类来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClass</span> <span class="keyword">implements</span> <span class="title">CustomInterface</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        CustomInterface instance = <span class="keyword">new</span> CustomClass();</span><br><span class="line">        instance.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Output:</span><br><span class="line"> </span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure><h2 id="Java-8的接口"><a href="#Java-8的接口" class="headerlink" title="Java 8的接口"></a>Java 8的接口</h2><p>从Java 8开始，除了公共抽象方法之外，接口还可以拥有公共静态方法（public static method）和默认方法（public default method）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomInterface</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"default method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"static method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClass</span> <span class="keyword">implements</span> <span class="title">CustomInterface</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"abstract method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        CustomInterface instance = <span class="keyword">new</span> CustomClass();</span><br><span class="line">        instance.method1();</span><br><span class="line">        instance.method2();</span><br><span class="line">        CustomInterface.method3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Output:</span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> method</span><br><span class="line"><span class="keyword">default</span> method</span><br><span class="line"><span class="keyword">static</span> method</span><br></pre></td></tr></table></figure><blockquote><p>在以上接口方法声明中，访问修饰符“public”是可选的。添加它们只是为了提高可读性。</p></blockquote><h2 id="Java-9的接口"><a href="#Java-9的接口" class="headerlink" title="Java 9的接口"></a>Java 9的接口</h2><p>从Java 9开始，我们将能够在接口中添加私有方法（private methods）和私有静态方法（private static method）。</p><p>这些私有方法将提高接口内部的代码可重用性。</p><p>例如，如果两个默认方法需要共享代码，那么提供一个私有接口方法即可，但是不会将这个私有方法暴露给它的实现类。</p><p>在接口中使用私有方法有四个规则:</p><ol><li>私有接口方法不能是抽象的。</li><li>私有方法只能在接口内部使用。</li><li>私有静态方法可以在其他静态和非静态接口方法中使用。</li><li>私有非静态方法不能在私有静态方法中使用。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomInterface</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method4();  <span class="comment">//private method inside default method</span></span><br><span class="line">        method5();  <span class="comment">//static method inside other non-static method</span></span><br><span class="line">        System.out.println(<span class="string">"default method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method5(); <span class="comment">//static method inside other static method</span></span><br><span class="line">        System.out.println(<span class="string">"static method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"private method"</span>);</span><br><span class="line">    &#125; </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"private static method"</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClass</span> <span class="keyword">implements</span> <span class="title">CustomInterface</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"abstract method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        CustomInterface instance = <span class="keyword">new</span> CustomClass();</span><br><span class="line">        instance.method1();</span><br><span class="line">        instance.method2();</span><br><span class="line">        CustomInterface.method3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Output:</span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> method</span><br><span class="line"><span class="keyword">private</span> method</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> method</span><br><span class="line"><span class="keyword">default</span> method</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> method</span><br><span class="line"><span class="keyword">static</span> method</span><br></pre></td></tr></table></figure><h2 id="Java-9私有方法例子"><a href="#Java-9私有方法例子" class="headerlink" title="Java 9私有方法例子"></a>Java 9私有方法例子</h2><p>让我们看一个示例来理解私有接口方法的用法。</p><p>我们创建一个具有两个函数的计算器类。第一个函数将接受一些整数并在其中添加所有偶数。第二个函数将接受一些整数并在其中添加所有奇数。</p><p><em>CustomCalculator.java – Interface</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.IntPredicate;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomCalculator</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">addEvenNumbers</span><span class="params">(<span class="keyword">int</span>... nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> add(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">addOddNumbers</span><span class="params">(<span class="keyword">int</span>... nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> add(n -&gt; n % <span class="number">2</span> != <span class="number">0</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(IntPredicate predicate, <span class="keyword">int</span>... nums)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> IntStream.of(nums)</span><br><span class="line">                .filter(predicate)</span><br><span class="line">                .sum();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>Main.java – Class</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">implements</span> <span class="title">CustomCalculator</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CustomCalculator demo = <span class="keyword">new</span> Main();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">int</span> sumOfEvens = demo.addEvenNumbers(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>);</span><br><span class="line">        System.out.println(sumOfEvens);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">int</span> sumOfOdds = demo.addOddNumbers(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>);</span><br><span class="line">        System.out.println(sumOfOdds);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Output:</span><br><span class="line"> </span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>简而言之，Java 9私有接口方法可以是静态的，也可以是实例的。在这两种情况下，私有方法都不会被子接口或实现继承。它们主要用于提高接口中的代码可重用性，从而提高封装性。</p><p>让我们回顾一下Java 9中允许的所有方法类型。</p><table><thead><tr><th>METHOD TYPE</th><th style="text-align:center">SINCE WHEN</th></tr></thead><tbody><tr><td>public abstract</td><td style="text-align:center">Java 7</td></tr><tr><td>public default</td><td style="text-align:center">Java 8</td></tr><tr><td>public static</td><td style="text-align:center">Java 8</td></tr><tr><td>private</td><td style="text-align:center">Java 9</td></tr><tr><td>private static</td><td style="text-align:center">Java 9</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java 9" scheme="https://www.sakuratears.top/tags/Java-9/"/>
    
  </entry>
  
  <entry>
    <title>Java 9模块化</title>
    <link href="https://www.sakuratears.top/blog/Java-9%E6%A8%A1%E5%9D%97%E5%8C%96.html"/>
    <id>https://www.sakuratears.top/blog/Java-9模块化.html</id>
    <published>2020-04-13T01:58:00.000Z</published>
    <updated>2020-04-13T02:06:34.271Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>JPMS（Java Platform Module System） Java平台模块系统是Java 9的主要增强。它也被称为Jigsaw项目。在本文中，我们将简单学习模块，以及在将来开始编写模块化代码时，编程风格将如何变化。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="什么是模块？"><a href="#什么是模块？" class="headerlink" title="什么是模块？"></a>什么是模块？</h2><p>在任何编程语言中，模块(类似于包)都是包含代码的构件，其中包含描述模块及其与其他模块的关系的元数据。理想情况下，这些构件从编译时一直到运行时都是可识别的。任何应用程序通常都是多个模块的组合，这些模块一起工作以执行业务目标。</p><p>在应用程序架构方面，模块应该表示特定的业务功能。对于该功能，它应该是自给自足的，并且应该只公开使用模块功能的接口。为了完成它的任务，它可能依赖于其他模块，它应该显式地声明这些模块。</p><p>因此，简而言之，一个模块应该遵循三个核心原则：</p><ul><li><p>强大的封装（Strong Encapsulation）</p><p>  封装意味着隐藏实现细节，这些细节对于正确使用模块并不重要。其目的是封装的代码可以自由改变而不影响模块的用户。</p></li><li><p>稳定的抽象（Stable Abstraction）</p><p>  抽象有助于使用接口(即公共api)公开模块功能。任何时候，如果想要更改模块代码中的业务逻辑或实现，更改对模块用户都是透明的。</p></li><li><p>显式的依赖关系（Explicit dependencies）</p><p>  模块也可以依赖于其他模块。这些外部依赖必须是模块定义本身的一部分。模块之间的这些依赖关系通常用图表示。一旦您看到应用程序级别的图，您将更好地理解应用程序的体系结构。</p></li></ul><h2 id="Java-9模块化介绍"><a href="#Java-9模块化介绍" class="headerlink" title="Java 9模块化介绍"></a>Java 9模块化介绍</h2><p>在Java 9之前，我们有“包（packages）”来根据业务功能对相关类进行分组。除了包之外，还有“访问修饰符”来控制哪些是可见的，哪些是隐藏在其他类或包中的。到目前为止，它运行得很好。Java对封装和抽象提供了强大的支持。</p><p>但是，显式依赖关系是事情开始崩溃的地方。在java中，依赖项是用“import”语句声明的;但是它们是严格的“编译时”构造。一旦代码被编译，就没有明确的机制来声明它的运行时依赖关系。事实上，java运行时依赖项解析是一个非常有问题的领域，因此专门创建了一些工具来解决这个问题，例如gradle或maven。此外，很少有框架捆绑它们的完整运行时依赖项，例如Spring boot项目。</p><p>有了新的Java 9模块，我们将能够更好地编写结构良好的应用程序。这种增强分为两个方面:</p><ol><li>模块化JDK本身。</li><li>提供一个模块系统供其他应用程序使用。</li></ol><blockquote><p>Java 9模块系统有一个“java.base”模块。它被称为基模块。它是一个独立的模块，不依赖于任何其他模块。默认情况下，所有其他模块都依赖于“java.base”。</p></blockquote><p>在Java 9中，模块帮助我们封装包并管理依赖项。所以通常情况下,</p><ul><li>类是字段和方法的容器</li><li>包是类和接口的容器</li><li>模块是包的容器</li></ul><p>如果我们不知道要查找的具体内容，那么我们不会感觉到普通代码和模块化代码之间的任何主要区别。如：</p><ul><li>模块通常只是一个jar文件，在根目录下有一个<code>module-info.class</code>文件。</li><li>要使用模块，请将jar文件包含到<code>modulepath</code>中，而不是<code>classpath</code>中。添加到<code>classpath</code>中的模块jar文件是普通的jar文件，而<code>module-info.class</code>文件将被忽略。</li></ul><h2 id="如何编写模块化代码"><a href="#如何编写模块化代码" class="headerlink" title="如何编写模块化代码"></a>如何编写模块化代码</h2><p>在阅读了所有上述概念之后，让我们看看模块化代码是如何在现实中编写的。我使用Netbeans IDE是因为它对Java 9有很好的早期支持(到今天为止)。</p><h3 id="创建Java模块项目"><a href="#创建Java模块项目" class="headerlink" title="创建Java模块项目"></a>创建Java模块项目</h3><p>创建一个Java模块项目，命名为<code>JavaAppOne</code>。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-610.jpg" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-611.jpg" alt="upload successful"></p><h3 id="创建Java模块"><a href="#创建Java模块" class="headerlink" title="创建Java模块"></a>创建Java模块</h3><p>我们向这个项目中添加两个模块，如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-612.jpg" alt="upload successful"></p><p>我向项目中添加了<code>helloworld</code>和<code>test</code> 模块，它们的结构如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-613.jpg" alt="upload successful"></p><p>相关代码如下：</p><p><code>/helloworld/module-info.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> helloworld &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HelloWorldApp.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.howtodoinjava.demo;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello from HelloWorldApp"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>/test/module-info.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> test &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TestApp.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//some code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到目前为止，模块是独立的。现在假设，我们想在TestApp类中使用<code>HelloWorldApp.sayHello()</code>方法。如果我们尝试在不导入模块的情况下使用该类，我们将得到编译时错误“package com.howtodoinjava.demo is not visible”。</p><h3 id="导入模块信息"><a href="#导入模块信息" class="headerlink" title="导入模块信息"></a>导入模块信息</h3><p>为了能够导入<code>HelloWorldApp</code>，我们必须首先从<code>helloworld</code>模块导出“com.howtodoinjava.demo”包，然后在<code>test</code>模块中包含<code>helloworld</code>模块。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> helloworld &#123;</span><br><span class="line">    <span class="keyword">exports</span> com.howtodoinjava.demo;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">module</span> test &#123;</span><br><span class="line">    <span class="keyword">requires</span> helloworld;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，<code>require</code>关键字表示依赖项，<code>exports</code>关键字标识可以导出到其他模块的包。只有当一个包被显式导出时，才能从其他模块访问它。模块内未导出的包在默认情况下无法从其他模块访问。</p><p>现在我们可以在<code>TestApp</code>类中使用<code>HelloWorldApp</code>类了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.howtodoinjava.demo.HelloWorldApp;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloWorldApp.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Output:</span><br><span class="line"> </span><br><span class="line">Hello from HelloWorldApp</span><br></pre></td></tr></table></figure><p>模块关系图如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-614.jpg" alt="upload successful"></p><blockquote><p>从Java 9开始，<code>public</code>意味着只对该模块内的所有其他包公开。只有在导出包含公共类型的包时，其他模块才能使用它。</p></blockquote><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>模块化应用程序有许多优点，当我们遇到具有非模块化代码库的应用程序时，我们会更加欣赏这些优点。模块化并不是什么灵丹妙药，但它是一种体系结构原则，如果应用得当，可以在很大程度上避免项目依赖混乱问题。</p><p>有了JPMS, Java向成为模块化语言迈出了一大步。这个决定是对是错，只有时间能证明。第三方库和框架如何适应和使用模块系统将会很有趣。以及它将如何影响开发工作，由我们来见证。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java 9" scheme="https://www.sakuratears.top/tags/Java-9/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV的使用（二） - 人脸的识别与训练</title>
    <link href="https://www.sakuratears.top/blog/OpenCV%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89-%E4%BA%BA%E8%84%B8%E7%9A%84%E8%AF%86%E5%88%AB%E4%B8%8E%E8%AE%AD%E7%BB%83.html"/>
    <id>https://www.sakuratears.top/blog/OpenCV的使用（二）-人脸的识别与训练.html</id>
    <published>2020-01-05T09:38:00.000Z</published>
    <updated>2020-01-05T09:42:54.924Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上篇文章我们讲到了OpenCV的安装和简单使用，<a href="https://www.sakuratears.top/blog/OpenCV%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89.html#more">OpenCV简介及使用（一）</a>。</p><p>这篇文章我们来看下如何使用OpenCV进行图像的识别与训练。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>由于OpenCV自带人脸识别及检测功能，我们来看下如何使用OpenCV来分辨人脸。</p><p>如果要进行人脸识别及训练，需要用到人脸灰度图，且有一定的数量，图片宽高需要保持一致。</p><p>上篇文章已经说到如何寻找并裁剪人脸，然后我们将它置灰即可，需要调用<code>org.bytedeco.opencv.global.opencv_imgproc.cvtColor</code>方法，如代码所示<code>cvtColor(image,image,COLOR_BGR2GRAY)</code>。</p><p>其中第一个image是原Mat图，第二个image是生成的Mat图，两个设置成一样则生成的灰度图会覆盖原图，<code>COLOR_BGR2GRAY</code>表示生成的图片颜色。</p><p>则生成灰度图代码大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Mat <span class="title">detectFace</span><span class="params">(String sourceImage, String targetImage,<span class="keyword">int</span> width,<span class="keyword">int</span> height)</span></span>&#123;</span><br><span class="line">    CascadeClassifier faceDetector = <span class="keyword">new</span> CascadeClassifier(CASCADE_FACE_FILENAME);</span><br><span class="line">    <span class="keyword">if</span>(faceDetector.empty())&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"处理文件时发生异常！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Mat image = imread(sourceImage);</span><br><span class="line">    RectVector rectVector = <span class="keyword">new</span> RectVector();</span><br><span class="line">    <span class="comment">// 进行人脸检测</span></span><br><span class="line">    faceDetector.detectMultiScale(image, rectVector);</span><br><span class="line"></span><br><span class="line">    Rect[] rects = rectVector.get();</span><br><span class="line">    <span class="keyword">if</span>(rects.length &lt;=<span class="number">0</span> )&#123;</span><br><span class="line">        log.error(<span class="string">"原图片上未检测到人脸：&#123;&#125;"</span>,sourceImage);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"原图片上未检测到人脸！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(rects.length &gt;<span class="number">1</span>)&#123;</span><br><span class="line">        log.error(<span class="string">"原图片上检测到多个人脸：&#123;&#125;"</span>,sourceImage);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"原图片上检测到多个人脸！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Rect rect = rects[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//人脸裁剪</span></span><br><span class="line">    image = <span class="keyword">new</span> Mat(image,rect);</span><br><span class="line">    <span class="comment">//将图片置灰</span></span><br><span class="line">    cvtColor(image,image,COLOR_BGR2GRAY);</span><br><span class="line">    <span class="comment">//调整图片大小(如果传入宽高为0，就取rect图片宽高)</span></span><br><span class="line">    <span class="keyword">if</span>(width==<span class="number">0</span>||height==<span class="number">0</span>)&#123;</span><br><span class="line">        width = rect.width();</span><br><span class="line">        height = rect.height();</span><br><span class="line">    &#125;</span><br><span class="line">    resize(image,image,<span class="keyword">new</span> Size(width,height));</span><br><span class="line">    <span class="comment">//图片落地（灰色图也可以不落地）</span></span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isNotBlank(targetImage))&#123;</span><br><span class="line">        imwrite(targetImage, image);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返会Mat图</span></span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法里主要使用了OpenCV中<code>org.bytedeco.opencv.global.opencv_imgcodecs</code>和<code>org.bytedeco.opencv.global.opencv_imgproc</code>两个包中的方法。</p><p>然后我们开始进行人脸识别训练。</p><p>人脸识别器（FaceRecognizer）这个类目前包含三种人脸识别方法：基于PCA变换的人脸识别(EigenFaceRecognizer)、基于Fisher变换的人脸识别(FisherFaceRecognizer)、基于局部二值模式的人脸识别(LBPHFaceRecognizer)。</p><p>这儿我们以基于PCA变换的人脸识别(EigenFaceRecognizer)来进行举例。</p><p>我们想识别两张不同的人脸，需要首先准备若干样本，这儿我准备了胡歌和刘亦菲的照片各10张来作为训练样本（想要更好的训练效果，训练图片至少要在数百张左右），如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-606.jpg" alt="upload successful"></p><p>其中胡歌的图片以0-开头，刘亦菲的图片以1-开头，对测试图片进行测试时，识别器的label（识别标签）返回0认为属于胡歌的照片，1认为属于刘亦菲的图片，-1认为不属于他们的照片。</p><p>训练时需要使用灰度图，我们使用上面的方法处理下生成宽高相等的灰度图。</p><p>其相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">faceRecognize</span><span class="params">(String baseImagePath,String testImage)</span></span>&#123;</span><br><span class="line">    <span class="comment">//存放样本的地址</span></span><br><span class="line">    File dirFile = <span class="keyword">new</span> File(baseImagePath);</span><br><span class="line">    <span class="keyword">if</span>(!dirFile.isDirectory())&#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"请指定样本文件目录！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//过滤指定图片文件</span></span><br><span class="line">    FilenameFilter imgFilter = (dir,name)-&gt;&#123;</span><br><span class="line">        name = name.toLowerCase();</span><br><span class="line">        <span class="keyword">return</span> name.endsWith(<span class="string">".jpg"</span>) || name.endsWith(<span class="string">".pgm"</span>) || name.endsWith(<span class="string">".png"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    File[] files = dirFile.listFiles(imgFilter);</span><br><span class="line">    <span class="keyword">if</span>(files == <span class="keyword">null</span> || files.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"目录下没有符合要求的图片文件！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//生成的训练样本（灰色图）临时文件存放在train目录下</span></span><br><span class="line">    String trainFileBasePath = baseImagePath + <span class="string">"/train"</span>;</span><br><span class="line">    File trainFileBase = <span class="keyword">new</span> File(trainFileBasePath);</span><br><span class="line">    <span class="keyword">if</span>(!trainFileBase.exists())&#123;</span><br><span class="line">        trainFileBase.mkdir();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始训练逻辑</span></span><br><span class="line">    <span class="comment">//样本灰色图Mat</span></span><br><span class="line">    MatVector matVector = <span class="keyword">new</span> MatVector(files.length);</span><br><span class="line">    <span class="comment">//样本标签</span></span><br><span class="line">    Mat labels = <span class="keyword">new</span> Mat(files.length, <span class="number">1</span>, CV_32SC1);</span><br><span class="line">    IntBuffer intBuffer = labels.createBuffer();</span><br><span class="line">    <span class="keyword">int</span> baseWidth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> baseHeight = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; files.length; i++) &#123;</span><br><span class="line">        <span class="comment">//灰色图地址</span></span><br><span class="line">        String tempImage = trainFileBasePath+<span class="string">"/"</span>+files[i].getName();</span><br><span class="line">        Mat mat = detectFace(files[i].getPath(),tempImage,baseWidth,baseHeight);</span><br><span class="line">        baseWidth = mat.rows();</span><br><span class="line">        baseHeight= mat.cols();</span><br><span class="line">        matVector.put(i,mat);</span><br><span class="line">        <span class="keyword">int</span> label = Integer.parseInt(files[i].getName().split(<span class="string">"-"</span>)[<span class="number">0</span>]);</span><br><span class="line">        intBuffer.put(i,label);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//人脸识别训练（训练要求训练图片和测试图片必须为灰度图，且大小一致）</span></span><br><span class="line">    <span class="comment">// num_components 主成分分析中保留的成分数(即特征面) 0为全部保留</span></span><br><span class="line">    <span class="comment">// threshold 置信度阈值，待识别图片如果大于这个阈值的话label就会返回-1</span></span><br><span class="line">    <span class="comment">// 可以不设置，会返回最低的置信度图片对于的label</span></span><br><span class="line">    FaceRecognizer faceRecognizer = EigenFaceRecognizer.create();</span><br><span class="line">    faceRecognizer.train(matVector,labels);</span><br><span class="line">    <span class="comment">//保存训练xml</span></span><br><span class="line">    faceRecognizer.save(baseImagePath+<span class="string">"/face.xml"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理待识别的图片</span></span><br><span class="line">    String testTempImage = baseImagePath + <span class="string">"/test"</span>;</span><br><span class="line">    File file = <span class="keyword">new</span> File(testTempImage);</span><br><span class="line">    <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">        file.mkdir();</span><br><span class="line">    &#125;</span><br><span class="line">    Mat tempMat = detectFace(testImage,testTempImage+<span class="string">"/temp.jpg"</span>,baseWidth,baseHeight);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//识别后结果标签，如果没有识别到，会返回-1</span></span><br><span class="line">    IntPointer label = <span class="keyword">new</span> IntPointer(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//识别置信度，越低越好，图片完全一样为0.0</span></span><br><span class="line">    DoublePointer confidence = <span class="keyword">new</span> DoublePointer(<span class="number">1</span>);</span><br><span class="line">    faceRecognizer.predict(tempMat, label, confidence);</span><br><span class="line">    <span class="keyword">int</span> predictedLabel = label.get();</span><br><span class="line">    System.out.println(<span class="string">"Predicted label: "</span> + predictedLabel);</span><br><span class="line">    System.out.println(confidence.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其关键部分代码为<code>faceRecognizer.train(matVector,labels)</code>，matVector接受生成的灰度图，labels为图片所属的标签，我们可以通过<code>faceRecognizer.save(baseImagePath+”/face.xml”)</code>保存训练后的xml。</p><p>在训练之前，通过灰度图处理（detectFace方法），如果训练图片选择落地的话，会在文件夹下生成train文件夹，里面就是存放宽高相等的待训练的样本。如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-607.jpg" alt="upload successful"></p><p>我们取一张测试照片test.jpg，来进行测试，如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-608.jpg" alt="upload successful"></p><p>其测试的主要代码就是上面代码的这部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理待识别的图片</span></span><br><span class="line">String testTempImage = baseImagePath + <span class="string">"/test"</span>;</span><br><span class="line">File file = <span class="keyword">new</span> File(testTempImage);</span><br><span class="line"><span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">    file.mkdir();</span><br><span class="line">&#125;</span><br><span class="line">Mat tempMat = detectFace(testImage,testTempImage+<span class="string">"/temp.jpg"</span>,baseWidth,baseHeight);</span><br><span class="line"></span><br><span class="line"><span class="comment">//识别后结果标签，如果没有识别到，会返回-1</span></span><br><span class="line">IntPointer label = <span class="keyword">new</span> IntPointer(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//识别置信度，越低越好，图片完全一样为0.0</span></span><br><span class="line">DoublePointer confidence = <span class="keyword">new</span> DoublePointer(<span class="number">1</span>);</span><br><span class="line">faceRecognizer.predict(tempMat, label, confidence);</span><br><span class="line"><span class="keyword">int</span> predictedLabel = label.get();</span><br><span class="line">System.out.println(<span class="string">"Predicted label: "</span> + predictedLabel);</span><br><span class="line">System.out.println(confidence.get());</span><br></pre></td></tr></table></figure><p>识别时也是需要使用灰度图进行识别，调用<code>faceRecognizer.predict(tempMat, label, confidence)</code>来对测试图片进行测试，同时也会返回置信度。</p><p>我们构建Main运行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//人脸识别训练</span></span><br><span class="line">    faceRecognize(<span class="string">"C:\\Users\\DELL-3020\\Desktop\\face\\base"</span>,<span class="string">"C:\\Users\\DELL-3020\\Desktop\\face\\test.jpg"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后可以看到输出结果：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-609.jpg" alt="upload successful"></p><p>可以看到符合我们的预期。</p><p>这儿只使用了少量训练样本来展示图像训练的方法，其实在进行识别训练时，样本越大精确度越高。</p><p>我们之前用到的<code>haarcascade_frontalface_alt.xml</code>，就是使用大量人脸样本进行训练生成的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>今天我们使用了OpenCV自带的人脸识别器（FaceRecognizer）来进行了人脸的识别与训练，后续我们会在了解下OpenCV在图像应用方面的一些其它功能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="OpenCV" scheme="https://www.sakuratears.top/tags/OpenCV/"/>
    
      <category term="人脸识别" scheme="https://www.sakuratears.top/tags/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>Java synchronized锁机制</title>
    <link href="https://www.sakuratears.top/blog/Java-synchronized%E9%94%81%E6%9C%BA%E5%88%B6.html"/>
    <id>https://www.sakuratears.top/blog/Java-synchronized锁机制.html</id>
    <published>2019-12-15T14:10:00.000Z</published>
    <updated>2019-12-15T14:28:08.054Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>聊到Java中的锁（<code>synchronized</code>关键字），我们需要了解重量锁、轻量锁（自旋锁）、偏向锁、锁消除、锁膨胀等一些知识。</p><p>下面我们来具体看一下。</p><h1 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h1><p>JDK中对<code>synchronized</code>进行了许多优化。它们如下：</p><h2 id="优化一"><a href="#优化一" class="headerlink" title="优化一"></a>优化一</h2><p>A: 重量级锁中的阻塞(挂起线程/恢复线程): 需要转入内核态中完成，有很大的性能影响。</p><p>B: 锁大多数情况都是在很短的时间执行完成。</p><p>解决方案: 引入轻量锁(通过自旋来完成锁竞争)。</p><h2 id="优化二"><a href="#优化二" class="headerlink" title="优化二"></a>优化二</h2><p>A: 轻量级锁中的自旋: 占用CPU时间，增加CPU的消耗(因此在多核处理器上优势更明显)。</p><p>B: 如果某锁始终是被长期占用，导致自旋如果没有把握好，白白浪费CPU资源。</p><p>解决方案: JDK5中引入默认自旋次数为10(用户可以通过-XX:PreBlockSpin进行修改)， JDK6中更是引入了自适应自旋（简单来说如果自旋成功概率高，就会允许等待更长的时间（如100次自旋），如果失败率很高，那很有可能就不做自旋，直接升级为重量级锁，实际场景中，HotSpot认为最佳时间应该是一个线程上下文切换的时间，而是否自旋以及自旋次数更是与对CPUs的负载、CPUs是否处于节电模式等息息相关的)。</p><h2 id="优化三"><a href="#优化三" class="headerlink" title="优化三"></a>优化三</h2><p>A: 无论是轻量级锁还是重量级锁: 在进入与退出时都要通过CAS修改对象头中的Mark Word来进行加锁与释放锁。</p><p>B: 在一些情况下总是同一线程多次获得锁，此时第二次再重新做CAS修改对象头中的Mark Word这样的操作，有些多余。</p><p>解决方案: JDK6引入偏向锁(首次需要通过CAS修改对象头中的Mark Word，之后该线程再进入只需要比较对象头中的Mark Word的Thread ID是否与当前的一致，如果一致说明已经取得锁，就不用再CAS了)。</p><h2 id="优化四"><a href="#优化四" class="headerlink" title="优化四"></a>优化四</h2><p>A: 项目中代码块中可能绝大情况下都是多线程访问。</p><p>B: 每次都是先偏向锁然后过渡到轻量锁，而偏向锁能用到的又很少。</p><p>解决方案: 可以使用-XX:-UseBiasedLocking=false禁用偏向锁。</p><h2 id="优化五"><a href="#优化五" class="headerlink" title="优化五"></a>优化五</h2><p>A: 代码中JDK原生或其他的工具方法中带有大量的加锁。</p><p>B: 实际过程中，很有可能很多加锁是无效的(如局部变量作为锁，由于每次都是新对象新锁，所以没有意义)。</p><p>解决方法: 引入锁削除(虚拟机即时编译器(JIT)运行时，依据逃逸分析的数据检测到不可能存在竞争的锁，就自动将该锁消除)。</p><h2 id="优化六"><a href="#优化六" class="headerlink" title="优化六"></a>优化六</h2><p>A: 为了让锁颗粒度更小，或者原生方法中带有锁，很有可能在一个频繁执行(如循环)中对同一对象加锁。</p><p>B: 由于在频繁的执行中，反复的加锁和解锁，这种频繁的锁竞争带来很大的性能损耗。</p><p>解决方法: 引入锁膨胀(会自动将锁的范围拓展到操作序列(如循环)外, 可以理解为将一些反复的锁合为一个锁放在它们外部)。</p><h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><p>上面说到的优化是十分笼统的，现在我们来分析一下JDK源码中锁实现的基本原理，进一步对Java的锁机制有更深入的了解。</p><h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><p>在HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p><p>其中对象头（Header）包括两部分信息：</p><ul><li><strong>Mark Word</strong>：用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等。</li><li><strong>Klass Pointer</strong>：对象指向它的类的元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li><li><strong>ArrayLength</strong>：用于记录数组长度的数据（如果当前对象不是数组，就没有这一部分数据）。</li></ul><p>其中我们关注的就是对象头中的<code>Mark Word</code>，其中存储着关于对象锁的一些信息。</p><p>对于处于不同状态的对象（无锁、轻量锁、偏向锁、重量锁），其Mark Word里的内容是不一样的，如下图分别是32位HotSpot虚拟机和64位HotSpot虚拟机对象头的存储结构：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-595.jpg" alt="upload successful"></p><p>我们来看下JVM源码，来证实下上图所说的内容。</p><p>我们可以通过 OpenJDK网站 <a href="http://hg.openjdk.java.net/" rel="external nofollow noopener noreferrer" target="_blank">OpenJDK Project</a>来下载JDK源码，我这儿下载了JDK10 源码，那么我们可以在<code>\jdk10-b09e56145e11\src\hotspot\share\oops</code>文件夹下找到<code>klass.hpp</code>、<code>klass.cpp</code>、<code>markOop.cpp</code>、<code>markOop.hpp</code>等文件。</p><blockquote><p>PS: hotspot文件夹即为JVM源码文件夹。</p></blockquote><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-596.jpg" alt="upload successful"></p><p>无论是32位的JVM还是64位的JVM，均为 1bit偏向锁+2bit锁标志位。对于Java中的<code>synchronized</code>关键字，就使用了Mark Word来标识对象加锁状态。</p><h2 id="synchronized实现原理"><a href="#synchronized实现原理" class="headerlink" title="synchronized实现原理"></a>synchronized实现原理</h2><p>我们刚才上面提到了锁优化的一些内容，对于<code>synchronized</code>关键字，JVM到底进行了怎样的处理呢？</p><p>我们通过JVM <code>synchronized</code> 的源码来大致了解下。</p><p>我们先写一个简单类，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个是在代码块上加锁，另一个是对方法加锁。</p><p>对于这两种的同步，JVM都是基于监视器对象（Monitor）的进入和退出来实现的，但是两者的实现细节有所不同。</p><p>代码块同步是使用monitorenter和monitorexit指令实现的，而方法同步是使用字节码同步指令ACC_SYNCHRONIZED来实现的。</p><blockquote><p>字节码同步指令ACC_SYNCHRONIZED原理：JVM通过使用Monitor来支持同步，JVM可以从方法常量池的方法表结构中的ACC_SYNCHRONIZED访问标志来得知一个方法是否声明为同步方法，当方法调用时，调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程就要求先成功持有Monitor，然后才能执行方法，最后当方法完成（无论是正常完成还是非正常完成）时释放管程，在方法执行期间，执行线程持有了Monitor，其他任何线程都无法在获取到同一个Monitor。</p></blockquote><p>我们将上述Test.java文件编译为Test.class 文件，然后反编译成字节码来看一下。</p><p>如下指令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -verbose -c E:\WorkSpace\helputils\target\test-classes\com\zwt\helputils\Test.class</span><br></pre></td></tr></table></figure><p>如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-597.jpg" alt="upload successful"></p><p>可以看到对于代码块同步，使用了monitorenter和monitorexit，而我们看到有两个monitorexit是因为保证出现异常monitor也能正确退出。对于方法同步，该方法有ACC_SYNCHRONIZED访问标志来保证同步性。</p><p>下面我们来分析下Synchronization部分的JVM源码，我们在<code>jdk10-b09e56145e11\src\hotspot\share\interpreter\interpreterRuntime.cpp</code>文件中可以找到monitorenter和monitorexit的相关方法，如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-598.jpg" alt="upload successful"></p><p>如果有启用偏向锁，则会使用<code>ObjectSynchronizer::fast_enter</code>来尝试获得偏向锁，否则会使用<code>ObjectSynchronizer::slow_enter</code>来尝试获得轻量锁。</p><p>使用<code>ObjectSynchronizer::slow_exit</code>来释放锁。</p><h3 id="偏向锁的获取"><a href="#偏向锁的获取" class="headerlink" title="偏向锁的获取"></a>偏向锁的获取</h3><p>我们来看下<code>ObjectSynchronizer::fast_enter</code>方法，它在<code>jdk10-b09e56145e11\src\hotspot\share\runtime\synchronizer.cpp</code>文件里，如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-599.jpg" alt="upload successful"></p><p>方法<code>revoke_and_rebias</code>为偏向锁的获取和撤销相关代码，它在<code>jdk10-b09e56145e11\src\hotspot\share\runtime\biasedLocking.cpp</code>文件里，相关代码量较多，这儿就不过多展示了。</p><p>偏向锁获取的相关逻辑如下：</p><ol><li>通过markOop mark = obj-&gt;mark()获取对象的markOop数据mark，即对象头的Mark Word；</li><li>判断mark是否为可偏向状态，即mark的偏向锁标志位为 1，锁标志位为 01；</li><li>判断mark中JavaThread的状态：如果为空，则进入4；如果指向当前线程，则执行同步代码块；如果指向其它线程，进入5；</li><li>通过CAS原子指令设置mark中JavaThread为当前线程ID，如果执行CAS成功，则执行同步代码块，否则进入5；</li><li>如果执行CAS失败，表示当前存在多个线程竞争锁，当达到全局安全点（safepoint），获得偏向锁的线程被挂起，撤销偏向锁，并升级为轻量级，升级完成后被阻塞在安全点的线程继续执行同步代码块；</li></ol><h3 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h3><p>偏向锁的撤销必须等待全局安全点（没有正在执行的字节码）时执行。<code>revoke_at_safepoint</code>是偏向锁撤销相关代码，它也在它在<code>jdk10-b09e56145e11\src\hotspot\share\runtime\biasedLocking.cpp</code>文件里。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-600.jpg" alt="upload successful"></p><p>偏向锁的撤销逻辑和偏向获取和撤销次数有关系，会走不同的逻辑，其相关逻辑如下：</p><ol><li>偏向锁的撤销动作必须等待全局安全点；</li><li>暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态；</li><li>撤销偏向锁，恢复到无锁（标志位为 01）或轻量级锁（标志位为 00）的状态；</li></ol><h3 id="轻量锁的获取"><a href="#轻量锁的获取" class="headerlink" title="轻量锁的获取"></a>轻量锁的获取</h3><p>当偏向锁处于关闭状态，或者多个线程竞争导致偏向锁升级为轻量锁，程序或尝试获取轻量锁。</p><p>其代码入口为<code>jdk10-b09e56145e11\src\hotspot\share\runtime\synchronizer.cpp</code>文件里的<code>ObjectSynchronizer::slow_enter</code>方法。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-601.jpg" alt="upload successful"></p><p>轻量锁的获取相关逻辑如下：</p><ol><li>markOop mark = obj-&gt;mark()方法获取对象的markOop数据mark；</li><li>mark-&gt;is_neutral()方法判断mark是否为无锁状态：mark的偏向锁标志位为 0，锁标志位为 01；</li><li>如果mark处于无锁状态，则进入4，否则执行6；</li><li>把mark保存到BasicLock对象的_displaced_header字段；</li><li>通过CAS尝试将Mark Word更新为指向BasicLock对象的指针，如果更新成功，表示竞争到锁，则执行同步代码，否则执行6；</li><li>如果当前mark处于加锁状态，且mark中的ptr指针指向当前线程的栈帧，则执行同步代码，否则说明有多个线程竞争轻量级锁，轻量级锁需要膨胀升级为重量级锁；</li></ol><p>假设线程A和B同时执行到临界区if (mark-&gt;is_neutral())：</p><ol><li>线程AB都把Mark Word复制到各自的_displaced_header字段，该数据保存在线程的栈帧上，是线程私有的；</li><li>Atomic::cmpxchg_ptr原子操作保证只有一个线程可以把指向栈帧的指针复制到Mark Word，假设此时线程A执行成功，并返回继续执行同步代码块；</li><li>线程B执行失败，退出临界区，通过ObjectSynchronizer::inflate方法开始膨胀锁；</li></ol><h3 id="轻量锁的释放"><a href="#轻量锁的释放" class="headerlink" title="轻量锁的释放"></a>轻量锁的释放</h3><p>轻量锁的释放入口为<code>jdk10-b09e56145e11\src\hotspot\share\runtime\synchronizer.cpp</code>文件里的<code>ObjectSynchronizer::slow_exit</code>方法，它最终调用的为该文件里的<code>ObjectSynchronizer::fast_exit</code>方法。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-602.jpg" alt="upload successful"></p><p>轻量锁的释放相关逻辑如下：</p><ol><li>确保处于偏向锁状态时不会执行这段逻辑；</li><li>取出在获取轻量级锁时保存在BasicLock对象的mark数据dhw；</li><li>通过CAS尝试把dhw替换到当前的Mark Word，如果CAS成功，说明成功的释放了锁，否则执行4；</li><li>如果CAS失败，说明有其它线程在尝试获取该锁，这时需要将该锁升级为重量级锁，并释放；</li></ol><h3 id="重量锁"><a href="#重量锁" class="headerlink" title="重量锁"></a>重量锁</h3><p>重量级锁通过对象内部的monitor实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。</p><h4 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h4><p>一般情况下重量级锁都是由轻量锁膨胀来的，其方法实现为<code>jdk10-b09e56145e11\src\hotspot\share\runtime\synchronizer.cpp</code>文件的<code>ObjectSynchronizer::inflate</code>方法。</p><p>如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-603.jpg" alt="upload successful"></p><p>膨胀过程的相关逻辑如下：</p><ol><li>整个膨胀过程在自旋下完成；</li><li>mark-&gt;has_monitor()方法判断当前是否为重量级锁，即Mark Word的锁标识位为 10，如果当前状态为重量级锁，执行3，否则执行4；</li><li>mark-&gt;monitor()方法获取指向ObjectMonitor的指针，并返回，说明膨胀过程已经完成；</li><li>如果当前锁处于膨胀中，说明该锁正在被其它线程执行膨胀操作，则当前线程就进行自旋等待锁膨胀完成，这里需要注意一点，虽然是自旋操作，但不会一直占用cpu资源，每隔一段时间会通过os::NakedYield方法放弃cpu资源，或通过park方法挂起；如果其他线程完成锁的膨胀操作，则退出自旋并返回；</li><li>如果当前是轻量级锁状态，即锁标识位为 00，膨胀过程如下：<ul><li>通过omAlloc方法，获取一个可用的ObjectMonitor monitor，并重置monitor数据；</li><li>通过CAS尝试将Mark Word设置为markOopDesc:INFLATING，标识当前锁正在膨胀中，如果CAS失败，说明同一时刻其它线程已经将Mark Word设置为markOopDesc:INFLATING，当前线程进行自旋等待膨胀完成；</li><li>如果CAS成功，设置monitor的各个字段：_header、_owner和_object等，并返回；</li></ul></li><li>如果是无锁，重置monitor值；</li></ol><h4 id="重量锁的获取与释放"><a href="#重量锁的获取与释放" class="headerlink" title="重量锁的获取与释放"></a>重量锁的获取与释放</h4><p>重量锁的获取包括锁的竞争、等待锁的释放与尝试获取步骤。</p><p>当锁膨胀完成并返回对应的monitor时，并不表示该线程竞争到了锁，真正的锁竞争发生在<code>jdk10-b09e56145e11\src\hotspot\share\runtime\objectMonitor.cpp</code>文件里的<code>ObjectMonitor::enter</code>方法里。</p><p>monitor竞争失败的线程，通过自旋执行<code>ObjectMonitor::EnterI</code>方法等待锁的释放。当该线程被唤醒时，会从挂起的点继续执行，通过<code>ObjectMonitor::TryLock</code>尝试获取锁。</p><p>当某个持有锁的线程执行完同步代码块时，会进行锁的释放，给其它线程机会执行同步代码，在HotSpot中，通过退出monitor的方式实现锁的释放，并通知被阻塞的线程，具体实现位于<code>ObjectMonitor::exit</code>方法中。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-604.jpg" alt="upload successful"></p><p>其具体逻辑涉及到大量C++代码，这儿就不在对代码进行过多分析。</p><p>这儿总结下重量锁的竞争逻辑大致如下（<code>ObjectMonitor::enter</code>方法相关逻辑）：</p><ol><li>通过CAS尝试把monitor的_owner字段设置为当前线程；</li><li>如果设置之前的_owner指向当前线程，说明当前线程再次进入monitor，即重入锁，执行_recursions ++ ，记录重入的次数；</li><li>如果之前的_owner指向的地址在当前线程中，这种描述有点拗口，换一种说法：之前_owner指向的BasicLock在当前线程栈上，说明当前线程是第一次进入该monitor，设置_recursions为1，_owner为当前线程，该线程成功获得锁并返回；</li><li>如果获取锁失败，则等待锁的释放；</li></ol><p>等待锁释放的逻辑大致如下（<code>ObjectMonitor::EnterI</code>方法相关逻辑）：</p><ol><li>当前线程被封装成ObjectWaiter对象node，状态设置成ObjectWaiter::TS_CXQ；</li><li>在for循环中，通过CAS把node节点push到_cxq列表中，同一时刻可能有多个线程把自己的node节点push到_cxq列表中；</li><li>node节点push到_cxq列表之后，通过自旋尝试获取锁，如果还是没有获取到锁，则通过park将当前线程挂起，等待被唤醒；</li><li>当该线程被唤醒时，会从挂起的点继续执行，通过<code>ObjectMonitor::TryLock</code>尝试获取锁；</li><li><code>ObjectMonitor::TryLock</code>方法本质就是通过CAS设置monitor的_owner字段为当前线程，如果CAS成功，则表示该线程获取了锁，跳出自旋操作，执行同步代码，否则继续被挂起；</li></ol><p>重量锁的释放相关逻辑大致如下（<code>ObjectMonitor::exit</code>方法的相关逻辑）：</p><ol><li>如果是重量级锁的释放，monitor中的_owner指向当前线程，即THREAD == _owner；</li><li>根据不同的策略（由QMode指定），从cxq或EntryList中获取头节点，通过<code>ObjectMonitor::ExitEpilog</code>方法唤醒该节点封装的线程，唤醒操作最终由unpark完成；</li><li>被唤醒的线程，继续执行monitor的竞争；</li></ol><h2 id="锁的升级情况"><a href="#锁的升级情况" class="headerlink" title="锁的升级情况"></a>锁的升级情况</h2><p>锁的升级是单向的：无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</p><p>有位笔者大神给出了锁的变换关系相关流程图，如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-605.jpg" alt="upload successful"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文主要介绍了<code>synchronized</code>的特点和实现，了解了偏向锁、轻量锁、重量锁、锁撤销和锁膨胀的一些原理。对我们更好的理解Java锁机制提供了一些帮助。</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ol><li><a href="https://blog.dreamtobe.cn/2015/11/13/java_synchronized/" rel="external nofollow noopener noreferrer" target="_blank">Java Synchronised机制</a></li><li><a href="https://www.cnblogs.com/dennyzhangdd/p/6734638.html" rel="external nofollow noopener noreferrer" target="_blank">jdk源码剖析二: 对象内存布局、synchronized终极原理</a></li><li><a href="https://wiki.openjdk.java.net/display/HotSpot/Native+Monitors+Design" rel="external nofollow noopener noreferrer" target="_blank">Native+Monitors+Design</a></li><li><a href="http://hg.openjdk.java.net/" rel="external nofollow noopener noreferrer" target="_blank">OpenJDK projects</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="synchronized" scheme="https://www.sakuratears.top/tags/synchronized/"/>
    
      <category term="重量锁" scheme="https://www.sakuratears.top/tags/%E9%87%8D%E9%87%8F%E9%94%81/"/>
    
      <category term="轻量锁" scheme="https://www.sakuratears.top/tags/%E8%BD%BB%E9%87%8F%E9%94%81/"/>
    
      <category term="偏向锁" scheme="https://www.sakuratears.top/tags/%E5%81%8F%E5%90%91%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV简介及使用（一）</title>
    <link href="https://www.sakuratears.top/blog/OpenCV%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89.html"/>
    <id>https://www.sakuratears.top/blog/OpenCV简介及使用（一）.html</id>
    <published>2019-11-10T10:05:00.000Z</published>
    <updated>2019-11-10T13:39:32.541Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>OpenCV (Open Source Computer Vision Library) 是一个基于BSD许可（开源）发行的跨平台计算机视觉库，可以运行在Linux、Windows、Android和Mac OS操作系统上。它主要由 C++ 语言编写，同时提供了Python、Ruby、MATLAB、Java等语言的接口，实现了图像处理和计算机视觉方面的很多通用算法，同时一个使用CUDA的GPU接口也于2010年9月开始实现。</p><p>该库拥有 2500 多个优化算法，其中包括一套全面的经典和最先进的计算机视觉和机器学习算法。这些算法可用于检测和识别人脸、识别对象、对视频中的人类行为进行分类、跟踪摄像机移动、跟踪移动对象、提取对象的 3D 模型、从立体摄像机生成 3D 点云、将图像拼接在一起生成整个场景的高分辨率图像，从图像数据库中查找相似图像，从使用闪光灯拍摄的图像中删除红眼，跟踪眼睛运动，识别风景，并建立标记以覆盖其增强现实等。</p><p>除了谷歌、微软、英特尔、IBM、索尼、等老牌公司，还有许多初创公司，它们广泛使用OpenCV。</p><p>我们可以通过以下网址获取各个版本的 OpenCV ，OpenCV最新版本已经进入 4.x.x 了。</p><p><a href="https://opencv.org/" rel="external nofollow noopener noreferrer" target="_blank">https://opencv.org/</a></p><h1 id="OpenCV环境搭建"><a href="#OpenCV环境搭建" class="headerlink" title="OpenCV环境搭建"></a>OpenCV环境搭建</h1><p>下面分别展示了Windows和Mac环境下的OpenCV搭建，在Linux环境下搭建和Mac环境下类似，如有机会，我会在进行补充。</p><p>本文基于 Java + IDEA + OpenCV 环境的搭建和使用来进行说明。</p><h2 id="Windows环境下的OpenCV环境搭建"><a href="#Windows环境下的OpenCV环境搭建" class="headerlink" title="Windows环境下的OpenCV环境搭建"></a>Windows环境下的OpenCV环境搭建</h2><p>首先下载 <a href="https://opencv.org/releases/" rel="external nofollow noopener noreferrer" target="_blank">OpenCV for Windows</a> 版本，我这儿下载了4.1.1 版本的OpenCV。</p><p>我们将这个exe运行，将OpenCV安装在一个方便寻找的目录下即可。</p><p>至此，OpenCV算是在Windows环境上安装了，下面我们来进行开发环境搭建。</p><p>PS：如果想获取OpenCV最新版进行安装，可以通过OpenCV的 <a href="https://github.com/opencv/" rel="external nofollow noopener noreferrer" target="_blank">GitHub</a> 获取最新版源码，在通过CMake工具进行编译生成OpenCV Lib，这块大家可以查阅相关资料，不在过多叙述。</p><p>我们打开OpenCV的安装目录，在 <code>build/java</code> 可以看到 <code>opencv-411.jar</code> 和 <code>x64、x86</code> 两个文件夹，这两个文件夹里有两个dll文件，都叫<code>opencv_java411.dll</code>，这分别是64位系统和32系统需要使用的动态链接库文件，我们如果想在Java环境下使用OpenCV，在JVM启动时，必须将dll文件加载进去，然后才能使用<code>opencv-411.jar</code>里提供的Java接口方法。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-577.jpg" alt="upload successful"></p><p>我们来看简单测试下，我们用IDEA新建一个Java项目test，同时需要引入上面的dll文件和jar文件。</p><p>新建一个Java项目：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-578.jpg" alt="upload successful"></p><p>引入必要文件：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-579.jpg" alt="upload successful"></p><p>这儿要注意两个文件同时选中，引入后如下图效果，Native Library 可以被正确加载到。否则在启动后会出现 <code>java.lang.UnsatisfiedLinkError</code>错误。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-580.jpg" alt="upload successful"></p><p>然后我们测试一下，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.loadLibrary(Core.NATIVE_LIBRARY_NAME);</span><br><span class="line">        Mat mat = <span class="keyword">new</span> Mat();</span><br><span class="line">        System.out.println(mat.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到正确输出内容。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-581.jpg" alt="upload successful"></p><p>这儿要注意<code>System.loadLibrary(Core.NATIVE_LIBRARY_NAME);</code>这句话，在使用OpenCV时，需要调用此语句以加载原生Library。</p><p>PS：上面的文件引入过程，dll和jar也是可以分别引入的，也是相当于引入到了JVM运行环境中。本质上是没有区别的，但一起引入方便理解，即<code>opencv_java411.dll</code>是为<code>opencv-411.jar</code> ”服务“ 的。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-582.jpg" alt="upload successful"></p><p>显然我们实际的项目是没有这么简单的，而且很多是Web （SpringBoot）项目，使用Maven管理，这种直接引入对我们的管理十分不方便。</p><p>对于jar包部分，我们可以使用如下配置引入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.bytedeco/opencv --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.bytedeco&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;opencv&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.1.0-1.5.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>对于dll文件，我们有三种引入方式：</p><ol><li><p>按照上面直接添加lib到项目里</p><p> 这种虽然可以正常使用，但是在Maven打包项目部署到服务器运行后仍会遇到连接不到的问题。</p></li><li><p>添加VM Options</p><p> 我们可以将dll所在路径添加到VM Options里，<code>-Djava.library.path=D:/opencv/build/java/x64</code>。</p><p> <img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-583.jpg" alt="upload successful"></p></li><li><p>使用程序在项目启动时加入</p><p> 理论上JVM启动后就不能在向其中加入参数了，但我们可以利用反射机制，在JVM启动时将<code>java.library.path</code>参数添加进去，代码如下：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 追加VM Options参数</span></span><br><span class="line"><span class="comment"> * java.library.path</span></span><br><span class="line"><span class="comment"> * 需要在启动后直接调用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> libraryPath</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addLibraryDir</span><span class="params">(String libraryPath)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Field userPathsField = ClassLoader.class.getDeclaredField(<span class="string">"usr_paths"</span>);</span><br><span class="line">    userPathsField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    String[] paths = (String[]) userPathsField.get(<span class="keyword">null</span>);</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; paths.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (libraryPath.equals(paths[i])) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(paths[i]).append(<span class="string">';'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sb.append(libraryPath);</span><br><span class="line">    System.setProperty(<span class="string">"java.library.path"</span>, sb.toString());</span><br><span class="line">    <span class="comment">//系统变量设置为空，JVM会重新加载 sys_paths 和 usr_paths</span></span><br><span class="line">    <span class="keyword">final</span> Field sysPathsField = ClassLoader.class.getDeclaredField(<span class="string">"sys_paths"</span>);</span><br><span class="line">    sysPathsField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    sysPathsField.set(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这个方法在项目启动时调用即可。</p><p> 这个方法在JDK9 及以上版本会出现警告，因为我们这样操作是不安全的，也是不建议的，未来JDK所有非法访问操作将被拒绝。</p><p> <img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-584.jpg" alt="upload successful"></p></li></ol><p>我们通常也建议使用第二种方法引入OpenCV动态链接库dll文件。</p><p>PS：有时候我们环境搭建好了，可能仍无法使用，出现动态库dll找不到的情况，如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-585.jpg" alt="upload successful"></p><p>这时候需要注意<code>Core.NATIVE_LIBRARY_NAME</code>这段代码，我们点进去，可以看到它使用的 LIBRARY_NAME 为 <code>opencv_java410</code>，加载不到的原因是我们安装的是 OpenCV 4.1.1 版本，这时候我们使用<code>System.loadLibrary(“opencv_java411”);</code>即可加载成功，出现这种情况的原因是我们上面Maven下载的jar包是 4.1.0 版本的（这也是目前Maven上的最高版本）。所以为防止出现问题，需要知道自己安装了什么版本的OpenCV，并建议设置为常量，方便引入。</p><h2 id="Mac环境下的OpenCV环境搭建"><a href="#Mac环境下的OpenCV环境搭建" class="headerlink" title="Mac环境下的OpenCV环境搭建"></a>Mac环境下的OpenCV环境搭建</h2><p>OpenCV未提供Mac版本的安装程序，我们通常有以下几种安装方式：</p><ol><li><p>使用Homebrew进行安装</p><p> 这是获取OpenCV最快的方式，安装Homebrew后，要检查Mac系统是否安装了 XCode Command Line Tools。</p><p> 在Terminal下执行如下命令 <code>xcode-select –install</code>，如果系统要求安装此工具，则进行安装即可。</p><p> 上述步骤完成后，我们可以直接使用<code>brew install opencv</code>安装OpenCV，安装好后的文件位于<code>/usr/local/Cellar/opencv4</code>文件夹下。</p><p> 我们使用此种方式安装，可以发现得到的OpenCV安装文件里是不包含支持Java接口部分的编译文件的。</p><p> 这对我们来说十分不友好。</p></li><li><p>使用Homebrew下载源码自动编译安装</p><p> 对于OpenCV，Homebrew也是可以在线自动下载源码到本地并自动进行编译安装的。</p><p> 在安装Homebrew和 XCode Command Line Tools 后，使用Homebrew安装cmake工具<code>brew install cmake</code>，这是OpenCV编译需要用到的工具。</p><p> 同时我们需要安装Apache Ant工具，<code>brew install ant</code>，因为OpenCV编译生成Java接口文件需要用到。</p><p> 然后我们使用指令<code>brew edit opencv</code>，可以打开查看opencv的编译项。如下图：</p><p> <img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-586.jpg" alt="upload successful"></p><p> 然后找到编译项里的 <code>-DBUILD_opencv_java=OFF</code>，将其改为 <code>-DBUILD_opencv_java=ON</code>，然后保存配置。</p><p> 由上面的操作可以看到 Homebrew 的 OpenCV编译默认是不包含Java相关支持的。</p><p> 我们使用<code>brew install –build-from-source opencv</code>下载源码到本地自动进行编译安装。</p><p> PS:我按照上述操作后确实会从GitHub上自动下载最新版源码并进行编译，但是在编译过程中遇到了一个”has no symbol”的错误。导致始终无法make成功，也未找到相关解决办法，于是放弃了该种安装办法。</p><p> 错误详情如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Linking CXX static library ../../lib/libopencv_core.a /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ranlib: file: ../../lib/libopencv_core.a(hal_internal.cpp.o) has no symbols /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ranlib: file: ../../lib/libopencv_core.a(opencl_clamdblas.cpp.o) has no symbols /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ranlib: file: ../../lib/libopencv_core.a(opencl_clamdfft.cpp.o) has no symbols /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ranlib: file: ../../lib/libopencv_core.a(opencl_core.cpp.o) has no symbols /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ranlib: file: ../../lib/libopencv_core.a(hal_internal.cpp.o) has no symbols /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ranlib: file: ../../lib/libopencv_core.a(opencl_clamdblas.cpp.o) has no symbols /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ranlib: file: ../../lib/libopencv_core.a(opencl_clamdfft.cpp.o) has no symbols /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ranlib: file: ../../lib/libopencv_core.a(opencl_core.cpp.o) has no symbols</span><br></pre></td></tr></table></figure><p> 我在OpenCV官网上也看到别人遇到此种情况，尚未有回复。</p><p> <a href="https://answers.opencv.org/question/104758/has-no-symbol-error-on-mac/" rel="external nofollow noopener noreferrer" target="_blank">https://answers.opencv.org/question/104758/has-no-symbol-error-on-mac/</a></p></li><li><p>手动编译OpenCV</p><p> 我们使用OpenCV的源码来编译OpenCV，同样我们需要cmake工具，使用<code>brew install cmake</code>进行安装。</p><p> 安装Apache Ant工具，<code>brew install ant</code>。</p><p> 从OpenCV官网上下载 <a href="https://opencv.org/releases/" rel="external nofollow noopener noreferrer" target="_blank">OpenCV的源码 Sources</a>，我下载的是opencv-4.1.1.zip。</p><p> 我们将它解压，得到源码文件。</p><p> 进入到opencv源码目录 <code>cd /Users/xxx/Desktop/opencv-4.1.1</code>。</p><p> 我们在该目录下创建一个build文件夹用于存放编译后的文件<code>mkdir build</code>。</p><p> 进入到build目录<code>cd build</code>。</p><p> 在此目录下，我们配置cmake的编译参数<code>cmake -DBUILD_SHARED_LIBS=OFF -D CMAKE_INSTALL_PREFIX=/Users/xxx/Applications/opencv-4.1.1 ..</code></p><p> PS：</p><p>   CMAKE_INSTALL_PREFIX 指的是编译完成后安装的路径前缀，我们会把OpenCV安装到此目录下。</p><p>   -DBUILD_SHARED_LIBS=OFF 指的是OpenCV作为一组静态库构建，不去动态依赖其它库，而是包含全部代码的编译。</p><p>   我们可以使用<code>brew info opencv</code>查看OpenCV的依赖库，如果-DBUILD_SHARED_LIBS=ON 则OpenCV会依赖已经存在的库来进行编译，可能会产生问题。</p><p> 构建完成后我们开始进行安装，使用<code>make -j6</code>来进行任务。</p><p> PS：-j6 指的是并行6个任务来进行构建，当然也可以 -j5 五个并行任务等等。</p><p> 检查cmake的输出并确保java是“待构建”模块之一。如果不是的话，很可能你缺少了一个依赖关系您应该通过查看cmake输出中未找到的与java相关的工具并安装它们来进行故障排除。</p><p> 完成后，我们使用<code>sudo make install</code>完成最后的安装任务。</p><p> 这样，在我们上面提到的安装目录里，就会找到OpenCV的安装文件，当然，也能找到Java接口部分的文件。</p><p> 位于 <code> ${CMAKE_INSTALL_PREFIX} /share/java/opencv4</code>文件夹下，如图：</p><p> <img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-594.jpg" alt="upload successful"></p></li></ol><h2 id="Linux环境下的OpenCV环境搭建"><a href="#Linux环境下的OpenCV环境搭建" class="headerlink" title="Linux环境下的OpenCV环境搭建"></a>Linux环境下的OpenCV环境搭建</h2><p>Linux环境下不再过多叙述，有需要的可以查看如下相关文章。</p><p><a href="https://opencv-java-tutorials.readthedocs.io/en/latest/01-installing-opencv-for-java.html" rel="external nofollow noopener noreferrer" target="_blank">installing-opencv-for-java</a></p><p>文章内也包含Windows和Mac的安装教程。</p><h1 id="OpenCV的使用"><a href="#OpenCV的使用" class="headerlink" title="OpenCV的使用"></a>OpenCV的使用</h1><p>这儿我们先来了解下OpenCV的简单使用，后面在深入了解。</p><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><p>先来了解下OpenCV的基本类<code>Mat</code>，它是一个图像的数据格式矩阵。用来存储图像的数据结构。</p><p>我们知道图像是由R (Red)、 G (Green) 、 B (Blue) 三原色构成，那<code>Mat</code>存储这三原色数据，会是一个三维数组？</p><p>其实不是的，<code>Mat</code>中是使用二维数组存储图像数据的，如何存储呢？如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-587.jpg" alt="upload successful"></p><p>可以看到<code>Mat</code>彩色图像的存储形式是三列当做一列，由 BGR 三个通道，存储在一个平面内，这儿彩色图的一个像素会占用3个字节。</p><p>对于灰度图，由于没有颜色要求，因此Mat的存储灰度图的格式和彩色图略有些不同，如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-588.jpg" alt="upload successful"></p><p>可以看到灰度图的一个像素在Mat中会占用1个字节。</p><p>我们使用OpenCV里的 <code>Imgcodecs</code>读取一张红色图片转为<code>Mat</code>，然后进行输出，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    addLibraryDir(vmOptions);</span><br><span class="line">    System.loadLibrary(opencvLibName);</span><br><span class="line">    Mat mat = Imgcodecs.imread(<span class="string">"C:\\Users\\DELL-3020\\Desktop\\test12.jpg"</span>);</span><br><span class="line">    System.out.println(mat.dump());</span><br><span class="line">    Color color = <span class="keyword">new</span> Color(<span class="number">250</span>,<span class="number">0</span>,  <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-589.jpg" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-590.jpg" alt="upload successful"></p><p>我们dump后可以看到<code>Mat</code>的数据内容。</p><p><code>Scalar</code>是OpenCV里的可认为是颜色的向量类，它最多可以有四个入参。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scalar scalar = <span class="keyword">new</span> Scalar(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>它的参数分别表示该颜色向量的 B G R 和 透明度，上面我们就创建了一个纯蓝色透明度为0（不透明）的颜色向量。</p><p>我们使用<code>setTo</code>方法，可以将原来<code>Mat</code>图的红色全部替换为蓝色，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    addLibraryDir(vmOptions);</span><br><span class="line">    System.loadLibrary(opencvLibName);</span><br><span class="line">    Mat mat = Imgcodecs.imread(<span class="string">"C:\\Users\\DELL-3020\\Desktop\\test13.jpg"</span>);</span><br><span class="line">    Scalar scalar = <span class="keyword">new</span> Scalar(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    mat.setTo(scalar);</span><br><span class="line">    System.out.println(mat.dump());</span><br><span class="line">    Imgcodecs.imwrite(<span class="string">"C:\\Users\\DELL-3020\\Desktop\\test15.jpg"</span>,mat);</span><br><span class="line">    Color color = <span class="keyword">new</span> Color(<span class="number">0</span>,<span class="number">0</span>, <span class="number">255</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们会生成一张蓝色图片。</p><h2 id="人脸检测"><a href="#人脸检测" class="headerlink" title="人脸检测"></a>人脸检测</h2><p><code>CascadeClassifier</code>级联分类器是OpenCV里进行图片对象识别的检测器。</p><p>一个分类器的生成： 用一个对象的几百个样本（或者更多）作为正面例子，需要将它们缩放到相同大小；负面例子样本可用任意多张（非正面例子）和正面例子相同大小的图片即可。用它们完成分类器的训练。</p><p>而对于级联分类器，则是由若干个分类器组成，它们占用不同的权重组成，比如人脸级联分类器，要检测人脸，则需要有眼睛部分，则眼睛分类器可以作为人脸级联分类器的一部分。</p><p>我们训练特定样本后，可以得到一个分类器文件（xml），加载这个xml文件后，我们可以对一些测试样本进行检测，看它是否属于目标样本。</p><p>关于训练的内容我们后面在聊，现在OpenCV内置了一些分类器文件例子，我们来看下，如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-591.jpg" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-592.jpg" alt="upload successful"></p><p>可以看到 <code>opencv\build\etc</code>文件夹下有<code>haarcascades</code>和<code>lbpcascades</code>两种模式的分类器，我们以Haar分类器来看。</p><p>可以看到它下面的一些分类器文件demo，根据英文名称还是比较好确认它们是对于哪种类型图片进行识别的。</p><p>根据以上，我们来看一个寻找图片人脸并进行裁剪的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FaceDetector</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 人脸识别xml文件地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CASCADE_FACE_FILENAME = <span class="string">"D:\\opencv\\sources\\data\\haarcascades\\haarcascade_frontalface_alt.xml"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * opencv 安装的版本号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String opencvLibName = <span class="string">"opencv_java411"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * VM Options</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String vmOptions = <span class="string">"D:/opencv/build/java/x64"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 人脸裁剪</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sourceImage</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetFilePath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getFaceImages</span><span class="params">(String sourceImage,String targetFilePath)</span></span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(sourceImage);</span><br><span class="line">        <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"文件不存在！！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        CascadeClassifier faceDetector = <span class="keyword">new</span> CascadeClassifier(CASCADE_FACE_FILENAME);</span><br><span class="line">        <span class="keyword">if</span>(faceDetector.empty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"处理文件时发生异常！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Mat image = Imgcodecs.imread(sourceImage);</span><br><span class="line">        MatOfRect faceDetections = <span class="keyword">new</span> MatOfRect();</span><br><span class="line">        <span class="comment">// 进行人脸检测</span></span><br><span class="line">        faceDetector.detectMultiScale(image, faceDetections);</span><br><span class="line"></span><br><span class="line">        Rect[] rects = faceDetections.toArray();</span><br><span class="line">        <span class="keyword">if</span>(rects.length &lt;=<span class="number">0</span> )&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"原图片上未检测到人脸！！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">"检测到人脸数量：&#123;&#125;"</span>,rects.length);</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Rect rect : rects) &#123;</span><br><span class="line">            <span class="comment">// 进行图片裁剪</span></span><br><span class="line">            Mat mat = <span class="keyword">new</span> Mat(image,<span class="keyword">new</span> Rect(rect.x, rect.y,rect.width,rect.height));</span><br><span class="line">            <span class="comment">// 输出人脸图片</span></span><br><span class="line">            String outFilePath = targetFilePath +<span class="string">"/"</span>+ i+<span class="string">".jpg"</span>;</span><br><span class="line">            Imgcodecs.imwrite(outFilePath, mat);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        addLibraryDir(vmOptions);</span><br><span class="line">        System.loadLibrary(opencvLibName);</span><br><span class="line">        getFaceImages(<span class="string">"C:/Users/DELL-3020/Desktop/test.jpg"</span>,<span class="string">"C:\\Users\\DELL-3020\\Desktop"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们寻找一张照片（包含人脸），可以看到成功生成人脸图。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-593.jpg" alt="upload successful"></p><p>其检测裁剪逻辑主要如下：</p><ul><li>级联分类器加载样本分类器文件<code>haarcascade_frontalface_alt.xml</code>，检测该文件的正确性<code>!faceDetector.empty()</code>；</li><li>将待检测图片读为<code>Mat</code>，<code>Imgcodecs.imread</code>；</li><li>进行人脸检测<code>faceDetector.detectMultiScale</code>，该方法除了传入<code>Mat</code>外，还要传入一个<code>MatOfRect</code>，它是一个<code>Rect</code>数组，用来存放识别返回的”感兴趣”的区域（人脸区域）；</li><li>“感兴趣”的区域可以有多个，如果一个也没有，我们就可以认为这张待检测图片上不存在人脸；</li><li>如果有的话，我们可以根据矩形区域裁剪得到人脸。</li></ul><p>关于这部分我们先介绍到这儿，有兴趣的可以了解下例子文件里的其他级联分类器。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面我们主要说了OpenCV的安装、开发环境的配置等内容。</p><p>对于OpenCV的安装，我们根据一些文档手册，安装还是比较简单的；开发环境的配置方面，由于OpenCV主要以C++编写、开发和使用，因此应用在Java上还是不那么方便的（需要加载原生Lib库）。</p><p>对于OpenCV的使用，这儿说的比较少，只是简单的介绍了它的一些使用，其原理也未作深入分析。</p><p>后面我们继续来看下OpenCV的一些有意思的地方（图片训练、图片识别等）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="OpenCV" scheme="https://www.sakuratears.top/tags/OpenCV/"/>
    
      <category term="人脸识别" scheme="https://www.sakuratears.top/tags/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"/>
    
      <category term="IDEA" scheme="https://www.sakuratears.top/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>MySQL规范</title>
    <link href="https://www.sakuratears.top/blog/MySQL%E8%A7%84%E8%8C%83.html"/>
    <id>https://www.sakuratears.top/blog/MySQL规范.html</id>
    <published>2019-10-29T14:26:00.000Z</published>
    <updated>2019-10-29T14:54:09.819Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="建表规约"><a href="#建表规约" class="headerlink" title="建表规约"></a>建表规约</h1><ol><li><p><strong>【强制】</strong> 表达是与否概念的字段，必须使用<code>is_xxx</code> 的方式命名，数据类型是<code>unsigned tinyint</code> (1表示是，0表示否)。 </p><p> <strong>说明:</strong> 任何字段如果为非负数，必须是<code>unsigned</code>。 </p><p> <strong>注意:</strong> <code>POJO</code>类中的任何布尔类型的变量，都不要加<code>is</code>前缀，所以，需要在设置 从<code>is_xxx</code>到<code>Xxx</code>的映射关系。数据库表示是与否的值，使用<code>tinyint</code>类型，坚持<code>is_xxx</code>的命名方式是为了明确其取值含义与取值范围。</p><p> <strong>正例:</strong> 表达逻辑删除的字段名<code>is_deleted</code>，1 表示删除，0 表示未删除。</p></li><li><p><strong>【强制】</strong> 表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。</p><p> <strong>说明:</strong> <code>MySQL</code>在<code>Windows</code>下不区分大小写，但在<code>Linux</code>下默认是区分大小写。因此，数据库名、表名、字段名，都不允许出现任何大写字母，避免节外生枝。 </p><p> <strong>正例:</strong> <code>aliyun_admin</code>，<code>rdc_config</code>，<code>level3_name</code></p><p> <strong>反例:</strong><code>AliyunAdmin</code>，<code>rdcConfig</code>，<code>level_3_name</code></p></li><li><p><strong>【强制】</strong> 表名不使用复数名词。 </p><p> <strong>说明:</strong> 表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于<code>DO</code>类名也是单数形式，符合表达习惯。</p></li><li><p><strong>【强制】</strong> 禁止保留字，如<code>desc</code>、<code>range</code>、<code>match</code>、<code>delayed</code>等，请参考<code>MySQL</code>官方保留字。</p></li><li><p><strong>【强制】</strong> 主键索引名为<code>pk_字段名</code>;唯一索引名为<code>uk_字段名</code>;普通索引名则为 <code>idx_字段名</code>。</p><p> <strong>说明:</strong> <code>pk_</code> 即 <code>primary key</code>；<code> uk_</code> 即 <code>unique key</code>;<code>idx_</code>即<code>index</code>的简称。</p></li><li><p><strong>【强制】</strong> 小数类型为<code>decimal</code>，禁止使用<code>float</code>和<code>double</code>。 </p><p> <strong>说明:</strong> <code>float</code> 和 <code>double</code> 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过 <code>decimal</code> 的范围，建议将数据拆成整数和小数分开存储。</p></li><li><p><strong>【强制】</strong> 如果存储的字符串长度几乎相等，使用 <code>char</code> 定长字符串类型。</p></li><li><p><strong>【强制】</strong> <code>varchar</code> 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 <code>text</code>，独立出来一张表，用主键来对应，避免影响其它字段索引效率。</p></li><li><p><strong>【强制】</strong> 表必备三字段:<code>id, gmt_create, gmt_modified</code>。 </p><p> <strong>说明:</strong> 其中<code>id</code>必为主键，类型为<code>bigintunsigned</code>、单表时自增、步长为1。<code>gmt_create, gmt_modified</code> 的类型均为 <code>datetime</code> 类型，前者现在时表示主动创建，后者过去分词表示被动更新。</p></li><li><p><strong>【推荐】</strong> 表的命名最好是加上“业务名称_表的作用”。</p><p><strong>正例:</strong> <code>alipay_task / force_project / trade_config</code></p></li><li><p><strong>【推荐】</strong> 库名与应用名称尽量一致。</p></li><li><p><strong>【推荐】</strong> 如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。</p></li><li><p><strong>【推荐】</strong> 字段允许适当冗余，以提高查询性能，但必须考虑数据一致。</p><p>冗余字段应遵循:</p><ul><li>不是频繁修改的字段。 </li><li>不是 <code>varchar</code> 超长字段，更不能是 <code>text</code> 字段。</li></ul><p><strong>正例:</strong> 商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存储类目名称，避免关联查询。</p></li><li><p><strong>【推荐】</strong> 单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。 </p><p><strong>说明:</strong> 如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。</p></li><li><p><strong>【参考】</strong> 合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。</p><p><strong>正例:</strong> 如下表，其中无符号值可以避免误存负数，且扩大了表示范围。</p></li></ol><table><thead><tr><th>对象</th><th>年龄区间</th><th>类型</th><th>字节</th><th>表示范围</th></tr></thead><tbody><tr><td>人</td><td>150岁之内</td><td>tinyint unsigned</td><td>1</td><td>无符号值:0 到 255</td></tr><tr><td>龟</td><td>数百岁</td><td>smallint unsigned</td><td>2</td><td>无符号值:0 到 65535</td></tr><tr><td>恐龙化石</td><td>数千万年</td><td>int unsigned</td><td>4</td><td>无符号值:0 到约 42.9 亿</td></tr><tr><td>太阳</td><td>约50亿年</td><td>bigint unsigned</td><td>8</td><td>无符号值:0 到约 10 的 19 次方</td></tr></tbody></table><h1 id="索引规约"><a href="#索引规约" class="headerlink" title="索引规约"></a>索引规约</h1><ol><li><p><strong>【强制】</strong> 业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。 </p><p> <strong>说明:</strong> 不要以为唯一索引影响了 <code>insert</code> 速度，这个速度损耗可以忽略，但提高查找速度是明显的;另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。</p></li><li><p><strong>【强制】</strong> 超过三个表禁止 <code>join</code>。需要 <code>join</code> 的字段，数据类型必须绝对一致;多表关联查询时， 保证被关联的字段需要有索引。 </p><p> <strong>说明:</strong> 即使双表 <code>join</code> 也要注意表索引、SQL 性能。</p></li><li><p><strong>【强制】</strong> 在 <code>varchar</code> 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。</p><p> <strong>说明:</strong> 索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90%以上，可以使用 <code>count(distinct left(列名, 索引长度))/count(*)</code>的区分度来确定。</p></li><li><p><strong>【强制】</strong> 页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。 </p><p> <strong>说明:</strong> 索引文件具有 <code>B-Tree</code> 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</p></li><li><p><strong>【推荐】</strong> 如果有 <code>order by</code> 的场景，请注意利用索引的有序性。<code>order by</code> 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现 <code>file_sort</code> 的情况，影响查询性能。 </p><p> <strong>正例:</strong> <code>where a=? and b=? order by c; 索引:a_b_c </code></p><p> <strong>反例:</strong> 索引中有范围查找，那么索引有序性无法利用，如:<code>WHERE a&gt;10 ORDER BY b; 索引 a_b 无法排序。</code></p></li><li><p><strong>【推荐】</strong> 利用覆盖索引来进行查询操作，避免回表。 *</p><p><strong>说明:</strong> 如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗?目录浏览一下就好，这个目录就是起到覆盖索引的作用。 </p><p> <strong>正例:</strong> 能够建立索引的种类分为主键索引、唯一索引、普通索引三种，而覆盖索引只是一种查询的一种效果，用explain的结果，extra列会出现:<code>using index</code>。</p></li><li><p><strong>【推荐】</strong> 利用延迟关联或者子查询优化超多分页场景。</p><p> <strong>说明:</strong> <code>MySQL</code> 并不是跳过 <code>offset</code> 行，而是取 <code>offset+N</code> 行，然后返回放弃前 <code>offset</code> 行，返回 <code>N</code> 行，那当 <code>offset</code> 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 <code>SQL</code> 改写。 </p><p> <strong>正例:</strong> 先快速定位需要获取的 id 段，然后再关联:<code>SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id</code></p></li><li><p><strong>【推荐】</strong> <code>SQL</code> 性能优化的目标:至少要达到 <code>range</code> 级别，要求是 <code>ref</code> 级别，如果可以是 <code>consts</code> 最好。</p><p> <code>SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id</code></p><p> <strong>说明:</strong> </p><ul><li><code>consts</code> 单表中最多只有一个匹配行(主键或者唯一索引)，在优化阶段即可读取到数据。</li><li><code>ref</code> 指的是使用普通的索引(<code>normal index</code>)。</li><li><code>range</code> 对索引进行范围检索。</li></ul><p><strong>反例:</strong> explain 表的结果，<code>type=index</code>，索引物理文件全扫描，速度非常慢，这个 <code>index</code> 级别比较<code>range</code> 还低，与全表扫描是小巫见大巫。</p></li><li><p><strong>【推荐】</strong> 建组合索引的时候，区分度最高的在最左边。 </p><p><strong>正例:</strong> 如果 <code>where a=? and b=?</code> ，如果 a 列的几乎接近于唯一值，那么只需要单建 <code>idx_a</code> 索引即可。 </p><p><strong>说明:</strong> 存在非等号和等号混合时，在建索引时，请把等号条件的列前置。如:<code>where c&gt;? and d=?</code> 那么即使 c 的区分度更高，也必须把 d 放在索引的最前列，即索引 <code>idx_d_c</code>。</p></li><li><p><strong>【推荐】</strong> 防止因字段类型不同造成的隐式转换，导致索引失效。</p></li><li><p><strong>【参考】</strong> 创建索引时避免有如下极端误解:</p><ul><li>宁滥勿缺。认为一个查询就需要建一个索引。</li><li>宁缺勿滥。认为索引会消耗空间、严重拖慢更新和新增速度。</li><li>抵制唯一索引。认为业务的唯一性一律需要在应用层通过“先查后插”方式解决。</li></ul></li></ol><h1 id="SQL-语句"><a href="#SQL-语句" class="headerlink" title="SQL 语句"></a>SQL 语句</h1><ol><li><p><strong>【强制】</strong> 不要使用 <code>count(列名)</code>或 <code>count(常量)</code>来替代 <code>count()</code>，<code>count()</code>是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。 </p><p> <strong>说明:</strong> <code>count(*)</code>会统计值为 NULL 的行，而 <code>count(列名)</code>不会统计此列为 NULL 值的行。</p></li><li><p><strong>【强制】</strong> <code>count(distinct col)</code> 计算该列除 NULL 之外的不重复行数，注意 <code>count(distinct col1, col2)</code>如果其中一列全为NULL，那么即使另一列有不同的值，也返回为0。</p></li><li><p><strong>【强制】</strong> 当某一列的值全是 NULL 时，<code>count(col)</code>的返回结果为 0，但<code>sum(col)</code>的返回结果为NULL，因此使用 <code>sum()</code>时需注意 NPE 问题。 </p><p> <strong>正例:</strong> 可以使用如下方式来避免sum的NPE问题:<code>SELECT IF(ISNULL(SUM(g)),0,SUM(g)) FROM table</code>;</p></li><li><p><strong>【强制】</strong> 使用 <code>ISNULL()</code>来判断是否为 NULL 值。 </p><p> <strong>说明:</strong> NULL 与任何值的直接比较都为 NULL。</p><ul><li>NULL&lt;&gt;NULL 的返回结果是NULL，而不是false。 </li><li>NULL=NULL 的返回结果是NULL，而不是true。 </li><li>NULL&lt;&gt;1 的返回结果是NULL，而不是true。</li></ul></li><li><p><strong>【强制】</strong>  在代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句。</p></li><li><p><strong>【强制】</strong> 不得使用外键与级联，一切外键概念必须在应用层解决。 </p><p> <strong>说明:</strong> 以学生和成绩的关系为例，学生表中的 <code>student_id</code> 是主键，那么成绩表中的 <code>student_id</code> 则为外键。</p><p> 如果更新学生表中的<code>student_id</code>，同时触发成绩表中的 <code>student_id</code> 更新，即为级联更新。</p><ul><li>外键与级联更新适用于单机低并发，不适合分布式、高并发集群;</li><li>级联更新是强阻塞，存在数据库更新风暴的风险;</li><li>外键影响数据库的插入速度。</li></ul></li><li><p><strong>【强制】</strong> 禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。</p></li><li><p><strong>【强制】</strong> 数据订正(特别是删除、修改记录操作)时，要先 select，避免出现误删除，确认无误才能执行更新语句。</p></li><li><p><strong>【推荐】</strong> in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控制在1000 个之内。</p></li><li><p><strong>【参考】</strong> 如果有国际化需要，所有的字符存储与表示，均以 <code>utf-8</code> 编码，注意字符统计函数的区别。</p><p><strong>说明:</strong> </p><p><code>SELECT LENGTH(“轻松工作”)</code>; 返回为12<br><code>SELECT CHARACTER_LENGTH(“轻松工作”)</code>; 返回为4</p><p>如果需要存储表情，那么选择 <code>utf8mb4</code> 来进行存储，注意它与 <code>utf-8</code> 编码的区别。</p></li><li><p><strong>【参考】</strong> <code>TRUNCATE TABLE</code> 比 <code>DELETE</code> 速度快，且使用的系统和事务日志资源少，但 <code>TRUNCATE</code>无事务且不触发 <code>trigger</code>，有可能造成事故，故不建议在开发代码中使用此语句。 </p><p><strong>说明:</strong> <code>TRUNCATE TABLE</code> 在功能上与不带 <code>WHERE</code> 子句的 <code>DELETE</code> 语句相同。</p></li></ol><h1 id="ORM-映射"><a href="#ORM-映射" class="headerlink" title="ORM 映射"></a>ORM 映射</h1><ol><li><p><strong>【强制】</strong> 在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。 </p><p> <strong>说明:</strong> </p><ul><li>增加查询分析器解析成本。</li><li>增减字段容易与 <code>resultMap</code> 配置不一致。</li><li>无用字段增加网络消耗，尤其是 <code>text</code> 类型的字段。</li></ul></li><li><p><strong>【强制】</strong> <code>POJO</code> 类的布尔属性不能加 is，而数据库字段必须加 is_，要求在 <code>resultMap</code> 中进行字段与属性之间的映射。 </p><p> <strong>说明:</strong> 参见定义 POJO 类以及数据库字段定义规定，在中增加映射，是必须的。 在MyBatis Generator生成的代码中，需要进行对应的修改。</p></li><li><p><strong>【强制】</strong> 不要用 <code>resultClass</code> 当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义;反过来，每一个表也必然有一个 <code>POJO</code> 类与之对应。 </p><p> <strong>说明:</strong> 配置映射关系，使字段与 <code>DO</code> 类解耦，方便维护。</p></li><li><p><strong>【强制】</strong> <code>sql.xml</code> 配置参数使用:#{}，#param# 不要使用${} 此种方式容易出现 SQL 注入。</p></li><li><p><strong>【强制】</strong> iBATIS自带的<code>queryForList(String statementName,int start,int size)</code>不推荐使用。</p><p> <strong>说明:</strong> 其实现方式是在数据库取到 <code>statementName</code> 对应的 SQL 语句的所有记录，再通过 subList取 <code>start,size</code> 的子集合。</p><p> <strong>正例:</strong> </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt; String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"start"</span>, start);</span><br><span class="line">map.put(<span class="string">"size"</span>, size);</span><br></pre></td></tr></table></figure></li><li><p><strong>【强制】</strong> 不允许直接拿 <code>HashMap</code> 与 <code>Hashtable</code> 作为查询结果集的输出。</p><p> <strong>说明:</strong> <code>resultClass=”Hashtable”</code>，会置入字段名和属性值，但是值的类型不可控。</p></li><li><p><strong>【强制】</strong> 更新数据表记录时，必须同时更新记录对应的 <code>gmt_modified</code> 字段值为当前时间。</p></li><li><p><strong>【推荐】</strong> 不要写一个大而全的数据更新接口。传入为 <code>POJO</code> 类，不管是不是自己的目标更新字段，都进行 <code>update table set c1=value1,c2=value2,c3=value3</code>; 这是不对的。</p><p> 执行 SQL 时，不要更新无改动的字段，一是易出错;二是效率低;三是增加 <code>binlog</code> 存储。</p></li><li><p><strong>【参考】</strong> <code>@Transactional</code> 事务不要滥用。事务会影响数据库的 QPS，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。</p></li><li><p><strong>【参考】</strong> 中的 <code>compareValue</code> 是与属性值对比的常量，一般是数字，表示相等时带上此条件;表示不为空且不为 null 时执行;表示不为 null 值时执行。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="MySQL" scheme="https://www.sakuratears.top/tags/MySQL/"/>
    
      <category term="规范" scheme="https://www.sakuratears.top/tags/%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>Java图片处理相关</title>
    <link href="https://www.sakuratears.top/blog/Java%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3.html"/>
    <id>https://www.sakuratears.top/blog/Java图片处理相关.html</id>
    <published>2019-10-27T10:54:00.000Z</published>
    <updated>2019-10-27T10:56:53.494Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近总结了Java处理图片的一些方法，特此分享下。</p><p>其中主要涉及到2种不同的类包。</p><p>一种是Java自带的<code>ImageIO</code>、<code>Graphics2D</code>、<code>BufferedImage</code>等类的使用；另一种是使用了<code>net.coobird.thumbnailator</code>包下的图片相关类。</p><p><code>net.coobird.thumbnailator</code>包中对图片的操作底层其实也使用了Java自带的图片操作类相关方法，这儿不做过多讨论，有兴趣的可以直接看下它的源码。</p><p>PS: <code>net.coobird.thumbnailator</code>这个工具包在2014年12月 0.4.8版本后就再也没有维护过了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.coobird<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thumbnailator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.4.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>我们来看一下相关的处理方法。</p><h2 id="获取图片真实格式（与后缀无关）"><a href="#获取图片真实格式（与后缀无关）" class="headerlink" title="获取图片真实格式（与后缀无关）"></a>获取图片真实格式（与后缀无关）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getExtension</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(filePath);</span><br><span class="line">    <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"图片地址不正确，请传入正确的图片地址！！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//图片真实格式</span></span><br><span class="line">    String format = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">try</span> (ImageInputStream iis = ImageIO.createImageInputStream(file)) &#123;</span><br><span class="line">        Iterator&lt;ImageReader&gt; iter = ImageIO.getImageReaders(iis);</span><br><span class="line">        <span class="keyword">if</span> (iter.hasNext()) &#123;</span><br><span class="line">            format = iter.next().getFormatName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"获取图片真实格式时出现异常！！"</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> format;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法可以获得图片的真实格式，这个格式和图片的后缀无关。</p><p>其返回的格式为大写，如JPEG，PNG等。</p><p>PS: jpg和jpeg类型的图片返回的格式均为JPEG。</p><h2 id="图片彩色转为黑白"><a href="#图片彩色转为黑白" class="headerlink" title="图片彩色转为黑白"></a>图片彩色转为黑白</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图片彩色转为黑白 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceImagePath 源图像地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetImagePath 生成的目标图像地址（不包含文件名称）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">gray</span><span class="params">(String sourceImagePath, String targetImagePath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//获取图片真实格式</span></span><br><span class="line">    String sourceFormat = getExtension(sourceImagePath).toLowerCase();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//黑白处理</span></span><br><span class="line">    BufferedImage src = ImageIO.read(<span class="keyword">new</span> File(sourceImagePath));</span><br><span class="line">    ColorSpace cs = ColorSpace.getInstance(ColorSpace.CS_GRAY);</span><br><span class="line">    ColorConvertOp op = <span class="keyword">new</span> ColorConvertOp(cs, <span class="keyword">null</span>);</span><br><span class="line">    src = op.filter(src, <span class="keyword">null</span>);</span><br><span class="line">    String targetFile = targetImagePath + <span class="string">"/"</span> + getUUID() + <span class="string">"."</span> + sourceFormat;</span><br><span class="line">    ImageIO.write(src, sourceFormat, <span class="keyword">new</span> File(targetFile));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> targetFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法可对彩色图片进行黑白处理。</p><h2 id="图片格式转换"><a href="#图片格式转换" class="headerlink" title="图片格式转换"></a>图片格式转换</h2><p><strong>A方法：使用Thumbnails进行图片格式转换</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图片格式转换 A 方案</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetFormat   目标格式 jpg  jpeg png 见枚举</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceFilePath 源文件路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetFilePath 生成目标文件路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">convertA</span><span class="params">(String targetFormat, String sourceFilePath, String targetFilePath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//校验</span></span><br><span class="line">    <span class="keyword">if</span> (isBlank(targetFormat) || isBlank(sourceFilePath) || isBlank(targetFilePath)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数错误！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取图片真实格式</span></span><br><span class="line">    String sourceFormat = getExtension(sourceFilePath).toLowerCase();</span><br><span class="line">    <span class="comment">//获取图片后缀格式</span></span><br><span class="line">    String suffixFormat = sourceFilePath.substring(sourceFilePath.lastIndexOf(<span class="string">"."</span>) + <span class="number">1</span>).toLowerCase();</span><br><span class="line">    <span class="comment">//目标格式</span></span><br><span class="line">    String targetFormatStr = targetFormat.toLowerCase();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是目标格式，就直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (sourceFormat.equals(targetFormatStr) &amp;&amp; suffixFormat.equals(targetFormatStr)) &#123;</span><br><span class="line">        <span class="keyword">return</span> sourceFilePath;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用Thumbnails处理</span></span><br><span class="line">    String targetFile = targetFilePath + <span class="string">"/"</span> + getUUID() + <span class="string">"."</span> + targetFormatStr;</span><br><span class="line">    Thumbnails.of(sourceFilePath).scale(<span class="number">1.0f</span>).outputFormat(targetFormatStr).toFile(targetFile);</span><br><span class="line">    <span class="keyword">return</span> targetFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>B方法：使用ImageIO进行图片格式转换</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图片格式转换 B 方案</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetFormat   目标格式 jpg  jpeg png 见枚举</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceFilePath 源文件路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetFilePath 生成目标文件路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">convertB</span><span class="params">(String targetFormat, String sourceFilePath, String targetFilePath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//校验</span></span><br><span class="line">    <span class="keyword">if</span> (isBlank(targetFormat) || isBlank(sourceFilePath) || isBlank(targetFilePath)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数错误！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取图片真实格式</span></span><br><span class="line">    String sourceFormat = getExtension(sourceFilePath).toLowerCase();</span><br><span class="line">    <span class="comment">//获取图片后缀格式</span></span><br><span class="line">    String suffixFormat = sourceFilePath.substring(sourceFilePath.lastIndexOf(<span class="string">"."</span>) + <span class="number">1</span>).toLowerCase();</span><br><span class="line">    <span class="comment">//目标格式</span></span><br><span class="line">    String targetFormatStr = targetFormat.toLowerCase();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是目标格式，就直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (sourceFormat.equals(targetFormatStr) &amp;&amp; suffixFormat.equals(targetFormatStr)) &#123;</span><br><span class="line">        <span class="keyword">return</span> sourceFilePath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getExtension方法已经校验了文件存不存在，这儿不用校验</span></span><br><span class="line">    File file = <span class="keyword">new</span> File(sourceFilePath);</span><br><span class="line">    <span class="comment">//使用ImageIO处理</span></span><br><span class="line">    String targetFile = targetFilePath + <span class="string">"/"</span> + getUUID() + <span class="string">"."</span> + targetFormatStr;</span><br><span class="line">    BufferedImage src = ImageIO.read(file);</span><br><span class="line">    ImageIO.write(src, targetFormatStr, <span class="keyword">new</span> File(targetFile));</span><br><span class="line">    <span class="keyword">return</span> targetFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种方法都可以实现图片格式转换。</p><h2 id="图片旋转相关"><a href="#图片旋转相关" class="headerlink" title="图片旋转相关"></a>图片旋转相关</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图片旋转</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceImage    原图片</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetImagePath   生成图片路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> angle          旋转角度   正数为顺时针旋转，负数为逆时针旋转</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">rotate</span><span class="params">(String sourceImage, String targetImagePath,<span class="keyword">double</span> angle)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isBlank(sourceImage)||isBlank(targetImagePath))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数错误！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取图片真实格式</span></span><br><span class="line">    String sourceFormat = getExtension(sourceImage).toLowerCase();</span><br><span class="line">    String targetFile = targetImagePath + <span class="string">"/"</span> + getUUID() + <span class="string">"."</span> + sourceFormat;</span><br><span class="line"></span><br><span class="line">    Thumbnails.of(sourceImage).scale(<span class="number">1.0f</span>).rotate(angle).outputFormat(sourceFormat).toFile(targetFile);</span><br><span class="line">    <span class="keyword">return</span> targetFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这儿我们使用Thumbnails工具来实现图片的旋转。</p><h2 id="图片缩放相关"><a href="#图片缩放相关" class="headerlink" title="图片缩放相关"></a>图片缩放相关</h2><p>图片缩放有两种类型，一种是根据比例进行缩放，另一种是按照大小进行缩放。</p><p>我们分别来看一下。</p><p><strong>A方法：使用Thumbnails进行图片比例缩放和大小缩放</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图片缩放</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceImage     原图片</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetImagePath 生成的图片地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> scaleWidth      宽度缩放比例    0&lt; scaleWidth &lt;1 表示缩小   scaleWidth &gt;1 表示放大</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> scaleHeight     高度缩放比例   0&lt; scaleWidth &lt;1 表示缩小   scaleWidth &gt;1 表示放大  （宽高缩放比相同图片将进行等比缩放）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">scale</span><span class="params">(String sourceImage, String targetImagePath, <span class="keyword">double</span> scaleWidth, <span class="keyword">double</span> scaleHeight)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isBlank(sourceImage) || isBlank(targetImagePath) || scaleWidth &lt;= <span class="number">0</span> || scaleHeight &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数错误！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取图片真实格式</span></span><br><span class="line">    String sourceFormat = getExtension(sourceImage).toLowerCase();</span><br><span class="line">    String targetFile = targetImagePath + <span class="string">"/"</span> + getUUID() + <span class="string">"."</span> + sourceFormat;</span><br><span class="line"></span><br><span class="line">    Thumbnails.of(sourceImage).scale(scaleWidth, scaleHeight).toFile(targetFile);</span><br><span class="line">    <span class="keyword">return</span> targetFile;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将图片调整到指定大小</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceImage     原图片</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetImagePath 生成目标图片地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> width           调整后的宽度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> height          调整后的高度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keep            是否保持宽高比</span></span><br><span class="line"><span class="comment"> *                        keep = false</span></span><br><span class="line"><span class="comment"> *                        比如照片长宽为 100*97 ，则</span></span><br><span class="line"><span class="comment"> *                        size(200,500) 后照片变为 200*198</span></span><br><span class="line"><span class="comment"> *                        size(300,198)后照片变为200*198</span></span><br><span class="line"><span class="comment"> *                        size(50,100)后照片变为50*49</span></span><br><span class="line"><span class="comment"> *                        size(80,49)后照片变为50*49</span></span><br><span class="line"><span class="comment"> *                        可见该种缩放会保持长宽比，可能导致长或宽有一项看起来不符合我们的预设值</span></span><br><span class="line"><span class="comment"> *                        设置了keep = true ，就会按照指定的宽高变化了</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">size</span><span class="params">(String sourceImage, String targetImagePath, <span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">boolean</span> keep)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isBlank(sourceImage) || isBlank(targetImagePath) || width &lt;= <span class="number">0</span> || height &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数错误！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取图片真实格式</span></span><br><span class="line">    String sourceFormat = getExtension(sourceImage).toLowerCase();</span><br><span class="line">    String targetFile = targetImagePath + <span class="string">"/"</span> + getUUID() + <span class="string">"."</span> + sourceFormat;</span><br><span class="line"></span><br><span class="line">    Thumbnails.of(sourceImage).size(width, height).keepAspectRatio(keep).toFile(targetFile);</span><br><span class="line">    <span class="keyword">return</span> targetFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>B方法：使用ImageIO进行图片比例缩放和大小缩放</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图片缩放，不常用，使用ImageIO进行的缩放</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceImage     原图片</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetImagePath 生成目标图片地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> scaleWidth      宽度缩放比例    0&lt; scaleWidth &lt;1 表示缩小   scaleWidth &gt;1 表示放大</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> scaleHeight     高度缩放比例   0&lt; scaleWidth &lt;1 表示缩小   scaleWidth &gt;1 表示放大</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">scaleB</span><span class="params">(String sourceImage, String targetImagePath, <span class="keyword">double</span> scaleWidth, <span class="keyword">double</span> scaleHeight)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isBlank(sourceImage) || isBlank(targetImagePath) || scaleWidth &lt;= <span class="number">0</span> || scaleHeight &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数错误！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取图片真实格式</span></span><br><span class="line">    String sourceFormat = getExtension(sourceImage).toLowerCase();</span><br><span class="line">    String targetFile = targetImagePath + <span class="string">"/"</span> + getUUID() + <span class="string">"."</span> + sourceFormat;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用ImageIO处理</span></span><br><span class="line">    BufferedImage src = ImageIO.read(<span class="keyword">new</span> File(sourceImage));</span><br><span class="line">    <span class="keyword">int</span> width = src.getWidth();</span><br><span class="line">    <span class="keyword">int</span> height = src.getHeight();</span><br><span class="line">    width = (<span class="keyword">int</span>) (width * scaleWidth);</span><br><span class="line">    height = (<span class="keyword">int</span>) (height * scaleHeight);</span><br><span class="line"></span><br><span class="line">    Image image = src.getScaledInstance(width, height, Image.SCALE_DEFAULT);</span><br><span class="line">    BufferedImage tag = <span class="keyword">new</span> BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);</span><br><span class="line">    Graphics g = tag.getGraphics();</span><br><span class="line">    g.drawImage(image, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">    g.dispose();</span><br><span class="line">    ImageIO.write(tag, sourceFormat, <span class="keyword">new</span> File(targetFile));</span><br><span class="line">    <span class="keyword">return</span> targetFile;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缩放图像（按照高度和宽度），不推荐使用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceImage     原图像</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetImagePath 生成的图像地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> width           要缩放到的宽</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> height          要缩放到的高</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keep            比例不对时是否需要补白：true为补白; false为不补白</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">sizeB</span><span class="params">(String sourceImage, String targetImagePath, <span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">boolean</span> keep)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isBlank(sourceImage) || isBlank(targetImagePath) || width &lt;= <span class="number">0</span> || height &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数错误！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取图片真实格式</span></span><br><span class="line">    String sourceFormat = getExtension(sourceImage).toLowerCase();</span><br><span class="line">    String targetFile = targetImagePath + <span class="string">"/"</span> + getUUID() + <span class="string">"."</span> + sourceFormat;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//缩放比例</span></span><br><span class="line">    <span class="keyword">double</span> ratio = <span class="number">0.0</span>;</span><br><span class="line">    BufferedImage bi = ImageIO.read(<span class="keyword">new</span> File(sourceImage));</span><br><span class="line">    Image image = bi.getScaledInstance(width, height, Image.SCALE_SMOOTH);</span><br><span class="line">    <span class="comment">// 计算比例</span></span><br><span class="line">    <span class="keyword">if</span> ((bi.getHeight() &gt; height) || (bi.getWidth() &gt; width)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bi.getHeight() &gt; bi.getWidth()) &#123;</span><br><span class="line">            ratio = (<span class="keyword">double</span>) (height / bi.getHeight());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ratio = (<span class="keyword">double</span>) (width / bi.getWidth());</span><br><span class="line">        &#125;</span><br><span class="line">        AffineTransformOp op = <span class="keyword">new</span> AffineTransformOp(AffineTransform.getScaleInstance(ratio, ratio), <span class="keyword">null</span>);</span><br><span class="line">        image = op.filter(bi, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否需要填充白色块</span></span><br><span class="line">    <span class="keyword">if</span> (keep) &#123;</span><br><span class="line">        BufferedImage temp = <span class="keyword">new</span> BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);</span><br><span class="line">        Graphics2D g = temp.createGraphics();</span><br><span class="line">        g.setColor(Color.WHITE);</span><br><span class="line">        g.fillRect(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">        <span class="keyword">if</span> (width == image.getWidth(<span class="keyword">null</span>)) &#123;</span><br><span class="line">            g.drawImage(image, <span class="number">0</span>, (height - image.getHeight(<span class="keyword">null</span>)) / <span class="number">2</span>,</span><br><span class="line">                    image.getWidth(<span class="keyword">null</span>), image.getHeight(<span class="keyword">null</span>),Color.WHITE, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            g.drawImage(image, (width - image.getWidth(<span class="keyword">null</span>)) / <span class="number">2</span>, <span class="number">0</span>,</span><br><span class="line">                    image.getWidth(<span class="keyword">null</span>), image.getHeight(<span class="keyword">null</span>),Color.WHITE, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        g.dispose();</span><br><span class="line">        image = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    ImageIO.write((BufferedImage) image, sourceFormat, <span class="keyword">new</span> File(targetFile));</span><br><span class="line">    <span class="keyword">return</span> targetFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们一般使用Thumbnails工具类提供的缩放来处理即可，这是比较常用的。</p><h2 id="图片压缩相关"><a href="#图片压缩相关" class="headerlink" title="图片压缩相关"></a>图片压缩相关</h2><p>图片压缩也大致有两种形式，一种是指定图片质量系数进行压缩，另一种是根据大小进行压缩。</p><p>PS：这儿对于根据大小进行压缩的意思是图片压缩后大小不会超过指定值，而不是压缩到指定值，因为理论上压缩到指定值是十分困难的，也是不必要的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图片压缩</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceImage     原图片</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetImagePath 生成的图片地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> quality         图片质量系数  [ 0,1]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">compress</span><span class="params">(String sourceImage, String targetImagePath, <span class="keyword">float</span> quality)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isBlank(sourceImage) || isBlank(targetImagePath) || quality &lt; <span class="number">0</span> || quality &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数错误！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取图片真实格式</span></span><br><span class="line">    String sourceFormat = getExtension(sourceImage).toLowerCase();</span><br><span class="line">    String targetFile = targetImagePath + <span class="string">"/"</span> + getUUID() + <span class="string">"."</span> + sourceFormat;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//控制图片生成质量，实际会压缩图片</span></span><br><span class="line">    Thumbnails.of(sourceImage).scale(<span class="number">1.0f</span>).outputQuality(quality).outputFormat(sourceFormat).toFile(targetFile);</span><br><span class="line">    <span class="keyword">return</span> targetFile;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 压缩图片文件 （文件大小不会超过指定值）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceImage     原文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetImagePath 生成的文件地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maxSize         文件被压缩后允许的最大大小，单位 byte</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">compress</span><span class="params">(String sourceImage, String targetImagePath, <span class="keyword">long</span> maxSize)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isBlank(sourceImage) || isBlank(targetImagePath) || maxSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数错误！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取图片真实格式</span></span><br><span class="line">    String sourceFormat = getExtension(sourceImage).toLowerCase();</span><br><span class="line">    String targetFile = targetImagePath + <span class="string">"/"</span> + getUUID() + <span class="string">"."</span> + sourceFormat;</span><br><span class="line"></span><br><span class="line">    File source = <span class="keyword">new</span> File(sourceImage);</span><br><span class="line">    <span class="keyword">long</span> size = source.length();</span><br><span class="line">    <span class="comment">//如果图片本身大小就不超过，就直接返回图片地址</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= maxSize) &#123;</span><br><span class="line">        <span class="keyword">return</span> sourceImage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算缩放比例</span></span><br><span class="line">    <span class="keyword">double</span> scale = (<span class="keyword">double</span>) (maxSize / size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//图片尺寸不变，压缩图片大小</span></span><br><span class="line">    Thumbnails.of(source).scale(<span class="number">1.0f</span>).outputQuality(scale).outputFormat(sourceFormat).toFile(targetFile);</span><br><span class="line">    <span class="keyword">return</span> targetFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们同样使用了Thumbnails工具类进行处理。</p><h2 id="图片切割相关"><a href="#图片切割相关" class="headerlink" title="图片切割相关"></a>图片切割相关</h2><p>切割主要有两种形式，一种是在原图指定位置切割一张指定大小的图片，另一种是把图片切割成若干份。</p><p><strong>A形式：从原图指定位置切割（裁剪）一张小图片</strong></p><p>可以通过Thumbnails工具类或者ImageIO实现，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从原图指定位置裁剪一张小图片</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceImage     原图</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetImagePath 生成的图片位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> positions       裁剪位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> width           裁剪宽</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> height          裁剪高</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">cutA</span><span class="params">(String sourceImage, String targetImagePath, Positions positions, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isBlank(sourceImage) || isBlank(targetImagePath) || positions == <span class="keyword">null</span> || width &lt;= <span class="number">0</span> || height &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数错误！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取图片真实格式</span></span><br><span class="line">    String sourceFormat = getExtension(sourceImage).toLowerCase();</span><br><span class="line">    String targetFile = targetImagePath + <span class="string">"/"</span> + getUUID() + <span class="string">"."</span> + sourceFormat;</span><br><span class="line"></span><br><span class="line">    Thumbnails.of(sourceImage).scale(<span class="number">1.0f</span>).sourceRegion(positions, width, height).outputFormat(sourceFormat).toFile(targetFile);</span><br><span class="line">    <span class="keyword">return</span> targetFile;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从原图指定位置裁剪一张小图片</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceImage     原图</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetImagePath 生成的图片位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x               裁剪位置x坐标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> y               裁剪位置y坐标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> width           裁剪宽</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> height          裁剪高</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">cutB</span><span class="params">(String sourceImage, String targetImagePath, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isBlank(sourceImage) || isBlank(targetImagePath) || x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || width &lt;= <span class="number">0</span> || height &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数错误！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取图片真实格式</span></span><br><span class="line">    String sourceFormat = getExtension(sourceImage).toLowerCase();</span><br><span class="line">    String targetFile = targetImagePath + <span class="string">"/"</span> + getUUID() + <span class="string">"."</span> + sourceFormat;</span><br><span class="line"></span><br><span class="line">    Thumbnails.of(sourceImage).scale(<span class="number">1.0f</span>).sourceRegion(x, y, width, height).outputFormat(sourceFormat).toFile(targetFile);</span><br><span class="line">    <span class="keyword">return</span> targetFile;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用ImageIO进行的切割，切割指定位置的一张图片</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceImage     原图</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetImagePath 生成图片位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x               切割图片的位置x</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> y               切割图片的位置y</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> width           切割图片的宽</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> height          切割图片的高</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">cutC</span><span class="params">(String sourceImage, String targetImagePath, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isBlank(sourceImage) || isBlank(targetImagePath) || x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || width &lt;= <span class="number">0</span> || height &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数错误！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取图片真实格式</span></span><br><span class="line">    String sourceFormat = getExtension(sourceImage).toLowerCase();</span><br><span class="line">    String targetFile = targetImagePath + <span class="string">"/"</span> + getUUID() + <span class="string">"."</span> + sourceFormat;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用ImageIO处理</span></span><br><span class="line">    BufferedImage bi = ImageIO.read(<span class="keyword">new</span> File(sourceImage));</span><br><span class="line">    <span class="keyword">int</span> srcWidth = bi.getHeight();</span><br><span class="line">    <span class="keyword">int</span> srcHeight = bi.getWidth();</span><br><span class="line">    Image image = bi.getScaledInstance(srcWidth, srcHeight,Image.SCALE_DEFAULT);</span><br><span class="line">    <span class="comment">// 四个参数分别为图像起点坐标和宽高</span></span><br><span class="line">    <span class="comment">// 即: CropImageFilter(int x,int y,int width,int height)</span></span><br><span class="line">    ImageFilter cropFilter = <span class="keyword">new</span> CropImageFilter(x, y, width, height);</span><br><span class="line">    Image img = Toolkit.getDefaultToolkit().createImage(<span class="keyword">new</span> FilteredImageSource(image.getSource(), cropFilter));</span><br><span class="line">    BufferedImage tag = <span class="keyword">new</span> BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);</span><br><span class="line">    Graphics g = tag.getGraphics();</span><br><span class="line">    g.drawImage(img, <span class="number">0</span>, <span class="number">0</span>, width, height, <span class="keyword">null</span>);</span><br><span class="line">    g.dispose();</span><br><span class="line">    <span class="comment">// 输出为文件</span></span><br><span class="line">    ImageIO.write(tag, sourceFormat, <span class="keyword">new</span> File(targetFile));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> targetFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>B形式：将原图分割成若干小图片</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分割图片</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> filePath           图片地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rows               纵向分割份数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cols               横向分割份数</span></span><br><span class="line"><span class="comment"> *                           rows = 2 cols = 2 则图片会分成4个相等大小的图片</span></span><br><span class="line"><span class="comment"> *                           rows = 2 cols = 1 则图片会分成2个大小相等的图片，分割为高度切割为2半</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> splitImageBasePath 输出小图片的基础路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String[][] splitImage(String filePath, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, String splitImageBasePath) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (rows &lt;= <span class="number">0</span> || cols &lt;= <span class="number">0</span> || isBlank(splitImageBasePath) || isBlank(filePath)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数错误！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String imageType = getExtension(filePath);</span><br><span class="line">    imageType = imageType.toLowerCase();</span><br><span class="line">    <span class="keyword">if</span> (!(JPG.equals(imageType) || JPEG.equals(imageType) || PNG.equals(imageType))) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"请使用jpg、jpeg、png类型的图片"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入文件</span></span><br><span class="line">    File file = <span class="keyword">new</span> File(filePath);</span><br><span class="line">    String fileName = file.getName();</span><br><span class="line">    String fileNamePrefix = fileName.substring(<span class="number">0</span>, fileName.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">    BufferedImage image = ImageIO.read(fis);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算每个小图的宽度和高度</span></span><br><span class="line">    <span class="keyword">int</span> chunkWidth = image.getWidth() / cols;</span><br><span class="line">    <span class="keyword">int</span> chunkHeight = image.getHeight() / rows;</span><br><span class="line"></span><br><span class="line">    BufferedImage[][] imgs = <span class="keyword">new</span> BufferedImage[rows][cols];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; rows; x++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; cols; y++) &#123;</span><br><span class="line">            <span class="comment">//设置小图的大小和类型</span></span><br><span class="line">            imgs[x][y] = <span class="keyword">new</span> BufferedImage(chunkWidth, chunkHeight, image.getType());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//写入图像内容</span></span><br><span class="line">            Graphics2D gr = imgs[x][y].createGraphics();</span><br><span class="line">            gr.drawImage(image, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    chunkWidth, chunkHeight,</span><br><span class="line">                    chunkWidth * y, chunkHeight * x,</span><br><span class="line">                    chunkWidth * y + chunkWidth,</span><br><span class="line">                    chunkHeight * x + chunkHeight, <span class="keyword">null</span>);</span><br><span class="line">            gr.dispose();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String[][] splitImages = <span class="keyword">new</span> String[rows][cols];</span><br><span class="line">    <span class="comment">// 输出小图</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; imgs.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; imgs[i].length; j++) &#123;</span><br><span class="line">            String splitImagePath = splitImageBasePath + <span class="string">"/"</span> + fileNamePrefix + i + <span class="string">"-"</span> + j + <span class="string">"."</span> + imageType;</span><br><span class="line">            splitImages[i][j] = splitImagePath;</span><br><span class="line">            ImageIO.write(imgs[i][j], imageType, <span class="keyword">new</span> File(splitImagePath));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> splitImages;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图片分割</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> filePath</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rows</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cols</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> splitImageBasePath</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">splitImageReturnList</span><span class="params">(String filePath, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, String splitImageBasePath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String[][] strings = splitImage(filePath, rows, cols, splitImageBasePath);</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(rows * cols);</span><br><span class="line">    <span class="keyword">for</span> (String[] strs : strings) &#123;</span><br><span class="line">        list.addAll(Arrays.asList(strs));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据单位图片大小切割图片</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> filePath            原图片</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> imageWidth          单位图片宽度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> imageHeight         单位图片高度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> splitImageBasePath   生成图片基础路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String[][] splitImageB(String filePath, <span class="keyword">int</span> imageWidth, <span class="keyword">int</span> imageHeight, String splitImageBasePath) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span>(isBlank(filePath)||imageWidth&lt;=<span class="number">0</span>||imageHeight&lt;=<span class="number">0</span>||isBlank(splitImageBasePath))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数错误！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    BufferedImage bufferedImage = ImageIO.read(<span class="keyword">new</span> File(filePath));</span><br><span class="line">    <span class="keyword">int</span> srcWidth = bufferedImage.getHeight();</span><br><span class="line">    <span class="keyword">int</span> srcHeight = bufferedImage.getWidth();</span><br><span class="line">    <span class="keyword">if</span>(srcWidth&lt;imageWidth||srcHeight&lt;imageHeight)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"基础图片长宽不符合要求！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cols;</span><br><span class="line">    <span class="keyword">int</span> rows;</span><br><span class="line">    <span class="comment">// 计算切片的横向和纵向数量</span></span><br><span class="line">    <span class="keyword">if</span> (srcWidth % imageWidth == <span class="number">0</span>) &#123;</span><br><span class="line">        cols = srcWidth / imageWidth;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cols = (<span class="keyword">int</span>) Math.floor((<span class="keyword">double</span>)(srcWidth / imageWidth)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (srcHeight % imageHeight == <span class="number">0</span>) &#123;</span><br><span class="line">        rows = srcHeight / imageHeight;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rows = (<span class="keyword">int</span>) Math.floor((<span class="keyword">double</span>)(srcHeight / imageHeight)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> splitImage(filePath,rows,cols,splitImageBasePath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述图片分割代码我们可以把一张图片分成9块来制造九宫格图片等。</p><h2 id="图片合并相关"><a href="#图片合并相关" class="headerlink" title="图片合并相关"></a>图片合并相关</h2><p>图片合并可以将两张或者多张图片按照顺序合成一整张图片。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并图片</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> images             图片列表</span></span><br><span class="line"><span class="comment"> *                           [1.jpg 2.jpg 3.jpg]</span></span><br><span class="line"><span class="comment"> *                           [4.jpg 5.jpg 6.jpg]</span></span><br><span class="line"><span class="comment"> *                           [7.jpg 8.jpg 9.jpg]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> finalImageBasePath 生成的图片要存放的位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">mergeImage</span><span class="params">(String[][] images, String finalImageBasePath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (images == <span class="keyword">null</span> || images.length == <span class="number">0</span> || isBlank(finalImageBasePath)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数不正确！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> rows = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cols = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; images.length; i++) &#123;</span><br><span class="line">        rows++;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; images[i].length; j++) &#123;</span><br><span class="line">            temp++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            cols = temp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (cols != temp) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"需要保证a * b 格式的图片"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String imageType = getExtension(images[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    imageType = imageType.toLowerCase();</span><br><span class="line">    <span class="keyword">if</span> (!(JPG.equals(imageType) || JPEG.equals(imageType) || PNG.equals(imageType))) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"请使用jpg、jpeg、png类型的图片"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> chunkWidth, chunkHeight;</span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建BufferedImage</span></span><br><span class="line">    BufferedImage[][] buffImages = <span class="keyword">new</span> BufferedImage[rows][cols];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            getExtension(images[i][j]);</span><br><span class="line">            buffImages[i][j] = ImageIO.read(<span class="keyword">new</span> File(images[i][j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    type = buffImages[<span class="number">0</span>][<span class="number">0</span>].getType();</span><br><span class="line">    chunkWidth = buffImages[<span class="number">0</span>][<span class="number">0</span>].getWidth();</span><br><span class="line">    chunkHeight = buffImages[<span class="number">0</span>][<span class="number">0</span>].getHeight();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置拼接后图的大小和类型</span></span><br><span class="line">    BufferedImage finalImg = <span class="keyword">new</span> BufferedImage(chunkWidth * cols, chunkHeight * rows, type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入图像内容</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            finalImg.createGraphics().drawImage(buffImages[i][j], chunkWidth * j, chunkHeight * i, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String filePath = finalImageBasePath + <span class="string">"/"</span> + getUUID() + <span class="string">"."</span> + imageType;</span><br><span class="line">    <span class="comment">//输出拼接后的图像</span></span><br><span class="line">    ImageIO.write(finalImg, imageType, <span class="keyword">new</span> File(filePath));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> filePath;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并图片</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> imageList</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rows</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> finalImageBasePath</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">mergeImage</span><span class="params">(List&lt;String&gt; imageList, <span class="keyword">int</span> rows, String finalImageBasePath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(imageList)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数错误"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rows &lt; <span class="number">0</span> || imageList.size() % rows != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数错误"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cols = imageList.size() / rows;</span><br><span class="line">    String[][] strings = <span class="keyword">new</span> String[rows][cols];</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strings.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; strings[i].length; j++) &#123;</span><br><span class="line">            strings[i][j] = imageList.get(temp);</span><br><span class="line">            temp++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mergeImage(strings, finalImageBasePath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图片水印相关"><a href="#图片水印相关" class="headerlink" title="图片水印相关"></a>图片水印相关</h2><h3 id="根据文字生成相应图片"><a href="#根据文字生成相应图片" class="headerlink" title="根据文字生成相应图片"></a>根据文字生成相应图片</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据文字生成JPG图片</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> text        要生成图片的文字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> picFontSize 字体大小设置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bgColor     图片整体背景色</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fontColor   文字颜色</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> font        字体</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> basePath    生成的图片地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createImageByText</span><span class="params">(String text, <span class="keyword">int</span> picFontSize, Color bgColor, Color fontColor, Font font, String basePath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//校验</span></span><br><span class="line">    <span class="keyword">if</span> (isBlank(text) || picFontSize &lt;= <span class="number">0</span> || bgColor == <span class="keyword">null</span> || fontColor == <span class="keyword">null</span> || font == <span class="keyword">null</span> || isBlank(basePath)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数错误！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于字体适应的单位长度</span></span><br><span class="line">    <span class="keyword">float</span> beautify = picFontSize / <span class="number">20.0f</span>;</span><br><span class="line">    <span class="comment">//图片宽高</span></span><br><span class="line">    <span class="keyword">int</span> width = text.length() * picFontSize + (<span class="keyword">int</span>) (<span class="number">5</span> * beautify);</span><br><span class="line">    <span class="keyword">int</span> height = picFontSize + (<span class="keyword">int</span>) (<span class="number">5</span> * beautify);</span><br><span class="line">    <span class="comment">//生成图片</span></span><br><span class="line">    BufferedImage bufferedImage = <span class="keyword">new</span> BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);</span><br><span class="line">    Graphics2D g = bufferedImage.createGraphics();</span><br><span class="line">    <span class="comment">//背景颜色</span></span><br><span class="line">    g.setColor(bgColor);</span><br><span class="line">    g.fillRect(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">    <span class="comment">//抗锯齿设置</span></span><br><span class="line">    g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);</span><br><span class="line">    <span class="comment">//字体颜色</span></span><br><span class="line">    g.setColor(fontColor);</span><br><span class="line">    g.setFont(font.deriveFont((<span class="keyword">float</span>) picFontSize));</span><br><span class="line">    <span class="comment">//在指定坐标除添加文字</span></span><br><span class="line">    g.drawString(text, beautify, picFontSize);</span><br><span class="line">    g.dispose();</span><br><span class="line">    String fileName = basePath + <span class="string">"/"</span> + getUUID() + <span class="string">"."</span> + PictureConstants.JPG;</span><br><span class="line">    <span class="keyword">try</span> (FileOutputStream out = <span class="keyword">new</span> FileOutputStream(fileName)) &#123;</span><br><span class="line">        ImageIO.write(bufferedImage, PictureConstants.JPEG, out);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fileName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法可以根据输入的文字、字体、颜色等生成一张图片。</p><h3 id="为图片添加图片水印"><a href="#为图片添加图片水印" class="headerlink" title="为图片添加图片水印"></a>为图片添加图片水印</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为图片在指定位置添加水印图片</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> watermark      水印图片</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceImage    原图片</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> positions      位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> opacity        透明度 [0.0 - 1.0]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetFilePath 目标文件生成路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">watermarkPic</span><span class="params">(String watermark, String sourceImage, Positions positions, <span class="keyword">float</span> opacity, String targetFilePath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isBlank(watermark) || isBlank(sourceImage) || isBlank(targetFilePath) || positions == <span class="keyword">null</span> || opacity &lt; <span class="number">0</span> || opacity &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数错误！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取图片真实格式</span></span><br><span class="line">    String sourceFormat = getExtension(sourceImage).toLowerCase();</span><br><span class="line">    String targetFile = targetFilePath + <span class="string">"/"</span> + getUUID() + <span class="string">"."</span> + sourceFormat;</span><br><span class="line">    Thumbnails.of(sourceImage).scale(<span class="number">1.0f</span>).watermark(positions, ImageIO.read(<span class="keyword">new</span> File(watermark)), opacity).outputFormat(sourceFormat).toFile(targetFile);</span><br><span class="line">    <span class="keyword">return</span> targetFile;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为图片在指定位置添加水印图片</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> watermark      水印图片</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceImage    原图片</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x              水印位置（距原图片中心 x方向的偏移量）  x&gt;0 在图片中心下方</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> y              水印位置（距原图片中心 y方向的偏移量）  y&gt;0 在图片中心右侧</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> opacity        透明度 [0.0 - 1.0]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetFilePath 目标文件生成路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">watermarkPic</span><span class="params">(String watermark, String sourceImage, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">float</span> opacity, String targetFilePath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isBlank(watermark) || isBlank(sourceImage) || isBlank(targetFilePath) || opacity &lt; <span class="number">0</span> || opacity &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数错误！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取图片真实格式</span></span><br><span class="line">    String sourceFormat = getExtension(sourceImage).toLowerCase();</span><br><span class="line">    String targetFile = targetFilePath + <span class="string">"/"</span> + getUUID() + <span class="string">"."</span> + sourceFormat;</span><br><span class="line"></span><br><span class="line">    Image src = ImageIO.read(<span class="keyword">new</span> File(sourceImage));</span><br><span class="line">    <span class="keyword">int</span> width = src.getWidth(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">int</span> height = src.getHeight(<span class="keyword">null</span>);</span><br><span class="line">    BufferedImage image = <span class="keyword">new</span> BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);</span><br><span class="line">    Graphics2D g = image.createGraphics();</span><br><span class="line">    g.drawImage(src, <span class="number">0</span>, <span class="number">0</span>, width, height, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 水印文件</span></span><br><span class="line">    Image waterPic = ImageIO.read(<span class="keyword">new</span> File(watermark));</span><br><span class="line">    <span class="keyword">int</span> waterWidth = waterPic.getWidth(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">int</span> waterHeight = waterPic.getHeight(<span class="keyword">null</span>);</span><br><span class="line">    g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_ATOP, opacity));</span><br><span class="line">    g.drawImage(waterPic, (width - waterWidth) / <span class="number">2</span> + x,</span><br><span class="line">            (height - waterHeight) / <span class="number">2</span> + y, waterWidth, waterHeight, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 水印文件结束</span></span><br><span class="line">    g.dispose();</span><br><span class="line">    ImageIO.write(image, sourceFormat, <span class="keyword">new</span> File(targetFile));</span><br><span class="line">    <span class="keyword">return</span> targetFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法分别使用了Thumbnails工具类和ImageIO类为原图片添加水印图片。</p><h3 id="为图片添加文字水印"><a href="#为图片添加文字水印" class="headerlink" title="为图片添加文字水印"></a>为图片添加文字水印</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加文字水印</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> text           水印文字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceImage    原图片</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fontColor      字体颜色</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> font           字体</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x              字体水印位置（距原图片中心 x方向的偏移量）  x&gt;0 在图片中心下方</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> y              字体水印位置（距原图片中心 x方向的偏移量）   y&gt;0 在图片中心右侧</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> opacity        透明度 [0.0 - 1.0]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetFilePath 目标文件生成路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">watermarkText</span><span class="params">(String text, String sourceImage, Color fontColor, Font font, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">float</span> opacity, String targetFilePath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isBlank(text) || isBlank(sourceImage) || fontColor == <span class="keyword">null</span> || font == <span class="keyword">null</span> || isBlank(targetFilePath) || opacity &lt; <span class="number">0</span> || opacity &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数错误！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取图片真实格式</span></span><br><span class="line">    String sourceFormat = getExtension(sourceImage).toLowerCase();</span><br><span class="line">    String targetFile = targetFilePath + <span class="string">"/"</span> + getUUID() + <span class="string">"."</span> + sourceFormat;</span><br><span class="line"></span><br><span class="line">    Image src = ImageIO.read(<span class="keyword">new</span> File(sourceImage));</span><br><span class="line">    <span class="keyword">int</span> width = src.getWidth(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">int</span> height = src.getHeight(<span class="keyword">null</span>);</span><br><span class="line">    BufferedImage image = <span class="keyword">new</span> BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);</span><br><span class="line">    Graphics2D g = image.createGraphics();</span><br><span class="line">    g.drawImage(src, <span class="number">0</span>, <span class="number">0</span>, width, height, <span class="keyword">null</span>);</span><br><span class="line">    g.setColor(fontColor);</span><br><span class="line">    g.setFont(font);</span><br><span class="line">    g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_ATOP, opacity));</span><br><span class="line">    <span class="comment">//抗锯齿设置</span></span><br><span class="line">    g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在指定坐标绘制水印文字</span></span><br><span class="line">    g.drawString(text, (width - (getLength(text) * font.getSize()))</span><br><span class="line">            / <span class="number">2</span> + x, (height - font.getSize()) / <span class="number">2</span> + y);</span><br><span class="line">    g.dispose();</span><br><span class="line">    ImageIO.write(image, sourceFormat, <span class="keyword">new</span> File(targetFile));</span><br><span class="line">    <span class="keyword">return</span> targetFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法可为图片在指定位置添加文字水印。</p><p>PS： </p><pre><code>这儿说下图片去水印的问题，一般情况下，对于一个项目，是保留原图，需要的时候再添加水印，从而实现添加水印和去除水印的效果。而如果就是想给一张有水印的图片去除水印，可以使用[OpenCV](https://opencv.org/)等相关进行处理。相关处理在这儿就不过多介绍了。Java在图片深度处理这方面是很一般的，一般进行图片深度处理时，都会调用其它语言的API。如上面提到的OpenCV，其核心算法就是由C++语言实现的，同时提供了其它语言的接口。</code></pre><h2 id="GIF图片的生成与转换"><a href="#GIF图片的生成与转换" class="headerlink" title="GIF图片的生成与转换"></a>GIF图片的生成与转换</h2><p>GIF相关操作可以使用<code>com.madgag.animated-gif-lib</code>相关Jar包，这个工具类Maven地址如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.madgag<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>animated-gif-lib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个工具包在 2017年7月维护到最新版本1.4后就再也没有维护过了。</p><p>这个工具包里有4个类<code>AnimatedGifEncoder.java</code>、<code>GifDecoder.java</code>、<code>LZWEncoder.java</code>、<code>NeuQuant.java</code>。</p><h3 id="将传入的若干图片生成gif"><a href="#将传入的若干图片生成gif" class="headerlink" title="将传入的若干图片生成gif"></a>将传入的若干图片生成gif</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据传入的图片生成指定间隔的gif图像</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> imageList 待处理图片</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> basePath  生成gif文件路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> delay     每张图片间隔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">imageToGif</span><span class="params">(List&lt;String&gt; imageList, String basePath, <span class="keyword">int</span> delay)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//校验</span></span><br><span class="line">    <span class="keyword">if</span>(isEmpty(imageList) || isBlank(basePath) || delay &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数错误！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String fileName = basePath + <span class="string">"/"</span> + getUUID() + <span class="string">"."</span> + PictureConstants.GIF;</span><br><span class="line">    File file = <span class="keyword">new</span> File(fileName);</span><br><span class="line">    <span class="keyword">try</span> (</span><br><span class="line">            ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="comment">//生成GIF</span></span><br><span class="line">        AnimatedGifEncoder e = <span class="keyword">new</span> AnimatedGifEncoder();</span><br><span class="line">        e.start(byteArrayOutputStream);</span><br><span class="line">        <span class="comment">//设置延迟时间</span></span><br><span class="line">        e.setDelay(delay);</span><br><span class="line">        <span class="keyword">for</span> (String imagePath : imageList) &#123;</span><br><span class="line">            e.addFrame(ImageIO.read(<span class="keyword">new</span> FileInputStream(imagePath)));</span><br><span class="line">            <span class="comment">//e.setDelay(delay);//可以设置不同的延迟时间</span></span><br><span class="line">        &#125;</span><br><span class="line">        e.finish();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写入到文件</span></span><br><span class="line">        <span class="keyword">byte</span>[] byteArray = byteArrayOutputStream.toByteArray();</span><br><span class="line">        fileOutputStream.write(byteArray);</span><br><span class="line">        fileOutputStream.flush();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fileName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用此方法，可以将传入的一系列图片生成一张gif，我们应尽量保证传入的图片格式一致。</p><h3 id="将gif图片拆分"><a href="#将gif图片拆分" class="headerlink" title="将gif图片拆分"></a>将gif图片拆分</h3><p>我们这里以jpg为例，将gif图片拆分成一张张jpg格式的图片。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * GIF 图片转 jpg</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> gifPath  GIF图片地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> basePath  生成图片地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">gifToImage</span><span class="params">(String gifPath, String basePath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//校验</span></span><br><span class="line">    <span class="keyword">if</span>(isBlank(gifPath) || isBlank(basePath))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数错误！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    File file = <span class="keyword">new</span> File(gifPath);</span><br><span class="line">    String fileName = file.getName();</span><br><span class="line">    String fileNamePrefix = fileName.substring(<span class="number">0</span>, fileName.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line">    String imagePath = basePath + <span class="string">"/"</span> + fileNamePrefix + <span class="string">"_%s."</span> + PictureConstants.JPG;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//GIF处理</span></span><br><span class="line">    GifDecoder gifDecoder = <span class="keyword">new</span> GifDecoder();</span><br><span class="line">    gifDecoder.read(gifPath);</span><br><span class="line">    <span class="comment">//frame个数</span></span><br><span class="line">    <span class="keyword">int</span> count = gifDecoder.getFrameCount();</span><br><span class="line">    List&lt;String&gt; imageList = <span class="keyword">new</span> ArrayList&lt;&gt;(count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">//得到帧</span></span><br><span class="line">        BufferedImage bufferedImage = gifDecoder.getFrame(i);</span><br><span class="line">        <span class="comment">//int delay = gifDecoder.getDelay(i);//延迟时间</span></span><br><span class="line">        String imageFileName = String.format(imagePath, i);</span><br><span class="line">        <span class="comment">//生成jpg文件</span></span><br><span class="line">        <span class="keyword">try</span> (FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(imageFileName)) &#123;</span><br><span class="line">            ImageIO.write(bufferedImage, PictureConstants.JPEG, fileOutputStream);</span><br><span class="line">        &#125;</span><br><span class="line">        imageList.add(imageFileName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> imageList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>将一些需要的代码记录下来形成自己的工具类包，提高自身经验总结，对以后是蛮有帮助的。</p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>源码详见我的 <a href="https://github.com/javazwt" rel="external nofollow noopener noreferrer" target="_blank">Github</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="图片处理" scheme="https://www.sakuratears.top/tags/%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86/"/>
    
      <category term="Thumbnailator" scheme="https://www.sakuratears.top/tags/Thumbnailator/"/>
    
  </entry>
  
  <entry>
    <title>MySQL优化</title>
    <link href="https://www.sakuratears.top/blog/MySQL%E4%BC%98%E5%8C%96.html"/>
    <id>https://www.sakuratears.top/blog/MySQL优化.html</id>
    <published>2019-10-27T09:16:00.000Z</published>
    <updated>2019-10-27T09:34:10.328Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="几个问题"><a href="#几个问题" class="headerlink" title="几个问题"></a>几个问题</h1><ol><li>如何发现慢查询？</li><li>为什么不建议使用订单号作为主键？</li><li>为什么要在需要排序的字段上加索引？</li><li>为什么字段加上函数或者计算就不走索引了？</li><li>为什么不建议字段允许为NULL？</li></ol><h1 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h1><h2 id="MySQL逻辑架构"><a href="#MySQL逻辑架构" class="headerlink" title="MySQL逻辑架构"></a>MySQL逻辑架构</h2><p>MySQL逻辑架构整体分为三层，如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-569.jpg" alt="upload successful"></p><ul><li><p>客户端：</p><ul><li>如，连接处理、授权认证、安全等功能</li></ul></li><li><p>核心服务：</p><ul><li>MySQL大多数核心服务均在这一层</li><li>包括查询解析、分析、优化、缓存、内置函数（如，时间、数学、加密等）</li><li>所有的跨存储引擎的功能也在这一层，如，存储过程、触发器、视图等</li></ul></li><li><p>存储引擎：</p><ul><li>负责MySQL中的数据存储和读取</li><li>中间的服务层通过API与存储引擎通信，这些API屏蔽了不同存储引擎间的差异</li></ul></li><li><p>重点解释下查询缓存：</p><ul><li>对于select语句，在解析查询之前，服务器会先检查查询缓存（Query Cache）。</li><li>如果命中，服务器便不再执行查询解析、优化和执行的过程，而是直接返回缓存中的结果集。</li></ul></li></ul><h2 id="MySQL执行过程"><a href="#MySQL执行过程" class="headerlink" title="MySQL执行过程"></a>MySQL执行过程</h2><p>下图是MySQL执行一个查询的过程。实际上每一步都比想象中的复杂，尤其优化器，更复杂也更难理解。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-570.jpg" alt="upload successful"></p><p><strong>MySQL查询过程如下：</strong></p><ol><li>客户端将查询发送到MySQL服务器；</li><li>服务器先检查查询缓存，如果命中，立即返回缓存中的结果，否则进入下一阶段；</li><li>服务器对SQL进行解析、预处理，再由优化器生成对象的执行计划；</li><li>MySQL根据优化器生成的执行计划，调用存储引擎API来执行查询；</li><li>服务器将结果返回给客户端，同时缓存查询结果。</li></ol><h2 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h2><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-571.jpg" alt="upload successful"></p><h3 id="InnoDB索引结构"><a href="#InnoDB索引结构" class="headerlink" title="InnoDB索引结构"></a>InnoDB索引结构</h3><p>在MySQL中索引是在存储引擎层实现的，而不是在服务器层实现的。不同存储引擎实现索引的方式也各有不同。</p><ul><li><p>Index_Type：</p><ul><li>主键</li><li>普通索引</li><li>唯一索引</li></ul></li><li><p>Index_Method：</p><ul><li><p>HASH： </p><p>  在HEAP表中，如果存储的数据重复度很低（也就是说基数很大），对该列数据以等值查询为主，没有范围查询、没有排序的时候，特别适合采用哈希索引。</p><p>  例如这种SQL：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> … <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> C1 = ?; — 仅等值查询</span><br></pre></td></tr></table></figure></li><li><p>BTREE（B+树）：</p><p>  在大多数场景下，都会有范围查询、排序、分组等查询特征，用B+树索引就可以了。B+树索引结构适用于绝大多数场景。</p><p>  为什么使用B+树？</p><p>  一、从内存⻆度上说，数据库中的索引一般时在磁盘上，数据量大的情况可能无法一次性装入内存，B+树的设计可以允许数据分批加载。</p><p>  二、从业务场景上说，如果只选择一个数据那确实是hash更快，但是数据库中经常会选中多条，这时候由于B+树索引有序，并且又有链表相连，它的查询效率比hash就快很多了。</p><ul><li><p>B-树</p><p>为了描述B-Tree，首先定义一条数据记录为一个二元组[key, data]，key为记录的键值，对于不同数据记录，key是互不相同的；data为数据记录除key外的数据。</p><p>那么B-Tree是满足下列条件的数据结构：</p><ul><li>d为大于1的一个正整数，称为B-Tree的深度。</li><li>h为一个正整数，称为B-Tree的高度。</li><li>每个非叶子节点由n-1个key和n个指针组成，其中d&lt;=n&lt;=2d。</li><li>每个叶子节点最少包含一个key和两个指针，最多包含2d-1个key和2d个指针，叶节点的指针均为null 。</li><li>所有叶节点具有相同的深度，等于树高h。</li><li>key和指针互相间隔，节点两端是指针。</li><li>一个节点中的key从左到右非递减排列。</li><li>所有节点组成树结构。</li><li>每个指针要么为null，要么指向另外一个节点。</li><li>如果某个指针在节点node最左边且不为null，则其指向节点的所有key小于v(key_1)，其中v(key_1)为node的第一个key的值。</li><li>如果某个指针在节点node最右边且不为null，则其指向节点的所有key大于v(key_m)，其中v(key_m)为node的最后一个key的值。</li><li>如果某个指针在节点node的左右相邻key分别是key_i和key{i+1}且不为null，则其指向节点的所有key小于v(key{i+1})且大于v(key_i)。</li></ul><p>下图是一个d=2的B-Tree示意图。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-572.jpg" alt="upload successful"></p></li><li><p>B+Tree</p><p>B-Tree有许多变种，其中最常用的是B+Tree，例如MySQL就普遍使⽤B+Tree实现其索引结构。</p><p>与B-Tree相比，B+Tree有以下不同点：</p><ul><li>每个节点的指针上限为2d而不是2d+1；</li><li>内节点不存储data，只存储key；</li><li>叶子节点不存储指针。</li></ul><p>下图是一个简单的B+Tree示意图。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-573.jpg" alt="upload successful"></p><p>一般来说，B+Tree比B-Tree更适合实现外存储索引结构，具体原因与外存储器原理及计算机存取原理有关。</p></li><li><p>带有顺序访问指针的B+Tree</p><p>一般在数据库系统或文件系统中使用的B+Tree结构都在经典B+Tree的基础上进行了优化，增加了顺序访问指针。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-574.jpg" alt="upload successful"></p><p>如图所示，在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。</p></li></ul></li></ul></li></ul><h3 id="InnoDB索引实现"><a href="#InnoDB索引实现" class="headerlink" title="InnoDB索引实现"></a>InnoDB索引实现</h3><ul><li><p>聚簇索引</p><p>  在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p><p>  <img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-575.jpg" alt="upload successful"></p><p>  上图是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。</p><blockquote><p>定义：数据行的物理顺序与列值（一般是主键那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引。</p></blockquote></li><li><p>辅助索引</p><p>  InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，下图为定义在Col3上的一个辅助索引：</p><p>  <img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-576.jpg" alt="upload successful"></p><p>  聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p><p>  了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。</p></li></ul><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h2 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h2><p>我们总是希望MySQL能够获得更高的查询性能，最好的办法是弄清楚MySQL是如何优化和执行查询的。一旦理解了这一点，就会发现：很多的查询优化工作实际上就是遵循一些原则让MySQL的优化器能够按照预想的合理方式运行而已。</p><ol><li><p>slow_query_log</p><p> 这个参数设置为ON，可以捕获执行时间超过一定数值的SQL语句。</p></li><li><p>long_query_time</p><p> 当SQL语句执行时间超过此数值时，就会被记录到日志中，建议设置为1或者更短。</p></li><li><p>slow_query_log_file</p><p> 记录日志的文件路径以及文件名。</p></li><li><p>log_queries_not_using_indexes</p><p> 这个参数设置为ON，可以捕获到所有未使用索引的SQL语句，尽管这个SQL语句有可能执行得很快。</p></li></ol><h2 id="慢查询解读"><a href="#慢查询解读" class="headerlink" title="慢查询解读"></a>慢查询解读</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">User@Host: <span class="title">test</span>[<span class="title">test</span>] @ [127.0.0.1] <span class="title">Id</span>: 85</span></span><br><span class="line"><span class="function"><span class="title">Query_time</span>: 3.299343 </span></span><br><span class="line"><span class="function"><span class="title">Lock_time</span>: 0.001484</span></span><br><span class="line"><span class="function"><span class="title">Rows_sent</span>: 10 </span></span><br><span class="line"><span class="function"><span class="title">Rows_examined</span>: 4844057</span></span><br><span class="line"><span class="function"><span class="title">SET</span> <span class="title">timestamp</span>=1557113299;</span></span><br><span class="line"><span class="function"><span class="title">SELECT</span></span></span><br><span class="line"><span class="function"> *</span></span><br><span class="line"><span class="function"><span class="title">FROM</span></span></span><br><span class="line"><span class="function"><span class="title">salaries</span></span></span><br><span class="line"><span class="function"><span class="title">ORDER</span> <span class="title">BY</span></span></span><br><span class="line"><span class="function"><span class="title">from_date</span>,</span></span><br><span class="line"><span class="function"><span class="title">salary</span></span></span><br><span class="line"><span class="function"><span class="title">LIMIT</span> 2000000, 10;</span></span><br></pre></td></tr></table></figure><p>从慢查询日志里面摘选一条慢查询日志，数据组成如下：</p><ol><li>用户名 、用户的IP信息、线程ID号</li><li>执行花费的时间【单位：毫秒】</li><li>执行获得锁的时间</li><li>获得的结果行数</li><li>扫描的数据行数</li><li>这SQL执行的具体时间</li><li>具体的SQL语句</li></ol><h2 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h2><h3 id="简要说明"><a href="#简要说明" class="headerlink" title="简要说明"></a>简要说明</h3><table><thead><tr><th>列名</th><th>表格查询的顺序编号</th><th>降序查看，id相同的从上到下查查看。id可以为null ，当table为(union ,m,n )类型的时候，id为null，这个时候，id的顺序为 m跟 n的后面。</th></tr></thead><tbody><tr><td>id</td><td>表查询的顺序编号</td><td>id相同，执行顺序由上至下；id不同，id值越大优先级越高，越先被执行</td></tr><tr><td>select_type</td><td>查询的方式</td><td>下文详细说明</td></tr><tr><td>table</td><td>表格名称</td><td>表名，别名，( union m,n ）</td></tr><tr><td>partitions</td><td>分区名称</td><td>查询使用到表分区的分区名</td></tr><tr><td>type</td><td>表连接的类型</td><td>下文详细说明</td></tr><tr><td>possible_keys</td><td>可能使用到的索引</td><td>这儿的索引只是可能会有到，实际不一定会用到</td></tr><tr><td>key</td><td>使用到的索引</td><td>实际使用的索引</td></tr><tr><td>key_len</td><td>使用到索引的长度</td><td>比如多列索引，只用到最左的一列，那么使用到索引的长度则为该列的长度，故该值不一定等于 key 列索引的长度</td></tr><tr><td>ref</td><td>谓词的关联信息</td><td>当 join type 为 const、eq_ref 或者 ref 时，谓词的关联信息。可能为 ：null（非 const \ eq_ref \ ref join type 时）、const（常量）、关联的谓词列名。显示该表的索引字段关联了哪张表的哪个字段</td></tr><tr><td>rows</td><td>扫描的行数</td><td>该表格扫描到的行数。这儿注意在mysql里边是嵌套链接，所以，需要把所有rows相乘就会得到查询数据行关联的次数</td></tr><tr><td>filtered</td><td>实际显示行数占扫描rows的比例</td><td>实际显示的行数 = rows * filtered / 100</td></tr><tr><td>extra</td><td>特性使用</td></tr></tbody></table><h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><ul><li><strong>SIMPLE</strong>，简单查询方式，不使用UNION跟子查询；</li><li><strong>PRIMARY</strong>，该表格位于最外层开始查询，通常会跟其他查询方式组合；</li><li><strong>SUBQUERY</strong>，子查询内层查询的第一个SELECT，结果不依赖于外部查询结果集（不会被数据库引擎改写的情况）；</li><li><strong>UNION</strong>，UNION 第一个SELECT 为PRIMARY，第二个及之后的所有SELECT 为 UNION SELECT TYPE；</li><li><strong>UNION RESULT</strong>，每个结果集的取出来后，会做合并操作，这个操作就是 UNION RESULT；</li><li><strong>DEPENDENT UNION</strong>，子查询中的UNION操作，从UNION 第二个及之后的所有SELECT语句的SELECT TYPE为 DEPENDENT UNION，这个一般跟DEPENDENT SUBQUERY⼀起结合应用，子查询中UNION 的第一个为DEPENDENT SUBQUERY；</li><li><strong>DEPENDENT SUBQUERY</strong>，子查询中内层的第一个SELECT，依赖于外部查询的结果集；</li><li><strong>DERIVED</strong>，查询使用内联视图；</li><li><strong>MATERIALIZED</strong>，子查询物化，表出现在非相关子查询中，并且需要进行物化时会出现MATERIALIZED关键词；</li><li><strong>UNCACHEABLE SUBQUERY</strong>，结果集无法缓存的子查询，需要逐次查询；</li><li><strong>UNCACHEABLE UNION</strong>，表示子查询不可被物化，需要逐次运行。</li></ul><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>性能排序：system-&gt;const-&gt;eq-ref-&gt;ref-&gt;fulltext-&gt;ref_or_null-&gt;index_merge-&gt;unique_subquery-&gt;index_subquery-&gt;range-&gt;index-&gt;ALL，一般来说，<strong>得保证查询至少达到range级别，最好能达到ref</strong>。</p><ul><li><strong>system</strong>：表只有一行记录，相当于系统表。</li><li><strong>const</strong>：通过索引一次就找到，只匹配一行数据。主键或者唯一索引的常量查询。</li><li><strong>eq_ref</strong>：join查询中，关联条件为主键或者唯一索引。</li><li><strong>ref</strong>：非唯一性索引扫描，返回匹配某个单独值的所有行，用于=、&lt;或&gt;操作符带索引的列。</li><li><strong>range</strong>：只检索给定范围的行，使用一个索引来选择行。一般使用between、&lt;、&gt;。</li><li><strong>index</strong>：只遍历索引树。使用到索引，但不是索引查找。</li><li><strong>all</strong>：全表扫描，性能最差。</li></ul><h3 id="extra"><a href="#extra" class="headerlink" title="extra"></a>extra</h3><p>重点以下几种情况：</p><ul><li><strong>Using filesort</strong>：MySQL会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。若出现有该值，应该优化SQL语句。</li><li><strong>Using temporary</strong>：使用临时表保存中间结果，比如MySQL在对查询结果排序时使用临时表，常见于group by和order by。若出现有该值，应该优化SQL语句。</li><li><strong>Using index</strong>：索引覆盖，不止用到索引，而且没有回表。避免了访问表的数据行，效率不错。</li></ul><h2 id="优化案例"><a href="#优化案例" class="headerlink" title="优化案例"></a>优化案例</h2><p>优化案例可以参考这篇文章 <a href="https://www.sakuratears.top/blog/MySql-%E4%BD%BF%E7%94%A8Explain%E5%88%86%E6%9E%90SQL%E8%AF%AD%E5%8F%A5%E5%8F%8A%E7%B4%A2%E5%BC%95.html">MySql 使用Explain分析SQL语句及索引</a></p><h2 id="优化口诀"><a href="#优化口诀" class="headerlink" title="优化口诀"></a>优化口诀</h2><blockquote><p>全职匹配我最爱，最左前缀要遵守；</p><p>带头大哥不能死，中间兄弟不能断；</p><p>索引列上少计算，范围之后全失效；</p><p>Like百分写最右，覆盖索引不写星；</p><p>不等空值还有or，索引失效要少用。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="MySQL" scheme="https://www.sakuratears.top/tags/MySQL/"/>
    
      <category term="索引" scheme="https://www.sakuratears.top/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>如何使Java项目生成可执行的exe文件</title>
    <link href="https://www.sakuratears.top/blog/%E5%A6%82%E4%BD%95%E4%BD%BFJava%E9%A1%B9%E7%9B%AE%E7%94%9F%E6%88%90%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%9A%84exe%E6%96%87%E4%BB%B6.html"/>
    <id>https://www.sakuratears.top/blog/如何使Java项目生成可执行的exe文件.html</id>
    <published>2019-10-16T14:48:00.000Z</published>
    <updated>2019-10-16T15:42:22.501Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前些天，有个朋友问我可否使用Java制作一个exe程序，要求运行程序可以实现某些功能。</p><p>我出于好奇了解了一下，是可以使用Java制作一些客户端exe程序的。</p><p>过程感觉还是比较有意思的，特此记录下来。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>因为这类程序一般都为客户端程序，涉及到较古老的<code>JFrame</code>，我就简单的使用一个例子来说明下。</p><p>我们比如说想制作一个读取文件大小的exe文件。</p><h2 id="构建Java项目"><a href="#构建Java项目" class="headerlink" title="构建Java项目"></a>构建Java项目</h2><p>我们首先构建一个普通的Java Maven项目，如下图。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-529.jpg" alt="upload successful"></p><p>随便给项目起个名称。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-530.jpg" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-531.jpg" alt="upload successful"></p><p>这儿我们不需要任何maven依赖，如果项目较复杂可以引入需要的maven依赖等。</p><p>我们新建一个Frame实现文件读取大小功能。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-532.jpg" alt="upload successful"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileHelper</span> <span class="keyword">extends</span> <span class="title">JFrame</span> <span class="keyword">implements</span> <span class="title">ActionListener</span> </span>&#123;</span><br><span class="line">    JButton open=<span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> FileHelper();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileHelper</span><span class="params">()</span></span>&#123;</span><br><span class="line">        open=<span class="keyword">new</span> JButton(<span class="string">"请选择要处理的文件"</span>);</span><br><span class="line">        <span class="keyword">this</span>.add(open);</span><br><span class="line">        <span class="keyword">this</span>.setBounds(<span class="number">400</span>, <span class="number">200</span>, <span class="number">1000</span>, <span class="number">500</span>);</span><br><span class="line">        <span class="keyword">this</span>.setVisible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        open.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">        JFileChooser jfc=<span class="keyword">new</span> JFileChooser();</span><br><span class="line">        jfc.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES );</span><br><span class="line">        jfc.showDialog(<span class="keyword">new</span> JLabel(), <span class="string">"选择"</span>);</span><br><span class="line">        File file=jfc.getSelectedFile();</span><br><span class="line">        <span class="keyword">if</span>(file.isDirectory())&#123;</span><br><span class="line">            JOptionPane.showMessageDialog(<span class="keyword">null</span>, <span class="string">"请选择一个文件"</span>, <span class="string">"信息"</span>, JOptionPane.INFORMATION_MESSAGE);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(file.isFile())&#123;</span><br><span class="line">            <span class="keyword">if</span>(file.canRead())&#123;</span><br><span class="line">                <span class="keyword">long</span> bytes = file.length();</span><br><span class="line">                String size = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">if</span>(bytes &lt; <span class="number">1024</span>)&#123;</span><br><span class="line">                    size = bytes + <span class="string">"B"</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bytes &lt; <span class="number">1048576</span>)&#123;</span><br><span class="line">                    size = bytes/<span class="number">1024</span> + <span class="string">"KB"</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    size = bytes/<span class="number">1048576</span> + <span class="string">"MB"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                String message = <span class="string">"该文件大小为:"</span>+size + <span class="string">"\r\n文件路径:"</span>+file.getPath();</span><br><span class="line">                JOptionPane.showMessageDialog(<span class="keyword">null</span>, message, <span class="string">"信息"</span>, JOptionPane.INFORMATION_MESSAGE);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                JOptionPane.showMessageDialog(<span class="keyword">null</span>, <span class="string">"该文件不可读"</span>, <span class="string">"信息"</span>, JOptionPane.INFORMATION_MESSAGE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们运行一下，可以成功启动此项目。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-533.jpg" alt="upload successful"></p><p>那我们如何将它转换为exe呢？</p><h2 id="生成可执行jar文件"><a href="#生成可执行jar文件" class="headerlink" title="生成可执行jar文件"></a>生成可执行jar文件</h2><p>在生成exe之前，我们需要先生成可执行jar文件，再将jar文件转换成exe文件。</p><p>我们打开IDEA项目结构（File -&gt; Project Structure -&gt; Artifacts），如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-534.jpg" alt="upload successful"></p><p>使项目可以生成一个可执行的jar包。</p><p>这儿要注意选择好项目和启动Main入口后，MANIFSET.MF一定到生成到src文件夹下。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-535.jpg" alt="upload successful"></p><p>完成后会看到我们项目的一些信息，这儿我们配置生成的jar输出到项目目录out下，点击OK即可。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-536.jpg" alt="upload successful"></p><p>这时候在项目src目录下可以看到META-INF文件夹及文件夹里的MANIFSET.MF文件，没有就说明配置错了。</p><p>在IDEA里找到 Build -&gt; Build Artifacts，选择这个项目，点击Build。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-537.jpg" alt="upload successful"></p><p>完成后会看到我们生成的jar包。</p><p>我们copy出来并使用Java运行一下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar framework-exe-app.jar</span><br></pre></td></tr></table></figure><p>可以看到成功运行。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-538.jpg" alt="upload successful"></p><p>显然我们只得到了一个只能在有JRT环境上运行的jar包，下一步我们来把它转成exe文件。</p><h2 id="生成exe文件"><a href="#生成exe文件" class="headerlink" title="生成exe文件"></a>生成exe文件</h2><p>将jar文件转换为exe文件，需要下载exe4j工具，<a href="https://exe4j.apponic.com/" rel="external nofollow noopener noreferrer" target="_blank">exe4j</a>。</p><p>下载完成后安装，会打开welcome界面，这个界面是用来输注册码用的，如果不输入，是可以直接next进行下去的。但若是不输入，双击生成的exe时，会alert出一段话，如图。必须点“确定”才可以执行程序。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-539.jpg" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-540.jpg" alt="upload successful"></p><p>关于License Key，网上可以找到，这儿也提供了一些。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A-XVK258563F-1p4lv7mg7sav</span><br><span class="line">A-XVK209982F-1y0i3h4ywx2h1</span><br><span class="line">A-XVK267351F-dpurrhnyarva</span><br><span class="line">A-XVK204432F-1kkoilo1jy2h3r</span><br><span class="line">A-XVK246130F-1l7msieqiwqnq</span><br><span class="line">A-XVK249554F-pllh351kcke50</span><br><span class="line">A-XVK238729F-25yn13iea25i</span><br><span class="line">A-XVK222711F-134h5ta8yxbm0</span><br></pre></td></tr></table></figure><p>配置后，直接点击Next，选择”JAR” in “EXE” mode，如下图。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-541.jpg" alt="upload successful"></p><p>点击Next，我们输入应用名（这儿我起名MyApp），然后文件输出路径我们新建一个文件夹，然后输出到这个文件夹下。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-542.jpg" alt="upload successful"></p><p>点击Next，在这个页面我们需要配置名称，应用图标可配置可以不配置，如果应用不允许多开则需要勾选 Allow 那个选项。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-543.jpg" alt="upload successful"></p><p>这儿在Advance Options里，还有一些其它可选项，有兴趣的童鞋可以自己看一下。</p><p>如果不想生成错误日志，可以去掉如图选项。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-544.jpg" alt="upload successful"></p><p>这儿我们在这里面选中生成64-bit的应用程序。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-545.jpg" alt="upload successful"></p><p>在第5步Java invocation页面，VM Parameters输入<code>-Dappdir=${EXE4J_EXEDIR}</code>，然后我们将我们生成的jar包引入，如下图：</p><p>Class Path —&gt; + —&gt; Archive —&gt; 选择jar包 —&gt; OK</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-546.jpg" alt="upload successful"></p><p>然后配置我们的程序入口。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-547.jpg" alt="upload successful"></p><p>点击Next，到达第6步，需要设置jre版本，如下图：</p><p>需要设置最小的jre版本，然后在Advance Options里，选择Search Sequence，我们设置使用自己的JRE，这样生成的应用程序可以在没有安装Java的系统上使用。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-548.jpg" alt="upload successful"></p><p>在这之前，我们需要一份JRE（Java Runtime Environment）文件，可以在Java安装目录里找到，或者在官网上下载。比如 <a href="https://www.oracle.com/technetwork/java/javase/downloads/jre8-downloads-2133155.html" rel="external nofollow noopener noreferrer" target="_blank">jre-8u231</a>。</p><p>将它复制到我们之前创建的MyApp目录里，在Search Sequence里选择它。（之前Search Sequence的默认的3个直接删除即可）。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-549.jpg" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-550.jpg" alt="upload successful"></p><p>点击Next，到达第7步，这儿是设置App启动图，可以不设置。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-551.jpg" alt="upload successful"></p><p>第8步默认即可。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-552.jpg" alt="upload successful"></p><p>点击Next，到达最后一步，可以点击<code>Click Here to start Application</code>按钮测试一下应用程序。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-553.jpg" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-554.jpg" alt="upload successful"></p><p>成功说明没有问题，点击<code>Exit</code>按钮即可。</p><p>最后它会问你要不要保存配置信息，保存的话可以下次使用这个配置，这个按自己需要来即可。</p><p>退出后我们在我们的MyApp文件夹下可以找到刚才生成的App，可以运行一下是没有问题的。</p><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><p>我们虽然制作完成了该App，可是我们发现，我们把应用程序exe文件单独移动到一个地方，运行时，就会报找不到JRE环境。</p><p>这是比较容易理解的，我们使用Java编译的class文件，最终转换成了exe文件，但是仍不能离开JRE环境运行，也就是需要将整个MyApp文件夹进行移动，或者作为一个项目（App）。</p><p>这显然和在一台机器上安装JRE没有本质区别……</p><p>就是变成了我们使用了项目自带的JRE环境。</p><p>这也是没有办法的事，因为Java的平台无关性，就是基于它的JRE环境，脱离JRE环境也无法运行class文件，我们的exe其实只是一层包装而已。</p><h2 id="可安装版本的exe文件"><a href="#可安装版本的exe文件" class="headerlink" title="可安装版本的exe文件"></a>可安装版本的exe文件</h2><p>即使是一层包装，能不能使它在优化下呢？起码别人一看起来不立马觉得别扭？</p><p>其实我们可以继续对exe文件和jre部分继续进行包装，使它成为一个安装版本的可执行文件。</p><p>这儿我们需要使用到 Inno Setup，这儿我们可以下载它 <a href="http://www.jrsoftware.org/isdl.php" rel="external nofollow noopener noreferrer" target="_blank">Inno Setup Downloads</a></p><p>下载安装完成（过程略）后打开，如下图：</p><p>我们选择使用生成向导来一步步引导我们生成exe文件。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-555.jpg" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-556.jpg" alt="upload successful"></p><p>我们可以设置自己的App名字及一些基本信息。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-557.jpg" alt="upload successful"></p><p>项目的安装路径，和是否允许用户更改安装路径参数设置我们直接取默认就好。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-558.jpg" alt="upload successful"></p><p>找到我们刚生成的exe文件，然后添加必要文件（jre文件），注意需要将jre文件夹下的全部文件添加上。</p><p>PS: 这儿我们需要新建一个temp文件夹，将jre移动进来，然后选择temp，这样生成的MyApp.exe会和jre文件夹在同一级，不然MyApp.exe找不到JRE环境。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-559.jpg" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-560.jpg" alt="upload successful"></p><p>然后下一步，是配置应用图标创建显示的，如果允许用户不在桌面创建图标，可以如下配置：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-561.jpg" alt="upload successful"></p><p>下一步关于License File 我们直接跳过就行。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-562.jpg" alt="upload successful"></p><p>下一步是安装后使用者权限，我们默认安装后所有人都可以使用即可。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-563.jpg" alt="upload successful"></p><p>下一步设置安装语言，用默认English即可。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-564.jpg" alt="upload successful"></p><p>然后设置生成的文件路径，还有应用图标等。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-565.jpg" alt="upload successful"></p><p>然后下一步到完成。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-566.jpg" alt="upload successful"></p><p>编译时会问到是否保存编译脚本，依照自己选择即可。</p><p>编译效果图如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-567.jpg" alt="upload successful"></p><p>最后会生成可安装的exe文件，我们运行下，把它安装一下。</p><p>我们安装完成可以看一下它的目录，其实和我们刚才的一模一样，只不过现在变成了一整个安装exe，而且安装包体积也被压缩了。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-568.jpg" alt="upload successful"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章没什么特别要总结的，主要就是相关工具的使用。</p><p>可以看到我们一个小小的功能，但生成的exe是巨大的，但是随着项目文件变多，jre占用比例减小，就是逐渐可以接受的了。</p><p>现在Java已经很少在桌面客户端进行一些开发工作了，但了解一下Java-exe的生成过程也是比较有意思的。</p><p>今天的内容就到这里吧。</p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>源码详见于我的 <a href="https://github.com/JavaZWT/" rel="external nofollow noopener noreferrer" target="_blank">GitHub</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="exe" scheme="https://www.sakuratears.top/tags/exe/"/>
    
      <category term="exe4j" scheme="https://www.sakuratears.top/tags/exe4j/"/>
    
      <category term="Inno Setup" scheme="https://www.sakuratears.top/tags/Inno-Setup/"/>
    
  </entry>
  
  <entry>
    <title>Java sort和parallelSort接口及其实现</title>
    <link href="https://www.sakuratears.top/blog/Java-sort%E5%92%8CparallelSort%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0.html"/>
    <id>https://www.sakuratears.top/blog/Java-sort和parallelSort接口及其实现.html</id>
    <published>2019-10-14T14:12:00.000Z</published>
    <updated>2019-10-20T08:12:23.286Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上篇文章我们介绍了 <a href="https://www.sakuratears.top/blog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B9%9D%EF%BC%89-Java%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84DualPivotQuicksort.html#more">排序算法（九）-Java源码中的DualPivotQuicksort</a>，今天我们来看下sort接口的实现，看看JDK对数据排序这块到底做了哪些优化。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="sort接口"><a href="#sort接口" class="headerlink" title="sort接口"></a>sort接口</h2><p>sort接口有多个重载的方法，我们整理下后，它们分别如下：</p><p>在 <code>java.util.Arrays</code>类里，调用 <code>Array.sort(a)</code>方法，可以对数组a进行排序，它有18个重载方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//整个int数组排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    DualPivotQuicksort.sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对int数组from到to的位置进行排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">    DualPivotQuicksort.sort(a, fromIndex, toIndex - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//long数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">long</span>[] a)</span> </span>&#123;</span><br><span class="line">    DualPivotQuicksort.sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">long</span>[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">    DualPivotQuicksort.sort(a, fromIndex, toIndex - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//short数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">short</span>[] a)</span> </span>&#123;</span><br><span class="line">    DualPivotQuicksort.sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">short</span>[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">    DualPivotQuicksort.sort(a, fromIndex, toIndex - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//char数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">char</span>[] a)</span> </span>&#123;</span><br><span class="line">    DualPivotQuicksort.sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">    DualPivotQuicksort.sort(a, fromIndex, toIndex - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//byte数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">byte</span>[] a)</span> </span>&#123;</span><br><span class="line">    DualPivotQuicksort.sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">byte</span>[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">    DualPivotQuicksort.sort(a, fromIndex, toIndex - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//float数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">float</span>[] a)</span> </span>&#123;</span><br><span class="line">    DualPivotQuicksort.sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">float</span>[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">    DualPivotQuicksort.sort(a, fromIndex, toIndex - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//double数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">double</span>[] a)</span> </span>&#123;</span><br><span class="line">    DualPivotQuicksort.sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">double</span>[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">    DualPivotQuicksort.sort(a, fromIndex, toIndex - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Object数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (LegacyMergeSort.userRequested)</span><br><span class="line">        legacyMergeSort(a);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ComparableTimSort.sort(a, <span class="number">0</span>, a.length, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Object[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">    <span class="keyword">if</span> (LegacyMergeSort.userRequested)</span><br><span class="line">        legacyMergeSort(a, fromIndex, toIndex);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ComparableTimSort.sort(a, fromIndex, toIndex, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] a, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sort(a);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (LegacyMergeSort.userRequested)</span><br><span class="line">            legacyMergeSort(a, c);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            TimSort.sort(a, <span class="number">0</span>, a.length, c, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">                            Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sort(a, fromIndex, toIndex);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">        <span class="keyword">if</span> (LegacyMergeSort.userRequested)</span><br><span class="line">            legacyMergeSort(a, fromIndex, toIndex, c);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            TimSort.sort(a, fromIndex, toIndex, c, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p><strong>可以看到对于基本数据类型，因为排序稳定性不会对数据造成影响（两个一样的数据谁前谁后都可以），故使用了DualPivotQuicksort排序算法。</strong></p><p><strong>对于Object数组(没有继承Comparator接口的数据类型)，会先判断一个<code>LegacyMergeSort.userRequested</code>的值是否为真，如果为真就使用legacyMergeSort排序算法，否则就使用ComparableTimSort排序算法。</strong></p><p><strong>对于泛型数组T []，如果比较器<code>Comparator</code>为空，就按照Object []方式进行处理；如果有比较器的话，照样先判断<code>LegacyMergeSort.userRequested</code>的值是否为真，是的话就用legacyMergeSort排序算法，否则就使用TimSort排序算法。</strong></p><p><strong>其他地方的sort最终会调用<code>Array.sort(a)</code>方法。如<code>java.util.Collections</code>类里的<code>sort(List<t> list)</t></code>方法，最终调用了<code>Array.sort(T[] a)</code>。</strong></p><p>根据上面的分析，我们先来看看<code>LegacyMergeSort.userRequested</code>这个参数吧，因为它决定非基本数据类型数组到底是使用legacyMergeSort还是TimSort（ComparableTimSort是TimSort的Object []版本，也相当于TimSort）。</p><p>追踪源码，<code>LegacyMergeSort.userRequested</code>赋值过程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LegacyMergeSort</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> userRequested =</span><br><span class="line">            java.security.AccessController.doPrivileged(</span><br><span class="line">                <span class="keyword">new</span> sun.security.action.GetBooleanAction(</span><br><span class="line">                    <span class="string">"java.util.Arrays.useLegacyMergeSort"</span>)).booleanValue();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到它是可以通过系统设置进行配置的，<code>java -Djava.util.Arrays.useLegacyMergeSort=true</code>，可以设置使用老的归并排序。</p><p>这个值默认是false，即不使用归并排序，Java之所以有这部分判断，完全是为了兼容老版本，同时归并排序这部分将在未来移除（当前介绍版本为JDK1.8，在JDK11中发现已经移除）。</p><p>legacyMergeSort这个方法涉及到的就是归并排序，关于这部分，我们不再展示源码（Java未来版本也会移除），有兴趣的可以看看我之前的文章<a href="https://www.sakuratears.top/blog/Java%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%88Merge-Sort%EF%BC%89">归并排序(MergeSort)</a>部分。这两者唯一不同的是Java的legacyMergeSort在排序部分长度小于 INSERTIONSORT_THRESHOLD = 7 的时候，会使用插入排序，相当于提高了普通归并的效率。</p><p>TimSort或者ComparableTimSort我在之前文章中也有分析了，有兴趣的可以看看，这儿不过多介绍。<a href="https://www.sakuratears.top/blog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89-TimSort.html#more">排序算法（六）- TimSort</a>。</p><p>关于Java源码里的DualPivotQuicksort内容详见这篇文章<a href="https://www.sakuratears.top/blog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B9%9D%EF%BC%89-Java%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84DualPivotQuicksort.html#more">排序算法（九）-Java源码中的DualPivotQuicksort</a>。</p><h2 id="parallelSort接口"><a href="#parallelSort接口" class="headerlink" title="parallelSort接口"></a>parallelSort接口</h2><p>看完串行排序接口，我们再来看下Java自带排序的并行版本parallelSort接口，看看它是如何实现并行排序的。</p><p>先看看它的几个重载方法,由于基本数据类型数组的parallelSort都是类似的，这儿我只拿int[]进行举例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int数据并行排序方法（其它基本数据类型数组和其类似，这儿代码就不在展示）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parallelSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.length, p, g;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= MIN_ARRAY_SORT_GRAN ||</span><br><span class="line">        (p = ForkJoinPool.getCommonPoolParallelism()) == <span class="number">1</span>)</span><br><span class="line">        DualPivotQuicksort.sort(a, <span class="number">0</span>, n - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">new</span> ArraysParallelSortHelpers.FJInt.Sorter</span><br><span class="line">            (<span class="keyword">null</span>, a, <span class="keyword">new</span> <span class="keyword">int</span>[n], <span class="number">0</span>, n, <span class="number">0</span>,</span><br><span class="line">                ((g = n / (p &lt;&lt; <span class="number">2</span>)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span><br><span class="line">                MIN_ARRAY_SORT_GRAN : g).invoke();</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parallelSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">    <span class="keyword">int</span> n = toIndex - fromIndex, p, g;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= MIN_ARRAY_SORT_GRAN ||</span><br><span class="line">        (p = ForkJoinPool.getCommonPoolParallelism()) == <span class="number">1</span>)</span><br><span class="line">        DualPivotQuicksort.sort(a, fromIndex, toIndex - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">new</span> ArraysParallelSortHelpers.FJInt.Sorter</span><br><span class="line">            (<span class="keyword">null</span>, a, <span class="keyword">new</span> <span class="keyword">int</span>[n], fromIndex, n, <span class="number">0</span>,</span><br><span class="line">                ((g = n / (p &lt;&lt; <span class="number">2</span>)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span><br><span class="line">                MIN_ARRAY_SORT_GRAN : g).invoke();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型数组并行排序方法（无比较器）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">parallelSort</span><span class="params">(T[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.length, p, g;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= MIN_ARRAY_SORT_GRAN ||</span><br><span class="line">        (p = ForkJoinPool.getCommonPoolParallelism()) == <span class="number">1</span>)</span><br><span class="line">        TimSort.sort(a, <span class="number">0</span>, n, NaturalOrder.INSTANCE, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">new</span> ArraysParallelSortHelpers.FJObject.Sorter&lt;T&gt;</span><br><span class="line">            (<span class="keyword">null</span>, a,</span><br><span class="line">                (T[])Array.newInstance(a.getClass().getComponentType(), n),</span><br><span class="line">                <span class="number">0</span>, n, <span class="number">0</span>, ((g = n / (p &lt;&lt; <span class="number">2</span>)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span><br><span class="line">                MIN_ARRAY_SORT_GRAN : g, NaturalOrder.INSTANCE).invoke();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parallelSort</span><span class="params">(T[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">    <span class="keyword">int</span> n = toIndex - fromIndex, p, g;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= MIN_ARRAY_SORT_GRAN ||</span><br><span class="line">        (p = ForkJoinPool.getCommonPoolParallelism()) == <span class="number">1</span>)</span><br><span class="line">        TimSort.sort(a, fromIndex, toIndex, NaturalOrder.INSTANCE, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">new</span> ArraysParallelSortHelpers.FJObject.Sorter&lt;T&gt;</span><br><span class="line">            (<span class="keyword">null</span>, a,</span><br><span class="line">                (T[])Array.newInstance(a.getClass().getComponentType(), n),</span><br><span class="line">                fromIndex, n, <span class="number">0</span>, ((g = n / (p &lt;&lt; <span class="number">2</span>)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span><br><span class="line">                MIN_ARRAY_SORT_GRAN : g, NaturalOrder.INSTANCE).invoke();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型数组并行排序方法（有比较器）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">parallelSort</span><span class="params">(T[] a, Comparator&lt;? <span class="keyword">super</span> T&gt; cmp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cmp == <span class="keyword">null</span>)</span><br><span class="line">        cmp = NaturalOrder.INSTANCE;</span><br><span class="line">    <span class="keyword">int</span> n = a.length, p, g;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= MIN_ARRAY_SORT_GRAN ||</span><br><span class="line">        (p = ForkJoinPool.getCommonPoolParallelism()) == <span class="number">1</span>)</span><br><span class="line">        TimSort.sort(a, <span class="number">0</span>, n, cmp, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">new</span> ArraysParallelSortHelpers.FJObject.Sorter&lt;T&gt;</span><br><span class="line">            (<span class="keyword">null</span>, a,</span><br><span class="line">                (T[])Array.newInstance(a.getClass().getComponentType(), n),</span><br><span class="line">                <span class="number">0</span>, n, <span class="number">0</span>, ((g = n / (p &lt;&lt; <span class="number">2</span>)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span><br><span class="line">                MIN_ARRAY_SORT_GRAN : g, cmp).invoke();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">parallelSort</span><span class="params">(T[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Comparator&lt;? <span class="keyword">super</span> T&gt; cmp)</span> </span>&#123;</span><br><span class="line">    rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">    <span class="keyword">if</span> (cmp == <span class="keyword">null</span>)</span><br><span class="line">        cmp = NaturalOrder.INSTANCE;</span><br><span class="line">    <span class="keyword">int</span> n = toIndex - fromIndex, p, g;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= MIN_ARRAY_SORT_GRAN ||</span><br><span class="line">        (p = ForkJoinPool.getCommonPoolParallelism()) == <span class="number">1</span>)</span><br><span class="line">        TimSort.sort(a, fromIndex, toIndex, cmp, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">new</span> ArraysParallelSortHelpers.FJObject.Sorter&lt;T&gt;</span><br><span class="line">            (<span class="keyword">null</span>, a,</span><br><span class="line">                (T[])Array.newInstance(a.getClass().getComponentType(), n),</span><br><span class="line">                fromIndex, n, <span class="number">0</span>, ((g = n / (p &lt;&lt; <span class="number">2</span>)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span><br><span class="line">                MIN_ARRAY_SORT_GRAN : g, cmp).invoke();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><p>对于基本类型数组数据，并行排序会判断排序长度n（或者数组长度）是否小于 <code>MIN_ARRAY_SORT_GRAN = 1 &lt;&lt; 13 = 8192</code>，如果小于或者<code>p = ForkJoinPool.getCommonPoolParallelism()) == 1</code>的时候，就会使用DualPivotQuicksort排序算法；否则它创建了一个<code>ArraysParallelSortHelpers.FJInt.Sorter</code>类进行并行排序。</p><p>对于Object数组或者泛型数组T[]的排序，可以看到与基本数据类型相似，只是最后的排序算法使用的是稳定的TimSort，并行帮助类使用的是<code>ArraysParallelSortHelpers.FJObject.Sorter</code>，这个类底层串行排序也是基于TimSort。</p><p>我们来分析下并行排序源码：</p><p>对于长度小于8192很好理解，就是数据长度小的时候，使用串行排序就可以了，即DualPivotQuicksort，并没有使用并行排序。</p><p>而<code>ForkJoinPool.getCommonPoolParallelism()</code>是返回公共线程池的并行级别，即允许多少个线程并行，如果是1的话说明禁用了线程，那么就无法使用多线程，也就只能使用串行排序，关于这个值和ForkJoinPool相关，后面我们会看下这个类，来了解一下它的实现，这儿就不过多叙述。</p><p>我们重点来看下<code>ArraysParallelSortHelpers.FJInt.Sorter</code>这个类，这个是针对于int数组的并行工具类，当然我们还可以看到其它数据类型的并行工具类，如<code>ArraysParallelSortHelpers.FJByte.Sorter</code>，他们都在<code>ArraysParallelSortHelpers</code>这个类里。</p><p>这个类的并行实现是根据<a href="http://supertech.lcs.mit.edu/cilk/" rel="external nofollow noopener noreferrer" target="_blank">Cilk算法</a>来实现的。</p><blockquote><p>Cilk是一种多线程算法语言。Cilk背后的理念是，程序员应该集中精力构建程序，以暴露并行性和利用局部性，让Cilk的运行时系统负责调度计算，以便在给定平台上高效运行。因此，Cilk运行时系统负责诸如负载平衡、分页和通信协议等细节。然而，与其他多线程语言不同，Cilk是算法语言，因为运行时系统保证了高效和可预测的性能。</p></blockquote><p>算法内容大致如下：</p><ol><li>如果数组长度 n 过小（小于临界值 threshold ），就使用串行排序；</li><li><p>否则，将数组分为两半：</p><ul><li>将一半数组再分为两半（n/4），对于每一半，继续分割下去，直到数组长度小于临界值threshold，不再进行分割；</li><li>对前一半串行排序，对后一半串行排序，两半排序是并行进行的； </li><li>需要注意的是 n/2排序时需要保证两个n/4的并行排序合并完成，以此类推，n/4排序时需要保证两个n/8的并行排序合并完成……</li><li>将两部分合并</li></ul></li></ol><p>其伪代码大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parallelSort</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = high - low +<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; threshold)&#123;</span><br><span class="line">        sort(a);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> half = n &gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        ForkJoinTaskTest task1 = ForkJoinTaskTest(a,low,half-<span class="number">1</span>);</span><br><span class="line">        task1.fork();</span><br><span class="line">        ForkJoinTaskTest task2 = ForkJoinTaskTest(a,half,high-<span class="number">1</span>);</span><br><span class="line">        task2.compute();</span><br><span class="line">        task1.join();</span><br><span class="line">        merge(a,low,half,high-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个分割过程和我们之前说到过的 <a href="https://www.sakuratears.top/blog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89-%E5%8F%8C%E8%B0%83%E6%8E%92%E5%BA%8F.html">双调排序</a>的并行版本有些许类似。</p><p>我们先不看Java源码的相关实现，我们想，如果我们自己实现一个并行版本的排序如何实现呢？</p><p>我们需要使用到<code>ForkJoinPool</code>，我们可以参考我的另一篇文章<a href="https://www.sakuratears.top/blog/%E4%B8%80%E9%81%93Java%E8%AF%95%E9%A2%98%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83.html">一道Java试题引发的思考</a>。</p><p>这篇文章里使用了分支/合并框架（ForkJoinPool）来使用并行处理累加数据，我们参照这个模式，可以根据伪代码写出使用 Java DualPivotQuicksort的并行版本，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParallelSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100000000</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">100000000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] b = a.clone();</span><br><span class="line">        System.out.println(<span class="string">"ParallelSort排序开始："</span>);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        ForkJoinParallelSort task = <span class="keyword">new</span> ForkJoinParallelSort(a);</span><br><span class="line">        <span class="keyword">new</span> ForkJoinPool().invoke(task);</span><br><span class="line">        System.out.println(<span class="string">"ParallelSort耗时："</span> + (System.currentTimeMillis() - start) + <span class="string">"ms"</span>);</span><br><span class="line">        System.out.println(<span class="string">"ParallelSort排序完成！"</span>);</span><br><span class="line">        System.out.println(<span class="string">"数组是否有序："</span> + isOrdered(a));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"ArrayParallelSort排序开始："</span>);</span><br><span class="line">        <span class="keyword">long</span> start1 = System.currentTimeMillis();</span><br><span class="line">        Arrays.parallelSort(b);</span><br><span class="line">        System.out.println(<span class="string">"ArrayParallelSort耗时："</span> + (System.currentTimeMillis() - start1) + <span class="string">"ms"</span>);</span><br><span class="line">        System.out.println(<span class="string">"ArrayParallelSort排序完成！"</span>);</span><br><span class="line">        System.out.println(<span class="string">"数组是否有序："</span> + isOrdered(b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ForkJoinParallelSort</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要排序的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] array;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组起始下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组结束下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> end;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组最小长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">8192</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinParallelSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ForkJoinParallelSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Void <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = end - start + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> half = length &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//小于等于阈值，串行排序处理</span></span><br><span class="line">        <span class="keyword">if</span> (length &lt;= THRESHOLD) &#123;</span><br><span class="line">            computeSequentially(array, start, end);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建一个子任务来为数组的前一半排序</span></span><br><span class="line">        ForkJoinParallelSort leftTask = <span class="keyword">new</span> ForkJoinParallelSort(array, start, start + half - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//利用另一个ForkJoinPool线程异步执行新创建的子任务</span></span><br><span class="line">        leftTask.fork();</span><br><span class="line">        <span class="comment">//创建一个任务为数组的后一半排序</span></span><br><span class="line">        ForkJoinParallelSort rightTask = <span class="keyword">new</span> ForkJoinParallelSort(array, start + half, end);</span><br><span class="line">        <span class="comment">//同步执行第二个子任务，有可能允许进一步递归划分</span></span><br><span class="line">        rightTask.compute();</span><br><span class="line">        <span class="comment">//读取第一个子任务的结果，没有完成就等待</span></span><br><span class="line">        leftTask.join();</span><br><span class="line">        <span class="comment">//合并结果</span></span><br><span class="line">        <span class="comment">//long startTime = System.currentTimeMillis();</span></span><br><span class="line">        merge(array, start, start + half - <span class="number">1</span>, start + half, end);</span><br><span class="line">        <span class="comment">//System.out.println("耗时："+(System.currentTimeMillis()-startTime)+"ms");</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用JavaDualPivotQuickSort串行处理较小的数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">computeSequentially</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//直接调用Arrays.sort 也可以</span></span><br><span class="line">        JavaDualPivotQuicksort.sort(array, start, end, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 快速合并两个有序数组   O(min(m,n))</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> leftStart</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> leftEnd</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rightStart</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rightEnd</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> leftStart, <span class="keyword">int</span> leftEnd, <span class="keyword">int</span> rightStart, <span class="keyword">int</span> rightEnd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array[leftEnd] &lt;= array[rightStart]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = leftStart;</span><br><span class="line">        <span class="keyword">int</span> j = rightStart;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len1 = leftEnd - leftStart + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len2 = rightEnd - rightStart + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[len1 + len2];</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= leftEnd &amp;&amp; j &lt;= rightEnd) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &lt;= array[j]) &#123;</span><br><span class="line">                temp[k++] = array[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[k++] = array[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == leftEnd + <span class="number">1</span> &amp;&amp; j &lt;= rightEnd) &#123;</span><br><span class="line">            System.arraycopy(array, j, temp, k, rightEnd - j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == rightEnd + <span class="number">1</span> &amp;&amp; i &lt;= leftEnd) &#123;</span><br><span class="line">            System.arraycopy(array, i, temp, k, leftEnd - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理完后将temp赋值给array</span></span><br><span class="line">        System.arraycopy(temp, <span class="number">0</span>, array, leftStart, len1);</span><br><span class="line">        System.arraycopy(temp, len1, array, rightStart, len2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码是比较好理解的，其要注意的地方是在排完序的两个有序数组合并上。</p><p>运行一下可以看到对于1亿数据量该方法耗时稳定在6~7s，Java源码的ParallelSort方法耗时在3~4s左右。</p><p>它们结果如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-525.jpg" alt="upload successful"></p><p>可以看到Java源码的排序处理速度要比我们实现的更高效的，速度差异主要在哪儿呢？</p><p>其实Java并行源码中借鉴了Cilk算法，但是有些不同的地方是，会把原数组分成四份进行并行排序。</p><p>算法说明如下：</p><ol><li>将数组分成4个子数组。</li><li>对前面两个子数组进行排序然后合并。</li><li>对后面的两个进行排序然后合并。<br>上面着几个步骤会重复递归，每个子数组都要求容量小于上面计算出来的临界值。</li></ol><p>我们回到<code>ArraysParallelSortHelpers</code>这个类从它里面的FJInt这个类入手，其他的类的实现和其类似。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-526.jpg" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-527.jpg" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-528.jpg" alt="upload successful"></p><p>根据上图的一些介绍，我再简单说明下。</p><p>其实上面图中Java源码这段代码是相当晦涩的，我们如何看出它每次是拆分成4个子任务并处理的呢？</p><p>我们可以根据第一次调用来看，这时候代码中的<code>b = this.base = 0</code>，<code>wb = this.wbase = 0</code>，则三个Sorter如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Sorter(rc, a, w, b+u, n-u, wb+u, g).fork();</span><br><span class="line"><span class="keyword">new</span> Sorter(rc, a, w, b+h, q, wb+h, g).fork();;</span><br><span class="line"><span class="keyword">new</span> Sorter(bc, a, w, b+q, h-q, wb+q, g).fork();</span><br></pre></td></tr></table></figure><p>代入b =0 可以看到，它们分别处理了[ u , u + n - u ],[ h , h + q ],[ q , q + h -q ] 三部分，正好是[ 3/4 , 1 ],[ 1/2 , 3/4 ],[ 1/4 , 1/2 ] 三部分。</p><p>而对于剩下的1/4 ，直接在当前线程处理（不需要fork），代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DualPivotQuicksort.sort(a, b, b + n - <span class="number">1</span>, w, wb, n);<span class="comment">//注：此时 n = q （对于当前线程）,可以看源码的赋值过程</span></span><br></pre></td></tr></table></figure><p>分别排序完了，需要进行合并，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (n &gt; g) &#123;</span><br><span class="line">    <span class="keyword">int</span> h = n &gt;&gt;&gt; <span class="number">1</span>, q = h &gt;&gt;&gt; <span class="number">1</span>, u = h + q; <span class="comment">// quartiles</span></span><br><span class="line">    Relay fc = <span class="keyword">new</span> Relay(<span class="keyword">new</span> Merger(s, w, a, wb, h, wb+h, n-h, b, g));</span><br><span class="line">    Relay rc = <span class="keyword">new</span> Relay(<span class="keyword">new</span> Merger(fc, a, w, b+h, q,b+u, n-u, wb+h, g));</span><br><span class="line">    <span class="keyword">new</span> Sorter(rc, a, w, b+u, n-u, wb+u, g).fork();</span><br><span class="line">    <span class="keyword">new</span> Sorter(rc, a, w, b+h, q, wb+h, g).fork();;</span><br><span class="line">    Relay bc = <span class="keyword">new</span> Relay(<span class="keyword">new</span> Merger(fc, a, w, b, q,b+q, h-q, wb, g));</span><br><span class="line">    <span class="keyword">new</span> Sorter(bc, a, w, b+q, h-q, wb+q, g).fork();</span><br><span class="line">    s = <span class="keyword">new</span> EmptyCompleter(bc);</span><br><span class="line">    n = q;</span><br><span class="line">&#125;</span><br><span class="line">DualPivotQuicksort.sort(a, b, b + n - <span class="number">1</span>, w, wb, n);</span><br><span class="line">s.tryComplete();</span><br></pre></td></tr></table></figure><p>这段Relay的依存关系是 rc （合并后1/2部分）和 bc （合并前1/2部分） 是并行的，fc 会合并rc和bc （排序好的数据）。</p><p>Java中把并行分成四份的优势在哪里呢？</p><p>明显这段代码和使用我们Cilk算法每次分成两份的本质是一样的，而且分成4份代码变得更加晦涩。</p><p>具体原因就要说说这个Merger了，这个Merger是关于两个有序数组并行合并的实现，它的效率是非常高的，我们回到我们自己实现的那个<code>ParallelSort</code>类，可以看到我们设计的merge就是比较常规的合并，当两个数组数据量越大时，耗时越长，我在代码中注掉了耗时计算，有兴趣的童鞋可以打开观察下，在数据量较小情况下，其耗时基本是0~10ms，但是运行中随着两部分待合并的数据越来越大，耗时越来越大。</p><p>比如对于1亿数据的排序，其耗时主要消耗在2个5000w的数据合并成最终结果、4个2500w的数据两两合并成2个5000w数据、8个1250w的数据两两合并成4个2500w数据……的合并上。</p><p>Java中的这个Merger对合并进行了优化，使用了并行合并，其原理如下：</p><ol><li>对于两个待合并数组A，B；</li><li>找到较大（或等于）的一个数组（比如A），如果长度小于阈值8192，就不分割了；如果大于8192，找到较大数组A的中点作为切割点M，使用二分法找到较小数组B中比这个切割点大的最小位置索引P；</li><li>这时候其实我们可以发现A中[lowA , M]和B中[lowB , P]位置数据合并后是始终 小于等于 A中[M , highA]和B中[P , highB]位置数据合并的，这就是分割合并有序的原则；</li><li>如果长度比较大，还会继续并行分割下去；</li><li>然后我们对上面拆分的数据两两合并，最终多线程执行完也就得到了有序数据。</li></ol><p>有兴趣的童鞋可以参考原理结合上图看一下。</p><p>而我们在排序及合并时，会用到工作数组，分成4份后，可以保证最后的排序完成数组在原数组中，而不是在工作数组中，也避免了一次数据拷贝。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于Java自带排序的内容就介绍到这儿，可以看到相比于串行排序，并行排序更加复杂，但是Cilk并行算法的原理还是比较简单的，Java并排代码之所以复杂是因为它尽可能的优化了算法耗时。</p><p>这也是软件开发者应当具有的品质：精益求精。</p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>关于自写的ParallelSort排序可见于我的 <a href="https://github.com/javazwt" rel="external nofollow noopener noreferrer" target="_blank">GitHub</a>。</p><p>关于 ArraysParallelSortHelpers相关代码可以参考JDK源码（1.8及以上版本）。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>JDK ArraysParallelSortHelpers源码</li><li>JDK Arrays源码</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="排序算法" scheme="https://www.sakuratears.top/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
      <category term="并行排序" scheme="https://www.sakuratears.top/tags/%E5%B9%B6%E8%A1%8C%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令大全</title>
    <link href="https://www.sakuratears.top/blog/Linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8.html"/>
    <id>https://www.sakuratears.top/blog/Linux命令大全.html</id>
    <published>2019-10-11T14:11:00.000Z</published>
    <updated>2019-10-16T14:48:00.002Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Linux 命令大全，一些常用命令使用<font color="red"><strong>红色</strong></font>标记。</p><h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><h2 id="linux系统管理命令"><a href="#linux系统管理命令" class="headerlink" title="linux系统管理命令"></a>linux系统管理命令</h2><h3 id="adduser"><a href="#adduser" class="headerlink" title="adduser"></a><font color="red">adduser</font></h3><p>功能说明：新增用户帐号。</p><p>语　　法：<code>adduser</code></p><p>补充说明：在Slackware中，adduser指令是个script程序，利用交谈的方式取得输入的用户帐号资料，然后再交由真正建立帐号的useradd指令建立新用户，如此可方便管理员建立用户帐号。在Red Hat Linux中，adduser指令则是useradd指令的符号连接，两者实际上是同一个指令。</p><h3 id="chfn-change-finger-information"><a href="#chfn-change-finger-information" class="headerlink" title="chfn(change finger information)"></a>chfn(change finger information)</h3><p>功能说明：改变finger指令显示的信息。</p><p>语　　法：<code>chfn [-f &lt;真实姓名&gt;][-h &lt;家中电话&gt;][-o &lt;办公地址&gt;][-p &lt;办公电话&gt;][-uv][帐号名称]</code></p><p>补充说明：chfn指令可用来更改执行finger指令时所显示的信息，这些信息都存放在/etc目录里的asswd文件里。若不指定任何参数，则chfn指令会进入问答式界面。</p><p>参　　数：</p><ul><li>-f&lt;真实姓名&gt;或–full-name&lt;真实姓名&gt; 　   设置真实姓名。 </li><li>-h&lt;家中电话&gt;或–home-phone&lt;家中电话&gt; 　  设置家中的电话号码。 </li><li>-o&lt;办公地址&gt;或–office&lt;办公地址&gt; 　      设置办公室的地址。 </li><li>-p&lt;办公电话&gt;或–office-phone&lt;办公电话&gt; 　设置办公室的电话号码。 </li><li>-u或–help 　在线帮助。 </li><li>-v或-version 　显示版本信息。</li></ul><h3 id="chsh-change-shell"><a href="#chsh-change-shell" class="headerlink" title="chsh(change shell)"></a>chsh(change shell)</h3><p>功能说明：更换登入系统时使用的shell。</p><p>语　　法：<code>chsh [-luv][-s &lt;shell 名称&gt;][用户名称]</code></p><p>补充说明：每位用户在登入系统时，都会拥有预设的shell环境，这个指令可更改其预设值。若不指定任何参数与用户名称，则chsh会以应答的方式进行设置。</p><p>参　　数：</p><ul><li>-s&lt;shell 名称&gt;或–shell&lt;shell 名称&gt; 　更改系统预设的shell环境。 </li><li>-l或–list-shells 　列出目前系统可用的shell清单。 </li><li>-u或–help 　在线帮助。 </li><li>-v或-version 　显示版本信息。</li></ul><h3 id="date"><a href="#date" class="headerlink" title="date"></a><font color="red">date</font></h3><p>功能说明：显示或设置系统时间与日期。</p><p>语    法：<br><code>date [-d &lt;字符串&gt;][-u][+%H%I%K%l%M%P%r%s%S%T%X%Z%a%A%b%B%c%d%D%j%m%U%w%x%y%Y%n%t] 或date [-s &lt;字符串&gt;][-u][MMDDhhmmCCYYss] 或 date [–help][–version]</code></p><p>补充说明：第一种语法可用来显示系统日期或时间，以%为开头的参数为格式参数，可指定日期或时间的显示格式。第二种语法可用来设置系统日期与时间。只有管理员才有设置日期与时间的权限。若不加任何参数，data会显示目前的日期与时间。</p><p>参　　数：</p><ul><li>%H 　小时(以00-23来表示)。 </li><li>%I 　小时(以01-12来表示)。 </li><li>%K 　小时(以0-23来表示)。 </li><li>%l 　小时(以0-12来表示)。 </li><li>%M 　分钟(以00-59来表示)。 </li><li>%P 　AM或PM。 </li><li>%r 　时间(含时分秒，小时以12小时AM/PM来表示)。 </li><li>%s 　总秒数。起算时间为1970-01-01 00:00:00 UTC。 </li><li>%S 　秒(以本地的惯用法来表示)。 </li><li>%T 　时间(含时分秒，小时以24小时制来表示)。 </li><li>%X 　时间(以本地的惯用法来表示)。 </li><li>%Z 　市区。 </li><li>%a 　星期的缩写。 </li><li>%A 　星期的完整名称。 </li><li>%b 　月份英文名的缩写。 </li><li>%B 　月份的完整英文名称。 </li><li>%c 　日期与时间。只输入date指令也会显示同样的结果。 </li><li>%d 　日期(以01-31来表示)。 </li><li>%D 　日期(含年月日)。 </li><li>%j 　该年中的第几天。 </li><li>%m 　月份(以01-12来表示)。 </li><li>%U 　该年中的周数。 </li><li>%w 　该周的天数，0代表周日，1代表周一，异词类推。 </li><li>%x 　日期(以本地的惯用法来表示)。 </li><li>%y 　年份(以00-99来表示)。 </li><li>%Y 　年份(以四位数来表示)。 </li><li>%n 　在显示时，插入新的一行。 </li><li>%t 　在显示时，插入tab。 </li><li>MM 　月份(必要)。 </li><li>DD 　日期(必要)。 </li><li>hh 　小时(必要)。 </li><li>mm 　分钟(必要)。 </li><li>CC 　年份的前两位数(选择性)。 </li><li>YY 　年份的后两位数(选择性)。 </li><li>ss 　秒(选择性)。 </li><li>-d&lt;字符串&gt; 　显示字符串所指的日期与时间。字符串前后必须加上双引号。 </li><li>-s&lt;字符串&gt; 　根据字符串来设置日期与时间。字符串前后必须加上双引号。 </li><li>-u 　显示GMT。 </li><li>–help 　在线帮助。 </li><li>–version 　显示版本信息。</li></ul><h3 id="exit"><a href="#exit" class="headerlink" title="exit"></a><font color="red">exit</font></h3><p>功能说明：退出目前的shell。</p><p>语　　法：<code>exit [状态值]</code></p><p>补充说明：执行exit可使shell以指定的状态值退出。若不设置状态值参数，则shell以预设值退出。状态值0代表执行成功，其他值代表执行失败。exit也可用在script，离开正在执行的script，回到shell。</p><h3 id="finger"><a href="#finger" class="headerlink" title="finger"></a>finger</h3><p>功能说明：查找并显示用户信息。</p><p>语　　法：<code>finger [-lmsp][帐号名称…]</code></p><p>补充说明：finger指令会去查找，并显示指定帐号的用户相关信息，包括本地与远端主机的用户皆可，帐号名称没有大小写的差别。单独执行finger指令，它会显示本地主机现在所有的用户的登陆信息，包括帐号名称，真实姓名，登入终端机，闲置时间，登入时间以及地址和电话。</p><p>参　　数：</p><ul><li>-l 　列出该用户的帐号名称，真实姓名，用户专属目录，登入所用的Shell，登入时间，转信地址，电子邮件状态，还有计划文件和方案文件内容。 </li><li>-m 　排除查找用户的真实姓名。</li><li>-s 　列出该用户的帐号名称，真实姓名，登入终端机，闲置时间，登入时间以及地址和电话。 </li><li>-p 　列出该用户的帐号名称，真实姓名，用户专属目录，登入所用的Shell，登入时间，转信地址，电子邮件状态，但不显示该用户的计划文件和方案文件内容。</li></ul><h3 id="free"><a href="#free" class="headerlink" title="free"></a><font color="red">free</font></h3><p>功能说明：显示内存状态。</p><p>语　　法： <code>free [-bkmotV][-s &lt;间隔秒数&gt;]</code></p><p>补充说明：free指令会显示内存的使用情况，包括实体内存，虚拟的交换文件内存，共享内存区段，以及系统核心使用的缓冲区等。</p><p>参　　数：</p><ul><li>-b 　以Byte为单位显示内存使用情况。 </li><li>-k 　以KB为单位显示内存使用情况。 </li><li>-m 　以MB为单位显示内存使用情况。 </li><li>-o 　不显示缓冲区调节列。 </li><li>-s&lt;间隔秒数&gt; 　持续观察内存使用状况。 </li><li>-t 　显示内存总和列。 </li><li>-V 　显示版本信息。</li></ul><h3 id="fwhois"><a href="#fwhois" class="headerlink" title="fwhois"></a>fwhois</h3><p>功能说明：查找并显示用户信息。</p><p>语　　法：<code>fwhios [帐号名称]</code></p><p>补充说明：本指令的功能有点类似finger指令，它会去查找并显示指定帐号的用户相关信息。不同之处在于fwhois指令是到Network Solutions的WHOIS数据库去查找，该帐号名称必须有在上面注册才能寻获，且名称没有大小写的差别</p><h3 id="gitps-gnu-interactive-tools-process-status"><a href="#gitps-gnu-interactive-tools-process-status" class="headerlink" title="gitps(gnu interactive tools process status)"></a>gitps(gnu interactive tools process status)</h3><p>功能说明：报告程序状况。</p><p>语　　法：<code>gitps [acefgjlnrsSTuvwxX][p &lt;程序识别码&gt;][t &lt;终端机编号&gt;][U &lt;帐号名称&gt;]</code></p><p>补充说明：gitps是用来报告并管理程序执行的指令，基本上它就是通过ps指令来报告，管理程序，也能通过gitps指令随时中断，删除不必要的程序。因为gitps指令会去执行ps指令，所以其参数和ps指令相当类似。</p><p>参　　数：</p><ul><li>a 　显示　现行终端机下的所有程序，包括其他用户的程序。 </li><li>c 　列出程序时，显示每个程序真正的指令名称，而不包含路径，参数或是常驻服务的标示． </li><li>e 　列出程序时，显示每个程序所使用的环境变量。 </li><li>f 　用ASCII字符显示树状结构，表达程序间的相互关系。 </li><li>g 　显示现行终端机下的所有程序，包括群组领导者的程序。 </li><li>j 　采用工作控制的格式来显示程序状况。 </li><li>l 　采用纤细的格式来显示程序状况。 </li><li>n 　以数字来表示USER和WCHAN栏位。 </li><li>p&lt;程序识别码&gt; 　指定程序识别码，并列出该程序的状况。 </li><li>r 　只列出现行终端机正在执行中的程序。 </li><li>s 　采用程序信号的格式显示程序状况。 </li><li>S 　列出程序时，包括已中断的子程序信息。 </li><li>t&lt;终端机机标号&gt; 　指定终端机编号，并列出属于该终端机的程序的状况。 </li><li>T 　显示现行终端机下的所有程序。 </li><li>u 　以用户为主的格式来显示程序状况。 </li><li>U&lt;帐号名称&gt; 　列出属于该用户的程序的状况。 </li><li>v 　采用虚拟内存的格式显示程序状况。 </li><li>w 　采用宽阔的格式来显示程序状况。 </li><li>x 　显示所有程序，不以终端机来区分。 </li><li>X 　采用旧试的Linux i386登陆格式显示程序状况。</li></ul><h3 id="groupdel-group-delete"><a href="#groupdel-group-delete" class="headerlink" title="groupdel(group delete)"></a><font color="red">groupdel(group delete)</font></h3><p>功能说明：删除群组。</p><p>语　　法：<code>groupdel [群组名称]</code></p><p>补充说明：需要从系统上删除群组时，可用groupdel指令来完成这项工作。倘若该群组中仍包括某些用户，则必须先删除这些用户后，方能删除群组。</p><h3 id="groupmod-group-modify"><a href="#groupmod-group-modify" class="headerlink" title="groupmod(group modify)"></a><font color="red">groupmod(group modify)</font></h3><p>功能说明：更改群组识别码或名称。</p><p>语　　法：<code>groupmod [-g &lt;群组识别码&gt; &lt;-o&gt;][-n &lt;新群组名称&gt;][群组名称]</code></p><p>补充说明：需要更改群组的识别码或名称时，可用groupmod指令来完成这项工作。</p><p>参　　数：</p><ul><li>-g &lt;群组识别码&gt; 　设置欲使用的群组识别码。 </li><li>-o 　重复使用群组识别码。 </li><li>-n &lt;新群组名称&gt; 　设置欲使用的群组名称。</li></ul><h3 id="halt"><a href="#halt" class="headerlink" title="halt"></a>halt</h3><p>功能说明：关闭系统。</p><p>语　　法：<code>halt [-dfinpw]</code></p><p>补充说明：halt会先检测系统的runlevel。若runlevel为0或6，则关闭系统，否则即调用shutdown来关闭系统。</p><p>参　　数：</p><ul><li>-d 　不要在wtmp中记录。 </li><li>-f 　不论目前的runlevel为何，不调用shutdown即强制关闭系统。 </li><li>-i 　在halt之前，关闭全部的网络界面。 </li><li>-n 　halt前，不用先执行sync。 </li><li>-p 　halt之后，执行poweroff。 </li><li>-w 　仅在wtmp中记录，而不实际结束系统。</li></ul><h3 id="id"><a href="#id" class="headerlink" title="id"></a><font color="red">id</font></h3><p>功能说明：显示用户的ID，以及所属群组的ID。</p><p>语　　法：<code>id [-gGnru][–help][–version][用户名称]</code></p><p>补充说明：id会显示用户以及所属群组的实际与有效ID。若两个ID相同，则仅显示实际ID。若仅指定用户名称，则显示目前用户的ID。</p><p>参　　数：　</p><ul><li>-g或–group 　显示用户所属群组的ID。 </li><li>-G或–groups 　显示用户所属附加群组的ID。 </li><li>-n或–name 　显示用户，所属群组或附加群组的名称。 </li><li>-r或–real 　显示实际ID。 </li><li>-u或–user 　显示用户ID。 </li><li>-help 　显示帮助。 </li><li>-version 　显示版本信息。</li></ul><h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a><font color="red">kill</font></h3><p>功能说明：删除执行中的程序或工作。</p><p>语　　法：<code>kill [-s &lt;信息名称或编号&gt;][程序]　或　kill [-l &lt;信息编号&gt;]</code></p><p>补充说明：kill可将指定的信息送至程序。预设的信息为SIGTERM(15)，可将指定程序终止。若仍无法终止该程序，可使用SIGKILL(9)信息尝试强制删除程序。程序或工作的编号可利用ps指令或jobs指令查看。 </p><p>参　　数：</p><ul><li>-l &lt;信息编号&gt; 　若不加&lt;信息编号&gt;选项，则-l参数会列出全部的信息名称。 </li><li>-s &lt;信息名称或编号&gt; 　指定要送出的信息。 </li></ul><p>PS: [程序] :　[程序]可以是程序的PID或是PGID，也可以是工作编号。</p><h3 id="last"><a href="#last" class="headerlink" title="last"></a><font color="red">last</font></h3><p>功能说明：列出目前与过去登入系统的用户相关信息。</p><p>语　　法：<code>last [-adRx][-f &lt;记录文件&gt;][-n &lt;显示列数&gt;][帐号名称…][终端机编号…]</code></p><p>补充说明：单独执行last指令，它会读取位于/var/log目录下，名称为wtmp的文件，并把该给文件的内容记录的登入系统的用户名单全部显示出来。</p><p>参　　数：</p><ul><li>-a 　把从何处登入系统的主机名称或IP地址，显示在最后一行。 </li><li>-d 　将IP地址转换成主机名称。 </li><li>-f &lt;记录文件&gt; 　指定记录文件。 </li><li>-n &lt;显示列数&gt;或-&lt;显示列数&gt; 　设置列出名单的显示列数。 </li><li>-R 　不显示登入系统的主机名称或IP地址。 </li><li>-x 　显示系统关机，重新开机，以及执行等级的改变等信息。</li></ul><h3 id="lastb"><a href="#lastb" class="headerlink" title="lastb"></a>lastb</h3><p>功能说明：列出登入系统失败的用户相关信息。</p><p>语　　法：<code>lastb [-adRx][-f &lt;记录文件&gt;][-n &lt;显示列数&gt;][帐号名称…][终端机编号…]</code></p><p>补充说明：单独执行lastb指令，它会读取位于/var/log目录下，名称为btmp的文件，并把该文件内容记录的登入失败的用户名单，全部显示出来。</p><p>参　　数：</p><ul><li>-a 　把从何处登入系统的主机名称或IP地址显示在最后一行。 </li><li>-d 　将IP地址转换成主机名称。 </li><li>-f&lt;记录文件&gt; 　指定记录文件。 </li><li>-n&lt;显示列数&gt;或-&lt;显示列数&gt; 　设置列出名单的显示列数。 </li><li>-R 　不显示登入系统的主机名称或IP地址。 </li><li>-x 　显示系统关机，重新开机，以及执行等级的改变等信息。</li></ul><h3 id="login"><a href="#login" class="headerlink" title="login"></a><font color="red">login</font></h3><p>功能说明：登入系统。</p><p>语　　法：<code>login</code></p><p>补充说明：login指令让用户登入系统，您亦可通过它的功能随时更换登入身份。在Slackware发行版中 ，您可在指令后面附加欲登入的用户名称，它会直接询问密码，等待用户输入。当/etc目录里含名称为nologin的文件时，系统只root帐号登入系统，其他用户一律不准登入。</p><h3 id="logname"><a href="#logname" class="headerlink" title="logname"></a>logname</h3><p>功能说明：显示用户名称。</p><p>语　　法：<code>logname [–help][–version]</code></p><p>补充说明：执行logname指令，它会显示目前用户的名称。</p><p>参　　数：</p><ul><li>–help 　在线帮助。 </li><li>–vesion 　显示版本信息。</li></ul><h3 id="logout"><a href="#logout" class="headerlink" title="logout"></a><font color="red">logout</font></h3><p>功能说明：退出系统。</p><p>语　　法：<code>logout</code></p><p>补充说明：logout指令让用户退出系统，其功能和login指令相互对应。</p><h3 id="logrotate"><a href="#logrotate" class="headerlink" title="logrotate"></a>logrotate</h3><p>功能说明：管理记录文件。</p><p>语　　法：<code>logrotate [-?dfv][-s &lt;状态文件&gt;][–usage][配置文件]</code></p><p>补充说明：使用logrotate指令，可让你轻松管理系统所产生的记录文件。它提供自动替换，压缩，删除和邮寄记录文件，每个记录文件都可被设置成每日，每周或每月处理，也能在文件太大时立即处理。您必须自行编辑，指定配置文件，预设的配置文件存放在/etc目录下，文件名称为logrotate.conf。</p><p>参　　数：</p><ul><li>-?或–help 　在线帮助。 </li><li>-d或–debug 　详细显示指令执行过程，便于排错或了解程序执行的情况。 </li><li>-f或–force 　强行启动记录文件维护操作，纵使logrotate指令认为没有需要亦然。 </li><li>-s&lt;状态文件&gt;或–state=&lt;状态文件&gt; 　使用指定的状态文件。 </li><li>-v或–version 　显示指令执行过程。 </li><li>-usage 　显示指令基本用法。</li></ul><h3 id="newgrp"><a href="#newgrp" class="headerlink" title="newgrp"></a>newgrp</h3><p>功能说明：登入另一个群组。</p><p>语　　法：<code>newgrp [群组名称]</code></p><p>补充说明：newgrp指令类似login指令，当它是以相同的帐号，另一个群组名称，再次登入系统。欲使用newgrp指令切换群组，您必须是该群组的用户，否则将无法登入指定的群组。单一用户要同时隶属多个群组，需利用交替用户的设置。若不指定群组名称，则newgrp指令会登入该用户名称的预设群组。</p><h3 id="nice"><a href="#nice" class="headerlink" title="nice"></a><font color="red">nice</font></h3><p>功能说明：设置优先权。</p><p>语　　法：<code>nice [-n &lt;优先等级&gt;][–help][–version][执行指令]</code></p><p>补充说明：nice指令可以改变程序执行的优先权等级。</p><p>参　　数：</p><ul><li>-n&lt;优先等级&gt;或-&lt;优先等级&gt;或–adjustment=&lt;优先等级&gt; 　设置欲执行的指令的优先权等级。等级的范围从-20－19，其中-20最高，19最低，只有系统管理者可以设置负数的等级。 </li><li>–help 　在线帮助。 </li><li>–version 　显示版本信息。</li></ul><h3 id="procinfo-process-information"><a href="#procinfo-process-information" class="headerlink" title="procinfo(process information)"></a>procinfo(process information)</h3><p>功能说明：显示当前进程信息。</p><p>语　　法：<code>procinfo [-abdDfhimsSv][-F &lt;输出文件&gt;][-n &lt;间隔秒数&gt;]</code></p><p>补充说明：procinfo指令从/proc目录里读取相关数据，将数据妥善整理过后输出到标准输出设备。</p><p>参　　数：</p><ul><li>-a 　显示所有信息。 </li><li>-b 　显示磁盘设备的区块数目，而非存取数目。 </li><li>-d 　显示系统信息每秒间的变化差额，而非总和的数值。本参数必须配合”-f”参数使用 </li><li>-D 　此参数效果和指定”-d”参数类似，但内存和交换文件的信息为总和数值。 </li><li>-f 　进入全画面的互动式操作界面。 </li><li>-F&lt;输出文件&gt; 　把信息状态输出到文件保存起来，而非预设的标准输出设备。 </li><li>-h 　在线帮助。 </li><li>-i 　显示完整的IRP列表。 </li><li>-m 　显示系统模块和外围设备等相关信息。 </li><li>-n间隔秒数&gt; 　设置全画面互动模式的信息更新速度，单位以秒计算。 </li><li>-s 　显示系统的内存，磁盘空间，IRP和DMA等信息，此为预设值。 </li><li>-S 　搭配参数”-d”或”-D”使用时，每秒都会更新信息，不论是否有使用参数”-n”。 </li><li>-v 　显示版本信息。</li></ul><h3 id="ps-process-status"><a href="#ps-process-status" class="headerlink" title="ps(process status)"></a><font color="red">ps(process status)</font></h3><p>功能说明：报告程序状况。</p><p>语　　法：<code>ps [-aAcdefHjlmNVwy][acefghLnrsSTuvxX][-C &lt;指令名称&gt;][-g &lt;群组名称&gt;][-G &lt;群组识别码&gt;][-p &lt;程序识别码&gt;][p &lt;程序识别码&gt;][-s &lt;阶段作业&gt;][-t &lt;终端机编号&gt;][t &lt;终端机编号&gt;][-u &lt;用户识别码&gt;][-U &lt;用户识别码&gt;][U &lt;用户名称&gt;][-&lt;程序识别码&gt;][–cols &lt;每列字符数&gt;][–columns &lt;每列字符数&gt;][–cumulative][–deselect][–forest][–headers][–help][–info][–lines &lt;显示列数&gt;][–no-headers][–group &lt;群组名称&gt;][-Group &lt;群组识别码&gt;][–pid &lt;程序识别码&gt;][–rows &lt;显示列数&gt;][–sid &lt;阶段作业&gt;][–tty &lt;终端机编号&gt;][–user &lt;用户名称&gt;][–User &lt;用户识别码&gt;][–version][–width &lt;每列字符数&gt;]</code></p><p>补充说明：ps是用来报告程序执行状况的指令，您可以搭配kill指令随时中断，删除不必要的程序。</p><p>参　　数：</p><ul><li>-a 　显示所有终端机下执行的程序，除了阶段作业领导者之外。 </li><li>a 　显示现行终端机下的所有程序，包括其他用户的程序。 </li><li>-A 　显示所有程序。 </li><li>-c 　显示CLS和PRI栏位。 </li><li>c 　列出程序时，显示每个程序真正的指令名称，而不包含路径，参数或常驻服务的标示。 </li><li>-C&lt;指令名称&gt; 　指定执行指令的名称，并列出该指令的程序的状况。 </li><li>-d 　显示所有程序，但不包括阶段作业领导者的程序。 </li><li>-e 　此参数的效果和指定”A”参数相同。 </li><li>e 　列出程序时，显示每个程序所使用的环境变量。 </li><li>-f 　显示UID,PPIP,C与STIME栏位。 </li><li>f 　用ASCII字符显示树状结构，表达程序间的相互关系。 </li><li>-g&lt;群组名称&gt; 　此参数的效果和指定”-G”参数相同，当亦能使用阶段作业领导者的名称来指定。 </li><li>g 　显示现行终端机下的所有程序，包括群组领导者的程序。 </li><li>-G&lt;群组识别码&gt; 　列出属于该群组的程序的状况，也可使用群组名称来指定。 </li><li>h 　不显示标题列。 </li><li>-H 　显示树状结构，表示程序间的相互关系。 </li><li>-j或j 　采用工作控制的格式显示程序状况。 </li><li>-l或l 　采用详细的格式来显示程序状况。 </li><li>L 　列出栏位的相关信息。 </li><li>-m或m 　显示所有的执行绪。 </li><li>n 　以数字来表示USER和WCHAN栏位。 </li><li>-N 　显示所有的程序，除了执行ps指令终端机下的程序之外。 </li><li>-p&lt;程序识别码&gt; 　指定程序识别码，并列出该程序的状况。 </li><li>p&lt;程序识别码&gt; 　此参数的效果和指定”-p”参数相同，只在列表格式方面稍有差异。 </li><li>r 　只列出现行终端机正在执行中的程序。 </li><li>-s&lt;阶段作业&gt; 　指定阶段作业的程序识别码，并列出隶属该阶段作业的程序的状况。 </li><li>s 　采用程序信号的格式显示程序状况。 </li><li>S 　列出程序时，包括已中断的子程序资料。 </li><li>-t&lt;终端机编号&gt; 　指定终端机编号，并列出属于该终端机的程序的状况。 </li><li>t&lt;终端机编号&gt; 　此参数的效果和指定”-t”参数相同，只在列表格式方面稍有差异。 </li><li>-T 　显示现行终端机下的所有程序。 </li><li>-u&lt;用户识别码&gt; 　此参数的效果和指定”-U”参数相同。 </li><li>u 　以用户为主的格式来显示程序状况。 </li><li>-U&lt;用户识别码&gt; 　列出属于该用户的程序的状况，也可使用用户名称来指定。 </li><li>U&lt;用户名称&gt; 　列出属于该用户的程序的状况。 </li><li>v 　采用虚拟内存的格式显示程序状况。 </li><li>-V或V 　显示版本信息。 </li><li>-w或w 　采用宽阔的格式来显示程序状况。　 </li><li>x 　显示所有程序，不以终端机来区分。 </li><li>X 　采用旧式的Linux i386登陆格式显示程序状况。 </li><li>-y 　配合参数”-l”使用时，不显示F(flag)栏位，并以RSS栏位取代ADDR栏位　。 </li><li>-&lt;程序识别码&gt; 　此参数的效果和指定”p”参数相同。 </li><li>–cols&lt;每列字符数&gt; 　设置每列的最大字符数。 </li><li>–columns&lt;每列字符数&gt; 　此参数的效果和指定”–cols”参数相同。 </li><li>–cumulative 　此参数的效果和指定”S”参数相同。 </li><li>–deselect 　此参数的效果和指定”-N”参数相同。 </li><li>–forest 　此参数的效果和指定”f”参数相同。 </li><li>–headers 　重复显示标题列。 </li><li>–help 　在线帮助。 </li><li>–info 　显示排错信息。 </li><li>–lines&lt;显示列数&gt; 　设置显示画面的列数。 </li><li>–no-headers 　此参数的效果和指定”h”参数相同，只在列表格式方面稍有差异。 </li><li>–group&lt;群组名称&gt; 　此参数的效果和指定”-G”参数相同。 </li><li>–Group&lt;群组识别码&gt; 　此参数的效果和指定”-G”参数相同。 </li><li>–pid&lt;程序识别码&gt; 　此参数的效果和指定”-p”参数相同。 </li><li>–rows&lt;显示列数&gt; 　此参数的效果和指定”–lines”参数相同。 </li><li>–sid&lt;阶段作业&gt; 　此参数的效果和指定”-s”参数相同。 </li><li>–tty&lt;终端机编号&gt; 　此参数的效果和指定”-t”参数相同。 </li><li>–user&lt;用户名称&gt; 　此参数的效果和指定”-U”参数相同。 </li><li>–User&lt;用户识别码&gt; 　此参数的效果和指定”-U”参数相同。 </li><li>–version 　此参数的效果和指定”-V”参数相同。 </li><li>–widty&lt;每列字符数&gt; 　此参数的效果和指定”-cols”参数相同。</li></ul><h3 id="pstree-process-status-tree"><a href="#pstree-process-status-tree" class="headerlink" title="pstree(process status tree)"></a>pstree(process status tree)</h3><p>功能说明：以树状图显示程序。</p><p>语　　法：<code>pstree [-acGhlnpuUV][-H &lt;程序识别码&gt;][&lt;程序识别码&gt;/&lt;用户名称&gt;]</code></p><p>补充说明：pstree指令用ASCII字符显示树状结构，清楚地表达程序间的相互关系。如果不指定程序识别码或用户名称，则会把系统启动时的第一个程序视为基层，并显示之后的所有程序。若指定用户名称，便会以隶属该用户的第一个程序当作基层，然后显示该用户的所有程序。</p><p>参　　数：</p><ul><li>-a 　显示每个程序的完整指令，包含路径，参数或是常驻服务的标示。 </li><li>-c 　不使用精简标示法。 </li><li>-G 　使用VT100终端机的列绘图字符。 </li><li>-h 　列出树状图时，特别标明现在执行的程序。 </li><li>-H&lt;程序识别码&gt; 　此参数的效果和指定”-h”参数类似，但特别标明指定的程序。 </li><li>-l 　采用长列格式显示树状图。 </li><li>-n 　用程序识别码排序。预设是以程序名称来排序。 </li><li>-p 　显示程序识别码。 </li><li>-u 　显示用户名称。 </li><li>-U 　使用UTF-8列绘图字符。 </li><li>-V 　显示版本信息。</li></ul><h3 id="reboot"><a href="#reboot" class="headerlink" title="reboot"></a>reboot</h3><p>功能说明：重新开机。</p><p>语　　法：<code>dreboot [-dfinw]</code></p><p>补充说明：执行reboot指令可让系统停止运作，并重新开机。</p><p>参　　数：</p><ul><li>-d 　重新开机时不把数据写入记录文件/var/tmp/wtmp。本参数具有”-n”参数的效果。 </li><li>-f 　强制重新开机，不调用shutdown指令的功能。 </li><li>-i 　在重开机之前，先关闭所有网络界面。 </li><li>-n 　重开机之前不检查是否有未结束的程序。 </li><li>-w 　仅做测试，并不真的将系统重新开机，只会把重开机的数据写入/var/log目录下的wtmp记录文件。</li></ul><h3 id="renice"><a href="#renice" class="headerlink" title="renice"></a><font color="red">renice</font></h3><p>功能说明：调整优先权。</p><p>语　　法：<code>renice [优先等级][-g &lt;程序群组名称&gt;…][-p &lt;程序识别码&gt;…][-u &lt;用户名称&gt;…]</code></p><p>补充说明：renice指令可重新调整程序执行的优先权等级。预设是以程序识别码指定程序调整其优先权，您亦可以指定程序群组或用户名称调整优先权等级，并修改所有隶属于该程序群组或用户的程序的优先权。等级范围从-20–19，只有系统管理者可以改变其他用户程序的优先权，也仅有系统管理者可以设置负数等级。</p><p>参　　数：</p><ul><li>-g &lt;程序群组名称&gt; 　使用程序群组名称，修改所有隶属于该程序群组的程序的优先权。 </li><li>-p &lt;程序识别码&gt; 　改变该程序的优先权等级，此参数为预设值。 </li><li>-u &lt;用户名称&gt; 　指定用户名称，修改所有隶属于该用户的程序的优先权。</li></ul><h3 id="rlogin-remote-login"><a href="#rlogin-remote-login" class="headerlink" title="rlogin(remote login)"></a>rlogin(remote login)</h3><p>功能说明：远端登入。</p><p>语　　法：<code>rlogin [-8EL][-e &lt;脱离字符&gt;][-l &lt;用户名称&gt;][主机名称或IP地址]</code></p><p>补充说明：执行rlogin指令开启终端机阶段操作，并登入远端主机。</p><p>参　　数：</p><ul><li>-8 　允许输入8位字符数据。 </li><li>-e脱离字符&gt; 　设置脱离字符。 </li><li>-E 　滤除脱离字符。 </li><li>-l用户名称&gt; 　指定要登入远端主机的用户名称。 </li><li>-L 　使用litout模式进行远端登入阶段操作。</li></ul><h3 id="rsh-remote-shell"><a href="#rsh-remote-shell" class="headerlink" title="rsh(remote shell)"></a>rsh(remote shell)</h3><p>功能说明：远端登入的Shell。</p><p>语　　法：<code>rsh [-dn][-l &lt;用户名称&gt;][主机名称或IP地址][执行指令]</code></p><p>补充说明：rsh提供用户环境，也就是Shell，以便指令能够在指定的远端主机上执行。</p><p>参　　数：</p><ul><li>-d 　使用Socket层级的排错功能。 </li><li>-l&lt;用户名称&gt; 　指定要登入远端主机的用户名称。 </li><li>-n 　把输入的指令号向代号为/dev/null的特殊外围设备。</li></ul><h3 id="rwho"><a href="#rwho" class="headerlink" title="rwho"></a>rwho</h3><p>功能说明：查看系统用户。</p><p>语　　法：<code>rwho [-a]</code></p><p>补充说明：rwho指令的效果类似who指令，但它会显示局域网里所有主机的用户。主机必须提供rwhod常驻服务的功能，方可使用rwho指令。</p><p>参　　数：</p><ul><li>-a 　列出所有的用户，包括闲置时间超过1个小时以上的用户。</li></ul><h3 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h3><p>功能说明：多重视窗管理程序。</p><p>语　　法：<code>screen [-AmRvx -ls -wipe][-d &lt;作业名称&gt;][-h &lt;行数&gt;][-r &lt;作业名称&gt;][-s &lt;shell&gt;][-S &lt;作业名称&gt;]</code></p><p>补充说明：screen为多重视窗管理程序。此处所谓的视窗，是指一个全屏幕的文字模式画面。通常只有在使用telnet登入主机或是使用老式的终端机时，才有可能用到screen程序。</p><p>参　　数：</p><ul><li>-A 　将所有的视窗都调整为目前终端机的大小。 </li><li>-d&lt;作业名称&gt; 　将指定的screen作业离线。 </li><li>-h&lt;行数&gt; 　指定视窗的缓冲区行数。 </li><li>-m 　即使目前已在作业中的screen作业，仍强制建立新的screen作业。 </li><li>-r&lt;作业名称&gt; 　恢复离线的screen作业。 </li><li>-R 　先试图恢复离线的作业。若找不到离线的作业，即建立新的screen作业。 </li><li>-s&lt;shell&gt; 　指定建立新视窗时，所要执行的shell。 </li><li>-S&lt;作业名称&gt; 　指定screen作业的名称。 </li><li>-v 　显示版本信息。 </li><li>-x 　恢复之前离线的screen作业。 </li><li>-ls或–list 　显示目前所有的screen作业。 </li><li>-wipe 　检查目前所有的screen作业，并删除已经无法使用的screen作业。</li></ul><h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h3><p>功能说明：系统关机指令。</p><p>语　　法：<code>shutdown [-efFhknr][-t 秒数][时间][警告信息]</code></p><p>补充说明：shutdown指令可以关闭所有程序，并依用户的需要，进行重新开机或关机的动作。</p><p>参　　数：</p><ul><li>-c 　当执行”shutdown -h 11:50”指令时，只要按+键就可以中断关机的指令。 </li><li>-f 　重新启动时不执行fsck。 </li><li>-F 　重新启动时执行fsck。 </li><li>-h 　将系统关机。 </li><li>-k 　只是送出信息给所有用户，但不会实际关机。 </li><li>-n 　不调用init程序进行关机，而由shutdown自己进行。 </li><li>-r 　shutdown之后重新启动。 </li><li>-t&lt;秒数&gt; 　送出警告信息和删除信息之间要延迟多少秒。 </li></ul><p>PS :</p><pre><code>[时间 ] :　设置多久时间后执行shutdown指令。 [警告信息 ] : 要传送给所有登入用户的信息。</code></pre><h3 id="sliplogin"><a href="#sliplogin" class="headerlink" title="sliplogin"></a>sliplogin</h3><p>功能说明：将SLIP接口加入标准输入。</p><p>语　　法：<code>sliplogin [用户名称]</code></p><p>补充说明：sliplogin可将SLIP接口加入标准输入，把一般终端机的连线变成SLIP连线。通常可用来建立SLIP服务器，让远端电脑以SLIP连线到服务器。sliplogin活去检查/etc/slip/slip.hosts文件中是否有相同的用户名称。通过检查后，sliplogin会调用执行shell script来设置IP地址，子网掩码等网络界面环境。此shell script通常是/etc/slip/slip.login。</p><h3 id="su-super-user"><a href="#su-super-user" class="headerlink" title="su(super user)"></a><font color="red">su(super user)</font></h3><p>功能说明：变更用户身份。</p><p>语　　法：<code>su [-flmp][–help][–version][-][-c &lt;指令&gt;][-s &lt;shell&gt;][用户帐号]</code></p><p>补充说明：su可让用户暂时变更登入的身份。变更时须输入所要变更的用户帐号与密码。</p><p>参　　数：</p><ul><li>-c&lt;指令&gt;或–command=&lt;指令&gt; 　执行完指定的指令后，即恢复原来的身份。 </li><li>-f或–fast 　适用于csh与tsch，使shell不用去读取启动文件。 </li><li>-.-l或–login 　改变身份时，也同时变更工作目录，以及HOME,SHELL,USER,LOGNAME。此外，也会变更PATH变量。  </li><li>-m,-p或–preserve-environment 　变更身份时，不要变更环境变量。 </li><li>-s&lt;shell&gt;或–shell=&lt;shell&gt; 　指定要执行的shell。 </li><li>–help 　显示帮助。 </li><li>–version 　显示版本信息。 </li></ul><p>PS:</p><pre><code>[用户帐号 ] : 指定要变更的用户。若不指定此参数，则预设变更为root。</code></pre><h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a><font color="red">sudo</font></h3><p>功能说明：以其他身份来执行指令。</p><p>语　　法：<code>sudo [-bhHpV][-s &lt;shell&gt;][-u &lt;用户&gt;][指令] 或 sudo [-klv]</code></p><p>补充说明：sudo可让用户以其他的身份来执行指定的指令，预设的身份为root。在/etc/sudoers中设置了可执行sudo指令的用户。若其未经授权的用户企图使用sudo，则会发出警告的邮件给管理员。用户使用sudo时，必须先输入密码，之后有5分钟的有效期限，超过期限则必须重新输入密码。  </p><p>参　　数：</p><ul><li>-b 　在后台执行指令。 </li><li>-h 　显示帮助。 </li><li>-H 　将HOME环境变量设为新身份的HOME环境变量。 </li><li>-k 　结束密码的有效期限，也就是下次再执行sudo时便需要输入密码。 </li><li>-l 　列出目前用户可执行与无法执行的指令。 </li><li>-p 　改变询问密码的提示符号。 </li><li>-s&lt;shell&gt; 　执行指定的shell。 </li><li>-u&lt;用户&gt; 　以指定的用户作为新的身份。若不加上此参数，则预设以root作为新的身份。 </li><li>-v 　延长密码有效期限5分钟。 </li><li>-V 　显示版本信息。</li></ul><h3 id="suspend"><a href="#suspend" class="headerlink" title="suspend"></a>suspend</h3><p>功能说明：暂停执行shell。</p><p>语　　法：<code>suspend [-f]</code></p><p>补充说明：suspend为shell内建指令，可暂停目前正在执行的shell。若要恢复，则必须使用SIGCONT信息。</p><p>参　　数：</p><ul><li>-f 　若目前执行的shell为登入的shell，则suspend预设无法暂停此shell。若要强迫暂停登入的shell，则必须使用-f参数。</li></ul><h3 id="swatch-simple-watcher"><a href="#swatch-simple-watcher" class="headerlink" title="swatch(simple watcher)"></a>swatch(simple watcher)</h3><p>功能说明：系统监控程序。</p><p>语　　法：<code>swatch [-A &lt;分隔字符&gt;][-c &lt;设置文件&gt;][-f &lt;记录文件&gt;][-I &lt;分隔字符&gt;][-P &lt;分隔字符&gt;][-r &lt;时间&gt;][-t &lt;记录文件&gt;]</code></p><p>补充说明：swatch可用来监控系统记录文件，并在发现特定的事件时，执行指定的动作。swatch所监控的事件以及对应事件的动作都存放在swatch的配置文件中。预设的配置文件为拥护根目录下的.swatchrc。然而在Red Hat Linux的预设用户根目录下并没有.swatchrc配置文件，您可将/usr/doc/swatch-2.2/config_files/swatchrc.personal文件复制到用户根目录下的.swatchrc，然后修改.swatchrc所要监控的事件及执行的动作。</p><p>参　　数：</p><ul><li>-A&lt;分隔字符&gt; 　预设配置文件中，动作的分隔字符，预设为逗号。 </li><li>-c设置文件&gt; 　指定配置文件，而不使用预设的配置文件。 </li><li>-f记录文件&gt; 　检查指定的记录文件，检查完毕后不会继续监控该记录文件。 </li><li>-I分隔字符&gt; 　指定输入记录的分隔字符，预设为换行字符。 </li><li>-P分隔字符&gt; 　指定配置文件中，事件的分隔字符，预设为逗号。 </li><li>-r时间&gt; 　在指定的时间重新启动。 </li><li>-t&lt;记录文件&gt; 　检查指定的记录文件，并且会监控加入记录文件中的后继记录。</li></ul><h3 id="tload"><a href="#tload" class="headerlink" title="tload"></a>tload</h3><p>功能说明：显示系统负载状况。</p><p>语　　法：<code>tload [-V][-d &lt;间隔秒数&gt;][-s &lt;刻度大小&gt;][终端机编号]</code></p><p>补充说明：tload指令使用ASCII字符简单地以文字模式显示系统负载状态。假设不给予终端机编号，则会在执行tload指令的终端机显示负载情形。</p><p>参　　数：</p><ul><li>-d&lt;间隔秒数&gt; 　设置tload检测系统负载的间隔时间，单位以秒计算。 </li><li>-s&lt;刻度大小&gt; 　设置图表的垂直刻度大小，单位以列计算。 </li><li>-V 　显示版本信息。</li></ul><h3 id="top"><a href="#top" class="headerlink" title="top"></a><font color="red">top</font></h3><p>功能说明：显示，管理执行中的程序。</p><p>语　　法：<code>top [bciqsS][d &lt;间隔秒数&gt;][n &lt;执行次数&gt;]</code></p><p>补充说明：执行top指令可显示目前正在系统中执行的程序，并通过它所提供的互动式界面，用热键加以管理。</p><p>参　　数：</p><ul><li>b 　使用批处理模式。 </li><li>c 　列出程序时，显示每个程序的完整指令，包括指令名称，路径和参数等相关信息。 </li><li>d&lt;间隔秒数&gt; 　设置top监控程序执行状况的间隔时间，单位以秒计算。 </li><li>i 　执行top指令时，忽略闲置或是已成为Zombie的程序。 </li><li>n&lt;执行次数&gt; 　设置监控信息的更新次数。 </li><li>q 　持续监控程序执行的状况。 </li><li>s 　使用保密模式，消除互动模式下的潜在危机。 </li><li>S 　使用累计模式，其效果类似ps指令的”-S”参数。</li></ul><h3 id="uname"><a href="#uname" class="headerlink" title="uname"></a><font color="red">uname</font></h3><p>功能说明：显示系统信息。</p><p>语　　法：<code>uname [-amnrsv][–help][–version]</code></p><p>补充说明：uname可显示电脑以及操作系统的相关信息。</p><p>参　　数：</p><ul><li>-a或–all 　显示全部的信息。 </li><li>-m或–machine 　显示电脑类型。 </li><li>-n或-nodename 　显示在网络上的主机名称。 </li><li>-r或–release 　显示操作系统的发行编号。 </li><li>-s或–sysname 　显示操作系统名称。 </li><li>-v 　显示操作系统的版本。 </li><li>–help 　显示帮助。 </li><li>–version 　显示版本信息。</li></ul><h3 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a><font color="red">useradd</font></h3><p>功能说明：建立用户帐号。</p><p>语　　法：<code>useradd [-mMnr][-c &lt;备注&gt;][-d &lt;登入目录&gt;][-e &lt;有效期限&gt;][-f &lt;缓冲天数&gt;][-g &lt;群组&gt;][-G &lt;群组&gt;][-s &lt;shell&gt;][-u &lt;uid&gt;][用户帐号] 或 useradd -D [-b][-e &lt;有效期限&gt;][-f &lt;缓冲天数&gt;][-g &lt;群组&gt;][-G &lt;群组&gt;][-s &lt;shell&gt;]</code></p><p>补充说明：useradd可用来建立用户帐号。帐号建好之后，再用passwd设定帐号的密码．而可用userdel删除帐号。使用useradd指令所建立的帐号，实际上是保存在/etc/passwd文本文件中。</p><p>参　　数：</p><ul><li>-c&lt;备注&gt; 　加上备注文字。备注文字会保存在passwd的备注栏位中。　 </li><li>-d&lt;登入目录&gt; 　指定用户登入时的启始目录。 </li><li>-D 　变更预设值． </li><li>-e&lt;有效期限&gt; 　指定帐号的有效期限。 </li><li>-f&lt;缓冲天数&gt; 　指定在密码过期后多少天即关闭该帐号。 </li><li>-g&lt;群组&gt; 　指定用户所属的群组。 </li><li>-G&lt;群组&gt; 　指定用户所属的附加群组。 </li><li>-m 　自动建立用户的登入目录。 </li><li>-M 　不要自动建立用户的登入目录。 </li><li>-n 　取消建立以用户名称为名的群组． </li><li>-r 　建立系统帐号。 </li><li>-s&lt;shell&gt;　 　指定用户登入后所使用的shell。 </li><li>-u&lt;uid&gt; 　指定用户ID。</li></ul><h3 id="userconf"><a href="#userconf" class="headerlink" title="userconf"></a>userconf</h3><p>功能说明：用户帐号设置程序。</p><p>语　　法：<code>userconf [–addgroup &lt;群组&gt;][–adduser &lt;用户ID&gt;&lt;群组&gt;&lt;用户名称&gt;&lt;shell&gt;][–delgroup &lt;群组&gt;][–deluser &lt;用户ID&gt;][–help]</code></p><p>补充说明：userconf实际上为linuxconf的符号连接，提供图形界面的操作方式，供管理员建立与管理各类帐号。若不加任何参数，即进入图形界面。 </p><p>参　　数：</p><ul><li>–addgroup&lt;群组&gt; 　新增群组。 </li><li>–adduser&lt;用户ID&gt;&lt;群组&gt;&lt;用户名称&gt;&lt;shell&gt; 　新增用户帐号。 </li><li>–delgroup&lt;群组&gt; 　删除群组。 </li><li>–deluser&lt;用户ID&gt; 　删除用户帐号。 </li><li>–help 　显示帮助。</li></ul><h3 id="userdel"><a href="#userdel" class="headerlink" title="userdel"></a><font color="red">userdel</font></h3><p>功能说明：删除用户帐号。</p><p>语　　法：<code>userdel [-r][用户帐号]</code></p><p>补充说明：userdel可删除用户帐号与相关的文件。若不加参数，则仅删除用户帐号，而不删除相关文件。</p><p>参　　数：</p><ul><li>-f 　删除用户登入目录以及目录中所有文件。</li></ul><h3 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a><font color="red">usermod</font></h3><p>功能说明：修改用户帐号。</p><p>语　　法：<code>usermod [-LU][-c &lt;备注&gt;][-d &lt;登入目录&gt;][-e &lt;有效期限&gt;][-f &lt;缓冲天数&gt;][-g &lt;群组&gt;][-G &lt;群组&gt;][-l &lt;帐号名称&gt;][-s &lt;shell&gt;][-u &lt;uid&gt;][用户帐号]</code></p><p>补充说明：usermod可用来修改用户帐号的各项设定。</p><p>参　　数：</p><ul><li>-c&lt;备注&gt; 　修改用户帐号的备注文字。 </li><li>-d登入目录&gt; 　修改用户登入时的目录。 </li><li>-e&lt;有效期限&gt; 　修改帐号的有效期限。 </li><li>-f&lt;缓冲天数&gt; 　修改在密码过期后多少天即关闭该帐号。 </li><li>-g&lt;群组&gt; 　修改用户所属的群组。 </li><li>-G&lt;群组&gt; 　修改用户所属的附加群组。 </li><li>-l&lt;帐号名称&gt; 　修改用户帐号名称。 </li><li>-L 　锁定用户密码，使密码无效。 </li><li>-s&lt;shell&gt; 　修改用户登入后所使用的shell。 </li><li>-u&lt;uid&gt; 　修改用户ID。 </li><li>-U 　解除密码锁定。</li></ul><h3 id="vlock-virtual-console-lock"><a href="#vlock-virtual-console-lock" class="headerlink" title="vlock(virtual console lock)"></a>vlock(virtual console lock)</h3><p>功能说明：锁住虚拟终端。</p><p>语　　法：<code>vlock [-achv]</code></p><p>补充说明：执行vlock指令可锁住虚拟终端，避免他人使用。</p><p>参　　数：</p><ul><li>-a或–all 　锁住所有的终端阶段作业，如果您在全屏幕的终端中使用本参数，则会将用键盘切换终端机的功能一并关闭。 </li><li>-c或–current 　锁住目前的终端阶段作业，此为预设值。 </li><li>-h或–help 　在线帮助。 </li><li>-v或–version 　显示版本信息。</li></ul><h3 id="w"><a href="#w" class="headerlink" title="w"></a><font color="red">w</font></h3><p>功能说明：显示目前登入系统的用户信息。</p><p>语　　法：<code>w [-fhlsuV][用户名称]</code></p><p>补充说明：执行这项指令可得知目前登入系统的用户有那些人，以及他们正在执行的程序。单独执行w<br>指令会显示所有的用户，您也可指定用户名称，仅显示某位用户的相关信息。</p><p>参　　数：</p><ul><li>-f 　开启或关闭显示用户从何处登入系统。 </li><li>-h 　不显示各栏位的标题信息列。 </li><li>-l 　使用详细格式列表，此为预设值。 </li><li>-s 　使用简洁格式列表，不显示用户登入时间，终端机阶段作业和程序所耗费的CPU时间。 </li><li>-u 　忽略执行程序的名称，以及该程序耗费CPU时间的信息。 </li><li>-V 　显示版本信息。</li></ul><h3 id="who"><a href="#who" class="headerlink" title="who"></a>who</h3><p>功能说明：显示目前登入系统的用户信息。</p><p>语　　法：<code>who [-Himqsw][–help][–version][am i][记录文件]</code></p><p>补充说明：执行这项指令可得知目前有那些用户登入系统，单独执行who指令会列出登入帐号，使用的 终端机，登入时间以及从何处登入或正在使用哪个X显示器。</p><p>参　　数：</p><ul><li>-H或–heading 　显示各栏位的标题信息列。 </li><li>-i或-u或–idle 　显示闲置时间，若该用户在前一分钟之内有进行任何动作，将标示成”.”号，如果该用户已超过24小时没有任何动作，则标示出”old”字符串。 </li><li>-m 　此参数的效果和指定”am i”字符串相同。 </li><li>-q或–count 　只显示登入系统的帐号名称和总人数。 </li><li>-s 　此参数将忽略不予处理，仅负责解决who指令其他版本的兼容性问题。 </li><li>-w或-T或–mesg或–message或–writable 　显示用户的信息状态栏。 </li><li>–help 　在线帮助。 </li><li>–version 　显示版本信息。</li></ul><h3 id="whoami"><a href="#whoami" class="headerlink" title="whoami"></a>whoami</h3><p>功能说明：显示用户名称。</p><p>语　　法：<code>whoami [–help][–version]</code></p><p>补充说明：显示自身的用户名称，本指令相当于执行”id -un”指令。</p><p>参　　数：</p><ul><li>–help 　在线帮助。 </li><li>–version 　显示版本信息。</li></ul><h3 id="whois"><a href="#whois" class="headerlink" title="whois"></a>whois</h3><p>功能说明：查找并显示用户信息。</p><p>语　　法：<code>whois [帐号名称]</code></p><p>补充说明：whois指令会去查找并显示指定帐号的用户相关信息，因为它是到Network Solutions的WHOIS数据库去查找，所以该帐号名称必须在上面注册方能寻获，且名称没有大小写的差别。</p><h2 id="linux系统设置命令"><a href="#linux系统设置命令" class="headerlink" title="linux系统设置命令"></a>linux系统设置命令</h2><h3 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h3><p>功能说明：设置指令的别名。</p><p>语　　法：<code>alias[别名]=[指令名称]</code></p><p>补充说明：用户可利用alias，自定指令的别名。若仅输入alias，则可列出目前所有的别名设置。　alias的效力仅及于该次登入的操作。若要每次登入是即自动设好别名，可在.profile或.cshrc中设定指令的别名。</p><p>参　　数：若不加任何参数，则列出目前所有的别名设置。</p><h3 id="apmd-advanced-power-management-BIOS-daemon"><a href="#apmd-advanced-power-management-BIOS-daemon" class="headerlink" title="apmd(advanced power management BIOS daemon)"></a>apmd(advanced power management BIOS daemon)</h3><p>功能说明：进阶电源管理服务程序。</p><p>语　　法：<code>apmd [-u v V W][-p &lt;百分比变化量&gt;][-w &lt;百分比值&gt;]</code></p><p>补充说明：apmd负责BIOS进阶电源管理(APM)相关的记录，警告与管理工作。</p><p>参　　数：</p><ul><li>-p&lt;百分比变化量&gt;或–percentage&lt;百分比变化量&gt;  当电力变化的幅度超出设置的百分比变化量，即记录事件百分比变化量的预设值为5，若设置值超过100，则关闭此功能。 </li><li>-u或–utc 将BIOS时钟设为UTC，以便从悬待模式恢复时，将-u参数传送至clock或hwclock程序。 </li><li>-v或–verbose 记录所有的APM事件。 </li><li>-V或–version 显示版本信息。 </li><li>-w&lt;百分比值&gt;或–warn&lt;百分比值&gt; 当电池不在充电状态时，且电池电量低于设置的百分比值，则在syslog(2)的ALERT层记录警告信息。百分比值的预设置为10，若设置为0，则关闭此功能。  </li><li>-W或–wall 发出警告信息给所有人。</li></ul><h3 id="aumix-audio-mixer"><a href="#aumix-audio-mixer" class="headerlink" title="aumix(audio mixer)"></a>aumix(audio mixer)</h3><p>功能说明：设置音效装置。</p><p>语　　法：<code>aumix [-123bcilmoprstvwWx][(+/-)强度][PqR][-dfhILqS]</code></p><p>补充说明：设置各项音效装置的信号强度以及指定播放与录音的装置。</p><p>参　　数：</p><ul><li>[-123bcilmoprstvwWx]为频道参数，用来指定装置的频道；[PqR]可用来指定播放或录音装置；[-dfhILqS] 则为指令参数。若不加任何参数，aumix会显示简单的图形界面供调整设置频道参数：</li><li>-1 　输入信号线１。 </li><li>-2 　输入信号线２。 </li><li>-3 　输入信号线３。 </li><li>-b 　低音。 </li><li>-c 　CD。 </li><li>-i 　输入信号强度。 </li><li>-m 　麦克风。 </li><li>-o 　输出信号强度。  </li><li>-p 　PC喇叭。 </li><li>-r 　录音。 </li><li>-s 　合成器。 </li><li>-t 　高音。 </li><li>-v 　主音量。 </li><li>-w 　PCM。 </li><li>-W 　PCM2。 </li><li>-x 　混音器。 </li><li>(+/-)强度 　出现(+/-)时，代表在原有的强度上加减指定值。若未使用(+/-)，则直接将强度设为指定值。 　</li></ul><p>指定音效装置 </p><ul><li>P 　指定播放装置。 </li><li>q 　显示频道设置。 </li><li>R 　指定录音装置。 </li></ul><p>指令参数 </p><ul><li>-d 　指定音效装置的名称。 </li><li>-f 　指定存储或载入设置的文件。 </li><li>-h 　在使用时显示信息。 </li><li>-I 　以图形界面方式来执行aumix。 </li><li>-L 　从$HOME/.aumixrc或/etc/aumixrc载入设置。 </li><li>-q 　显示所有频道的设置值。 </li><li>-S 　将设置值保存至/HOME/.aumixrc。</li></ul><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>功能说明：显示或设置键盘按键与其相关的功能。</p><p>语　　法：<code>bind [-dlv][-f &lt;按键配置文件&gt;][-m &lt;按键配置&gt;][-q &lt;功能&gt;]</code></p><p>补充说明：您可以利用bind命令了解有哪些按键组合与其功能，也可以自行指定要用哪些按键组合。</p><p>参　　数：</p><ul><li>-d 　显示按键配置的内容。 </li><li>-f&lt;按键配置文件&gt; 　载入指定的按键配置文件。 </li><li>-l 　列出所有的功能。 </li><li>-m&lt;按键配置&gt; 　指定按键配置。 </li><li>-q&lt;功能&gt; 　显示指定功能的按键。 </li><li>-v 　列出目前的按键配置与其功能。</li></ul><h3 id="chkconfig-check-config"><a href="#chkconfig-check-config" class="headerlink" title="chkconfig(check config)"></a>chkconfig(check config)</h3><p>功能说明：检查，设置系统的各种服务。</p><p>语　　法：<code>chkconfig [–add][–del][–list][系统服务] 或 chkconfig [–level &lt;等级代号&gt;][系统服务][on/off/reset]</code></p><p>补充说明：这是Red Hat公司遵循GPL规则所开发的程序，它可查询操作系统在每一个执行等级中会执行哪些系统服务，其中包括各类常驻服务。</p><p>参　　数：</p><ul><li>–add 　增加所指定的系统服务，让chkconfig指令得以管理它，并同时在系统启动的叙述文件内增加相关数据。 </li><li>–del 　删除所指定的系统服务，不再由chkconfig指令管理，并同时在系统启动的叙述文件内删除相关数据。 </li><li>–level&lt;等级代号&gt; 　指定读系统服务要在哪一个执行等级中开启或关毕</li></ul><h3 id="chroot-change-root"><a href="#chroot-change-root" class="headerlink" title="chroot(change root)"></a>chroot(change root)</h3><p>功能说明：改变根目录。</p><p>语　　法：<code>chroot [–help][–version][目的目录][执行指令…]</code></p><p>补充说明：把根目录换成指定的目的目录。</p><p>参　　数：</p><ul><li>–help 　在线帮助。</li><li>–version 　显示版本信息。</li></ul><h3 id="clock"><a href="#clock" class="headerlink" title="clock"></a>clock</h3><p>功能说明：调整 RTC 时间。</p><p>语　　法：<br><code>clock [–adjust][–debug][–directisa][–getepoch][–hctosys][–set –date=”&lt;日期时间&gt;”][–setepoch –epoch=&lt;年份&gt;][–show][–systohc][–test][–utc][–version]</code></p><p>补充说明：RTC 是电脑内建的硬件时间，执行这项指令可以显示现在时刻，调整硬件时钟的时间，将系统时间设成与硬件时钟之时间一致，或是把系统时间回存到硬件时钟。</p><p>参　　数：</p><ul><li>–adjust 　第一次使用”–set”或”–systohc”参数设置硬件时钟，会在/etc目录下产生一个名称为adjtime的文件。当再次使用这两个参数调整硬件时钟，此文件便会记录两次调整间之差异，日后执行clock指令加上”–adjust”参数时，程序会自动根 据记录文件的数值差异，计算出平均值，自动调整硬件时钟的时间。 </li><li>–debug 　详细显示指令执行过程，便于排错或了解程序执行的情形。 </li><li>–directisa 　告诉clock指令不要通过/dev/rtc设备文件，直接对硬件时钟进行存取。这个参数适用于仅有ISA总线结构的老式电脑。 </li><li>–getepoch 　把系统核心内的硬件时钟新时代数值，呈现到标准输出设备。 </li><li>–hctosys 　Hardware Clock to System Time，把系统时间设成和硬件时钟一致。由于这个动作将会造成系统全面更新文件的存取时间，所以最好在系统启动时就执行它。 </li><li>–set–date 　设置硬件时钟的日期和时间。 </li><li>–setepoch–epoch=&lt;年份&gt;  　设置系统核心之硬件时钟的新时代数值，年份以四位树字表示。 </li><li>–show 　读取硬件时钟的时间，并将其呈现至标准输出设备。 </li><li>–systohc 　System Time to Hardware Clock，将系统时间存回硬件时钟内。 </li><li>–test 　仅作测试，并不真的将时间写入硬件时钟或系统时间。 </li><li>–utc 　把硬件时钟上的时间时为CUT，有时也称为UTC或UCT。 </li><li>–version 　显示版本信息。</li></ul><h3 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h3><p>功能说明：设置计时器。</p><p>语　　法：<code>crontab [-u &lt;用户名称&gt;][配置文件] 或 crontab [-u &lt;用户名称&gt;][-elr]</code></p><p>补充说明：cron是一个常驻服务，它提供计时器的功能，让用户在特定的时间得以执行预设的指令或程序。只要用户会编辑计时器的配置文件，就可以使用计时器的功能。其配置文件格式如下：</p><pre><code>Minute Hour Day Month DayOFWeek Command </code></pre><p>参　　数：</p><ul><li>-e 　编辑该用户的计时器设置。 </li><li>-l 　列出该用户的计时器设置。 </li><li>-r 　删除该用户的计时器设置。 </li><li>-u&lt;用户名称&gt; 　指定要设定计时器的用户名称。</li></ul><h3 id="declare"><a href="#declare" class="headerlink" title="declare"></a>declare</h3><p>功能说明：声明 shell 变量。</p><p>语　　法：<code>declare [+/-][rxi][变量名称＝设置值] 或 declare -f</code></p><p>补充说明：declare为shell指令，在第一种语法中可用来声明变量并设置变量的属性([rix]即为变量的属性），在第二种语法中可用来显示shell函数。若不加上任何参数，则会显示全部的shell变量与函数(与执行set指令的效果相同)。</p><p>参　　数：</p><ul><li>+/- 　“-“可用来指定变量的属性，”+”则是取消变量所设的属性。 </li><li>-f 　仅显示函数。 </li><li>r 　将变量设置为只读。 </li><li>x 　指定的变量会成为环境变量，可供shell以外的程序来使用。 </li><li>i 　[设置值]可以是数值，字符串或运算式。</li></ul><h3 id="depmod-depend-module"><a href="#depmod-depend-module" class="headerlink" title="depmod(depend module)"></a>depmod(depend module)</h3><p>功能说明：分析可载入模块的相依性。</p><p>语　　法：<code>depmod [-adeisvV][-m &lt;文件&gt;][–help][模块名称]</code></p><p>补充说明：depmod可检测模块的相依性，供modprobe在安装模块时使用。</p><p>参　　数：</p><ul><li>-a或–all 　分析所有可用的模块。 </li><li>-d或debug 　执行排错模式。 </li><li>-e 　输出无法参照的符号。 </li><li>-i 　不检查符号表的版本。 </li><li>-m&lt;文件&gt;或system-map&lt;文件&gt; 　使用指定的符号表文件。 </li><li>-s或–system-log 　在系统记录中记录错误。 </li><li>-v或–verbose 　执行时显示详细的信息。 </li><li>-V或–version 　显示版本信息。 </li><li>–help 　显示帮助。</li></ul><h3 id="dircolors"><a href="#dircolors" class="headerlink" title="dircolors"></a>dircolors</h3><p>功能说明：设置 ls 指令在显示目录或文件时所用的色彩。</p><p>语　　法：<code>dircolors [色彩配置文件] 或 dircolors [-bcp][–help][–version]</code></p><p>补充说明：dircolors可根据[色彩配置文件]来设置LS_COLORS环境变量或是显示设置LS_COLORS环境变量的shell指令。</p><p>参　　数：</p><ul><li>-b或–sh或–bourne-shell 　显示在Boume shell中，将LS_COLORS设为目前预设置的shell指令。 </li><li>-c或–csh或–c-shell 　显示在C shell中，将LS_COLORS设为目前预设置的shell指令。 </li><li>-p或–print-database 　显示预设置 </li><li>-help 　显示帮助。 </li><li>-version 　显示版本信息。</li></ul><h3 id="dmesg"><a href="#dmesg" class="headerlink" title="dmesg"></a>dmesg</h3><p>功能说明：显示开机信息。</p><p>语　　法：<code>dmesg [-cn][-s &lt;缓冲区大小&gt;]</code></p><p>补充说明：kernel会将开机信息存储在ring buffer中。您若是开机时来不及查看信息，可利用dmesg来查看。开机信息亦保存在/var/log目录中，名称为dmesg的文件里。</p><p>参　　数：</p><ul><li>-c 　显示信息后，清除ring buffer中的内容。 </li><li>-s&lt;缓冲区大小&gt; 　预设置为8196，刚好等于ring buffer的大小。 </li><li>-n 　设置记录信息的层级。</li></ul><h3 id="enable"><a href="#enable" class="headerlink" title="enable"></a>enable</h3><p>功能说明：启动或关闭 shell 内建指令。</p><p>语　　法：<code>enable [-n][-all][内建指令]</code></p><p>补充说明：若要执行的文件名称与shell内建指令相同，可用enable -n来关闭shell内建指令。若不加-n参数，enable可重新启动关闭的指令。</p><p>参　　数：</p><ul><li>-n 　关闭指定的shell内建指令。 </li><li>-all 　显示shell所有关闭与启动的指令。</li></ul><h3 id="eval"><a href="#eval" class="headerlink" title="eval"></a><font color="red">eval</font></h3><p>功能说明：重新运算求出参数的内容。</p><p>语　　法：<code>eval [参数]</code></p><p>补充说明：eval可读取一连串的参数，然后再依参数本身的特性来执行。</p><p>参　　数：参数不限数目，彼此之间用分号分开。</p><h3 id="export"><a href="#export" class="headerlink" title="export"></a><font color="red">export</font></h3><p>功能说明：设置或显示环境变量。</p><p>语　　法：<code>export [-fnp][变量名称]=[变量设置值]</code></p><p>补充说明：在shell中执行程序时，shell会提供一组环境变量。export可新增，修改或删除环境变量，供后续执行的程序使用。export的效力仅及于该此登陆操作。</p><p>参　　数：</p><ul><li>-f 　代表[变量名称]中为函数名称。 </li><li>-n 　删除指定的变量。变量实际上并未删除，只是不会输出到后续指令的执行环境中。 </li><li>-p 　列出所有的shell赋予程序的环境变量。</li></ul><h3 id="fbset-frame-buffer-setup"><a href="#fbset-frame-buffer-setup" class="headerlink" title="fbset(frame buffer setup)"></a>fbset(frame buffer setup)</h3><p>功能说明：设置景框缓冲区。</p><p>语　　法：<code>fbset [-ahinsvVx][-db &lt;信息文件&gt;][-fb &lt;外围设备代号&gt;][–test][显示模式]</code></p><p>补充说明：fbset指令可用于设置景框缓冲区的大小，还能调整画面之分辨率，位置，高低宽窄，色彩 深度，并可决定是否启动先卡之各项硬件特性。</p><p>参　　数：</p><ul><li>-a或–all 　改变所有使用该设备之虚拟终端机的显示模式。 </li><li>-db&lt;信息文件&gt; 　指定显示模式的信息文件，预设值文件名称为fb.modes，存放在/etc目录下  </li><li>-fb&lt;外围设备代号&gt; 　指定用来做为输出景框缓冲区之外围设备，预设置为”/dev/fd0”。 </li><li>-h或-help 　在线帮助。 </li><li>-i或–info 　列出所有景框缓冲区之相关信息。 </li><li>-ifb&lt;外围设备代号&gt; 　使用另一个景框缓冲区外围设备之设置值。 </li><li>-n或–now 　马上改变显示模式。 </li><li>-ofb&lt;外围设备代号&gt; 　此参数效果和指定”-fb”参数相同。 </li><li>-s或–show 　列出目前显示模式之设置。 </li><li>-v或–verbose 　显示指令执行过程。 </li><li>-V或–version 　显示版本信息。 </li><li>-x或–xfree86 　使用XFree86兼容模式。 </li><li>–test 　仅做测试，并不改变现行的显示模式</li></ul><h3 id="grpconv-group-convert-to-shadow-password"><a href="#grpconv-group-convert-to-shadow-password" class="headerlink" title="grpconv(group convert to shadow password)"></a>grpconv(group convert to shadow password)</h3><p>功能说明：开启群组的投影密码。</p><p>语　　法：<code>grpconv</code></p><p>补充说明：Linux系统里的用户和群组密码，分别存放在/etc目录下的passwd和group文件中。因系统运作所需，任何人都得以读取它们，造成安全上的破绽。投影密码将文件内的密码改存在/etc目录下的shadow和gshadow文件内，只允许系统管理者读取，同时把原密码置换为”x”字符。投影密码的功能可随时开启或关闭，您只需执行grpconv指令就能开启群组投影密码。</p><h3 id="grpunconv-group-unconvert-from-shadow-password"><a href="#grpunconv-group-unconvert-from-shadow-password" class="headerlink" title="grpunconv(group unconvert from shadow password)"></a>grpunconv(group unconvert from shadow password)</h3><p>功能说明：关闭群组的投影密码。</p><p>语　　法：<code>grpunconv</code></p><p>补充说明：执行grpunconv指令可关闭群组投影密码，它会把密码从gshadow文件内，回存到group文件里。</p><h3 id="hwclock-hardware-clock"><a href="#hwclock-hardware-clock" class="headerlink" title="hwclock(hardware clock)"></a>hwclock(hardware clock)</h3><p>功能说明：显示与设定硬件时钟。</p><p>语　　法：<br><code>hwclock [–adjust][–debug][–directisa][–hctosys][–show][–systohc][–test]<br>[–utc][–version][–set –date=&lt;日期与时间&gt;]</code></p><p>补充说明：在Linux中有硬件时钟与系统时钟等两种时钟。硬件时钟是指主机板上的时钟设备，也就是通常可在BIOS画面设定的时钟。系统时钟则是指kernel中的时钟。当Linux启动时，系统时钟会去读取硬件时钟的设定，之后系统时钟即独立运作。所有Linux相关指令与函数都是读取系统时钟的设定。</p><p>参　　数：</p><ul><li>–adjust 　hwclock每次更改硬件时钟时，都会记录在/etc/adjtime文件中。使用–adjust参数，可使hwclock根据先前的记录来估算硬件时钟的偏差，并用来校正目前的硬件时钟。 </li><li>–debug 　显示hwclock执行时详细的信息。 </li><li>–directisa 　hwclock预设从/dev/rtc设备来存取硬件时钟。若无法存取时，可用此参数直接以I/O指令来存取硬件时钟。 </li><li>–hctosys 　将系统时钟调整为与目前的硬件时钟一致。 </li><li>–set –date=&lt;日期与时间&gt; 　设定硬件时钟。 </li><li>–show 　显示硬件时钟的时间与日期。 </li><li>–systohc 　将硬件时钟调整为与目前的系统时钟一致。 </li><li>–test 　仅测试程序，而不会实际更改硬件时钟。 </li><li>–utc 　若要使用格林威治时间，请加入此参数，hwclock会执行转换的工作。 </li><li>–version 　显示版本信息。</li></ul><h3 id="insmod-install-module"><a href="#insmod-install-module" class="headerlink" title="insmod(install module)"></a>insmod(install module)</h3><p>功能说明：载入模块。</p><p>语　　法：<code>insmod [-fkmpsvxX][-o &lt;模块名称&gt;][模块文件][符号名称 = 符号值]</code></p><p>补充说明：Linux有许多功能是通过模块的方式，在需要时才载入kernel。如此可使kernel较为精简，进而提高效率，以及保有较大的弹性。这类可载入的模块，通常是设备驱动程序。</p><p>参　　数：</p><ul><li>-f 　不检查目前kernel版本与模块编译时的kernel版本是否一致，强制将模块载入。 </li><li>-k 　将模块设置为自动卸除。 </li><li>-m 　输出模块的载入信息。 </li><li>-o&lt;模块名称&gt; 　指定模块的名称，可使用模块文件的文件名。 </li><li>-p 　测试模块是否能正确地载入kernel。 </li><li>-s 　将所有信息记录在系统记录文件中。 </li><li>-v 　执行时显示详细的信息。 </li><li>-x 　不要汇出模块的外部符号。 </li><li>-X 　汇出模块所有的外部符号，此为预设置</li></ul><h3 id="kbdconfig"><a href="#kbdconfig" class="headerlink" title="kbdconfig"></a>kbdconfig</h3><p>功能说明：设置键盘类型。</p><p>语　　法：<code>kbdconfig [–back][–test]</code></p><p>补充说明：kbdconfig(Red Hat Linux才有的指令)是一个用来设置键盘的程序，提供图形化的操作界面。kbdconfig实际上是修改/etc/sysconfig/keyboard的键盘配置文件。</p><p>参　　数：</p><ul><li>–back 　执行时将预设的Cancel按钮更改为Back按钮。 </li><li>–test 　仅作测试，不会实际更改设置。</li></ul><h3 id="lilo-linux-loader"><a href="#lilo-linux-loader" class="headerlink" title="lilo(linux loader)"></a>lilo(linux loader)</h3><p>功能说明：安装核心载入，开机管理程序。</p><p>语　　法：<code>lilo [-clqtV][-b&lt;外围设备代号&gt;][-C&lt;配置文件&gt;][-d&lt;延迟时间&gt;][－D&lt;识别标签&gt;][-f&lt;几何参数文件&gt;][-i&lt;开机磁区文件&gt;][-I&lt;识别标签&gt;][-m&lt;映射文件&gt;][-P&lt;fix/ignore&gt;][-r&lt;根目录&gt;][-R&lt;执行指令&gt;…][-s&lt;备份文件&gt;][-S&lt;备份文件&gt;][-uU&lt;外围设备代号&gt;][-v…]</code></p><p>补充说明：lilo是个Linux系统核心载入程序，同时具备管理开机的功能。单独执行lilo指令，它会读取/etc/目录下的lilo.conf配置文件，然后根据其内容安装lilo。</p><p>参　　数：</p><ul><li>-b&lt;外围设备代号&gt; 　指定安装lilo之处的外围设备代号。 </li><li>-c 　使用紧致映射模式。 </li><li>-C&lt;配置文件&gt; 　指定lilo的配置文件。 </li><li>-d&lt;延迟时间&gt; 　设置开机延迟时间。 </li><li>-D&lt;识别标签&gt; 　指定开机后预设启动的操作系统，或系统核心识别标签。 </li><li>-f&lt;几何参数文件&gt; 　指定磁盘的几何参数配置文件。 </li><li>-i&lt;开机磁区文件&gt; 　指定欲使用的开机磁区文件，预设是/boot目录里的boot.b文件。 </li><li>-I&lt;识别标签&gt; 　显示系统核心存放之处。 </li><li>-l 　产生线形磁区地址。 </li><li>-m&lt;映射文件&gt; 　指定映射文件。 </li><li>-P&lt;fix/ignore&gt; 　决定要修复或忽略分区表的错误。 </li><li>-q 　列出映射的系统核心文件。 </li><li>-r&lt;根目录&gt; 　设置系统启动时欲挂入成为根目录的目录。 </li><li>-R&lt;执行指令&gt; 　设置下次启动系统时，首先执行的指令。 </li><li>-s&lt;备份文件&gt; 　指定备份文件。 </li><li>-S&lt;备份文件&gt; 　强制指定备份文件。 </li><li>-t 　不执行指令，仅列出实际执行会进行的动作。 </li><li>-u&lt;外围色设备代号&gt; 　删除lilo。 </li><li>-U&lt;外围设备代号&gt; 　此参数的效果和指定”-u”参数类似，当不检查时间戳记。 </li><li>-v 　显示指令执行过程。 </li><li>-V 　显示版本信息。</li></ul><h3 id="liloconfig"><a href="#liloconfig" class="headerlink" title="liloconfig"></a>liloconfig</h3><p>功能说明：设置核心载入，开机管理程序。</p><p>语　　法：<code>liloconfig</code></p><p>补充说明：liloconfig是Slackware发行版专门用来调整lilo设置的程序。它通过互动式操作界面，让用户能够利用键盘上的方向键等，轻易地操控lilo的安装，设置作业，而无须下达各种参数或撰写配置文件。</p><h3 id="lsmod-list-modules"><a href="#lsmod-list-modules" class="headerlink" title="lsmod(list modules)"></a>lsmod(list modules)</h3><p>功能说明：显示已载入系统的模块。</p><p>语　　法：<code>lsmod</code></p><p>补充说明：执行lsmod指令，会列出所有已载入系统的模块。Linux操作系统的核心具有模块化的特性，应此在编译核心时，务须把全部的功能都放入核心。您可以将这些功能编译成一个个单独的模块，待需要时再分别载入。</p><h3 id="minfo"><a href="#minfo" class="headerlink" title="minfo"></a>minfo</h3><p>功能说明：显示MS-DOS文件系统的各项参数。</p><p>语　　法：<code>minfo [-v][驱动器代号]</code></p><p>补充说明：minfo为mtools工具指令，可显示MS-DOS系统磁盘的各项参数，包括磁区数，磁头数…等。</p><p>参　　数：</p><ul><li>-v 　除了一般信息外，并显示可开机磁区的内容。</li></ul><h3 id="mkkickstart"><a href="#mkkickstart" class="headerlink" title="mkkickstart"></a>mkkickstart</h3><p>功能说明：建立安装的组态文件。</p><p>语　　法：<code>mkkickstart [–bootp][–dhcp][–nonet][–nox][–version][–nfs &lt;远端电脑:路径&gt;]</code></p><p>补充说明：mkkickstart可根据目前系统的设置来建立组态文件，供其他电脑在安装时使用。组态文件的内容包括使用语言，网络环境，系统磁盘状态，以及X Windows的设置等信息。</p><p>参　　数：</p><ul><li>–bootp 　安装与开机时，使用BOOTP。 </li><li>–dhcp 　安装与开机时，使用DHCP。 </li><li>–nfs&lt;远端电脑:路径&gt; 　使用指定的网络路径安装。 </li><li>–nonet 　不要进行网络设置，即假设在没有网络环境的状态下。 </li><li>–nox 　不要进行X Windows的环境设置。 </li><li>–version 　显示版本信息。</li></ul><h3 id="modinfo-module-infomation"><a href="#modinfo-module-infomation" class="headerlink" title="modinfo(module infomation)"></a>modinfo(module infomation)</h3><p>功能说明：显示kernel模块的信息。</p><p>语　　法：<code>modinfo [-adhpV][模块文件]</code></p><p>补充说明：modinfo会显示kernel模块的对象文件，以显示该模块的相关信息。</p><p>参　　数：</p><ul><li>-a或–author 　显示模块开发人员。 </li><li>-d或–description 　显示模块的说明。 </li><li>-h或–help 　显示modinfo的参数使用方法。 </li><li>-p或–parameters 　显示模块所支持的参数。 </li><li>-V或–version 　显示版本信息。</li></ul><h3 id="modprobe-module-probe"><a href="#modprobe-module-probe" class="headerlink" title="modprobe(module probe)"></a>modprobe(module probe)</h3><p>功能说明：自动处理可载入模块。</p><p>语　　法：<code>modprobe [-acdlrtvV][–help][模块文件][符号名称 = 符号值]</code></p><p>补充说明：modprobe可载入指定的个别模块，或是载入一组相依的模块。modprobe会根据depmod所产生的相依关系，决定要载入哪些模块。若在载入过程中发生错误，在modprobe会卸载整组的模块。</p><p>参　　数：</p><ul><li>-a或–all 　载入全部的模块。 </li><li>-c或–show-conf 　显示所有模块的设置信息。 </li><li>-d或–debug 　使用排错模式。 </li><li>-l或–list 　显示可用的模块。 </li><li>-r或–remove 　模块闲置不用时，即自动卸载模块。 </li><li>-t或–type 　指定模块类型。 </li><li>-v或–verbose 　执行时显示详细的信息。 </li><li>-V或–version 　显示版本信息。 </li><li>-help 　显示帮助。</li></ul><h3 id="mouseconfig"><a href="#mouseconfig" class="headerlink" title="mouseconfig"></a>mouseconfig</h3><p>功能说明：设置鼠标相关参数。</p><p>语　　法：<br><code>mouseconfig [–back][–emulthree][–help][–expert][–kickstart][–noprobe][–test][–device &lt;连接端口&gt;][鼠标类型]</code></p><p>补充说明：mouseconfig为鼠标设置程序，可自动设置相关参数，或者用户也可以利用所提供互动模式自行设置鼠标。mouseconfig是Red Hat Linux才有的命令。</p><p>参　　数：</p><ul><li>–back 　在设置画面上显示Back按钮，而取代预设的Cancel按钮。 </li><li>–device&lt;连接端口&gt; 　指定硬件连接端口。可用的选项有ttyS0，ttyS1，ttyS2，ttyS3与orpsaux。 </li><li>–emulthree 　将二钮鼠标模拟成三钮鼠标。 </li><li>–help 　显示帮助以及所有支持的鼠标类型。 </li><li>–expert 　程序预设可自动判断部分设置值。若要自行设置，请使用–expert参数。 </li><li>–kickstart 　让程序自动检测并保存所有的鼠标设置。 </li><li>–noprobe 　不要检测鼠标设备。 </li><li>–test 　测试模式，不会改变任何设置。</li></ul><h3 id="ntsysv"><a href="#ntsysv" class="headerlink" title="ntsysv"></a>ntsysv</h3><p>功能说明：设置系统的各种服务。</p><p>语　　法：<code>ntsysv [–back][–level &lt;等级代号&gt;]</code></p><p>补充说明：这是Red Hat公司遵循GPL规则所开发的程序，它具有互动式操作界面，您可以轻易地利用方向键和空格键等，开启，关闭操作系统在每个执行等级中，所要执行的系统服务。</p><p>参　　数：</p><ul><li>–back 　在互动式界面里，显示Back钮，而非Cancel钮。 </li><li>–level &lt;等级代号&gt; 　在指定的执行等级中，决定要开启或关闭哪些系统服务。</li></ul><h3 id="passwd-password"><a href="#passwd-password" class="headerlink" title="passwd(password)"></a>passwd(password)</h3><p>功能说明：设置密码。</p><p>语　　法：<code>passwd [-dklS][-u &lt;-f&gt;][用户名称]</code></p><p>补充说明：passwd指令让用户可以更改自己的密码，而系统管理者则能用它管理系统用户的密码。只有管理者可以指定用户名称，一般用户只能变更自己的密码。</p><p>参　　数：</p><ul><li>-d 　删除密码。本参数仅有系统管理者才能使用。 </li><li>-f 　强制执行。 </li><li>-k 　设置只有在密码过期失效后，方能更新。 </li><li>-l 　锁住密码。 </li><li>-s 　列出密码的相关信息。本参数仅有系统管理者才能使用。 </li><li>-u 　解开已上锁的帐号。</li></ul><h3 id="pwconv"><a href="#pwconv" class="headerlink" title="pwconv"></a>pwconv</h3><p>功能说明：开启用户的投影密码。</p><p>语　　法：<code>pwconv</code></p><p>补充说明：Linux系统里的用户和群组密码，分别存放在名称为passwd和group的文件中，　这两个文件位于/etc目录下。因系统运作所需，任何人都得以读取它们，造成安全上的破绽。投影密码将文件内的密码改存在/etc目录下的shadow和gshadow文件内，只允许系统管理者读取，同时把原密码置换为”x”字符，有效的强化了系统的安全性。</p><h3 id="pwunconv"><a href="#pwunconv" class="headerlink" title="pwunconv"></a>pwunconv</h3><p>功能说明：关闭用户的投影密码。</p><p>语　　法：<code>pwunconv</code></p><p>补充说明：执行pwunconv指令可以关闭用户投影密码，它会把密码从shadow文件内，重回存到passwd文件里。</p><h3 id="rdate-receive-date"><a href="#rdate-receive-date" class="headerlink" title="rdate(receive date)"></a>rdate(receive date)</h3><p>功能说明：显示其他主机的日期与时间。</p><p>语　　法：<code>rdate [-ps][主机名称或IP地址…]</code></p><p>补充说明：执行rdate指令，向其他主机询问系统时间并显示出来。</p><p>参　　数：</p><ul><li>-p 　显示远端主机的日期与时间。 </li><li>-s 　把从远端主机收到的日期和时间，回存到本地主机的系统时间。</li></ul><h3 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h3><p>功能说明：设置终端机视窗的大小。</p><p>语　　法：<code>resize [-cu][-s &lt;列数&gt; &lt;行数&gt;]</code></p><p>补充说明：执行resize指令可设置虚拟终端机的视窗大小。</p><p>参　　数：</p><ul><li>-c 　就算用户环境并非C Shell，也用C Shell指令改变视窗大小。 </li><li>-s &lt;列数&gt; &lt;行数&gt; 　设置终端机视窗的垂直高度和水平宽度。 </li><li>-u 　就算用户环境并非Bourne Shell，也用Bourne Shell指令改变视窗大小。</li></ul><h3 id="rmmod-remove-module"><a href="#rmmod-remove-module" class="headerlink" title="rmmod(remove module)"></a>rmmod(remove module)</h3><p>功能说明：删除模块。</p><p>语　　法：<code>rmmod [-as][模块名称…]</code></p><p>补充说明：执行rmmod指令，可删除不需要的模块。Linux操作系统的核心具有模块化的特性，应此在编译核心时，务须把全部的功能都放如核心。你可以将这些功能编译成一个个单独的模块，待有需要时再分别载入它们。</p><p>参　　数：</p><ul><li>-a 　删除所有目前不需要的模块。 </li><li>-s 　把信息输出至syslog常驻服务，而非终端机界面。</li></ul><h3 id="rpm-redhat-package-manager"><a href="#rpm-redhat-package-manager" class="headerlink" title="rpm(redhat package manager)"></a>rpm(redhat package manager)</h3><p>功能说明：管理套件。</p><p>语　　法：<code>rpm [-acdhilqRsv][-b&lt;完成阶段&gt;&lt;套间档&gt;+][-e&lt;套件挡&gt;][-f&lt;文件&gt;+][-i&lt;套件档&gt;][-p&lt;套件档&gt;＋][-U&lt;套件档&gt;][-vv][–addsign&lt;套件档&gt;+][–allfiles][–allmatches][–badreloc][–buildroot&lt;根目录&gt;][–changelog][–checksig&lt;套件档&gt;+][–clean][–dbpath&lt;数据库目录&gt;][–dump][–excludedocs][–excludepath&lt;排除目录&gt;][–force][–ftpproxy&lt;主机名称或IP地址&gt;][–ftpport&lt;通信端口&gt;][–help][–httpproxy&lt;主机名称或IP地址&gt;][–httpport&lt;通信端口&gt;][–ignorearch][–ignoreos][–ignoresize][–includedocs][–initdb][justdb][–nobulid][–nodeps][–nofiles][–nogpg][–nomd5][–nopgp][–noorder][–noscripts][–notriggers][–oldpackage][–percent][–pipe&lt;执行指令&gt;][–prefix&lt;目的目录&gt;][–provides][–queryformat&lt;档头格式&gt;][–querytags][–rcfile&lt;配置档&gt;][–rebulid&lt;套件档&gt;][–rebuliddb][–recompile&lt;套件档&gt;][–relocate&lt;原目录&gt;=&lt;新目录&gt;][–replacefiles][–replacepkgs][–requires][–resign&lt;套件档&gt;+][–rmsource][–rmsource&lt;文件&gt;][–root&lt;根目录&gt;][–scripts][–setperms][–setugids][–short-circuit][–sign][–target=&lt;安装平台&gt;+][–test][–timecheck&lt;检查秒数&gt;][–triggeredby&lt;套件档&gt;][–triggers][–verify][–version][–whatprovides&lt;功能特性&gt;][–whatrequires&lt;功能特性&gt;]</code></p><p>补充说明：rmp原本是Red Hat Linux发行版专门用来管理Linux各项套件的程序，由于它遵循GPL规则且功能强大方便，因而广受欢迎。逐渐受到其他发行版的采用。RPM套件管理方式的出现，让Linux易于安装，升级，间接提升了Linux的适用度。</p><p>参　　数：</p><ul><li>-a 　查询所有套件。</li><li>-b&lt;完成阶段&gt;&lt;套件档&gt;+或-t &lt;完成阶段&gt;&lt;套件档&gt;+ 　设置包装套件的完成阶段，并指定套件档的文件名称。</li><li>-c 　只列出组态配置文件，本参数需配合”-l”参数使用。 </li><li>-d 　只列出文本文件，本参数需配合”-l”参数使用。　 </li><li>-e&lt;套件档&gt;或–erase&lt;套件档&gt; 　删除指定的套件。</li><li>-f&lt;文件&gt;+ 　查询拥有指定文件的套件。 </li><li>-h或–hash 　套件安装时列出标记。 </li><li>-i 　显示套件的相关信息。 </li><li>-i&lt;套件档&gt;或–install&lt;套件档&gt; 　安装指定的套件档。 </li><li>-l 　显示套件的文件列表。 </li><li>-p&lt;套件档&gt;+ 　查询指定的RPM套件档。 </li><li>-q 　使用询问模式，当遇到任何问题时，rpm指令会先询问用户。 </li><li>-R 　显示套件的关联性信息。 </li><li>-s 　显示文件状态，本参数需配合”-l”参数使用。 </li><li>-U&lt;套件档&gt;或–upgrade&lt;套件档&gt;   升级指定的套件档。 </li><li>-v 　显示指令执行过程。</li><li>-vv 　详细显示指令执行过程，便于排错。 </li><li>-addsign&lt;套件档&gt;+ 　在指定的套件里加上新的签名认证。 </li><li>–allfiles 　安装所有文件。 </li><li>–allmatches 　删除符合指定的套件所包含的文件。 </li><li>–badreloc 　发生错误时，重新配置文件。 </li><li>–buildroot&lt;根目录&gt; 　设置产生套件时，欲当作根目录的目录。 </li><li>–changelog 　显示套件的更改记录。 </li><li>–checksig&lt;套件档&gt;+ 　检验该套件的签名认证。 </li><li>–clean 　完成套件的包装后，删除包装过程中所建立的目录。 </li><li>–dbpath&lt;数据库目录&gt; 　设置欲存放RPM数据库的目录。 </li><li>–dump 　显示每个文件的验证信息。本参数需配合”-l”参数使用。 </li><li>–excludedocs 　安装套件时，不要安装文件。 </li><li>–excludepath&lt;排除目录&gt; 　忽略在指定目录里的所有文件。 </li><li>–force 　强行置换套件或文件。 </li><li>–ftpproxy&lt;主机名称或IP地址&gt; 　指定FTP代理服务器。 </li><li>–ftpport&lt;通信端口&gt; 　设置FTP服务器或代理服务器使用的通信端口。 </li><li>–help 　在线帮助。 </li><li>–httpproxy&lt;主机名称或IP地址&gt; 　指定HTTP代理服务器。 </li><li>–httpport&lt;通信端口&gt; 　设置HTTP服务器或代理服务器使用的通信端口。 </li><li>–ignorearch 　不验证套件档的结构正确性。 </li><li>–ignoreos 　不验证套件档的结构正确性。 </li><li>–ignoresize 　安装前不检查磁盘空间是否足够。 </li><li>–includedocs 　安装套件时，一并安装文件。 </li><li>–initdb 　确认有正确的数据库可以使用。 </li><li>–justdb 　更新数据库，当不变动任何文件。 </li><li>–nobulid 　不执行任何完成阶段。 </li><li>–nodeps 　不验证套件档的相互关联性。 </li><li>–nofiles 　不验证文件的属性。 </li><li>–nogpg 　略过所有GPG的签名认证。 </li><li>–nomd5 　不使用MD5编码演算确认文件的大小与正确性。 </li><li>–nopgp 　略过所有PGP的签名认证。 </li><li>–noorder 　不重新编排套件的安装顺序，以便满足其彼此间的关联性。 </li><li>–noscripts 　不执行任何安装Script文件。 </li><li>–notriggers 　不执行该套件包装内的任何Script文件。 </li><li>–oldpackage 　升级成旧版本的套件。 </li><li>–percent 　安装套件时显示完成度百分比。 </li><li>–pipe&lt;执行指令&gt; 　建立管道，把输出结果转为该执行指令的输入数据。 </li><li>–prefix&lt;目的目录&gt; 　若重新配置文件，就把文件放到指定的目录下。 </li><li>–provides 　查询该套件所提供的兼容度。 </li><li>–queryformat&lt;档头格式&gt; 　设置档头的表示方式。 </li><li>–querytags 　列出可用于档头格式的标签。 </li><li>–rcfile&lt;配置文件&gt; 　使用指定的配置文件。 </li><li>–rebulid&lt;套件档&gt; 　安装原始代码套件，重新产生二进制文件的套件。 </li><li>–rebuliddb 　以现有的数据库为主，重建一份数据库。 </li><li>–recompile&lt;套件档&gt; 　此参数的效果和指定”–rebulid”参数类似，当不产生套件档。 </li><li>–relocate&lt;原目录&gt;=&lt;新目录&gt; 　把本来会放到原目录下的文件改放到新目录。 </li><li>–replacefiles 　强行置换文件。 </li><li>–replacepkgs 　强行置换套件。 </li><li>–requires 　查询该套件所需要的兼容度。 </li><li>–resing&lt;套件档&gt;+ 　删除现有认证，重新产生签名认证。 </li><li>–rmsource 　完成套件的包装后，删除原始代码。 </li><li>–rmsource&lt;文件&gt; 　删除原始代码和指定的文件。 </li><li>–root&lt;根目录&gt; 　设置欲当作根目录的目录。 </li><li>–scripts 　列出安装套件的Script的变量。 </li><li>–setperms 　设置文件的权限。 </li><li>–setugids 　设置文件的拥有者和所属群组。 </li><li>–short-circuit 　直接略过指定完成阶段的步骤。</li><li>–sign 　产生PGP或GPG的签名认证。 </li><li>–target=&lt;安装平台&gt;+ 　设置产生的套件的安装平台。 </li><li>–test 　仅作测试，并不真的安装套件。 </li><li>–timecheck&lt;检查秒数&gt; 　设置检查时间的计时秒数。 </li><li>–triggeredby&lt;套件档&gt; 　查询该套件的包装者。 </li><li>–triggers 　展示套件档内的包装Script。 </li><li>–verify 　此参数的效果和指定”-q”参数相同。 </li><li>–version 　显示版本信息。 </li><li>–whatprovides&lt;功能特性&gt; 　查询该套件对指定的功能特性所提供的兼容度。 </li><li>–whatrequires&lt;功能特性&gt; 　查询该套件对指定的功能特性所需要的兼容度。</li></ul><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>功能说明：设置shell。</p><p>语　　法：<code>set [+-abCdefhHklmnpPtuvx]</code></p><p>补充说明：set指令能设置所使用shell的执行方式，可依照不同的需求来做设置。</p><p>参　　数：</p><ul><li>-a 　标示已修改的变量，以供输出至环境变量。 </li><li>-b 　使被中止的后台程序立刻回报执行状态。 </li><li>-C 　转向所产生的文件无法覆盖已存在的文件。 </li><li>-d 　Shell预设会用杂凑表记忆使用过的指令，以加速指令的执行。使用-d参数可取消。 </li><li>-e 　若指令传回值不等于0，则立即退出shell。　　 </li><li>-f　 　取消使用通配符。 </li><li>-h 　自动记录函数的所在位置。 </li><li>-H Shell 　可利用”!”加&lt;指令编号&gt;的方式来执行history中记录的指令。 </li><li>-k 　指令所给的参数都会被视为此指令的环境变量。 </li><li>-l 　记录for循环的变量名称。 </li><li>-m 　使用监视模式。 </li><li>-n 　只读取指令，而不实际执行。 </li><li>-p 　启动优先顺序模式。 </li><li>-P 　启动-P参数后，执行指令时，会以实际的文件或目录来取代符号连接。 </li><li>-t 　执行完随后的指令，即退出shell。 </li><li>-u 　当执行时使用到未定义过的变量，则显示错误信息。 </li><li>-v 　显示shell所读取的输入值。 </li><li>-x 　执行指令后，会先显示该指令及所下的参数。 </li><li>+&lt;参数&gt; 　取消某个set曾启动的参数。</li></ul><h3 id="setconsole"><a href="#setconsole" class="headerlink" title="setconsole"></a>setconsole</h3><p>功能说明：设置系统终端。</p><p>语　　法：<code>setconsole [video][serial][ttya][ttyb]</code></p><p>补充说明：setconsole可用来指定系统终端。</p><p>参　　数：</p><ul><li>serial 　使用PROM终端。 </li><li>ttya,cua0或ttyS0 　使用第１个串口设备作为终端。 </li><li>ttyb,cua1或ttyS1 　使用第２个串口设备作为终端。 </li><li>video 　使用主机上的现卡作为终端。</li></ul><h3 id="setenv-set-environment-variable"><a href="#setenv-set-environment-variable" class="headerlink" title="setenv(set environment variable)"></a>setenv(set environment variable)</h3><p>功能说明：查询或显示环境变量。</p><p>语　　法：<code>setenv [变量名称][变量值]</code></p><p>补充说明：setenv为tsch中查询或设置环境变量的指令</p><h3 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h3><p>功能说明：设置公用程序。</p><p>语　　法：<code>setup</code></p><p>补充说明：setup是一个设置公用程序，提供图形界面的操作方式。在setup中可设置7类的选项：</p><pre><code>１.登陆认证方式 ２.键盘组态设置 ３.鼠标组态设置 ４.开机时所要启动的系统服务 ５.声卡组态设置 ６.时区设置 ７.X Windows组态设置</code></pre><h3 id="sndconfig"><a href="#sndconfig" class="headerlink" title="sndconfig"></a>sndconfig</h3><p>功能说明：设置声卡。</p><p>语　　法：<code>sndconfig [–help][–noautoconfig][–noprobe]</code></p><p>补充说明：sndconfig为声卡设置程序，支持PnP柚茫勺远觳獠⑸柚肞nP声卡。</p><p>参 　 数：</p><ul><li>–help 　显示帮助。 </li><li>–noautoconfig 　不自动设置PnP的声卡。 </li><li>–noprobe 　不自动检测PnP声卡。</li></ul><h3 id="SVGAText-Mode"><a href="#SVGAText-Mode" class="headerlink" title="SVGAText Mode"></a>SVGAText Mode</h3><p>功能说明：加强文字模式的显示画面。</p><p>语　　法：<code>SVGATextMode [-acdfhmnrsv][-t &lt;配置文件&gt;][模式]</code></p><p>补充说明：SVGATextMode可用来设置文字模式下的显示画面，包括分辨率，字体和更新频率等。</p><p>参　　数：</p><ul><li>-a 　如果新显示模式的屏幕大小与原先不同时，SVGATextMode会执行必要的系统设置。 </li><li>-c 　维持原有的VGA时脉。 </li><li>-d 　执行时会显示详细的信息，供排错时参考。 </li><li>-f 　不要执行配置文件中有关字体载入的指令。 </li><li>-h 　显示帮助。 </li><li>-m 　允许1x1的方式来重设屏幕大小。 </li><li>-n 　仅测试指定的模式。 </li><li>-r 　通知或重设与屏幕大小相关的程序。 </li><li>-s 　显示配置文件中所有可用的模式。 </li><li>-t&lt;配置文件&gt; 　指定配置文件。 </li><li>-v 　SVGATextMode在配置新的显示模式时，预设会先检查垂直与水平的更新更新频率是否在配置文件所指定的范围内，如果不在范围内，则不设置新的显示模式。 </li><li>[模式］ [模式]参数必须是配置文件中模式的名称。</li></ul><h3 id="timeconfig"><a href="#timeconfig" class="headerlink" title="timeconfig"></a>timeconfig</h3><p>功能说明：设置时区。</p><p>语　　法：<code>timeconfig [–arc][–back][–test][–utc][时区名称]</code></p><p>补充说明：这是Red Hat公司遵循GPL规则所开发的程序，它具有互动式操作界面，您可以轻易地利用方向键和空格键等，设置系统时间所属的时区。</p><p>参　　数：</p><ul><li>–arc 　使用Alpha硬件结构的格式存储系统时间。 </li><li>–back 　在互动式界面里，显示Back钮而非Cancel钮。 </li><li>–test 　仅作测试，并不真的改变系统的时区。 </li><li>–utc 　把硬件时钟上的时间视为CUT，有时也称为UTC或UCT。</li></ul><h3 id="ulimit"><a href="#ulimit" class="headerlink" title="ulimit"></a><font color="red">ulimit</font></h3><p>功能说明：控制shell程序的资源。</p><p>语　　法：<code>ulimit [-aHS][-c &lt;core文件上限&gt;][-d &lt;数据节区大小&gt;][-f &lt;文件大小&gt;][-m &lt;内存大小&gt;][-n &lt;文件数目&gt;][-p &lt;缓冲区大小&gt;][-s &lt;堆叠大小&gt;][-t &lt;CPU时间&gt;][-u &lt;程序数目&gt;][-v &lt;虚拟内存大小&gt;]</code></p><p>补充说明：ulimit为shell内建指令，可用来控制shell执行程序的资源。</p><p>参　　数：</p><ul><li>-a 　显示目前资源限制的设定。 </li><li>-c &lt;core文件上限&gt; 　设定core文件的最大值，单位为区块。 </li><li>-d &lt;数据节区大小&gt; 　程序数据节区的最大值，单位为KB。 </li><li>-f &lt;文件大小&gt; 　shell所能建立的最大文件，单位为区块。 </li><li>-H 　设定资源的硬性限制，也就是管理员所设下的限制。 </li><li>-m &lt;内存大小&gt; 　指定可使用内存的上限，单位为KB。 </li><li>-n &lt;文件数目&gt; 　指定同一时间最多可开启的文件数。 </li><li>-p &lt;缓冲区大小&gt; 　指定管道缓冲区的大小，单位512字节。 </li><li>-s &lt;堆叠大小&gt; 　指定堆叠的上限，单位为KB。 </li><li>-S 　设定资源的弹性限制。 </li><li>-t &lt;CPU时间&gt; 　指定CPU使用时间的上限，单位为秒。 </li><li>-u &lt;程序数目&gt; 　用户最多可开启的程序数目。 </li><li>-v &lt;虚拟内存大小&gt; 　指定可使用的虚拟内存上限，单位为KB。</li></ul><h3 id="unalias"><a href="#unalias" class="headerlink" title="unalias"></a>unalias</h3><p>功能说明：删除别名。</p><p>语　　法：<code>unalias [-a][别名]</code></p><p>补充说明：unalias为shell内建指令，可删除别名设置。</p><p>参　　数：</p><ul><li>-a 　删除全部的别名。</li></ul><h3 id="unset"><a href="#unset" class="headerlink" title="unset"></a>unset</h3><p>功能说明：删除变量或函数。</p><p>语　　法：<code>unset [-fv][变量或函数名称]</code></p><p>补充说明：unset为shell内建指令，可删除变量或函数。</p><p>参 　 数：</p><ul><li>-f 　仅删除函数。 </li><li>-v 　仅删除变量。</li></ul><h2 id="linux文档编辑命令"><a href="#linux文档编辑命令" class="headerlink" title="linux文档编辑命令"></a>linux文档编辑命令</h2><h3 id="col"><a href="#col" class="headerlink" title="col"></a>col</h3><p>功能说明：过滤控制字符。</p><p>语　　法：<code>col [-bfx][-l&lt;缓冲区列数&gt;]</code></p><p>补充说明：在许多UNIX说明文件里，都有RLF控制字符。当我们运用shell特殊字符”&gt;”和”&gt;&gt;”，把说明文件的内容输出成纯文本文件时，控制字符会变成乱码，col指令则能有效滤除这些控制字符。</p><p>参　　数：</p><ul><li>-b   过滤掉所有的控制字符，包括RLF和HRLF。</li><li>-f   滤除RLF字符，但允许将HRLF字符呈现出来。</li><li>-x   以多个空格字符来表示跳格字符。</li><li>-l&lt;缓冲区列数&gt;   预设的内存缓冲区有128列，您可以自行指定缓冲区的大小。</li></ul><h3 id="colrm-column-remove"><a href="#colrm-column-remove" class="headerlink" title="colrm(column remove)"></a>colrm(column remove)</h3><p>功能说明：滤掉指定的行。</p><p>语　　法：<code>colrm [开始行数编号&lt;结束行数编号&gt;]</code></p><p>补充说明：colrm指令从标准输入设备读取书记，转而输出到标准输出设备。如果不加任何参数，则该指令不会过滤任何一行。</p><h3 id="comm-common"><a href="#comm-common" class="headerlink" title="comm(common)"></a>comm(common)</h3><p>功能说明：比较两个已排过序的文件。</p><p>语　　法：<code>comm [-123][–help][–version][第1个文件][第2个文件]</code></p><p>补充说明：这项指令会一列列地比较两个已排序文件的差异，并将其结果显示出来，如果没有指定任何参数，则会把结果分成3行显示：第1行仅是在第1个文件中出现过的列，第2行是仅在第2个文件中出现过的列，第3行则是在第1与第2个文件里都出现过的列。若给予的文件名称为”-“，则comm指令会从标准输入设备读取数据。</p><p>参　　数：</p><ul><li>-1   不显示只在第1个文件里出现过的列。</li><li>-2   不显示只在第2个文件里出现过的列。</li><li>-3   不显示只在第1和第2个文件里出现过的列。</li><li>–help   在线帮助。</li><li>–version   显示版本信息。</li></ul><h3 id="csplit-context-split"><a href="#csplit-context-split" class="headerlink" title="csplit(context split)"></a>csplit(context split)</h3><p>功能说明：分割文件。</p><p>语　　法：<code>csplit [-kqsz][-b&lt;输出格式&gt;][-f&lt;输出字首字符串&gt;][-n&lt;输出文件名位数&gt;][–help][–version][文件][范本样式…]</code></p><p>补充说明：将文件依照指定的范本样式予以切割后，分别保存成名称为xx00,xx01,xx02…的文件。若给予的文件名称为”-“，则csplit指令会从标准输入设备读取数据。</p><p>参　　数：</p><ul><li>-b&lt;输出格式&gt;或–suffix-format=&lt;输出格式&gt;   预设的输出格式其文件名称为xx00,xx01…等，您可以通过改变&lt;输出格式&gt;来改变输出的文件名。</li><li>-f&lt;输出字首字符串&gt;或–prefix=&lt;输出字首字符串&gt;   预设的输出字首字符串其文件名为xx00,xx01…等，如果你指定输出字首字符串为”hello”，则输出的文件名称会变成hello00,hello01…等。</li><li>-k或–keep-files   保留文件，就算发生错误或中断执行，也不能删除已经输出保存的文件。</li><li>-n&lt;输出文件名位数&gt;或–digits=&lt;输出文件名位数&gt;   预设的输出文件名位数其文件名称为xx00,xx01…等，如果你指定输出文件名位数为”3”，则输出的文件名称会变成xx000,xx001…等。</li><li>-q或-s或–quiet或–silent   不显示指令执行过程。</li><li>-z或–elide-empty-files   删除长度为0 Byte文件。</li><li>–help   在线帮助。</li><li>–version   显示版本信息。</li></ul><h3 id="ed-editor"><a href="#ed-editor" class="headerlink" title="ed(editor)"></a>ed(editor)</h3><p>功能说明：文本编辑器。</p><p>语　　法：<code>ed [-][-Gs][-p&lt;字符串&gt;][–help][–version][文件]</code></p><p>补充说明：ed是Linux中功能最简单的文本编辑程序，一次仅能编辑一行而非全屏幕方式的操作。</p><p>参　　数：</p><ul><li>-G或–traditional   提供回兼容的功能。</li><li>-p&lt;字符串&gt;   指定ed在command mode的提示字符。</li><li>-s,-,–quiet或–silent   不执行开启文件时的检查功能。</li><li>–help   显示帮助。</li><li>–version   显示版本信息。</li></ul><h3 id="egrep"><a href="#egrep" class="headerlink" title="egrep"></a>egrep</h3><p>功能说明：在文件内查找指定的字符串。egrep执行效果如grep -E，使用的语法及参数可参照grep指令，与grep不同点在于解读字符串的方法，egrep是用extended regular expression语法来解读，而grep则用basic regular expression语法，extended regular expression比basic regular expression有更完整的表达规范。</p><h3 id="ex"><a href="#ex" class="headerlink" title="ex"></a>ex</h3><p>功能说明：在Ex模式下启动vim文本编辑器。ex执行效果如同vi -E，使用语法及参数可参照vi指令，如要从Ex模式回到普通模式，则在vim中输入:vi或:visual即可。</p><h3 id="fgrep-fixed-regexp"><a href="#fgrep-fixed-regexp" class="headerlink" title="fgrep(fixed regexp)"></a>fgrep(fixed regexp)</h3><p>功能说明：查找文件里符合条件的字符串。</p><p>语　　法：<code>fgrep [范本样式][文件或目录…]</code></p><p>补充说明：本指令相当于执行grep指令加上参数”-F”，详见grep指令说明。</p><h3 id="fmt-fromat"><a href="#fmt-fromat" class="headerlink" title="fmt(fromat)"></a>fmt(fromat)</h3><p>功能说明：编排文本文件。</p><p>语　　法：<code>fmt [-cstu][-p&lt;列起始字符串&gt;][-w&lt;每列字符数&gt;][–help][–version][文件…]</code></p><p>补充说明：fmt指令会从指定的文件里读取内容，将其依照指定格式重新编排后，输出到标准输出设备。若指定的文件名为”-“，则fmt指令会从标准输入设备读取数据。</p><p>参　　数：</p><ul><li>-c或–crown-margin   每段前两列缩排。</li><li>-p&lt;列起始字符串&gt;或-prefix=&lt;列起始字符串&gt;   仅合并含有指定字符串的列，通常运用在程序语言的注解方面。</li><li>-s或–split-only   只拆开字数超出每列字符数的列，但不合并字数不足每列字符数的列。</li><li>-t或–tagged-paragraph   每列前两列缩排，但第1列和第2列的缩排格式不同。</li><li>-u或–uniform-spacing   每个字符之间都以一个空格字符间隔，每个句子之间则两个空格字符分隔。</li><li>-w&lt;每列字符数&gt;或–width=&lt;每列字符数&gt;或-&lt;每列字符数&gt;   设置每列的最大字符数。</li><li>–help   在线帮助。</li><li>–version   显示版本信息。</li></ul><h3 id="fold"><a href="#fold" class="headerlink" title="fold"></a>fold</h3><p>功能说明：限制文件列宽。</p><p>语　　法：<code>fold [-bs][-w&lt;每列行数&gt;][–help][–version][文件…]</code></p><p>补充说明：fold指令会从指定的文件里读取内容，将超过限定列宽的列加入增列字符后，输出到标准输出设备。若不指定任何文件名称，或是所给予的文件名为“-”，则fold指令会从标准输入设备读取数据。</p><p>参　　数：</p><ul><li>-b或–bytes   以Byte为单位计算列宽，而非采用行数编号为单位。</li><li>-s或–spaces   以空格字符作为换列点。</li><li>-w&lt;每列行数&gt;或–width&lt;每列行数&gt;   设置每列的最大行数。</li><li>–help   在线帮助。</li><li>–version   显示版本信息。</li></ul><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a><font color="red">grep</font></h3><p>功能说明：查找文件里符合条件的字符串。</p><p>语　　法：<code>grep [-abcEFGhHilLnqrsvVwxy][-A&lt;显示列数&gt;][-B&lt;显示列数&gt;][-C&lt;显示列数&gt;][-d&lt;进行动作&gt;][-e&lt;范本样式&gt;][-f&lt;范本文件&gt;][–help][范本样式][文件或目录…]</code></p><p>补充说明：grep指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设grep指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为“-”，则grep指令会从标准输入设备读取数据。</p><p>参　　数：</p><ul><li>-a或–text   不要忽略二进制的数据。</li><li>-A&lt;显示列数&gt;或–after-context=&lt;显示列数&gt;   除了显示符合范本样式的那一列之外，并显示该列之后的内容。</li><li>-b或–byte-offset   在显示符合范本样式的那一列之前，标示出该列第一个字符的位编号。</li><li>-B&lt;显示列数&gt;或–before-context=&lt;显示列数&gt;   除了显示符合范本样式的那一列之外，并显示该列之前的内容。</li><li>-c或–count   计算符合范本样式的列数。</li><li>-C&lt;显示列数&gt;或–context=&lt;显示列数&gt;或-&lt;显示列数&gt;   除了显示符合范本样式的那一列之外，并显示该列之前后的内容。</li><li>-d&lt;进行动作&gt;或–directories=&lt;进行动作&gt;   当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。</li><li>-e&lt;范本样式&gt;或–regexp=&lt;范本样式&gt;   指定字符串做为查找文件内容的范本样式。</li><li>-E或–extended-regexp   将范本样式为延伸的普通表示法来使用。</li><li>-f&lt;范本文件&gt;或–file=&lt;范本文件&gt;   指定范本文件，其内容含有一个或多个范本样式，让grep查找符合范本条件的文件内容，格式为每列一个范本样式。</li><li>-F或–fixed-regexp   将范本样式视为固定字符串的列表。</li><li>-G或–basic-regexp   将范本样式视为普通的表示法来使用。</li><li>-h或–no-filename   在显示符合范本样式的那一列之前，不标示该列所属的文件名称。</li><li>-H或–with-filename   在显示符合范本样式的那一列之前，表示该列所属的文件名称。</li><li>-i或–ignore-case   忽略字符大小写的差别。</li><li>-l或–file-with-matches   列出文件内容符合指定的范本样式的文件名称。</li><li>-L或–files-without-match   列出文件内容不符合指定的范本样式的文件名称。</li><li>-n或–line-number   在显示符合范本样式的那一列之前，标示出该列的列数编号。</li><li>-q或–quiet或–silent   不显示任何信息。</li><li>-r或–recursive   此参数的效果和指定“-d recurse”参数相同。</li><li>-s或–no-messages   不显示错误信息。</li><li>-v或–revert-match   反转查找。</li><li>-V或–version   显示版本信息。</li><li>-w或–word-regexp   只显示全字符合的列。</li><li>-x或–line-regexp   只显示全列符合的列。</li><li>-y   此参数的效果和指定“-i”参数相同。</li><li>–help   在线帮助。</li></ul><h3 id="ispell-interactive-spelling-checking"><a href="#ispell-interactive-spelling-checking" class="headerlink" title="ispell(interactive spelling checking)"></a>ispell(interactive spelling checking)</h3><p>功能说明：拼字检查程序。</p><p>语　　法：<code>ispell [-aAbBClmMnNPStVx][-d&lt;字典文件&gt;][-L&lt;行数&gt;][-p&lt;字典文件&gt;][-w&lt;非字母字符&gt;][-W&lt;字符串长度&gt;][要检查的文件]</code></p><p>补充说明：ispell预设会使用/usr/lib/ispell/english.hash字典文件来检查文本文件。若在检查的文件中找到字典没有的词汇，ispell会建议使用的词汇，或是让你将新的词汇加入个人字典。</p><p>参　　数：</p><ul><li>-a   当其他程序输出送到ispell时，必须使用此参数。</li><li>-A   读取到”&amp;Include File&amp;”字符串时，就去检查字符串后所指定文件的内容。</li><li>-b   产生备份文件，文件名为.bak。</li><li>-B   检查连字错误。</li><li>-C   不检查连字错误。</li><li>-d&lt;字典文件&gt;   指定字典文件。</li><li>-l   从标准输入设备读取字符串，结束后显示拼错的词汇。</li><li>-L&lt;行数&gt;   指定内文显示的行数。</li><li>-m   自动考虑字尾的变化。</li><li>-M   进入ispell后，在画面下方显示指令的按键。</li><li>-n   检查的文件为noff或troff的格式。</li><li>-N   进入ispell后，在画面下方不显示指令的按键。</li><li>-p&lt;字典文件&gt;   指定个人字典文件。</li><li>-P   不考虑字尾变化的情形。</li><li>-S   不排序建议取代的词汇。</li><li>-t   检查的文件为TeX或LaTeX的格式。</li><li>-V   非ANSI标准的字符会以”M-^”的方式来显示。</li><li>-w&lt;非字母字符&gt;   检查时，特别挑出含有指定的字符。</li><li>-W&lt;字符串长度&gt;   不检查指定长度的词汇。</li><li>-x   不要产生备份文件。</li></ul><h3 id="jed"><a href="#jed" class="headerlink" title="jed"></a>jed</h3><p>功能说明：编辑文本文件。</p><p>语　　法：<code>jed [-2n][-batch][-f&lt;函数&gt;][-g&lt;行数&gt;][-i&lt;文件&gt;][-I&lt;文件&gt;][-s&lt;字符串&gt;][文件]</code></p><p>补充说明：Jed是以Slang所写成的程序，适合用来编辑程序原始代码。</p><p>参　　数：</p><ul><li>-2   显示上下两个编辑区。</li><li>-batch   以批处理模式来执行。</li><li>-f&lt;函数&gt;   执行Slang函数。</li><li>-g&lt;行数&gt;   移到缓冲区中指定的行数。</li><li>-i&lt;文件&gt;   将指定的文件载入缓冲区。</li><li>-i&lt;文件&gt;   载入Slang原始代码文件。</li><li>-n   不要载入jed.rc配置文件。</li><li>-s&lt;字符串&gt;   查找并移到指定的字符串。</li></ul><h3 id="joe"><a href="#joe" class="headerlink" title="joe"></a>joe</h3><p>功能说明：编辑文本文件。</p><p>语　　法：<br><code>joe [-asis][-beep][-csmode][-dopadding][-exask][-force][-help][-keepup][-lightoff][-arking][-mid][-nobackups][-nonotice][-nosta][-noxon][-orphan][-backpath&lt;目录&gt;][-columns&lt;栏位&gt;][-lines&lt;行数&gt;][-pg&lt;行数&gt;][-skiptop&lt;行数&gt;][-autoindent crlf linums overwrite rdonly wordwrap][+&lt;行数&gt;][-indentc&lt;缩排字符&gt;][-istep&lt;缩排字符数&gt;][-keymap&lt;按键配置文件&gt;][-lmargin&lt;栏数&gt;][-rmargin&lt;栏数&gt;][-tab&lt;栏数&gt;][要编辑的文件]</code></p><p>补充说明：Joe是一个功能强大的全屏幕文本编辑程序。操作的复杂度要比Pico高一点，但是功能较为齐全。Joe一次可开启多个文件，每个文件各放在一个编辑区内，并可在文件之间执行剪贴的动作。</p><p>参　　数：</p><p>以下为程序参数</p><ul><li>-asis   字符码超过127的字符不做任何处理。</li><li>-backpath&lt;目录&gt;   指定备份文件的目录。</li><li>-beep   编辑时，若有错误即发出哗声。</li><li>-columns&lt;栏位&gt;   设置栏数。</li><li>-csmode   可执行连续查找模式。</li><li>-dopadding   是程序跟tty间存在缓冲区。</li><li>-exask   在程序中，执行”Ctrl+k+x”时，会先确认是否要保存文件。</li><li>-force   强制在最后一行的结尾处加上换行符号。</li><li>-help   执行程序时一并显示帮助。</li><li>-keepup   在进入程序后，画面上方为状态列。</li><li>-lightoff   选取的区块在执行完区块命令后，就会回复成原来的状态。</li><li>-lines&lt;行数&gt;   设置行数。</li><li>-marking   在选取区块时，反白区块会随着光标移动。</li><li>-mid   当光标移出画面时，即自动卷页，使光标回到中央。</li><li>-nobackups   不建立备份文件。</li><li>-nonotice   程序执行时，不显示版权信息。</li><li>-nosta   程序执行时，不显示状态列。</li><li>-noxon   尝试取消“Ctrl+s”与“Ctrl+q”键的功能。</li><li>-orphan   若同时开启一个以上的文件，则其他文件会置于独立的缓冲区，而不会另外开启编辑区。</li><li>-pg&lt;行数&gt;   按“PageUp”或“PageDown”换页时，所要保留前一页的行数。</li><li>-skiptop&lt;行数&gt;   不使用屏幕上方指定的行数。</li></ul><p>以下为文件参数</p><ul><li>+&lt;行数&gt;   指定开启文件时，光标所在的行数。</li><li>-autoindent   自动缩排。</li><li>-crlf   在换行时，使用CR-LF字符。</li><li>-indentc&lt;缩排字符&gt;   执行缩排时，实际插入的字符。</li><li>-istep&lt;缩排字符数&gt;   每次执行缩排时，所移动的缩排字符数。</li><li>-keymap&lt;按键配置文件&gt;   使用不同的按键配置文件。</li><li>-linums   在每行前面加上行号。</li><li>-lmargin&lt;栏数&gt;   设置左侧边界。</li><li>-overwrite   设置覆盖模式。</li><li>-rmargin&lt;栏数&gt;   设置右侧边界。</li><li>-tab&lt;栏数&gt;   设置tab的宽度。</li><li>-rdonly   以只读的方式开启文件-wordwrap编辑时若超过右侧边界，则自动换行。</li></ul><h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>功能说明：将两个文件中，指定栏位内容相同的行连接起来。</p><p>语　　法：<code>join [-i][-a&lt;1或2&gt;][-e&lt;字符串&gt;][-o&lt;格式&gt;][-t&lt;字符&gt;][-v&lt;1或2&gt;][-1&lt;栏位&gt;][-2&lt;栏位&gt;][–help][–version][文件1][文件2]</code></p><p>补充说明：找出两个文件中，指定栏位内容相同的行，并加以合并，再输出到标准输出设备。</p><p>参　　数：</p><ul><li>-a&lt;1或2&gt;   除了显示原来的输出内容之外，还显示指令文件中没有相同栏位的行。</li><li>-e&lt;字符串&gt;   若[文件1]与[文件2]中找不到指定的栏位，则在输出中填入选项中的字符串。</li><li>-i或–igore-case   比较栏位内容时，忽略大小写的差异。</li><li>-o&lt;格式&gt;   按照指定的格式来显示结果。</li><li>-t&lt;字符&gt;   使用栏位的分隔字符。</li><li>-v&lt;1或2&gt;   跟-a相同，但是只显示文件中没有相同栏位的行。</li><li>-1&lt;栏位&gt;   连接[文件1]指定的栏位。</li><li>-2&lt;栏位&gt;   连接[文件2]指定的栏位。</li><li>–help   显示帮助。</li><li>–version   显示版本信息。</li></ul><h3 id="look"><a href="#look" class="headerlink" title="look"></a>look</h3><p>功能说明：查询单字。</p><p>语　　法：<code>look [-adf][-t&lt;字尾字符串&gt;][字首字符串][字典文件]</code></p><p>补充说明：look指令用于英文单字的查询。您仅需给予它欲查询的字首字符串，它会显示所有开头字符串符合该条件的单字。</p><p>参　　数：</p><ul><li>-a   使用另一个字典文件web2，该文件也位于/usr/dict目录下。</li><li>-d   只对比英文字母和数字，其余一慨忽略不予比对。</li><li>-f   忽略字符大小写差别。</li><li>-t&lt;字尾字符串&gt;   设置字尾字符串。</li></ul><h3 id="mtype"><a href="#mtype" class="headerlink" title="mtype"></a>mtype</h3><p>功能说明：显示MS-DOS文件的内容。</p><p>语　　法：<code>mtype [-st][文件]</code></p><p>补充说明：mtype为mtools工具指令，模拟MS-DOS的type指令，可显示MS-DOS文件的内容。</p><p>参　　数：</p><ul><li>-s   去除8位字符码集的第一个位，使它兼容于7位的ASCII。</li><li>-t   将MS-DOS文本文件中的“换行+光标移至行首”字符转换成Linux的换行字符。</li></ul><h3 id="pico"><a href="#pico" class="headerlink" title="pico"></a>pico</h3><p>功能说明：编辑文字文件。</p><p>语　　法：<code>pico [-bdefghjkmqtvwxz][-n&lt;间隔秒数&gt;][-o&lt;工作目录&gt;][-r&lt;编辑页宽&gt;][-s&lt;拼字检查器&gt;][+&lt;列数编号&gt;][文件]</code></p><p>补充说明：pico是个简单易用、以显示导向为主的文字编辑程序，它伴随着处理电子邮件和新闻组的程序pine而来。</p><p>参　　数：</p><ul><li>-b   开启置换的功能。</li><li>-d   开启删除的功能。</li><li>-e   使用完整的文件名称。</li><li>-f   支持键盘上的F1、F2…等功能键。</li><li>-g   显示光标。</li><li>-h   在线帮助。</li><li>-j   开启切换的功能。</li><li>-k   预设pico在使用剪下命令时，会把光标所在的列的内容全部删除。</li><li>-m   开启鼠标支持的功能，您可用鼠标点选命令列表。</li><li>-n&lt;间隔秒数&gt;   设置多久检查一次新邮件。</li><li>-o&lt;工作目录&gt;   设置工作目录。</li><li>-q   忽略预设值。</li><li>-r&lt;编辑页宽&gt;   设置编辑文件的页宽。</li><li>-s&lt;拼字检查器&gt;   另外指定拼字检查器。</li><li>-t   启动工具模式。</li><li>-v   启动阅读模式，用户只能观看，无法编辑文件的内容。</li><li>-w   关闭自动换行，通过这个参数可以编辑内容很长的列。</li><li>-x   关闭换面下方的命令列表。</li><li>-z   让pico可被Ctrl+z中断，暂存在后台作业里。</li><li>+&lt;列数编号&gt;   执行pico指令进入编辑模式时，从指定的列数开始编辑。</li></ul><h3 id="rgrep-recursive-grep"><a href="#rgrep-recursive-grep" class="headerlink" title="rgrep(recursive grep)"></a>rgrep(recursive grep)</h3><p>功能说明：递归查找文件里符合条件的字符串。</p><p>语　　法：<code>rgrep [-?BcDFhHilnNrv][-R&lt;范本样式&gt;][-W&lt;列长度&gt;][-x&lt;扩展名&gt;][–help][–version][范本样式][文件或目录…]</code></p><p>补充说明：rgrep指令的功能和grep指令类似，可查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设rgrep指令会把含有范本样式的那一列显示出来。</p><p>参　　数：</p><ul><li>-?   显示范本样式与范例的说明。</li><li>-B   忽略二进制的数据。</li><li>-c   计算符合范本样式的列数。</li><li>-D   排错模式，只列出指令搜寻的目录清单，而不会读取文件内容。</li><li>-F   当遇到符号连接时，rgrep预设是忽略不予处理，加上本参数后，rgrep指令就会读取该连接所指向的原始文件的内容。</li><li>-h   特别将符合范本样式的字符串标示出来。</li><li>-H   只列出符合范本样式的字符串，而非显示整列的内容。</li><li>-i   忽略字符大小写的差别。</li><li>-l   列出文件内容符合指定的范本样式的文件名称。</li><li>-n   在显示符合坊本样式的那一列之前，标示出该列的列数编号。</li><li>-N   不要递归处理。</li><li>-r   递归处理，将指定目录下的所有文件及子目录一并处理。</li><li>-R&lt;范本样式&gt;   此参数的效果和指定“-r”参数类似，但只主力符合范本样式文件名称的文件。</li><li>-v   反转查找。</li><li>-W&lt;列长度&gt;   限制符合范本样式的字符串所在列，必须拥有的字符数。</li><li>-x&lt;扩展名&gt;   只处理符合指定扩展名的文件名称的文件。</li><li>–help   在线帮助。</li><li>–version   显示版本信息。</li></ul><h3 id="sed-stream-editor"><a href="#sed-stream-editor" class="headerlink" title="sed(stream editor)"></a>sed(stream editor)</h3><p>功能说明：利用script来处理文本文件。</p><p>语　　法：<code>sed [-hnV][-e &lt;script&gt;][-f&lt;script文件&gt;][文本文件]</code></p><p>补充说明：sed可依照script的指令，来处理、编辑文本文件。</p><p>参　　数：</p><ul><li>-e&lt;script&gt;或–expression=&lt;script&gt;   以选项中指定的script来处理输入的文本文件。</li><li>-f&lt;script文件&gt;或–file=&lt;script文件&gt;  以选项中指定的script文件来处理输入的文本文件。</li><li>-h或–help   显示帮助。</li><li>-n或–quiet或–silent   仅显示script处理后的结果。</li><li>-V或–version   显示版本信息。</li></ul><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>功能说明：将文本文件内容加以排序。</p><p>语　　法：<code>sort [-bcdfimMnr][-o&lt;输出文件&gt;][-t&lt;分隔字符&gt;][+&lt;起始栏位&gt;-&lt;结束栏位&gt;][–help][–verison][文件]</code></p><p>补充说明：sort可针对文本文件的内容，以行为单位来排序。</p><p>参　　数：</p><ul><li>-b   忽略每行前面开始出的空格字符。</li><li>-c   检查文件是否已经按照顺序排序。</li><li>-d   排序时，处理英文字母、数字及空格字符外，忽略其他的字符。</li><li>-f   排序时，将小写字母视为大写字母。</li><li>-i   排序时，除了040至176之间的ASCII字符外，忽略其他的字符。</li><li>-m   将几个排序好的文件进行合并。</li><li>-M   将前面3个字母依照月份的缩写进行排序。</li><li>-n   依照数值的大小排序。</li><li>-o&lt;输出文件&gt;   将排序后的结果存入指定的文件。</li><li>-r   以相反的顺序来排序。</li><li>-t&lt;分隔字符&gt;   指定排序时所用的栏位分隔字符。</li><li>+&lt;起始栏位&gt;-&lt;结束栏位&gt;   以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。</li><li>–help   显示帮助。</li><li>–version   显示版本信息。</li></ul><h3 id="spell"><a href="#spell" class="headerlink" title="spell"></a>spell</h3><p>功能说明：拼字检查程序。</p><p>语　　法：<code>spell</code></p><p>补充说明：spell可从标准输入设备读取字符串，结束后显示拼错的词汇。</p><h3 id="tr-translate-character"><a href="#tr-translate-character" class="headerlink" title="tr(translate character)"></a>tr(translate character)</h3><p>功能说明：转换字符。</p><p>语　　法：<code>tr [-cdst][–help][–version][第一字符集][第二字符集]</code></p><p>补充说明：tr指令从标准输入设备读取数据，经过字符串转译后，输出到标准输出设备。</p><p>参　　数：</p><ul><li>-c或–complerment   取代所有不属于第一字符集的字符。</li><li>-d或–delete   删除所有属于第一字符集的字符。</li><li>-s或–squeeze-repeats   把连续重复的字符以单独一个字符表示。</li><li>-t或–truncate-set1   先删除第一字符集较第二字符集多出的字符。</li><li>–help   在线帮助。</li><li>–version   显示版本信息。</li></ul><h3 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h3><p>功能说明：检查及删除文本文件中重复出现的行列。</p><p>语　　法：<code>uniq [-cdu][-f&lt;栏位&gt;][-s&lt;字符位置&gt;][-w&lt;字符位置&gt;][–help][–version][输入文件][输出文件]</code></p><p>补充说明：uniq可检查文本文件中重复出现的行列。</p><p>参　　数：</p><ul><li>-c或–count   在每列旁边显示该行重复出现的次数。</li><li>-d或–repeated   仅显示重复出现的行列。</li><li>-f&lt;栏位&gt;或–skip-fields=&lt;栏位&gt;   忽略比较指定的栏位。</li><li>-s&lt;字符位置&gt;或–skip-chars=&lt;字符位置&gt;   忽略比较指定的字符。</li><li>-u或–unique   仅显示出一次的行列。</li><li>-w&lt;字符位置&gt;或–check-chars=&lt;字符位置&gt;   指定要比较的字符。</li><li>–help   显示帮助。</li><li>–version   显示版本信息。</li></ul><p>PS:</p><pre><code>[输入文件]   指定已排序好的文本文件。[输出文件]   指定输出的文件。</code></pre><h3 id="wc-word-count"><a href="#wc-word-count" class="headerlink" title="wc(word count)"></a>wc(word count)</h3><p>功能说明：计算字数。</p><p>语　　法：<code>wc [-clw][–help][–version][文件…]</code></p><p>补充说明：利用wc指令我们可以计算文件的Byte数、字数、或是列数，若不指定文件名称、或是所给予的文件名为“-”，则wc指令会从标准输入设备读取数据。</p><p>参　　数：</p><ul><li>-c或–bytes或–chars   只显示Bytes数。</li><li>-l或–lines   只显示列数。</li><li>-w或–words   只显示字数。</li><li>–help   在线帮助。</li><li>–version   显示版本信息。</li></ul><h2 id="linux压缩备份命令"><a href="#linux压缩备份命令" class="headerlink" title="linux压缩备份命令"></a>linux压缩备份命令</h2><h3 id="ar"><a href="#ar" class="headerlink" title="ar"></a>ar</h3><p>功能说明：建立或修改备存文件，或是从备存文件中抽取文件。</p><p>语　　法：<code>ar[-dmpqrtx][cfosSuvV][a&lt;成员文件&gt;][b&lt;成员文件&gt;][i&lt;成员文件&gt;][备存文件][成员文件]</code></p><p>补充说明：ar可让您集合许多文件，成为单一的备存文件。在备存文件中，所有成员文件皆保有原来的属性与权限。</p><p>参　　数：</p><p>　指令参数 </p><ul><li>-d 　删除备存文件中的成员文件。 </li><li>-m 　变更成员文件在备存文件中的次序。 </li><li>-p 　显示备存文件中的成员文件内容。 </li><li>-q 　将问家附加在备存文件末端。 </li><li>-r 　将文件插入备存文件中。 </li><li>-t 　显示备存文件中所包含的文件。 </li><li>-x 　自备存文件中取出成员文件。</li></ul><p>　选项参数 </p><ul><li>a&lt;成员文件&gt; 　将文件插入备存文件中指定的成员文件之后。 </li><li>b&lt;成员文件&gt; 　将文件插入备存文件中指定的成员文件之前。 </li><li>c 　建立备存文件。 </li><li>f 　为避免过长的文件名不兼容于其他系统的ar指令指令，因此可利用此参数，截掉要放入备存文件中过长的成员文件名称。 </li><li>i&lt;成员文件&gt; 　将问家插入备存文件中指定的成员文件之前。 </li><li>o 　保留备存文件中文件的日期。 </li><li>s 　若备存文件中包含了对象模式，可利用此参数建立备存文件的符号表。 </li><li>S 　不产生符号表。 </li><li>u 　只将日期较新文件插入备存文件中。 </li><li>v 　程序执行时显示详细的信息。 </li><li>V 　显示版本信息。</li></ul><h3 id="bunzip2"><a href="#bunzip2" class="headerlink" title="bunzip2"></a>bunzip2</h3><p>功能说明：.bz2文件的解压缩程序。</p><p>语　　法：<code>bunzip2 [-fkLsvV][.bz2压缩文件]</code></p><p>补充说明：bunzip2可解压缩.bz2格式的压缩文件。bunzip2实际上是bzip2的符号连接，执行bunzip2与bzip2 -d的效果相同。</p><p>参　　数：</p><ul><li>-f或–force 　解压缩时，若输出的文件与现有文件同名时，预设不会覆盖现有的文件。若要覆盖，请使用此参数。 </li><li>-k或–keep 　在解压缩后，预设会删除原来的压缩文件。若要保留压缩文件，请使用此参数。 </li><li>-s或–small 　降低程序执行时，内存的使用量。 </li><li>-v或–verbose 　解压缩文件时，显示详细的信息。 </li><li>-l,–license,-V或–version 　显示版本信息。</li></ul><h3 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h3><p>功能说明：.bz2文件的压缩程序。</p><p>语　　法：<code>bzip2 [-cdfhkLstvVz][–repetitive-best][–repetitive-fast][- 压缩等级][要压缩的文件]</code></p><p>补充说明：bzip2采用新的压缩演算法，压缩效果比传统的LZ77/LZ78压缩演算法来得好。若没有加上任何参数，bzip2压缩完文件后会产生.bz2的压缩文件，并删除原始的文件。</p><p>参　　数：</p><ul><li>-c或–stdout 　将压缩与解压缩的结果送到标准输出。 </li><li>-d或–decompress 　执行解压缩。 </li><li>-f或–force 　bzip2在压缩或解压缩时，若输出文件与现有文件同名，预设不会覆盖现有文件。若要覆盖，请使用此参数。 </li><li>-h或–help 　显示帮助。 </li><li>-k或–keep 　bzip2在压缩或解压缩后，会删除原始的文件。若要保留原始文件，请使用此参数。 </li><li>-s或–small 　降低程序执行时内存的使用量。 </li><li>-t或–test 　测试.bz2压缩文件的完整性。 </li><li>-v或–verbose 　压缩或解压缩文件时，显示详细的信息。 </li><li>-z或–compress 　强制执行压缩。 </li><li>-L,–license,</li><li>-V或–version 　显示版本信息。 </li><li>–repetitive-best 　若文件中有重复出现的资料时，可利用此参数提高压缩效果。 </li><li>–repetitive-fast 　若文件中有重复出现的资料时，可利用此参数加快执行速度。 </li><li>-压缩等级 　压缩时的区块大小。</li></ul><h3 id="bzip2recover"><a href="#bzip2recover" class="headerlink" title="bzip2recover"></a>bzip2recover</h3><p>功能说明：用来修复损坏的.bz2文件。</p><p>语　　法：<code>bzip2recover [.bz2 压缩文件]</code></p><p>补充说明：bzip2是以区块的方式来压缩文件，每个区块视为独立的单位。因此，当某一区块损坏时，便可利用bzip2recover，试着将文件中的区块隔开来，以便解压缩正常的区块。通常只适用在压缩文件很大的情况。</p><h3 id="compress"><a href="#compress" class="headerlink" title="compress"></a>compress</h3><p>功能说明：压缩或解压文件。</p><p>语　　法：<code>compress [-cdfrvV][-b &lt;压缩效率&gt;][文件或目录…]</code></p><p>补充说明：compress是个历史悠久的压缩程序，文件经它压缩后，其名称后面会多出”.Z”的扩展名。当要解压缩时，可执行uncompress指令。事实上uncompress是指向compress的符号连接，因此不论是压缩或解压缩，都可通过compress指令单独完成。</p><p>参　　数：</p><ul><li>-b&lt;压缩效率&gt; 　压缩效率是一个介于9－16的数值，预设值为”16”，指定愈大的数值，压缩效率就愈高。 </li><li>-c 　把压缩后的文件输出到标准输出设备，不去更动原始文件。 </li><li>-d 　对文件进行解压缩而非压缩。 </li><li>-f 　强制保存压缩文件，不理会文件名称或硬连接是否存在，该文件是否为符号连接以及压缩效率高低的问题。 </li><li>-r 　递归处理，将指定目录下的所有文件及子目录一并处理。 </li><li>-v 　显示指令执行过程。 </li><li>-V 　显示指令版本及程序预设值。</li></ul><h3 id="cpio-copy-in-out"><a href="#cpio-copy-in-out" class="headerlink" title="cpio(copy in/out)"></a>cpio(copy in/out)</h3><p>功能说明：备份文件。</p><p>语　　法：<code>cpio [-0aABckLovV][-C &lt;输入/输出大小&gt;][-F &lt;备份档&gt;][-H &lt;备份格式&gt;][-O &lt;备份档&gt;][–block-size=&lt;区块大小&gt;][–force-local][–help][–quiet][–version] 或 cpio [-bBcdfikmnrsStuvV][-C &lt;输入/输出大小&gt;][-E &lt;范本文件&gt;][-F &lt;备份档&gt;][-H &lt;备份格式&gt;][-I &lt;备份档&gt;][-M &lt;回传信息&gt;][-R &lt;拥有者&gt;&lt;:/.&gt;&lt;所属群组&gt;][–block-size=&lt;区块大小&gt;][–force-local][–help][–no-absolute-filenames][–no-preserve-owner][–only-verify-crc][–quiet][–sparse][–version][范本样式…] 或 cpio [-0adkiLmpuvV][-R &lt;拥有者&gt;&lt;:/.&gt;&lt;所属群组&gt;][–help][–no-preserve-owner][–quiet][–sparse][–version][目的目]</code></p><p>补充说明：cpio是用来建立，还原备份档的工具程序，它可以加入，解开cpio或tra备份档内的文件。</p><p>参　　数：</p><ul><li>-0或–null 　接受新增列控制字符，通常配合find指令的”-print0”参数使用。 </li><li>-a或–reset-access-time 　重新设置文件的存取时间。 </li><li>-A或–append 　附加到已存在的备份档中，且这个备份档必须存放在磁盘上，而不能放置于磁带机里。 </li><li>-b或–swap 　此参数的效果和同时指定”-sS”参数相同。 </li><li>-B 　将输入/输出的区块大小改成5210 Bytes。 </li><li>-c 　使用旧ASCII备份格式。 </li><li>-C&lt;区块大小&gt;或–io-size=&lt;区块大小&gt; 　设置输入/输出的区块大小，单位是Byte。 </li><li>-d或–make-directories 　如有需要cpio会自行建立目录。 </li><li>-E&lt;范本文件&gt;或–pattern-file=&lt;范本文件&gt; 　指定范本文件，其内含有一个或多个范本样式，让cpio解开符合范本条件的文件，格式为每列一个范本样式。 </li><li>-f或–nonmatching 　让cpio解开所有不符合范本条件的文件。 </li><li>-F&lt;备份档&gt;或–file=&lt;备份档&gt; 　指定备份档的名称，用来取代标准输入或输出，也能借此通过网络使用另一台主机的保存设备存取备份档。 </li><li>-H&lt;备份格式&gt; 　指定备份时欲使用的文件格式。 </li><li>-i或–extract 　执行copy-in模式，还原备份档。 </li><li>-l&lt;备份档&gt; 　指定备份档的名称，用来取代标准输入，也能借此通过网络使用另一台主机的保存设备读取备份档。 </li><li>-k 　此参数将忽略不予处理，仅负责解决cpio不同版本间的兼容性问题。 </li><li>-l或–link 　以硬连接的方式取代复制文件，可在copy-pass模式下运用。 </li><li>-L或–dereference 　不建立符号连接，直接复制该连接所指向的原始文件。 </li><li>-m或preserve-modification-time 　不去更换文件的更改时间。 </li><li>-M&lt;回传信息&gt;或–message=&lt;回传信息&gt; 　设置更换保存媒体的信息。 </li><li>-n或–numeric-uid-gid 　使用”-tv”参数列出备份档的内容时，若再加上参数”-n”，则会以用户识别码和群组识别码替代拥有者和群组名称列出文件清单。 </li><li>-o或–create 　执行copy-out模式，建立备份档。 </li><li>-O&lt;备份档&gt; 　指定备份档的名称，用来取代标准输出，也能借此通过网络　使用另一台主机的保存设备存放备份档。 </li><li>-p或–pass-through 　执行copy-pass模式，略过备份步骤，直接将文件复制到目的目录。 </li><li>-r或–rename 　当有文件名称需要更动时，采用互动模式。 </li><li>-R&lt;拥有者&gt;&lt;:/.&gt;&lt;所属群组&gt;或</li><li>—-owner&lt;拥有者&gt;&lt;:/.&gt;&lt;所属群组&gt; 　在copy-in模式还原备份档，或copy-pass模式复制文件时，可指定这些备份，复制的文件的拥有者与所属群组。 </li><li>-s或–swap-bytes 　交换每对字节的内容。 </li><li>-S或–swap-halfwords 　交换每半个字节的内容。 </li><li>-t或–list 　将输入的内容呈现出来。 </li><li>-u或–unconditional 　置换所有文件，不论日期时间的新旧与否，皆不予询问而直接覆盖。 </li><li>-v或–verbose 　详细显示指令的执行过程。 </li><li>-V或–dot 　执行指令时，在每个文件的执行程序前面加上”.”号 </li><li>–block-size=&lt;区块大小&gt; 　设置输入/输出的区块大小，假如设置数值为5，则区块大小为2500，若设置成10，则区块大小为5120，依次类推。 </li><li>–force-local 　强制将备份档存放在本地主机。 </li><li>–help 　在线帮助。 </li><li>–no-absolute-filenames 　使用相对路径建立文件名称。 </li><li>–no-preserve-owner 　不保留文件的拥有者，谁解开了备份档，那些文件就归谁所有。 </li><li>-only-verify-crc 　当备份档采用CRC备份格式时，可使用这项参数检查备份档内的每个文件是否正确无误。 </li><li>–quiet 　不显示复制了多少区块。 </li><li>–sparse 　倘若一个文件内含大量的连续0字节，则将此文件存成稀疏文件。 </li><li>–version 　显示版本信息。</li></ul><h3 id="dump"><a href="#dump" class="headerlink" title="dump"></a><font color="red">dump</font></h3><p>功能说明：备份文件系统。</p><p>语　　法：<code>dump [-cnu][-0123456789][-b &lt;区块大小&gt;][-B &lt;区块数目&gt;][-d &lt;密度&gt;][-f &lt;设备名称&gt;][-h &lt;层级&gt;][-s &lt;磁带长度&gt;][-T &lt;日期&gt;][目录或文件系统] 或 dump [-wW]</code></p><p>补充说明：dump为备份工具程序，可将目录或整个文件系统备份至指定的设备，或备份成一个大文件。</p><p>参　　数：</p><ul><li>-0123456789 　备份的层级。 </li><li>-b&lt;区块大小&gt; 　指定区块的大小，单位为KB。 </li><li>-B&lt;区块数目&gt; 　指定备份卷册的区块数目。 </li><li>-c 　修改备份磁带预设的密度与容量。 </li><li>-d&lt;密度&gt; 　设置磁带的密度。单位为BPI。 </li><li>-f&lt;设备名称&gt; 　指定备份设备。 </li><li>-h&lt;层级&gt; 　当备份层级等于或大雨指定的层级时，将不备份用户标示为”nodump”的文件。 </li><li>-n 　当备份工作需要管理员介入时，向所有”operator”群组中的使用者发出通知。 </li><li>-s&lt;磁带长度&gt; 　备份磁带的长度，单位为英尺。 </li><li>-T&lt;日期&gt; 　指定开始备份的时间与日期。 </li><li>-u 　备份完毕后，在/etc/dumpdates中记录备份的文件系统，层级，日期与时间等。 </li><li>-w 　与-W类似，但仅显示需要备份的文件。 </li><li>-W 　显示需要备份的文件及其最后一次备份的层级，时间与日期。</li></ul><h3 id="gunzip-gnu-unzip"><a href="#gunzip-gnu-unzip" class="headerlink" title="gunzip(gnu unzip)"></a>gunzip(gnu unzip)</h3><p>功能说明：解压文件。</p><p>语　　法：<code>gunzip [-acfhlLnNqrtvV][-s &lt;压缩字尾字符串&gt;][文件…] 或 gunzip [-acfhlLnNqrtvV][-s &lt;压缩字尾字符串&gt;][目录]</code></p><p>补充说明：gunzip是个使用广泛的解压缩程序，它用于解开被gzip压缩过的文件，这些压缩文件预设最后的扩展名为”.gz”。事实上gunzip就是gzip的硬连接，因此不论是压缩或解压缩，都可通过gzip指令单独完成。</p><p>参　　数：</p><ul><li>-a或–ascii 　使用ASCII文字模式。 </li><li>-c或–stdout或–to-stdout 　把解压后的文件输出到标准输出设备。 </li><li>-f或-force 　强行解开压缩文件，不理会文件名称或硬连接是否存在以及该文件是否为符号连接。 </li><li>-h或–help 　在线帮助。 </li><li>-l或–list 　列出压缩文件的相关信息。 </li><li>-L或–license 　显示版本与版权信息。 </li><li>-n或–no-name 　解压缩时，若压缩文件内含有远来的文件名称及时间戳记，则将其忽略不予处理。 </li><li>-N或–name 　解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其回存到解开的文件上。 </li><li>-q或–quiet 　不显示警告信息。 </li><li>-r或–recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。 </li><li>-S&lt;压缩字尾字符串&gt;或–suffix&lt;压缩字尾字符串&gt; 　更改压缩字尾字符串。 </li><li>-t或–test 　测试压缩文件是否正确无误。 </li><li>-v或–verbose 　显示指令执行过程。 </li><li>-V或–version 显示版本信息。</li></ul><h3 id="gzexe-gzip-executable"><a href="#gzexe-gzip-executable" class="headerlink" title="gzexe(gzip executable)"></a>gzexe(gzip executable)</h3><p>功能说明：压缩执行文件。</p><p>语　　法：<code>gzexe [-d][执行文件…]</code></p><p>补充说明：gzexe是用来压缩执行文件的程序。当您去执行被压缩过的执行文件时，该文件会自动解压然后继续执行，和使用一般的执行文件相同。</p><p>参　　数：</p><ul><li>-d 　解开压缩文件。</li></ul><h3 id="gzip-gnu-zip"><a href="#gzip-gnu-zip" class="headerlink" title="gzip(gnu zip)"></a><font color="red">gzip(gnu zip)</font></h3><p>功能说明：压缩文件。</p><p>语　　法：<code>gzip [-acdfhlLnNqrtvV][-S &lt;压缩字尾字符串&gt;][-&lt;压缩效率&gt;][–best/fast][文件…] 或 gzip [-acdfhlLnNqrtvV][-S &lt;压缩字尾字符串&gt;][-&lt;压缩效率&gt;][–best/fast][目录]</code></p><p>补充说明：gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多出”.gz”的扩展名。</p><p>参　　数：</p><ul><li>-a或–ascii 　使用ASCII文字模式。 </li><li>-c或–stdout或–to-stdout 　把压缩后的文件输出到标准输出设备，不去更动原始文件。 </li><li>-d或–decompress或—-uncompress 　解开压缩文件。 </li><li>-f或–force 　强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接。 </li><li>-h或–help 　在线帮助。 </li><li>-l或–list 　列出压缩文件的相关信息。 </li><li>-L或–license 　显示版本与版权信息。 </li><li>-n或–no-name 　压缩文件时，不保存原来的文件名称及时间戳记。 </li><li>-N或–name 　压缩文件时，保存原来的文件名称及时间戳记。 </li><li>-q或–quiet 　不显示警告信息。 </li><li>-r或–recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。 </li><li>-S&lt;压缩字尾字符串&gt;或—-suffix&lt;压缩字尾字符串&gt; 　更改压缩字尾字符串。 </li><li>-t或–test 　测试压缩文件是否正确无误。 </li><li>-v或–verbose 　显示指令执行过程。 </li><li>-V或–version 　显示版本信息。 </li><li>-&lt;压缩效率&gt; 　压缩效率是一个介于1－9的数值，预设值为”6”，指定愈大的数值，压缩效率就会愈高。 </li><li>–best 　此参数的效果和指定”-9”参数相同。 </li><li>–fast 　此参数的效果和指定”-1”参数相同。</li></ul><h3 id="lha"><a href="#lha" class="headerlink" title="lha"></a>lha</h3><p>功能说明：压缩或解压缩文件。</p><p>语　　法：<br><code>lha [-acdfglmnpqtuvx][-a &lt;0/1/2&gt;/u&lt;/0/1/2&gt;][-&lt;a/c/u&gt;d][-&lt;e/x&gt;i][-&lt;a/u&gt;o][-&lt;e/x&gt;w=&lt;目的目录&gt;][-&lt;a/u&gt;z][压缩文件][文件…] 或 lha [-acdfglmnpqtuvx][-a &lt;0/1/2&gt;/u&lt;/0/1/2&gt;][-&lt;a/c/u&gt;d][-&lt;e/x&gt;i][-&lt;a/u&gt;o][-&lt;e/x&gt;w=&lt;目的目录&gt;][-&lt;a/u&gt;z][压缩文件][目录…]</code></p><p>补充说明：lha是从lharc演变而来的压缩程序，文件经它压缩后，会另外产生具有”.lzh”扩展名的压缩文件。</p><p>参　　数：</p><ul><li>-a或a   压缩文件，并加入到压缩文件内。</li><li>-a&lt;0/1/2&gt;/u&lt;/0/1/2&gt;   压缩文件时，采用不同的文件头。</li><li>-c或c   压缩文件，重新建构新的压缩文件后，再将其加入。</li><li>-d或d   从压缩文件内删除指定的文件。</li><li>-&lt;a/c/u&gt;d或&lt;a/c/u&gt;d   压缩文件，然后将其加入，重新建构，更新压缩文件或，删除原始文件，也就是把文件移到压缩文件中。</li><li>-e或e   解开压缩文件。</li><li>-f或f   强制执行lha命令，在解压时会直接覆盖已有的文件而不加以询问。</li><li>-g或g   使用通用的压缩格式，便于解决兼容性的问题。</li><li>-&lt;e/x&gt;i或&lt;e/x&gt;i   解开压缩文件时，忽略保存在压缩文件内的文件路径，直接将其解压后存放在现行目录下或是指定的目录中。</li><li>-l或l   列出压缩文件的相关信息。</li><li>-m或m   此参数的效果和同时指定”-ad”参数相同。</li><li>-n或n   不执行指令，仅列出实际执行会进行的动作。</li><li>-&lt;a/u&gt;o或&lt;a/u&gt;o   采用lharc兼容格式，将压缩后的文件加入，更新压缩文件。</li><li>-p或p   从压缩文件内输出到标准输出设备。</li><li>-q或q   不显示指令执行过程。</li><li>-t或t   检查备份文件内的每个文件是否正确无误。</li><li>-u或u   更换较新的文件到压缩文件内。</li><li>-u&lt;/0/1/2&gt;或u&lt;/0/1/2&gt;   在文件压缩时采用不同的文件头，然后更新到压缩文件内。</li><li>-v或v   详细列出压缩文件的相关信息。</li><li>-&lt;e/x&gt;w=&lt;目的目录&gt;或&lt;e/x&gt;w=&lt;目的目录&gt;   指定解压缩的目录。</li><li>-x或x   解开压缩文件。</li><li>-&lt;a/u&gt;z或&lt;a/u&gt;z   不压缩文件，直接把它加入，更新压缩文件。</li></ul><h3 id="restore"><a href="#restore" class="headerlink" title="restore"></a>restore</h3><p>功能说明：还原(Restore)由倾倒(Dump)操作所备份下来的文件或整个文件系统(一个分区)。</p><p>语　　法：<code>restore [-cCvy][-b &lt;区块大小&gt;][-D &lt;文件系统&gt;][-f &lt;备份文件&gt;][-s &lt;文件编号&gt;] 或 restore [-chimvy][-b &lt;区块大小&gt;][-f &lt;备份文件&gt;][-s &lt;文件编号&gt;] 或 restore [-crvy][-b &lt;区块大小&gt;][-f &lt;备份文件&gt;][-s &lt;文件编号&gt;] 或 restore [-cRvy][-b &lt;区块大小&gt;][-D &lt;文件系统&gt;][-f &lt;备份文件&gt;][-s &lt;文件编号&gt;] 或 restore [chtvy][-b &lt;区块大小&gt;][-D &lt;文件系统&gt;][-f &lt;备份文件&gt;][-s &lt;文件编号&gt;][文件…] 或 restore [-chmvxy][-b &lt;区块大小&gt;][-D &lt;文件系统&gt;][-f &lt;备份文件&gt;][-s &lt;文件编号&gt;][文件…]</code></p><p>补充说明：restore 指令所进行的操作和dump指令相反，倾倒操作可用来备份文件，而还原操作则是写回这些已备份的文件。</p><p>参　　数：</p><ul><li>-b&lt;区块大小&gt;   设置区块大小，单位是Byte。</li><li>-c   不检查倾倒操作的备份格式，仅准许读取使用旧格式的备份文件。</li><li>-C   使用对比模式，将备份的文件与现行的文件相互对比。</li><li>-D&lt;文件系统&gt;   允许用户指定文件系统的名称。</li><li>-f&lt;备份文件&gt;   从指定的文件中读取备份数据，进行还原操作。</li><li>-h   仅解出目录而不包括与该目录相关的所有文件。</li><li>-i   使用互动模式，在进行还原操作时，restore指令将依序询问用户。</li><li>-m   解开符合指定的inode编号的文件或目录而非采用文件名称指定。</li><li>-r   进行还原操作。</li><li>-R   全面还原文件系统时，检查应从何处开始进行。</li><li>-s&lt;文件编号&gt;   当备份数据超过一卷磁带时，您可以指定备份文件的编号。</li><li>-t   指定文件名称，若该文件已存在备份文件中，则列出它们的名称。</li><li>-v   显示指令执行过程。</li><li>-x   设置文件名称，且从指定的存储媒体里读入它们，若该文件已存在在备份文件中，则将其还原到文件系统内。</li><li>-y   不询问任何问题，一律以同意回答并继续执行指令。</li></ul><h3 id="tar-tape-archive"><a href="#tar-tape-archive" class="headerlink" title="tar(tape archive)"></a><font color="red">tar(tape archive)</font></h3><p>功能说明：备份文件。</p><p>语　　法：<code>tar [-ABcdgGhiklmMoOpPrRsStuUvwWxzZ][-b &lt;区块数目&gt;][-C &lt;目的目录&gt;][-f &lt;备份文件&gt;][-F &lt;Script文件&gt;][-K &lt;文件&gt;][-L &lt;媒体容量&gt;][-N &lt;日期时间&gt;][-T &lt;范本文件&gt;][-V &lt;卷册名称&gt;][-X &lt;范本文件&gt;][-&lt;设备编号&gt;&lt;存储密度&gt;][–after-date=&lt;日期时间&gt;][–atime-preserve][–backuup=&lt;备份方式&gt;][–checkpoint][–concatenate][–confirmation][–delete][–exclude=&lt;范本样式&gt;][–force-local][–group=&lt;群组名称&gt;][–help][–ignore-failed-read][–new-volume-script=&lt;Script文件&gt;][–newer-mtime][–no-recursion][–null][–numeric-owner][–owner=&lt;用户名称&gt;][–posix][–erve][–preserve-order][–preserve-permissions][–record-size=&lt;区块数目&gt;][–recursive-unlink][–remove-files][–rsh-command=&lt;执行指令&gt;][–same-owner][–suffix=&lt;备份字尾字符串&gt;][–totals][–use-compress-program=&lt;执行指令&gt;][–version][–volno-file=&lt;编号文件&gt;][文件或目录…]</code></p><p>补充说明：tar是用来建立，还原备份文件的工具程序，它可以加入，解开备份文件内的文件。</p><p>参　　数：</p><ul><li>-A或–catenate   新增温暖件到已存在的备份文件。</li><li>-b&lt;区块数目&gt;或–blocking-factor=&lt;区块数目&gt;   设置每笔记录的区块数目，每个区块大小为12Bytes。</li><li>-B或–read-full-records   读取数据时重设区块大小。</li><li>-c或–create   建立新的备份文件。</li><li>-C&lt;目的目录&gt;或–directory=&lt;目的目录&gt;   切换到指定的目录。</li><li>-d或–diff或–compare   对比备份文件内和文件系统上的文件的差异。</li><li>-f&lt;备份文件&gt;或–file=&lt;备份文件&gt;   指定备份文件。</li><li>-F&lt;Script文件&gt;或–info-script=&lt;Script文件&gt;   每次更换磁带时，就执行指定的Script文件。</li><li>-g或–listed-incremental   处理GNU格式的大量备份。</li><li>-G或–incremental   处理旧的GNU格式的大量备份。</li><li>-h或–dereference   不建立符号连接，直接复制该连接所指向的原始文件。</li><li>-i或–ignore-zeros   忽略备份文件中的0 Byte区块，也就是EOF。</li><li>-k或–keep-old-files   解开备份文件时，不覆盖已有的文件。</li><li>-K&lt;文件&gt;或–starting-file=&lt;文件&gt;   从指定的文件开始还原。</li><li>-l或–one-file-system   复制的文件或目录存放的文件系统，必须与tar指令执行时所处的文件系统相同，否则不予复制。</li><li>-L&lt;媒体容量&gt;或-tape-length=&lt;媒体容量&gt;   设置存放每体的容量，单位以1024 Bytes计算。</li><li>-m或–modification-time   还原文件时，不变更文件的更改时间。</li><li>-M或–multi-volume   在建立，还原备份文件或列出其中的内容时，采用多卷册模式。</li><li>-N&lt;日期格式&gt;或–newer=&lt;日期时间&gt;   只将较指定日期更新的文件保存到备份文件里。</li><li>-o或–old-archive或–portability   将资料写入备份文件时使用V7格式。</li><li>-O或–stdout   把从备份文件里还原的文件输出到标准输出设备。</li><li>-p或–same-permissions   用原来的文件权限还原文件。</li><li>-P或–absolute-names   文件名使用绝对名称，不移除文件名称前的”/“号。</li><li>-r或–append   新增文件到已存在的备份文件的结尾部分。</li><li>-R或–block-number   列出每个信息在备份文件中的区块编号。</li><li>-s或–same-order   还原文件的顺序和备份文件内的存放顺序相同。</li><li>-S或–sparse   倘若一个文件内含大量的连续0字节，则将此文件存成稀疏文件。</li><li>-t或–list   列出备份文件的内容。</li><li>-T&lt;范本文件&gt;或–files-from=&lt;范本文件&gt;   指定范本文件，其内含有一个或多个范本样式，让tar解开或建立符合设置条件的文件。</li><li>-u或–update   仅置换较备份文件内的文件更新的文件。</li><li>-U或–unlink-first   解开压缩文件还原文件之前，先解除文件的连接。</li><li>-v或–verbose   显示指令执行过程。</li><li>-V&lt;卷册名称&gt;或–label=&lt;卷册名称&gt;   建立使用指定的卷册名称的备份文件。</li><li>-w或–interactive   遭遇问题时先询问用户。</li><li>-W或–verify   写入备份文件后，确认文件正确无误。</li><li>-x或–extract或–get  从备份文件中还原文件。</li><li>-X&lt;范本文件&gt;或–exclude-from=&lt;范本文件&gt;  指定范本文件，其内含有一个或多个范本样式，让ar排除符合设置条件的文件。</li><li>-z或–gzip或–ungzip   通过gzip指令处理备份文件。</li><li>-Z或–compress或–uncompress   通过compress指令处理备份文件。</li><li>-&lt;设备编号&gt;&lt;存储密度&gt;   设置备份用的外围设备编号及存放数据的密度。</li><li>–after-date=&lt;日期时间&gt;   此参数的效果和指定”-N”参数相同。</li><li>–atime-preserve   不变更文件的存取时间。</li><li>–backup=&lt;备份方式&gt;或–backup   移除文件前先进行备份。</li><li>–checkpoint   读取备份文件时列出目录名称。</li><li>–concatenate   此参数的效果和指定”-A”参数相同。</li><li>–confirmation   此参数的效果和指定”-w”参数相同。</li><li>–delete   从备份文件中删除指定的文件。</li><li>–exclude=&lt;范本样式&gt;   排除符合范本样式的问家。</li><li>–group=&lt;群组名称&gt;   把加入设备文件中的文件的所属群组设成指定的群组。</li><li>–help   在线帮助。</li><li>–ignore-failed-read   忽略数据读取错误，不中断程序的执行。</li><li>–new-volume-script=&lt;Script文件&gt;   此参数的效果和指定”-F”参数相同。</li><li>–newer-mtime   只保存更改过的文件。</li><li>–no-recursion   不做递归处理，也就是指定目录下的所有文件及子目录不予处理。</li><li>–null   从null设备读取文件名称。</li><li>–numeric-owner   以用户识别码及群组识别码取代用户名称和群组名称。</li><li>–owner=&lt;用户名称&gt;   把加入备份文件中的文件的拥有者设成指定的用户。</li><li>–posix   将数据写入备份文件时使用POSIX格式。</li><li>–preserve      此参数的效果和指定”-ps”参数相同。</li><li>–preserve-order      此参数的效果和指定”-A”参数相同。</li><li>–preserve-permissions      此参数的效果和指定”-p”参数相同。</li><li>–record-size=&lt;区块数目&gt;      此参数的效果和指定”-b”参数相同。</li><li>–recursive-unlink   解开压缩文件还原目录之前，先解除整个目录下所有文件的连接。</li><li>–remove-files   文件加入备份文件后，就将其删除。</li><li>–rsh-command=&lt;执行指令&gt;   设置要在远端主机上执行的指令，以取代rsh指令。</li><li>–same-owner   尝试以相同的文件拥有者还原问家你。</li><li>–suffix=&lt;备份字尾字符串&gt;   移除文件前先行备份。</li><li>–totals   备份文件建立后，列出文件大小。</li><li>–use-compress-program=&lt;执行指令&gt;   通过指定的指令处理备份文件。</li><li>–version   显示版本信息。</li><li>–volno-file=&lt;编号文件&gt;   使用指定文件内的编号取代预设的卷册编号。</li></ul><h3 id="unarj"><a href="#unarj" class="headerlink" title="unarj"></a>unarj</h3><p>功能说明：解压缩.arj文件。</p><p>语　　法：<code>unarj [eltx][.arj压缩文件]</code></p><p>补充说明：unarj为.arj压缩文件的压缩程序。</p><p>参　　数：</p><ul><li>e   解压缩.arj文件。</li><li>l   显示压缩文件内所包含的文件。</li><li>t   检查压缩文件是否正确。</li><li>x   解压缩时保留原有的路径。</li></ul><h3 id="unzip"><a href="#unzip" class="headerlink" title="unzip"></a><font color="red">unzip</font></h3><p>功能说明：解压缩zip文件</p><p>语　　法：<code>unzip [-cflptuvz][-agCjLMnoqsVX][-P &lt;密码&gt;][.zip文件][文件][-d &lt;目录&gt;][-x &lt;文件&gt;] 或 unzip [-Z]</code></p><p>补充说明：unzip为.zip压缩文件的解压缩程序。</p><p>参　　数：</p><ul><li>-c   将解压缩的结果显示到屏幕上，并对字符做适当的转换。</li><li>-f   更新现有的文件。</li><li>-l   显示压缩文件内所包含的文件。</li><li>-p   与-c参数类似，会将解压缩的结果显示到屏幕上，但不会执行任何的转换。</li><li>-t   检查压缩文件是否正确。</li><li>-u   与-f参数类似，但是除了更新现有的文件外，也会将压缩文件中的其他文件解压缩到目录中。</li><li>-v   执行是时显示详细的信息。</li><li>-z   仅显示压缩文件的备注文字。</li><li>-a   对文本文件进行必要的字符转换。</li><li>-b   不要对文本文件进行字符转换。 </li><li>-C   压缩文件中的文件名称区分大小写。</li><li>-j   不处理压缩文件中原有的目录路径。</li><li>-L   将压缩文件中的全部文件名改为小写。</li><li>-M   将输出结果送到more程序处理。</li><li>-n   解压缩时不要覆盖原有的文件。</li><li>-o   不必先询问用户，unzip执行后覆盖原有文件。</li><li>-P&lt;密码&gt;   使用zip的密码选项。</li><li>-q   执行时不显示任何信息。</li><li>-s   将文件名中的空白字符转换为底线字符。</li><li>-V   保留VMS的文件版本信息。</li><li><p>-X   解压缩时同时回存文件原来的UID/GID。</p><p>  [.zip文件]   指定.zip压缩文件。<br>  [文件]   指定要处理.zip压缩文件中的哪些文件。</p></li><li><p>-d&lt;目录&gt;   指定文件解压缩后所要存储的目录。</p></li><li>-x&lt;文件&gt;   指定不要处理.zip压缩文件中的哪些文件。</li><li>-Z   unzip -Z等于执行zipinfo指令。</li></ul><h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a><font color="red">zip</font></h3><p>功能说明：压缩文件。</p><p>语　　法：<code>zip [-AcdDfFghjJKlLmoqrSTuvVwXyz$][-b &lt;工作目录&gt;][-ll][-n &lt;字尾字符串&gt;][-t &lt;日期时间&gt;][-&lt;压缩效率&gt;][压缩文件][文件…][-i &lt;范本样式&gt;][-x &lt;范本样式&gt;]</code></p><p>补充说明：zip是个使用广泛的压缩程序，文件经它压缩后会另外产生具有”.zip”扩展名的压缩文件。</p><p>参　　数：</p><ul><li>-A   调整可执行的自动解压缩文件。</li><li>-b&lt;工作目录&gt;   指定暂时存放文件的目录。</li><li>-c   替每个被压缩的文件加上注释。</li><li>-d   从压缩文件内删除指定的文件。</li><li>-D   压缩文件内不建立目录名称。</li><li>-f   此参数的效果和指定”-u”参数类似，但不仅更新既有文件，如果某些文件原本不存在于压缩文件内，使用本参数会一并将其加入压缩文件中。</li><li>-F   尝试修复已损坏的压缩文件。</li><li>-g   将文件压缩后附加在既有的压缩文件之后，而非另行建立新的压缩文件。</li><li>-h   在线帮助。</li><li>-i&lt;范本样式&gt;   只压缩符合条件的文件。</li><li>-j   只保存文件名称及其内容，而不存放任何目录名称。</li><li>-J   删除压缩文件前面不必要的数据。</li><li>-k   使用MS-DOS兼容格式的文件名称。</li><li>-l   压缩文件时，把LF字符置换成LF+CR字符。</li><li>-ll   压缩文件时，把LF+CR字符置换成LF字符。</li><li>-L   显示版权信息。</li><li>-m   将文件压缩并加入压缩文件后，删除原始文件，即把文件移到压缩文件中。</li><li>-n&lt;字尾字符串&gt;   不压缩具有特定字尾字符串的文件。</li><li>-o   以压缩文件内拥有最新更改时间的文件为准，将压缩文件的更改时间设成和该文件相同。</li><li>-q   不显示指令执行过程。</li><li>-r   递归处理，将指定目录下的所有文件和子目录一并处理。</li><li>-S   包含系统和隐藏文件。</li><li>-t&lt;日期时间&gt;   把压缩文件的日期设成指定的日期。</li><li>-T   检查备份文件内的每个文件是否正确无误。</li><li>-u   更换较新的文件到压缩文件内。</li><li>-v   显示指令执行过程或显示版本信息。</li><li>-V   保存VMS操作系统的文件属性。</li><li>-w   在文件名称里假如版本编号，本参数仅在VMS操作系统下有效。</li><li>-x&lt;范本样式&gt;   压缩时排除符合条件的文件。</li><li>-X   不保存额外的文件属性。</li><li>-y   直接保存符号连接，而非该连接所指向的文件，本参数仅在UNIX之类的系统下有效。</li><li>-z   替压缩文件加上注释。</li><li>-$   保存第一个被压缩文件所在磁盘的卷册名称。</li><li>-&lt;压缩效率&gt;   压缩效率是一个介于1-9的数值。</li></ul><h3 id="zipinfo"><a href="#zipinfo" class="headerlink" title="zipinfo"></a>zipinfo</h3><p>功能说明：列出压缩文件信息。</p><p>语　　法：<code>zipinfo [-12hlmMstTvz][压缩文件][文件…][-x &lt;范本样式&gt;]</code></p><p>补充说明：执行zipinfo指令可得知zip压缩文件的详细信息。</p><p>参　　数：</p><ul><li>-1   只列出文件名称。</li><li>-2   此参数的效果和指定”-1”参数类似，但可搭配”-h”,”-t”和”-z”参数使用。</li><li>-h   只列出压缩文件的文件名称。</li><li>-l   此参数的效果和指定”-m”参数类似，但会列出原始文件的大小而非每个文件的压缩率。</li><li>-m   此参数的效果和指定”-s”参数类似，但多会列出每个文件的压缩率。</li><li>-M   若信息内容超过一个画面，则采用类似more指令的方式列出信息。</li><li>-s   用类似执行”ls -l”指令的效果列出压缩文件内容。</li><li>-t   只列出压缩文件内所包含的文件数目，压缩前后的文件大小及压缩率。</li><li>-T   将压缩文件内每个文件的日期时间用年，月，日，时，分，秒的顺序列出。</li><li>-v   详细显示压缩文件内每一个文件的信息。</li><li>-x&lt;范本样式&gt;   不列出符合条件的文件的信息。</li><li>-z   如果压缩文件内含有注释，就将注释显示出来。</li></ul><h2 id="linux文件管理命令"><a href="#linux文件管理命令" class="headerlink" title="linux文件管理命令"></a>linux文件管理命令</h2><h3 id="diff-differential"><a href="#diff-differential" class="headerlink" title="diff(differential)"></a>diff(differential)</h3><p>功能说明：比较文件的差异。 </p><p>语　　法：<code>diff [-abBcdefHilnNpPqrstTuvwy][-&lt;行数&gt;][-C &lt;行数&gt;][-D &lt;巨集名称&gt;][-I &lt;字符或字符串&gt;][-S &lt;文件&gt;][-W &lt;宽度&gt;][-x &lt;文件或目录&gt;][-X &lt;文件&gt;][–help][–left-column][–suppress-common-line][文件或目录1][文件或目录2] </code></p><p>补充说明：diff以逐行的方式，比较文本文件的异同处。所是指定要比较目录，则diff会比较目录中相同文件名的文件，但不会比较其中子目录。</p><p>参　　数：</p><ul><li>-&lt;行数&gt; 　指定要显示多少行的文本。此参数必须与-c或-u参数一并使用。 </li><li>-a或–text 　diff预设只会逐行比较文本文件。</li><li>-b或–ignore-space-change 　不检查空格字符的不同。 </li><li>-B或–ignore-blank-lines 　不检查空白行。 </li><li>-c 　显示全部内文，并标出不同之处。 </li><li>-C&lt;行数&gt;或–context&lt;行数&gt; 　与执行”-c-&lt;行数&gt;”指令相同。 </li><li>-d或–minimal 　使用不同的演算法，以较小的单位来做比较。 </li><li>-D&lt;巨集名称&gt;或ifdef&lt;巨集名称&gt; 　此参数的输出格式可用于前置处理器巨集。 </li><li>-e或–ed 　此参数的输出格式可用于ed的script文件。 </li><li>-f或-forward-ed 　输出的格式类似ed的script文件，但按照原来文件的顺序来显示不同处。 </li><li>-H或–speed-large-files 　比较大文件时，可加快速度。 </li><li>-l&lt;字符或字符串&gt;或–ignore-matching-lines&lt;字符或字符串&gt; 　若两个文件在某几行有所不同，而这几行同时都包含了选项中指定的字符或字符串，则不显示这两个文件的差异。 </li><li>-i或–ignore-case 　不检查大小写的不同。 </li><li>-l或–paginate 　将结果交由pr程序来分页。 </li><li>-n或–rcs 　将比较结果以RCS的格式来显示。 </li><li>-N或–new-file 　在比较目录时，若文件A仅出现在某个目录中，预设会显示：</li><li>Only in目录：文件A若使用-N参数，则diff会将文件A与一个空白的文件比较。  </li><li>-p 　若比较的文件为C语言的程序码文件时，显示差异所在的函数名称。 </li><li>-P或–unidirectional-new-file 　与-N类似，但只有当第二个目录包含了一个第一个目录所没有的文件时，才会将这个文件与空白的文件做比较。 </li><li>-q或–brief 　仅显示有无差异，不显示详细的信息。 </li><li>-r或–recursive 　比较子目录中的文件。 </li><li>-s或–report-identical-files 　若没有发现任何差异，仍然显示信息。 </li><li>-S&lt;文件&gt;或–starting-file&lt;文件&gt; 　在比较目录时，从指定的文件开始比较。 </li><li>-t或–expand-tabs 　在输出时，将tab字符展开。 </li><li>-T或–initial-tab 　在每行前面加上tab字符以便对齐。 </li><li>-u,-U&lt;列数&gt;或–unified=&lt;列数&gt; 　以合并的方式来显示文件内容的不同。 </li><li>-v或–version 　显示版本信息。 </li><li>-w或–ignore-all-space 　忽略全部的空格字符。 </li><li>-W&lt;宽度&gt;或–width&lt;宽度&gt; 　在使用-y参数时，指定栏宽。 </li><li>-x&lt;文件名或目录&gt;或–exclude&lt;文件名或目录&gt; 　不比较选项中所指定的文件或目录。 </li><li>-X&lt;文件&gt;或–exclude-from&lt;文件&gt; 　您可以将文件或目录类型存成文本文件，然后在=&lt;文件&gt;中指定此文本文件。 </li><li>-y或–side-by-side 　以并列的方式显示文件的异同之处。 </li><li>–help 　显示帮助。 </li><li>–left-column 　在使用-y参数时，若两个文件某一行内容相同，则仅在左侧的栏位显示该行内容。</li><li>–suppress-common-lines 　在使用-y参数时，仅显示不同之处。</li></ul><h3 id="diffstat-differential-status"><a href="#diffstat-differential-status" class="headerlink" title="diffstat(differential status)"></a>diffstat(differential status)</h3><p>功能说明：根据diff的比较结果，显示统计数字。</p><p>语　　法：<code>diff [-wV][-n &lt;文件名长度&gt;][-p &lt;文件名长度&gt;]</code></p><p>补充说明：diffstat读取diff的输出结果，然后统计各文件的插入，删除，修改等差异计量。</p><p>参　　数：</p><ul><li>-n&lt;文件名长度&gt; 　指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。 </li><li>-p&lt;文件名长度&gt; 　与-n参数相同，但此处的&lt;文件名长度&gt;包括了文件的路径。 </li><li>-w 　指定输出时栏位的宽度。 </li><li>-V 　显示版本信息。</li></ul><h3 id="file"><a href="#file" class="headerlink" title="file"></a>file</h3><p>功能说明：辨识文件类型。 </p><p>语　　法：<code>file [-beLvz][-f &lt;名称文件&gt;][-m &lt;魔法数字文件&gt;…][文件或目录…]  </code></p><p>补充说明：通过file指令，我们得以辨识该文件的类型。 </p><p>参　　数：</p><ul><li>-b 　列出辨识结果时，不显示文件名称。 </li><li>-c 　详细显示指令执行过程，便于排错或分析程序执行的情形。 </li><li>-f&lt;名称文件&gt; 　指定名称文件，其内容有一个或多个文件名称呢感，让file依序辨识这些文件，格式为每列一个文件名称。  </li><li>-L 　直接显示符号连接所指向的文件的类别。 </li><li>-m&lt;魔法数字文件&gt; 　指定魔法数字文件。 </li><li>-v 　显示版本信息。 </li><li>-z 　尝试去解读压缩文件的内容。</li></ul><h3 id="find"><a href="#find" class="headerlink" title="find"></a><font color="red">find</font></h3><p>功能说明：查找文件或目录。</p><p>语　　法：<code>find [目录…][-amin &lt;分钟&gt;][-anewer &lt;参考文件或目录&gt;][-atime &lt;24小时数&gt;][-cmin &lt;分钟&gt;][-cnewer &lt;参考文件或目录&gt;][-ctime &lt;24小时数&gt;][-daystart][-depyh][-empty][-exec &lt;执行指令&gt;][-false][-fls &lt;列表文件&gt;][-follow][-fprint &lt;列表文件&gt;][-fprint0 &lt;列表文件&gt;][-fprintf &lt;列表文件&gt;&lt;输出格式&gt;][-fstype &lt;文件系统类型&gt;][-gid &lt;群组识别码&gt;][-group &lt;群组名称&gt;][-help][-ilname &lt;范本样式&gt;][-iname &lt;范本样式&gt;][-inum &lt;inode编号&gt;][-ipath &lt;范本样式&gt;][-iregex &lt;范本样式&gt;][-links &lt;连接数目&gt;][-lname &lt;范本样式&gt;][-ls][-maxdepth &lt;目录层级&gt;][-mindepth &lt;目录层级&gt;][-mmin &lt;分钟&gt;][-mount]<br>[-mtime &lt;24小时数&gt;][-name &lt;范本样式&gt;][-newer &lt;参考文件或目录&gt;][-nogroup][noleaf] [-nouser][-ok &lt;执行指令&gt;][-path &lt;范本样式&gt;][-perm &lt;权限数值&gt;][-print][-print0][-printf &lt;输出格式&gt;][-prune][-regex &lt;范本样式&gt;][-size &lt;文件大小&gt;][-true][-type &lt;文件类型&gt;][-uid &lt;用户识别码&gt;][-used &lt;日数&gt;][-user &lt;拥有者名称&gt;][-version][-xdev][-xtype &lt;文件类型&gt;]</code></p><p>补充说明：find指令用于查找符合条件的文件。任何位于参数之前的字符串都将被视为欲查找的目录。</p><p>参　　数：</p><ul><li>-amin&lt;分钟&gt; 　查找在指定时间曾被存取过的文件或目录，单位以分钟计算。 </li><li>-anewer&lt;参考文件或目录&gt; 　查找其存取时间较指定文件或目录的存取时间更接近现在的文件或目录。 </li><li>-atime&lt;24小时数&gt; 　查找在指定时间曾被存取过的文件或目录，单位以24小时计算。 </li><li>-cmin&lt;分钟&gt; 　查找在指定时间之时被更改的文件或目录。 </li><li>-cnewer&lt;参考文件或目录&gt; 　查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录。 </li><li>-ctime&lt;24小时数&gt; 　查找在指定时间之时被更改的文件或目录，单位以24小时计算。 </li><li>-daystart 　从本日开始计算时间。 </li><li>-depth 　从指定目录下最深层的子目录开始查找。 </li><li>-expty 　寻找文件大小为0 Byte的文件，或目录下没有任何子目录或文件的空目录。 </li><li>-exec&lt;执行指令&gt; 　假设find指令的回传值为True，就执行该指令。 </li><li>-false 　将find指令的回传值皆设为False。 </li><li>-fls&lt;列表文件&gt; 　此参数的效果和指定”-ls”参数类似，但会把结果保存为指定的列表文件。 </li><li>-follow 　排除符号连接。 </li><li>-fprint&lt;列表文件&gt; 　此参数的效果和指定”-print”参数类似，但会把结果保存成指定的列表文件。 </li><li>-fprint0&lt;列表文件&gt; 　此参数的效果和指定”-print0”参数类似，但会把结果保存成指定的列表文件。 </li><li>-fprintf&lt;列表文件&gt;&lt;输出格式&gt; 　此参数的效果和指定”-printf”参数类似，但会把结果保存成指定的列表文件。 </li><li>-fstype&lt;文件系统类型&gt; 　只寻找该文件系统类型下的文件或目录。 </li><li>-gid&lt;群组识别码&gt; 　查找符合指定之群组识别码的文件或目录。 </li><li>-group&lt;群组名称&gt; 　查找符合指定之群组名称的文件或目录。 </li><li>-help或–help 　在线帮助。 </li><li>-ilname&lt;范本样式&gt; 　此参数的效果和指定”-lname”参数类似，但忽略字符大小写的差别。 </li><li>-iname&lt;范本样式&gt; 　此参数的效果和指定”-name”参数类似，但忽略字符大小写的差别。 </li><li>-inum&lt;inode编号&gt; 　查找符合指定的inode编号的文件或目录。 </li><li>-ipath&lt;范本样式&gt; 　此参数的效果和指定”-ipath”参数类似，但忽略字符大小写的差别。 </li><li>-iregex&lt;范本样式&gt; 　此参数的效果和指定”-regexe”参数类似，但忽略字符大小写的差别。 </li><li>-links&lt;连接数目&gt; 　查找符合指定的硬连接数目的文件或目录。 </li><li>-iname&lt;范本样式&gt; 　指定字符串作为寻找符号连接的范本样式。 </li><li>-ls 　假设find指令的回传值为True，就将文件或目录名称列出到标准输出。 </li><li>-maxdepth&lt;目录层级&gt; 　设置最大目录层级。 </li><li>-mindepth&lt;目录层级&gt; 　设置最小目录层级。 </li><li>-mmin&lt;分钟&gt; 　查找在指定时间曾被更改过的文件或目录，单位以分钟计算。 </li><li>-mount 　此参数的效果和指定”-xdev”相同。 </li><li>-mtime&lt;24小时数&gt; 　查找在指定时间曾被更改过的文件或目录，单位以24小时计算。 </li><li>-name&lt;范本样式&gt; 　指定字符串作为寻找文件或目录的范本样式。 </li><li>-newer&lt;参考文件或目录&gt; 　查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录。 </li><li>-nogroup 　找出不属于本地主机群组识别码的文件或目录。 </li><li>-noleaf 　不去考虑目录至少需拥有两个硬连接存在。 </li><li>-nouser 　找出不属于本地主机用户识别码的文件或目录。 </li><li>-ok&lt;执行指令&gt; 　此参数的效果和指定”-exec”参数类似，但在执行指令之前会先询问用户，若回答”y”或”Y”，则放弃执行指令。 </li><li>-path&lt;范本样式&gt; 　指定字符串作为寻找目录的范本样式。 </li><li>-perm&lt;权限数值&gt; 　查找符合指定的权限数值的文件或目录。 </li><li>-print 　假设find指令的回传值为True，就将文件或目录名称列出到标准输出。格式为每列一个名称，每个名称之前皆有”./“字符串。 </li><li>-print0 　假设find指令的回传值为True，就将文件或目录名称列出到标准输出。格式为全部的名称皆在同一行。 </li><li>-printf&lt;输出格式&gt; 　假设find指令的回传值为True，就将文件或目录名称列出到标准输出。格式可以自行指定。 </li><li>-prune 　不寻找字符串作为寻找文件或目录的范本样式。 </li><li>-regex&lt;范本样式&gt; 　指定字符串作为寻找文件或目录的范本样式。 </li><li>-size&lt;文件大小&gt; 　查找符合指定的文件大小的文件。 </li><li>-true 　将find指令的回传值皆设为True。 </li><li>-typ&lt;文件类型&gt; 　只寻找符合指定的文件类型的文件。 </li><li>-uid&lt;用户识别码&gt; 　查找符合指定的用户识别码的文件或目录。 </li><li>-used&lt;日数&gt; 　查找文件或目录被更改之后在指定时间曾被存取过的文件或目录，单位以日计算。 </li><li>-user&lt;拥有者名称&gt; 　查找符合指定的拥有者名称的文件或目录。 </li><li>-version或–version 　显示版本信息。 </li><li>-xdev 　将范围局限在先行的文件系统中。 </li><li>-xtype&lt;文件类型&gt; 　此参数的效果和指定”-type”参数类似，差别在于它针对符号连接检查。</li></ul><h3 id="git-gnu-interactive-tools"><a href="#git-gnu-interactive-tools" class="headerlink" title="git(gnu interactive tools)"></a>git(gnu interactive tools)</h3><p>功能说明：文字模式下的文件管理员。 </p><p>语　　法：<code>git</code></p><p>补充说明：git是用来管理文件的程序，它十分类似DOS下的Norton Commander，具有互动式操作界面。它的操作方法和Norton Commander几乎一样，略诉如下： </p><pre><code>F1 ：执行info指令，查询指令相关信息，会要求您输入欲查询的名称。 F2 ：执行cat指令，列出文件内容。 F3 ：执行gitview指令，观看文件内容。 F4 ：执行vi指令，编辑文件内容。 F5 ：执行cp指令，复制文件或目录，会要求您输入目标文件或目录。 F6 ：执行mv指令，移动文件或目录，或是更改其名称，会要求您输入目标文件或目录。 F7 ：执行mkdir指令，建立目录。 F8 ：执行rm指令，删除文件或目录。 F9 ：执行make指令，批处理执行指令或编译程序时，会要求您输入相关命令。 F10 ：离开git文件管理员。</code></pre><h3 id="gitview-gnu-interactie-tools-viewer"><a href="#gitview-gnu-interactie-tools-viewer" class="headerlink" title="gitview(gnu interactie tools viewer)"></a>gitview(gnu interactie tools viewer)</h3><p>功能说明：Hex/ASCII的看文件程序。 </p><p>语　　法：<code>gitview [-bchilv][文件] </code></p><p>补充说明：gitview指令可用于观看文件的内容，它会同时显示十六进制和ASCII格式的字码。 </p><p>参　　数：</p><ul><li>-b 　单色模式，不使用ANSI控制码显示彩色。 </li><li>-c 　彩色模式，使用ANSI控制码显示色彩。 </li><li>-h 　在线帮助。 </li><li>-i 　显示存放gitview程序的所在位置。 </li><li>-l 　不使用先前的显示字符。 </li><li>-v 　显示版本信息。</li></ul><h3 id="ln-link"><a href="#ln-link" class="headerlink" title="ln(link)"></a>ln(link)</h3><p>功能说明：连接文件或目录。 </p><p>语　　法：<code>ln [-bdfinsv][-S &lt;字尾备份字符串&gt;][-V &lt;备份方式&gt;][–help][–version][源文件或目录][目标文件或目录] 或 ln [-bdfinsv][-S &lt;字尾备份字符串&gt;][-V &lt;备份方式&gt;][–help][–version][源文件或目录…][目的目录] </code></p><p>补充说明：ln指令用在连接文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则会把前面指定的所有文件或目录复制到该目录中。若同时指定多个文件或目录，且最后的目的地并非是一个已存在的目录，则会出现错误信息。 </p><p>参　　数：</p><ul><li>-b或–backup 　删除，覆盖目标文件之前的备份。 </li><li>-d或-F或–directory 　建立目录的硬连接。 </li><li>-f或–force 　强行建立文件或目录的连接，不论文件或目录是否存在。 </li><li>-i或–interactive 　覆盖既有文件之前先询问用户。 </li><li>-n或–no-dereference 　把符号连接的目的目录视为一般文件。 </li><li>-s或–symbolic 　对源文件建立符号连接，而非硬连接。 </li><li>-S&lt;字尾备份字符串&gt;或–suffix=&lt;字尾备份字符串&gt; 　用”-b”参数备份目标文件后，备份文件的字尾会被加上一个备份字符串，预设的字尾备份字符串是符号”~”，您可通过”-S”参数来改变它。 </li><li>-v或–verbose 　显示指令执行过程。 </li><li>-V&lt;备份方式&gt;或–version-control=&lt;备份方式&gt; 　用”-b”参数备份目标文件后，备份文件的字尾会被加上一个备份字符串，这个字符串不仅可用”-S”参数变更，当使用”-V”参数&lt;备份方式&gt;指定不同备份方式时，也会产生不同字尾的备份字符串。 </li><li>–help 　在线帮助。 </li><li>–version 　显示版本信息。</li></ul><h3 id="locate"><a href="#locate" class="headerlink" title="locate"></a><font color="red">locate</font></h3><p>功能说明：查找文件。 </p><p>语　　法：<code>locate [-d &lt;数据库文件&gt;][–help][–version][范本样式…]</code></p><p>补充说明：locate指令用于查找符合条件的文件，它会去保存文件与目录名称的数据库内，查找合乎范本样式条件的文件或目录。 </p><p>参　　数：</p><ul><li>-d&lt;数据库文件&gt;或–database=&lt;数据库文件&gt;  设置locate指令使用的数据库。locate指令预设的数据库位于/var/lib/slocate目录里，文件名为slocate.db，您可使用这个参数另行指定。 </li><li>–help 　在线帮助。 </li><li>–version 　显示版本信息。</li></ul><h3 id="lsattr-list-attribute"><a href="#lsattr-list-attribute" class="headerlink" title="lsattr(list attribute)"></a>lsattr(list attribute)</h3><p>功能说明：显示文件属性。 </p><p>语　　法：<code>lsattr [-adlRvV][文件或目录…]  </code></p><p>补充说明：用chattr执行改变文件或目录的属性，可执行lsattr指令查询其属性。 </p><p>参　　数：</p><ul><li>-a 　显示所有文件和目录，包括以”.”为名称开头字符的额外内建，现行目录”.”与上层目录”..”。 </li><li>-d 　显示，目录名称，而非其内容。 </li><li>-l 　此参数目前没有任何作用。 </li><li>-R 　递归处理，将指定目录下的所有文件及子目录一并处理。 </li><li>-v 　显示文件或目录版本。 </li><li>-V 　显示版本信息。</li></ul><h3 id="mattrib"><a href="#mattrib" class="headerlink" title="mattrib"></a>mattrib</h3><p>功能说明：变更或显示MS-DOS文件的属性。 </p><p>语　　法：<code>mattrib [+/-][ahrs][-/X][文件] 或 mattrib [-/X][文件] </code></p><p>补充说明：mattrib为mtools工具指令，模拟MS-DOS的attrib指令，可变更MS-DOS文件的属性。 </p><p>参　　数：</p><ul><li>+/- 　“+”代表开启指定的文件属性。”-“代表关闭指定的文件属性。 </li><li>a 　备份属性。使备份程序可用来判断文件是否已经备份过。 </li><li>h 　隐藏属性。 </li><li>r 　只读属性。 </li><li>s 　系统属性。 </li><li>-/ 　列出指定目录及子目录下所有文件的属性。 </li><li>-X 　显示文件属性时，中间不输入空格。</li></ul><h3 id="mc-midnight-commander"><a href="#mc-midnight-commander" class="headerlink" title="mc(midnight commander)"></a>mc(midnight commander)</h3><p>功能说明：提供一个菜单式的文件管理程序。</p><p>语　　法：<code>mc [-abcdfhkPstuUVx][-C &lt;参数&gt;][-l &lt;文件&gt;][-v &lt;文件&gt;][目录] </code></p><p>补充说明：执行mc之后，将会看到菜单式的文件管理程序，共分成４个部分。 </p><p>参　　数：</p><ul><li>-a 　当mc程序画线时不用绘图字符画线。 </li><li>-b 　使用单色模式显示。 </li><li>-c 　使用彩色模式显示。 </li><li>-C&lt;参数&gt; 　指定显示的颜色。 </li><li>-d 　不使用鼠标。 </li><li>-f 　显示mc函数库所在的目录。 </li><li>-h 　显示帮助。 </li><li>-k 　重设softkeys成预设置。 </li><li>-l&lt;文件&gt; 　在指定文件中保存ftpfs对话窗的内容。 </li><li>-P 　程序结束时，列出最后的工作目录。 </li><li>-s 　用慢速的终端机模式显示，在这模式下将减少大量的绘图及文字显示。 </li><li>-t 　使用TEMPCAP变量设置终端机，而不使用预设置。 </li><li>-u 　不用目前的shell程序。 </li><li>-U 　使用目前的shell程序。 </li><li>-v&lt;文件&gt; 　使用mc的内部编辑器来显示指定的文件。 </li><li>-V 　显示版本信息。 </li><li>-x 　指定以xterm模式显示。</li></ul><h3 id="mcopy"><a href="#mcopy" class="headerlink" title="mcopy"></a>mcopy</h3><p>功能说明：复制MS-DOS文件。</p><p>语　　法：<code>mcopy [-bnmpQt/][源文件][目标文件或目录]</code></p><p>补充说明：mcopy为mtools工具指令，可在MS-DOS文件系统中复制文件或是在MS-DOS与Linux的文件系统之间复制文件。mcopy会MS-DOS磁盘驱动器代号出现的位置来判断如何复制文件。</p><p>参　　数：</p><ul><li>-b 　批处理模式。 </li><li>-n 　覆盖其他文件时，不需进行确认而直接覆盖。 </li><li>-m 　将源文件修改时间设为目标文件的修改时间。 </li><li>-p 　将源文件属性设为目标文件的属性。 </li><li>-Q 　复制多个文件时，若发生错误，则立即结束程序。 </li><li>-t 　转换文本文件。 </li><li>-/ 　复制子目录以及其中的所有文件。</li></ul><h3 id="mdel"><a href="#mdel" class="headerlink" title="mdel"></a>mdel</h3><p>功能说明：删除MS-DOS文件。</p><p>语　　法：<code>mdel [文件…]</code></p><p>补充说明：mdel为mtools工具指令，模拟MS-DOS的del指令，可删除MS-DOS文件系统中的文件。</p><h3 id="mdir"><a href="#mdir" class="headerlink" title="mdir"></a>mdir</h3><p>功能说明：显示MS-DOS目录。</p><p>语　　法：<code>mdir [-afwx/][目录]</code></p><p>补充说明：mdir为mtools工具指令，模拟MS-DOS的dir指令，可显示MS-DOS文件系统中的目录内容。</p><p>参　　数：</p><ul><li>-/   显示目录下所有子目录与文件。 </li><li>-a 　显示隐藏文件。 </li><li>-f 　不显示磁盘所剩余的可用空间。 </li><li>-w 　仅显示目录或文件名称，并以横排方式呈现，以便一次能显示较多的目录或文件。 </li><li>-X 　仅显示目录下所有子目录与文件的完整路径，不显示其他信息。</li></ul><h3 id="mktemp"><a href="#mktemp" class="headerlink" title="mktemp"></a>mktemp</h3><p>功能说明：建立暂存文件。</p><p>语　　法：<code>mktemp [-qu][文件名参数]</code></p><p>补充说明：mktemp可建立一个暂存文件，供shell script使用。</p><p>参　　数：</p><ul><li>-q 　执行时若发生错误，不会显示任何信息。 </li><li><p>-u 　暂存文件会在mktemp结束前先行删除。 </p><p>  　[文件名参数] 　文件名参数必须是以”自订名称.XXXXXX”的格式。</p></li></ul><h3 id="mmove"><a href="#mmove" class="headerlink" title="mmove"></a>mmove</h3><p>功能说明：在MS-DOS文件系统中，移动文件或目录，或更改名称。</p><p>语　　法：<code>mmove [源文件或目录…][目标文件或目录]</code></p><p>补充说明：mmove为mtools工具指令，模拟MS-DOS的move指令，可在MS-DOS文件系统中移动现有的文件或目录，或是更改现有文件或目录的名称。</p><h3 id="mread"><a href="#mread" class="headerlink" title="mread"></a>mread</h3><p>功能说明：将MS-DOS文件复制到Linux/Unix的目录中。</p><p>语　　法：<code>mread [MS-DOS文件…][Linux文件或目录]</code></p><p>补充说明：mread为mtools工具指令，可将MS-DOS文件复制到Linux的文件系统中。这个指令目前已经不常用，一般都使用mcopy指令来代替。</p><h3 id="mren"><a href="#mren" class="headerlink" title="mren"></a>mren</h3><p>功能说明：更改MS-DOS文件或目录的名称，或是移动文件或目录。</p><p>语　　法：<code>mren [源文件或目录…][目标文件或目录]</code></p><p>补充说明：mren为MS-DOS工具指令，模拟MS-DOS的ren指令，可更改MS-DOS文件或目录名称。除此之外，ren也可移动文件或目录，但仅限于在同一设备内。</p><h3 id="mshowfat"><a href="#mshowfat" class="headerlink" title="mshowfat"></a>mshowfat</h3><p>功能说明：显示MS-DOS文件在FAT中的记录。</p><p>语　　法：<code>mshowfat [文件…]</code></p><p>补充说明：mshowfat为mtools工具指令，可显示MS-DOS文件在FAT中的记录编号。</p><h3 id="mtools"><a href="#mtools" class="headerlink" title="mtools"></a>mtools</h3><p>功能说明：显示mtools支持的指令。</p><p>语　　法：<code>mtools</code></p><p>补充说明：mtools为MS-DOS文件系统的工具程序，可模拟许多MS-DOS的指令。这些指令都是mtools的符号连接，因此会有一些共同的特性。</p><p>参　　数：</p><ul><li>-a 　长文件名重复时自动更改目标文件的长文件名。 </li><li>-A 　短文件名重复但长文件名不同时自动更改目标文件的短文件名。 </li><li>-o 　长文件名重复时，将目标文件覆盖现有的文件。 </li><li>-O 　短文件名重复但长文件名不同时，将目标文件覆盖现有的文件。 </li><li>-r 　长文件名重复时，要求用户更改目标文件的长文件名。 </li><li>-R 　短文件名重复但长文件名煌保笥没Ц哪勘晡募亩涛募?nbsp;</li><li>-s 　长文件名重复时，则不处理该目标文件。 </li><li>-S 　短文件名重复但长文件名不同时，则不处理该目标文件。 </li><li>-v 　执行时显示详细的说明。 </li><li>-V 　显示版本信息。</li></ul><h3 id="mtoolstest"><a href="#mtoolstest" class="headerlink" title="mtoolstest"></a>mtoolstest</h3><p>功能说明：测试并显示mtools的相关设置。</p><p>语　　法：<code>mtoolstest</code></p><p>补充说明：mtoolstest为mtools工具指令，可读取与分析mtools的配置文件，并在屏幕上显示结果</p><h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a><font color="red">mv</font></h3><p>功能说明：移动或更名现有的文件或目录。</p><p>语　　法：<code>mv [-bfiuv][–help][–version][-S &lt;附加字尾&gt;][-V &lt;方法&gt;][源文件或目录][目标文件或目录]</code></p><p>补充说明：mv可移动文件或目录，或是更改文件或目录的名称。</p><p>参　　数：</p><ul><li>-b或–backup 　若需覆盖文件，则覆盖前先行备份。 </li><li>-f或–force 　若目标文件或目录与现有的文件或目录重复，则直接覆盖现有的文　件或目录。 </li><li>-i或–interactive 　覆盖前先行询问用户。 </li><li>-S&lt;附加字尾&gt;或</li><li>–suffix=&lt;附加字尾&gt; 　与-b参数一并使用，可指定备份文件的所要附加的字尾。 </li><li>-u或–update 　在移动或更改文件名时，若目标文件已存在，且其文件日期比源文件新，则不覆盖目标文件。 </li><li>-v或–verbose 　执行时显示详细的信息。 </li><li>-V=&lt;方法&gt;或</li><li>–version-control=&lt;方法&gt; 　与-b参数一并使用，可指定备份的方法。 </li><li>–help 　显示帮助。 </li><li>–version 　显示版本信息。</li></ul><h3 id="od-octal-dump"><a href="#od-octal-dump" class="headerlink" title="od(octal dump)"></a>od(octal dump)</h3><p>功能说明：输出文件内容。</p><p>语　　法：<code>od [-abcdfhilovx][-A &lt;字码基数&gt;][-j &lt;字符数目&gt;][-N &lt;字符数目&gt;][-s &lt;字符串字符数&gt;][-t &lt;输出格式&gt;][-w &lt;每列字符数&gt;][–help][–version][文件…]</code></p><p>补充说明：od指令会读取所给予的文件的内容，并将其内容以八进制字码呈现出来。</p><p>参　　数：</p><ul><li>-a 　此参数的效果和同时指定”-ta”参数相同。 </li><li>-A&lt;字码基数&gt; 　选择要以何种基数计算字码。 </li><li>-b 　此参数的效果和同时指定”-toC”参数相同。 </li><li>-c 　此参数的效果和同时指定”-tC”参数相同。 </li><li>-d 　此参数的效果和同时指定”-tu2”参数相同。 </li><li>-f 　此参数的效果和同时指定”-tfF”参数相同。 </li><li>-h 　此参数的效果和同时指定”-tx2”参数相同。 </li><li>-i 　此参数的效果和同时指定”-td2”参数相同。 </li><li>-j&lt;字符数目&gt;或–skip-bytes=&lt;字符数目&gt; 　略过设置的字符数目。 </li><li>-l 　此参数的效果和同时指定”-td4”参数相同。 </li><li>-N&lt;字符数目&gt;或–read-bytes=&lt;字符数目&gt; 　到设置的字符数目为止。 </li><li>-o 　此参数的效果和同时指定”-to2”参数相同。 </li><li>-s&lt;字符串字符数&gt;或–strings=&lt;字符串字符数&gt; 　只显示符合指定的字符数目的字符串。 </li><li>-t&lt;输出格式&gt;或–format=&lt;输出格式&gt; 　设置输出格式。 </li><li>-v或–output-duplicates 　输出时不省略重复的数据。 </li><li>-w&lt;每列字符数&gt;或–width=&lt;每列字符数&gt; 　设置每列的最大字符数。 </li><li>-x 　此参数的效果和同时指定”-h”参数相同。 </li><li>–help 　在线帮助。 </li><li>–version 　显示版本信息。</li></ul><h3 id="paste"><a href="#paste" class="headerlink" title="paste"></a>paste</h3><p>功能说明：合并文件的列。</p><p>语　　法：<code>paste [-s][-d &lt;间隔字符&gt;][–help][–version][文件…]</code></p><p>补充说明：paste指令会把每个文件以列对列的方式，一列列地加以合并。</p><p>参　　数：</p><ul><li>-d&lt;间隔字符&gt;或–delimiters=&lt;间隔字符&gt; 　用指定的间隔字符取代跳格字符。 </li><li>-s或–serial 　串列进行而非平行处理。 </li><li>–help 　在线帮助。 </li><li>–version 　显示帮助信息。</li></ul><h3 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h3><p>功能说明：修补文件。</p><p>语　　法：<code>patch [-bceEflnNRstTuvZ][-B &lt;备份字首字符串&gt;][-d &lt;工作目录&gt;][-D &lt;标示符号&gt;][-F &lt;监别列数&gt;][-g &lt;控制数值&gt;][-i &lt;修补文件&gt;][-o &lt;输出文件&gt;][-p &lt;剥离层级&gt;][-r &lt;拒绝文件&gt;][-V &lt;备份方式&gt;][-Y &lt;备份字首字符串&gt;][-z &lt;备份字尾字符串&gt;][–backup-if　　 -mismatch][–binary][–help][–nobackup-if-mismatch][–verbose][原始文件 &lt;修补文件&gt;] 或 path [-p &lt;剥离层级&gt;] &lt; [修补文件]</code></p><p>补充说明：patch指令让用户利用设置修补文件的方式，修改，更新原始文件。倘若一次仅修改一个文件，可直接在指令列中下达指令依序执行。如果配合修补文件的方式则能一次修补大批文件，这也是Linux系统核心的升级方法之一。</p><p>参　　数：</p><ul><li>-b或–backup 　备份每一个原始文件。 </li><li>-B&lt;备份字首字符串&gt;或–prefix=&lt;备份字首字符串&gt; 　设置文件备份时，附加在文件名称前面的字首字符串，该字符串可以是路径名称。 </li><li>-c或–context 　把修补数据解译成关联性的差异。 </li><li>-d&lt;工作目录&gt;或–directory=&lt;工作目录&gt; 　设置工作目录。 </li><li>-D&lt;标示符号&gt;或–ifdef=&lt;标示符号&gt; 　用指定的符号把改变的地方标示出来。 </li><li>-e或–ed 　把修补数据解译成ed指令可用的叙述文件。 </li><li>-E或–remove-empty-files 　若修补过后输出的文件其内容是一片空白，则移除该文件。 </li><li>-f或–force 　此参数的效果和指定”-t”参数类似，但会假设修补数据的版本为新　版本。 </li><li>-F&lt;监别列数&gt;或–fuzz&lt;监别列数&gt; 　设置监别列数的最大值。 </li><li>-g&lt;控制数值&gt;或–get=&lt;控制数值&gt; 　设置以RSC或SCCS控制修补作业。 </li><li>-i&lt;修补文件&gt;或–input=&lt;修补文件&gt; 　读取指定的修补问家你。 </li><li>-l或–ignore-whitespace 　忽略修补数据与输入数据的跳格，空格字符。 </li><li>-n或–normal 　把修补数据解译成一般性的差异。 </li><li>-N或–forward 　忽略修补的数据较原始文件的版本更旧，或该版本的修补数据已使　用过。 </li><li>-o&lt;输出文件&gt;或–output=&lt;输出文件&gt; 　设置输出文件的名称，修补过的文件会以该名称存放。 </li><li>-p&lt;剥离层级&gt;或–strip=&lt;剥离层级&gt; 　设置欲剥离几层路径名称。 </li><li>-f&lt;拒绝文件&gt;或–reject-file=&lt;拒绝文件&gt; 　设置保存拒绝修补相关信息的文件名称，预设的文件名称为.rej。 </li><li>-R或–reverse 　假设修补数据是由新旧文件交换位置而产生。 </li><li>-s或–quiet或–silent 　不显示指令执行过程，除非发生错误。 </li><li>-t或–batch 　自动略过错误，不询问任何问题。 </li><li>-T或–set-time 　此参数的效果和指定”-Z”参数类似，但以本地时间为主。 </li><li>-u或–unified 　把修补数据解译成一致化的差异。 </li><li>-v或–version 　显示版本信息。 </li><li>-V&lt;备份方式&gt;或–version-control=&lt;备份方式&gt; 　用”-b”参数备份目标文件后，备份文件的字尾会被加上一个备份字符串，这个字符串不仅可用”-z”参数变更，当使用”-V”参数指定不同备份方式时，也会产生不同字尾的备份字符串。</li><li>-Y&lt;备份字首字符串&gt;或–basename-prefix=–&lt;备份字首字符串&gt; 　设置文件备份时，附加在文件基本名称开头的字首字符串。</li><li>-z&lt;备份字尾字符串&gt;或–suffix=&lt;备份字尾字符串&gt; 　此参数的效果和指定”-B”参数类似，差别在于修补作业使用的路径与文件名若为src/linux/fs/super.c，加上”backup/“字符串后，文件super.c会备份于/src/linux/fs/backup目录里。 </li><li>-Z或–set-utc 　把修补过的文件更改，存取时间设为UTC。 </li><li>–backup-if-mismatch 　在修补数据不完全吻合，且没有刻意指定要备份文件时，才备份文件。 </li><li>–binary 　以二进制模式读写数据，而不通过标准输出设备。 </li><li>–help 　在线帮助。 </li><li>–nobackup-if-mismatch 　在修补数据不完全吻合，且没有刻意指定要备份文件时，不要备份文件。 </li><li>–verbose 　详细显示指令的执行过程。</li></ul><h3 id="rcp-remote-copy"><a href="#rcp-remote-copy" class="headerlink" title="rcp(remote copy)"></a>rcp(remote copy)</h3><p>功能说明：远端复制文件或目录。</p><p>语　　法：<code>rcp [-pr][源文件或目录][目标文件或目录] 或 rcp [-pr][源文件或目录…][目标文件] </code></p><p>补充说明：rcp指令用在远端复制文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则它灰把前面指定的所有文件或目录复制到该目录中。</p><p>参　　数：</p><ul><li>-p 　保留源文件或目录的属性，包括拥有者，所属群组，权限与时间。 </li><li>-r 　递归处理，将指定目录下的文件与子目录一并处理。</li></ul><h3 id="rhmask"><a href="#rhmask" class="headerlink" title="rhmask"></a>rhmask</h3><p>功能说明：产生与还原加密文件。</p><p>语　　法：<code>rhmask [加密文件][输出文件] 或 rhmask [-d][加密文件][源文件][输出文件]</code></p><p>补充说明：执行rhmask指令可制作加密过的文件，方便用户在公开的网络上传输该文件，而不至于被任意盗用。</p><p>参　　数：</p><ul><li>-d 　产生加密过的文件。</li></ul><h3 id="rm-remove"><a href="#rm-remove" class="headerlink" title="rm(remove)"></a><font color="red">rm(remove)</font></h3><p>功能说明：删除文件或目录。</p><p>语　　法：<code>rm [-dfirv][–help][–version][文件或目录…]</code></p><p>补充说明：执行rm指令可删除文件或目录，如欲删除目录必须加上参数”-r”，否则预设仅会删除文件。 </p><p>参　　数：</p><ul><li>-d或–directory 　直接把欲删除的目录的硬连接数据删成0，删除该目录。 </li><li>-f或–force 　强制删除文件或目录。 </li><li>-i或–interactive 　删除既有文件或目录之前先询问用户。 </li><li>-r或-R或–recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。 </li><li>-v或–verbose 　显示指令执行过程。 </li><li>–help 　在线帮助。 </li><li>–version 　显示版本信息。</li></ul><h3 id="slocate-secure-locate"><a href="#slocate-secure-locate" class="headerlink" title="slocate(secure locate)"></a>slocate(secure locate)</h3><p>功能说明：查找文件或目录。</p><p>语　　法：<code>slocate [-u][–help][–version][-d &lt;目录&gt;][查找的文件]</code></p><p>补充说明：slocate本身具有一个数据库，里面存放了系统中文件与目录的相关信息。</p><p>参　　数：</p><ul><li>-d&lt;目录&gt;或–database=&lt;目录&gt; 　指定数据库所在的目录。 </li><li>-u 　更新slocate数据库。 </li><li>–help 　显示帮助。 </li><li>–version 　显示版本信息。</li></ul><h3 id="split"><a href="#split" class="headerlink" title="split"></a>split</h3><p>功能说明：切割文件。</p><p>语　　法：<code>split [–help][–version][-&lt;行数&gt;][-b &lt;字节&gt;][-C &lt;字节&gt;][-l &lt;行数&gt;][要切割的文件][输出文件名]</code></p><p>补充说明：split可将文件切成较小的文件，预设每1000行会切成一个小文件。</p><p>参　　数：</p><ul><li>-&lt;行数&gt;或-l&lt;行数&gt; 　指定每多少行就要切成一个小文件。 </li><li>-b&lt;字节&gt; 　指定每多少字就要切成一个小文件。 </li><li>-C&lt;字节&gt; 　与-b参数类似，但切割时尽量维持每行的完整性。 </li><li>–help 　显示帮助。 </li><li>–version 　显示版本信息。<br>　<br>  [输出文件名] 　设置切割后文件的前置文件名，split会自动在前置文件名后再加上编号。</li></ul><h3 id="tee"><a href="#tee" class="headerlink" title="tee"></a>tee</h3><p>功能说明：读取标准输入的数据，并将其内容输出成文件。</p><p>语　　法：<code>tee [-ai][–help][–version][文件…]</code></p><p>补充说明：tee指令会从标准输入设备读取数据，将其内容输出到标准输出设备，同时保存成文件。</p><p>参　　数：</p><ul><li>-a或–append 　附加到既有文件的后面，而非覆盖它． </li><li>-i-i或–ignore-interrupts 　忽略中断信号。 </li><li>–help 　在线帮助。 </li><li>–version 　显示版本信息。</li></ul><h3 id="tmpwatch-temporary-watch"><a href="#tmpwatch-temporary-watch" class="headerlink" title="tmpwatch(temporary watch)"></a>tmpwatch(temporary watch)</h3><p>功能说明：删除暂存文件。</p><p>语　　法：<code>tmpwatch [-afqv][–test][超期时间][目录…]</code></p><p>补充说明：执行tmpwatch指令可删除不必要的暂存文件，您可以设置文件超期时间，单位以小时计算。</p><p>参　　数：</p><ul><li>-a或–all 　删除任何类型的文件。 </li><li>-f或–force 　强制删除文件或目录，其效果类似rm指令的”-f”参数。 </li><li>-q或–quiet 　不显示指令执行过程。 </li><li>-v或–verbose 　详细显示指令执行过程。 </li><li>-test 　仅作测试，并不真的删除文件或目录。</li></ul><h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><p>功能说明：改变文件或目录时间。</p><p>语　　法：<code>touch [-acfm][-d &lt;日期时间&gt;][-r &lt;参考文件或目录&gt;][-t &lt;日期时间&gt;][–help]　　 [–version][文件或目录…] 或 touch [-acfm][–help][–version][日期时间][文件或目录…] </code></p><p>补充说明：使用touch指令可更改文件或目录的日期时间，包括存取时间和更改时间。</p><p>参　　数：</p><ul><li>-a或–time=atime或–time=access或–time=use 　只更改存取时间。 </li><li>-c或–no-create 　不建立任何文件。 </li><li>-d&lt;时间日期&gt; 　使用指定的日期时间，而非现在的时间。 </li><li>-f 　此参数将忽略不予处理，仅负责解决BSD版本touch指令的兼容性问题。 </li><li>-m或–time=mtime或–time=modify 　只更改变动时间。 </li><li>-r&lt;参考文件或目录&gt; 　把指定文件或目录的日期时间，统统设成和参考文件或目录的日期时间相同。 </li><li>-t&lt;日期时间&gt; 　使用指定的日期时间，而非现在的时间。 </li><li>–help 　在线帮助。 </li><li>–version 　显示版本信息。</li></ul><h3 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h3><p>功能说明：指定在建立文件时预设的权限掩码。</p><p>语　　法：<code>umask [-S][权限掩码]</code></p><p>补充说明：umask可用来设定[权限掩码]。[权限掩码]是由3个八进制的数字所组成，将现有的存取权限减掉权限掩码后，即可产生建立文件时预设的权限。</p><p>参　　数：</p><ul><li>-S 　以文字的方式来表示权限掩码。</li></ul><h3 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h3><p>功能说明：查找文件。</p><p>语　　法：<code>whereis [-bfmsu][-B &lt;目录&gt;…][-M &lt;目录&gt;…][-S &lt;目录&gt;…][文件…]</code></p><p>补充说明：whereis指令会在特定目录中查找符合条件的文件。这些文件的烈性应属于原始代码，二进制文件，或是帮助文件。</p><p>参　　数：</p><ul><li>-b 　只查找二进制文件。 </li><li>-B&lt;目录&gt; 　只在设置的目录下查找二进制文件。 </li><li>-f 　不显示文件名前的路径名称。 </li><li>-m 　只查找说明文件。 </li><li>-M&lt;目录&gt; 　只在设置的目录下查找说明文件。 </li><li>-s 　只查找原始代码文件。 </li><li>-S&lt;目录&gt; 　只在设置的目录下查找原始代码文件。 </li><li>-u 　查找不包含指定类型的文件。</li></ul><h3 id="which"><a href="#which" class="headerlink" title="which"></a>which</h3><p>功能说明：查找文件。</p><p>语　　法：<code>which [文件…]</code></p><p>补充说明：which指令会在环境变量$PATH设置的目录里查找符合条件的文件。</p><p>参　　数：</p><ul><li>-n&lt;文件名长度&gt; 　指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。 </li><li>-p&lt;文件名长度&gt; 　与-n参数相同，但此处的&lt;文件名长度&gt;包括了文件的路径。 </li><li>-w 　指定输出时栏位的宽度。 </li><li>-V 　显示版本信息。</li></ul><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a><font color="red">cat</font></h3><p>使用权限：所有使用者 </p><p>使用方式：<code>cat [-AbeEnstTuv] [–help] [–version] fileName </code></p><p>说明：把档案串连接后传到基本输出（萤幕或加 &gt; fileName 到另一个档案）</p><p>参数：</p><ul><li>-n 或 –number 由 1 开始对所有输出的行数编号</li><li>-b 或 –number-nonblank 和 -n 相似，只不过对于空白行不编号</li><li>-s 或 –squeeze-blank 当遇到有连续两行以上的空白行，就代换为一行的空白行</li><li>-v 或 –show-nonprinting</li></ul><p>范例：</p><pre><code>cat -n textfile1 &amp;gt; textfile2 把 textfile1 的档案内容加上行号后输入 textfile2 这个档案里cat -b textfile1 textfile2 &amp;gt;&amp;gt; textfile3 把 textfile1 和 textfile2 的档案内容加上行号（空白行不加）之后将内容附加到 textfile3 里。</code></pre><h3 id="chattr-change-attribute"><a href="#chattr-change-attribute" class="headerlink" title="chattr(change attribute)"></a>chattr(change attribute)</h3><p>功能说明：改变文件属性。</p><p>语　　法：<code>chattr [-RV][-v&lt;版本编号&gt;][+/-/=&lt;属性&gt;][文件或目录…]</code></p><p>补充说明：这项指令可改变存放在ext2文件系统上的文件或目录属性，这些属性共有以下8种模式： </p><pre><code>　a：让文件或目录仅供附加用途。 　b：不更新文件或目录的最后存取时间。 　c：将文件或目录压缩后存放。 　d：将文件或目录排除在倾倒操作之外。 　i：不得任意更动文件或目录。 　s：保密性删除文件或目录。 　S：即时更新文件或目录。 　u：预防以外删除。 </code></pre><p>参　　数：</p><ul><li>-R  递归处理，将指定目录下的所有文件及子目录一并处理。 </li><li>-v&lt;版本编号&gt;  设置文件或目录版本。 </li><li>-V  显示指令执行过程。 </li><li>+&lt;属性&gt;  开启文件或目录的该项属性。 </li><li>-&lt;属性&gt;  关闭文件或目录的该项属性。 </li><li>=&lt;属性&gt;  指定文件或目录的该项属性。</li></ul><h3 id="chgrp-change-group"><a href="#chgrp-change-group" class="headerlink" title="chgrp(change group)"></a>chgrp(change group)</h3><p>功能说明：变更文件或目录的所属群组。</p><p>语　　法：<code>chgrp [-cfhRv][–help][–version][所属群组][文件或目录…] 或 chgrp [-cfhRv][–help][–reference=&lt;参考文件或目录&gt;][–version][文件或目录…] </code></p><p>补充说明：在UNIX系统家族里，文件或目录权限的掌控以拥有者及所属群组来管理。您可以使用chgrp指令去变更文件与目录的所属群组，设置方式采用群组名称或群组识别码皆可。 </p><p>参　　数：</p><ul><li>-c或–changes  效果类似”-v”参数，但仅回报更改的部分。 </li><li>-f或–quiet或–silent 　不显示错误信息。 </li><li>-h或–no-dereference 　只对符号连接的文件作修改，而不更动其他任何相关文件。 </li><li>-R或–recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。 </li><li>-v或–verbose 　显示指令执行过程。 </li><li>–help 　在线帮助。 </li><li>–reference=&lt;参考文件或目录&gt; 　把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同。 </li><li>–version 　显示版本信息。</li></ul><h3 id="chmod-change-mode"><a href="#chmod-change-mode" class="headerlink" title="chmod(change mode)"></a><font color="red">chmod(change mode)</font></h3><p>功能说明：变更文件或目录的权限。</p><p>语　　法：<code>chmod [-cfRv][–help][–version][&lt;权限范围&gt;+/-/=&lt;权限设置…&gt;][文件或目录…] 或 chmod [-cfRv][–help][–version][数字代号][文件或目录…] 或 chmod [-cfRv][–help][–reference=&lt;参考文件或目录&gt;][–version][文件或目录…] </code></p><p>补充说明：在UNIX系统家族里，文件或目录权限的控制分别以读取，写入，执行3种一般权限来区分，另有3种特殊权限可供运用，再搭配拥有者与所属群组管理权限范围。您可以使用chmod指令去变更文件与目录的权限，设置方式采用文字或数字代号皆可。符号连接的权限无法变更，如果您对符号连接修改权限，其改变会作用在被连接的原始文件。权限范围的表示法如下： </p><pre><code>　u：User，即文件或目录的拥有者。 　g：Group，即文件或目录的所属群组。 　o：Other，除了文件或目录拥有者或所属群组之外，其他用户皆属于这个范围。 　a：All，即全部的用户，包含拥有者，所属群组以及其他用户。  　有关权限代号的部分，列表于下： 　r：读取权限，数字代号为&quot;4&quot;。 　w：写入权限，数字代号为&quot;2&quot;。 　x：执行或切换权限，数字代号为&quot;1&quot;。 　-：不具任何权限，数字代号为&quot;0&quot;。 　s：特殊?b&amp;gt;功能说明：变更文件或目录的权限。</code></pre><p>参　　数：</p><ul><li>-c或–changes 　效果类似”-v”参数，但仅回报更改的部分。 </li><li>-f或–quiet或–silent 　不显示错误信息。 </li><li>-R或–recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。 </li><li>-v或–verbose 　显示指令执行过程。 </li><li>–help 　在线帮助。 </li><li>–reference=&lt;参考文件或目录&gt; 　把指定文件或目录的权限全部设成和参考文件或目录的权限相同 </li><li><p>–version 　显示版本信息。 </p><p>  　&lt;权限范围&gt;+&lt;权限设置&gt; 　开启权限范围的文件或目录的该项权限设置。<br>  　&lt;权限范围&gt;-&lt;权限设置&gt; 　关闭权限范围的文件或目录的该项权限设置。<br>  　&lt;权限范围&gt;=&lt;权限设置&gt; 　指定权限范围的文件或目录的该项权限设置。<br>   如chmod a+x …</p></li></ul><h3 id="chown-change-owner"><a href="#chown-change-owner" class="headerlink" title="chown(change owner)"></a><font color="red">chown(change owner)</font></h3><p>功能说明：变更文件或目录的拥有者或所属群组。</p><p>语　　法：<code>chown [-cfhRv][–dereference][–help][–version][拥有者.&lt;所属群组&gt;][文件或目录..] 或chown [-chfRv][–dereference][–help][–version][.所属群组][文件或目录… …] 或chown [-cfhRv][–dereference][–help][–reference=&lt;参考文件或目录&gt;][–version][文件或目录…] </code></p><p>补充说明：在UNIX系统家族里，文件或目录权限的掌控以拥有者及所属群组来管理。您可以使用chown指令去变更文件与目录的拥有者或所属群组，设置方式采用用户名称或用户识别码皆可，设置群组则用群组名称或群组识别码。 </p><p>参　　数：</p><ul><li>-c或–changes 　效果类似”-v”参数，但仅回报更改的部分。 </li><li>-f或–quite或–silent 　不显示错误信息。 </li><li>-h或–no-dereference 　之对符号连接的文件作修改，而不更动其他任何相关文件。 </li><li>-R或–recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。 </li><li>-v或–version 　显示指令执行过程。 </li><li>–dereference 　效果和”-h”参数相同。 </li><li>–help 　在线帮助。 </li><li>–reference=&lt;参考文件或目录&gt; 　把指定文件或目录的拥有者与所属群组全部设成和参考文件或目　录的拥有者与所属群组相同。 </li><li>–version 　显示版本信息。</li></ul><h3 id="cksum-check-sum"><a href="#cksum-check-sum" class="headerlink" title="cksum(check sum)"></a>cksum(check sum)</h3><p>功能说明：检查文件的CRC是否正确。 </p><p>语　　法：<code>cksum [–help][–version][文件…] </code> </p><p>补充说明：CRC是一种排错检查方式，该演算法的标准由CCITT所指定，至少可检测到99.998%的已知错误。指定文件交由cksum演算，它会回报计算结果，供用户核对文件是否正确无误。若不指定任何文件名称或是所给予的文件名为”-“，则cksum指令会从标准输入设备读取数据。 </p><p>参　　数：</p><ul><li>–help 　在线帮助。 </li><li>–version 　显示版本信息。</li></ul><h3 id="cmp-compare"><a href="#cmp-compare" class="headerlink" title="cmp(compare)"></a>cmp(compare)</h3><p>功能说明：比较两个文件是否有差异。</p><p>语　　法：<code>cmp [-clsv][-i &lt;字符数目&gt;][–help][第一个文件][第二个文件]</code></p><p>补充说明：当相互比较的两个文件完全一样时，则该指令不会显示任何信息。若发现有所差异，预设会标示出第一个不同之处的字符和列数编号。若不指定任何文件名称或是所给予的文件名为”-“，则cmp指令会从标准输入设备读取数据。</p><p>参　　数：</p><ul><li>-c或–print-chars 　除了标明差异处的十进制字码之外，一并显示该字符所对应字符。 </li><li>-i&lt;字符数目&gt;或–ignore-initial=&lt;字符数目&gt; 　指定一个数目。 </li><li>-l或–verbose 　标示出所有不一样的地方。 </li><li>-s或–quiet或–silent 　不显示错误信息。 </li><li>-v或–version 　显示版本信息。 </li><li>–help 　在线帮助。</li></ul><h3 id="cp-copy"><a href="#cp-copy" class="headerlink" title="cp(copy)"></a><font color="red">cp(copy)</font></h3><p>功能说明：复制文件或目录。 </p><p>语　　法：<code>cp [-abdfilpPrRsuvx][-S &lt;备份字尾字符串&gt;][-V &lt;备份方式&gt;][–help][–spares=&lt;使用时机&gt;][–version][源文件或目录][目标文件或目录] [目的目录] </code></p><p>补充说明：cp指令用在复制文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则它会把前面指定的所有文件或目录复制到该目录中。若同时指定多个文件或目录，而最后的目的地并非是一个已存在的目录，则会出现错误信息。</p><p>参　　数：</p><ul><li>-a或–archive 　此参数的效果和同时指定”-dpR”参数相同。 </li><li>-b或–backup 　删除，覆盖目标文件之前的备份，备份文件会在字尾加上一个备份字符串。 </li><li>-d或–no-dereference 　当复制符号连接时，把目标文件或目录也建立为符号连接，并指向与源文件或目录连接的原始文件或目录。 </li><li>-f或–force 　强行复制文件或目录，不论目标文件或目录是否已存在。 </li><li>-i或–interactive 　覆盖既有文件之前先询问用户。 </li><li>-l或–link 　对源文件建立硬连接，而非复制文件。 </li><li>-p或–preserve 　保留源文件或目录的属性。 </li><li>-P或–parents 　保留源文件或目录的路径。 </li><li>-r 　递归处理，将指定目录下的文件与子目录一并处理。 </li><li>-R或–recursive 　递归处理，将指定目录下的所有文件与子目录一并处理。 </li><li>-s或–symbolic-link 　对源文件建立符号连接，而非复制文件。 </li><li>-S&lt;备份字尾字符串&gt;或–suffix=&lt;备份字尾字符串&gt; 　用”-b”参数备份目标文件后，备份文件的字尾会被加上一个备份字符串，预设的备份字尾字符串是符号”~”。 </li><li>-u或–update 　使用这项参数后只会在源文件的更改时间较目标文件更新时或是　名称相互对应的目标文件并不存在，才复制文件。 </li><li>-v或–verbose 　显示指令执行过程。 </li><li>-V&lt;备份方式&gt;或–version-control=&lt;备份方式&gt; 　用”-b”参数备份目标文件后，备份文件的字尾会被加上一个备份字符串，这字符串不仅可用”-S”参数变更，当使用”-V”参数指定不同备份方式时，也会产生不同字尾的备份字串。  </li><li>-x或–one-file-system 　复制的文件或目录存放的文件系统，必须与cp指令执行时所处的文件系统相同，否则不予复制。 </li><li>–help 　在线帮助。 </li><li>–sparse=&lt;使用时机&gt; 　设置保存稀疏文件的时机。 </li><li>–version 　显示版本信息。</li></ul><h3 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h3><p>使用权限：所有使用者</p><p>用法：<code>cut -cnum1-num2 filename</code></p><p>说明：显示每行从开头算起 num1 到 num2 的文字。</p><p>范例：</p><pre><code>shell&amp;gt;&amp;gt; cat exampletest2this is test1shell&amp;gt;&amp;gt; cut -c0-6 example       ## print 开头算起前 6 个字元test2this i </code></pre><h3 id="indent"><a href="#indent" class="headerlink" title="indent"></a>indent</h3><p>功能说明：调整C原始代码文件的格式。</p><p>语　　法：<code>indent [参数][源文件] 或 indent [参数][源文件][-o 目标文件]</code></p><p>补充说明：indent可辨识C的原始代码文件，并加以格式化，以方便程序设计师阅读。 </p><p>参　　数：</p><ul><li>-bad或–blank-lines-after-declarations  　在声明区段或加上空白行。 </li><li>-bap或–blank-lines-after-procedures 　在程序或加上空白行。 </li><li>-bbb或–blank-lines-after-block-comments 　在注释区段后加上空白行。 </li><li>-bc或–blank-lines-after-commas  　在声明区段中，若出现逗号即换行。 </li><li>-bl或–braces-after-if-line 　if(或是else,for等等)与后面执行区段的”{“不同行，且”}”自成一行。 </li><li>-bli&lt;缩排格数&gt;或–brace-indent&lt;缩排格数&gt; 　设置{ }缩排的格数。 </li><li>-br或–braces-on-if-line 　if(或是else,for等等)与后面执行跛段的”{“不同行，且”}”自成一行。 </li><li>-bs或–blank-before-sizeof 　在sizeof之后空一格。 </li><li>-c&lt;栏数&gt;或–comment-indentation&lt;栏数&gt; 　将注释置于程序码右侧指定的栏位。 </li><li>-cd&lt;栏数&gt;或–declaration-comment-column&lt;栏数&gt; 　将注释置于声明右侧指定的栏位。 </li><li>-cdb或–comment-delimiters-on-blank-lines 　注释符号自成一行。 </li><li>-ce或–cuddle-else 　将else置于”}”(if执行区段的结尾)之后。 </li><li>-ci&lt;缩排格数&gt;或–continuation-indentation&lt;缩排格数&gt; 　叙述过长而换行时，指定换行后缩排的格数。 </li><li>-cli&lt;缩排格数&gt;或–case-indentation-&lt;缩排格数&gt; 　使用case时，switch缩排的格数。 </li><li>-cp&lt;栏数&gt;或-else-endif-column&lt;栏数&gt; 　将注释置于else与elseif叙述右侧定的栏位。 </li><li>-cs或–space-after-cast 　在cast之后空一格。 </li><li>-d&lt;缩排格数&gt;或-line-comments-indentation&lt;缩排格数&gt; 　针对不是放在程序码右侧的注释，设置其缩排格数。 </li><li>-di&lt;栏数&gt;或–declaration-indentation&lt;栏数&gt; 　将声明区段的变量置于指定的栏位。 </li><li>-fc1或–format-first-column-comments 　针对放在每行最前端的注释，设置其格式。 </li><li>-fca或–format-all-comments 　设置所有注释的格式。 </li><li>-gnu或–gnu-style 　指定使用GNU的格式，此为预设值。 </li><li>-i&lt;格数&gt;或–indent-level&lt;格数&gt; 　设置缩排的格数。 </li><li>-ip&lt;格数&gt;或–parameter-indentation&lt;格数&gt; 　设置参数的缩排格数。 </li><li>-kr或–k-and-r-style 　指定使用Kernighan&amp;Ritchie的格式。 </li><li>-lp或–continue-at-parentheses 　叙述过长而换行，且叙述中包含了括弧时，将括弧中的每行起始栏位内容垂直对其排列。 </li><li>-nbad或–no-blank-lines-after-declarations 　在声明区段后不要加上空白行。 </li><li>-nbap或–no-blank-lines-after-procedures 　在程序后不要加上空白行。 </li><li>-nbbb或–no-blank-lines-after-block-comments 　在注释区段后不要加上空白行。 </li><li>-nbc或–no-blank-lines-after-commas 　在声明区段中，即使出现逗号，仍旧不要换行。 </li><li>-ncdb或–no-comment-delimiters-on-blank-lines 　注释符号不要自成一行。 </li><li>-nce或–dont-cuddle-else 　不要将else置于”}”之后。 </li><li>-ncs或–no-space-after-casts 　不要在cast之后空一格。 </li><li>-nfc1或–dont-format-first-column-comments 　不要格式化放在每行最前端的注释。 </li><li>-nfca或–dont-format-comments 　不要格式化任何的注释。 </li><li>-nip或–no-parameter-indentation 　参数不要缩排。 </li><li>-nlp或–dont-line-up-parentheses 　叙述过长而换行，且叙述中包含了括弧时，不用将括弧中的每行起始栏位垂直对其排列。 </li><li>-npcs或–no-space-after-function-call-names 　在调用的函数名称之后，不要加上空格。 </li><li>-npro或–ignore-profile 　不要读取indent的配置文件.indent.pro。 </li><li>-npsl或–dont-break-procedure-type 　程序类型与程序名称放在同一行。 </li><li>-nsc或–dont-star-comments 　注解左侧不要加上星号(*)。 </li><li>-nsob或–leave-optional-semicolon 　不用处理多余的空白行。 </li><li>-nss或–dont-space-special-semicolon  　若for或while区段仅有一行时，在分号前不加上空格。 </li><li>-nv或–no-verbosity 　不显示详细的信息。 </li><li>-orig或–original 　使用Berkeley的格式。 </li><li>-pcs或–space-after-procedure-calls 　在调用的函数名称与”{“之间加上空格。 </li><li>-psl或–procnames-start-lines 　程序类型置于程序名称的前一行。 </li><li>-sc或–start-left-side-of-comments 　在每行注释左侧加上星号(*)。 </li><li>-sob或–swallow-optional-blank-lines 　删除多余的空白行。 </li><li>-ss或–space-special-semicolon 　若for或swile区段今有一行时，在分号前加上空格。 </li><li>-st或–standard-output 　将结果显示在标准输出设备。 </li><li>-T 　数据类型名称缩排。 </li><li>-ts&lt;格数&gt;或–tab-size&lt;格数&gt; 　设置tab的长度。 </li><li>-v或–verbose 　执行时显示详细的信息。 </li><li>-version 　显示版本信息。</li></ul><h2 id="linux文件传输命令"><a href="#linux文件传输命令" class="headerlink" title="linux文件传输命令"></a>linux文件传输命令</h2><h3 id="bye"><a href="#bye" class="headerlink" title="bye"></a>bye</h3><p>功能说明：中断FTP连线并结束程序。</p><p>语　　法：<code>bye</code></p><p>补充说明：在ftp模式下，输入bye即可中断目前的连线作业，并结束ftp的执行。</p><h3 id="ftp-file-transfer-protocol"><a href="#ftp-file-transfer-protocol" class="headerlink" title="ftp(file transfer protocol)"></a>ftp(file transfer protocol)</h3><p>功能说明：设置文件系统相关功能。</p><p>语　　法：<code>ftp [-dignv][主机名称或IP地址]</code></p><p>补充说明：FTP是ARPANet的标准文件传输协议，该网络就是现今Internet的前身。</p><p>参　　数：</p><ul><li>-d   详细显示指令执行过程，便于排错或分析程序执行的情形。</li><li>-i   关闭互动模式，不询问任何问题。</li><li>-g   关闭本地主机文件名称支持特殊字符的扩充特性。</li><li>-n   不使用自动登陆。</li><li>-v   显示指令执行过程。</li></ul><h3 id="ftpcount"><a href="#ftpcount" class="headerlink" title="ftpcount"></a>ftpcount</h3><p>功能说明：显示目前以FTP登入的用户人数。</p><p>语　　法：<code>ftpcount</code></p><p>补充说明：执行这项指令可得知目前用FTP登入系统的人数以及FTP登入人数的上限。</p><h3 id="ftpshut-ftp-shutdown"><a href="#ftpshut-ftp-shutdown" class="headerlink" title="ftpshut(ftp shutdown)"></a>ftpshut(ftp shutdown)</h3><p>功能说明：在指定的时间关闭FTP服务器。</p><p>语　　法：<code>ftpshut [-d&lt;分钟&gt;][-l&lt;分钟&gt;][关闭时间][“警告信息”]</code></p><p>补充说明：本指令提供系统管理者在设置的时间关闭FTP服务器，且能在关闭之前发出警告信息通知用户。关闭时间若设置后为”none”，则会马上关闭服务器。如果采用”+30”的方式来设置表示服务器在30分钟之后关闭。依次类推，假设使用”1130”的格式则代表服务器会在每日的11时30分关闭，时间格式为24小时制。FTP服务器关闭后，在/etc目录下会产生一个名称为shutmsg的文件，把它删除后即可再度启动FTP服务器的功能。</p><p>参　　数：</p><ul><li>-d&lt;分钟&gt;   切断所有FTP连线时间。</li><li>-l&lt;分钟&gt;   停止接受FTP登入的时间。</li></ul><h3 id="ftpwho"><a href="#ftpwho" class="headerlink" title="ftpwho"></a>ftpwho</h3><p>功能说明：显示目前所有以FTP登入的用户信息。</p><p>语　　法：<code>ftpwho</code></p><p>补充说明：执行这项指令可得知目前用FTP登入系统的用户有那些人，以及他们正在进行的操作。</p><h3 id="ncftp-nc-file-transfer-protocol"><a href="#ncftp-nc-file-transfer-protocol" class="headerlink" title="ncftp(nc file transfer protocol)"></a>ncftp(nc file transfer protocol)</h3><p>功能说明：传输文件。</p><p>语　　法：<code>ncftp [主机或IP地址]</code></p><p>补充说明：FTP让用户得以下载存放于服务器主机的文件，也能将文件上传到远端主机放置。NcFTP是文字模式FTP程序的佼佼者，它具备多样特色， 包括显示传输速率，下载进度，自动续传，标住书签，可通过防火墙和代理服务器等。</p><h3 id="tftp-trivial-file-transfer-protocol"><a href="#tftp-trivial-file-transfer-protocol" class="headerlink" title="tftp(trivial file transfer protocol)"></a>tftp(trivial file transfer protocol)</h3><p>功能说明：传输文件。</p><p>语　　法：<code>tftp [主机名称或IP地址]</code></p><p>补充说明：FTP让用户得以下载存放于远端主机的文件，也能将文件上传到远端主机放置。tftp是简单的文字模式ftp程序，它所使用的指令和FTP类似。</p><h3 id="uucico"><a href="#uucico" class="headerlink" title="uucico"></a>uucico</h3><p>功能说明：UUCP文件传输服务程序。</p><p>语　　法：<code>uucico [-cCDefqvwz][-i&lt;类型&gt;][-I&lt;文件&gt;][-p&lt;连接端口号码&gt;][-][-rl][-s&lt;主机&gt;][-S&lt;主机&gt;][-u&lt;用户&gt;][-x&lt;类型&gt;][–help]</code></p><p>补充说明：uucico是用来处理uucp或uux送到队列的文件传输工具。uucico有两种工作模式：主动模式和附属模式。当在主动模式下时，uucico会调用远端主机；在附属模式下时，uucico则接受远端主机的调用。</p><p>参　　数：</p><ul><li>-c或–quiet   当不执行任何工作时，不要更改记录文件的内容及更新目前的状态。</li><li>-C或–ifwork   当有工作要执行时，才调用-s或-S参数所指定主机。</li><li>-D或–nodetach   不要与控制终端机离线。</li><li>-e或–loop   在附属模式下执行，并且出现要求登入的提示画面。</li><li>-f或–force   当执行错误时，不等待任何时间即重新调用主机。</li><li>-i&lt;类型&gt;或–stdin&lt;类型&gt;   当使用到标准输入设备时，指定连接端口的类型。</li><li>-I&lt;文件&gt;–config&lt;文件&gt;   指定使用的配置文件。</li><li>-l或–prompt   出现要求登入的提示画面。</li><li>-p&lt;连接端口号码&gt;或-port&lt;连接端口号码&gt;   指定连接端口号码。</li><li>-q或–quiet   不要启动uuxqt服务程序。</li><li>-r0或–slave   以附属模式启动。</li><li>-s&lt;主机&gt;或–system&lt;主机&gt;   调用指定的主机。</li><li>-u&lt;用户&gt;或–login&lt;用户&gt;   指定登入的用户帐号，而不允许输入任意的登入帐号。</li><li>-v或–version   显示版本信息，并且结束程序。</li><li>-w或–wait   在主动模式下，当执行调用动作时，则出现要求登入的提示画面。</li><li>-x&lt;类型&gt;或-X&lt;类型&gt;或outgoing-debug&lt;类型&gt;   启动指定的排错模式。</li><li>-z或–try-next   当执行不成功时，尝试下一个选择而不结束程序。</li><li>–help   显示帮助，并且结束程序。</li></ul><h3 id="uucp"><a href="#uucp" class="headerlink" title="uucp"></a>uucp</h3><p>功能说明：在Unix系统之间传送文件。</p><p>语　　法：<code>uucp [-cCdfjmrRtvW][-g&lt;等级&gt;][-I&lt;配置文件&gt;][-n&lt;用户&gt;][-x&lt;类型&gt;][–help][…来源][目的]</code></p><p>补充说明：UUCP为Unix系统之间，通过序列线来连线的协议。uucp使用UUCP协议，主要的功能为传送文件。</p><p>参　　数：</p><ul><li>-c或–nocopy   不用将文件复制到缓冲区。</li><li>-C或–copy   将文件复制到缓冲区。</li><li>-d或–directiories   在传送文件时，自动在[目的]建立必要的目录。</li><li>-f或–nodirectiories   在传送文件时，若需要在[目的]建立目录，则放弃执行该作业。</li><li>-g&lt;等级&gt;或–grade&lt;等级&gt;   指定文件传送作业的优先顺序。</li><li>-I&lt;配置文件&gt;或–config&lt;配置文件&gt;   指定uucp配置文件。</li><li>-j或–jobid   显示作业编号。</li><li>-m或–mail   作业结束后，以电子邮件报告作业是否顺利完成。</li><li>-n&lt;用户&gt;或–notify&lt;用户&gt;   作业结束后，以电子邮件向指定的用户报告作业是否顺利完成。</li><li>-r或–nouucico   不要立即启动uucico服务程序，仅将作业送到队列中，待稍后再执行。</li><li>-R或–recursive   若[来源]为目录，则将整个目录包含子目录复制到[目的]。</li><li>-t或–uuto   将最后一个参数视为”主机名!用户”。</li><li>-v或–version   显示版本信息。</li><li>-W或–noexpand   不要将目前所在的目录加入路径。</li><li>-x&lt;类型&gt;或–debug&lt;类型&gt;启动指定的排错模式。</li><li><p>–help   显示帮助。</p><p>   [源…]   指定源文件或路径。<br>   [目的]   指定目标文件或路径。</p></li></ul><h3 id="uupick"><a href="#uupick" class="headerlink" title="uupick"></a>uupick</h3><p>功能说明：处理传送进来的文件。</p><p>语　　法：<code>uupick [-v][-I&lt;配置文件&gt;][-s&lt;主机&gt;][-x&lt;层级&gt;][–help]</code></p><p>补充说明：当其他主机通过UUCP将文件传送进来时，可利用uupick指令取出这些文件。</p><p>参　　数：</p><ul><li>-I&lt;配置文件&gt;或–config&lt;配置文件&gt;   指定配置文件。</li><li>-s&lt;主机&gt;或–system&lt;主机&gt;   处理由指定主机传送过来的文件。</li><li>-v或–version   显示版本信息。</li><li>–help   显示帮助。</li></ul><h3 id="uuto"><a href="#uuto" class="headerlink" title="uuto"></a>uuto</h3><p>功能说明：将文件传送到远端的UUCP主机。</p><p>语　　法：<code>uuto [文件][目的]</code></p><p>补充说明：uuto为script文件，它实际上会执行uucp，用来将文件传送到远端UUCP主机，并在完成工作后，以邮件通知远端主机上的用户。</p><p>参　　数：</p><p>相关参数请参考uucp指令。</p><h2 id="linux磁盘管理命令"><a href="#linux磁盘管理命令" class="headerlink" title="linux磁盘管理命令"></a>linux磁盘管理命令</h2><h3 id="cd-change-directory"><a href="#cd-change-directory" class="headerlink" title="cd(change directory)"></a><font color="red">cd(change directory)</font></h3><p>功能说明：切换目录。</p><p>语　　法：<code>cd [目的目录]</code></p><p>补充说明：cd指令可让用户在不同的目录间切换，但该用户必须拥有足够的权限进入目的目录。</p><h3 id="df-disk-free"><a href="#df-disk-free" class="headerlink" title="df(disk free)"></a><font color="red">df(disk free)</font></h3><p>功能说明：显示磁盘的相关信息。</p><p>语　　法：<code>df [-ahHiklmPT][–block-size=&lt;区块大小&gt;][-t &lt;文件系统类型&gt;][-x &lt;文件系统类型&gt;][–help][–no-sync][–sync][–version][文件或设备]</code></p><p>补充说明：df可显示磁盘的文件系统与使用情形。</p><p>参　　数：</p><ul><li>-a或–all   包含全部的文件系统。</li><li>–block-size=&lt;区块大小&gt;   以指定的区块大小来显示区块数目。</li><li>-h或–human-readable   以可读性较高的方式来显示信息。</li><li>-H或–si   与-h参数相同，但在计算时是以1000 Bytes为换算单位而非1024 Bytes。</li><li>-i或–inodes   显示inode的信息。</li><li>-k或–kilobytes   指定区块大小为1024字节。</li><li>-l或–local   仅显示本地端的文件系统。</li><li>-m或–megabytes   指定区块大小为1048576字节。</li><li>–no-sync   在取得磁盘使用信息前，不要执行sync指令，此为预设值。</li><li>-P或–portability   使用POSIX的输出格式。</li><li>–sync   在取得磁盘使用信息前，先执行sync指令。</li><li>-t&lt;文件系统类型&gt;或–type=&lt;文件系统类型&gt;   仅显示指定文件系统类型的磁盘信息。</li><li>-T或–print-type   显示文件系统的类型。</li><li>-x&lt;文件系统类型&gt;或–exclude-type=&lt;文件系统类型&gt;   不要显示指定文件系统类型的磁盘信息。</li><li>–help   显示帮助。</li><li><p>–version   显示版本信息。</p><p>  [文件或设备]   指定磁盘设备。</p></li></ul><h3 id="dirs"><a href="#dirs" class="headerlink" title="dirs"></a><font color="red">dirs</font></h3><p>功能说明：显示目录记录。</p><p>语　　法：<code>dirs [+/-n -l]</code></p><p>补充说明：显示目录堆叠中的记录。</p><p>参　　数：</p><ul><li>+n   显示从左边算起第n笔的目录。</li><li>-n   显示从右边算起第n笔的目录。</li><li>-l   显示目录完整的记录。</li></ul><h3 id="du-disk-usage"><a href="#du-disk-usage" class="headerlink" title="du(disk usage)"></a><font color="red">du(disk usage)</font></h3><p>功能说明：显示目录或文件的大小。</p><p>语　　法：<code>du [-abcDhHklmsSx][-L &lt;符号连接&gt;][-X &lt;文件&gt;][–block-size][–exclude=&lt;目录或文件&gt;][–max-depth=&lt;目录层数&gt;][–help][–version][目录或文件]</code></p><p>补充说明：du会显示指定的目录或文件所占用的磁盘空间。</p><p>参　　数：</p><ul><li>-a或-all   显示目录中个别文件的大小。</li><li>-b或-bytes   显示目录或文件大小时，以byte为单位。</li><li>-c或–total   除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。</li><li>-D或–dereference-args   显示指定符号连接的源文件大小。</li><li>-h或–human-readable   以K，M，G为单位，提高信息的可读性。</li><li>-H或–si   与-h参数相同，但是K，M，G是以1000为换算单位。</li><li>-k或–kilobytes   以1024 bytes为单位。</li><li>-l或–count-links   重复计算硬件连接的文件。</li><li>-L&lt;符号连接&gt;或–dereference&lt;符号连接&gt;   显示选项中所指定符号连接的源文件大小。</li><li>-m或–megabytes   以1MB为单位。</li><li>-s或–summarize   仅显示总计。</li><li>-S或–separate-dirs   显示个别目录的大小时，并不含其子目录的大小。</li><li>-x或–one-file-xystem   以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。</li><li>-X&lt;文件&gt;或–exclude-from=&lt;文件&gt;   在&lt;文件&gt;指定目录或文件。</li><li>–exclude=&lt;目录或文件&gt;   略过指定的目录或文件。</li><li>–max-depth=&lt;目录层数&gt;   超过指定层数的目录后，予以忽略。</li><li>–help   显示帮助。</li><li>–version   显示版本信息。</li></ul><h3 id="edquota-edit-quota"><a href="#edquota-edit-quota" class="headerlink" title="edquota(edit quota)"></a>edquota(edit quota)</h3><p>功能说明：编辑用户或群组的quota。</p><p>语　　法：<code>edquota [-p &lt;源用户名称&gt;][-ug][用户或群组名称…] 或 edquota [-ug] -t</code></p><p>补充说明：edquota预设会使用vi来编辑使用者或群组的quota设置。</p><p>参　　数：</p><ul><li>-u   设置用户的quota，这是预设的参数。</li><li>-g   设置群组的quota。</li><li>-p&lt;源用户名称&gt;   将源用户的quota设置套用至其他用户或群组。</li><li>-t   设置宽限期限。</li></ul><h3 id="eject"><a href="#eject" class="headerlink" title="eject"></a>eject</h3><p>功能说明：退出抽取式设备。</p><p>语　　法：<code>eject [-dfhnqrstv][-a &lt;开关&gt;][-c &lt;光驱编号&gt;][设备]</code></p><p>补充说明：若设备已挂入，则eject会先将该设备卸除再退出。</p><p>参　　数：</p><pre><code>[设备]   设备可以是驱动程序名称，也可以是挂入点。</code></pre><ul><li>-a&lt;开关&gt;或–auto&lt;开关&gt;   控制设备的自动退出功能。</li><li>-c&lt;光驱编号&gt;或–changerslut&lt;光驱编号&gt;   选择光驱柜中的光驱。</li><li>-d或–default   显示预设的设备，而不是实际执行动作。</li><li>-f或–floppy   退出抽取式磁盘。</li><li>-h或–help   显示帮助。</li><li>-n或–noop   显示指定的设备。</li><li>-q或–tape   退出磁带。</li><li>-r或–cdrom   退出光盘。</li><li>-s或–scsi   以SCSI指令来退出设备。</li><li>-t或–trayclose   关闭光盘的托盘。</li><li>-v或–verbose   执行时，显示详细的说明。</li></ul><h3 id="lndir-link-directory"><a href="#lndir-link-directory" class="headerlink" title="lndir(link directory)"></a>lndir(link directory)</h3><p>功能说明：连接目录内容。</p><p>语　　法：<code>lndir [-ignorelinks][-silent][源目录][目的目录]</code></p><p>补充说明：执行lndir指令，可一口气把源目录底下的文件和子目录统统建立起相互对应的符号连接。</p><p>参　　数：</p><ul><li>-ignorelinks   直接建立符号连接的符号连接。</li><li>-silent   不显示指令执行过程。</li></ul><h3 id="ls-list"><a href="#ls-list" class="headerlink" title="ls(list)"></a><font color="red">ls(list)</font></h3><p>功能说明：列出目录内容。</p><p>语　　法：<code>ls [-1aAbBcCdDfFgGhHiklLmnNopqQrRsStuUvxX][-I &lt;范本样式&gt;][-T &lt;跳格字数&gt;][-w &lt;每列字符数&gt;][–block-size=&lt;区块大小&gt;][–color=&lt;使用时机&gt;][–format=&lt;列表格式&gt;][–full-time][–help][–indicator-style=&lt;标注样式&gt;][–quoting-style=&lt;引号样式&gt;][–show-control-chars][–sort=&lt;排序方式&gt;][–time=&lt;时间戳记&gt;][–version][文件或目录…]</code></p><p>补充说明：执行ls指令可列出目录的内容，包括文件和子目录的名称。</p><p>参　　数：</p><ul><li>-1   每列仅显示一个文件或目录名称。</li><li>-a或–all   下所有文件和目录。</li><li>-A或–almost-all   显示所有文件和目录，但不显示现行目录和上层目录。</li><li>-b或–escape   显示脱离字符。</li><li>-B或–ignore-backups   忽略备份文件和目录。</li><li>-c   以更改时间排序，显示文件和目录。</li><li>-C   以又上至下，从左到右的直行方式显示文件和目录名称。</li><li>-d或–directory   显示目录名称而非其内容。</li><li>-D或–dired   用Emacs的模式产生文件和目录列表。</li><li>-f   此参数的效果和同时指定”aU”参数相同，并关闭”lst”参数的效果。</li><li>-F或–classify   在执行文件，目录，Socket，符号连接，管道名称后面，各自加上”*”,”/“,”=”,”@”,”|”号。</li><li>-g   次参数将忽略不予处理。</li><li>-G或–no-group   不显示群组名称。</li><li>-h或–human-readable   用”K”,”M”,”G”来显示文件和目录的大小。</li><li>-H或–si   此参数的效果和指定”-h”参数类似，但计算单位是1000Bytes而非1024Bytes。</li><li>-i或–inode   显示文件和目录的inode编号。</li><li>-I&lt;范本样式&gt;或–ignore=&lt;范本样式&gt;   不显示符合范本样式的文件或目录名称。</li><li>-k或–kilobytes   此参数的效果和指定”block-size=1024”参数相同。</li><li>-l   使用详细格式列表。</li><li>-L或–dereference   如遇到性质为符号连接的文件或目录，直接列出该连接所指向的原始文件或目录。</li><li>-m   用”,”号区隔每个文件和目录的名称。</li><li>-n或–numeric-uid-gid   以用户识别码和群组识别码替代其名称。</li><li>-N或–literal   直接列出文件和目录名称，包括控制字符。</li><li>-o   此参数的效果和指定”-l” 参数类似，但不列出群组名称或识别码。</li><li>-p或–file-type   此参数的效果和指定”-F”参数类似，但不会在执行文件名称后面加上”*”号。</li><li>-q或–hide-control-chars   用”?”号取代控制字符，列出文件和目录名称。</li><li>-Q或–quote-name   把文件和目录名称以””号标示起来。</li><li>-r或–reverse   反向排序。</li><li>-R或–recursive   递归处理，将指定目录下的所有文件及子目录一并处理。</li><li>-s或–size   显示文件和目录的大小，以区块为单位。</li><li>-S   用文件和目录的大小排序。</li><li>-t   用文件和目录的更改时间排序。</li><li>-T&lt;跳格字符&gt;或–tabsize=&lt;跳格字数&gt;   设置跳格字符所对应的空白字符数。</li><li>-u   以最后存取时间排序，显示文件和目录。</li><li>-U   列出文件和目录名称时不予排序。</li><li>-v   文件和目录的名称列表以版本进行排序。</li><li>-w&lt;每列字符数&gt;或–width=&lt;每列字符数&gt;   设置每列的最大字符数。</li><li>-x   以从左到右，由上至下的横列方式显示文件和目录名称。</li><li>-X   以文件和目录的最后一个扩展名排序。</li><li>–block-size=&lt;区块大小&gt;   指定存放文件的区块大小。</li><li>–color=&lt;列表格式&gt;   培植文件和目录的列表格式。</li><li>–full-time   列出完整的日期与时间。</li><li>–help   在线帮助。</li><li>–indicator-style=&lt;标注样式&gt;   在文件和目录等名称后面加上标注，易于辨识该名称所属的类型。</li><li>–quoting-syte=&lt;引号样式&gt;   把文件和目录名称以指定的引号样式标示起来。</li><li>–show-control-chars   在文件和目录列表时，使用控制字符。</li><li>–sort=&lt;排序方式&gt;   配置文件和目录列表的排序方式。</li><li>–time=&lt;时间戳记&gt;   用指定的时间戳记取代更改时间。</li><li>–version   显示版本信息。</li></ul><h3 id="mcd"><a href="#mcd" class="headerlink" title="mcd"></a>mcd</h3><p>功能说明：在MS-DOS文件系统中切换工作目录</p><p>语　　法：<code>mcd [目录名称]</code></p><p>补充说明：mcd为mtools工具指令，可在MS-DOS文件系统中切换工作目录。若不加任何参数，则显示目前所在的磁盘与工作目录。</p><h3 id="mdeltree"><a href="#mdeltree" class="headerlink" title="mdeltree"></a>mdeltree</h3><p>功能说明：删除MS-DOS目录</p><p>语　　法：<code>mdeltree [目录…]</code></p><p>补充说明：mdel为mtools工具指令，模拟MS-DOS的deltree指令，可删除MS-DOS文件系统中的目录及目录下所有子目录与文件。</p><h3 id="mdu"><a href="#mdu" class="headerlink" title="mdu"></a>mdu</h3><p>功能说明：显示MS-DOS目录所占用的磁盘空间。</p><p>语　　法：<code>mdu [-as][目录]</code></p><p>补充说明：mdu为mstools工具指令，可显示MS-DOS文件系统中目录所占用的磁盘空间。</p><p>参　　数：</p><ul><li>-a   显示每个文件及整个目录所占用的空间。</li><li>-s   仅显示整个目录所占用的空间。</li></ul><h3 id="mkdir-make-directories"><a href="#mkdir-make-directories" class="headerlink" title="mkdir(make directories)"></a><font color="red">mkdir(make directories)</font></h3><p>功能说明：建立目录</p><p>语　　法：<code>mkdir [-p][–help][–version][-m &lt;目录属性&gt;][目录名称]</code></p><p>补充说明：mkdir可建立目录并同时设置目录的权限。</p><p>参　　数：</p><ul><li>-m&lt;目录属性&gt;或–mode&lt;目录属性&gt;   建立目录时同时设置目录的权限。</li><li>-p或–parents   若所要建立目录的上层目录目前尚未建立，则会一并建立上层目录。</li><li>–help   显示帮助。</li><li>–verbose   执行时显示详细的信息。</li><li>–version   显示版本信息。</li></ul><h3 id="mlabel"><a href="#mlabel" class="headerlink" title="mlabel"></a>mlabel</h3><p>功能说明：显示或设置MS-DOS磁盘驱动器的标签名称。</p><p>语　　法：<code>mlabel [-csvV][驱动器代号][标签名称]</code></p><p>补充说明：mlabel为mtools工具指令，模拟MS-DOS的label指令，可显示或设置MS-DOS磁盘驱动器的标签名称。</p><p>参　　数：</p><ul><li>-c   清楚标签名称</li><li>-s   显示标签名称</li><li>-v   执行时显示详细的信息。</li><li>-V   显示版本信息。</li></ul><h3 id="mmd"><a href="#mmd" class="headerlink" title="mmd"></a>mmd</h3><p>功能说明：在MS-DOS文件系统中建立目录。</p><p>语　　法：<code>mmd [目录…]</code></p><p>补充说明：mmd为mtools工具指令，模拟MS-DOS的md指令，可在MS-DOS的文件系统中建立目录。</p><h3 id="mmount"><a href="#mmount" class="headerlink" title="mmount"></a>mmount</h3><p>功能说明：挂入MS-DOS文件系统。</p><p>语　　法：<code>mmount [驱动器代号][mount参数]</code></p><p>补充说明：mmount为mtools工具指令，可根据[mount参数]中的设置，将磁盘内容挂入到Linux目录中。</p><p>参　　数：</p><pre><code>[mount参数]的用法请参考mount指令。</code></pre><h3 id="mrd"><a href="#mrd" class="headerlink" title="mrd"></a>mrd</h3><p>功能说明：删除MS-DOS文件系统中的目录。</p><p>语　　法：<code>mrd [目录…]</code></p><p>补充说明：mrd为mtools工具指令，模拟MS-DOS的rd指令，可删除MS-DOS的目录。</p><h3 id="mzip"><a href="#mzip" class="headerlink" title="mzip"></a>mzip</h3><p>功能说明：Zip/Jaz磁盘驱动器控制指令。</p><p>语　　法：<code>mzip [-efpqruwx]</code></p><p>补充说明：mzip为mtools工具指令，可设置Zip或Jaz磁盘驱动区的保护模式以及执行退出磁盘的动作。</p><p>参　　数：</p><ul><li>-e   退出磁盘。</li><li>-f   与-e参数一并使用，不管是否已经挂入磁盘中的文件系统，一律强制退出磁盘。</li><li>-p   设置磁盘的写入密码。</li><li>-q   显示目前的状态。</li><li>-r   将磁盘设为防写状态。</li><li>-u   退出磁盘以前，暂时解除磁盘的保护状态。</li><li>-w   将磁盘设为可写入状态。</li><li>-x   设置磁盘的密码。</li></ul><h3 id="pwd-print-working-directory"><a href="#pwd-print-working-directory" class="headerlink" title="pwd(print working directory)"></a><font color="red">pwd(print working directory)</font></h3><p>功能说明：显示工作目录。</p><p>语　　法：<code>pwd [–help][–version]</code></p><p>补充说明：执行pwd指令可立刻得知您目前所在的工作目录的绝对路径名称。</p><p>参　　数：</p><ul><li>–help   在线帮助。</li><li>–version   显示版本信息。</li></ul><h3 id="quota"><a href="#quota" class="headerlink" title="quota"></a>quota</h3><p>功能说明：显示磁盘已使用的空间与限制。</p><p>语　　法：<code>quota [-quvV][用户名称…] 或 quota [-gqvV][群组名称…]</code></p><p>补充说明：执行quota指令，可查询磁盘空间的限制，并得知已使用多少空间。</p><p>参　　数：</p><ul><li>-g   列出群组的磁盘空间限制。</li><li>-q   简明列表，只列出超过限制的部分。</li><li>-u   列出用户的磁盘空间限制。</li><li>-v   显示该用户或群组，在所有挂入系统的存储设备的空间限制。</li><li>-V   显示版本信息。</li></ul><h3 id="quotacheck"><a href="#quotacheck" class="headerlink" title="quotacheck"></a>quotacheck</h3><p>功能说明：检查磁盘的使用空间与限制。</p><p>语　　法：<code>quotacheck [-adgRuv][文件系统…]</code></p><p>补充说明：执行quotacheck指令，扫描挂入系统的分区，并在各分区的文件系统根目录下产生quota.user和quota.group文件，设置用户和群组的磁盘空间限制。</p><p>参　　数：</p><ul><li>-a   扫描在/etc/fstab文件里，有加入quota设置的分区。</li><li>-d   详细显示指令执行过程，便于排错或了解程序执行的情形。</li><li>-g   扫描磁盘空间时，计算每个群组识别码所占用的目录和文件数目。</li><li>-R   排除根目录所在的分区。</li><li>-u   扫描磁盘空间时，计算每个用户识别码所占用的目录和文件数目。</li><li>-v   显示指令执行过程。</li></ul><h3 id="quotaoff"><a href="#quotaoff" class="headerlink" title="quotaoff"></a>quotaoff</h3><p>功能说明：关闭磁盘空间限制。</p><p>语　　法：<code>quotaoff [-aguv][文件系统…]</code></p><p>补充说明：执行quotaoff指令可关闭用户和群组的磁盘空间限制。</p><p>参　　数：</p><ul><li>-a   关闭在/etc/fstab文件里，有加入quota设置的分区的空间限制。</li><li>-g   关闭群组的磁盘空间限制。</li><li>-u   关闭用户的磁盘空间限制。</li><li>-v   显示指令执行过程。</li></ul><h3 id="quotaon"><a href="#quotaon" class="headerlink" title="quotaon"></a>quotaon</h3><p>功能说明：开启磁盘空间限制。</p><p>语　　法：<code>quotaon [-aguv][文件系统…]</code></p><p>补充说明：执行quotaon指令可开启用户和群组的才磅秒年空间限制，各分区的文件系统根目录必须有quota.user和quota.group配置文件。</p><p>参　　数：</p><ul><li>-a   开启在/ect/fstab文件里，有加入quota设置的分区的空间限制。</li><li>-g   开启群组的磁盘空间限制。</li><li>-u   开启用户的磁盘空间限制。</li><li>-v   显示指令指令执行过程。</li></ul><h3 id="repquota-report-quota"><a href="#repquota-report-quota" class="headerlink" title="repquota(report quota)"></a>repquota(report quota)</h3><p>功能说明：检查磁盘空间限制的状态。</p><p>语　　法：<code>repquota [-aguv][文件系统…]</code></p><p>补充说明：执行repquota指令，可报告磁盘空间限制的状况，清楚得知每位用户或每个群组已使用多少空间。</p><p>参　　数：</p><ul><li>-a   列出在/etc/fstab文件里，有加入quota设置的分区的使用状况，包括用户和群组。</li><li>-g   列出所有群组的磁盘空间限制。</li><li>-u   列出所有用户的磁盘空间限制。</li><li>-v   显示该用户或群组的所有空间限制。</li></ul><h3 id="rmdir-remove-directory"><a href="#rmdir-remove-directory" class="headerlink" title="rmdir(remove directory)"></a>rmdir(remove directory)</h3><p>功能说明：删除目录。</p><p>语　　法：<code>rmdir [-p][–help][–ignore-fail-on-non-empty][–verbose][–version][目录…]</code></p><p>补充说明：当有空目录要删除时，可使用rmdir指令。</p><p>参　　数：</p><ul><li>-p或–parents   删除指定目录后，若该目录的上层目录已变成空目录，则将其一并删除。</li><li>–help   在线帮助。</li><li>–ignore-fail-on-non-empty   忽略非空目录的错误信息。</li><li>–verbose   显示指令执行过程。</li><li>–version   显示版本信息。</li></ul><h3 id="rmt-remote-magnetic-tape"><a href="#rmt-remote-magnetic-tape" class="headerlink" title="rmt(remote magnetic tape)"></a>rmt(remote magnetic tape)</h3><p>功能说明：远端磁带传输协议模块。</p><p>语　　法：<code>rmt</code></p><p>补充说明：通过rmt指令，用户可通过IPC连线，远端操控磁带机的倾倒和还原操作。</p><h3 id="stat-status"><a href="#stat-status" class="headerlink" title="stat(status)"></a><font color="red">stat(status)</font></h3><p>功能说明：显示inode内容。</p><p>语　　法：<code>stat [文件或目录]</code></p><p>补充说明：stat以文字的格式来显示inode的内容。</p><h3 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h3><p>功能说明：以树状图列出目录的内容。</p><p>语　　法：<code>tree [-aACdDfFgilnNpqstux][-I &lt;范本样式&gt;][-P &lt;范本样式&gt;][目录…]</code></p><p>补充说明：执行tree指令，它会列出指定目录下的所有文件，包括子目录里的文件。</p><p>参　　数：</p><ul><li>-a   显示所有文件和目录。</li><li>-A   使用ASNI绘图字符显示树状图而非以ASCII字符组合。</li><li>-C   在文件和目录清单加上色彩，便于区分各种类型。</li><li>-d   显示目录名称而非内容。</li><li>-D   列出文件或目录的更改时间。</li><li>-f   在每个文件或目录之前，显示完整的相对路径名称。</li><li>-F   在执行文件，目录，Socket，符号连接，管道名称名称，各自加上”*”,”/“,”=”,”@”,”|”号。</li><li>-g   列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码。</li><li>-i   不以阶梯状列出文件或目录名称。</li><li>-I&lt;范本样式&gt;   不显示符合范本样式的文件或目录名称。</li><li>-l   如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录。</li><li>-n   不在文件和目录清单加上色彩。</li><li>-N   直接列出文件和目录名称，包括控制字符。</li><li>-p   列出权限标示。</li><li>-P&lt;范本样式&gt;   只显示符合范本样式的文件或目录名称。</li><li>-q   用”?”号取代控制字符，列出文件和目录名称。</li><li>-s   列出文件或目录大小。</li><li>-t   用文件和目录的更改时间排序。</li><li>-u   列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码。</li><li>-x   将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该子目录予以排除在寻找范围外。</li></ul><h3 id="umount"><a href="#umount" class="headerlink" title="umount"></a>umount</h3><p>功能说明：卸除文件系统。</p><p>语　　法：<code>umount [-ahnrvV][-t &lt;文件系统类型&gt;][文件系统]</code></p><p>补充说明：umount可卸除目前挂在Linux目录中的文件系统。</p><p>参　　数：</p><ul><li>-a   卸除/etc/mtab中记录的所有文件系统。</li><li>-h   显示帮助。</li><li>-n   卸除时不要将信息存入/etc/mtab文件中。</li><li>-r   若无法成功卸除，则尝试以只读的方式重新挂入文件系统。</li><li>-t&lt;文件系统类型&gt;   仅卸除选项中所指定的文件系统。</li><li>-v   执行时显示详细的信息。</li><li><p>-V   显示版本信息。</p><p>  [文件系统]   除了直接指定文件系统外，也可以用设备名称或挂入点来表示文件系统。</p></li></ul><h2 id="linux磁盘维护命令"><a href="#linux磁盘维护命令" class="headerlink" title="linux磁盘维护命令"></a>linux磁盘维护命令</h2><h3 id="badblocks"><a href="#badblocks" class="headerlink" title="badblocks"></a>badblocks</h3><p>功能说明：检查磁盘装置中损坏的区块。</p><p>语　　法：<code>badblocks [-svw][-b &lt;区块大小&gt;][-o &lt;输出文件&gt;][磁盘装置][磁盘区块数][启始区块]</code></p><p>补充说明：执行指令时须指定所要检查的磁盘装置，及此装置的磁盘区块数。</p><p>参　　数：</p><ul><li>-b&lt;区块大小&gt;   指定磁盘的区块大小，单位为字节。</li><li>-o&lt;输出文件&gt;   将检查的结果写入指定的输出文件。</li><li>-s   在检查时显示进度。</li><li>-v   执行时显示详细的信息。</li><li><p>-w   在检查时，执行写入测试。</p><pre><code>[磁盘装置]   指定要检查的磁盘装置。[磁盘区块数]   指定磁盘装置的区块总数。[启始区块]   指定要从哪个区块开始检查。</code></pre></li></ul><h3 id="cfdisk"><a href="#cfdisk" class="headerlink" title="cfdisk"></a>cfdisk</h3><p>功能说明：磁盘分区。</p><p>语　　法：<code>cfdisk [-avz][-c &lt;柱面数目&gt;-h &lt;磁头数目&gt;-s &lt;盘区数目&gt;][-P &lt;r,s,t&gt;][外围设备代号]</code></p><p>补充说明：cfdisk是用来磁盘分区的程序，它十分类似DOS的fdisk，具有互动式操作界面而非传统fdisk的问答式界面，您可以轻易地利用方向键来操控分区操作。</p><p>参　　数：</p><ul><li>-a   在程序里不用反白代表选取，而以箭头表示。</li><li>-c&lt;柱面数目&gt;   忽略BIOS的数值，直接指定磁盘的柱面数目。</li><li>-h&lt;磁头数目&gt;   忽略BIOS的数值，直接指定磁盘的磁头数目。</li><li>-P&lt;r,s,t&gt;   显示分区表的内容，附加参数”r”会显示整个分区表的详细资料，附加参数”s”会依照磁区的顺序显示相关信息，附加参数”t”则会以磁头，磁区，柱面的方式来显示资料。</li><li>-s&lt;磁区数目&gt;   忽略BIOS的数值，直接指定磁盘的磁区数目。</li><li>-v   显示版本信息。</li><li>-z   不读取现有的分区，直接当作没有分区的新磁盘使用。</li></ul><h3 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h3><p>功能说明：读取，转换并输出数据。</p><p>语　　法：<code>dd [bs=&lt;字节数&gt;][cbs=&lt;字节数&gt;][conv=&lt;关键字&gt;][count=&lt;区块数&gt;][ibs=&lt;字节数&gt;][if=&lt;文件&gt;][obs=&lt;字节数&gt;][of=&lt;文件&gt;][seek=&lt;区块数&gt;][skip=&lt;区块数&gt;][–help][–version]</code></p><p>补充说明：dd可从标准输入或文件读取数据，依指定的格式来转换数据，再输出到文件，设备或标准输出。</p><p>参　　数：</p><ul><li>bs=&lt;字节数&gt;   将ibs( 输入)与obs(输出)设成指定的字节数。</li><li>cbs=&lt;字节数&gt;   转换时，每次只转换指定的字节数。</li><li>conv=&lt;关键字&gt;   指定文件转换的方式。</li><li>count=&lt;区块数&gt;   仅读取指定的区块数。</li><li>ibs=&lt;字节数&gt;   每次读取的字节数。</li><li>if=&lt;文件&gt;   从文件读取。</li><li>obs=&lt;字节数&gt;   每次输出的字节数。</li><li>of=&lt;文件&gt;   输出到文件。</li><li>seek=&lt;区块数&gt;   一开始输出时，跳过指定的区块数。</li><li>skip=&lt;区块数&gt;   一开始读取时，跳过指定的区块数。</li><li>–help   帮助。</li><li>–version   显示版本信息。</li></ul><h3 id="e2fsck-ext2-file-system-check"><a href="#e2fsck-ext2-file-system-check" class="headerlink" title="e2fsck(ext2 file system check)"></a>e2fsck(ext2 file system check)</h3><p>功能说明：检查ext2文件系统的正确性。</p><p>语　　法：<code>e2fsck [-acCdfFnprsStvVy][-b &lt;superblock&gt;][-B &lt;区块大小&gt;][-l &lt;文件&gt;][-L &lt;文件&gt;][设备名称]</code></p><p>补充说明：e2fsck执行后的传回值及代表意义如下。</p><ul><li>0     没有任何错误发生。</li><li>1     文件系统发生错误，并且已经修正。</li><li>2     文件系统发生错误，并且已经修正。</li><li>4     文件系统发生错误，但没有修正。</li><li>8     运作时发生错误。</li><li>16    使用的语法发生错误。</li><li>128   共享的函数库发生错误。</li></ul><p>参　　数：</p><ul><li>-a   不询问使用者意见，便自动修复文件系统。</li><li>-b&lt;superblock&gt;   指定superblock，而不使用预设的superblock。</li><li>-B&lt;区块大小&gt;   指定区块的大小，单位为字节。</li><li>-c   一并执行badblocks，以标示损坏的区块。</li><li>-C   将检查过程的信息完整记录在file descriptor中，使得整个检查过程都能完整监控。</li><li>-d   显示排错信息。</li><li>-f   即使文件系统没有错误迹象，仍强制地检查正确性。</li><li>-F   执行前先清除设备的缓冲区。</li><li>-l&lt;文件&gt;   将文件中指定的区块加到损坏区块列表。</li><li>-L&lt;文件&gt;   先清除损坏区块列表，再将文件中指定的区块加到损坏区块列表。因此损坏区块列表的区块跟文件中指定的区块是一样的。</li><li>-n   以只读模式开启文件系统，并采取非互动方式执行，所有的问题对话均设置以”no”回答。</li><li>-p   不询问使用者意见，便自动修复文件系统。</li><li>-r   此参数只为了兼容性而存在，并无实际作用。</li><li>-s   如果文件系统的字节顺序不适当，就交换字节顺序，否则不做任何动作。</li><li>-S   不管文件系统的字节顺序，一律交换字节顺序。</li><li>-t   显示时间信息。</li><li>-v   执行时显示详细的信息。</li><li>-V   显示版本信息。</li><li>-y   采取非互动方式执行，所有的问题均设置以”yes”回答。</li></ul><h3 id="ext2ed-ext2-file-system-editor"><a href="#ext2ed-ext2-file-system-editor" class="headerlink" title="ext2ed(ext2 file system editor)"></a>ext2ed(ext2 file system editor)</h3><p>功能说明：ext2文件系统编辑程序。</p><p>语　　法：<code>ext2ed</code></p><p>补充说明：ext2ed可直接处理硬盘分区上的数据，这指令只有Red Hat Linux才提供。</p><p>参　　数：</p><p>  一般指令</p><ul><li>setdevice[设备名称]   指定要处理的设备。</li><li>disablewrite   将ext2ed设为只读的状态。</li><li>enablewrite   将ext2ed设为可读写的状态。</li><li>help[指令]   显示个别指令的帮助。</li><li>next   移至下一个单位，单位会依目前所在的模式而异。</li><li>prev   移至前一个单位，单位会依目前所在的模式而异。</li><li>pgup   移至下一页。</li><li>pgdn   移至上一页。</li><li>set   修改目前的数据，参数会依目前所在的模式而异。</li><li><p>writedata   在执行此指令之后，才会实际修改分区中的数据。</p><p>ext2进入3种模式的指令</p></li><li><p>super   进入main superblock,即Superblock模式。</p></li><li>group&lt;编号&gt;   进入指定的group，即Group模式。</li><li><p>cd&lt;目录或文件&gt;   在inode模式下，进入指定的目录或文件，即Inode模式。</p><p>Superblock模式</p></li><li><p>gocopy&lt;备份编号&gt;   进入指定的superblock备份。</p></li><li><p>setactivecopy   将目前所在的superblock，复制到main superblock。</p><p>Group模式</p></li><li><p>blockbitmap   显示目前groupo的区块图。</p></li><li>inode   进入目前group的第一个inode。</li><li><p>inodebitmap   显示目前group的inode二进制码。</p><p>Inode模式</p></li><li><p>dir   进入目录模式。</p></li><li>file   进入文件模式。</li></ul><h3 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h3><p>功能说明：磁盘分区。</p><p>语　　法：<code>fdisk [-b &lt;分区大小&gt;][-uv][外围设备代号] 或 fdisk [-l][-b &lt;分区大小&gt;][-uv][外围设备代号…] 或 fdisk [-s &lt;分区编号&gt;]</code></p><p>补充说明：fdisk是用来磁盘分区的程序，它采用传统的问答式界面，而非类似DOS fdisk的cfdisk互动式操作界面，因此在使用上较为不便，但功能却丝毫不打折扣。</p><p>参　　数：</p><ul><li>-b&lt;分区大小&gt;   指定每个分区的大小。</li><li>-l   列出指定的外围设备的分区表状况。</li><li>-s&lt;分区编号&gt;   将指定的分区大小输出到标准输出上，单位为区块。</li><li>-u   搭配”-l”参数列表，会用分区数目取代柱面数目，来表示每个分区的起始地址。</li><li>-v   显示版本信息。</li></ul><h3 id="fsck-ext2-file-system-check-second-filesystem"><a href="#fsck-ext2-file-system-check-second-filesystem" class="headerlink" title="fsck.ext2(file system check-second filesystem)"></a>fsck.ext2(file system check-second filesystem)</h3><p>功能说明：检查文件系统并尝试修复错误。</p><p>语　　法：<code>fsck.ext2 [-acdfFnprsStvVy][-b &lt;分区第一个磁区地址&gt;][-B &lt;区块大小&gt;][-C &lt;反叙述器&gt;][-I &lt;inode缓冲区块数&gt;][-l/L &lt;损坏区块文件&gt;][-P &lt;处理inode大小&gt;][外围设备代号]</code></p><p>补充说明：当ext2文件系统发生错误时，可用fsck.ext2指令尝试加以修复。</p><p>参　　数：</p><ul><li>-a   自动修复文件系统，不询问任何问题。</li><li>-b&lt;分区第一个磁区地址&gt;   指定分区的第一个磁区的起始地址，也就是Super Block。</li><li>-B&lt;区块大小&gt;   设置该分区每个区块的大小。</li><li>-c   检查指定的文件系统内，是否存在有损坏的区块。</li><li>-C&lt;反叙述器&gt;   指定反叙述器，fsck.ext2指令会把全部的执行过程，都交由其逆向叙述，便于排错或监控程序执行的情形。</li><li>-d   详细显示指令执行过程，便于排错或分析程序执行的情形。</li><li>-f   强制对该文件系统进行完整检查，纵然该文件系统在慨略检查下没有问题。</li><li>-F   检查文件系统之前，先清理该保存设备块区内的数据。</li><li>-I&lt;inode缓冲区块数&gt;   设置欲检查的文件系统，其inode缓冲区的区块数目。</li><li>-l&lt;损坏区块文件&gt;   把文件中所列出的区块，视为损坏区块并将其标示出来，避免应用程序使用该区块。</li><li>-L&lt;损坏区块文件&gt;   此参数的效果和指定”-l”参数类似，但在参考损坏区块文件标示损坏区块之前，会先将原来标示成损坏区块者统统清楚，即全部重新设置，而非仅是加入新的损坏区块标示。</li><li>-n   把欲检查的文件系统设成只读，并关闭互动模式，否决所有询问的问题。</li><li>-p   此参数的效果和指定”-a”参数相同。</li><li>-P&lt;处理inode大小&gt;   设置fsck.ext2指令所能处理的inode大小为多少。</li><li>-r   此参数将忽略不予处理，仅负责解决兼容性的问题。</li><li>-s   检查文件系统时，交换每对字节的内容。</li><li>-S   此参数的效果和指定”-s”参数类似，但不论该文件系统是否已是标准位顺序，一律交换每对字节的内容。</li><li>-t   显示fsck.ext2指令的时序信息。</li><li>-v   详细显示指令执行过程。</li><li>-V   显示版本信息。</li><li>-y   关闭互动模式，且同意所有询问的问题。</li></ul><h3 id="fsck-file-system-check"><a href="#fsck-file-system-check" class="headerlink" title="fsck(file system check)"></a>fsck(file system check)</h3><p>功能说明：检查文件系统并尝试修复错误。</p><p>语　　法：<code>fsck [-aANPrRsTV][-t &lt;文件系统类型&gt;][文件系统…]</code></p><p>补充说明：当文件系统发生错误四化，可用fsck指令尝试加以修复。</p><p>参　　数：</p><ul><li>-a   自动修复文件系统，不询问任何问题。</li><li>-A   依照/etc/fstab配置文件的内容，检查文件内所列的全部文件系统。</li><li>-N   不执行指令，仅列出实际执行会进行的动作。</li><li>-P   当搭配”-A”参数使用时，则会同时检查所有的文件系统。</li><li>-r   采用互动模式，在执行修复时询问问题，让用户得以确认并决定处理方式。</li><li>-R   当搭配”-A”参数使用时，则会略过/目录的文件系统不予检查。</li><li>-s   依序执行检查作业，而非同时执行。</li><li>-t&lt;文件系统类型&gt;   指定要检查的文件系统类型。</li><li>-T   执行fsck指令时，不显示标题信息。</li><li>-V   显示指令执行过程。</li></ul><h3 id="fsck-minix-file-system-check-minix-filesystem"><a href="#fsck-minix-file-system-check-minix-filesystem" class="headerlink" title="fsck.minix(file system check-minix filesystem)"></a>fsck.minix(file system check-minix filesystem)</h3><p>功能说明：检查文件系统并尝试修复错误。</p><p>语　　法：<code>fsck.minix [-aflmrsv][外围设备代号]</code></p><p>补充说明：当minix文件系统发生错误时，可用fsck.minix指令尝试加以参考。</p><p>参　　数：</p><ul><li>-a   自动修复文件系统，不询问任何问题。</li><li>-f   强制对该文件系统进行完整检查，纵然该文件系统在慨略检查下没有问题。</li><li>-l   列出所有文件名称。</li><li>-m   使用类似MINIX操作系统的警告信息。</li><li>-r   采用互动模式，在执行修复时询问问题，让用户得以确认并决定处理方式。</li><li>-s   显示该分区第一个磁区的相关信息。</li><li>-v   显示指令执行过程。</li></ul><h3 id="fsconf-file-system-configurator"><a href="#fsconf-file-system-configurator" class="headerlink" title="fsconf(file system configurator)"></a>fsconf(file system configurator)</h3><p>功能说明：设置文件系统相关功能。</p><p>语　　法：<code>fsconf [–check]</code></p><p>补充说明：fsconf是Red Hat Linux发行版专门用来调整Linux各项设置的程序。</p><p>参　　数：</p><ul><li>–chedk   检查特定文件的权限。</li></ul><h3 id="hdparm-hard-disk-parameters"><a href="#hdparm-hard-disk-parameters" class="headerlink" title="hdparm(hard disk parameters)"></a>hdparm(hard disk parameters)</h3><p>功能说明：显示与设定硬盘的参数。</p><p>语　　法：<code>hdparm [-CfghiIqtTvyYZ][-a &lt;快取分区&gt;][-A &lt;0或1&gt;][-c &lt;I/O模式&gt;][-d &lt;0或1&gt;][-k &lt;0或1&gt;][-K &lt;0或1&gt;][-m &lt;分区数&gt;][-n &lt;0或1&gt;][-p &lt;PIO模式&gt;][-P &lt;分区数&gt;][-r &lt;0或1&gt;][-S &lt;时间&gt;][-u &lt;0或1&gt;][-W &lt;0或1&gt;][-X &lt;传输模式&gt;][设备]</code></p><p>补充说明：hdparm可检测，显示与设定IDE或SCSI硬盘的参数。</p><p>参　　数：</p><ul><li>-a&lt;快取分区&gt;   设定读取文件时，预先存入块区的分区数，若不加上&lt;快取分区&gt;选项，则显示目前的设定。</li><li>-A&lt;0或1&gt;   启动或关闭读取文件时的快取功能。</li><li>-c&lt;I/O模式&gt;   设定IDE32位I/O模式。</li><li>-C   检测IDE硬盘的电源管理模式。</li><li>-d&lt;0或1&gt;   设定磁盘的DMA模式。</li><li>-f   将内存缓冲区的数据写入硬盘，并清楚缓冲区。</li><li>-g   显示硬盘的磁轨，磁头，磁区等参数。</li><li>-h   显示帮助。</li><li>-i   显示硬盘的硬件规格信息，这些信息是在开机时由硬盘本身所提供。</li><li>-I   直接读取硬盘所提供的硬件规格信息。</li><li>-k&lt;0或1&gt;   重设硬盘时，保留-dmu参数的设定。</li><li>-K&lt;0或1&gt;   重设硬盘时，保留-APSWXZ参数的设定。</li><li>-m&lt;磁区数&gt;   设定硬盘多重分区存取的分区数。</li><li>-n&lt;0或1&gt;   忽略硬盘写入时所发生的错误。</li><li>-p&lt;PIO模式&gt;   设定硬盘的PIO模式。</li><li>-P&lt;磁区数&gt;   设定硬盘内部快取的分区数。</li><li>-q   在执行后续的参数时，不在屏幕上显示任何信息。</li><li>-r&lt;0或1&gt;   设定硬盘的读写模式。</li><li>-S&lt;时间&gt;   设定硬盘进入省电模式前的等待时间。</li><li>-t   评估硬盘的读取效率。</li><li>-T   平谷硬盘快取的读取效率。</li><li>-u&lt;0或1&gt;   在硬盘存取时，允许其他中断要求同时执行。</li><li>-v   显示硬盘的相关设定。</li><li>-W&lt;0或1&gt;   设定硬盘的写入快取。</li><li>-X&lt;传输模式&gt;   设定硬盘的传输模式。</li><li>-y   使IDE硬盘进入省电模式。</li><li>-Y   使IDE硬盘进入睡眠模式。</li><li>-Z   关闭某些Seagate硬盘的自动省电功能。</li></ul><h3 id="losetup-loop-setup"><a href="#losetup-loop-setup" class="headerlink" title="losetup(loop setup)"></a>losetup(loop setup)</h3><p>功能说明：设置循环设备。</p><p>语　　法：<code>losetup [-d][-e &lt;加密方式&gt;][-o &lt;平移数目&gt;][循环设备代号][文件]</code></p><p>补充说明：循环设备可把文件虚拟成区块设备，籍以模拟整个文件系统，让用户得以将其视为硬盘驱动器，光驱或软驱等设备，并挂入当作目录来使用。</p><p>参　　数：</p><ul><li>-d   卸除设备。</li><li>-e&lt;加密方式&gt;   启动加密编码。</li><li>-o&lt;平移数目&gt;   设置数据平移的数目。</li></ul><h3 id="mbadblocks"><a href="#mbadblocks" class="headerlink" title="mbadblocks"></a>mbadblocks</h3><p>功能说明：检查MS-DOS文件系统的磁盘是否有损坏的磁区。</p><p>语　　法：<code>mbadblocks [驱动器代号]</code></p><p>补充说明：mbadblocks为mtools工具指令，可用来扫描MS-DOS文件系统的磁盘驱动器，并标示出损坏的磁区。</p><h3 id="mformat"><a href="#mformat" class="headerlink" title="mformat"></a>mformat</h3><p>功能说明：对MS-DOS文件系统的磁盘进行格式化。</p><p>语　　法：<code>mformat [-1aCFIKX][-0 &lt;数据传输率&gt;][-2 &lt;磁区数&gt;][-A &lt;数据传输率&gt;][-B &lt;开机区文件&gt;][-c &lt;丛集大小&gt;][-h &lt;磁头数&gt;][-H &lt;隐藏磁区数&gt;][-l &lt;磁盘标签&gt;][-M &lt;磁区大小&gt;][-n &lt;序号&gt;][-r &lt;根目录大小&gt;][-s &lt;磁区数&gt;][-S &lt;磁区大小&gt;][-t &lt;柱面数&gt;][驱动器代号]</code></p><p>补充说明：mformat为mtools工具指令，模拟MS-DOS的format指令，可将指定的磁盘或硬盘分区格式化为MS-DOS文件系统。</p><p>参　　数：</p><ul><li>-0&lt;数据传输率&gt;   指定第0磁轨的数据传输率。</li><li>-1   不使用2M格式。</li><li>-2&lt;磁区数&gt;   指定在第0磁轨的第0个磁头的磁区数，也就是所谓的2M格式。</li><li>-a   指定产生Atari格式的序号。</li><li>-A&lt;数据传输率&gt;   指定第0磁轨以外所有磁轨的数据传输率。</li><li>-B&lt;开机区文件&gt;   从指定的文件来建立开机区。</li><li>-c&lt;丛集大小&gt;   指定丛集大小，单位为磁区。</li><li>-C   建立磁盘MS-DOS文件系统的映像文件。</li><li>-F   以FAT32来格式化磁盘。</li><li>-H&lt;隐藏磁区数&gt;   指定隐藏磁区的数目。</li><li>-I   指定FAT32的frVersion编号。</li><li>-k   尽可能地保留原有的开机区。</li><li>-l&lt;磁盘标签&gt;   指定磁盘标签名称。</li><li>-M&lt;磁区大小&gt;   指定MS-DOS文件系统所使用的磁区大小，预设应该与硬体磁区大小相同，单位为字节。</li><li>-n&lt;序号&gt;   指定序号。</li><li>-r&lt;根目录大小&gt;   指定根目录的大小，单位为磁区。</li><li>-s&lt;磁区数&gt;   指定每一磁轨所包含的磁区数目。</li><li>-S&lt;磁区大小&gt;   指定硬件磁区大小。</li><li>-t&lt;柱面数&gt;   指定柱面数目。</li><li>-X   格式化XDF磁盘。</li></ul><h3 id="mkbootdisk-make-boot-disk"><a href="#mkbootdisk-make-boot-disk" class="headerlink" title="mkbootdisk(make boot disk)"></a>mkbootdisk(make boot disk)</h3><p>功能说明：建立目前系统的启动盘。</p><p>语　　法：<code>mkbootdisk [–noprompt][–verbose][–version][–device &lt;设备&gt;][–mkinitrdargs &lt;参数&gt;][kernel 版本]</code></p><p>补充说明：mkbootdisk可建立目前系统的启动盘。</p><p>参　　数：</p><ul><li>–device&lt;设备&gt;   指定设备。</li><li>–mkinitrdargs&lt;参数&gt;   设置mkinitrd的参数。</li><li>–noprompt   不会提示用户插入磁盘。</li><li>–verbose   执行时显示详细的信息。</li><li>–version   显示版本信息。</li></ul><h3 id="mkdosfs-make-Dos-file-system"><a href="#mkdosfs-make-Dos-file-system" class="headerlink" title="mkdosfs(make Dos file system)"></a>mkdosfs(make Dos file system)</h3><p>功能说明：建立MS-DOS文件系统。</p><p>语　　法：<code>mkdosfs [-cv][-f &lt;FAT数目&gt;][-F &lt;FAT记录的单位&gt;][-i &lt;磁盘序号&gt;][-l &lt;文件名&gt;][-m &lt;信息文件&gt;][-n &lt;标签&gt;][-r &lt;根目录项目数&gt;][-s &lt;磁区数&gt;][设备名称][区块数]</code></p><p>补充说明：mkdosfs可在Linux下，将磁盘格式化为MS-DOS文件系统的格式。</p><p>参　　数：</p><ul><li>-c   检查是否有损坏的区块。</li><li>-f&lt;FAT数目&gt;   指定FAT的数目，目前支持1与2两种选项。</li><li>-F&lt;FAT记录的单位&gt;   指定FAT记录的单位为12或16位。</li><li>-i&lt;磁盘序号&gt;   设置文件系统的磁盘序号。</li><li>-l&lt;文件名&gt;   从指定的文件中，读取文件系统中损坏区块的信息。</li><li>-m&lt;信息文件&gt;   若以次文件系统开机，而却因操作系统没有正常安装，则会显示选项中所指定的信息文件内容。</li><li>-n&lt;标签&gt;   设置文件系统的磁盘标签名称。</li><li>-r&lt;根目录项目数&gt;   设置根目录最多能记载项目数。</li><li>-s&lt;磁区数&gt;   指定每个丛集所包含的磁区数。</li><li>-v   执行时显示详细的信息。</li></ul><h3 id="mke2fs-make-ext2-file-system"><a href="#mke2fs-make-ext2-file-system" class="headerlink" title="mke2fs(make ext2 file system)"></a>mke2fs(make ext2 file system)</h3><p>功能说明：建立ext2文件系统。</p><p>语　　法：<code>mke2fs [-cFMqrSvV][-b &lt;区块大小&gt;][-f &lt;不连续区段大小&gt;][-i &lt;字节&gt;][-N &lt;inode数&gt;][-l &lt;文件&gt;][-L &lt;标签&gt;][-m &lt;百分比值&gt;][-R=&lt;区块数&gt;][ 设备名称][区块数]</code></p><p>补充说明：mke2fs可建立Linux的ext2文件系统。</p><p>参　　数：</p><ul><li>-b&lt;区块大小&gt;   指定区块大小，单位为字节。</li><li>-c   检查是否有损坏的区块。</li><li>-f&lt;不连续区段大小&gt;   指定不连续区段的大小，单位为字节。</li><li>-F   不管指定的设备为何，强制执行mke2fs。</li><li>-i&lt;字节&gt;   指定”字节/inode”的比例。</li><li>-N&lt;inode数&gt;   指定要建立的inode数目。</li><li>-l&lt;文件&gt;   从指定的文件中，读取文件西中损坏区块的信息。</li><li>-L&lt;标签&gt;   设置文件系统的标签名称。</li><li>-m&lt;百分比值&gt;   指定给管理员保留区块的比例，预设为5%。</li><li>-M   记录最后一次挂入的目录。</li><li>-q   执行时不显示任何信息。</li><li>-r   指定要建立的ext2文件系统版本。</li><li>-R=&lt;区块数&gt;   设置磁盘阵列参数。</li><li>-S   仅写入superblock与group descriptors，而不更改inode able inode bitmap以及block bitmap。</li><li>-v   执行时显示详细信息。</li><li>-V   显示版本信息。</li></ul><h3 id="mkfs-ext2"><a href="#mkfs-ext2" class="headerlink" title="mkfs.ext2"></a>mkfs.ext2</h3><p>功能说明：与mke2fs相同。</p><h3 id="mkfs-make-file-system"><a href="#mkfs-make-file-system" class="headerlink" title="mkfs(make file system)"></a>mkfs(make file system)</h3><p>功能说明：建立各种文件系统。</p><p>语　　法：<code>mkfs [-vV][fs][-f &lt;文件系统类型&gt;][设备名称][区块数]</code></p><p>补充说明：mkfs本身并不执行建立文件系统的工作，而是去调用相关的程序来执行。</p><p>参　　数：</p><ul><li>fs   指定建立文件系统时的参数。</li><li>-t&lt;文件系统类型&gt;   指定要建立何种文件系统。</li><li>-v   显示版本信息与详细的使用方法。</li><li>-V   显示简要的使用方法。</li></ul><h3 id="mkfs-minix"><a href="#mkfs-minix" class="headerlink" title="mkfs.minix"></a>mkfs.minix</h3><p>功能说明：建立Minix文件系统。</p><p>语　　法：<code>mkfs.minix [-cv][-i &lt;inode数目&gt;][-l &lt;文件&gt;][-n &lt;文件名长度&gt;][设备名称][区块数]</code></p><p>补充说明：mkfs.minix可建立Minix文件系统。</p><p>参　　数：</p><ul><li>-c   检查是否有损坏的区块。</li><li>-i&lt;inode数目&gt;   指定文件系统的inode总数。</li><li>-l&lt;文件&gt;   从指定的文件中，读取文件系统中损坏区块的信息。</li><li>-n&lt;文件名长度&gt;   指定文件名称长度的上限。</li><li>-v   建立第2版的Minix文件系统。</li></ul><h3 id="mkfs-msdos"><a href="#mkfs-msdos" class="headerlink" title="mkfs.msdos"></a>mkfs.msdos</h3><p>功能说明：与mkdosfs相同。</p><h3 id="mkinitrd-make-initial-ramdisk-images"><a href="#mkinitrd-make-initial-ramdisk-images" class="headerlink" title="mkinitrd(make initial ramdisk images)"></a>mkinitrd(make initial ramdisk images)</h3><p>功能说明：建立要载入ramdisk的映像文件。</p><p>语　　法：<code>mkinitrd [-fv][–omit-scsi-modules][–version][–preload=&lt;模块名称&gt;][–with=&lt;模块名称&gt;][映像文件][Kernel 版本]</code></p><p>补充说明：mkinitrd可建立映像文件，以供Linux开机时载入ramdisk。</p><p>参　　数：</p><ul><li>-f   若指定的映像问家名称与现有文件重复，则覆盖现有的文件。</li><li>-v　　执行时显示详细的信息。</li><li>–omit-scsi-modules   不要载入SCSI模块。</li><li>–preload=&lt;模块名称&gt;   指定要载入的模块。</li><li>–with=&lt;模块名称&gt;   指定要载入的模块。</li><li>–version   显示版本信息。</li></ul><h3 id="mkisofs-make-iso-file-system"><a href="#mkisofs-make-iso-file-system" class="headerlink" title="mkisofs(make iso file system)"></a>mkisofs(make iso file system)</h3><p>功能说明：建立ISO 9660映像文件。</p><p>语　　法：<code>mkisofs [-adDfhJlLNrRTvz][-print-size][-quiet][-A &lt;应用程序ID&gt;][-abstract &lt;摘要文件&gt;][-b &lt;开机映像文件&gt;][-biblio &lt;ISBN文件&gt;][-c &lt;开机文件名称&gt;][-C &lt;盘区编号，磁区编号&gt;][-copyright &lt;版权信息文件&gt;][-hide &lt;目录或文件名&gt;][-hide-joliet &lt;文件或目录名&gt;][-log-file &lt;记录文件&gt;][-m &lt;目录或文件名&gt;][-M &lt;开机映像文件&gt;][-o &lt;映像文件&gt;][-p &lt;数据处理人&gt;][-P &lt;光盘发行人&gt;][-sysid &lt;系统ID &gt;][-V &lt;光盘ID &gt;][-volset &lt;卷册集ID&gt;][-volset-size &lt;光盘总数&gt;][-volset-seqno &lt;卷册序号&gt;][-x &lt;目录&gt;][目录或文件]</code></p><p>补充说明：mkisofs可将指定的目录与文件做成ISO 9660格式的映像文件，以供刻录光盘。</p><p>参　　数：</p><ul><li>-a或–all   mkisofs通常不处理备份文件。使用此参数可以把备份文件加到映像文件中。</li><li>-A&lt;应用程序ID&gt;或-appid&lt;应用程序ID&gt;   指定光盘的应用程序ID。</li><li>-abstract&lt;摘要文件&gt;   指定摘要文件的文件名。</li><li>-b&lt;开机映像文件&gt;或-eltorito-boot&lt;开机映像文件&gt;   指定在制作可开机光盘时所需的开机映像文件。</li><li>-biblio&lt;ISBN文件&gt;   指定ISBN文件的文件名，ISBN文件位于光盘根目录下，记录光盘的ISBN。</li><li>-c&lt;开机文件名称&gt;   制作可开机光盘时，mkisofs会将开机映像文件中的全-eltorito-catalog&lt;开机文件名称&gt;全部内容作成一个文件。</li><li>-C&lt;盘区编号，盘区编号&gt;   将许多节区合成一个映像文件时，必须使用此参数。</li><li>-copyright&lt;版权信息文件&gt;   指定版权信息文件的文件名。</li><li>-d或-omit-period   省略文件后的句号。</li><li>-D或-disable-deep-relocation   ISO 9660最多只能处理8层的目录，超过8层的部分，RRIP会自动将它们设置成ISO 9660兼容的格式。使用-D参数可关闭此功能。</li><li>-f或-follow-links   忽略符号连接。</li><li>-h   显示帮助。</li><li>-hide&lt;目录或文件名&gt;   使指定的目录或文件在ISO 9660或Rock RidgeExtensions的系统中隐藏。</li><li>-hide-joliet&lt;目录或文件名&gt;   使指定的目录或文件在Joliet系统中隐藏。</li><li>-J或-joliet   使用Joliet格式的目录与文件名称。</li><li>-l或-full-iso9660-filenames   使用ISO 9660 32字符长度的文件名。</li><li>-L或-allow-leading-dots   允许文件名的第一个字符为句号。</li><li>-log-file&lt;记录文件&gt;   在执行过程中若有错误信息，预设会显示在屏幕上。</li><li>-m&lt;目录或文件名&gt;或-exclude&lt;目录或文件名&gt;   指定的目录或文件名将不会房入映像文件中。</li><li>-M&lt;映像文件&gt;或-prev-session&lt;映像文件&gt;   与指定的映像文件合并。</li><li>-N或-omit-version-number   省略ISO 9660文件中的版本信息。</li><li>-o&lt;映像文件&gt;或-output&lt;映像文件&gt;   指定映像文件的名称。</li><li>-p&lt;数据处理人&gt;或-preparer&lt;数据处理人&gt;   记录光盘的数据处理人。</li><li>-print-size   显示预估的文件系统大小。</li><li>-quiet   执行时不显示任何信息。</li><li>-r或-rational-rock   使用Rock Ridge Extensions，并开放全部文件的读取权限。</li><li>-R或-rock   使用Rock Ridge Extensions。</li><li>-sysid&lt;系统ID&gt;   指定光盘的系统ID。</li><li>-T或-translation-table   建立文件名的转换表，适用于不支持Rock Ridge Extensions的系统上。</li><li>-v或-verbose   执行时显示详细的信息。</li><li>-V&lt;光盘ID&gt;或-volid&lt;光盘ID&gt;   指定光盘的卷册集ID。</li><li>-volset-size&lt;光盘总数&gt;   指定卷册集所包含的光盘张数。</li><li>-volset-seqno&lt;卷册序号&gt;   指定光盘片在卷册集中的编号。</li><li>-x&lt;目录&gt;   指定的目录将不会放入映像文件中。</li><li>-z   建立通透性压缩文件的SUSP记录，此记录目前只在Alpha机器上的Linux有效。</li></ul><h3 id="mkswap"><a href="#mkswap" class="headerlink" title="mkswap"></a>mkswap</h3><p>功能说明：设置交换区(swap area)。</p><p>语　　法：<code>mkswap [-cf][-v0][-v1][设备名称或文件][交换区大小]</code></p><p>补充说明：mkswap可将磁盘分区或文件设为Linux的交换区。</p><p>参　　数：</p><ul><li>-c   建立交换区前，先检查是否有损坏的区块。</li><li>-f   在SPARC电脑上建立交换区时，要加上此参数。</li><li>-v0   建立旧式交换区，此为预设值。</li><li><p>-v1   建立新式交换区。</p><p>  [交换区大小]   指定交换区的大小，单位为1024字节。</p></li></ul><h3 id="mpartition"><a href="#mpartition" class="headerlink" title="mpartition"></a>mpartition</h3><p>功能说明：建立或删除MS-DOS的分区。</p><p>语　　法：<code>mpartition [-acdfIprv][-b &lt;磁区数&gt;][-h &lt;磁头数&gt;][l &lt;磁区数&gt;][-s &lt;磁区数&gt;][-t &lt;柱面数&gt;][驱动器代号]</code></p><p>补充说明：mpartition为mtools工具指令，可建立或删除磁盘分区。</p><p>参　　数：</p><ul><li>-a   将分区设置为可开机分区。</li><li>-b&lt;磁区数&gt;   建立分区时，指定要从第几个磁区开始建立分区。</li><li>-c   建立分区。</li><li>-d   将分区设置为无法开机的分区。</li><li>-f   强制地修改分区而不管检查时发生的错误信息。</li><li>-h&lt;磁头数&gt;   建立分区时，指定分区的磁头数。</li><li>-I   删除全部的分区。</li><li>-l&lt;磁区数&gt;   建立分区时，指定分区的容量大小，单位为磁区数。</li><li>-p   当要重新建立分区时，显示命令列。</li><li>-r   删除分区。</li><li>-s&lt;磁区数&gt;   建立分区时，指定每个磁轨的磁区数。</li><li>-t&lt;柱面数&gt;   建立分区时，指定分区的柱面数。</li><li>-v   与-p参数一并使用，若没有同时下达修改分区的命令，则显示目前分区的状态。</li></ul><h3 id="sfdisk"><a href="#sfdisk" class="headerlink" title="sfdisk"></a>sfdisk</h3><p>功能说明：硬盘恩区工具程序。</p><p>语　　法：<code>sfdisk [-?Tvx][-d &lt;硬盘&gt;][-g &lt;硬盘&gt;][-l &lt;硬盘&gt;][-s &lt;分区&gt;][-V &lt;硬盘&gt;]</code></p><p>补充说明：sfdisk为硬盘分区工具程序，可显示分区的设置信息，并检查分区是否正常。</p><p>参　　数：</p><ul><li>-?或–help   显示帮助。</li><li>-d&lt;硬盘&gt;   显示硬盘分区的设置。</li><li>-g&lt;硬盘&gt;或–show-geometry&lt;硬盘&gt;   显示硬盘的CHS参数。</li><li>-l&lt;硬盘&gt;   显示后硬盘分区的相关设置。</li><li>-s&lt;分区&gt;   显示分区的大小，单位为区块。</li><li>-T或–list-types   显示所有sfdisk能辨识的文件系统ID。</li><li>-v或–version   显示版本信息。</li><li>-V&lt;硬盘&gt;或–verify&lt;硬盘&gt;   检查硬盘分区是否正常。</li><li>-x或–show-extend   显示扩展分区中的逻辑分区。</li></ul><h3 id="swapoff"><a href="#swapoff" class="headerlink" title="swapoff"></a>swapoff</h3><p>功能说明：关闭系统交换区(swap area)。</p><p>语　　法：<code>swapoff [设备]</code></p><p>补充说明：swapoff实际上为swapon的符号连接，可用来关闭系统的交换区。</p><h3 id="swapon"><a href="#swapon" class="headerlink" title="swapon"></a>swapon</h3><p>功能说明：启动系统交换区(swap area)。</p><p>语　　法：<code>swapon [-ahsV][-p &lt;优先顺序&gt;][设备]</code></p><p>补充说明：Linux系统的内存管理必须使用交换区来建立虚拟内存。</p><p>参　　数：</p><ul><li>-a   将/etc/fstab文件中所有设置为swap的设备，启动为交换区。</li><li>-h   显示帮助。</li><li>-p&lt;优先顺序&gt;   指定交换区的优先顺序。</li><li>-s   显示交换区的使用状况。</li><li>-V   显示版本信息。</li></ul><h3 id="symlinks-symbolic-links"><a href="#symlinks-symbolic-links" class="headerlink" title="symlinks(symbolic links)"></a>symlinks(symbolic links)</h3><p>功能说明：维护符号连接的工具程序。</p><p>语　　法：<code>symlinks [-cdrstv][目录]</code></p><p>补充说明：symlinks可检查目录中的符号连接，并显示符号连接类型。以下为symlinks可判断的符号连接类型：</p><ul><li>absolute：符号连接使用了绝对路径。</li><li>dangling：原始文件已经不存在。</li><li>lengthy：符号连接的路径中包含了多余的”../“。</li><li>messy：符号连接的路径中包含了多余的”/“。</li><li>other_fs：原始文件位于其他文件系统中。</li><li>relative：符号连接使用了相对路径。</li></ul><p>参　　数：</p><ul><li>-c   将使用绝对路径的符号连接转换为相对路径。</li><li>-d   移除dangling类型的符号连接。</li><li>-r   检查目录下所有子目录中的符号连接。</li><li>-s   检查lengthy类型的符号连接。</li><li>-t   与-c一并使用时，会显示如何将绝对路径的符号连接转换为相对路径，但不会实际转换。</li><li>-v   显示所有类型的符号连接。</li></ul><h3 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h3><p>功能说明：将内存缓冲区内的数据写入磁盘。</p><p>语　　法：<code>sync [–help][–version]</code></p><p>补充说明：在Linux系统中，当数据需要存入磁盘时，通常会先放到缓冲区内，等到适当的时刻再写入磁盘，如此可提高系统的执行效率。</p><p>参　　数：</p><ul><li>–help   显示帮助。</li><li>–version   显示版本信息。</li></ul><h2 id="linux网络通讯命令"><a href="#linux网络通讯命令" class="headerlink" title="linux网络通讯命令"></a>linux网络通讯命令</h2><h3 id="dip"><a href="#dip" class="headerlink" title="dip"></a>dip</h3><p>功能说明：IP拨号连接。</p><p>语　　法：<code>dip [-aikltv][-m&lt;MTU数目&gt;][-p&lt;协议&gt;][拨号script文件]</code></p><p>补充说明：dip可控制调制解调器，以拨号IP的方式建立对外的双向连接。</p><p>参　　数：</p><ul><li>-a   询问用户名称与密码。</li><li>-i   启动拨号服务器功能。</li><li>-k   删除执行中的dip程序。</li><li>-l   指定要删除的连线，必须配合-k参数一起使用。</li><li>-m&lt;MTU数目&gt;   设置最大传输单位，预设值为296。</li><li>-p&lt;协议&gt;   设置通信协议。</li><li>-t   进入dip的指令模式。</li><li>-v   执行时显示详细的信息。</li></ul><h3 id="getty-get-teletypewriter"><a href="#getty-get-teletypewriter" class="headerlink" title="getty(get teletypewriter)"></a>getty(get teletypewriter)</h3><p>功能说明：设置终端机模式，连线速率和管制线路。</p><p>语　　法：<code>getty [-h][-d&lt;组态配置文件&gt;][-r&lt;延迟秒数&gt;][-t&lt;超时秒数&gt;][-w&lt;等待字符串&gt;][终端机编号][连线速率&lt;终端机类型&gt;&lt;管制线路&gt;] 或 getty [-c&lt;定义配置文件&gt;]</code></p><p>补充说明：getty指令是UNIX之类操作系统启动时所必须的3个步骤之一。</p><p>参　　数：</p><ul><li>-c&lt;定义配置文件&gt;   指定定义配置文件，预设为/etc/gettydefs。</li><li>-d&lt;组态配置文件&gt;   指定组态配置文件，预设为/etc/conf.getty。</li><li>-h   当传输速率为0时就强制断线。</li><li>-r&lt;延迟秒数&gt;   设置延迟时间。</li><li>-t&lt;超时秒数&gt;   设置等待登入的时间。</li><li>-w&lt;等待字符串&gt;   设置等待回应的字符串。</li></ul><h3 id="mingetty"><a href="#mingetty" class="headerlink" title="mingetty"></a>mingetty</h3><p>功能说明：精简版的getty。</p><p>语　　法：<code>mingetty [–long-hostname][–noclear][tty]</code></p><p>补充说明：mingetty适用于本机上的登入程序。</p><p>参　　数：</p><ul><li>–long-hostname   显示完整的主机名称。</li><li>–noclear   在询问登入的用户名称之前不要清楚屏幕画面。</li></ul><h3 id="ppp-off"><a href="#ppp-off" class="headerlink" title="ppp-off"></a>ppp-off</h3><p>功能说明：关闭ppp连线。</p><p>语　　法：<code>ppp-off</code></p><p>补充说明：这是Slackware发行版内附的程序，让用户切断PPP的网络连线。</p><h3 id="smbd-samba-daemon"><a href="#smbd-samba-daemon" class="headerlink" title="smbd(samba daemon)"></a>smbd(samba daemon)</h3><p>功能说明：Samba服务器程序。</p><p>语　　法：<code>smbd [-aDhoP][-d&lt;排错层级&gt;][-i&lt;范围&gt;][-l&lt;记录文件&gt;][-O&lt;连接槽选项&gt;][-p&lt;连接端口编号&gt;][-s&lt;配置文件&gt;]</code></p><p>补充说明：smbd为Samba服务器程序，可分享文件与打印机等网络资源供Windows相关的用户端程序存取。</p><p>参　　数：</p><ul><li>-a   所有的连线记录都会加到记录文件中。</li><li>-d&lt;排错层级&gt;   指定记录文件所记载事件的详细程度。</li><li>-D   使用此参数时，smbd会以服务程序的方式在后台执行。</li><li>-h   显示帮助。</li><li>-i&lt;范围&gt;   指定NetBIOS名称的范围。</li><li>-l&lt;记录文件&gt;   指定记录文件的名称。</li><li>-o   每次启动时，会覆盖原有的记录文件。</li><li>-O&lt;连接槽选项&gt;   设置连接槽选项。</li><li>-p&lt;连接端口编号&gt;   设置连接端口编号。</li><li>-P   仅用来测试smbd程序的正确性。</li><li>-s&lt;配置文件&gt;   指定smbd的设置文件。</li></ul><h3 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a><font color="red">telnet</font></h3><p>功能说明：远端登入。</p><p>语　　法：<code>telnet [-8acdEfFKLrx][-b&lt;主机别名&gt;][-e&lt;脱离字符&gt;][-k&lt;域名&gt;][-l&lt;用户名称&gt;][-n&lt;记录文件&gt;][-S&lt;服务类型&gt;][-X&lt;认证形态&gt;][主机名称或IP地址&lt;通信端口&gt;]</code></p><p>补充说明：执行telnet指令开启终端机阶段作业，并登入远端主机。</p><p>参　　数：</p><ul><li>-8   允许使用8位字符资料，包括输入与输出。</li><li>-a   尝试自动登入远端系统。</li><li>-b&lt;主机别名&gt;   使用别名指定远端主机名称。</li><li>-c   不读取用户专属目录里的.telnetrc文件。</li><li>-d   启动排错模式。</li><li>-e&lt;脱离字符&gt;   设置脱离字符。</li><li>-E   滤除脱离字符。</li><li>-f   此参数的效果和指定”-F”参数相同。</li><li>-F   使用Kerberos V5认证时，加上此参数可把本地主机的认证数据上传到远端主机。</li><li>-k&lt;域名&gt;   使用Kerberos认证时，加上此参数让远端主机采用指定的领域名，而非该主机的域名。</li><li>-K   不自动登入远端主机。</li><li>-l&lt;用户名称&gt;   指定要登入远端主机的用户名称。</li><li>-L   允许输出8位字符资料。</li><li>-n&lt;记录文件&gt;   指定文件记录相关信息。</li><li>-r   使用类似rlogin指令的用户界面。</li><li>-S&lt;服务类型&gt;   设置telnet连线所需的IP TOS信息。</li><li>-x   假设主机有支持数据加密的功能，就使用它。</li><li>-X&lt;认证形态&gt;   关闭指定的认证形态。</li></ul><h3 id="uulog"><a href="#uulog" class="headerlink" title="uulog"></a>uulog</h3><p>功能说明：显示UUCP记录文件。</p><p>语　　法：<code>uulog [-DFISv][-&lt;行数&gt;][-f&lt;主机&gt;][-I&lt;配置文件&gt;][-n&lt;行数&gt;][-s&lt;主机&gt;][-u&lt;用户&gt;][-X&lt;层级&gt;][–help]</code></p><p>补充说明：uulog可用来显示UUCP记录文件中记录。</p><p>参　　数：</p><ul><li>-D或–debuglog   显示排错记录。</li><li>-f&lt;主机&gt;或–follow&lt;主机&gt;   与-F参数类似，但仅显示与指定主机相关的记录。</li><li>-I&lt;配置文件&gt;或–config&lt;配置文件&gt;   指定程序的配置文件。</li><li>-&lt;行数&gt;,-n&lt;行数&gt;或–lines&lt;行数&gt;   显示记录文件中，从最后算起指定行数的数值。</li><li>-s&lt;主机&gt;   仅显示记录文件中，与指定文件相关的记录。</li><li>-S或–statslog   显示统计记录。</li><li>-u&lt;用户&gt;或–suer&lt;用户&gt;   仅显示记录文件中，与指定用户相关的记录。</li><li>-v或–version   显示版本信息。</li><li>-X&lt;层级&gt;或–debug&lt;层级&gt;   设定排错层级。</li><li>–help   显示帮助。</li></ul><h3 id="uustat"><a href="#uustat" class="headerlink" title="uustat"></a>uustat</h3><p>功能说明：显示UUCP目前的状况。</p><p>语　　法：<code>uustat [-aeiKmMNpqQRv][-B&lt;行数&gt;][-c&lt;指令&gt;][-C&lt;指令&gt;][-I&lt;配置文件&gt;][-k&lt;工作&gt;][-o&lt;小时&gt;][-r&lt;工作&gt;][-s&lt;主机&gt;][-S&lt;主机&gt;][-u&lt;用户&gt;][-U&lt;用户&gt;][-W&lt;附注&gt;][-y&lt;小时&gt;][-x&lt;层级&gt;][–help]</code></p><p>补充说明：执行uucp与uux指令后，会先将工作送到队列，再由uucico来执行工作。uustat可显示，删除或启动队列中等待执行的工作。</p><p>参　　数：</p><ul><li>-a或-all   显示全部的UUCP工作。</li><li>-B&lt;行数&gt;或–mail-lines&lt;行数&gt;   与-M或-N参数一并使用，用来指定邮件中要包含多少行的信息。</li><li>-c&lt;指令&gt;或–command&lt;指令&gt;   显示与&lt;指令&gt;有关的工作。</li><li>-C&lt;指令&gt;或–not-command&lt;指令&gt;   显示与&lt;指令&gt;无关的工作。</li><li>-e或–executions   仅显示待执行的工作。</li><li>-i或–prompt   针对队列中的每项工作，询问使用是否要删除工作。</li><li>-I&lt;配置文件&gt;或–config&lt;配置文件&gt;   指定配置文件。</li><li>-k&lt;工作&gt;或–kill&lt;工作&gt;   删除指定的工作。</li><li>-m或–status   删除全部的工作。</li><li>-M或-mail   将状态信息邮寄给UUCP管理员。</li><li>-N或–notify   将状态信息分别邮寄给提出该项工作的用户。</li><li>-o&lt;小时&gt;或–older-than&lt;小时&gt;   显示超过指定时数的工作。</li><li>-p或–ps   显示负责UUCP锁定的程序。</li><li>-q或–list   显示每台远端主机上所要执行工作的状态。</li><li>-Q或–no-list   不显示工作。</li><li>-r&lt;工作&gt;或–rejuvenate&lt;工作&gt;   重新启动指定的工作。</li><li>-R或–rejuvenate-all   重新启动全部的工作。</li><li>-s&lt;主机&gt;或–system&lt;主机&gt;   显示与&lt;主机&gt;有关的工作。</li><li>-S&lt;主机&gt;或–not-system&lt;主机&gt;   显示与&lt;主机&gt;无关的工作。</li><li>-v或–version   显示版本信息。</li><li>-u&lt;用户&gt;或–user&lt;用户&gt;   显示与&lt;用户&gt;有关的工作。</li><li>-U&lt;用户&gt;或–not-user&lt;用户&gt;   显示与&lt;用户&gt;无关的工作。</li><li>-W&lt;附注&gt;或–comment&lt;附注&gt;   要放在邮件信息中的附注。</li><li>-y&lt;小时&gt;或–younger-than&lt;小时&gt;   显示低于指定时数的工作。</li><li>-x&lt;层级&gt;或–debug&lt;层级&gt;   指定排错层级。</li><li>–help   显示帮助。</li></ul><h3 id="uux"><a href="#uux" class="headerlink" title="uux"></a>uux</h3><p>功能说明：在远端的UUCP主机上执行指令。</p><p>语　　法：<code>uux [-bcCIjlnrvz][-a&lt;地址&gt;][-g&lt;等级&gt;][-s&lt;文件&gt;][-x&lt;层级&gt;][–help][指令]</code></p><p>补充说明：uux可在远端的UUCP主机上执行指令或是执行本机上的指令，但在执行时会使用远端电脑的文件。</p><p>参　　数：</p><ul><li>-或-p或–stdin   直接从键盘读取要执行的指令。</li><li>-a&lt;地址&gt;或–requestor&lt;地址&gt;   执行邮件地址，以便寄送状态信息。</li><li>-b或–erturn-stdin   在屏幕上显示状态信息。</li><li>-c或–nocopy   不用将文件复制到缓冲区。</li><li>-C或–copy   将文件复制到缓冲区。</li><li>-g&lt;等级&gt;或–grade&lt;等级&gt;   指定文件传送作业的优先顺序。</li><li>-I或–config file   指定uux配置文件。</li><li>-j或–jobid   显示作业编号。</li><li>-l或–link   将本机上的文件连接到缓冲区。</li><li>-n或–notification=no   无论发生任何状态，都不寄邮件通知用户。</li><li>-r或–nouucico   不要立即启动uucico服务程序，仅将作业送到队列中，然后再执行。</li><li>-s&lt;文件&gt;或–status&lt;文件&gt;   将完成状态保存为指定的文件。</li><li>-v或–version   显示版本信息。</li><li>-x&lt;层级&gt;或–debug&lt;层级&gt;   指定排错层级。</li><li>-z或–notification=error   若发生错误，则以邮件来通知用户。</li><li>–help   显示帮助。</li></ul><h3 id="cu-call-up"><a href="#cu-call-up" class="headerlink" title="cu(call up)"></a>cu(call up)</h3><p>功能说明：连接另一个系统主机。</p><p>语　　法：<code>cu [dehnotv][-a&lt;通信端口&gt;][-c&lt;电话号码&gt;][-E&lt;脱离字符&gt;][-I&lt;设置文件&gt;][-l&lt;外围设备代号&gt;][-s&lt;连线速率&gt;][-x&lt;排错模式&gt;][-z&lt;系统主机&gt;][–help][-nostop][–parity=none][&lt;系统主机&gt;/&lt;电话号码&gt;]</code></p><p>补充说明：本指令可连接另一台主机，并采用类似拨号终端机的接口工作，也可执行简易的文件传输作业。</p><p>参　　数：</p><ul><li>-a&lt;通信端口&gt;或-p&lt;通信端口&gt;或–port&lt;通信端口&gt;   使用指定的通信端口进行连线。</li><li>-c&lt;电话号码&gt;或–phone&lt;电话号码&gt;   拨打该电话号码。</li><li>-d   进入排错模式。</li><li>-e或–parity=even   使用双同位检查。</li><li>-E&lt;脱离字符&gt;或–escape&lt;脱离字符&gt;   设置脱离字符。</li><li>-h或–halfduple   使用半双工模式。</li><li>-I&lt;配置文件&gt;或–config&lt;配置文件&gt;   指定要使用的配置文件。</li><li>-l&lt;外围设备代号&gt;或–line&lt;外围设备代号&gt;   指定某项外围设备，作为连接的设备。</li><li>-n或–prompt   拨号时等待用户输入电话号码。</li><li>-o或–parity=odd   使用单同位检查。</li><li>-s&lt;连线速率&gt;或–speed&lt;连线速率&gt;或–baud&lt;连线速率&gt;或-&lt;连线速率&gt;   设置连线的速率，单位以鲍率计算。</li><li>-t或–maper   把CR字符置换成LF+CR字符。</li><li>-v或–version   显示版本信息。</li><li>-x&lt;排错模式&gt;或–debug&lt;排错模式&gt;   使用排错模式。</li><li>-z&lt;系统主机&gt;或–system&lt;系统主机&gt;   连接该系统主机。</li><li>–help   在线帮助。</li><li>–nostop   关闭Xon/Xoff软件流量控制。</li><li>–parity=none   不使用同位检查。</li></ul><h3 id="dnsconf-dns-configurator"><a href="#dnsconf-dns-configurator" class="headerlink" title="dnsconf(dns configurator)"></a>dnsconf(dns configurator)</h3><p>功能说明：设置DNS服务器组态。</p><p>语　　法：<code>dnsconf [–deldomain&lt;域&gt;][–delsecondary&lt;域&gt;][–newdomain&lt;域&gt;][–set&lt;主机&gt;&lt;IP&gt;][–setcname&lt;CNAME&gt;&lt;主机&gt;][–setmx&lt;域&gt;&lt;主机&gt;][–setns&lt;域&gt;&lt;主机&gt;][–unset&lt;主机&gt;]</code></p><p>补充说明：dnsconf实际上为linuxconf的符号连接，提供图形截面的操作方式，供管理员管理DNS服务器。</p><p>参　　数：</p><ul><li>–deldomain&lt;域&gt;   删除域。</li><li>–delsecondary&lt;域&gt;   删除次级域。</li><li>–newdomain&lt;域&gt;   新增域。</li><li>–set&lt;主机&gt;&lt;IP&gt;   新增主机记录。</li><li>–setcname&lt;CNAME&gt;&lt;主机&gt;   设置&lt;CNAME&gt;。</li><li>–setmx&lt;域&gt;&lt;主机&gt;   指定域的邮件主机。</li><li>–setns&lt;域&gt;&lt;主机&gt;   指定域的DNS服务器。</li><li>–unset&lt;主机&gt;   删除DNS中某台主机的记录。</li></ul><h3 id="efax"><a href="#efax" class="headerlink" title="efax"></a>efax</h3><p>功能说明：收发传真。</p><p>语　　法：<code>efax [-sw][-a&lt;AT指令&gt;][-c&lt;调制解调器属性&gt;][-d&lt;驱动程序&gt;][-f&lt;字体文件&gt;][-g&lt;指令&gt;][-h&lt;传真标题字符串&gt;][-i&lt;AT指令&gt;][-j&lt;AT指令&gt;][-k&lt;AT指令&gt;][-l&lt;识别码&gt;][-o&lt;选项&gt;][-q&lt;错误次数&gt;][-r&lt;文件名&gt;][-v&lt;信息类型&gt;][-x&lt;UUCP锁定文件&gt;][-t&lt;电话号码&gt;&lt;传真文件&gt;]</code></p><p>补充说明：支持Class 1与Class 2的调制解调器来收发传真。</p><p>参　　数：</p><ul><li>-a&lt;AT指令&gt;   以指定的AT指令来接电话。</li><li>-c&lt;调制解调器属性&gt;   设置本机调制解调器的属性。</li><li>-d&lt;驱动程序&gt;   指定调制解调器驱动程序。</li><li>-f&lt;字体文件&gt;   使用指定的字体文件来建立传真标题。</li><li>-g&lt;指令&gt;   若接到的电话为数据，则执行指定的指令。</li><li>-h&lt;传真标题字符串&gt;   指定字符串为每页最前端的标题。</li><li>-i&lt;AT指令&gt;   在调制解调器进入传真模式前，传送AT指令到调制解调器。</li><li>-j&lt;AT指令&gt;   在调制解调器进入传真模式后，传送AT指令到调制解调器。</li><li>-k&lt;AT指令&gt;   在调制解调器离开传真模式前，传送AT指令到调制解调器。</li><li>-l&lt;识别码&gt;   设置本机调制解调器的识别码。</li><li>-o&lt;选项&gt;   使用非标准调制解调器时设置相关选项。</li><li>-q&lt;错误次数&gt;   接收传真时，当每页发生错误次数超过指定的数目时，要求对方重发。</li><li>-r&lt;文件名&gt;   在接收传真时，将每页分别保存成文件。</li><li>-v&lt;信息类型&gt;   选择要印出的信息类型。</li><li>-w   不要接听电话，等待OK或CONNECT的信号。</li><li>-x&lt;UUCP锁定文件&gt;   使用UUCP格式的锁定文件来锁定调制解调器。</li><li>-t&lt;电话号码&gt;&lt;传真文件&gt;   以&lt;电话号码&gt;中的号码来拨号，并将&lt;传真文件&gt;传真出去。</li></ul><h3 id="httpd-http-daemon"><a href="#httpd-http-daemon" class="headerlink" title="httpd(http daemon)"></a>httpd(http daemon)</h3><p>功能说明：Apache HTTP服务器程序。</p><p>语　　法：<code>httpd [-hlLStvVX][-c&lt;httpd指令&gt;][-C&lt;httpd指令&gt;][-d&lt;服务器根目录&gt;][-D&lt;设定文件参数&gt;][-f&lt;设定文件&gt;]</code></p><p>补充说明：httpd为Apache HTTP服务器程序。直接执行程序可启动服务器的服务。</p><p>参　　数：</p><ul><li>-c&lt;httpd指令&gt;   在读取配置文件前，先执行选项中的指令。</li><li>-C&lt;httpd指令&gt;   在读取配置文件后，再执行选项中的指令。</li><li>-d&lt;服务器根目录&gt;   指定服务器的根目录。</li><li>-D&lt;设定文件参数&gt;   指定要传入配置文件的参数。</li><li>-f&lt;设定文件&gt;   指定配置文件。</li><li>-h   显示帮助。</li><li>-l   显示服务器编译时所包含的模块。</li><li>-L   显示httpd指令的说明。</li><li>-S   显示配置文件中的设定。</li><li>-t   测试配置文件的语法是否正确。</li><li>-v   显示版本信息。</li><li>-V   显示版本信息以及建立环境。</li><li>-X   以单一程序的方式来启动服务器。</li></ul><h3 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h3><p>功能说明：显示或设置网络设备。</p><p>语　　法：<code>ifconfig [网络设备][down up -allmulti -arp -promisc][add&lt;地址&gt;][del&lt;地址&gt;][&lt;hw&lt;网络设备类型&gt;&lt;硬件地址&gt;][io_addr&lt;I/O地址&gt;][irq&lt;IRQ地址&gt;][media&lt;网络媒介类型&gt;][mem_start&lt;内存地址&gt;][metric&lt;数目&gt;][mtu&lt;字节&gt;][netmask&lt;子网掩码&gt;][tunnel&lt;地址&gt;][-broadcast&lt;地址&gt;][-pointopoint&lt;地址&gt;][IP地址]</code></p><p>补充说明：ifconfig可设置网络设备的状态，或是显示目前的设置。</p><p>参　　数：</p><ul><li>add&lt;地址&gt;   设置网络设备IPv6的IP地址。</li><li>del&lt;地址&gt;   删除网络设备IPv6的IP地址。</li><li>down   关闭指定的网络设备。</li><li>hw&lt;网络设备类型&gt;&lt;硬件地址&gt;   设置网络设备的类型与硬件地址。</li><li>io_addr&lt;I/O地址&gt;   设置网络设备的I/O地址。</li><li>irq&lt;IRQ地址&gt;   设置网络设备的IRQ。</li><li>media&lt;网络媒介类型&gt;   设置网络设备的媒介类型。</li><li>mem_start&lt;内存地址&gt;   设置网络设备在主内存所占用的起始地址。</li><li>metric&lt;数目&gt;   指定在计算数据包的转送次数时，所要加上的数目。</li><li>mtu&lt;字节&gt;   设置网络设备的MTU。</li><li>netmask&lt;子网掩码&gt;   设置网络设备的子网掩码。</li><li>tunnel&lt;地址&gt;   建立IPv4与IPv6之间的隧道通信地址。</li><li>up   启动指定的网络设备。</li><li>-broadcast&lt;地址&gt;   将要送往指定地址的数据包当成广播数据包来处理。</li><li>-pointopoint&lt;地址&gt;   与指定地址的网络设备建立直接连线，此模式具有保密功能。</li><li><p>-promisc   关闭或启动指定网络设备的promiscuous模式。</p><p>  [IP地址]   指定网络设备的IP地址。<br>  [网络设备]   指定网络设备的名称。</p></li></ul><h3 id="mesg"><a href="#mesg" class="headerlink" title="mesg"></a>mesg</h3><p>功能说明：设置终端机的写入权限。</p><p>语　　法：<code>mesg [ny]</code></p><p>补充说明：将mesg设置y时，其他用户可利用write指令将信息直接显示在您的屏幕上。</p><p>参　　数：</p><ul><li>n   不允许其他用户将信息直接显示在你的屏幕上。</li><li>y   允许其他用户将信息直接显示在你的屏幕上。</li></ul><h3 id="minicom"><a href="#minicom" class="headerlink" title="minicom"></a>minicom</h3><p>功能说明：调制解调器通信程序。</p><p>语　　法：<code>minicom [-8lmMostz][-a&lt;on或0ff&gt;][-c&lt;on或off&gt;][-C&lt;取文件&gt;][-d&lt;编号&gt;][-p&lt;模拟终端机&gt;][-S&lt;script文件&gt;][配置文件]</code></p><p>补充说明：minicom是一个相当受欢迎的PPP拨号连线程序。</p><p>参　　数：</p><ul><li>-8   不要修改任何8位编码的字符。</li><li>-a&lt;on或0ff&gt;   设置终端机属性。</li><li>-c&lt;on或off&gt;   设置彩色模式。</li><li>-C&lt;取文件&gt;   指定取文件，并在启动时开启取功能。</li><li>-d&lt;编号&gt;   启动或直接拨号。</li><li>-l   不会将所有的字符都转成ASCII码。</li><li>-m   以Alt或Meta键作为指令键。</li><li>-M   与-m参数类似。</li><li>-o   不要初始化调制解调器。</li><li>-p   &lt;模拟终端机&gt;   使用模拟终端机。</li><li>-s   开启程序设置画面。</li><li>-S&lt;script文件&gt;   在启动时，执行指定的script文件。</li><li>-t   设置终端机的类型。</li><li><p>-z   在终端机上显示状态列。</p><p>   [配置文件]   指定minicom配置文件。</p></li></ul><h3 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h3><p>功能说明：设置路由器。</p><p>语　　法：<code>nc [-hlnruz][-g&lt;网关…&gt;][-G&lt;指向器数目&gt;][-i&lt;延迟秒数&gt;][-o&lt;输出文件&gt;][-p&lt;通信端口&gt;][-s&lt;来源位址&gt;][-v…][-w&lt;超时秒数&gt;][主机名称][通信端口…]</code></p><p>补充说明：执行本指令可设置路由器的相关参数。</p><p>参　　数：</p><ul><li>-g&lt;网关&gt;   设置路由器跃程通信网关，最丢哦可设置8个。</li><li>-G&lt;指向器数目&gt;   设置来源路由指向器，其数值为4的倍数。</li><li>-h   在线帮助。</li><li>-i&lt;延迟秒数&gt;   设置时间间隔，以便传送信息及扫描通信端口。</li><li>-l   使用监听模式，管控传入的资料。</li><li>-n   直接使用IP地址，而不通过域名服务器。</li><li>-o&lt;输出文件&gt;   指定文件名称，把往来传输的数据以16进制字码倾倒成该文件保存。</li><li>-p&lt;通信端口&gt;   设置本地主机使用的通信端口。</li><li>-r   乱数指定本地与远端主机的通信端口。</li><li>-s&lt;来源位址&gt;   设置本地主机送出数据包的IP地址。</li><li>-u   使用UDP传输协议。</li><li>-v   显示指令执行过程。</li><li>-w&lt;超时秒数&gt;   设置等待连线的时间。</li><li>-z   使用0输入/输出模式，只在扫描通信端口时使用。</li></ul><h3 id="netconf"><a href="#netconf" class="headerlink" title="netconf"></a>netconf</h3><p>功能说明：设置各项网络功能。</p><p>语　　法：<code>netconf</code></p><p>补充说明：netconf是Red Hat Linux发行版专门用来调整Linux各项设置的程序。</p><h3 id="netconfig"><a href="#netconfig" class="headerlink" title="netconfig"></a>netconfig</h3><p>功能说明：设置网络环境。</p><p>语　　法：<code>netconfig</code></p><p>补充说明：这是Slackware发行版内附程序，它具有互动式的问答界面，让用户轻易完成网络环境的设置。</p><h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a><font color="red">netstat</font></h3><p>功能说明：显示网络状态。</p><p>语　　法：<code>netstat [-acCeFghilMnNoprstuvVwx][-A&lt;网络类型&gt;][–ip]</code></p><p>补充说明：利用netstat指令可让你得知整个Linux系统的网络情况。</p><p>参　　数：</p><ul><li>-a或–all   显示所有连线中的Socket。</li><li>-A&lt;网络类型&gt;或–&lt;网络类型&gt;   列出该网络类型连线中的相关地址。</li><li>-c或–continuous   持续列出网络状态。</li><li>-C或–cache   显示路由器配置的快取信息。</li><li>-e或–extend   显示网络其他相关信息。</li><li>-F或–fib   显示FIB。</li><li>-g或–groups   显示多重广播功能群组组员名单。</li><li>-h或–help   在线帮助。</li><li>-i或–interfaces   显示网络界面信息表单。</li><li>-l或–listening   显示监控中的服务器的Socket。</li><li>-M或–masquerade   显示伪装的网络连线。</li><li>-n或–numeric   直接使用IP地址，而不通过域名服务器。</li><li>-N或–netlink或–symbolic   显示网络硬件外围设备的符号连接名称。</li><li>-o或–timers   显示计时器。</li><li>-p或–programs   显示正在使用Socket的程序识别码和程序名称。</li><li>-r或–route   显示Routing Table。</li><li>-s或–statistice   显示网络工作信息统计表。</li><li>-t或–tcp   显示TCP传输协议的连线状况。</li><li>-u或–udp   显示UDP传输协议的连线状况。</li><li>-v或–verbose   显示指令执行过程。</li><li>-V或–version   显示版本信息。</li><li>-w或–raw   显示RAW传输协议的连线状况。</li><li>-x或–unix   此参数的效果和指定”-A unix”参数相同。</li><li>–ip或–inet   此参数的效果和指定”-A inet”参数相同。</li></ul><h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a><font color="red">ping</font></h3><p>功能说明：检测主机。</p><p>语　　法：<code>ping [-dfnqrRv][-c&lt;完成次数&gt;][-i&lt;间隔秒数&gt;][-I&lt;网络界面&gt;][-l&lt;前置载入&gt;][-p&lt;范本样式&gt;][-s&lt;数据包大小&gt;][-t&lt;存活数值&gt;][主机名称或IP地址]</code></p><p>补充说明：执行ping指令会使用ICMP传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。</p><p>参　　数：</p><ul><li>-d   使用Socket的SO_DEBUG功能。</li><li>-c&lt;完成次数&gt;   设置完成要求回应的次数。</li><li>-f   极限检测。</li><li>-i&lt;间隔秒数&gt;   指定收发信息的间隔时间。</li><li>-I&lt;网络界面&gt;   使用指定的网络界面送出数据包。</li><li>-l&lt;前置载入&gt;   设置在送出要求信息之前，先行发出的数据包。</li><li>-n   只输出数值。</li><li>-p&lt;范本样式&gt;   设置填满数据包的范本样式。</li><li>-q   不显示指令执行过程，开头和结尾的相关信息除外。</li><li>-r   忽略普通的Routing Table，直接将数据包送到远端主机上。</li><li>-R   记录路由过程。</li><li>-s&lt;数据包大小&gt;   设置数据包的大小。</li><li>-t&lt;存活数值&gt;   设置存活数值TTL的大小。</li><li>-v   详细显示指令的执行过程。</li></ul><h3 id="pppstats-point-to-point-protocol-status"><a href="#pppstats-point-to-point-protocol-status" class="headerlink" title="pppstats(point to point protocol status)"></a>pppstats(point to point protocol status)</h3><p>功能说明：显示PPP连线状态。</p><p>语　　法：<code>pppstats [-adrv][-c&lt;执行次数&gt;][-w&lt;间隔秒数&gt;][网络界面]</code></p><p>补充说明：利用pppstats指令可让你得知PPP连接网络的相关信息。</p><p>参　　数：</p><ul><li>-a   显示绝对统计值。</li><li>-c&lt;执行次数&gt;   设置回报状况的次数。</li><li>-d   显示相对统计值。</li><li>-r   显示数据包压缩比率的统计值。</li><li>-v   显示VJTCP文件头的压缩效率统计值。</li><li>-w&lt;间隔秒数&gt;   设置显示统计信息的间隔时间。</li></ul><h3 id="samba"><a href="#samba" class="headerlink" title="samba"></a>samba</h3><p>功能说明：Samba服务器控制。</p><p>语　　法：<code>samba [start][stop][status][restart]</code></p><p>补充说明：samba为script文件，可启动，停止Samba服务器或回报目前的状态。</p><p>参　　数：</p><ul><li>start   启动Samba服务器的服务。</li><li>stop    停止Samba服务器的服务。</li><li>status   显示Samba服务器目前的状态。</li><li>restart   重新启动Samba服务器。</li></ul><h3 id="setserial"><a href="#setserial" class="headerlink" title="setserial"></a>setserial</h3><p>功能说明：设置或显示串口的相关信息。</p><p>语　　法：<code>setserial [-abgGqvVz][设备][串口参数]</code></p><p>补充说明：setserial可用来设置串口或显示目前的设置。</p><p>参　　数：</p><ul><li>-a   显示详细信息。</li><li>-b   显示摘要信息。</li><li>-g   显示串口的相关信息。</li><li>-G   以指令列表的格式来显示信息。</li><li>-q   执行时显示较少的信息。</li><li>-v   执行时显示较多的信息。</li><li>-V   显示版本信息。</li><li>-z   设置前，先将所有的标记归零。</li></ul><h3 id="shapecfg-shaper-configuration"><a href="#shapecfg-shaper-configuration" class="headerlink" title="shapecfg(shaper configuration)"></a>shapecfg(shaper configuration)</h3><p>功能说明：管制网络设备的流量。</p><p>语　　法：<code>shapecfg attach [流量管制器][网络设备] 或  shapecfg speed [流量管制器][带宽]</code></p><p>补充说明：自Linux-2.15开始，便支持流量管制的功能。</p><p>参　　数：</p><ul><li>attach   将流量管制器与实际的网络设备结合。</li><li>speed   设置流量管制器的对外传输带宽。</li></ul><h3 id="smbd-samba-daemon-1"><a href="#smbd-samba-daemon-1" class="headerlink" title="smbd(samba daemon)"></a>smbd(samba daemon)</h3><p>功能说明：Samba服务器程序。</p><p>语　　法：<code>smbd [-aDhoP][-d&lt;排错层级&gt;][-i&lt;范围&gt;][-l&lt;记录文件&gt;][-O&lt;连接槽选项&gt;][-p&lt;连接端口编号&gt;][-s&lt;配置文件&gt;]</code></p><p>补充说明：smbd为Samba服务器程序，可分享文件与打印机等网络资源供Windows相关的用户端程序存取。</p><p>参　　数：</p><ul><li>-a   所有的连线记录都会加到记录文件中。</li><li>-d&lt;排错层级&gt;   指定记录文件所记载事件的详细程度。</li><li>-D   使用此参数时，smbd会以服务程序的方式在后台执行。</li><li>-h   显示帮助。</li><li>-i&lt;范围&gt;   指定NetBIOS名称的范围。</li><li>-l&lt;记录文件&gt;   指定记录文件的名称。</li><li>-o   每次启动时，会覆盖原有的记录文件。</li><li>-O&lt;连接槽选项&gt;   设置连接槽选项。</li><li>-p&lt;连接端口编号&gt;   设置连接端口编号。</li><li>-P   仅用来测试smbd程序的正确性。</li><li>-s&lt;配置文件&gt;   指定smbd的设置文件。</li></ul><h3 id="statserial-status-ofserial-port"><a href="#statserial-status-ofserial-port" class="headerlink" title="statserial(status ofserial port)"></a>statserial(status ofserial port)</h3><p>功能说明：显示串口状态。</p><p>语　　法：<code>statserial [-dnx][串口设备名称]</code></p><p>补充说明：statserial可显示各个接脚的状态，常用来判断串口是否正常。</p><p>参　　数：</p><ul><li>-d   以10进制数字来表示串口的状态。</li><li>-n   仅显示一次串口的状态后即结束程序。</li><li>-x   与-n参数类似，但是以16进制来表示。</li></ul><h3 id="talk"><a href="#talk" class="headerlink" title="talk"></a>talk</h3><p>功能说明：与其他用户交谈。</p><p>语　　法：<code>talk [用户名称][终端机编号]</code></p><p>补充说明：通过talk指令，你可以和另一个用户线上交谈。</p><h3 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h3><p>功能说明：倾倒网络传输数据。</p><p>语　　法：<code>tcpdump [-adeflnNOpqStvx][-c&lt;数据包数目&gt;][-dd][-ddd][-F&lt;表达文件&gt;][-i&lt;网络界面&gt;][-r&lt;数据包文件&gt;][-s&lt;数据包大小&gt;][-tt][-T&lt;数据包类型&gt;][-vv][-w&lt;数据包文件&gt;][输出数据栏位]</code></p><p>补充说明：执行tcpdump指令可列出经过指定网络界面的数据包文件头，在Linux操作系统中，你必须是系统管理员。</p><p>参　　数：</p><ul><li>-a   尝试将网络和广播地址转换成名称。</li><li>-c&lt;数据包数目&gt;   收到指定的数据包数目后，就停止进行倾倒操作。</li><li>-d   把编译过的数据包编码转换成可阅读的格式，并倾倒到标准输出。</li><li>-dd   把编译过的数据包编码转换成C语言的格式，并倾倒到标准输出。</li><li>-ddd   把编译过的数据包编码转换成十进制数字的格式，并倾倒到标准输出。</li><li>-e   在每列倾倒资料上显示连接层级的文件头。</li><li>-f   用数字显示网际网络地址。</li><li>-F&lt;表达文件&gt;   指定内含表达方式的文件。</li><li>-i&lt;网络界面&gt;   使用指定的网络截面送出数据包。</li><li>-l   使用标准输出列的缓冲区。</li><li>-n   不把主机的网络地址转换成名字。</li><li>-N   不列出域名。</li><li>-O   不将数据包编码最佳化。</li><li>-p   不让网络界面进入混杂模式。</li><li>-q   快速输出，仅列出少数的传输协议信息。</li><li>-r&lt;数据包文件&gt;   从指定的文件读取数据包数据。</li><li>-s&lt;数据包大小&gt;   设置每个数据包的大小。</li><li>-S   用绝对而非相对数值列出TCP关联数。</li><li>-t   在每列倾倒资料上不显示时间戳记。</li><li>-tt   在每列倾倒资料上显示未经格式化的时间戳记。</li><li>-T&lt;数据包类型&gt;   强制将表达方式所指定的数据包转译成设置的数据包类型。</li><li>-v   详细显示指令执行过程。</li><li>-vv   更详细显示指令执行过程。</li><li>-x   用十六进制字码列出数据包资料。</li><li>-w&lt;数据包文件&gt;   把数据包数据写入指定的文件。</li></ul><h3 id="testparm-test-parameter"><a href="#testparm-test-parameter" class="headerlink" title="testparm(test parameter)"></a>testparm(test parameter)</h3><p>功能说明：测试Samba的设置是否正确无误。</p><p>语　　法：<code>testparm [-s][配置文件][&lt;主机名称&gt;&lt;IP地址&gt;]</code></p><p>补充说明：执行testparm指令可以简单测试Samba的配置文件，假如测试结果无误，Samba常驻服务就能正确载入该设置值，但并不保证其后的操作如预期般一切正常。</p><p>参　　数：</p><ul><li>-s   不显示提示符号等待用户按下Enter键，就直接列出Samba服务定义信息。</li></ul><h3 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h3><p>功能说明：显示数据包到主机间的路径。</p><p>语　　法：<code>traceroute [-dFlnrvx][-f&lt;存活数值&gt;][-g&lt;网关&gt;…][-i&lt;网络界面&gt;][-m&lt;存活数值&gt;][-p&lt;通信端口&gt;][-s&lt;来源地址&gt;][-t&lt;服务类型&gt;][-w&lt;超时秒数&gt;][主机名称或IP地址][数据包大小]</code></p><p>补充说明：traceroute指令让你追踪网络数据包的路由途径，预设数据包大小是40Bytes，用户可另行设置。</p><p>参　　数：</p><ul><li>-d   使用Socket层级的排错功能。</li><li>-f&lt;存活数值&gt;   设置第一个检测数据包的存活数值TTL的大小。</li><li>-F   设置勿离断位。</li><li>-g&lt;网关&gt;   设置来源路由网关，最多可设置8个。</li><li>-i&lt;网络界面&gt;   使用指定的网络界面送出数据包。</li><li>-I   使用ICMP回应取代UDP资料信息。</li><li>-m&lt;存活数值&gt;   设置检测数据包的最大存活数值TTL的大小。</li><li>-n   直接使用IP地址而非主机名称。</li><li>-p&lt;通信端口&gt;   设置UDP传输协议的通信端口。</li><li>-r   忽略普通的Routing Table，直接将数据包送到远端主机上。</li><li>-s&lt;来源地址&gt;   设置本地主机送出数据包的IP地址。</li><li>-t&lt;服务类型&gt;   设置检测数据包的TOS数值。</li><li>-v   详细显示指令的执行过程。</li><li>-w&lt;超时秒数&gt;   设置等待远端主机回报的时间。</li><li>-x   开启或关闭数据包的正确性检验。</li></ul><h3 id="tty-teletypewriter"><a href="#tty-teletypewriter" class="headerlink" title="tty(teletypewriter)"></a>tty(teletypewriter)</h3><p>功能说明：显示终端机连接标准输入设备的文件名称。</p><p>语　　法：<code>tty [-s][–help][–version]</code></p><p>补充说明：在Linux操作系统中，所有外围设备都有其名称与代号，这些名称代号以特殊文件的类型存放于/dev目录下。你可以执行tty指令查询目前使用的终端机的文件名称。</p><p>参　　数：</p><ul><li>-s或–silent或–quiet   不显示任何信息，只回传状态代码。</li><li>–help   在线帮助。</li><li>–version   显示版本信息。</li></ul><h3 id="uuname"><a href="#uuname" class="headerlink" title="uuname"></a>uuname</h3><p>功能说明：显示全部的UUCP远端主机。</p><p>语　　法：<code>uuname [-alv][-I&lt;配置文件&gt;][–help]</code></p><p>补充说明：uuname可显示UUCP远端主机。</p><p>参　　数：</p><ul><li>-a或–aliases   显示别名。</li><li>-I&lt;配置文件&gt;或–config&lt;配置文件&gt;   指定程序的配置文件。</li><li>-l或–local   显示本机名称。</li><li>-v或–version   显示版本信息。</li><li>–help   显示帮助。</li></ul><h3 id="wall-write-all"><a href="#wall-write-all" class="headerlink" title="wall(write all)"></a>wall(write all)</h3><p>功能说明：传送信息。</p><p>语　　法：<code>wall [公告信息]</code></p><p>补充说明：通过wall指令可将信息发送给每位同意接收公众信息的终端机用户，若不给予其信息内容，则wall指令会从标准输入设备读取数据，然后再把所得到的数据传送给所有终端机用户。</p><h3 id="write"><a href="#write" class="headerlink" title="write"></a>write</h3><p>功能说明：传送信息。</p><p>语　　法：<code>write [用户名称][终端机编号]</code></p><p>补充说明：通过write指令可传递信息给另一位登入系统的用户，当输入完毕后，键入EOF表示信息结束，write指令就会将信息传给对方。如果接收信息的用户不只登入本地主机一次，你可以指定接收信息的终端机编号。</p><h3 id="ytalk"><a href="#ytalk" class="headerlink" title="ytalk"></a>ytalk</h3><p>功能说明：与其他用户交谈。</p><p>语　　法：<code>ytalk [-isxY][-h&lt;主机名称IP地址&gt;][用户名称…]</code></p><p>补充说明：通过ytalk指令，你可以和其他用户线上交谈，如果想和其他主机的用户交谈，在用户名称后加上其主机名称或IP地址即可。</p><p>参　　数：</p><ul><li>-h&lt;主机名称IP地址&gt;   指定交谈对象所在的远端主机。</li><li>-i   用提醒声响代替显示信息。</li><li>-s   在指令提示符号先开启ytalk交谈窗。</li><li>-x   关闭图形界面。</li><li>-Y   所有必须回应yes或no的问题，都必须用大写英文字母”Y”或”N”回答。</li></ul><h3 id="arpwatch-ARP-watcher"><a href="#arpwatch-ARP-watcher" class="headerlink" title="arpwatch(ARP watcher)"></a>arpwatch(ARP watcher)</h3><p>功能说明：监听网络上ARP的记录。</p><p>语　　法：<code>arpwatch [-d][-f&lt;记录文件&gt;][-i&lt;接口&gt;][-r&lt;记录文件&gt;]</code></p><p>补充说明：ARP(Address Resolution Protocol)是用来解析IP与网络装置硬件地址的协议。arpwatch可监听区域网络中的ARP数据包并记录，同时将监听到的变化通过E-mail来报告。</p><p>参　　数：</p><ul><li>-d   启动排错模式。</li><li>-f&lt;记录文件&gt;   设置存储ARP记录的文件，预设为/var/arpwatch/arp.dat。</li><li>-i&lt;接口&gt;   指定监听ARP的接口，预设的接口为eth0。</li><li>-r&lt;记录文件&gt;   从指定的文件中读取ARP记录，而不是从网络上监听。</li></ul><h3 id="apachectl-Apache-control-interface"><a href="#apachectl-Apache-control-interface" class="headerlink" title="apachectl(Apache control interface)"></a>apachectl(Apache control interface)</h3><p>功能说明：可用来控制Apache HTTP服务器的程序。</p><p>语　　法：<code>apachectl [configtest][fullstatus][graceful][help][restart][start][status][stop]</code></p><p>补充说明：apachectl是slackware内附Apache HTTP服务器的script文件，可供管理员控制服务器，但在其他Linux的Apache HTTP服务器不一定有这个文件。</p><p>参　　数：</p><ul><li>configtest   检查设置文件中的语法是否正确。</li><li>fullstatus   显示服务器完整的状态信息。</li><li>graceful   重新启动Apache服务器，但不会中断原有的连接。</li><li>help   显示帮助信息。</li><li>restart   重新启动Apache服务器。</li><li>start   启动Apache服务器。</li><li>status   显示服务器摘要的状态信息。</li><li>stop   停止Apache服务器。</li></ul><h3 id="smbclient-samba-client"><a href="#smbclient-samba-client" class="headerlink" title="smbclient(samba client)"></a>smbclient(samba client)</h3><p>功能说明：可存取SMB/CIFS服务器的用户端程序。</p><p>语　　法：<code>smbclient [网络资源][密码][-EhLN][-B&lt;IP地址&gt;][-d&lt;排错层级&gt;][-i&lt;范围&gt;][-I&lt;IP地址&gt;][-l&lt;记录文件&gt;][-M&lt;NetBIOS名称&gt;][-n&lt;NetBIOS名称&gt;][-O&lt;连接槽选项&gt;][-p&lt;TCP连接端口&gt;][-R&lt;名称解析顺序&gt;][-s&lt;目录&gt;][-t&lt;服务器字码&gt;][-T&lt;tar选项&gt;][-U&lt;用户名称&gt;][-W&lt;工作群组&gt;]</code></p><p>补充说明：SMB与CIFS为服务器通信协议，常用于Windows95/98/NT等系统。smbclient可让Linux系统存取Windows系统所分享的资源。</p><p>参　　数：</p><ul><li>[网络资源]  [网络资源]的格式为//服务器名称/资源分享名称。</li><li>[密码]   输入存取网络资源所需的密码。</li><li>-B&lt;IP地址&gt;   传送广播数据包时所用的IP地址。</li><li>-d&lt;排错层级&gt;   指定记录文件所记载事件的详细程度。</li><li>-E   将信息送到标准错误输出设备。</li><li>-h   显示帮助。</li><li>-i&lt;范围&gt;   设置NetBIOS名称范围。</li><li>-I&lt;IP地址&gt;   指定服务器的IP地址。</li><li>-l&lt;记录文件&gt;   指定记录文件的名称。</li><li>-L   显示服务器端所分享出来的所有资源。</li><li>-M&lt;NetBIOS名称&gt;   可利用WinPopup协议，将信息送给选项中所指定的主机。</li><li>-n&lt;NetBIOS名称&gt;   指定用户端所要使用的NetBIOS名称。</li><li>-N   不用询问密码。</li><li>-O&lt;连接槽选项&gt;   设置用户端TCP连接槽的选项。</li><li>-p&lt;TCP连接端口&gt;   指定服务器端TCP连接端口编号。</li><li>-R&lt;名称解析顺序&gt;   设置NetBIOS名称解析的顺序。</li><li>-s&lt;目录&gt;   指定smb.conf所在的目录。</li><li>-t&lt;服务器字码&gt;   设置用何种字符码来解析服务器端的文件名称。</li><li>-T&lt;tar选项&gt;   备份服务器端分享的全部文件，并打包成tar格式的文件。</li><li>-U&lt;用户名称&gt;   指定用户名称。</li><li>-W&lt;工作群组&gt;   指定工作群组名称。</li></ul><h3 id="pppsetup"><a href="#pppsetup" class="headerlink" title="pppsetup"></a>pppsetup</h3><p>功能说明：设置PPP连线。</p><p>语　　法：<code>pppsetup</code></p><p>补充说明：这是Slackware发行版内附程序，它具有互动式的问答界面，让用户轻易完成PPP的连线设置。</p><h2 id="linux电子邮件与新闻组命令"><a href="#linux电子邮件与新闻组命令" class="headerlink" title="linux电子邮件与新闻组命令"></a>linux电子邮件与新闻组命令</h2><h3 id="archive"><a href="#archive" class="headerlink" title="archive"></a>archive</h3><p>功能说明：新闻组文件备存程序。</p><p>语　　法：<code>archive [-fmr][-a&lt;备存目录&gt;][-i&lt;索引文件&gt;][源文件]</code></p><p>补充说明：archive会读取新闻组的文件，然后加以备存。archive备存时，会保存[源文件]中文件的目录阶层。</p><p>参　　数：</p><ul><li>-a&lt;备存目录&gt;   指定备存的目录。</li><li>-f   将阶层目录名称的阶层关系取消，以句点来取代斜线。</li><li>-i&lt;索引文件&gt;   制作文件索引。</li><li>-m   将文件复制到目的地，建立文件连接后，以连接取代原始的文件。</li><li>-r   archive预设的标准错误输出为/var/errlog。-r参数可取消此功能。</li><li>[源文件]   在源文件中指定要备份的文件。</li></ul><h3 id="ctlinnd-control-the-internet-news-daemon"><a href="#ctlinnd-control-the-internet-news-daemon" class="headerlink" title="ctlinnd(control the internet news daemon)"></a>ctlinnd(control the internet news daemon)</h3><p>功能说明：设置INN新闻组服务器。</p><p>语　　法：<code>ctlinnd [-hs][-t&lt;超时秒数&gt;][控制命令&lt;设置数值&gt;…]</code></p><p>补充说明：通过ctlinnd指令，可以对新闻组服务器这项常驻服务下达控制命令，直接设置相关数值。</p><p>参　　数：</p><ul><li>-h   在线帮助。</li><li>-s   不显示指令执行过程。</li><li>-t&lt;超时秒数&gt;   设置等待服务器回报的时间，单位以秒计算，超过此一时间则为超时。</li></ul><h3 id="elm"><a href="#elm" class="headerlink" title="elm"></a>elm</h3><p>功能说明：E-mail管理程序。</p><p>语　　法：<code>elm [-s&lt;邮件主题&gt;][收信人别名或地址]&lt;[要输入的文件] 或 elm [-hmvz][-f&lt;目录&gt;][-i&lt;文件名&gt;]</code></p><p>补充说明：elm为全屏文字模式的电子邮件管理程序。与mail相比，elm提供较易操作的界面，但仍不及pine来得友善。</p><p>参　　数：</p><ul><li>-s&lt;邮件主题&gt;   指定新邮件的邮件主题。</li><li>-f&lt;目录&gt;   开启程序时，读取指定的目录。</li><li>-h   显示帮助。</li><li>-i&lt;文件名&gt;   将文件内容插入送出的邮件中。</li><li>-m   进入elm后，不显示指令说明。</li><li>-v   显示elm的版本信息。</li><li>-z   若收件信箱没有邮件，则不启动elm程序。</li></ul><h3 id="getlist"><a href="#getlist" class="headerlink" title="getlist"></a>getlist</h3><p>功能说明：下载新闻组清单。</p><p>语　　法：<code>getlist [-h&lt;新闻组服务器&gt;][-p&lt;通信端口&gt;][群组类型&lt;范本样式&gt;&lt;群组名称&gt;]</code></p><p>补充说明：getlist指令会从新闻服务器下载新闻组清单，并把清单输出到标准输出设备。</p><p>参　　数：</p><ul><li>-h&lt;新闻组服务器&gt;   指定欲连接的新闻组服务器。</li><li>-p&lt;通信端口&gt;   设置连接新闻组服务器的通讯端口。</li></ul><h3 id="inncheck-inn-check"><a href="#inncheck-inn-check" class="headerlink" title="inncheck(inn check)"></a>inncheck(inn check)</h3><p>功能说明：检查inn相关配置文件的语法是否正确。</p><p>语　　法：<code>inncheck [-afv][-pedantic][-perm][-noperm][文件]</code></p><p>补充说明：inncheck会检查inn配置文件的语法是否正确，但不会实际修改这些配置文件。</p><p>参　　数：</p><ul><li>-a   不管是否出现[文件]参数，仍然检查全部的配置文件。</li><li>-f   若发现配置文件有误，则列出可修正错误的指令。</li><li>-v   执行时显示详细的信息。</li><li>-pedantic   以较为严格的方式来检查。</li><li>-perm   检查文件权限是否有误。</li><li>–noperm   不检查文件的权限设置。</li><li>[文件]   若不指定此参数，则inncheck会检查所有预设的文件。</li></ul><h3 id="mail"><a href="#mail" class="headerlink" title="mail"></a>mail</h3><p>功能说明：E-mail管理程序。</p><p>语　　法：<code>mail [-iInNv][-b&lt;地址&gt;][-c&lt;地址&gt;][-f&lt;邮件文件&gt;][-s&lt;邮件主题&gt;][-u&lt;用户帐号&gt;][收信人地址]</code></p><p>补充说明：mail是一个文字模式的邮件管理程序，操作的界面不像elm或pine那么容易使用，但功能尚称完整。</p><p>参　　数：</p><ul><li>-b&lt;地址&gt;   指定密件副本的收信人地址。</li><li>-c&lt;地址&gt;   指定副本的收信人地址。</li><li>-f&lt;邮件文件&gt;   读取指定邮件文件中的邮件。</li><li>-i   不显示终端发出的信息。</li><li>-I   使用互动模式。</li><li>-n   程序使用时，不使用mail.rc文件中的设置。</li><li>-N   阅读邮件时，不显示邮件的标题。</li><li>-s&lt;邮件主题&gt;   指定邮件的主题。</li><li>-u&lt;用户帐号&gt;   读取指定用户的邮件。</li><li>-v   执行时，显示详细的信息。</li></ul><h3 id="mailconf"><a href="#mailconf" class="headerlink" title="mailconf"></a>mailconf</h3><p>功能说明：Sendmail设置程序。</p><p>语　　法：<code>mailconf [–addvdom&lt;虚拟网络&gt;][–delvdom&lt;虚拟网络&gt;][–help]</code></p><p>补充说明：mailconf实际为linuxconf的符号连接，用来设置Sendmail相关的选项。执行mailconf时，不管目前的环境为指令列模式或是X Window，都会出现图形界面的设置画面，让您轻松地完成设置。所有指令列的参数都可以在图形界面中设置。建议不用加上任何参数，直接进入mailconf的图形界面来设置。</p><h3 id="mailq-mail-queue"><a href="#mailq-mail-queue" class="headerlink" title="mailq(mail queue)"></a>mailq(mail queue)</h3><p>功能说明：显示待寄邮件的清单。</p><p>语　　法：<code>mailq [-q]</code></p><p>补充说明：mailq可列出待寄邮件的清单，包括邮件ID，邮件大小，邮件保存时间，寄信人，收信人，以及邮件无法寄出的原因，提供管理员参考的信息。mailq实际上是执行sendmail -bp指令。</p><p>参　　数：</p><ul><li>-v   显示较详细的信息。</li></ul><h3 id="messages"><a href="#messages" class="headerlink" title="messages"></a>messages</h3><p>功能说明：查看信箱中的邮件数。</p><p>语　　法：<code>messages [邮件目录或文件]</code></p><p>补充说明：messages实际上是一个script文件，可用来检查信箱中的邮件数。若不指定[邮件目录或文件]参数，则显示目前收件信箱中的邮件数。</p><h3 id="metamail"><a href="#metamail" class="headerlink" title="metamail"></a>metamail</h3><p>功能说明：负责处理非文字E-mail的程序。</p><p>语　　法：<code>metafile [-bBdehpPqrRTwxyz][-c&lt;邮件内容类型&gt;][-f&lt;寄信人地址&gt;][-m&lt;邮件管理程序名称&gt;][-s&lt;邮件主题&gt;][文件名]</code></p><p>补充说明：当E-mail管理程序遇到非ISO-8859-1标准文字的邮件内容，而不知道要如何处理的时候，即调用metamail。</p><p>参　　数：</p><ul><li>-b   邮件只有内文，没有表头。</li><li>-B   在背景显示信息。</li><li>-c&lt;邮件内容类型&gt;   不要读取邮件表头的”Content-type”栏位，而去读取&lt;邮件内容类型&gt;中的设置，以决定要调用哪个程序来处理邮件信息。</li><li>-d   metamail在调用其他程序显示信息前，不需向用户确认。</li><li>-e   删除内文前端的空白行。</li><li>-f&lt;寄信人地址&gt;   不要读取邮件表头中的寄信人地址，而去读取选项中的设置。</li><li>-h   使用metamail的邮件管理程序名称。</li><li>-m&lt;邮件管理程序名称&gt;   记录调用metamail的邮件管理程序名称。</li><li>-p   将显示内容送给more指令处理之后，再送到输出设备。</li><li>-P   与-p参数功能类似，但会在信息结束显示”Press RETURN to go on”字符串。</li><li>-q   metamail在调用其他程序来显示信息前，不用在屏幕上显示相关的信息。</li><li>-r   metamail预设无法让root用户执行。</li><li>-R   显示信息前先清除屏幕。</li><li>-s&lt;邮件主题&gt;   不要读取邮件表头中的邮件主题，而去读取选项中的设置。</li><li>-T   若要在一个新的终端机模拟视窗中重新启动metamail，则metamail必须以递归模式来调用程序本身，这时便需要使用-T参数。</li><li>-w   不要读取mailcap中的设置，而直接处理邮件，并将数据存入文件中。</li><li>-x   不要以终端机模式来执行，即不使用互动模式。</li><li>-y   抽出邮件内文中MIME格式的部分。</li><li>-z   程序结束时将输入的文件删除。</li></ul><h3 id="mutt"><a href="#mutt" class="headerlink" title="mutt"></a>mutt</h3><p>功能说明：E-mail管理程序。</p><p>语　　法：<code>mutt [-hnpRvxz][-a&lt;文件&gt;][-b&lt;地址&gt;][-c&lt;地址&gt;][-f&lt;邮件文件&gt;][-F&lt;配置文件&gt;][-H&lt;邮件草稿&gt;][-i&lt;文件&gt;][-m&lt;类型&gt;][-s&lt;主题&gt;][邮件地址]</code></p><p>补充说明：mutt是一个文字模式的邮件管理程序，提供了全屏幕的操作界面。</p><p>参　　数：</p><ul><li>-a&lt;文件&gt;   在邮件中加上附加文件。</li><li>-b&lt;地址&gt;   指定密件副本的收信人地址。</li><li>-c&lt;地址&gt;   指定副本的收信人地址。</li><li>-f&lt;邮件文件&gt;   指定要载入的邮件文件。</li><li>-F&lt;配置文件&gt;   指定mutt程序的设置文件，而不读取预设的.muttrc文件。</li><li>-h   显示帮助。</li><li>-H&lt;邮件草稿&gt;   将指定的邮件草稿送出。</li><li>-i&lt;文件&gt;   将指定文件插入邮件内文中。</li><li>-m&lt;类型&gt;   指定预设的邮件信箱类型。</li><li>-n   不要去读取程序培植文件(/etc/Muttrc)。</li><li>-p   在mutt中编辑完邮件后，而不想将邮件立即送出，可将该邮件暂缓寄出。</li><li>-R   以只读的方式开启邮件文件。</li><li>-s&lt;主题&gt;   指定邮件的主题。</li><li>-v   显示mutt的版本信息以及当初编译此文件时所给予的参数。</li><li>-x   模拟mailx的编辑方式。</li><li>-z   与-f参数一并使用时，若邮件文件中没有邮件即不启动mutt。</li></ul><h3 id="nntpget"><a href="#nntpget" class="headerlink" title="nntpget"></a>nntpget</h3><p>功能说明：下载新闻组文章。</p><p>语　　法：<code>nntpget [-ov][-d&lt;组类型清单&gt;][-f&lt;文件或目录&gt;][-n&lt;组名称清单&gt;][-t&lt;时间日期&gt;][-u&lt;文件或目录&gt;][新闻组服务器]</code></p><p>补充说明：执行nntpget指令将从指定的新闻组服务器下载文章。nntpget指令会从标准输入设备读取信息识别码，而下载的新闻文章则呈现到标准输出设备。</p><p>参　　数：</p><ul><li>-d&lt;组类型清单&gt;   指定新闻组类型为distribution的清单。</li><li>-f&lt;文件或目录&gt;   下载其更改时间较指定文件或目录的更改时间更接近现在的新闻文章。</li><li>-n&lt;组名称清单&gt;   指定新闻组名称的清单。</li><li>-o   下载本地主机所没有的新闻文章。</li><li>-t&lt;时间日期&gt;   指定时间与日期，较该日期时间更新的新闻文章都会被下载。</li><li>-u&lt;文件或目录&gt;   此参数的效果和指定”-f”参数类似，但它在成功下载文章之后会去更改指定文件或木的更改时间，便于下次再作为参考。</li><li>-v   当指令执行时，把每篇文章的信息识别码都送到标准输出。本参数需配合参数”-o”使用。</li></ul><h3 id="pine"><a href="#pine" class="headerlink" title="pine"></a>pine</h3><p>功能说明：收发电子邮件，浏览新闻组。</p><p>语　　法：<code>pine [-ahikorz][-attach&lt;附件&gt;][-attach_and_delete&lt;附件&gt;][-attachlist&lt;附件清单&gt;][-c&lt;邮件编号&gt;][-conf][-create_lu&lt;地址薄&gt;&lt;排序法&gt;][-f&lt;收件箱&gt;][-F&lt;文件&gt;][-I&lt;暂存快捷键&gt;][-n&lt;邮件编号&gt;][-nr][-p&lt;环境文件&gt;][-pinerc&lt;输出文件&gt;][-P&lt;配置文件&gt;][-sort&lt;排序法&gt;&lt;/reverse&gt;][-url&lt;URL&gt;][-&lt;功能选项&gt;=&lt;设置值&gt;][用户名称或电子邮件地址…]</code></p><p>补充说明：pine是个以显示导向为住的邮件处理程序，包括一般电子邮件和新闻组的文章。pine也支持MIME格式，可让用户将MIME的对象保存成文件，甚至指定外挂程序直接开启对象。</p><p>参　　数：</p><ul><li>-a   在UWIN中使用匿名模式。</li><li>-attach&lt;附件&gt;   把指定的文件附加在信件里，一并夹带寄出。</li><li>-attach_and_delete   此参数的效果和指定”-attach”参数类似，但在信件寄出后&lt;附件&gt;会将指定的文件删除。</li><li>-attachlist&lt;附件清单&gt;   设置一份文件清单，把该清单内的文件全部附加到信件中，夹带寄出。</li><li>-c&lt;邮件编号&gt;   直接开启指定编号的邮件。</li><li>-conf   产生pine.conf的范例文件，并输出到标准输出设备。</li><li>-create_lu&lt;地址薄&gt;&lt;排序法&gt;   将地址薄以指定的排序法排序，产生.addressbook.lu索引文件。</li><li>-f&lt;收件箱&gt;   开启指定的接收信件箱，而非预设的INBOX收件箱。</li><li>-F&lt;文件&gt;   直接浏览指定文件的内容。</li><li>-h   在线帮助。</li><li>-i   直接进入收件箱。</li><li>-I&lt;暂存快捷键&gt;   设置进入pine就要执行的命令，该命令以快捷键的按键指定。</li><li>-k   支持键盘上的F1,F2…等功能，而非使用一般快捷键。</li><li>-n&lt;邮件编号&gt;   设置现在的邮件编号。</li><li>-nr   使用UWIN的特殊模式。</li><li>-o   设置收件箱为只读。</li><li>-p&lt;环境文件&gt;   另外指定pine的环境文件。</li><li>-pinerc&lt;输出文件&gt;   读取.pinerc环境文件的内容并输出成文件保存起来，您必须指定输出文件的名称。</li><li>-r   展示模式。</li><li>-sort&lt;排序法&gt;   把收件箱内的信件依指定的方式排序。</li><li>-url&lt;URL&gt;   直接开启给予的URL。</li><li>-z   让pine可被Ctrl+z中断，暂存在后台作业里。</li><li>-&lt;功能选项&gt;=&lt;设置值&gt;   暂时指定各项功能的设置值。</li></ul><h3 id="slrn"><a href="#slrn" class="headerlink" title="slrn"></a>slrn</h3><p>功能说明：新闻组阅读程序。</p><p>语　　法：<code>slrn [-Cdnp][-create][-help][-f&lt;新闻组文件&gt;][-h&lt;服务器&gt;][–version]</code></p><p>补充说明：slrn是一个很容易使用的新闻组阅读程序，提供全屏幕的图形操作界面，让用户能轻松地阅读与管理新闻组。</p><p>参　　数：</p><ul><li>-C   使用彩色模式。</li><li>-d   下载组清单时，也一并下载每个组的说明。</li><li>-f&lt;新闻组文件&gt;   指定要存储组内容的文件，预设的文件名为.newsrc。</li><li>-h&lt;服务器&gt;   指定新闻组服务器。</li><li>-n   不要检查是否有新的新闻组。</li><li>-p   设置新闻组服务器的连接端口编号，预设为119。</li><li>-create   第一次连上某台新闻组服务器时，必须使用此参数，以便下载服务器中的组清单，并保存在指定的newsrc文件中。</li><li>-help   显示帮助。</li><li>–version   显示版本信息。</li></ul><h2 id="linux其他命令"><a href="#linux其他命令" class="headerlink" title="linux其他命令"></a>linux其他命令</h2><h3 id="reconfig"><a href="#reconfig" class="headerlink" title="reconfig"></a>reconfig</h3><p>功能说明：转换配置文件。</p><p>语　　法：<code>reconfig [Xconfig] XF86Config</code></p><p>补充说明：reconfig指令能将XFree86 3.1及以前的版本的配置文件，转成新的格式。现今的配置文件XF86Config，存放在/etc或/etc/X11目录下，它的格式包含了更多的信息，因此在转换之后，您还须自行编辑设置文件，输入不足的部分。</p><h3 id="startx-start-X-Window"><a href="#startx-start-X-Window" class="headerlink" title="startx(start X Window)"></a>startx(start X Window)</h3><p>功能说明：启动X Window。</p><p>语　　法：<code>startx [程序][–服务器设置]</code></p><p>补充说明：startx为启动X Window的script文件，实际上启动X Window的程序为xinit。</p><p>参　　数：</p><ul><li>[程序]   此处所指定的[程序]为X Window所要执行程序的配置文件。</li><li>[–服务器设置]   startx预设会去读取.xerverrc中的配置，决定启动X Window的方式。</li></ul><h3 id="xconfigurator"><a href="#xconfigurator" class="headerlink" title="xconfigurator"></a>xconfigurator</h3><p>功能说明：设置XFree86。</p><p>语　　法：<code>Xconfigurator [–card&lt;显卡型号&gt;][–expert][–help][–hsync”&lt;水平扫描频率&gt;”][-kickstart][–monitor&lt;显示器型号&gt;][–server&lt;显示服务器&gt;][–vsync”&lt;垂直扫描频率&gt;”]</code></p><p>补充说明：这是Red Hat公司遵循GPL规则所开发的程序，它具有互动式操作界面，您可以轻易地利用方向键和空格键等，设置显卡和显示器，并选择欲使用的画面分辨率与色彩深度，最后保存配置文件XF86Config。</p><p>参　　数：</p><ul><li>–card&lt;显卡型号&gt;   设置显卡的型号，可用”–help”参数查询型号列表。</li><li>–expert   启用专家模式，增加用户得以自行选择的项目而非由程序完全自动检测。</li><li>–help   在线帮助。</li><li>–hsync”&lt;水平扫描频率&gt;”   设置水平扫描频率。</li><li>–kickstart   启用全自动模式。</li><li>–monitor&lt;显示器型号&gt;   设置显示器型号，可用”–help”参数查询型号列表。</li><li>–server&lt;显示服务器&gt;   设置显示服务器。</li><li>–vsync”&lt;垂直扫描频率&gt;”   设置垂直扫描频率。</li></ul><h3 id="XF86Setup"><a href="#XF86Setup" class="headerlink" title="XF86Setup"></a>XF86Setup</h3><p>功能说明：设置XFee86。</p><p>语　　法：<code>XF86Setup [-display&lt;主机名称或IP地址&gt;:&lt;显示器编号&gt;][-nodialog][-sync]</code></p><p>补充说明：这是Linux系统用来设置XFee86的程序，它会进入图形模式，通过互动操作界面，让用户轻松完成XFee86环境的设置。</p><p>参　　数：</p><ul><li>-display&lt;主机名称或IP地址&gt;:&lt;显示器编号&gt;   指定显示XF86Setup设置画面的主机名称以及欲在该主机上的哪个显示器显示画面。</li><li>-nodialog   执行XF86Setup时，不显示交谈窗，直接以文字模式提出询问。</li><li>–sync   和X Server进行数据同步传输。</li></ul><h3 id="xlsatoms"><a href="#xlsatoms" class="headerlink" title="xlsatoms"></a>xlsatoms</h3><p>功能说明：列出X Server定义的成分。</p><p>语　　法：<code>xlsatoms [-display&lt;显示器编号&gt;][-format&lt;输出格式&gt;][-name&lt;成分名称&gt;][-range&lt;列表范围&gt;]</code></p><p>补充说明：执行xlsatoms指令会列出X Server内部所有定义的成分，每个成分都有其编号，您可利用参数设置列表范围，或直接指定欲查询的成分名称。</p><p>参　　数：</p><ul><li>-display&lt;显示器编号&gt;   指定X Server连接的显示器编号，该编号由”0”开始计算， 依序递增。</li><li>-format&lt;输出格式&gt;   设置成分清单的列表格式，您可使用控制字符改变显示样式。</li><li>-name&lt;成分名称&gt;   列出指定的成分。</li><li>-range&lt;列表范围&gt;   设置成分清单的列表范围。 </li></ul><h3 id="xlsclients"><a href="#xlsclients" class="headerlink" title="xlsclients"></a>xlsclients</h3><p>功能说明：列出显示器中的客户端应用程序。</p><p>语　　法：<code>xlsclients [-al][-display&lt;显示器编号&gt;][-m&lt;最大指令长度&gt;]</code></p><p>补充说明：执行xlsclients指令可列出某个显示器中，正在执行的客户端应用程序信息。</p><p>参　　数：</p><ul><li>-a   列出所有显示器的客户端应用程序信息。</li><li>-display&lt;显示器编号&gt;   指定X Server连接的显示器编号，该编号由”0”开始计算，依序递增。</li><li>-l   使用详细格式列表。</li><li>-m&lt;最大指令长度&gt;   设置显示指令信息的最大长度，单位以字符计算。</li></ul><h3 id="xlsfonts"><a href="#xlsfonts" class="headerlink" title="xlsfonts"></a>xlsfonts</h3><p>功能说明：列出X Server使用的字体。</p><p>语　　法：<code>xlsfonts [-1Clmou][-display&lt;主机名称或IP地址&gt;:&lt;显示器编号&gt;][-fn&lt;范本样式&gt;][-ll][-lll][-n&lt;显示栏位数&gt;][-w&lt;每列字符数&gt;]</code></p><p>补充说明：执行xlsfonts指令会显示目前X Server可使用的字体，也能使用范本样式仅列出的符合条件的字体。</p><p>参　　数：</p><ul><li>-1   仅用单一栏位列出字体清单。</li><li>-C   使用多个栏位列出字体清单。</li><li>-display&lt;主机名称或IP地址&gt;:&lt;显示器编号&gt;   指定显示XF86Setup设置画面的主机名称以及欲放在该主机机上的哪个显示器画面。</li><li>-fn&lt;范本样式&gt;   只列出符合范本样式指定的条件的字体。</li><li>-l   除字体名称外，同时列出字体的属性。</li><li>-ll   此参数的效果和指定”l”参数类似，但显示更详细的信息。</li><li>-lll   此参数的效果和指定”ll”参数类似，但显示更详细的信息。</li><li>-m   配合参数”-l”使用时，一并列出字体大小的上下限。</li><li>-n&lt;显示栏位数&gt;   设置每列显示的栏位数。</li><li>-o   以OpenFont的形式列出字体清单。</li><li>-u   列出字体清单时不依照其名称排序。</li><li>-w&lt;每列字符数&gt;   设置每列的最大字符数。</li></ul><h3 id="yes"><a href="#yes" class="headerlink" title="yes"></a>yes</h3><p>1.命令说明</p><pre><code>输出回应的字符串。yes回应“y”字符，后者指定字符。 </code></pre><p>2.路径</p><pre><code>/usr/bin/yes</code></pre><p>3.语法 :<code>yes [–help] [–version] string</code></p><p>4.参数</p><ul><li>–help 显示帮助字符。 –version 显示版本信息 </li></ul><p>5.相关命令</p><p>无</p><p>6.举例说明</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@bixuan/]<span class="comment">#yes "OK" //回应“OK”字符串。</span></span><br><span class="line">命令执行结果如下：</span><br><span class="line">OK</span><br><span class="line">OK</span><br><span class="line">OK </span><br><span class="line">...</span><br><span class="line">Ctrl+c //按Ctrl+c键中断</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Linux" scheme="https://www.sakuratears.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>记一次MySQL历史数据初始化的问题</title>
    <link href="https://www.sakuratears.top/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1MySQL%E5%8E%86%E5%8F%B2%E6%95%B0%E6%8D%AE%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E9%97%AE%E9%A2%98.html"/>
    <id>https://www.sakuratears.top/blog/记一次MySQL历史数据初始化的问题.html</id>
    <published>2019-09-25T14:14:00.000Z</published>
    <updated>2019-09-26T14:24:31.946Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>先说下背景吧，在某项目迭代过程中，由于系统设计问题，需要对b表新增加两个字段（证件类型type和证件号码number），这本来是一件很平常的事情。</p><p>但是对于b表的历史数据，需要对其进行初始化维护，也就是历史数据要赋值，这理论上也是一件简单的事情。</p><p>证件信息数据要从a表获取，但是a表中对于一个用户（userId）可以有多种类型证件，且证件可以被修改。</p><p>对于b表，只需要一种证件，它遵循一个规则，即证件类型有个优先级（d、b、e、c、a），取优先级最高的一张，如果证件被改动过（update_date），则从改动的证件里按照上面优先级找到一张。</p><p>看起来很懵逼，我们来分析下。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>我们先来看下a，b表结构。</p><p>对于b表，我略去部分结构，b表主要简化如下，其中type和number是我们需求新增的字段，对于历史数据，这两个字段需要维护。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`b`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'自增主键'</span>,</span><br><span class="line">  <span class="string">`user_id`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户ID'</span>,</span><br><span class="line">  <span class="string">`type`</span> <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'证件类型'</span>,</span><br><span class="line">  <span class="string">`number`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'证件号'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">1</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'b表'</span>;</span><br></pre></td></tr></table></figure><p>A表的简化如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`a`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'自增主键'</span>,</span><br><span class="line">  <span class="string">`user_id`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户ID'</span>,</span><br><span class="line">  <span class="string">`type`</span> <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'证件类型'</span>,</span><br><span class="line">  <span class="string">`number`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'证件号'</span>,</span><br><span class="line">  <span class="string">`create_date`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line">  <span class="string">`update_date`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'更新时间'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">1</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'a表'</span>;</span><br></pre></td></tr></table></figure><p>我们假设a、b表有如下数据：</p><p>b表<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`b`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>) <span class="keyword">VALUES</span> (<span class="string">'1'</span>, <span class="string">'111111'</span>, <span class="string">''</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`b`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>) <span class="keyword">VALUES</span> (<span class="string">'2'</span>, <span class="string">'222222'</span>, <span class="string">''</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`b`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>) <span class="keyword">VALUES</span> (<span class="string">'3'</span>, <span class="string">'333333'</span>, <span class="string">''</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`b`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>) <span class="keyword">VALUES</span> (<span class="string">'4'</span>, <span class="string">'444444'</span>, <span class="string">''</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`b`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>) <span class="keyword">VALUES</span> (<span class="string">'5'</span>, <span class="string">'555555'</span>, <span class="string">''</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`b`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>) <span class="keyword">VALUES</span> (<span class="string">'6'</span>, <span class="string">'666666'</span>, <span class="string">''</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`b`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>) <span class="keyword">VALUES</span> (<span class="string">'7'</span>, <span class="string">'777777'</span>, <span class="string">''</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`b`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>) <span class="keyword">VALUES</span> (<span class="string">'8'</span>, <span class="string">'888888'</span>, <span class="string">''</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`b`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>) <span class="keyword">VALUES</span> (<span class="string">'9'</span>, <span class="string">'999999'</span>, <span class="string">''</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`b`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>) <span class="keyword">VALUES</span> (<span class="string">'10'</span>, <span class="string">'111111'</span>, <span class="string">''</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></p><p>a表<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`a`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>, <span class="string">`create_date`</span>, <span class="string">`update_date`</span>) <span class="keyword">VALUES</span> (<span class="string">'1'</span>, <span class="string">'111111'</span>, <span class="string">'a'</span>, <span class="string">'123'</span>, <span class="string">'2019-09-10 14:02:46'</span>, <span class="string">'2019-09-10 14:02:46'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`a`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>, <span class="string">`create_date`</span>, <span class="string">`update_date`</span>) <span class="keyword">VALUES</span> (<span class="string">'10'</span>, <span class="string">'111111'</span>, <span class="string">'c'</span>, <span class="string">'1234'</span>, <span class="string">'2019-09-10 14:02:46'</span>, <span class="string">'2019-09-11 14:02:46'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`a`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>, <span class="string">`create_date`</span>, <span class="string">`update_date`</span>) <span class="keyword">VALUES</span> (<span class="string">'2'</span>, <span class="string">'111111'</span>, <span class="string">'d'</span>, <span class="string">'32122'</span>, <span class="string">'2019-09-10 14:02:46'</span>, <span class="string">'2019-09-11 14:02:46'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`a`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>, <span class="string">`create_date`</span>, <span class="string">`update_date`</span>) <span class="keyword">VALUES</span> (<span class="string">'12'</span>, <span class="string">'222222'</span>, <span class="string">'d'</span>, <span class="string">'32111'</span>, <span class="string">'2019-09-10 14:02:46'</span>, <span class="string">'2019-09-12 14:02:46'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`a`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>, <span class="string">`create_date`</span>, <span class="string">`update_date`</span>) <span class="keyword">VALUES</span> (<span class="string">'3'</span>, <span class="string">'333333'</span>, <span class="string">'b'</span>, <span class="string">'12131'</span>, <span class="string">'2019-09-10 14:02:46'</span>, <span class="string">'2019-09-10 14:02:46'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`a`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>, <span class="string">`create_date`</span>, <span class="string">`update_date`</span>) <span class="keyword">VALUES</span> (<span class="string">'13'</span>, <span class="string">'333333'</span>, <span class="string">'d'</span>, <span class="string">'12133'</span>, <span class="string">'2019-09-10 14:02:46'</span>, <span class="string">'2019-09-10 14:02:46'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`a`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>, <span class="string">`create_date`</span>, <span class="string">`update_date`</span>) <span class="keyword">VALUES</span> (<span class="string">'4'</span>, <span class="string">'444444'</span>, <span class="string">'b'</span>, <span class="string">'3434'</span>, <span class="string">'2019-09-10 14:02:46'</span>, <span class="string">'2019-09-10 14:02:46'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`a`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>, <span class="string">`create_date`</span>, <span class="string">`update_date`</span>) <span class="keyword">VALUES</span> (<span class="string">'14'</span>, <span class="string">'444444'</span>, <span class="string">'e'</span>, <span class="string">'34341'</span>, <span class="string">'2019-09-10 14:02:46'</span>, <span class="string">'2019-09-13 14:02:46'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`a`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>, <span class="string">`create_date`</span>, <span class="string">`update_date`</span>) <span class="keyword">VALUES</span> (<span class="string">'5'</span>, <span class="string">'555555'</span>, <span class="string">'c'</span>, <span class="string">'353452'</span>, <span class="string">'2019-09-10 14:02:46'</span>, <span class="string">'2019-09-10 14:02:46'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`a`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>, <span class="string">`create_date`</span>, <span class="string">`update_date`</span>) <span class="keyword">VALUES</span> (<span class="string">'15'</span>, <span class="string">'555555'</span>, <span class="string">'a'</span>, <span class="string">'3534599'</span>, <span class="string">'2019-09-10 14:02:46'</span>, <span class="string">'2019-09-11 14:02:46'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`a`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>, <span class="string">`create_date`</span>, <span class="string">`update_date`</span>) <span class="keyword">VALUES</span> (<span class="string">'6'</span>, <span class="string">'666666'</span>, <span class="string">'c'</span>, <span class="string">'3654688'</span>, <span class="string">'2019-09-10 14:02:46'</span>, <span class="string">'2019-09-10 14:02:46'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`a`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>, <span class="string">`create_date`</span>, <span class="string">`update_date`</span>) <span class="keyword">VALUES</span> (<span class="string">'16'</span>, <span class="string">'666666'</span>, <span class="string">'a'</span>, <span class="string">'365461'</span>, <span class="string">'2019-09-10 14:02:46'</span>, <span class="string">'2019-09-10 14:02:46'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`a`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>, <span class="string">`create_date`</span>, <span class="string">`update_date`</span>) <span class="keyword">VALUES</span> (<span class="string">'7'</span>, <span class="string">'777777'</span>, <span class="string">'d'</span>, <span class="string">'4645655'</span>, <span class="string">'2019-09-10 14:02:46'</span>, <span class="string">'2019-09-10 14:02:46'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`a`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>, <span class="string">`create_date`</span>, <span class="string">`update_date`</span>) <span class="keyword">VALUES</span> (<span class="string">'17'</span>, <span class="string">'777777'</span>, <span class="string">'b'</span>, <span class="string">'4645653'</span>, <span class="string">'2019-09-10 14:02:46'</span>, <span class="string">'2019-09-11 14:02:46'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`a`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>, <span class="string">`create_date`</span>, <span class="string">`update_date`</span>) <span class="keyword">VALUES</span> (<span class="string">'8'</span>, <span class="string">'888888'</span>, <span class="string">'d'</span>, <span class="string">'4444'</span>, <span class="string">'2019-09-10 14:02:46'</span>, <span class="string">'2019-09-11 14:02:46'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`a`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>, <span class="string">`create_date`</span>, <span class="string">`update_date`</span>) <span class="keyword">VALUES</span> (<span class="string">'18'</span>, <span class="string">'999999'</span>, <span class="string">'c'</span>, <span class="string">'44447'</span>, <span class="string">'2019-09-10 14:02:46'</span>, <span class="string">'2019-09-10 14:02:46'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`a`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>, <span class="string">`create_date`</span>, <span class="string">`update_date`</span>) <span class="keyword">VALUES</span> (<span class="string">'9'</span>, <span class="string">'999999'</span>, <span class="string">'d'</span>, <span class="string">'234243'</span>, <span class="string">'2019-09-10 14:02:46'</span>, <span class="string">'2019-09-10 14:02:46'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`a`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>, <span class="string">`create_date`</span>, <span class="string">`update_date`</span>) <span class="keyword">VALUES</span> (<span class="string">'19'</span>, <span class="string">'999999'</span>, <span class="string">'e'</span>, <span class="string">'234248'</span>, <span class="string">'2019-09-10 14:02:46'</span>, <span class="string">'2019-09-10 14:02:46'</span>);</span><br></pre></td></tr></table></figure></p><p>他们的表数据如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-520.jpg" alt="upload successful"><br><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-521.jpg" alt="upload successful"></p><p>我们根据前言里提到的规则，b表只接受该用户一张证件，优先级为（d、b、e、c、a），但是如果证件被改动过的话，就在改动列表里继续按照优先级寻找。</p><p>所以对于上面的<code>user_id = 444444</code>的用户，我们应该放入e证件，因为它被改动过；对于 <code>user_id = 111111</code>的用户，可以看到c和d都被改动过，因此从c和d里选，而不考虑a类型，d的优先级高，故最后放入d证件。</p><p>虽然程序里很好解决，但是历史数据初始化需要使用SQL处理，我们来看下。</p><p>首先要更新b表数据，这些数据应该从a表（或者a表最后经过一系列查询形成的临时表）获取并赋值，它的SQL语句部分应大致如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> b</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> (</span><br><span class="line"> <span class="keyword">SELECT</span> XXXXX <span class="keyword">from</span> a</span><br><span class="line">) <span class="keyword">AS</span> temp <span class="keyword">ON</span> b.user_id = temp.user_id</span><br><span class="line"><span class="keyword">SET</span> b.type = temp.type,</span><br><span class="line"> b.number = temp.number;</span><br></pre></td></tr></table></figure><p>这个SQL比较好理解，temp临时表部分表示我们在a里查询出一个user_id、type、number一组数据，在通过user_id相等对b表的type和number进行赋值。</p><p>接下来就是关于如何获取生成的临时表这部分了。</p><p>我们先寻找改动过的，在里面对于每个用户找到他的最高优先级的证件。</p><p>可以看到这是在MySQL中使用分组排序获取最高优先级的数据。</p><p>SQL如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    *</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span></span><br><span class="line">            user_id,</span><br><span class="line">            <span class="keyword">type</span>,</span><br><span class="line">            <span class="built_in">number</span></span><br><span class="line">        <span class="keyword">FROM</span></span><br><span class="line">            a</span><br><span class="line">        <span class="keyword">WHERE</span></span><br><span class="line">        create_date &lt;&gt; update_date</span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">            user_id,</span><br><span class="line">            (</span><br><span class="line">                <span class="keyword">CASE</span> <span class="keyword">type</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'d'</span> <span class="keyword">THEN</span></span><br><span class="line">                    <span class="number">1</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'b'</span> <span class="keyword">THEN</span></span><br><span class="line">                    <span class="number">2</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'e'</span> <span class="keyword">THEN</span></span><br><span class="line">                    <span class="number">3</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'c'</span> <span class="keyword">THEN</span></span><br><span class="line">                    <span class="number">4</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'a'</span> <span class="keyword">THEN</span></span><br><span class="line">                    <span class="number">5</span></span><br><span class="line">                <span class="keyword">END</span></span><br><span class="line">            )</span><br><span class="line">    ) <span class="keyword">AS</span> t</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    t.user_id</span><br></pre></td></tr></table></figure><p>这儿我们看到，我们这里GROUP BY了user_id 和 type，因此t表返回的每个user_id的第一条即为需要的数据，这时候对t表根据user_id进行GROUP BY，进而获取到了每个的第一条数据。</p><p>我们在获取没有改动过的，这儿要注意要除去改动过的用户证件，因为它已经包含在上面的SQL里了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    *</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span></span><br><span class="line">            user_id,</span><br><span class="line">            <span class="keyword">type</span>,</span><br><span class="line">            <span class="built_in">number</span></span><br><span class="line">        <span class="keyword">FROM</span></span><br><span class="line">            a</span><br><span class="line">        <span class="keyword">WHERE</span></span><br><span class="line">        create_date = update_date</span><br><span class="line">        <span class="keyword">AND</span> user_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">            <span class="keyword">SELECT</span></span><br><span class="line">                user_id</span><br><span class="line">            <span class="keyword">FROM</span></span><br><span class="line">                a</span><br><span class="line">            <span class="keyword">WHERE</span></span><br><span class="line">                create_date &lt;&gt; update_date</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">            user_id,</span><br><span class="line">            (</span><br><span class="line">                <span class="keyword">CASE</span> <span class="keyword">type</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'d'</span> <span class="keyword">THEN</span></span><br><span class="line">                    <span class="number">1</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'b'</span> <span class="keyword">THEN</span></span><br><span class="line">                    <span class="number">2</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'e'</span> <span class="keyword">THEN</span></span><br><span class="line">                    <span class="number">3</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'c'</span> <span class="keyword">THEN</span></span><br><span class="line">                    <span class="number">4</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'a'</span> <span class="keyword">THEN</span></span><br><span class="line">                    <span class="number">5</span></span><br><span class="line">                <span class="keyword">END</span></span><br><span class="line">            )</span><br><span class="line">    ) <span class="keyword">AS</span> t</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    t.user_id</span><br></pre></td></tr></table></figure><p>然后我们使用UNION ALL 将两部分合并。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">SELECT</span></span><br><span class="line">    *</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span></span><br><span class="line">            user_id,</span><br><span class="line">            <span class="keyword">type</span>,</span><br><span class="line">            <span class="built_in">number</span></span><br><span class="line">        <span class="keyword">FROM</span></span><br><span class="line">            a</span><br><span class="line">        <span class="keyword">WHERE</span></span><br><span class="line">        create_date &lt;&gt; update_date</span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">            user_id,</span><br><span class="line">            (</span><br><span class="line">                <span class="keyword">CASE</span> <span class="keyword">type</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'d'</span> <span class="keyword">THEN</span></span><br><span class="line">                    <span class="number">1</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'b'</span> <span class="keyword">THEN</span></span><br><span class="line">                    <span class="number">2</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'e'</span> <span class="keyword">THEN</span></span><br><span class="line">                    <span class="number">3</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'c'</span> <span class="keyword">THEN</span></span><br><span class="line">                    <span class="number">4</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'a'</span> <span class="keyword">THEN</span></span><br><span class="line">                    <span class="number">5</span></span><br><span class="line">                <span class="keyword">END</span></span><br><span class="line">            )</span><br><span class="line">    ) <span class="keyword">AS</span> t</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    t.user_id)</span><br><span class="line">    <span class="keyword">UNION</span> ALL</span><br><span class="line">(<span class="keyword">SELECT</span></span><br><span class="line">    *</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span></span><br><span class="line">            user_id,</span><br><span class="line">            <span class="keyword">type</span>,</span><br><span class="line">            <span class="built_in">number</span></span><br><span class="line">        <span class="keyword">FROM</span></span><br><span class="line">            a</span><br><span class="line">        <span class="keyword">WHERE</span></span><br><span class="line">        create_date = update_date</span><br><span class="line">        <span class="keyword">AND</span> user_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">            <span class="keyword">SELECT</span></span><br><span class="line">                user_id</span><br><span class="line">            <span class="keyword">FROM</span></span><br><span class="line">                a</span><br><span class="line">            <span class="keyword">WHERE</span></span><br><span class="line">                create_date &lt;&gt; update_date</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">            user_id,</span><br><span class="line">            (</span><br><span class="line">                <span class="keyword">CASE</span> <span class="keyword">type</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'d'</span> <span class="keyword">THEN</span></span><br><span class="line">                    <span class="number">1</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'b'</span> <span class="keyword">THEN</span></span><br><span class="line">                    <span class="number">2</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'e'</span> <span class="keyword">THEN</span></span><br><span class="line">                    <span class="number">3</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'c'</span> <span class="keyword">THEN</span></span><br><span class="line">                    <span class="number">4</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'a'</span> <span class="keyword">THEN</span></span><br><span class="line">                    <span class="number">5</span></span><br><span class="line">                <span class="keyword">END</span></span><br><span class="line">            )</span><br><span class="line">    ) <span class="keyword">AS</span> t</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    t.user_id)</span><br></pre></td></tr></table></figure><p>然后我们最后得到的SQL如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> b</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> (</span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">user_id,</span><br><span class="line"><span class="keyword">type</span>,</span><br><span class="line"><span class="built_in">number</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">a</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">create_date &lt;&gt; update_date</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">user_id,</span><br><span class="line">(</span><br><span class="line"><span class="keyword">CASE</span> <span class="keyword">type</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'d'</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'b'</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'e'</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'c'</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'a'</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">)</span><br><span class="line">) <span class="keyword">AS</span> t</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">t.user_id</span><br><span class="line">)</span><br><span class="line"><span class="keyword">UNION</span> ALL</span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">user_id,</span><br><span class="line"><span class="keyword">type</span>,</span><br><span class="line"><span class="built_in">number</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">a</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">create_date = update_date</span><br><span class="line"><span class="keyword">AND</span> user_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">user_id</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">a</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">create_date &lt;&gt; update_date</span><br><span class="line">)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">user_id,</span><br><span class="line">(</span><br><span class="line"><span class="keyword">CASE</span> <span class="keyword">type</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'d'</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'b'</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'e'</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'c'</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'a'</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">)</span><br><span class="line">) <span class="keyword">AS</span> t</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">t.user_id</span><br><span class="line">)</span><br><span class="line">) <span class="keyword">AS</span> temp <span class="keyword">ON</span> b.user_id = temp.user_id</span><br><span class="line"><span class="keyword">SET</span> b.type = temp.type,</span><br><span class="line"> b.number = temp.number;</span><br></pre></td></tr></table></figure><p>我们也可以将上面数据放入临时表中，再通过临时表插入b表，如下：</p><p>创建临时表help_temp：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TEMPORARY</span> <span class="keyword">TABLE</span> help_temp (</span><br><span class="line">user_id <span class="built_in">VARCHAR</span> (<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="keyword">type</span> <span class="built_in">VARCHAR</span> (<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="built_in">number</span> <span class="built_in">VARCHAR</span> (<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>插入临时表数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> help_temp (user_id, <span class="keyword">type</span>, <span class="built_in">number</span>) <span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(</span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">user_id,</span><br><span class="line"><span class="keyword">type</span>,</span><br><span class="line"><span class="built_in">number</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">a</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">create_date &lt;&gt; update_date</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">user_id,</span><br><span class="line">(</span><br><span class="line"><span class="keyword">CASE</span> <span class="keyword">type</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'d'</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'b'</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'e'</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'c'</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'a'</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">)</span><br><span class="line">) <span class="keyword">AS</span> t</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">t.user_id</span><br><span class="line">)</span><br><span class="line"><span class="keyword">UNION</span> ALL</span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">user_id,</span><br><span class="line"><span class="keyword">type</span>,</span><br><span class="line"><span class="built_in">number</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">a</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">create_date = update_date</span><br><span class="line"><span class="keyword">AND</span> user_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">user_id</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">a</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">create_date &lt;&gt; update_date</span><br><span class="line">)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">user_id,</span><br><span class="line">(</span><br><span class="line"><span class="keyword">CASE</span> <span class="keyword">type</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'d'</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'b'</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'e'</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'c'</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'a'</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">)</span><br><span class="line">) <span class="keyword">AS</span> t</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">t.user_id</span><br><span class="line">)</span><br><span class="line">) <span class="keyword">AS</span> temp;</span><br></pre></td></tr></table></figure><p>将临时表数据放入到b表中：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> b</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> help_temp <span class="keyword">ON</span> b.user_id = help_temp.user_id</span><br><span class="line"><span class="keyword">SET</span> b.type = help_temp.type,</span><br><span class="line"> b.number = help_temp.number;</span><br></pre></td></tr></table></figure><p>删除临时表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TEMPORARY</span> <span class="keyword">TABLE</span> help_temp;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们上述使用了<code>CASE…WHEN</code>语句，它可以跟在<code>ORDER BY</code> 或者 <code>GROUP BY</code>语句后面，可以让数据按照指定格式排序；</p><p>我们通过<code>GROUP BY</code> user_id 和 type得到一次分组结构，这分组里面的第一条即是我们要求的数据，其实这样<code>GROUP BY</code>返回的数据也是通过对user_id分组，对type排序的数据集；我们拿到user_id这一层分组的第一条即可，故得到的数据再对user_id进行<code>GROUP BY</code>即可。</p><p>使用<code>UNION ALL</code>合并两部分数据，<code>UNION ALL</code>是合并全部数据，如果只使用<code>UNION</code>，合并时相同的数据只会保留一条。</p><p>要将一张表里的数据UPDATE到另一张表里，我们这里使用了<code>INNER JOIN ON</code>语句。</p><p>最后提到了临时表，当我们处理过程较复杂时，可以加入临时表进行辅助处理数据，处理完后连接断开后临时表自动删除，当然也可以主动去删除临时表。</p><h1 id="引申"><a href="#引申" class="headerlink" title="引申"></a>引申</h1><p>我们上面所说的分组排序，相当于<code>GROUP BY</code>了两个字段，对于type来说，只能为不同的值，如果user_id,type相同，则两条数据会被分到同一组。</p><p>如下，a表我们新增一条数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`a`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>, <span class="string">`create_date`</span>, <span class="string">`update_date`</span>) <span class="keyword">VALUES</span> (<span class="string">'20'</span>, <span class="string">'111111'</span>, <span class="string">'a'</span>, <span class="string">'1234'</span>, <span class="string">'2019-09-10 14:02:46'</span>, <span class="string">'2019-09-10 14:02:46'</span>);</span><br></pre></td></tr></table></figure><p>可以看到此时a表数据如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-522.jpg" alt="upload successful"></p><p>对于<code>user_id = 111111</code>的用户，他有两个相同的<code>type = a</code>的证件，这时候我们<code>GROUP BY user_id,type</code>，得到的数据这两条肯定会只取一条。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-523.jpg" alt="upload successful"></p><p>我们如果想分组排序这样肯定是不对的，因为缺失了一条数据，怎么处理呢？</p><p>一种非常简单的处理方式是再引入一个字段<code>GROUP BY</code>，比如证件号number，如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-524.jpg" alt="upload successful"></p><p>可以看到这时候数据就完全展示了。</p><p>会不会没有辅助字段可以引入呢？</p><p>实际中，只要有主键id存在，我们理论上无论如何也是可以找到辅助<code>GROUP BY</code>的字段，如上面我们使用主键id，也是可以得到user_id和type的分组排序结果的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="MySQL" scheme="https://www.sakuratears.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>排序算法（九）- Java源码中的DualPivotQuicksort</title>
    <link href="https://www.sakuratears.top/blog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B9%9D%EF%BC%89-Java%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84DualPivotQuicksort.html"/>
    <id>https://www.sakuratears.top/blog/排序算法（九）-Java源码中的DualPivotQuicksort.html</id>
    <published>2019-09-17T15:02:00.000Z</published>
    <updated>2019-09-19T14:11:22.215Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上篇文章中我们了解了双轴快排和三路快排的原理及实现，<a href="https://www.sakuratears.top/blog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89-%E5%8F%8C%E8%BD%B4%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html#more">排序算法（七） - 双轴快速排序</a>和<a href="https://www.sakuratears.top/blog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89-%E4%B8%89%E8%B7%AF%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html#more">排序算法（八） - 三路快速排序</a>，了解了虽然快速排序有着较高的效率，但是在数据坏的情况下排序速度非常不乐观。</p><p>而后提到了Java源码中的DualPivotQuicksort，它是一种混合排序算法。</p><p>而双轴快排和三路快排正是Java源码中的DualPivotQuicksort的一部分，我们来看下它吧。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>这个排序算法是Vladimir Yaroslavskiy、Jon Bentley、Josh Bloch在2011年完成的，最早见于JDK1.7版本。</p><p>它是一种混合排序算法，其内部主要包括插入排序、三路快排、双轴快排、计数排序、归并排序这几种排序算法，将几种排序算法的优点发挥出来。</p><p>在了解排序原理之前，先了解几个固定值，这几个固定值是根据大量实验确定的数据。</p><ul><li><p><strong>MAX_RUN_COUNT = 67</strong></p><p>这个值，可以用来指使用归并排序的最大RUN数量，也可以指校验数据是否可以使用归并排序的一个标准。</p><p>比如对于int型数据int[] array，DualPivotQuicksort在开始时会从数组头部开始，寻找连续有序数据段，寻找到一段，就把末尾下标记录进一个run，如果该段逆序，就把它倒过来，比如[1,2,8,5,3,2,7,1,9]，它的有序段分隔为[1,2,8][5,3,2][7,1][9]，其中[5,3,2]和[7,1]在处理过程中会倒过来，这样如果当数据量大时，明显run数量会超过67，如果超了，就直接使用优化的快排处理了。</p><p>PS：上面的例子我们可以看到最后的run为 <font color="red"></font></p><p>run[0] = 2 =  index0 -index 2= [1,2,8] ; </p><p>run[1] = 5 = index3 - index5 = [2,3,5] ; </p><p>run[2] = 7 = index6 -index7= [1,7] ; </p><p>run[3] = 8 = index8 = [9] ; </p><p></p><p>其实run[2]和run[3]是可以合并的，这样可以节省run数量。<font color="red">合并条件就是后一个run的第一个元素要大于等于前一个run的最后一个元素</font>。JDK1.8并未对这块做处理，JDK9及以上版本这块有了优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (run[count] &gt; left &amp;&amp; a[run[count]] &gt;= a[run[count] - <span class="number">1</span>]) &#123;</span><br><span class="line">  count--; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>会处理这种情况。</p><ul><li><p><strong>QUICKSORT_THRESHOLD = 286</strong></p><p>这个值表示快排阈值，如果数据量不超过286，就直接使用优化的快排处理。</p></li><li><p><strong>INSERTION_SORT_THRESHOLD = 47</strong></p><p>这个值表示插入排序阈值，对于长度小于等于这个数的数据，就使用插入排序（或变体）处理。</p></li><li><p><strong>COUNTING_SORT_THRESHOLD_FOR_BYTE = 29</strong></p><p>对于byte类型数据，如果数据长度小于等于这个值，直接使用插入排序处理。（超过会使用计数排序处理）</p></li><li><p><strong>COUNTING_SORT_THRESHOLD_FOR_SHORT_OR_CHAR = 3200</strong></p><p>对于short或者char类型数据，如果长度超过3200阈值，就会使用计数排序处理。</p></li><li><p><strong>NUM_SHORT_VALUES = 1 &lt;&lt; 16 = 65536</strong></p><p>对于short类型数据，使用计数排序时，初始化桶的数量。（-32768 &lt;= short &lt;= 32767）</p></li><li><p><strong>NUM_CHAR_VALUES = 1 &lt;&lt; 16 = 65536</strong></p><p>对于char类型数据，使用计数排序时，初始化桶的数量。（字符集范围Unicode  0-65535）</p></li><li><p><strong>NUM_BYTE_VALUES = 1 &lt;&lt; 8 = 256</strong></p><p>对于byte类型数据，使用计数排序，初始化桶的数量。（-128 &lt;= byte &lt;= 127）</p></li></ul><p>以上前五个都是大量实验确定的值。</p><p>DualPivotQuicksort的算法原理可以大致描述如下：</p><h3 id="int类型数据"><a href="#int类型数据" class="headerlink" title="int类型数据"></a>int类型数据</h3><ol><li><p>对于待排序数组<code>int[] array</code>，如果数据长度小于 <code>QUICKSORT_THRESHOLD = 286</code>，直接使用优化的快速排序<code>sort</code>；</p></li><li><p>否则校验数据，构建一个 <code>MAX_RUN_COUNT+1 = 68</code> 的数组，用来存储run，也用来校验是否可以使用归并排序或者使用优化的快排<code>sort</code>；</p></li><li><p>对于待排序数组，依次寻找连续有序数组段，将末尾index记录进run，由于会出现相等的数据值：</p><ul><li><p>JDK1.8的处理方式是统计连续相等值的数量，超过 <code>MAX_RUN_LENGTH=33</code> 时会直接使用优化后的快速排序<code>sort</code>；</p></li><li><p>JDK9及以上版本的处理方式为将这些相等值统计进了上一个run里。逆序后相邻两个run可以保持升序的也会被合并。</p><p>如上面例子：[1,2,8,5,3,2,7,1,9] 会分成[1,2,8][5,3,2][7,1][9]，倒序的逆序得到[1,2,8][2,3,5][1,7][9] 这四个run，JDK9及以上版本[1,7][9]这两个run会合并为一个[1,7,9]，得益于这个校验。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (run[count] &gt; left &amp;&amp; a[run[count]] &gt;= a[run[count] - <span class="number">1</span>]) &#123;</span><br><span class="line">            count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>如果统计过程中run数量超过<code>MAX_RUN_COUNT</code>（限制条件<code>++count == MAX_RUN_COUNT</code>），则说明数据不是高度结构化的（是杂乱无章的），就会使用优化后的快排进行处理<code>sort</code>；如果是高度结构化的（部分有序的），会使用归并排序进行处理。</p></li><li><p>再来说下优化后的快速排序<code>sort</code>：</p><ul><li><p>如果输入数据长度小于 <code>INSERTION_SORT_THRESHOLD = 47</code> ，则直接使用插入排序（或变种）进行处理。</p></li><li><p>具体使用普通的插入排序还是变种的插入排序，取决于<code>leftmost</code>这个<code>boolean</code>值，如果<code>true</code>的话就使用普通的插排；否则使用首部部分部分有序的插排（变种）。</p></li><li><p>如果长度大于等于47，就要开始真正的快排部分了，首先它会寻找5个点<code>index（e1,e2,e3,e4,e5）</code>，这5个index可以大致把数据分成等长的7份（其中<code>e3</code>近似为数据长度中点）；</p></li><li><p>对这5个index上的值进行排序同时交换了它们的位置（用的是穷举法的插入排序）；</p></li><li><p>如果这5个点的值都不相等，用 <code>array[e2]</code> 和 <code>array[e4]</code> 作为基准轴，对数据进行双轴快排处理，这里面有一点优化，（我们知道双轴快排会把数据分成3份，左部分、中间部分、右部分）就是如果中间部分长度超过4/7总长度，会跳过等于<code>pivot</code>（基准值）的元素，因为它们是相等的；</p></li><li><p>如果5个点的值全部相等，就使用三路快排处理，其轴为 <code>array[e3]</code> 即中间值（5个值都相等，较大概率说明数据的重复度很高了）。</p></li></ul></li></ol><h3 id="long类型数据"><a href="#long类型数据" class="headerlink" title="long类型数据"></a>long类型数据</h3><p>同int类型数据处理</p><h3 id="short类型数据"><a href="#short类型数据" class="headerlink" title="short类型数据"></a>short类型数据</h3><ol><li><p>对于待排序数组<code>short[] array</code>，如果数据长度大于 <code>COUNTING_SORT_THRESHOLD_FOR_SHORT_OR_CHAR = 3200</code> ，直接使用计数排序处理，计数排序的初始化桶数量为 <code>NUM_SHORT_VALUES = 65536</code>；</p></li><li><p>否则对于小于等于<code>3200</code>的数据，参考int类型处理。</p></li></ol><h3 id="char类型数据"><a href="#char类型数据" class="headerlink" title="char类型数据"></a>char类型数据</h3><p>参考short类型处理方式</p><h3 id="byte类型数据"><a href="#byte类型数据" class="headerlink" title="byte类型数据"></a>byte类型数据</h3><ol><li><p>对于待排序数组<code>byte[] array</code>，如果数据长度大于 <code>COUNTING_SORT_THRESHOLD_FOR_BYTE = 29</code> ，直接使用计数排序处理，其中初始化的桶数量为 <code>NUM_BYTE_VALUES = 256</code>；</p></li><li><p>否则数据长度小于等于<code>29</code>，直接使用插入排序法处理。</p></li></ol><h3 id="float类型数据"><a href="#float类型数据" class="headerlink" title="float类型数据"></a>float类型数据</h3><ol><li><p>对于待排序数组<code>float[] array</code>，先看看数据中有没有<code>NaN</code>这种数据，有的话直接与尾部数据交换，排序边界位置也应该缩小，因为<code>NaN</code>是无法参与比较的；</p></li><li><p>对于剩下可以比较大小的数据部分，直接参考int类型数据的处理方式；</p></li><li><p>排好后，由于可能有正0和负数0（-0.0 和 +0.0）这种数据，这种情况下负0应该在正0前面的，需要特殊处理下（程序中使用了 <code>Float.floatToRawIntBits</code>方法处理，这个可以返回浮点值的实际表示形式，可以确定正负）。</p></li></ol><h3 id="double类型数据"><a href="#double类型数据" class="headerlink" title="double类型数据"></a>double类型数据</h3><p>参考float类型处理方式</p><p>以上就是DualPivotQuicksort的逻辑原理。</p><h2 id="相关源代码"><a href="#相关源代码" class="headerlink" title="相关源代码"></a>相关源代码</h2><p>我们可以在 <code>java.util.DualPivotQuicksort</code>找到这个类，它是一个not public且final，且构造函数为private的类。</p><p>下图是我对它源码的一些解读，有兴趣的可以看看，这儿使用的是JDK1.8_131版本，在高版本的JDK中，某些部分有些改动，但不影响整体阅读。</p><p>这个源码有3000多行，考虑到文字数量及可读性问题，我使用了图片，方便大家阅读部分逻辑。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-515.jpg" alt="upload successful"><br><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-516.jpg" alt="upload successful"><br><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-517.jpg" alt="upload successful"></p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>上面我们看到Java里优化后的DualPivotQuicksort代码量是十分巨大的，这儿我们以int[]举例，来检测DualPivotQuicksort的效率问题。</p><p>我们创建几个测试数组，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 随机生成数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] randomArray(<span class="keyword">int</span> length)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = r.nextInt(length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成一个有序的倒序数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] reversalArray(<span class="keyword">int</span> length)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = a.length - i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成有个有序的正序数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] orderArray(<span class="keyword">int</span> length)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成前X部分有序后length-X部分无序的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] orderAndRandomArray(<span class="keyword">int</span> length,<span class="keyword">int</span> x)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &gt;= length)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"x不能超过length"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x; i++) &#123;</span><br><span class="line">            a[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=a.length - x;i&lt;a.length;i++ )&#123;</span><br><span class="line">            a[i] = r.nextInt(length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成前x部分无序后length-x部分有序的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] randomAndOrderArray(<span class="keyword">int</span> length,<span class="keyword">int</span> x)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &gt;= length)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"x不能超过length"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x; i++) &#123;</span><br><span class="line">            a[i] = r.nextInt(length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=a.length - x;i&lt;a.length;i++ )&#123;</span><br><span class="line">            a[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Java-DualPivotQuicksort排序开始："</span>);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        JavaDualPivotQuicksort.sort(a,<span class="number">0</span>,a.length-<span class="number">1</span>,<span class="keyword">null</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">"Java-DualPivotQuicksort耗时："</span>+(System.currentTimeMillis()-start)+<span class="string">"ms"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Java-DualPivotQuicksort排序完成！"</span>);</span><br><span class="line">        System.out.println(<span class="string">"数组是否有序："</span>+isOrdered(a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> length = <span class="number">100000000</span>;</span><br><span class="line">        <span class="comment">//随机无序数组</span></span><br><span class="line">        <span class="keyword">int</span>[] a1 = randomArray(length);</span><br><span class="line">        doSort(a1);</span><br><span class="line">        <span class="comment">//有序数组</span></span><br><span class="line">        <span class="keyword">int</span>[] a2 = orderArray(length);</span><br><span class="line">        doSort(a2);</span><br><span class="line">        <span class="comment">//逆序数组</span></span><br><span class="line">        <span class="keyword">int</span>[] a3 = reversalArray(length);</span><br><span class="line">        doSort(a3);</span><br><span class="line">        <span class="comment">//前部分有序后部分无序数组</span></span><br><span class="line">        <span class="keyword">int</span>[] a4 = orderAndRandomArray(length,length/<span class="number">3</span>);</span><br><span class="line">        doSort(a4);</span><br><span class="line">        <span class="comment">//前部分无序后部分有序数组</span></span><br><span class="line">        <span class="keyword">int</span>[] a5 = randomAndOrderArray(length,length/<span class="number">3</span>);</span><br><span class="line">        doSort(a5);</span><br><span class="line">        <span class="comment">//前部分有序后部分无序数组</span></span><br><span class="line">        <span class="keyword">int</span>[] a6 = orderAndRandomArray(length,length - length/<span class="number">3</span>);</span><br><span class="line">        doSort(a6);</span><br><span class="line">        <span class="comment">//前部分无序后部分有序数组</span></span><br><span class="line">        <span class="keyword">int</span>[] a7 = randomAndOrderArray(length,length/<span class="number">2</span>);</span><br><span class="line">        doSort(a7);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后可以得到类似的结果：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-518.jpg" alt="upload successful"></p><p>PS：我们可以使用之前提到的所有排序算法进行测试，其效率都不如该算法稳定。对于O(n^2)复杂度的排序算法，很多出现内存或者栈溢出异常。</p><p>我们进一步分析下该算法。</p><p>可以看到该算法排序取决于几个要素：<strong>数据长度、数据类型、数据是否结构化（部分有序）</strong>。</p><p>其算法比较突出的地方有以下几点：</p><ul><li><p>创建了 <code>MAX_RUN_COUNT+1</code> 个run，这个run一个重要的作用就是判断数据是否结构化，如果是的话用归并处理要快很多；如果不是，再使用快排，相比直接快排，只是浪费了一些校验时间，却规避了快排<code>O(n^2)</code>复杂度出现的情况，这也是run的数量要取合适的一个原因，算法作者通过大量实验确定了67这个数。</p></li><li><p>当对于<code>short、char、byte</code>类型数据时，由于其范围不是很大，计数排序的优势就体现出来了，因此使用了计数排序。</p></li><li><p>对数据进行快排时，首先选择了5个点，在分情况从中获取基准值，并决定使用双轴快排还是三路快排。</p><p>这儿有一点是比较有意思的，我们可以看下源码中的这个优化后的快排算法<code>sort(int[] a, int left, int right, boolean leftmost)</code>，它掺杂着双轴快排和三路快排，使用条件是看这5个点的值是否相等，也就是比如一个数组A，开始时使用了双轴快排，分成了3段A1、A2、A3，可能出现A1后面使用了三路快排（数据里重复元素较多，导致5个点的值全部相等），A2和A3继续使用双轴快排的情况。</p></li></ul><h2 id="复杂度情况"><a href="#复杂度情况" class="headerlink" title="复杂度情况"></a>复杂度情况</h2><p>该排序算法的时间复杂度如下：</p><ul><li>时间复杂度（最好）：O(n)</li><li>时间复杂度（平均）：O(n * log n)</li><li>时间复杂度（最差）：O(n * log n)</li></ul><p>该排序算法的空间复杂度最差为O(n * log n)。</p><p>该排序算法为不稳定排序算法。</p><h2 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h2><p>这个排序算法就不展示动图了。其排序流程图大致如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-519.jpg" alt="upload successful"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于该算法的主要内容基本就介绍到这里了，有兴趣的同学可以看看源代码，了解下算法中每个排序（优化排序）具体的实现过程。</p><p>可以看到JDK源代码中对于一些常用方法、工具类，是有大量优化的。</p><h1 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h1><p>上述所提到的所有Java代码均可见于我的<a href="https://github.com/javazwt" rel="external nofollow noopener noreferrer" target="_blank">Github</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>JDK1.8 <code>java.util.DualPivotQuicksort</code> 源码</li><li>JDK9.0 <code>java.util.DualPivotQuicksort</code> 源码</li><li>JDK11.0 <code>java.util.DualPivotQuicksort</code> 源码</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="DualPivotQuicksort" scheme="https://www.sakuratears.top/tags/DualPivotQuicksort/"/>
    
  </entry>
  
  <entry>
    <title>排序算法（八） - 三路快速排序</title>
    <link href="https://www.sakuratears.top/blog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89-%E4%B8%89%E8%B7%AF%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html"/>
    <id>https://www.sakuratears.top/blog/排序算法（八）-三路快速排序.html</id>
    <published>2019-09-17T14:05:00.000Z</published>
    <updated>2019-09-17T14:34:38.498Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上篇文章我们讲到了<a href="https://www.sakuratears.top/blog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89-%E5%8F%8C%E8%BD%B4%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html#more">双轴快速排序</a>，今天我们来看下快排的另一种 - 三路快速排序（ThirdWayQuickSort），也称三向切分的快速排序。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="简介及原理"><a href="#简介及原理" class="headerlink" title="简介及原理"></a>简介及原理</h2><p>三路快速排序（ThirdWayQuickSort）是如何出现的呢？</p><p>我们知道，对于待排序数组，其数据是随机的，如果数组中有大量相同元素，无论普通快排还是双轴快排，由于快速排序的判定问题，会导致这些重复数移到一边从而大幅增加算法的运算时间。</p><p>为了优化这种数据情况，进而出现了三路快速排序。</p><p>三路快速排序也是采用一个轴值pivot，那具体是哪三路呢？ </p><p>三路指的就是每分割（Partition）一次，三路排序会把数据分为小于pivot、等于pivot和大于pivot的三部分。</p><p>三路排序的大致原理如下：</p><ol><li>对于待排序数组，选取第一个元素为中轴pivot；</li><li>每次分割处理将小于pivot的数据放到左边，等于pivot的数据放在中间，大于pivot的数据放在右边；</li><li>对小于pivot和大于pivot的部分重复分割过程。</li></ol><p>我们以一个数组为例，来看下它的原理,如下图。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-510.jpg" alt="upload successful"></p><p>其算法描述如下：</p><ol><li>对于待排序数组<code>a</code>，最左索引为<code>left</code>，最右索引为<code>right</code>；</li><li>排序过程中，以<code>a[left]</code>最为<code>pivot</code>，用<code>i</code>、<code>j</code>、<code>k</code>将数组分割为4部分，其中<code>i</code>表示<code>pivot</code>元素的起始index，所有小于<code>pivot</code>的元素下标都应该小于<code>i</code>；<code>k</code>表示待扫描的元素索引从<code>i+1</code>开始，到<code>j</code>结束；<code>j</code>表示待扫描元素的最后索引；</li><li>开始时<code>i=left</code>，<code>k=left+1</code>,<code>j=right</code>,此时小于<code>pivot</code>的元素为0个，大于<code>pivot</code>的元素为0个，待扫描的元素为<code>j-k+1</code>个；</li><li>从<code>k</code>开始扫描，当该元素比<code>pivot</code>小时，交换<code>a[i]</code>和<code>a[k]</code>，同时<code>i++</code>，<code>k++</code>，这样就能把该元素放到<code>pivot</code>的左边了；</li><li>当该元素等于<code>pivot</code>时，略过即可，即<code>k++</code>；</li><li><p>当该元素大于<code>pivot</code>时，需要把它放到右边，先看下<code>a[j]</code>和<code>pivot</code>的大小。</p><p> (1) 如果<code>a[j] &gt; pivot</code>，显然它已经在右边了，我们只需<code>j–</code>即可；</p><p> (2) 如果<code>a[j] = pivot</code>，这时候我们需要交换<code>a[k]</code>和<code>a[j]</code>的位置，同时<code>k++</code>,<code>j–</code>即可；</p><p> (3) 如果<code>a[j] &lt; pivot</code>，这时候我们除了交换<code>a[k]</code>和<code>a[j]</code>位置后，继续交换<code>a[i]</code>和<code>a[k]</code>的位置，将这个小元素移到左边，同时<code>i++</code>,<code>j–</code>,<code>k++</code>;</p></li><li><p>最后数据会被分为大于<code>pivot</code>、小于<code>pivot</code>、等于<code>pivot</code>的三部分，我们对大于<code>pivot</code>和小于<code>pivot</code>的部分再进行上述逻辑，直到传入的数据长度为1，说明数据全部有序了。</p></li></ol><h2 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-511.gif" alt="upload successful"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThirdWayQuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort3Way</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归终止条件，少于等于一个元素的数组已有序</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i, j, k, pivot;</span><br><span class="line">        <span class="comment">//首元素作为中轴</span></span><br><span class="line">        pivot = a[left];</span><br><span class="line">        i = left;</span><br><span class="line">        k = left + <span class="number">1</span>;</span><br><span class="line">        j = right;</span><br><span class="line"></span><br><span class="line">        outer:</span><br><span class="line">        <span class="keyword">while</span> (k &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[k] &lt; pivot) &#123;</span><br><span class="line">                swap(a, i, k);</span><br><span class="line">                i++;</span><br><span class="line">                k++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[k] == pivot) &#123;</span><br><span class="line">                k++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">// 遇到A[k]&gt;pivot的情况，j从右向左扫描</span></span><br><span class="line">                <span class="comment">//A[j]&gt;pivot的情况,j继续向左扫描</span></span><br><span class="line">                <span class="keyword">while</span> (a[j] &gt; pivot) &#123;</span><br><span class="line">                    j--;</span><br><span class="line">                    <span class="keyword">if</span> (j &lt; k) &#123;</span><br><span class="line">                        <span class="keyword">break</span> outer;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//A[j]==pivot的情况</span></span><br><span class="line">                <span class="keyword">if</span> (a[j] == pivot) &#123;</span><br><span class="line">                    swap(a, k, j);</span><br><span class="line">                    k++;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//A[j]&lt;pivot的情况</span></span><br><span class="line">                    swap(a, i, j);</span><br><span class="line">                    swap(a, j, k);</span><br><span class="line">                    i++;</span><br><span class="line">                    k++;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//A[i, j] 等于 pivot 且位置固定，不需要参与排序</span></span><br><span class="line">        <span class="comment">// 对小于pivot的部分进行递归</span></span><br><span class="line">        quickSort3Way(a, left, i - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 对大于pivot的部分进行递归</span></span><br><span class="line">        quickSort3Way(a, j + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100000000</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">100000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"ThirdWayQuickSort排序开始："</span>);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        quickSort3Way(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"ThirdWayQuickSort耗时："</span>+(System.currentTimeMillis()-start)+<span class="string">"ms"</span>);</span><br><span class="line">        System.out.println(<span class="string">"ThirdWayQuickSort排序完成！"</span>);</span><br><span class="line">        System.out.println(<span class="string">"数组是否有序："</span>+isOrdered(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h2><p>三路快排的时间复杂度与快速排序相当：</p><ul><li>时间复杂度（最好）：O(n * log n)</li><li>时间复杂度（平均）：O(n * log n)</li><li>时间复杂度（最差）：O(n^2)</li></ul><p>三路快排的空间复杂度为O(n * log n) （递归消耗栈空间，是一种就地排序算法，如果从堆空间角度空间复杂度为O(1)）</p><p>三路快排也是一种不稳定排序算法。</p><p>相比普通快排和双轴快排，我们可以看到三路快排对于有重复数据的数组处理较佳，可以减少元素交换次数。</p><h2 id="测试相关"><a href="#测试相关" class="headerlink" title="测试相关"></a>测试相关</h2><p>我们来实际测试下，相关代码如下：</p><p>我们准备1亿数据，但是数据集范围为[0,10000)，这时候相同元素产生的就会比较多，我们分别测试下三路快排、双轴快排和普通快排。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100000000</span>];</span><br><span class="line">    Random r = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        a[i] = r.nextInt(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] b = a.clone();</span><br><span class="line">    <span class="keyword">int</span>[] c = a.clone();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"ThirdWayQuickSort排序开始："</span>);</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    quickSort3Way(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">"ThirdWayQuickSort耗时："</span>+(System.currentTimeMillis()-start)+<span class="string">"ms"</span>);</span><br><span class="line">    System.out.println(<span class="string">"ThirdWayQuickSort排序完成！"</span>);</span><br><span class="line">    System.out.println(<span class="string">"数组是否有序："</span>+isOrdered(a));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"DualPivotQuickSort排序开始："</span>);</span><br><span class="line">    <span class="keyword">long</span> start1 = System.currentTimeMillis();</span><br><span class="line">    DualPivotQuickSort.dualPivotQuickSort(b,<span class="number">0</span>,b.length-<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">"DualPivotQuickSort耗时："</span>+(System.currentTimeMillis()-start1)+<span class="string">"ms"</span>);</span><br><span class="line">    System.out.println(<span class="string">"DualPivotQuickSort排序完成！"</span>);</span><br><span class="line">    System.out.println(<span class="string">"数组是否有序："</span>+isOrdered(b));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"QuickSort排序开始："</span>);</span><br><span class="line">    <span class="keyword">long</span> start2 = System.currentTimeMillis();</span><br><span class="line">    QuickSort.quickSort(c,<span class="number">0</span>,c.length-<span class="number">1</span>,<span class="keyword">true</span>);</span><br><span class="line">    System.out.println(<span class="string">"QuickSort耗时："</span>+(System.currentTimeMillis()-start2)+<span class="string">"ms"</span>);</span><br><span class="line">    System.out.println(<span class="string">"QuickSort排序完成！"</span>);</span><br><span class="line">    System.out.println(<span class="string">"数组是否有序："</span>+isOrdered(c));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多次测试结果大致如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-512.jpg" alt="upload successful"></p><p>我们可以看到，当数据集重复元素较多时，三路快排确实有着比较优的排序效率。</p><p>我们将数据集范围改为[0,100)，效果更加明显。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    a[i] = r.nextInt(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-513.jpg" alt="upload successful"></p><p>我们增大数据集范围，改为[0,100000000)，再来测试一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    a[i] = r.nextInt(<span class="number">100000000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-514.jpg" alt="upload successful"></p><p>可以看到三路快排效率比不上双轴快排了，因为这种情况下，重复元素较少，三路快排基本退化为普通快排。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过对三路快排（ThirdWayQuickSort）的介绍，我们大致了解了它的一些原理和排序过程，快速排序主要就有普通快排、三路快排和双轴快排三种。</p><p>在数据集元素重复较多的情况下，三路快排有着显著的优势，因此它和双轴快排一起，作为了Java对基本数据类型排序方法实现的一部分。</p><h1 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h1><p>本篇文章提到的所有代码均可见于我的<a href="https://github.com/javazwt" rel="external nofollow noopener noreferrer" target="_blank">GitHub</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="排序算法" scheme="https://www.sakuratears.top/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
      <category term="sort" scheme="https://www.sakuratears.top/tags/sort/"/>
    
      <category term="三路快排" scheme="https://www.sakuratears.top/tags/%E4%B8%89%E8%B7%AF%E5%BF%AB%E6%8E%92/"/>
    
  </entry>
  
</feed>
