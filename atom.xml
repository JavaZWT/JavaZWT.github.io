<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SakuraTears的博客</title>
  
  <subtitle>越努力越幸运</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.sakuratears.top/"/>
  <updated>2020-06-20T08:32:08.567Z</updated>
  <id>https://www.sakuratears.top/</id>
  
  <author>
    <name>SakuraTears</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Gson转换遇到的问题</title>
    <link href="https://www.sakuratears.top/blog/Gson%E8%BD%AC%E6%8D%A2%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98.html"/>
    <id>https://www.sakuratears.top/blog/Gson转换遇到的问题.html</id>
    <published>2020-06-20T08:25:00.000Z</published>
    <updated>2020-06-20T08:32:08.567Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天在项目中遇到了一个Gson转换数字后会变为Double类型引起的Bug，特此记录一下。</p><p>背景是这样的，我们对于前端请求，有一个公共处理Controller，并根据请求里的接口名称将其分发给其他处理类（Controller）。</p><p>因为每个处理类的请求类Req和返回Res是不同的，但是它们的响应code和原因是可以提取的，因此拿到前端数据后，我们后台会处理并返回数据。</p><p>Req如下，我们会根据前端在Header和传过来的data数据组成如下Req分发给指定apiName的Controller。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonReq</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line">    <span class="keyword">private</span> String apiName;</span><br><span class="line">    <span class="keyword">private</span> String device;</span><br><span class="line">    <span class="keyword">private</span> String platform;</span><br><span class="line">    <span class="keyword">private</span> String version;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个业务实体类TestReq，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReq</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一切都是很正常的，直到我们升级了FastJson的版本后，便出现了异常。</p><h1 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h1><p>尝试定位问题，发现是枚举值转换抛出的异常，我们有一个枚举值，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Type &#123;</span><br><span class="line">    A(<span class="string">"1"</span>, <span class="string">"A"</span>),</span><br><span class="line">    B(<span class="string">"2"</span>, <span class="string">"B"</span>);</span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">    Type(String code, String desc) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCode</span><span class="params">(String code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDesc</span><span class="params">(String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Type <span class="title">getEnum</span><span class="params">(String code)</span> </span>&#123;</span><br><span class="line">        Optional&lt;Type&gt; optional = Arrays.stream(Type.values()).filter(e -&gt; e.code.equals(code)).findFirst();</span><br><span class="line">        <span class="keyword">return</span> optional.orElse(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前端传过来的为1，我们转换传A，这样。</p><p>跟踪了一下，发现原来过来的是”1”，但是现在变成了”1.0”。因此转换异常了。</p><p>继续检查，发现前端传的数据为int类型的1（其实我们接口定义的String），如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"apiName"</span>:<span class="string">"test"</span>,<span class="attr">"version"</span>:<span class="string">"v1"</span>,<span class="attr">"data"</span>:&#123;<span class="attr">"amount"</span>:<span class="string">"3672.0"</span>,<span class="attr">"type"</span>:<span class="number">1</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>然后我们系统会将该数据转化为<code>CommonReq&lt;TestReq></code>对象。</p><p>转化的时候我们发现<code>TestReq</code>里得到的type已经是1.0了。</p><p>继续检查发现在前端数据请求过来后，使用的是Gson进行转化的，由于不知道泛型T的具体类型，因此转换逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CommonReq commonReq = GsonUtil.json2Bean(str,CommonReq.class);</span><br></pre></td></tr></table></figure><p>我自己编写了测试类，经过测试，发现Gson确实会把1转换为1.0，但针对的是该类型不明的情况，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"&#123;\"apiName\":\"test\",\"version\":\"v1\",\"data\":&#123;\"amount\":\"3672.0\",\"type\":1&#125;&#125;"</span>;</span><br><span class="line">        CommonReq commonReq = GsonUtil.json2Bean(str,CommonReq.class);</span><br><span class="line">        LinkedTreeMap linkedTreeMap = (LinkedTreeMap) commonReq.getData();</span><br><span class="line">        System.out.println(linkedTreeMap.get(<span class="string">"type"</span>));;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-623.jpg" alt="upload successful"></p><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>但我观察之前请求的日志，前端传的也是int类型的1，但转换后就是”1”，而不是”1.0”，这又是什么原因呢。</p><p>由于我们升级过一次FastJson版本，但Gson的问题和FastJson又有什么关系呢？</p><p>因此继续排查，我发现了一个特别的地方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(commonReq.getData() <span class="keyword">instanceof</span> LinkedHashMap||commonReq.getData() <span class="keyword">instanceof</span> LinkedTreeMap) &#123;</span><br><span class="line">                String jsonStr = FastJsonConvert.convertObjectToJSON(commonReq.getData());</span><br><span class="line">                commonReq.setData(apiService.convertRequest(jsonStr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其重点在于<code>FastJsonConvert.convertObjectToJSON(reqVo.getData())</code>这段代码上。</p><p>我们看上面的列子，使用Gson转换后<code>CommonReq</code> 里的data对象为<code>LinkedTreeMap</code>，不能直接强转为<code>TestReq</code>对象，因此借助了FastJson将其转换为jsonStr，然后再转回来。</p><p>这样就会不同吗？</p><p>在升级之前，我们使用的FastJson是1.2.10，升级后为1.2.70。</p><p>我们使用1.2.10的FastJson，对Gson得到的<code>LinkedTreeMap</code>进行转换输出，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.10&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"&#123;\"apiName\":\"test\",\"version\":\"v1\",\"data\":&#123;\"amount\":\"3672.0\",\"type\":1&#125;&#125;"</span>;</span><br><span class="line">        CommonReq commonReq = GsonUtil.json2Bean(str,CommonReq.class);</span><br><span class="line">        String jsonStr = FastJsonUtil.bean2Json(commonReq.getData());</span><br><span class="line">        System.out.println(jsonStr);;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-624.jpg" alt="upload successful"></p><p>可以看到type为1.</p><p>我们继续使用1.2.70版本的FastJson进行试验时，可以看到它输出了1.0.</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-625.jpg" alt="upload successful"></p><p>我们实际对FastJson进行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TestVO testVO = <span class="keyword">new</span> TestVO();</span><br><span class="line">testVO.setF(<span class="number">1.0</span>);</span><br><span class="line">String jsonStr = FastJsonUtil.bean2Json(testVO);</span><br><span class="line">System.out.println(jsonStr);</span><br></pre></td></tr></table></figure><p>在1.2.10版本下，FastJson输出了<code>{“f”:1}</code>，在1.2.70版本下，输出了<code>{“f”:1.0}</code>。</p><p>在低版本下，未指定对象类型情况下，FastJson对于小数数字末尾包含0的，都会舍去。</p><p>到这里其实问题也比较清楚了，由于Gson对于未指定类型的数字，会将其转换成Double类型，而FastJson低版本中，对于未指定的浮点数字，如果末尾为0，就会去掉，进而显示整数，而在高版本里解决了这个问题。</p><p>我们系统升级了FastJson，因而出现了问题。</p><p>但归根结底这个问题是由Gson引起的，因为Gson对于未指定类型的数字，会将其转换成Double类型，至目前原作者也没有修复这个问题。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过这个问题排查总结，我们能从中学到一点有用的东西。</p><ol><li>在一个项目中尽量使用一种Json转换工具，如Jackson、Fastjson、Gson，将它们在项目中混用既不方便维护，也加大了问题的排查难度，而且不同的Json转换工具转换出来的Json串可能相互处理起来并不友好。</li><li><p>这个问题，我们最终将Gson替换为Fastjson，从而解决了问题。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-626.jpg" alt="upload successful"></p><p>可以看到只使用FastJson，我们得到的数据不会被转换为Double。</p></li><li><p>在与客户端商定报文格式时，客户端应尽量传送的报文格式与服务端定义的类型一致。</p></li><li><p>关于如果使用Gson，如何避免出现未指定类型的整数转换为double的问题，可以参考这篇文章。</p><p><a href="https://stackoverflow.com/questions/36508323/how-can-i-prevent-gson-from-converting-integers-to-doubles" rel="external nofollow noopener noreferrer" target="_blank">how-can-i-prevent-gson-from-converting-integers-to-doubles</a></p></li></ol><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>其实客户端应该上送String类型的1而不是int类型的，但考虑但客户端需要发版，且旧版本客户端后端仍需要兼容，进而改为让服务端进行兼容改造，客户端迭代进行变更处理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="FastJson" scheme="https://www.sakuratears.top/tags/FastJson/"/>
    
      <category term="Gson" scheme="https://www.sakuratears.top/tags/Gson/"/>
    
  </entry>
  
  <entry>
    <title>【转】Java 12 特性及更新</title>
    <link href="https://www.sakuratears.top/blog/%E3%80%90%E8%BD%AC%E3%80%91Java-12-%E7%89%B9%E6%80%A7%E5%8F%8A%E6%9B%B4%E6%96%B0.html"/>
    <id>https://www.sakuratears.top/blog/【转】Java-12-特性及更新.html</id>
    <published>2020-04-29T06:46:00.000Z</published>
    <updated>2020-04-29T06:48:01.856Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://howtodoinjava.com/java12/new-features-enhancements/" rel="external nofollow noopener noreferrer" target="_blank">原文链接</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java 12(发布于2019年3月19日)是JDK的最新版本。让我们看看它为开发人员和架构师带来的新特性和改进。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Stream-API-新的方法-Collectors-teeing"><a href="#Stream-API-新的方法-Collectors-teeing" class="headerlink" title="Stream API 新的方法 Collectors.teeing()"></a>Stream API 新的方法 Collectors.teeing()</h2><p>此收集器将其输入转发给其他两个收集器，然后将它们的结果与一个函数合并。它是一个静态方法<code>Collectors::teeing</code>.</p><p><code>teeing(Collector, Collector, BiFunction)</code> 接受两个收集器和一个函数来合并它们的结果。传递给结果收集器的每个元素都由两个下游收集器处理，然后使用指定的merge函数将它们的结果合并到最终结果中。</p><p>例如，在给定的雇员列表中，如果我们想要找出拥有最高工资和最低工资的雇员，我们可以使用此收集器在单个语句中完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SalaryRange salaryRange = Stream</span><br><span class="line">            .of(<span class="number">56700</span>, <span class="number">67600</span>, <span class="number">45200</span>, <span class="number">120000</span>, <span class="number">77600</span>, <span class="number">85000</span>)</span><br><span class="line">            .collect(teeing(</span><br><span class="line">                    minBy(Integer::compareTo), </span><br><span class="line">                    maxBy(Integer::compareTo), </span><br><span class="line">                    SalaryRange::fromOptional));</span><br></pre></td></tr></table></figure><p>关于更多的关于此收集器的内容，可以查看<a href="https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/stream/Collectors.html#teeing(java.util.stream.Collector,java.util.stream.Collector,java.util.function.BiFunction" rel="external nofollow noopener noreferrer" target="_blank">Collectors.teeing()</a>)这篇文章。</p><h2 id="String-API-变化"><a href="#String-API-变化" class="headerlink" title="String API 变化"></a>String API 变化</h2><h3 id="String-indent"><a href="#String-indent" class="headerlink" title="String.indent()"></a>String.indent()</h3><p>这个缩进方法有助于更改字符串的缩进。我们可以传递一个正值，也可以传递一个负值，这取决于我们是想要添加更多的空白还是删除现有的空白。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String result = <span class="string">"foo\nbar\nbar2"</span>.indent(<span class="number">4</span>);</span><br><span class="line"> </span><br><span class="line">System.out.println(result);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//    foo</span></span><br><span class="line"><span class="comment">//    bar</span></span><br><span class="line"><span class="comment">//    bar2</span></span><br></pre></td></tr></table></figure><p>需要注意，indent()方法会自动添加新行字符(如果没有的话)。这是意料之中的，也是新方法的一个特点。</p><blockquote><p>每个空白字符都被视为单个字符。特别是制表符<code>“\t” (U+0009)</code>被认为是单个字符;它没有展开。</p></blockquote><h3 id="String-transform"><a href="#String-transform" class="headerlink" title="String.transform()"></a>String.transform()</h3><p><code>transform()</code>方法获取一个字符串，并在函数的帮助下将其转换为一个新字符串。</p><p>在给定的示例中，我们有一个名称列表。我们使用<code>transform()</code>方法执行两个操作(删除空白和将所有名称设置为大小写)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = List.of(</span><br><span class="line">                        <span class="string">"   Alex"</span>,</span><br><span class="line">                        <span class="string">"brian"</span>);</span><br><span class="line"> </span><br><span class="line">List&lt;String&gt; transformedNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (String name : names) </span><br><span class="line">&#123;</span><br><span class="line">    String transformedName = name.transform(String::strip)</span><br><span class="line">                                .transform(StringUtils::toCamelCase);</span><br><span class="line"> </span><br><span class="line">    transformedNames.add(transformedName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="String-constants"><a href="#String-constants" class="headerlink" title="String constants"></a>String constants</h3><p>从Java 12开始，String类实现了两个额外的接口<code> java.lang.constant.Constable</code>和<code>java.lang.constant.ConstantDesc</code>。</p><p><code>String</code>类还引入了另外两个低级方法<code>describeConstable()</code>和<code>resolveConstantDesc(MethodHandles.Lookup)</code>。</p><p>它们是低级api，用于库和提供字节码解析和生成功能的工具，例如Byte Buddy。</p><p>注意，<code>Constable</code>类型的值是常量，可以在<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.4" rel="external nofollow noopener noreferrer" target="_blank">JVMS 4.4</a>中描述的Java类文件的常量池中表示，它的实例可以在名义上将自己描述为<code>ConstantDesc</code>。</p><p><code>resolveConstantDesc()</code>类似于<code>describeConstable()</code>，不同之处在于这个方法返回的是<code>ConstantDesc</code>的一个实例。</p><h2 id="Files-mismatch-Path-Path"><a href="#Files-mismatch-Path-Path" class="headerlink" title="Files.mismatch(Path, Path)"></a>Files.mismatch(Path, Path)</h2><p>有时，我们希望确定两个文件是否具有相同的内容。这个API有助于比较文件的内容。</p><p><code>mismatch()</code>方法比较两个文件路径并返回一个long值。long值表示两个文件内容中<strong>第一个不匹配的字节</strong>的位置。如果文件内容相同，返回值将是“-1”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Path helloworld1 = tempDir.resolve(<span class="string">"helloworld1.txt"</span>);</span><br><span class="line"> </span><br><span class="line">Path helloworld2 = tempDir.resolve(<span class="string">"helloworld2.txt"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">long</span> diff = Files.mismatch(helloworld1, helloworld2);   <span class="comment">//returns long value</span></span><br></pre></td></tr></table></figure><h2 id="数字格式"><a href="#数字格式" class="headerlink" title="数字格式"></a>数字格式</h2><p>由用户界面或命令行工具呈现的大数字总是很难解析。使用数字的缩写形式要普遍得多。紧凑的数字表示更易于阅读，并且在不丢失原始含义的情况下，在屏幕上需要更少的空间。</p><p>例: <code>3.6 M</code> 比 <code>3,600,000</code> 容易读得多。</p><p>Java 12引入了一个<code>NumberFormat.getCompactNumberInstance(Locale, NumberFormat.Style)</code>的方便方法用于创建紧凑数字表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NumberFormat formatter = NumberFormat.getCompactNumberInstance(Locale.US,</span><br><span class="line">                                                        NumberFormat.Style.SHORT);</span><br><span class="line"> </span><br><span class="line">String formattedString = formatter.format(<span class="number">25000L</span>);      <span class="comment">//25K</span></span><br></pre></td></tr></table></figure><h2 id="Unicode-11-相关支持"><a href="#Unicode-11-相关支持" class="headerlink" title="Unicode 11 相关支持"></a>Unicode 11 相关支持</h2><p>在一个emoji表情符号在社交媒体渠道上扮演着重要角色的时代，支持最新的Unicode规范比以往任何时候都更重要。Java 12保持了同步并支持Unicode 11。</p><p>Unicode 11增加了684个字符，总共有137374个字符，还有7个新脚本，总共有146个脚本。</p><h2 id="switch-表达式扩展"><a href="#switch-表达式扩展" class="headerlink" title="switch 表达式扩展"></a>switch 表达式扩展</h2><p>这个更改扩展了switch语句，因此它既可以用作语句，也可以用作表达式。</p><p>我们可以简单地使用箭头语法，而不必为每个case块定义一个break语句。箭头语法在语义上看起来像一个lambda，它将大小写标签从表达式中分离出来。</p><p>使用新的switch表达式，我们可以直接将switch语句分配给一个变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isWeekend = <span class="keyword">switch</span> (day) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -&gt; <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> SATURDAY, SUNDAY -&gt; <span class="keyword">true</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">default</span> -&gt; <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Illegal day entry :: "</span> + day);</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">System.out.println(isWeekend);<span class="comment">//根据输入日期返回true或false</span></span><br></pre></td></tr></table></figure><blockquote><p>要使用此特性，请记住，我们必须在应用程序启动期间使用<code>-enable-preview</code>标志显式地指示JVM。</p></blockquote><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>以上就是关于Java 12 的全部内容。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java 12" scheme="https://www.sakuratears.top/tags/Java-12/"/>
    
  </entry>
  
  <entry>
    <title>【转】Java 11 特性及更新</title>
    <link href="https://www.sakuratears.top/blog/%E3%80%90%E8%BD%AC%E3%80%91Java-11-%E7%89%B9%E6%80%A7%E5%8F%8A%E6%9B%B4%E6%96%B0.html"/>
    <id>https://www.sakuratears.top/blog/【转】Java-11-特性及更新.html</id>
    <published>2020-04-23T06:46:00.000Z</published>
    <updated>2020-04-23T06:48:45.136Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://howtodoinjava.com/java11/features-enhancements/" rel="external nofollow noopener noreferrer" target="_blank">原文链接</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java 11(于2018年9月发布)包含许多重要和有用的更新。让我们看看它为开发人员和架构师带来的新特性和改进。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="HTTP-Client-API"><a href="#HTTP-Client-API" class="headerlink" title="HTTP Client API"></a>HTTP Client API</h2><p>Java长期使用HttpURLConnection类进行HTTP通信。但是随着时间的推移，需求变得越来越复杂，对应用程序的要求也越来越高。在Java 11之前，开发人员不得不求助于功能丰富的库，如<em>Apache HttpComponents</em>或<em>OkHttp</em>等。</p><p>我们看到Java 9发布版将<code>HttpClient</code>实现作为一个实验性特性包括在内。它随着时间的推移而发展，现在是Java 11的最后一个特性。现在，Java应用程序可以进行HTTP通信，而不需要任何外部依赖。</p><h3 id="如何使用HttpClient"><a href="#如何使用HttpClient" class="headerlink" title="如何使用HttpClient"></a>如何使用HttpClient</h3><p>它与<code>java.net.http</code>模块的经典HTTP通信是类似的：</p><ul><li>创建一个HttpClient实例，并根据需要配置它。</li><li>创建HttpRequest实例并填充信息。</li><li>将请求传递给客户机，执行请求并检索HttpResponse的实例。</li><li>处理HttpResponse中包含的信息。</li></ul><p>HTTP API可以处理同步和异步通信。让我们来看一个简单的例子。</p><h3 id="同步请求例子"><a href="#同步请求例子" class="headerlink" title="同步请求例子"></a>同步请求例子</h3><p>注意，Http客户端API如何使用builder模式来创建复杂对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> java.net.http.HttpClient;</span><br><span class="line"><span class="keyword">import</span> java.net.http.HttpRequest;</span><br><span class="line"><span class="keyword">import</span> java.net.http.HttpResponse;</span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"> </span><br><span class="line">HttpClient httpClient = HttpClient.newBuilder()</span><br><span class="line">                        .connectTimeout(Duration.ofSeconds(<span class="number">10</span>))</span><br><span class="line">                        .build();                                  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    String urlEndpoint = <span class="string">"https://postman-echo.com/get"</span>;</span><br><span class="line">    URI uri = URI.create(urlEndpoint + <span class="string">"?foo1=bar1&amp;foo2=bar2"</span>);</span><br><span class="line">    HttpRequest request = HttpRequest.newBuilder()</span><br><span class="line">                                    .uri(uri)</span><br><span class="line">                                    .build();                              </span><br><span class="line">    HttpResponse&lt;String&gt; response = httpClient.send(request,</span><br><span class="line">                                        HttpResponse.BodyHandlers.ofString()); </span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">System.out.println(<span class="string">"Status code: "</span> + response.statusCode());                            </span><br><span class="line">System.out.println(<span class="string">"Headers: "</span> + response.headers().allValues(<span class="string">"content-type"</span>));               </span><br><span class="line">System.out.println(<span class="string">"Body: "</span> + response.body());</span><br></pre></td></tr></table></figure><h3 id="异步请求例子"><a href="#异步请求例子" class="headerlink" title="异步请求例子"></a>异步请求例子</h3><p>如果我们不想等待响应，可以使用异步通信。我们提供回调处理程序，它在响应可用时执行。</p><p>注意使用<code>sendAsync()</code>方法发送异步请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> java.net.http.HttpClient;</span><br><span class="line"><span class="keyword">import</span> java.net.http.HttpRequest;</span><br><span class="line"><span class="keyword">import</span> java.net.http.HttpResponse;</span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.Collectors.toList;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">final</span> List&lt;URI&gt; uris = Stream.of(</span><br><span class="line">                        <span class="string">"https://www.google.com/"</span>,</span><br><span class="line">                        <span class="string">"https://www.github.com/"</span>,</span><br><span class="line">                        <span class="string">"https://www.yahoo.com/"</span></span><br><span class="line">                        ).map(URI::create).collect(toList());      </span><br><span class="line"> </span><br><span class="line">HttpClient httpClient = HttpClient.newBuilder()</span><br><span class="line">                        .connectTimeout(Duration.ofSeconds(<span class="number">10</span>))</span><br><span class="line">                        .followRedirects(HttpClient.Redirect.ALWAYS)</span><br><span class="line">                        .build();</span><br><span class="line"> </span><br><span class="line">CompletableFuture[] futures = uris.stream()</span><br><span class="line">                            .map(uri -&gt; verifyUri(httpClient, uri))</span><br><span class="line">                            .toArray(CompletableFuture[]::<span class="keyword">new</span>);     </span><br><span class="line"> </span><br><span class="line">CompletableFuture.allOf(futures).join();           </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> CompletableFuture&lt;Void&gt; <span class="title">verifyUri</span><span class="params">(HttpClient httpClient, </span></span></span><br><span class="line"><span class="function"><span class="params">                                          URI uri)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HttpRequest request = HttpRequest.newBuilder()</span><br><span class="line">                                    .timeout(Duration.ofSeconds(<span class="number">5</span>))</span><br><span class="line">                                    .uri(uri)</span><br><span class="line">                                    .build();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> httpClient.sendAsync(request,HttpResponse.BodyHandlers.ofString())</span><br><span class="line">                        .thenApply(HttpResponse::statusCode)</span><br><span class="line">                        .thenApply(statusCode -&gt; statusCode == <span class="number">200</span>)</span><br><span class="line">                        .exceptionally(ex -&gt; <span class="keyword">false</span>)</span><br><span class="line">                        .thenAccept(valid -&gt; </span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">                                System.out.println(<span class="string">"[SUCCESS] Verified "</span> + uri);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                System.out.println(<span class="string">"[FAILURE] Could not "</span> + <span class="string">"verify "</span> + uri);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);                                    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不用编译运行一个单文件项目"><a href="#不用编译运行一个单文件项目" class="headerlink" title="不用编译运行一个单文件项目"></a>不用编译运行一个单文件项目</h2><p>通常，对于我们想要执行的每个程序，我们都需要首先编译它为class文件。对于用于测试的小程序来说，这似乎是一个不必要的冗长过程。</p><p>Java 11做出了改变，现在我们可以执行包含在单个文件中的Java源代码，而不需要首先编译它。</p><p><strong>HelloWorld.java</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>要执行上面的类，直接用<code>java</code>命令运行它。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ java HelloWorld.java</span><br><span class="line"> </span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，程序不能使用除<code>java.base</code>模块之外的任何外部依赖项，并且程序只能是单文件程序。</p></blockquote><h2 id="String-API变更"><a href="#String-API变更" class="headerlink" title="String API变更"></a>String API变更</h2><h3 id="String-repeat-Integer"><a href="#String-repeat-Integer" class="headerlink" title="String.repeat(Integer)"></a>String.repeat(Integer)</h3><p>这个方法简单地重复一个字符串n次。它返回一个字符串，其值是重复N次的给定字符串的串联。</p><p>如果该字符串为空或count为零，则返回空字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String str = <span class="string">"1"</span>.repeat(<span class="number">5</span>);</span><br><span class="line"> </span><br><span class="line">        System.out.println(str);    <span class="comment">//11111</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="String-isBlank"><a href="#String-isBlank" class="headerlink" title="String.isBlank()"></a>String.isBlank()</h3><p>此方法判断字符串是否为空或者为空字符串。在此之前，我们一直在使用Apache开源包的<code>StringUtils.java</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="string">"1"</span>.isBlank();  <span class="comment">//false</span></span><br><span class="line"> </span><br><span class="line">        <span class="string">""</span>.isBlank();   <span class="comment">//true</span></span><br><span class="line"> </span><br><span class="line">        <span class="string">"    "</span>.isBlank();   <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="String-strip"><a href="#String-strip" class="headerlink" title="String.strip()"></a>String.strip()</h3><p>此方法负责删除开头和结尾空白。我们可以更具体地使用<code>String.stripLeading() </code>删除开头空白，或者使用<code>String.stripTrailing()</code>删除结尾空白。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="string">"   hi  "</span>.strip();  <span class="comment">//"hi"</span></span><br><span class="line"> </span><br><span class="line">       <span class="string">"   hi  "</span>.stripLeading();    <span class="comment">//"hi   "</span></span><br><span class="line"> </span><br><span class="line">       <span class="string">"   hi  "</span>.stripTrailing();   <span class="comment">//"   hi"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="String-lines"><a href="#String-lines" class="headerlink" title="String.lines()"></a>String.lines()</h3><p>这个方法有助于将多行文本处理为一个流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String testString = <span class="string">"hello\nworld\nis\nexecuted"</span>;</span><br><span class="line"> </span><br><span class="line">        List&lt;String&gt; lines = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">        testString.lines().forEach(line -&gt; lines.add(line));</span><br><span class="line"> </span><br><span class="line">        assertEquals(List.of(<span class="string">"hello"</span>, <span class="string">"world"</span>, <span class="string">"is"</span>, <span class="string">"executed"</span>), lines);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Collection-toArray-IntFunction"><a href="#Collection-toArray-IntFunction" class="headerlink" title="Collection.toArray(IntFunction)"></a>Collection.toArray(IntFunction)</h2><p>在Java 11之前，将集合转换为数组并不方便。Java 11使转换更加方便。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        names.add(<span class="string">"alex"</span>);</span><br><span class="line">        names.add(<span class="string">"brian"</span>);</span><br><span class="line">        names.add(<span class="string">"charles"</span>);</span><br><span class="line"> </span><br><span class="line">        String[] namesArr1 = names.toArray(<span class="keyword">new</span> String[names.size()]);       <span class="comment">//Before Java 11</span></span><br><span class="line"> </span><br><span class="line">        String[] namesArr2 = names.toArray(String[]::<span class="keyword">new</span>);                  <span class="comment">//Since Java 11</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Files-readString-和-Files-writeString"><a href="#Files-readString-和-Files-writeString" class="headerlink" title="Files.readString() 和 Files.writeString()"></a>Files.readString() 和 Files.writeString()</h2><p>使用这些重载的方法，Java 11旨在减少大量的样板代码，使文件的读写更加容易。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//Read file as string</span></span><br><span class="line">        URI txtFileUri = getClass().getClassLoader().getResource(<span class="string">"helloworld.txt"</span>).toURI();</span><br><span class="line"> </span><br><span class="line">        String content = Files.readString(Path.of(txtFileUri),Charset.defaultCharset());</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//Write string to file</span></span><br><span class="line">        Path tmpFilePath = Path.of(File.createTempFile(<span class="string">"tempFile"</span>, <span class="string">".tmp"</span>).toURI());</span><br><span class="line"> </span><br><span class="line">        Path returnedFilePath = Files.writeString(tmpFilePath,<span class="string">"Hello World!"</span>, </span><br><span class="line">                                    Charset.defaultCharset(), StandardOpenOption.WRITE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Optional-isEmpty"><a href="#Optional-isEmpty" class="headerlink" title="Optional.isEmpty()"></a>Optional.isEmpty()</h2><p>Optional是一个容器对象，它可以包含也可以不包含一个非空值。如果没有值，则认为该对象是空的。</p><p>如果存在值，则先前存在的方法<code>isPresent()</code>返回true，否则返回false。有时，它迫使我们写出不方便阅读的判断语句。</p><p><code>isEmpty()</code>方法与<code>isPresent()</code>方法相反，如果有值，则返回false，否则返回true。</p><p>所以在任何情况下我们都不需要写出相反的条件。在适当的时候使用这两种方法中的任何一种。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String currentTime = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">        assertTrue(!Optional.ofNullable(currentTime).isPresent());  <span class="comment">//It's negative condition</span></span><br><span class="line">        assertTrue(Optional.ofNullable(currentTime).isEmpty());     <span class="comment">//Write it like this</span></span><br><span class="line"> </span><br><span class="line">        currentTime = <span class="string">"12:00 PM"</span>;</span><br><span class="line"> </span><br><span class="line">        assertFalse(!Optional.ofNullable(currentTime).isPresent()); <span class="comment">//It's negative condition</span></span><br><span class="line">        assertFalse(Optional.ofNullable(currentTime).isEmpty());    <span class="comment">//Write it like this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>以上就是关于Java 11 更新的内容。</p><p>相关链接: <a href="https://docs.oracle.com/en/java/javase/11/" rel="external nofollow noopener noreferrer" target="_blank">Java 11 release doc</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java 11" scheme="https://www.sakuratears.top/tags/Java-11/"/>
    
  </entry>
  
  <entry>
    <title>【转】Java 10 特性及更新</title>
    <link href="https://www.sakuratears.top/blog/Java-10-%E7%89%B9%E6%80%A7%E5%8F%8A%E6%9B%B4%E6%96%B0.html"/>
    <id>https://www.sakuratears.top/blog/Java-10-特性及更新.html</id>
    <published>2020-04-21T08:37:00.000Z</published>
    <updated>2020-04-21T09:00:49.108Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://howtodoinjava.com/java10/java10-features/" rel="external nofollow noopener noreferrer" target="_blank">原文链接</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在Java 9发布之后，Java 10很快就出现了。与之前的版本不同，Java 10没有那么多令人兴奋的特性，但是它仍然有一些重要的更新，这些更新将改变我们编写代码的方式，以及其他未来的Java版本。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="局部变量类型推断（Local-Variable-Type-Inference）"><a href="#局部变量类型推断（Local-Variable-Type-Inference）" class="headerlink" title="局部变量类型推断（Local Variable Type Inference）"></a>局部变量类型推断（Local Variable Type Inference）</h2><p>Java现在有了<code>var</code>样式声明。它允许我们在不指定类型的情况下声明局部变量。变量的类型将从实际创建的对象的类型中推断出来。</p><p>这个特性对Java 10开发人员来说可以说是唯一的特性，因为其它Java 10的特性更新离我们编码较远。</p><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var str = <span class="string">"Hello world"</span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//or</span></span><br><span class="line">  </span><br><span class="line">String str = <span class="string">"Hello world"</span>;</span><br></pre></td></tr></table></figure><p>在上面的例子中，两个语句是等价的。在第一个语句中，str的类型由赋值类型决定，赋值类型为字符串类型。</p><p>想了解更多有关内容，可以阅读这篇文章<a href="https://www.sakuratears.top/blog/Java-10-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD.html#more">Java 10 局部变量类型推断</a>。</p><h2 id="基于时间的发布版本（Time-Based-Release-Versioning）"><a href="#基于时间的发布版本（Time-Based-Release-Versioning）" class="headerlink" title="基于时间的发布版本（Time-Based Release Versioning）"></a>基于时间的发布版本（Time-Based Release Versioning）</h2><p>从Java 10开始，Oracle已经采用了基于时间的版本字符串模式。版本号的新格式为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$FEATURE.$INTERIM.$UPDATE.$PATCH</span><br></pre></td></tr></table></figure><p>与旧版本不同的是，基于时间的新版本不会延迟发布，新功能将每六个月发布一次，对新版本中可以发布哪些功能没有限制。</p><p>还有长期发行版本(LTS)。主要面向企业客户。LTS版本的产品将由Oracle公司提供卓越和持续的支持。此外，这些版本的更新将至少在三年内可用。</p><p>关于该部分的更多内容，可以查看这篇文章<a href="https://www.sakuratears.top/blog/Java-10-%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E7%9A%84%E5%8F%91%E5%B8%83%E7%89%88%E6%9C%AC.html#more">Java 10 基于时间的发布版本</a>.</p><h2 id="垃圾收集器接口（Garbage-Collector-Interface）"><a href="#垃圾收集器接口（Garbage-Collector-Interface）" class="headerlink" title="垃圾收集器接口（Garbage-Collector Interface）"></a>垃圾收集器接口（Garbage-Collector Interface）</h2><p>在早期的JDK结构中，组成垃圾收集器(GC)实现的组件分散在代码库的各个部分。它在Java 10中进行了变化。现在，它是JVM源代码中的一个干净的接口，允许快速、轻松地集成替代收集器。它将改进不同垃圾收集器的源代码隔离。</p><p>这是一次非常重要的重构，以使得垃圾收集器可以适应过去现在及未来的需要。</p><h2 id="G1的并行Full-GC（Parallel-Full-GC-for-G1）"><a href="#G1的并行Full-GC（Parallel-Full-GC-for-G1）" class="headerlink" title="G1的并行Full GC（Parallel Full GC for G1）"></a>G1的并行Full GC（Parallel Full GC for G1）</h2><p>Java 9引入了 G1(garbage first) 垃圾收集器。G1垃圾收集器的设计是为了避免Full GC，但当并发收集不能足够快地回收内存时。有了这个更改，就会发生 Full GC。</p><p>G1 Full GC 实现使用的是单线程 标记-清除-压缩（mark-sweep-compact） 算法。这个更改将并行化 标记-清除-压缩（mark-sweep-compact） 算法，并使用相同数量的线程。当收集的并发线程不能足够快地恢复内存时，将会触发G1 Full GC。</p><p>线程的数量可以通过<code>-XX:ParallelGCThreads</code> 选项进行控制。</p><h2 id="可选内存设备上的堆分配（Heap-Allocation-on-Alternative-Memory-Devices）"><a href="#可选内存设备上的堆分配（Heap-Allocation-on-Alternative-Memory-Devices）" class="headerlink" title="可选内存设备上的堆分配（Heap Allocation on Alternative Memory Devices）"></a>可选内存设备上的堆分配（Heap Allocation on Alternative Memory Devices）</h2><p>此更改的目的是使<code>HotSpot VM</code>能够在用户指定的其他内存设备(如NV-DIMM)上分配Java对象堆。</p><p>要在这样的内存中分配堆，我们可以添加一个新选项:<code>-XX:AllocateHeapAt=\<path></path></code>。此选项将采用到文件系统的路径，并使用内存映射来实现在内存设备上分配对象堆的期望结果。现有的堆相关参数(如<code>-Xmx</code>、<code>-Xms</code>等)和垃圾收集相关参数将继续工作。</p><h2 id="JDK-分支整合（Consolidate-the-JDK-Forest-into-a-Single-Repository）"><a href="#JDK-分支整合（Consolidate-the-JDK-Forest-into-a-Single-Repository）" class="headerlink" title="JDK 分支整合（Consolidate the JDK Forest into a Single Repository）"></a>JDK 分支整合（Consolidate the JDK Forest into a Single Repository）</h2><p>为了简化和简化开发，JDK 分支的许多存储库被合并到一个单独的存储库中。</p><p>在JDK 9中有八个<code>repos</code>: <code>root</code>、<code>corba</code>、<code>hotspot</code>、<code>jaxp</code>、<code>jaxws</code>、<code>JDK</code>、<code>langtools</code>和<code>nashorn</code>。在合并后，Java模块的代码在一个顶级<code>src</code>目录下。</p><p>例如，之前JDK分支有一些基于模块的目录，比如：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ROOT/jdk/src/java.base</span><br><span class="line">...</span><br><span class="line">$ROOT/langtools/src/java.compiler</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>整合后，它们现在变为这样：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ROOT/src/java.base</span><br><span class="line">$ROOT/src/java.compiler</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="应用数据共享（Application-Class-Data-Sharing）"><a href="#应用数据共享（Application-Class-Data-Sharing）" class="headerlink" title="应用数据共享（Application Class-Data Sharing）"></a>应用数据共享（Application Class-Data Sharing）</h2><p>该特性的目标是改进启动占用空间，扩展现有的类数据共享(“CDS”)特性，允许将应用程序类放在共享归档中。</p><p>在JDK 5中引入的类数据共享允许将一组类预先处理为共享的存档文件，然后在运行时对这些文件进行内存映射，以减少启动时间。当多个jvm共享相同的归档文件时，它还可以减少动态内存占用。</p><p>目前CDS只允许引导类加载器加载存档的类。应用程序CDS允许内置的系统类装入器、内置的平台类装入器和自定义类装入器装入归档的类。</p><p>指定<code>-XX:+UseAppCDS</code>命令行选项，以便为系统类装入器、平台类装入器和其他用户定义的类装入器启用类数据共享。</p><h2 id="Unicode语言标记扩展（Additional-Unicode-Language-Tag-Extensions）"><a href="#Unicode语言标记扩展（Additional-Unicode-Language-Tag-Extensions）" class="headerlink" title="Unicode语言标记扩展（Additional Unicode Language-Tag Extensions）"></a>Unicode语言标记扩展（Additional Unicode Language-Tag Extensions）</h2><p>它的目标是增强<code>java.util.Locale</code>和相关api来实现<a href="https://www.rfc-editor.org/rfc/bcp/bcp47.txt" rel="external nofollow noopener noreferrer" target="_blank">BCP 47</a>语言标记的额外Unicode扩展。</p><p>对BCP 47语言标记的支持最初是在Java SE 7中添加的，对Unicode区域设置扩展的支持仅限于日历和数字。这个JEP将在相关的JDK类中实现最新<a href="https://www.unicode.org/reports/tr35/tr35.html#Locale_Extension_Key_and_Type_Data" rel="external nofollow noopener noreferrer" target="_blank">LDML规范</a>中指定的更多扩展。</p><p>这个JEP将增加对以下附加扩展的支持:</p><ul><li>cu (currency type)</li><li>fw (first day of week)</li><li>rg (region override)</li><li>tz (time zone)</li></ul><p>修改的相关API有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">java.text.DateFormat::get*Instance</span><br><span class="line">java.text.DateFormatSymbols::getInstance</span><br><span class="line">java.text.DecimalFormatSymbols::getInstance</span><br><span class="line">java.text.NumberFormat::get*Instance</span><br><span class="line">java.time.format.DateTimeFormatter::localizedBy</span><br><span class="line">java.time.format.DateTimeFormatterBuilder::getLocalizedDateTimePattern</span><br><span class="line">java.time.format.DecimalStyle::of</span><br><span class="line">java.time.temporal.WeekFields::of</span><br><span class="line">java.util.Calendar::&#123;getFirstDayOfWeek,getMinimalDaysInWeek&#125;</span><br><span class="line">java.util.Currency::getInstance</span><br><span class="line">java.util.Locale::getDisplayName</span><br><span class="line">java.util.spi.LocaleNameProvider</span><br></pre></td></tr></table></figure><h2 id="根证书（Root-Certificates）"><a href="#根证书（Root-Certificates）" class="headerlink" title="根证书（Root Certificates）"></a>根证书（Root Certificates）</h2><p>作为JDK的一部分，cacerts密钥存储库旨在包含一组根证书，这些根证书可用于在各种安全协议中使用的证书链中建立信任。但是，JDK源代码中的cacerts密钥库目前是空的。</p><p>cacerts密钥存储库将使用一组由Oracle的Java SE根CA程序签名颁发的根证书。许多供应商已经签署了所需的协议，并为每个供应商提供了将包含的根证书列表。那些没有签署协议的国家将不在此列。那些需要较长时间处理的将包含在下一个版本中。</p><p>这也意味着Oracle和Open JDK的二进制文件在功能上是相同的。关键的安全组件，比如TLS，将在OpenJDK构建中默认使用。</p><h2 id="基于Java的JIT编译器（Experimental-Java-Based-JIT-Compiler）"><a href="#基于Java的JIT编译器（Experimental-Java-Based-JIT-Compiler）" class="headerlink" title="基于Java的JIT编译器（Experimental Java-Based JIT Compiler）"></a>基于Java的JIT编译器（Experimental Java-Based JIT Compiler）</h2><p>该特性使基于Java的JIT编译器 <em>Graal</em> 能够作为Linux/x64平台上的实验性JIT编译器使用。Graal将使用JDK 9中引入的JVM编译器接口(JVMCI)。Graal已经在JDK中了，所以启用它作为实验性的JIT主要是测试和调试工作。</p><p>要启用Graal作为JIT编译器，请在Java命令行上使用以下选项:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler</span><br></pre></td></tr></table></figure><p>Graal是Java中对JIT编译器的完全重写。以前的JIT编译器是用c++编写的。</p><h2 id="线程本地”握手”（Thread-Local-Handshakes）"><a href="#线程本地”握手”（Thread-Local-Handshakes）" class="headerlink" title="线程本地”握手”（Thread-Local Handshakes）"></a>线程本地”握手”（Thread-Local Handshakes）</h2><p>这个JEP通过在不执行全局VM安全点的情况下在应用程序线程上执行回调，为改进VM性能奠定了基础。这意味着JVM可以停止单个线程，而不是全部。</p><p>线程本地握手将首先在x64和SPARC上实现。其他平台将退回到正常的安全点。新选项<code>-XX:ThreadLocalHandshakes</code>(默认值为true)允许用户在支持的平台上选择正常的安全点。</p><h2 id="移除头文件生成工具（Remove-the-Native-Header-Generation-Tool）"><a href="#移除头文件生成工具（Remove-the-Native-Header-Generation-Tool）" class="headerlink" title="移除头文件生成工具（Remove the Native-Header Generation Tool）"></a>移除头文件生成工具（Remove the Native-Header Generation Tool）</h2><p>它将从JDK中删除<code>javah</code>工具，这是一个在编译JNI代码时生成头文件的独立工具，因为这可以通过<code>javac</code>完成。</p><p>这是另一个Java 10特性，侧重于管理。</p><h2 id="新增的API和参数（New-Added-APIs-and-Options）"><a href="#新增的API和参数（New-Added-APIs-and-Options）" class="headerlink" title="新增的API和参数（New Added APIs and Options）"></a>新增的API和参数（New Added APIs and Options）</h2><p>Java 10里新增了73个API，我们来看下：</p><table><thead><tr><th>API</th><th>DESCRIPTION</th></tr></thead><tbody><tr><td>Optional.orElseThrow()</td><td>一个新的方法orElseThrow被添加到这个可选的类中。它是现有get方法的同义词，现在是首选的替代方法</td></tr><tr><td>List.copyOf, Set.copyOf, and Map.copyOf</td><td>这些方法从现有实例创建新的集合实例</td></tr><tr><td>Collectors.toUnmodifiableList, Collectors.toUnmodifiableSet, Collectors.toUnmodifiableMap</td><td>这些方法允许将流的元素收集到不可修改的集合中</td></tr><tr><td>–jdk.disableLastUsageTracking</td><td>禁用对正在运行的VM的JRE最后一次使用情况跟踪</td></tr><tr><td>–add-stylesheet</td><td>支持在生成的文档中使用多个样式表</td></tr><tr><td>–main-stylesheet</td><td>以帮助区分主样式表和其他样式表</td></tr><tr><td>@summary Tag</td><td>添加以显式指定用作API描述摘要的文本。默认情况下，API描述的摘要是从第一句话推断出来的</td></tr></tbody></table><h2 id="删除的API和参数（Removed-APIs-and-Options）"><a href="#删除的API和参数（Removed-APIs-and-Options）" class="headerlink" title="删除的API和参数（Removed APIs and Options）"></a>删除的API和参数（Removed APIs and Options）</h2><table><thead><tr><th>API</th><th>DESCRIPTION</th></tr></thead><tbody><tr><td>LookAndFeels</td><td></td></tr><tr><td>Runtime.getLocalizedInputStream, Runtime.getLocalizedOutputStream</td><td>过时的国际化机制的一部分，没有实际用途</td></tr><tr><td>RMI Server-Side Multiplex Protocol Support</td><td>JDK 9被禁用，现在已被删除</td></tr><tr><td>Common DOM APIs</td><td><code>com.sun.java.browser.plugin2.DOM</code>和<code>sun.plugin.dom.DOMObject</code>现已被删除，应用可以使用<code>netscape.javascript.JSObject</code>去操作DOM</td></tr><tr><td>FlatProfiler</td><td>JDK 9已弃用，目前已删除</td></tr><tr><td>-Xoss, -Xsqnopause, -Xoptimize, -Xboundthreads,-Xusealtsigs</td><td>这几项参数均被移除</td></tr><tr><td>policytool</td><td>policytool安全工具已从JDK中删除。</td></tr><tr><td>弃用<code>com.sun.security.auth.**</code></td><td>下面的class已被删除：com.sun.security.auth.PolicyFile, com.sun.security.auth.SolarisNumericGroupPrincipal,com.sun.security.auth.SolarisNumericUserPrincipal,com.sun.security.auth.SolarisPrincipal,com.sun.security.auth.X500Principal,com.sun.security.auth.module.SolarisLoginModule,com.sun.security.auth.module.SolarisSystem</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java 10" scheme="https://www.sakuratears.top/tags/Java-10/"/>
    
  </entry>
  
  <entry>
    <title>Java 10 局部变量类型推断</title>
    <link href="https://www.sakuratears.top/blog/Java-10-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD.html"/>
    <id>https://www.sakuratears.top/blog/Java-10-局部变量类型推断.html</id>
    <published>2020-04-21T08:31:00.000Z</published>
    <updated>2020-04-21T08:34:38.200Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java一直在逐步减少语法上的冗长。首先是Diamond操作符，现在是var(局部变量类型- <a href="https://openjdk.java.net/jeps/286" rel="external nofollow noopener noreferrer" target="_blank">JEP 286</a>)来在Java中声明变量。</p><p>当我们使用var来声明变量时，不是声明一个变量类型，而是假设它的类型来自它被设置的值。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var str = <span class="string">"Hello world"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"> </span><br><span class="line">String str = <span class="string">"Hello world"</span>;</span><br></pre></td></tr></table></figure><p>在上面的例子中，在第一个语句中，我们将一个字符串设置为变量str，因此它被隐式地假定为字符串类型。第一个语句本质上等价于上面例子中的第二个语句。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="需要同时声明和初始化var"><a href="#需要同时声明和初始化var" class="headerlink" title="需要同时声明和初始化var"></a>需要同时声明和初始化var</h2><p>使用var时，必须在相同的位置初始化变量。</p><p>不能将声明和初始化放在不同的位置。</p><p>如果我们没有在适当的地方初始化变量，那么将会得到编译错误 - <code>Cannot use ‘var’ on variable without initializer</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var i;  <span class="comment">//错误声明定义 - - Cannot use 'var' on variable without initializer</span></span><br><span class="line">         </span><br><span class="line">var j = <span class="number">10</span>; <span class="comment">//正确声明定义</span></span><br><span class="line"> </span><br><span class="line">System.out.println(i);</span><br></pre></td></tr></table></figure><h2 id="var不是关键字"><a href="#var不是关键字" class="headerlink" title="var不是关键字"></a>var不是关键字</h2><p>看起来像，但实际上var不是Java的关键字，所以我们可以命名叫var的变量，这是允许的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var var = <span class="number">10</span>;   <span class="comment">//正确</span></span><br><span class="line">         </span><br><span class="line"><span class="keyword">int</span> var = <span class="number">10</span>;   <span class="comment">//正确</span></span><br></pre></td></tr></table></figure><h2 id="var用法"><a href="#var用法" class="headerlink" title="var用法"></a>var用法</h2><p>var的使用是有限制的，它可以应用在局部变量与初始化参数、for循环等，它不适用于方法参数、构造函数参数、方法返回类型、字段、捕获参数或任何其他类型的变量声明。</p><p>允许使用范围：</p><ul><li>初始化的局部变量</li><li>增强for循环</li><li>普通for循环</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var blogName = <span class="string">"howtodoinjava.com"</span>;</span><br><span class="line">         </span><br><span class="line"><span class="keyword">for</span> ( var object : dataList)&#123;</span><br><span class="line">    System.out.println( object );</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> ( var i = <span class="number">0</span> ; i &lt; dataList.size(); i++ )&#123;</span><br><span class="line">    System.out.println( dataList.get(i) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不允许使用的范围：</p><ul><li>方法参数</li><li>构造函数参数</li><li>方法返回类型</li><li>类字段</li><li>异常捕获参数或者其他类型的变量声明</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//var firstName;    //不允许定义在类里</span></span><br><span class="line">         </span><br><span class="line">    <span class="comment">//public Application(var param)&#123;    //不允许作为构造函数参数</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*try&#123;</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">    &#125; catch(var ex)&#123;    //不允许作为异常捕获参数</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*public var demoMethod()&#123;  //不允许作为方法返回参数</span></span><br><span class="line"><span class="comment">        return null;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*public Integer demoMethod2( var input )&#123;  //不允许作为方法入参</span></span><br><span class="line"><span class="comment">        return null;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="var不是向后兼容的"><a href="#var不是向后兼容的" class="headerlink" title="var不是向后兼容的"></a>var不是向后兼容的</h2><p>由于这是一种新的语言特性，所以使用var编写的代码不会在较低的JDK版本(少于10)中编译。</p><p>所以，只有我们确定要使用它时，才建议使用。</p><h2 id="var不影响性能"><a href="#var不影响性能" class="headerlink" title="var不影响性能"></a>var不影响性能</h2><p>要知道，在Java中，类型不是在运行时推断的，而是在编译时推断的。这意味着生成的字节码与显式类型声明相同 - 它确实包含了关于类型的信息。这意味着在运行时没有进行额外的处理。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>以上就是关于var的全部内容。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java 10" scheme="https://www.sakuratears.top/tags/Java-10/"/>
    
  </entry>
  
  <entry>
    <title>Java 10 基于时间的发布版本</title>
    <link href="https://www.sakuratears.top/blog/Java-10-%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E7%9A%84%E5%8F%91%E5%B8%83%E7%89%88%E6%9C%AC.html"/>
    <id>https://www.sakuratears.top/blog/Java-10-基于时间的发布版本.html</id>
    <published>2020-04-21T08:29:00.000Z</published>
    <updated>2020-04-21T08:30:05.669Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从Java 10开始，Oracle已经适应了基于时间的版本字符串方案[JEP 322]。新的基于时间的模型已经取代了过去基于特性的多年发布模型。与旧版本不同的是，基于时间的新版本不会延迟发布，新功能将每六个月发布一次，对新版本中可以发布哪些功能没有限制。</p><p>更新版本将在每个季度(1月、4月、7月、10月)发布。更新版本将严格限制在新特性的安全问题、回归和bug的修复上。根据计划安排，我们可以说每个特性发布在下一次特性发布之前会收到两次更新。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Java版本格式化"><a href="#Java版本格式化" class="headerlink" title="Java版本格式化"></a>Java版本格式化</h2><p>如果我们在终端运行<code>java -version</code>命令，那么将会得到如下的版本信息输出：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\<span class="title">Lokesh</span>&gt;<span class="title">java</span> -<span class="title">version</span></span></span><br><span class="line"><span class="function"><span class="title">java</span> <span class="title">version</span> "10.0.1" 2018-04-17</span></span><br><span class="line"><span class="function"><span class="title">Java</span>(<span class="title">TM</span>) <span class="title">SE</span> <span class="title">Runtime</span> <span class="title">Environment</span> 18.3 (<span class="title">build</span> 10.0.1+10)</span></span><br><span class="line"><span class="function"><span class="title">Java</span> <span class="title">HotSpot</span>(<span class="title">TM</span>) 64-<span class="title">Bit</span> <span class="title">Server</span> <span class="title">VM</span> 18.3 (<span class="title">build</span> 10.0.1+10, <span class="title">mixed</span> <span class="title">mode</span>)</span></span><br></pre></td></tr></table></figure><p>新的版本号格式是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$FEATURE.$INTERIM.$UPDATE.$PATCH</span><br></pre></td></tr></table></figure><table><thead><tr><th>COUNTER NAME</th><th>DESCRIPTION</th></tr></thead><tbody><tr><td>$FEATURE</td><td>每6个月将增加，如下：JDK 10, JDK 11. (旧称 $MAJOR.)</td></tr><tr><td>$INTERIM</td><td>这个通常是0，在6个月期限内。对于包含兼容的bug修复和增强，但没有不兼容的更改、没有删除特性和对标准api没有更改的非特性发布，它将增加。(旧称：$MINOR)</td></tr><tr><td>$UPDATE</td><td>在处理兼容的更新版本，以修复新特性中的安全问题、倒退和bug时，它将会增加.(旧称：$SECURITY)</td></tr><tr><td>$PATCH</td><td>只有在需要生成紧急版本来修复关键问题时，才会增加它。</td></tr></tbody></table><blockquote><p>将一个版本号中的数字序列与另一个版本号中的数字序列进行逐点比较;例如，10.0.4小于10.1.2。如果一个序列短于另一个序列，则认为短序列缺少的元素小于长序列相应的元素;例如，10.0.2小于10.0.2.1。</p></blockquote><h2 id="Java-Version-API"><a href="#Java-Version-API" class="headerlink" title="Java Version API"></a>Java Version API</h2><p><code>Runtime.version()</code> 使我们可以通过代码去获取版本信息。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Version version = Runtime.version();</span><br><span class="line">version.feature();</span><br><span class="line">version.interim();</span><br><span class="line">version.update();</span><br><span class="line">version.patch();</span><br><span class="line"> </span><br><span class="line">Output:</span><br><span class="line"> </span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>版本的转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Version version = Runtime.Version.parse(<span class="string">"10.0.1"</span>);</span><br><span class="line"> </span><br><span class="line">version.feature();</span><br><span class="line">version.interim();</span><br><span class="line">version.update();</span><br><span class="line">version.patch();</span><br></pre></td></tr></table></figure><h2 id="长期版本支持-LTS"><a href="#长期版本支持-LTS" class="headerlink" title="长期版本支持 (LTS)"></a>长期版本支持 (LTS)</h2><p>主要面向企业客户。Oracle将为LTS版本的产品将提供卓越和持续的支持。此外，这些版本的更新将至少在三年内可用。</p><p>“LTS”在<code>java -version</code>的输出中会突出显示。例如: <code>11.0.2 + 13-LTS</code></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>以上就是关于Java 10 版本的全部内容。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java 10" scheme="https://www.sakuratears.top/tags/Java-10/"/>
    
  </entry>
  
  <entry>
    <title>[转] Java 9特性及增强</title>
    <link href="https://www.sakuratears.top/blog/%5B%E8%BD%AC%5DJava-9%E7%89%B9%E6%80%A7%E5%8F%8A%E5%A2%9E%E5%BC%BA.html"/>
    <id>https://www.sakuratears.top/blog/[转]Java-9特性及增强.html</id>
    <published>2020-04-13T02:54:00.000Z</published>
    <updated>2020-04-13T03:01:32.963Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://howtodoinjava.com/java9/java9-new-features-enhancements/" rel="external nofollow noopener noreferrer" target="_blank">原文链接</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java 9带来了很多新的增强，这些增强将在很大程度上影响我们的编程风格和习惯。最大的变化是Java的模块化。这是Java 8中的Lambdas之后的另一个重大变化。</p><p>本文中，我们将介绍JDK 9的新特性及增强。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="模块化（Java-platform-module-system）"><a href="#模块化（Java-platform-module-system）" class="headerlink" title="模块化（Java platform module system）"></a>模块化（Java platform module system）</h2><p>JPMS (Java平台模块系统)是新版Java 9的核心亮点。它也被称为<a href="https://openjdk.java.net/projects/jigsaw/" rel="external nofollow noopener noreferrer" target="_blank">“Jigshaw计划”</a>。模块是新的结构，就像我们已经有了包一样。使用新的模块化编程开发的应用程序可以看作是具有定义良好的边界和这些模块之间的依赖关系的交互模块的集合。</p><p>JPMS包括对编写模块化应用程序的支持，以及对JDK源代码的模块化。JDK 9附带了大约92个模块(在GA版本中可以进行更改)。Java 9模块系统有一个“Java”。它被称为基模块。它是一个独立的模块，不依赖于任何其他模块。默认情况下，所有其他模块都依赖于“java.base”。</p><p>java模块化编程要点：</p><ol><li>模块通常只是一个jar文件，在根目录下有一个module-info.class文件。</li><li>要使用模块，请将jar文件包含到modulepath中，而不是classpath中。添加到classpath中的模块jar文件是普通的jar文件，而module-info.class文件将被忽略。</li></ol><p>典型的module-info.java类是这样的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> helloworld &#123;</span><br><span class="line">    <span class="keyword">exports</span> com.howtodoinjava.demo;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">module</span> test &#123;</span><br><span class="line">    <span class="keyword">requires</span> helloworld;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于模块化的更多介绍可以查看 <a href="https://www.sakuratears.top/blog/Java-9%E6%A8%A1%E5%9D%97%E5%8C%96.html#more">Java 9模块化</a></p><h2 id="接口私有方法（Interface-Private-Methods）"><a href="#接口私有方法（Interface-Private-Methods）" class="headerlink" title="接口私有方法（Interface Private Methods）"></a>接口私有方法（Interface Private Methods）</h2><p>Java 8允许在接口中编写默认方法，这是一个广受好评的特性。因此，在这之后，接口中缺少的只有私有方法了。从Java 9开始，我们可以在接口中声明私有方法。</p><p>这些私有方法将提高接口内部的代码可重用性。例如，如果两个默认方法需要共享代码，一个私有接口方法将允许它们这样做，但是不会将这个私有方法暴露给它的实现类。</p><p>在接口中使用私有方法有四个规则:</p><ol><li>私有接口方法不能是抽象的。</li><li>私有方法只能在接口内部使用。</li><li>私有静态方法可以在其他静态和非静态接口方法中使用。</li><li>私有非静态方法不能在私有静态方法中使用。</li></ol><p>一个使用私有方法接口的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomCalculator</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">addEvenNumbers</span><span class="params">(<span class="keyword">int</span>... nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> add(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">addOddNumbers</span><span class="params">(<span class="keyword">int</span>... nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> add(n -&gt; n % <span class="number">2</span> != <span class="number">0</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(IntPredicate predicate, <span class="keyword">int</span>... nums)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> IntStream.of(nums)</span><br><span class="line">                .filter(predicate)</span><br><span class="line">                .sum();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于接口私有方法的更多内容可以查看 <a href="https://www.sakuratears.top/blog/Java-9%E6%8E%A5%E5%8F%A3%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95.html#more">Java 9接口私有方法</a></p><h2 id="HTTP-2-Client"><a href="#HTTP-2-Client" class="headerlink" title="HTTP/2 Client"></a>HTTP/2 Client</h2><p>HTTP/1.1客户端在1997年发布。从那以后发生了很大的变化。因此，Java 9引入了一个新的API，它使用起来更干净、更清晰，并且还增加了对HTTP/2的支持。</p><p>新的API使用了3个主要的类:<code>HttpClient</code>, <code>HttpRequest</code>和<code>HttpResponse</code>。</p><p>要发出请求，只需获取客户端、构建请求并发送请求，如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HttpClient httpClient = HttpClient.newHttpClient(); </span><br><span class="line">HttpRequest httpRequest = HttpRequest.newBuilder().uri(<span class="keyword">new</span> URI(<span class="string">"//howtodoinjava.com/"</span>)).GET().build(); </span><br><span class="line">HttpResponse&lt;String&gt; httpResponse = httpClient.send(httpRequest, HttpResponse.BodyHandler.asString()); </span><br><span class="line">System.out.println( httpResponse.body() );</span><br></pre></td></tr></table></figure><p>上面的代码看起来更清晰可读了。</p><p>新的API还支持使用<code>httpClient.sendAsync()</code>方法的异步HTTP请求。它返回<code>CompletableFuture</code>对象，该对象可用于确定请求是否已完成。它还提供了在请求完成后对<code>HttpResponse</code>的访问。最好的一点是，如果你想，你甚至可以在请求完成之前取消它。</p><p>我们来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(httpResponse.isDone()) &#123;</span><br><span class="line">    System.out.println(httpResponse.get().statusCode());</span><br><span class="line">    System.out.println(httpResponse.get().body());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    httpResponse.cancel(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JShell-工具（JShell-–-REPL-Tool）"><a href="#JShell-工具（JShell-–-REPL-Tool）" class="headerlink" title="JShell 工具（JShell – REPL Tool）"></a>JShell 工具（JShell – REPL Tool）</h2><p>JShell是JDK 9发行版附带的新的命令行交互工具[JEP 222]，用于评估用Java编写的声明、语句和表达式。JShell允许我们执行Java代码片段并立即获得结果，而不必创建解决方案或项目。</p><p>Jshell很像linux操作系统中的命令窗口。不同之处在于JShell是特定于Java的。除了执行简单的代码片段外，它还有许多其他功能。如：</p><ol><li>在单独的窗口中启动内建代码编辑器</li><li>在单独的窗口中启动您选择的代码编辑器</li><li>当保存操作在这些外部编辑器中发生时执行代码</li><li>从文件系统加载预先编写的类</li></ol><p>关于JShell的更多内容，请查看 <a href="https://www.sakuratears.top/blog/Java-9-JShell.html#more">Java 9 JShell</a>。</p><h2 id="平台和JVM日志（Platform-and-JVM-Logging）"><a href="#平台和JVM日志（Platform-and-JVM-Logging）" class="headerlink" title="平台和JVM日志（Platform and JVM Logging）"></a>平台和JVM日志（Platform and JVM Logging）</h2><p>JDK 9通过一个新的loging API改进了平台类(JDK类)和JVM组件的日志记录。它允许我们指定自己选择的日志记录框架(例如Log4J2)作为来自JDK类的日志记录消息的日志记录后端。</p><p>关于这个API，我们需要知道以下几点:</p><ol><li>API应该由JDK中的类使用，而不是由应用程序类使用。</li><li>对于我们的应用程序代码，我们将像以前一样继续使用其他日志api。</li><li>该API不允许我们以编程方式配置日志记录器。</li></ol><p>API包含以下内容:</p><ol><li>一个服务接口，<code>java.lang.System.LoggerFinder</code>，它是一个抽象的静态类</li><li>一个接口<code>java.lang.System.Logger</code>，它提供了日志API</li><li>一个重载方法<code>getLogger()</code>位于<code>java.lang.System</code>类，它返回一个logger实例。</li></ol><p>JDK 9还添加了一个新的命令行选项<code>-Xlog</code>，它为我们提供了一个访问所有JVM类中记录的所有消息的单点访问点。</p><p>下面是使用<code>-Xlog</code>选项的语法:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xlog [:][:[][:[][:]]]</span><br></pre></td></tr></table></figure><p>所有选项都是可选的。如果缺少<code>-Xlog</code>中的前一部分，则必须为该部分使用冒号。</p><p>例如，<code>-Xlog::stderr</code>表示所有部件都是默认的，其中输出设置为stderr。</p><p>关于JVM Logging的更多内容，我们后面讨论。</p><h2 id="进程API更新（Process-API-Updates）"><a href="#进程API更新（Process-API-Updates）" class="headerlink" title="进程API更新（Process API Updates）"></a>进程API更新（Process API Updates）</h2><p>在Java 5之前，生成新进程的惟一方法是使用Runtime.getRuntime().exec()方法。然后在Java 5中引入了ProcessBuilder API，它支持一种更干净的生成新进程的方式。现在Java 9增加了一种获取当前进程和任何衍生进程信息的新方法。</p><p>要获取任何进程的信息，现在应该使用<code>java.lang.ProcessHandle.Info</code>接口。这个接口在获取进程较多信息时很有用。如以下进程信息：</p><ol><li>用于启动进程的命令</li><li>命令的参数</li><li>启动过程的时间瞬间</li><li>它和创建它的用户所花费的总时间</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ProcessHandle processHandle = ProcessHandle.current();</span><br><span class="line">ProcessHandle.Info processInfo = processHandle.info();</span><br><span class="line"> </span><br><span class="line">System.out.println( processHandle.getPid() );</span><br><span class="line">System.out.println( processInfo.arguments().isPresent() );</span><br><span class="line">System.out.println( pprocessInfo.command().isPresent() );</span><br><span class="line">System.out.println( processInfo.command().get().contains(<span class="string">"java"</span>) );</span><br><span class="line">System.out.println( processInfo.startInstant().isPresent() );</span><br></pre></td></tr></table></figure><p>要获取新派生进程的信息，请使用<code>process.toHandle()</code>方法获取<code>ProcessHandle</code>实例。剩下的事情如上所述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String javaPrompt = ProcessUtils.getJavaCmd().getAbsolutePath();</span><br><span class="line">ProcessBuilder processBuilder = <span class="keyword">new</span> ProcessBuilder(javaPrompt, <span class="string">"-version"</span>);</span><br><span class="line">Process process = processBuilder.inheritIO().start();</span><br><span class="line">ProcessHandle processHandle = process.toHandle();</span><br></pre></td></tr></table></figure><p>还可以使用<code>ProcessHandle.allProcesses()</code>获取系统中所有可用进程的<code>ProcessHandle</code>流。</p><p>要获得所有子进程的列表(一级的和n级深度的)，可以使用<code>children()</code> 和 <code>descendants()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;ProcessHandle&gt; children    = ProcessHandle.current().children();</span><br><span class="line">Stream&lt;ProcessHandle&gt; descendants = ProcessHandle.current().descendants();</span><br></pre></td></tr></table></figure><h2 id="集合API更新（Collection-API-Updates）"><a href="#集合API更新（Collection-API-Updates）" class="headerlink" title="集合API更新（Collection API Updates）"></a>集合API更新（Collection API Updates）</h2><p>从Java 9开始，我们可以使用新的工厂方法创建不可变集合，如不可变list、不可变set和不可变map。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableCollections</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;String&gt; namesList = List.of(<span class="string">"Lokesh"</span>, <span class="string">"Amit"</span>, <span class="string">"John"</span>);</span><br><span class="line"> </span><br><span class="line">        Set&lt;String&gt; namesSet = Set.of(<span class="string">"Lokesh"</span>, <span class="string">"Amit"</span>, <span class="string">"John"</span>);</span><br><span class="line"> </span><br><span class="line">        Map&lt;String, String&gt; namesMap = Map.ofEntries(</span><br><span class="line">                                    Map.entry(<span class="string">"1"</span>, <span class="string">"Lokesh"</span>),</span><br><span class="line">                                    Map.entry(<span class="string">"2"</span>, <span class="string">"Amit"</span>),</span><br><span class="line">                                    Map.entry(<span class="string">"3"</span>, <span class="string">"Brian"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于更多的集合API更新内容请查看 <a href="https://www.sakuratears.top/blog/Java-9%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E5%8F%98%E6%9B%B4.html#more">Java 9集合相关更新</a></p><h2 id="Stream-API相关更新（Stream-API-Improvements）"><a href="#Stream-API相关更新（Stream-API-Improvements）" class="headerlink" title="Stream API相关更新（Stream API Improvements）"></a>Stream API相关更新（Stream API Improvements）</h2><p>Java 9引入了两种与流交互的新方法，即<code>takeWhile</code>/<code>dropWhile</code>方法。此外，它还添加了两个重载方法，即<code>ofNullable</code>和<code>iterate</code>方法。</p><p>新的方法<code>takeWhile</code>和<code>dropWhile</code>允许我们根据谓词获取流的一部分。</p><ol><li>在一个有序的流上，<code>takeWhile</code>返回从流中取出的与给定谓词匹配的元素的“最长前缀”，从流的开头开始。<code>dropWhile</code>返回未被<code>takeWhile</code>匹配的剩余项。</li><li>在一个无序流上，<code>takeWhile</code>从流的开头开始返回匹配给定谓词(但不是全部)的流元素的子集。<code>dropWhile</code>在删除匹配给定谓词的元素子集后返回剩余的流元素。</li></ol><p>类似地，在Java 8之前，流中不能有<code>null</code>值。它会导致<code>NullPointerException</code>。自Java 9以来，<code>Stream.ofnullable()</code>方法允许我们创建一个单元素流，它包装一个值(如果不是<code>null</code>)，或者是一个空流。从技术上讲，<code>Stream.ofnullable()</code>与在流API上下文中使用<code>null</code>条件检查非常相似。</p><p>关于Stream API更新更多内容，可以查看 <a href="https://www.sakuratears.top/blog/Java-9-Stream-API%E5%8F%98%E6%9B%B4.html#more">Java 9 Stream API更新</a></p><h2 id="多版本JAR引用增强（Multi-Release-JAR-Files）"><a href="#多版本JAR引用增强（Multi-Release-JAR-Files）" class="headerlink" title="多版本JAR引用增强（Multi-Release JAR Files）"></a>多版本JAR引用增强（Multi-Release JAR Files）</h2><p>这个增强与我们如何在jar文件中打包应用程序类有关。在此之前，我们必须将所有类打包到一个jar文件中，并放入另一个希望使用它的应用程序的类路径中。</p><p>使用多版本特性，现在jar可以包含一个类的不同版本——兼容于不同的JDK版本。类的不同版本的信息，以及在哪个JDK版本中哪个类应该被类加载，都存储在<code>MANIFEST.MF</code>文件中。在本例中，<code>MANIFEST.MF</code>文件主要部分包含了条目<code>Multi-Release: true</code>。</p><p>而且，<code>META-INF</code>包含一个版本子目录，它的整数命名的子目录(从9开始(对于Java 9))存储特定于版本的类和资源文件。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">JAR content root</span><br><span class="line">  A.class</span><br><span class="line">  B.class</span><br><span class="line">  C.class</span><br><span class="line">  D.class</span><br><span class="line">  META-INF</span><br><span class="line">     MANIFEST.MF</span><br><span class="line">     versions</span><br><span class="line">        <span class="number">9</span></span><br><span class="line">           A.class</span><br><span class="line">           B.class</span><br></pre></td></tr></table></figure><p>让我们假设在JDK 10中，A.class被更新以利用一些Java 10特性，然后这个Jar文件可以这样更新:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">JAR content root</span><br><span class="line">  A.class</span><br><span class="line">  B.class</span><br><span class="line">  C.class</span><br><span class="line">  D.class</span><br><span class="line">  META-INF</span><br><span class="line">     MANIFEST.MF</span><br><span class="line">     versions</span><br><span class="line">        <span class="number">9</span></span><br><span class="line">           A.class</span><br><span class="line">           B.class</span><br><span class="line">        <span class="number">10</span></span><br><span class="line">           A.class</span><br></pre></td></tr></table></figure><p>这看起来是一个很有用的增强，它解决了在大型应用程序中经常出现的依赖问题，在这些应用程序中，具有不同版本的jar彼此不兼容。这个特性对解决这些场景有很大的帮助。</p><h2 id="Deprecated标签（-Deprecated-Tag-Changes）"><a href="#Deprecated标签（-Deprecated-Tag-Changes）" class="headerlink" title="@Deprecated标签（@Deprecated Tag Changes）"></a>@Deprecated标签（@Deprecated Tag Changes）</h2><p>从Java 9开始，<code>@Deprecated</code>注释将有两个属性，即<code>forRemoval</code>和<code>since</code>。</p><ol><li><code>forRemoval</code>：指示所注释的元素在将来的版本中是否要被删除。</li><li><code>since</code>：它返回注释元素被弃用的版本。</li></ol><p>强烈建议在文档中使用<code>@deprecated</code> javadoc标记解释弃用该API的原因。文档还应该建议并链接到推荐的替换API(如果适用的话)。替换API通常有一些与原API不同的地方，因此也应该作出说明。</p><h2 id="堆栈相关（Stack-Walking）"><a href="#堆栈相关（Stack-Walking）" class="headerlink" title="堆栈相关（Stack Walking）"></a>堆栈相关（Stack Walking）</h2><p>堆栈是后进先出(LIFO)数据结构。在JVM级别，堆栈存储帧。每次调用一个方法时，都会创建一个新帧并将其推到堆栈的顶部。当方法调用完成时，帧将被销毁(从堆栈中弹出)。堆栈上的每个帧都包含自己的局部变量数组，以及自己的操作数堆栈、返回值和对当前方法类的运行时常量池的引用。</p><p>在给定的线程中，在任何点上都只有一个帧是活动的。活动帧称为当前帧，其方法称为当前方法。(<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.2" rel="external nofollow noopener noreferrer" target="_blank">了解更多</a>)</p><p>在Java 8之前，<code>StackTraceElement</code>表示一个堆栈帧。要获得完整的堆栈，必须使用<code>Thread.getStackTrace()</code>和<code>Throwable.getStackTrace()</code>。它返回一个<code>StackTraceElement</code>数组，我们可以迭代该数组以获得所需的信息。</p><p>在Java 9中，引入了一个新的类<code>StackWalker</code>。该类使用当前线程的连续堆栈帧流提供了简单而有效的堆栈遍历。<code>StackWalker</code>类非常高效，因为它对堆栈帧的计算是延迟的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印当前线程的所有堆栈帧的详细信息</span></span><br><span class="line">StackWalker.getInstance () .forEach (system . out:: println);</span><br></pre></td></tr></table></figure><p>我们还可以用这个流做很多其他的事情，我们将在其他的文章中讨论。</p><h2 id="Java-Docs-相关更新（Java-Docs-Updates）"><a href="#Java-Docs-相关更新（Java-Docs-Updates）" class="headerlink" title="Java Docs 相关更新（Java Docs Updates）"></a>Java Docs 相关更新（Java Docs Updates）</h2><p>Java 9增强了<code>javadoc</code>工具来生成HTML5标记。它当前在HTML 4.01中生成页面。</p><p>为了生成HTML5 Javadoc，需要在命令行参数中加入参数<code>-html5</code>。要在命令行生成文档，可以运行以下命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javadoc [options] [packagenames] [sourcefile] [@files]</span><br></pre></td></tr></table></figure></p><p>使用HTML5带来了更简单的HTML5结构的好处。它还实现了<a href="https://www.w3.org/WAI/standards-guidelines/aria/" rel="external nofollow noopener noreferrer" target="_blank">WAI-ARIA standard </a>可访问性标准。这样做的目的是让有生理或视觉缺陷的人更容易使用屏幕阅读器之类的工具访问<code>javadocs</code>页面。</p><p><a href="https://openjdk.java.net/jeps/225" rel="external nofollow noopener noreferrer" target="_blank">JEP 225</a>允许在<code>javadoc</code>中搜索程序元素和带标记的单词和短语。</p><p>以下将被索引和搜索:</p><ul><li>模块的声明名称(Declared names of modules)</li><li>包(Packages)</li><li>类型和成员(Types and members)</li><li>方法参数类型的简单名称(The simple name of method parameter types)</li></ul><p>这是在客户端实现的，带有一个新的<code>search.js</code> Javascript文件，以及在生成<code>javadoc</code>时生成的索引。在生成的HTML5 API页面上有一个搜索框可用。</p><p>请注意，搜索选项将默认添加，但可以关闭参数:<code>-noindex</code>。</p><h2 id="其它特性及增强（Miscellaneous-Other-Features）"><a href="#其它特性及增强（Miscellaneous-Other-Features）" class="headerlink" title="其它特性及增强（Miscellaneous Other Features）"></a>其它特性及增强（Miscellaneous Other Features）</h2><p>在Java 9中还有其他特性，我把它们列在下面以供快速参考。我们将在以后的文章中讨论所有这些特性。</p><ul><li>Reactive Streams API</li><li>GC改进（GC (Garbage Collector) Improvements）</li><li>Filter Incoming Serialization Data</li><li>弃用Applet（Deprecate the Applet API）</li><li>Indify String Concatenation</li><li>Enhanced Method Handles</li><li>Compact Strings</li><li>Nashorn解析器（Parser API for Nashorn）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java 9" scheme="https://www.sakuratears.top/tags/Java-9/"/>
    
  </entry>
  
  <entry>
    <title>Java 9 JShell</title>
    <link href="https://www.sakuratears.top/blog/Java-9-JShell.html"/>
    <id>https://www.sakuratears.top/blog/Java-9-JShell.html</id>
    <published>2020-04-13T02:15:00.000Z</published>
    <updated>2020-04-13T02:32:26.143Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>JShell是JDK 9发行版[JEP 222]附带的新命令行交互式REPL (Read-Evaluate-Print-Loop)控制台，用于计算用Java编写的声明、语句和表达式。JShell允许我们执行Java代码片段并立即获得结果，而不必创建解决方案或项目。</p><p>在本文中，我们将通过示例学习在JShell中可以完成的各种任务。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="运行JShell"><a href="#运行JShell" class="headerlink" title="运行JShell"></a>运行JShell</h2><p>首先要做的是将JDK 9安装到您的计算机中。从这个链接下载<a href="https://jdk.java.net/9/" rel="external nofollow noopener noreferrer" target="_blank">JDK 9</a>并安装它。</p><p>进入安装位置，查看/jdk-9/bin文件夹。我们将在这里找到jshell.exe文件。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-615.png" alt="upload successful"></p><p>现在启动一个新的命令窗口并检查java版本。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; java -version</span><br></pre></td></tr></table></figure><p>它应该指向JDK 9版本。如果不是，则使用相应的值更新环境属性<code>JAVA_HOME</code>和<code>PATH</code>。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME=C:\Program Files\Java\jdk-<span class="number">9</span></span><br><span class="line"><span class="built_in">PATH</span>=C:\Program Files\Java\jdk-<span class="number">9</span>\bin    //<span class="built_in">Path</span> till bin folder</span><br></pre></td></tr></table></figure><p>现在再次启动新的命令提示窗口并输入命令jshell。它将把游标更改为jshell。如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-616.png" alt="upload successful"></p><p>接下来我们来看下如何在JShell REPL中运行了Java相关代码。</p><h2 id="在REPL里编写和运行一段Java代码"><a href="#在REPL里编写和运行一段Java代码" class="headerlink" title="在REPL里编写和运行一段Java代码"></a>在REPL里编写和运行一段Java代码</h2><p>Jshell允许创建小的代码片段并对它们进行测试，而不需要创建和构建复杂的项目。这就是它的用法。</p><p>在JShell上运行代码片段非常容易，我们来看一下。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>我们可以像在实际编程中那样定义变量。唯一不同的是，我们不必一开始就编写一个类或方法。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; int i = <span class="number">10</span>;</span><br><span class="line">i ==&gt; <span class="number">10</span></span><br></pre></td></tr></table></figure><p>要输出变量的值，只需输入变量名并回车。它将输出变量的值。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; i</span><br><span class="line">i ==&gt; <span class="number">10</span></span><br></pre></td></tr></table></figure><p>要将变量重新赋值给新值，只需按常规方式执行即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; i=<span class="number">20</span>;</span><br><span class="line">i ==&gt; <span class="number">20</span></span><br></pre></td></tr></table></figure><p>要列出所有定义的变量，使用 <code>/vars</code> 命令。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; /vars</span><br><span class="line">|    int i = <span class="number">20</span></span><br><span class="line">|    int j = <span class="number">30</span></span><br></pre></td></tr></table></figure><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-617.png" alt="upload successful"></p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>和变量一样，方法也很简单。</p><p>要在JShell中创建方法，需要定义retrun类型、方法名称、参数和方法体定义方法。不需要访问修饰符。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; int sum (int a, int b) &#123;</span><br><span class="line">   ...&gt; return a+b;</span><br><span class="line">   ...&gt; &#125;</span><br><span class="line">|  created method sum(int,int)</span><br></pre></td></tr></table></figure><p>列出所有定义的方法，使用<code>/methods</code> 命令。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; /methods</span><br><span class="line">|    int sum(int,int)</span><br></pre></td></tr></table></figure><p>要使用方法，像普通编程那样调用即可。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; sum(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">$<span class="number">6</span> ==&gt; <span class="number">4</span></span><br></pre></td></tr></table></figure><p>如果我们想查看方法源码，使用<code>/list</code>命令即可，它将展示指定方法的源码。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; /list sum</span><br><span class="line"> </span><br><span class="line"><span class="number">1</span> : int sum (int a, int b) &#123;</span><br><span class="line">   return a+b;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如果想更改方法代码，需要用相同的方法名重写新修改的代码。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; int sum (int a, int b) &#123;</span><br><span class="line">   ...&gt; int c = a+b;</span><br><span class="line">   ...&gt; return c;</span><br><span class="line">   ...&gt; &#125;</span><br><span class="line">|  modified method sum(int,int)</span><br><span class="line"> </span><br><span class="line">jshell&gt; /list sum</span><br><span class="line"> </span><br><span class="line">   <span class="number">3</span> : int sum (int a, int b) &#123;</span><br><span class="line">       int c = a+b;</span><br><span class="line">       return c;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-618.png" alt="upload successful"></p><blockquote><p>请牢记方法重载规则。如果更改了方法参数数量或它们的数据类型，那么它将是一个新方法，并且将有两个方法在JShell中注册。</p></blockquote><h2 id="在JShell编辑器上编写代码"><a href="#在JShell编辑器上编写代码" class="headerlink" title="在JShell编辑器上编写代码"></a>在JShell编辑器上编写代码</h2><p>当只有几行代码时，JShell内联编辑器已经足够好了。但是当代码量开始变大时，我们可能需要一个文件编辑器来修改代码。</p><p>这里我们可以使用JShell编辑器。要启动编辑器，使用 <code>/edit</code>命令 + 要编辑的方法名。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-619.png" alt="upload successful"></p><p>在这里，根据需要更改方法代码并单击Accept按钮。修改后的代码将在Jshell中更新，我们将在提示中收到确认消息。我们可以随时更改代码，保存它，然后退出窗口。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-620.png" alt="upload successful"></p><h2 id="在外部编辑器中编辑代码"><a href="#在外部编辑器中编辑代码" class="headerlink" title="在外部编辑器中编辑代码"></a>在外部编辑器中编辑代码</h2><p>自带的编辑器可以满足大多数需要，但如果你喜欢在任何特定的编辑器上编码，你也可以使用它。</p><p>JShell允许轻松地配置任何外部编辑器来编辑代码片段。只需要获得我们想要使用的编辑器的完整路径，并在JShell中运行<code>/set editor</code>命令来配置编辑器。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/<span class="built_in">set</span> editor "C:\\Program Files\\Sublime Text <span class="number">3</span>\\sublime_text.exe"</span><br></pre></td></tr></table></figure><p>再次执行<code>/edit</code>命令。它将在sublime编辑器中打开代码。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-621.png" alt="upload successful"></p><p>自由编辑代码，并保存。</p><h2 id="将外部Java文件加载到REPL"><a href="#将外部Java文件加载到REPL" class="headerlink" title="将外部Java文件加载到REPL"></a>将外部Java文件加载到REPL</h2><p>很多时候，我们可能已经在任何java文件中编写了一些代码，希望将其执行到JShell中。</p><p>要在JShell中加载文件，使用<code>/open</code>命令。</p><p>假设我在<code>c://temp</code>文件夹中有一个<code>Demo.java</code>文件。它的内容是:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> i2 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> i3 = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">int</span> i4 = <span class="number">40</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在让我们把它加载到JShell。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/open c:\\temp\\demo.java</span><br></pre></td></tr></table></figure><p>可以看到代码被加载到了JShell。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-622.png" alt="upload successful"></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>以上就是在使用Java 9中JShell我们需要了解的内容。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java 9" scheme="https://www.sakuratears.top/tags/Java-9/"/>
    
  </entry>
  
  <entry>
    <title>Java 9 Stream API变更</title>
    <link href="https://www.sakuratears.top/blog/Java-9-Stream-API%E5%8F%98%E6%9B%B4.html"/>
    <id>https://www.sakuratears.top/blog/Java-9-Stream-API变更.html</id>
    <published>2020-04-13T02:12:00.000Z</published>
    <updated>2020-04-13T02:13:11.734Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java 9 Stream API新增了 <code>takeWhile</code> / <code>dropWhile</code>, <code>ofNullable</code> ,<code>iterate</code> 等方法。</p><p>我们通过例子来了解下它们。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="使用takeWhile-和dropWhile-方法对流进行限制"><a href="#使用takeWhile-和dropWhile-方法对流进行限制" class="headerlink" title="使用takeWhile()和dropWhile()方法对流进行限制"></a>使用takeWhile()和dropWhile()方法对流进行限制</h2><p>新的方法<code>takeWhile</code>和<code>dropWhile</code>允许我们根据谓词获取流的一部分。</p><p>这里的流可以是有序的，也可以是无序的，所以:</p><ol><li>在一个有序的流上，<code>takeWhile</code>返回从流中取出的与给定谓词匹配的元素的“最长前缀”，从流的开头开始。</li><li>在一个无序流上，<code>takeWhile</code>从流的开头开始返回匹配给定谓词(但不是全部)的流元素的子集。</li></ol><p><code>dropWhile</code>方法与<code>takeWhile</code>方法相反。</p><ol><li>在一个有序的流中，<code>dropWhile</code>返回与给定谓词匹配的“最长前缀”之后的剩余项。</li><li>在一个无序的流上，<code>dropWhile</code>在删除匹配给定谓词的元素子集后返回剩余的流元素。</li></ol><h2 id="takeWhile和dropWhile的例子"><a href="#takeWhile和dropWhile的例子" class="headerlink" title="takeWhile和dropWhile的例子"></a>takeWhile和dropWhile的例子</h2><p>在本例中，我们有一个从’a’到’i’的字符List。我想要在迭代中获取出现在’d’之前的所有字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; alphabets = List.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>, <span class="string">"g"</span>, <span class="string">"h"</span>, <span class="string">"i"</span>);</span><br><span class="line"> </span><br><span class="line">List&lt;String&gt; subset1 = alphabets</span><br><span class="line">        .stream()</span><br><span class="line">        .takeWhile(s -&gt; !s.equals(<span class="string">"d"</span>))</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line"> </span><br><span class="line">System.out.println(subset1);</span><br><span class="line"> </span><br><span class="line">Output:</span><br><span class="line"> </span><br><span class="line">[a, b, c]</span><br></pre></td></tr></table></figure><p>如前所述，<code>dropWhile</code>的作用与<code>takeWhile</code>方法相反，因此在上面的例子中，如果使用<code>dropWhile</code>方法，它将返回<code>takeWhile</code>谓词所留下的所有字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; alphabets = List.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>, <span class="string">"g"</span>, <span class="string">"h"</span>, <span class="string">"i"</span>);</span><br><span class="line"> </span><br><span class="line">List&lt;String&gt; subset2 = alphabets</span><br><span class="line">        .stream()</span><br><span class="line">        .dropWhile(s -&gt; !s.equals(<span class="string">"d"</span>))</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line"> </span><br><span class="line">System.out.println(subset2);</span><br><span class="line"> </span><br><span class="line">Output:</span><br><span class="line"> </span><br><span class="line">[d, e, f, g, h, i]</span><br></pre></td></tr></table></figure><h2 id="重载流的iterate方法"><a href="#重载流的iterate方法" class="headerlink" title="重载流的iterate方法"></a>重载流的iterate方法</h2><p><code>iterate()</code>方法，用于创建以单个元素(the seed)开始的流，并通过连续应用一元运算符生成后续元素，结果是一个无限的流。</p><p>要终止流，需要使用限制或其他一些短路函数，如<code>findFirst</code>或<code>findAny</code>。</p><p>Java 8中的<code>iterate</code>方法有这样的签名:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Stream <span class="title">iterate</span><span class="params">(<span class="keyword">final</span> T seed, <span class="keyword">final</span> UnaryOperator f)</span></span></span><br></pre></td></tr></table></figure><p>在Java 9中，新的重载版本的iterate将一个谓词作为第二个参数:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Stream <span class="title">iterate</span><span class="params">(T seed, Predicate hasNext, UnaryOperator next)</span></span></span><br></pre></td></tr></table></figure><p>让我们看看Java 8和Java 9之间<code>iterate</code>方法使用的不同之处。</p><p><em>iterate method in Java 8</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Stream.iterate(<span class="number">1</span>, i -&gt; i+<span class="number">1</span>)</span><br><span class="line">                            .limit(<span class="number">10</span>)</span><br><span class="line">                            .collect(Collectors.toList());</span><br><span class="line">         </span><br><span class="line">System.out.println(numbers);</span><br><span class="line"> </span><br><span class="line">Output:</span><br><span class="line"> </span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><p><em>iterate method in Java 9</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Stream.iterate(<span class="number">1</span>, i -&gt; i &lt;= <span class="number">10</span> ,i -&gt; i+<span class="number">1</span>)</span><br><span class="line">                                .collect(Collectors.toList());</span><br><span class="line"> </span><br><span class="line">System.out.println(numbers);</span><br><span class="line"> </span><br><span class="line">Output:</span><br><span class="line"> </span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><p>在上面的例子中，第一个流是使用带有限制的<code>iterate</code>的Java 8方式。第二个使用谓词作为第二个参数。</p><h2 id="新方法ofNullable"><a href="#新方法ofNullable" class="headerlink" title="新方法ofNullable()"></a>新方法ofNullable()</h2><p>在Java 8之前，流中不能有<code>null</code>值。它会导致<code>NullPointerException</code>。</p><p>在Java 9中，<code>ofNullable</code>方法允许我们创建一个单元素流，该流包装一个值(如果不是null)，或者是一个空流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.ofNullable(<span class="string">"123"</span>);</span><br><span class="line">System.out.println(stream.count());</span><br><span class="line"> </span><br><span class="line">stream = Stream.ofNullable(<span class="keyword">null</span>);</span><br><span class="line">System.out.println(stream.count());</span><br><span class="line"> </span><br><span class="line">Output:</span><br><span class="line"> </span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>这里，<code>count</code>方法返回流中非空元素的数量。</p><p>从技术上讲，<code>Stream.ofnullable()</code>与在流API上下文中使用<code>null</code>条件检查非常相似。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java 9" scheme="https://www.sakuratears.top/tags/Java-9/"/>
    
  </entry>
  
  <entry>
    <title>Java 9集合相关变更</title>
    <link href="https://www.sakuratears.top/blog/Java-9%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E5%8F%98%E6%9B%B4.html"/>
    <id>https://www.sakuratears.top/blog/Java-9集合相关变更.html</id>
    <published>2020-04-13T02:10:00.000Z</published>
    <updated>2020-04-13T02:11:30.393Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java 9 对于不可变集合可以使用工厂模式进行创建，我们来看一下，如何来创建不可变List、不可变Map、不可变Set。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="创建不可变List（Immutable-List）"><a href="#创建不可变List（Immutable-List）" class="headerlink" title="创建不可变List（Immutable List）"></a>创建不可变List（Immutable List）</h2><p>使用<code>List.of()</code>静态工厂方法创建不可变列表。它有以下不同的重载版本:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;E&gt; <span class="function">List&lt;E&gt;  <span class="title">of</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt;  <span class="title">of</span><span class="params">(E e1)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt;  <span class="title">of</span><span class="params">(E e1, E e2)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt;  <span class="title">of</span><span class="params">(E e1, E e2, E e3)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt;  <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt;  <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt;  <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5, E e6)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt;  <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5, E e6, E e7)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt;  <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt;  <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt;  <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10)</span></span></span><br><span class="line"><span class="function"><span class="comment">//varargs</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt;  <span class="title">of</span><span class="params">(E... elements)</span></span></span><br></pre></td></tr></table></figure><p>这些方法创建的<code>List</code>实例具有以下特征:</p><ol><li>这些<code>List</code>是不可变的。在这些<code>List</code>中不能添加、删除或替换元素。调用任何<code>mutator</code>方法(即<code>add</code>、<code>addAll</code>、<code>clear</code>、<code>remove</code>、<code>removeAll</code>、<code>replaceAll</code>)总是会引发<code>UnsupportedOperationException</code>。</li><li>它们不允许空元素。尝试添加空元素会导致<code>NullPointerException</code>。</li><li>如果所有元素都是可序列化的，则它们是可序列化的。</li><li>列表中元素的顺序与提供的参数或提供的数组中的元素的顺序相同。</li></ol><p>让我们来看几个使用不可变列表的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.howtodoinjava;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableCollections</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;String&gt; names = List.of(<span class="string">"Lokesh"</span>, <span class="string">"Amit"</span>, <span class="string">"John"</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//Preserve the elements order</span></span><br><span class="line">        System.out.println(names);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//names.add("Brian"); //UnsupportedOperationException occured</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//java.lang.NullPointerException</span></span><br><span class="line">        <span class="comment">//List&lt;String&gt; names2 = List.of("Lokesh", "Amit", "John", null); </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Output:</span><br><span class="line"> </span><br><span class="line">[Lokesh, Amit, John]</span><br></pre></td></tr></table></figure><h2 id="创建不可变Set（Immutable-Set）"><a href="#创建不可变Set（Immutable-Set）" class="headerlink" title="创建不可变Set（Immutable Set）"></a>创建不可变Set（Immutable Set）</h2><p><code>Set</code>的行为与<code>List</code>非常相似，只有很少的区别。如：</p><ol><li>设置不允许重复的元素。传递的任何重复元素都会导致<code>IllegalArgumentException</code>。</li><li>集合元素的迭代顺序是未指定的，可能会发生变化。</li></ol><p>所有的<code>Set</code>工厂方法都具有与<code>List</code>相同的签名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;E&gt; <span class="function">Set&lt;E&gt;   <span class="title">of</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt;   <span class="title">of</span><span class="params">(E e1)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt;   <span class="title">of</span><span class="params">(E e1, E e2)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt;   <span class="title">of</span><span class="params">(E e1, E e2, E e3)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt;   <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt;   <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt;   <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5, E e6)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt;   <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5, E e6, E e7)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt;   <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt;   <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt;   <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10)</span></span></span><br><span class="line"><span class="function"><span class="comment">//varargs</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt;   <span class="title">of</span><span class="params">(E... elements)</span></span></span><br></pre></td></tr></table></figure><p>我们来看几个不可变<code>Set</code>的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableCollections</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; names = Set.of(<span class="string">"Lokesh"</span>, <span class="string">"Amit"</span>, <span class="string">"John"</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//Elements order not fixed</span></span><br><span class="line">        System.out.println(names);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//names.add("Brian"); //UnsupportedOperationException occured</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//java.lang.NullPointerException</span></span><br><span class="line">        <span class="comment">//Set&lt;String&gt; names2 = Set.of("Lokesh", "Amit", "John", null); </span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//java.lang.IllegalArgumentException</span></span><br><span class="line">        <span class="comment">//Set&lt;String&gt; names3 = Set.of("Lokesh", "Amit", "John", "Amit"); </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建不可变Map（Immutable-Map）"><a href="#创建不可变Map（Immutable-Map）" class="headerlink" title="创建不可变Map（Immutable Map）"></a>创建不可变Map（Immutable Map）</h2><p><code>Map</code>工厂方法与<code>List</code>或<code>Set</code>重载工厂方法相同。唯一的区别是方法的签名采用交替的键和值作为参数。如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">Map&lt;K,V&gt;   <span class="title">of</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;K,V&gt; Map&lt;K,V&gt;   <span class="title">of</span><span class="params">(K k1, V v1)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;K,V&gt; Map&lt;K,V&gt;   <span class="title">of</span><span class="params">(K k1, V v1, K k2, V v2)</span></span></span><br><span class="line"><span class="function">...</span></span><br><span class="line"><span class="function">...</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;K,V&gt; Map&lt;K,V&gt;   <span class="title">ofEntries</span><span class="params">(Map.Entry&lt;? extends K,? extends V&gt;... entries)</span></span></span><br></pre></td></tr></table></figure><p>Java 9 还提供了一个特殊的方法来创建<code>Map</code>实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; Map.Entry&lt;K,V&gt; entry​(K k, V v)</span><br></pre></td></tr></table></figure><p>我们来看几个Java 9 创建不可变<code>Map</code>的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableCollections</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; names = Map.ofEntries(</span><br><span class="line">                Map.entry(<span class="string">"1"</span>, <span class="string">"Lokesh"</span>),</span><br><span class="line">                Map.entry(<span class="string">"2"</span>, <span class="string">"Amit"</span>),</span><br><span class="line">                Map.entry(<span class="string">"3"</span>, <span class="string">"Brian"</span>));</span><br><span class="line">         </span><br><span class="line">        System.out.println(names);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//UnsupportedOperationException</span></span><br><span class="line">        <span class="comment">//names.put("2", "Ravi");</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Output:</span><br><span class="line"> </span><br><span class="line">&#123;<span class="number">1</span>=Lokesh, <span class="number">2</span>=Amit, <span class="number">3</span>=Brian&#125;</span><br></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>可以看到在Java 9中创建不可变集合的新工厂方法非常易读且易于使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java 9" scheme="https://www.sakuratears.top/tags/Java-9/"/>
    
  </entry>
  
  <entry>
    <title>Java 9接口私有方法</title>
    <link href="https://www.sakuratears.top/blog/Java-9%E6%8E%A5%E5%8F%A3%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95.html"/>
    <id>https://www.sakuratears.top/blog/Java-9接口私有方法.html</id>
    <published>2020-04-13T02:08:00.000Z</published>
    <updated>2020-04-13T02:10:08.591Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从Java 9开始，我们可以在接口中包含私有方法。使用私有方法，现在在接口中也可以进行封装。</p><p>在本文中，我们将详细了解接口私有方法。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Java-7之前的接口"><a href="#Java-7之前的接口" class="headerlink" title="Java 7之前的接口"></a>Java 7之前的接口</h2><p>在Java 7和所有早期版本中，接口非常简单。它们只能包含公共抽象方法（public abstract method）。这些接口方法必须由选择实现接口的类来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClass</span> <span class="keyword">implements</span> <span class="title">CustomInterface</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        CustomInterface instance = <span class="keyword">new</span> CustomClass();</span><br><span class="line">        instance.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Output:</span><br><span class="line"> </span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure><h2 id="Java-8的接口"><a href="#Java-8的接口" class="headerlink" title="Java 8的接口"></a>Java 8的接口</h2><p>从Java 8开始，除了公共抽象方法之外，接口还可以拥有公共静态方法（public static method）和默认方法（public default method）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomInterface</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"default method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"static method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClass</span> <span class="keyword">implements</span> <span class="title">CustomInterface</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"abstract method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        CustomInterface instance = <span class="keyword">new</span> CustomClass();</span><br><span class="line">        instance.method1();</span><br><span class="line">        instance.method2();</span><br><span class="line">        CustomInterface.method3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Output:</span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> method</span><br><span class="line"><span class="keyword">default</span> method</span><br><span class="line"><span class="keyword">static</span> method</span><br></pre></td></tr></table></figure><blockquote><p>在以上接口方法声明中，访问修饰符“public”是可选的。添加它们只是为了提高可读性。</p></blockquote><h2 id="Java-9的接口"><a href="#Java-9的接口" class="headerlink" title="Java 9的接口"></a>Java 9的接口</h2><p>从Java 9开始，我们将能够在接口中添加私有方法（private methods）和私有静态方法（private static method）。</p><p>这些私有方法将提高接口内部的代码可重用性。</p><p>例如，如果两个默认方法需要共享代码，那么提供一个私有接口方法即可，但是不会将这个私有方法暴露给它的实现类。</p><p>在接口中使用私有方法有四个规则:</p><ol><li>私有接口方法不能是抽象的。</li><li>私有方法只能在接口内部使用。</li><li>私有静态方法可以在其他静态和非静态接口方法中使用。</li><li>私有非静态方法不能在私有静态方法中使用。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomInterface</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method4();  <span class="comment">//private method inside default method</span></span><br><span class="line">        method5();  <span class="comment">//static method inside other non-static method</span></span><br><span class="line">        System.out.println(<span class="string">"default method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method5(); <span class="comment">//static method inside other static method</span></span><br><span class="line">        System.out.println(<span class="string">"static method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"private method"</span>);</span><br><span class="line">    &#125; </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"private static method"</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClass</span> <span class="keyword">implements</span> <span class="title">CustomInterface</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"abstract method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        CustomInterface instance = <span class="keyword">new</span> CustomClass();</span><br><span class="line">        instance.method1();</span><br><span class="line">        instance.method2();</span><br><span class="line">        CustomInterface.method3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Output:</span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> method</span><br><span class="line"><span class="keyword">private</span> method</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> method</span><br><span class="line"><span class="keyword">default</span> method</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> method</span><br><span class="line"><span class="keyword">static</span> method</span><br></pre></td></tr></table></figure><h2 id="Java-9私有方法例子"><a href="#Java-9私有方法例子" class="headerlink" title="Java 9私有方法例子"></a>Java 9私有方法例子</h2><p>让我们看一个示例来理解私有接口方法的用法。</p><p>我们创建一个具有两个函数的计算器类。第一个函数将接受一些整数并在其中添加所有偶数。第二个函数将接受一些整数并在其中添加所有奇数。</p><p><em>CustomCalculator.java – Interface</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.IntPredicate;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomCalculator</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">addEvenNumbers</span><span class="params">(<span class="keyword">int</span>... nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> add(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">addOddNumbers</span><span class="params">(<span class="keyword">int</span>... nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> add(n -&gt; n % <span class="number">2</span> != <span class="number">0</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(IntPredicate predicate, <span class="keyword">int</span>... nums)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> IntStream.of(nums)</span><br><span class="line">                .filter(predicate)</span><br><span class="line">                .sum();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>Main.java – Class</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">implements</span> <span class="title">CustomCalculator</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CustomCalculator demo = <span class="keyword">new</span> Main();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">int</span> sumOfEvens = demo.addEvenNumbers(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>);</span><br><span class="line">        System.out.println(sumOfEvens);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">int</span> sumOfOdds = demo.addOddNumbers(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>);</span><br><span class="line">        System.out.println(sumOfOdds);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Output:</span><br><span class="line"> </span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>简而言之，Java 9私有接口方法可以是静态的，也可以是实例的。在这两种情况下，私有方法都不会被子接口或实现继承。它们主要用于提高接口中的代码可重用性，从而提高封装性。</p><p>让我们回顾一下Java 9中允许的所有方法类型。</p><table><thead><tr><th>METHOD TYPE</th><th style="text-align:center">SINCE WHEN</th></tr></thead><tbody><tr><td>public abstract</td><td style="text-align:center">Java 7</td></tr><tr><td>public default</td><td style="text-align:center">Java 8</td></tr><tr><td>public static</td><td style="text-align:center">Java 8</td></tr><tr><td>private</td><td style="text-align:center">Java 9</td></tr><tr><td>private static</td><td style="text-align:center">Java 9</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java 9" scheme="https://www.sakuratears.top/tags/Java-9/"/>
    
  </entry>
  
  <entry>
    <title>Java 9模块化</title>
    <link href="https://www.sakuratears.top/blog/Java-9%E6%A8%A1%E5%9D%97%E5%8C%96.html"/>
    <id>https://www.sakuratears.top/blog/Java-9模块化.html</id>
    <published>2020-04-13T01:58:00.000Z</published>
    <updated>2020-04-13T02:06:34.271Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>JPMS（Java Platform Module System） Java平台模块系统是Java 9的主要增强。它也被称为Jigsaw项目。在本文中，我们将简单学习模块，以及在将来开始编写模块化代码时，编程风格将如何变化。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="什么是模块？"><a href="#什么是模块？" class="headerlink" title="什么是模块？"></a>什么是模块？</h2><p>在任何编程语言中，模块(类似于包)都是包含代码的构件，其中包含描述模块及其与其他模块的关系的元数据。理想情况下，这些构件从编译时一直到运行时都是可识别的。任何应用程序通常都是多个模块的组合，这些模块一起工作以执行业务目标。</p><p>在应用程序架构方面，模块应该表示特定的业务功能。对于该功能，它应该是自给自足的，并且应该只公开使用模块功能的接口。为了完成它的任务，它可能依赖于其他模块，它应该显式地声明这些模块。</p><p>因此，简而言之，一个模块应该遵循三个核心原则：</p><ul><li><p>强大的封装（Strong Encapsulation）</p><p>  封装意味着隐藏实现细节，这些细节对于正确使用模块并不重要。其目的是封装的代码可以自由改变而不影响模块的用户。</p></li><li><p>稳定的抽象（Stable Abstraction）</p><p>  抽象有助于使用接口(即公共api)公开模块功能。任何时候，如果想要更改模块代码中的业务逻辑或实现，更改对模块用户都是透明的。</p></li><li><p>显式的依赖关系（Explicit dependencies）</p><p>  模块也可以依赖于其他模块。这些外部依赖必须是模块定义本身的一部分。模块之间的这些依赖关系通常用图表示。一旦您看到应用程序级别的图，您将更好地理解应用程序的体系结构。</p></li></ul><h2 id="Java-9模块化介绍"><a href="#Java-9模块化介绍" class="headerlink" title="Java 9模块化介绍"></a>Java 9模块化介绍</h2><p>在Java 9之前，我们有“包（packages）”来根据业务功能对相关类进行分组。除了包之外，还有“访问修饰符”来控制哪些是可见的，哪些是隐藏在其他类或包中的。到目前为止，它运行得很好。Java对封装和抽象提供了强大的支持。</p><p>但是，显式依赖关系是事情开始崩溃的地方。在java中，依赖项是用“import”语句声明的;但是它们是严格的“编译时”构造。一旦代码被编译，就没有明确的机制来声明它的运行时依赖关系。事实上，java运行时依赖项解析是一个非常有问题的领域，因此专门创建了一些工具来解决这个问题，例如gradle或maven。此外，很少有框架捆绑它们的完整运行时依赖项，例如Spring boot项目。</p><p>有了新的Java 9模块，我们将能够更好地编写结构良好的应用程序。这种增强分为两个方面:</p><ol><li>模块化JDK本身。</li><li>提供一个模块系统供其他应用程序使用。</li></ol><blockquote><p>Java 9模块系统有一个“java.base”模块。它被称为基模块。它是一个独立的模块，不依赖于任何其他模块。默认情况下，所有其他模块都依赖于“java.base”。</p></blockquote><p>在Java 9中，模块帮助我们封装包并管理依赖项。所以通常情况下,</p><ul><li>类是字段和方法的容器</li><li>包是类和接口的容器</li><li>模块是包的容器</li></ul><p>如果我们不知道要查找的具体内容，那么我们不会感觉到普通代码和模块化代码之间的任何主要区别。如：</p><ul><li>模块通常只是一个jar文件，在根目录下有一个<code>module-info.class</code>文件。</li><li>要使用模块，请将jar文件包含到<code>modulepath</code>中，而不是<code>classpath</code>中。添加到<code>classpath</code>中的模块jar文件是普通的jar文件，而<code>module-info.class</code>文件将被忽略。</li></ul><h2 id="如何编写模块化代码"><a href="#如何编写模块化代码" class="headerlink" title="如何编写模块化代码"></a>如何编写模块化代码</h2><p>在阅读了所有上述概念之后，让我们看看模块化代码是如何在现实中编写的。我使用Netbeans IDE是因为它对Java 9有很好的早期支持(到今天为止)。</p><h3 id="创建Java模块项目"><a href="#创建Java模块项目" class="headerlink" title="创建Java模块项目"></a>创建Java模块项目</h3><p>创建一个Java模块项目，命名为<code>JavaAppOne</code>。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-610.jpg" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-611.jpg" alt="upload successful"></p><h3 id="创建Java模块"><a href="#创建Java模块" class="headerlink" title="创建Java模块"></a>创建Java模块</h3><p>我们向这个项目中添加两个模块，如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-612.jpg" alt="upload successful"></p><p>我向项目中添加了<code>helloworld</code>和<code>test</code> 模块，它们的结构如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-613.jpg" alt="upload successful"></p><p>相关代码如下：</p><p><code>/helloworld/module-info.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> helloworld &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HelloWorldApp.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.howtodoinjava.demo;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello from HelloWorldApp"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>/test/module-info.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> test &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TestApp.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//some code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到目前为止，模块是独立的。现在假设，我们想在TestApp类中使用<code>HelloWorldApp.sayHello()</code>方法。如果我们尝试在不导入模块的情况下使用该类，我们将得到编译时错误“package com.howtodoinjava.demo is not visible”。</p><h3 id="导入模块信息"><a href="#导入模块信息" class="headerlink" title="导入模块信息"></a>导入模块信息</h3><p>为了能够导入<code>HelloWorldApp</code>，我们必须首先从<code>helloworld</code>模块导出“com.howtodoinjava.demo”包，然后在<code>test</code>模块中包含<code>helloworld</code>模块。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> helloworld &#123;</span><br><span class="line">    <span class="keyword">exports</span> com.howtodoinjava.demo;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">module</span> test &#123;</span><br><span class="line">    <span class="keyword">requires</span> helloworld;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，<code>require</code>关键字表示依赖项，<code>exports</code>关键字标识可以导出到其他模块的包。只有当一个包被显式导出时，才能从其他模块访问它。模块内未导出的包在默认情况下无法从其他模块访问。</p><p>现在我们可以在<code>TestApp</code>类中使用<code>HelloWorldApp</code>类了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.howtodoinjava.demo.HelloWorldApp;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloWorldApp.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Output:</span><br><span class="line"> </span><br><span class="line">Hello from HelloWorldApp</span><br></pre></td></tr></table></figure><p>模块关系图如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-614.jpg" alt="upload successful"></p><blockquote><p>从Java 9开始，<code>public</code>意味着只对该模块内的所有其他包公开。只有在导出包含公共类型的包时，其他模块才能使用它。</p></blockquote><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>模块化应用程序有许多优点，当我们遇到具有非模块化代码库的应用程序时，我们会更加欣赏这些优点。模块化并不是什么灵丹妙药，但它是一种体系结构原则，如果应用得当，可以在很大程度上避免项目依赖混乱问题。</p><p>有了JPMS, Java向成为模块化语言迈出了一大步。这个决定是对是错，只有时间能证明。第三方库和框架如何适应和使用模块系统将会很有趣。以及它将如何影响开发工作，由我们来见证。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java 9" scheme="https://www.sakuratears.top/tags/Java-9/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV的使用（二） - 人脸的识别与训练</title>
    <link href="https://www.sakuratears.top/blog/OpenCV%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89-%E4%BA%BA%E8%84%B8%E7%9A%84%E8%AF%86%E5%88%AB%E4%B8%8E%E8%AE%AD%E7%BB%83.html"/>
    <id>https://www.sakuratears.top/blog/OpenCV的使用（二）-人脸的识别与训练.html</id>
    <published>2020-01-05T09:38:00.000Z</published>
    <updated>2020-01-05T09:42:54.924Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上篇文章我们讲到了OpenCV的安装和简单使用，<a href="https://www.sakuratears.top/blog/OpenCV%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89.html#more">OpenCV简介及使用（一）</a>。</p><p>这篇文章我们来看下如何使用OpenCV进行图像的识别与训练。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>由于OpenCV自带人脸识别及检测功能，我们来看下如何使用OpenCV来分辨人脸。</p><p>如果要进行人脸识别及训练，需要用到人脸灰度图，且有一定的数量，图片宽高需要保持一致。</p><p>上篇文章已经说到如何寻找并裁剪人脸，然后我们将它置灰即可，需要调用<code>org.bytedeco.opencv.global.opencv_imgproc.cvtColor</code>方法，如代码所示<code>cvtColor(image,image,COLOR_BGR2GRAY)</code>。</p><p>其中第一个image是原Mat图，第二个image是生成的Mat图，两个设置成一样则生成的灰度图会覆盖原图，<code>COLOR_BGR2GRAY</code>表示生成的图片颜色。</p><p>则生成灰度图代码大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Mat <span class="title">detectFace</span><span class="params">(String sourceImage, String targetImage,<span class="keyword">int</span> width,<span class="keyword">int</span> height)</span></span>&#123;</span><br><span class="line">    CascadeClassifier faceDetector = <span class="keyword">new</span> CascadeClassifier(CASCADE_FACE_FILENAME);</span><br><span class="line">    <span class="keyword">if</span>(faceDetector.empty())&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"处理文件时发生异常！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Mat image = imread(sourceImage);</span><br><span class="line">    RectVector rectVector = <span class="keyword">new</span> RectVector();</span><br><span class="line">    <span class="comment">// 进行人脸检测</span></span><br><span class="line">    faceDetector.detectMultiScale(image, rectVector);</span><br><span class="line"></span><br><span class="line">    Rect[] rects = rectVector.get();</span><br><span class="line">    <span class="keyword">if</span>(rects.length &lt;=<span class="number">0</span> )&#123;</span><br><span class="line">        log.error(<span class="string">"原图片上未检测到人脸：&#123;&#125;"</span>,sourceImage);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"原图片上未检测到人脸！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(rects.length &gt;<span class="number">1</span>)&#123;</span><br><span class="line">        log.error(<span class="string">"原图片上检测到多个人脸：&#123;&#125;"</span>,sourceImage);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"原图片上检测到多个人脸！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Rect rect = rects[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//人脸裁剪</span></span><br><span class="line">    image = <span class="keyword">new</span> Mat(image,rect);</span><br><span class="line">    <span class="comment">//将图片置灰</span></span><br><span class="line">    cvtColor(image,image,COLOR_BGR2GRAY);</span><br><span class="line">    <span class="comment">//调整图片大小(如果传入宽高为0，就取rect图片宽高)</span></span><br><span class="line">    <span class="keyword">if</span>(width==<span class="number">0</span>||height==<span class="number">0</span>)&#123;</span><br><span class="line">        width = rect.width();</span><br><span class="line">        height = rect.height();</span><br><span class="line">    &#125;</span><br><span class="line">    resize(image,image,<span class="keyword">new</span> Size(width,height));</span><br><span class="line">    <span class="comment">//图片落地（灰色图也可以不落地）</span></span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isNotBlank(targetImage))&#123;</span><br><span class="line">        imwrite(targetImage, image);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返会Mat图</span></span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法里主要使用了OpenCV中<code>org.bytedeco.opencv.global.opencv_imgcodecs</code>和<code>org.bytedeco.opencv.global.opencv_imgproc</code>两个包中的方法。</p><p>然后我们开始进行人脸识别训练。</p><p>人脸识别器（FaceRecognizer）这个类目前包含三种人脸识别方法：基于PCA变换的人脸识别(EigenFaceRecognizer)、基于Fisher变换的人脸识别(FisherFaceRecognizer)、基于局部二值模式的人脸识别(LBPHFaceRecognizer)。</p><p>这儿我们以基于PCA变换的人脸识别(EigenFaceRecognizer)来进行举例。</p><p>我们想识别两张不同的人脸，需要首先准备若干样本，这儿我准备了胡歌和刘亦菲的照片各10张来作为训练样本（想要更好的训练效果，训练图片至少要在数百张左右），如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-606.jpg" alt="upload successful"></p><p>其中胡歌的图片以0-开头，刘亦菲的图片以1-开头，对测试图片进行测试时，识别器的label（识别标签）返回0认为属于胡歌的照片，1认为属于刘亦菲的图片，-1认为不属于他们的照片。</p><p>训练时需要使用灰度图，我们使用上面的方法处理下生成宽高相等的灰度图。</p><p>其相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">faceRecognize</span><span class="params">(String baseImagePath,String testImage)</span></span>&#123;</span><br><span class="line">    <span class="comment">//存放样本的地址</span></span><br><span class="line">    File dirFile = <span class="keyword">new</span> File(baseImagePath);</span><br><span class="line">    <span class="keyword">if</span>(!dirFile.isDirectory())&#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"请指定样本文件目录！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//过滤指定图片文件</span></span><br><span class="line">    FilenameFilter imgFilter = (dir,name)-&gt;&#123;</span><br><span class="line">        name = name.toLowerCase();</span><br><span class="line">        <span class="keyword">return</span> name.endsWith(<span class="string">".jpg"</span>) || name.endsWith(<span class="string">".pgm"</span>) || name.endsWith(<span class="string">".png"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    File[] files = dirFile.listFiles(imgFilter);</span><br><span class="line">    <span class="keyword">if</span>(files == <span class="keyword">null</span> || files.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"目录下没有符合要求的图片文件！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//生成的训练样本（灰色图）临时文件存放在train目录下</span></span><br><span class="line">    String trainFileBasePath = baseImagePath + <span class="string">"/train"</span>;</span><br><span class="line">    File trainFileBase = <span class="keyword">new</span> File(trainFileBasePath);</span><br><span class="line">    <span class="keyword">if</span>(!trainFileBase.exists())&#123;</span><br><span class="line">        trainFileBase.mkdir();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始训练逻辑</span></span><br><span class="line">    <span class="comment">//样本灰色图Mat</span></span><br><span class="line">    MatVector matVector = <span class="keyword">new</span> MatVector(files.length);</span><br><span class="line">    <span class="comment">//样本标签</span></span><br><span class="line">    Mat labels = <span class="keyword">new</span> Mat(files.length, <span class="number">1</span>, CV_32SC1);</span><br><span class="line">    IntBuffer intBuffer = labels.createBuffer();</span><br><span class="line">    <span class="keyword">int</span> baseWidth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> baseHeight = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; files.length; i++) &#123;</span><br><span class="line">        <span class="comment">//灰色图地址</span></span><br><span class="line">        String tempImage = trainFileBasePath+<span class="string">"/"</span>+files[i].getName();</span><br><span class="line">        Mat mat = detectFace(files[i].getPath(),tempImage,baseWidth,baseHeight);</span><br><span class="line">        baseWidth = mat.rows();</span><br><span class="line">        baseHeight= mat.cols();</span><br><span class="line">        matVector.put(i,mat);</span><br><span class="line">        <span class="keyword">int</span> label = Integer.parseInt(files[i].getName().split(<span class="string">"-"</span>)[<span class="number">0</span>]);</span><br><span class="line">        intBuffer.put(i,label);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//人脸识别训练（训练要求训练图片和测试图片必须为灰度图，且大小一致）</span></span><br><span class="line">    <span class="comment">// num_components 主成分分析中保留的成分数(即特征面) 0为全部保留</span></span><br><span class="line">    <span class="comment">// threshold 置信度阈值，待识别图片如果大于这个阈值的话label就会返回-1</span></span><br><span class="line">    <span class="comment">// 可以不设置，会返回最低的置信度图片对于的label</span></span><br><span class="line">    FaceRecognizer faceRecognizer = EigenFaceRecognizer.create();</span><br><span class="line">    faceRecognizer.train(matVector,labels);</span><br><span class="line">    <span class="comment">//保存训练xml</span></span><br><span class="line">    faceRecognizer.save(baseImagePath+<span class="string">"/face.xml"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理待识别的图片</span></span><br><span class="line">    String testTempImage = baseImagePath + <span class="string">"/test"</span>;</span><br><span class="line">    File file = <span class="keyword">new</span> File(testTempImage);</span><br><span class="line">    <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">        file.mkdir();</span><br><span class="line">    &#125;</span><br><span class="line">    Mat tempMat = detectFace(testImage,testTempImage+<span class="string">"/temp.jpg"</span>,baseWidth,baseHeight);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//识别后结果标签，如果没有识别到，会返回-1</span></span><br><span class="line">    IntPointer label = <span class="keyword">new</span> IntPointer(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//识别置信度，越低越好，图片完全一样为0.0</span></span><br><span class="line">    DoublePointer confidence = <span class="keyword">new</span> DoublePointer(<span class="number">1</span>);</span><br><span class="line">    faceRecognizer.predict(tempMat, label, confidence);</span><br><span class="line">    <span class="keyword">int</span> predictedLabel = label.get();</span><br><span class="line">    System.out.println(<span class="string">"Predicted label: "</span> + predictedLabel);</span><br><span class="line">    System.out.println(confidence.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其关键部分代码为<code>faceRecognizer.train(matVector,labels)</code>，matVector接受生成的灰度图，labels为图片所属的标签，我们可以通过<code>faceRecognizer.save(baseImagePath+”/face.xml”)</code>保存训练后的xml。</p><p>在训练之前，通过灰度图处理（detectFace方法），如果训练图片选择落地的话，会在文件夹下生成train文件夹，里面就是存放宽高相等的待训练的样本。如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-607.jpg" alt="upload successful"></p><p>我们取一张测试照片test.jpg，来进行测试，如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-608.jpg" alt="upload successful"></p><p>其测试的主要代码就是上面代码的这部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理待识别的图片</span></span><br><span class="line">String testTempImage = baseImagePath + <span class="string">"/test"</span>;</span><br><span class="line">File file = <span class="keyword">new</span> File(testTempImage);</span><br><span class="line"><span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">    file.mkdir();</span><br><span class="line">&#125;</span><br><span class="line">Mat tempMat = detectFace(testImage,testTempImage+<span class="string">"/temp.jpg"</span>,baseWidth,baseHeight);</span><br><span class="line"></span><br><span class="line"><span class="comment">//识别后结果标签，如果没有识别到，会返回-1</span></span><br><span class="line">IntPointer label = <span class="keyword">new</span> IntPointer(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//识别置信度，越低越好，图片完全一样为0.0</span></span><br><span class="line">DoublePointer confidence = <span class="keyword">new</span> DoublePointer(<span class="number">1</span>);</span><br><span class="line">faceRecognizer.predict(tempMat, label, confidence);</span><br><span class="line"><span class="keyword">int</span> predictedLabel = label.get();</span><br><span class="line">System.out.println(<span class="string">"Predicted label: "</span> + predictedLabel);</span><br><span class="line">System.out.println(confidence.get());</span><br></pre></td></tr></table></figure><p>识别时也是需要使用灰度图进行识别，调用<code>faceRecognizer.predict(tempMat, label, confidence)</code>来对测试图片进行测试，同时也会返回置信度。</p><p>我们构建Main运行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//人脸识别训练</span></span><br><span class="line">    faceRecognize(<span class="string">"C:\\Users\\DELL-3020\\Desktop\\face\\base"</span>,<span class="string">"C:\\Users\\DELL-3020\\Desktop\\face\\test.jpg"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后可以看到输出结果：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-609.jpg" alt="upload successful"></p><p>可以看到符合我们的预期。</p><p>这儿只使用了少量训练样本来展示图像训练的方法，其实在进行识别训练时，样本越大精确度越高。</p><p>我们之前用到的<code>haarcascade_frontalface_alt.xml</code>，就是使用大量人脸样本进行训练生成的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>今天我们使用了OpenCV自带的人脸识别器（FaceRecognizer）来进行了人脸的识别与训练，后续我们会在了解下OpenCV在图像应用方面的一些其它功能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="OpenCV" scheme="https://www.sakuratears.top/tags/OpenCV/"/>
    
      <category term="人脸识别" scheme="https://www.sakuratears.top/tags/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>Java synchronized锁机制</title>
    <link href="https://www.sakuratears.top/blog/Java-synchronized%E9%94%81%E6%9C%BA%E5%88%B6.html"/>
    <id>https://www.sakuratears.top/blog/Java-synchronized锁机制.html</id>
    <published>2019-12-15T14:10:00.000Z</published>
    <updated>2019-12-15T14:28:08.054Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>聊到Java中的锁（<code>synchronized</code>关键字），我们需要了解重量锁、轻量锁（自旋锁）、偏向锁、锁消除、锁膨胀等一些知识。</p><p>下面我们来具体看一下。</p><h1 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h1><p>JDK中对<code>synchronized</code>进行了许多优化。它们如下：</p><h2 id="优化一"><a href="#优化一" class="headerlink" title="优化一"></a>优化一</h2><p>A: 重量级锁中的阻塞(挂起线程/恢复线程): 需要转入内核态中完成，有很大的性能影响。</p><p>B: 锁大多数情况都是在很短的时间执行完成。</p><p>解决方案: 引入轻量锁(通过自旋来完成锁竞争)。</p><h2 id="优化二"><a href="#优化二" class="headerlink" title="优化二"></a>优化二</h2><p>A: 轻量级锁中的自旋: 占用CPU时间，增加CPU的消耗(因此在多核处理器上优势更明显)。</p><p>B: 如果某锁始终是被长期占用，导致自旋如果没有把握好，白白浪费CPU资源。</p><p>解决方案: JDK5中引入默认自旋次数为10(用户可以通过-XX:PreBlockSpin进行修改)， JDK6中更是引入了自适应自旋（简单来说如果自旋成功概率高，就会允许等待更长的时间（如100次自旋），如果失败率很高，那很有可能就不做自旋，直接升级为重量级锁，实际场景中，HotSpot认为最佳时间应该是一个线程上下文切换的时间，而是否自旋以及自旋次数更是与对CPUs的负载、CPUs是否处于节电模式等息息相关的)。</p><h2 id="优化三"><a href="#优化三" class="headerlink" title="优化三"></a>优化三</h2><p>A: 无论是轻量级锁还是重量级锁: 在进入与退出时都要通过CAS修改对象头中的Mark Word来进行加锁与释放锁。</p><p>B: 在一些情况下总是同一线程多次获得锁，此时第二次再重新做CAS修改对象头中的Mark Word这样的操作，有些多余。</p><p>解决方案: JDK6引入偏向锁(首次需要通过CAS修改对象头中的Mark Word，之后该线程再进入只需要比较对象头中的Mark Word的Thread ID是否与当前的一致，如果一致说明已经取得锁，就不用再CAS了)。</p><h2 id="优化四"><a href="#优化四" class="headerlink" title="优化四"></a>优化四</h2><p>A: 项目中代码块中可能绝大情况下都是多线程访问。</p><p>B: 每次都是先偏向锁然后过渡到轻量锁，而偏向锁能用到的又很少。</p><p>解决方案: 可以使用-XX:-UseBiasedLocking=false禁用偏向锁。</p><h2 id="优化五"><a href="#优化五" class="headerlink" title="优化五"></a>优化五</h2><p>A: 代码中JDK原生或其他的工具方法中带有大量的加锁。</p><p>B: 实际过程中，很有可能很多加锁是无效的(如局部变量作为锁，由于每次都是新对象新锁，所以没有意义)。</p><p>解决方法: 引入锁削除(虚拟机即时编译器(JIT)运行时，依据逃逸分析的数据检测到不可能存在竞争的锁，就自动将该锁消除)。</p><h2 id="优化六"><a href="#优化六" class="headerlink" title="优化六"></a>优化六</h2><p>A: 为了让锁颗粒度更小，或者原生方法中带有锁，很有可能在一个频繁执行(如循环)中对同一对象加锁。</p><p>B: 由于在频繁的执行中，反复的加锁和解锁，这种频繁的锁竞争带来很大的性能损耗。</p><p>解决方法: 引入锁膨胀(会自动将锁的范围拓展到操作序列(如循环)外, 可以理解为将一些反复的锁合为一个锁放在它们外部)。</p><h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><p>上面说到的优化是十分笼统的，现在我们来分析一下JDK源码中锁实现的基本原理，进一步对Java的锁机制有更深入的了解。</p><h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><p>在HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p><p>其中对象头（Header）包括两部分信息：</p><ul><li><strong>Mark Word</strong>：用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等。</li><li><strong>Klass Pointer</strong>：对象指向它的类的元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li><li><strong>ArrayLength</strong>：用于记录数组长度的数据（如果当前对象不是数组，就没有这一部分数据）。</li></ul><p>其中我们关注的就是对象头中的<code>Mark Word</code>，其中存储着关于对象锁的一些信息。</p><p>对于处于不同状态的对象（无锁、轻量锁、偏向锁、重量锁），其Mark Word里的内容是不一样的，如下图分别是32位HotSpot虚拟机和64位HotSpot虚拟机对象头的存储结构：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-595.jpg" alt="upload successful"></p><p>我们来看下JVM源码，来证实下上图所说的内容。</p><p>我们可以通过 OpenJDK网站 <a href="http://hg.openjdk.java.net/" rel="external nofollow noopener noreferrer" target="_blank">OpenJDK Project</a>来下载JDK源码，我这儿下载了JDK10 源码，那么我们可以在<code>\jdk10-b09e56145e11\src\hotspot\share\oops</code>文件夹下找到<code>klass.hpp</code>、<code>klass.cpp</code>、<code>markOop.cpp</code>、<code>markOop.hpp</code>等文件。</p><blockquote><p>PS: hotspot文件夹即为JVM源码文件夹。</p></blockquote><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-596.jpg" alt="upload successful"></p><p>无论是32位的JVM还是64位的JVM，均为 1bit偏向锁+2bit锁标志位。对于Java中的<code>synchronized</code>关键字，就使用了Mark Word来标识对象加锁状态。</p><h2 id="synchronized实现原理"><a href="#synchronized实现原理" class="headerlink" title="synchronized实现原理"></a>synchronized实现原理</h2><p>我们刚才上面提到了锁优化的一些内容，对于<code>synchronized</code>关键字，JVM到底进行了怎样的处理呢？</p><p>我们通过JVM <code>synchronized</code> 的源码来大致了解下。</p><p>我们先写一个简单类，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个是在代码块上加锁，另一个是对方法加锁。</p><p>对于这两种的同步，JVM都是基于监视器对象（Monitor）的进入和退出来实现的，但是两者的实现细节有所不同。</p><p>代码块同步是使用monitorenter和monitorexit指令实现的，而方法同步是使用字节码同步指令ACC_SYNCHRONIZED来实现的。</p><blockquote><p>字节码同步指令ACC_SYNCHRONIZED原理：JVM通过使用Monitor来支持同步，JVM可以从方法常量池的方法表结构中的ACC_SYNCHRONIZED访问标志来得知一个方法是否声明为同步方法，当方法调用时，调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程就要求先成功持有Monitor，然后才能执行方法，最后当方法完成（无论是正常完成还是非正常完成）时释放管程，在方法执行期间，执行线程持有了Monitor，其他任何线程都无法在获取到同一个Monitor。</p></blockquote><p>我们将上述Test.java文件编译为Test.class 文件，然后反编译成字节码来看一下。</p><p>如下指令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -verbose -c E:\WorkSpace\helputils\target\test-classes\com\zwt\helputils\Test.class</span><br></pre></td></tr></table></figure><p>如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-597.jpg" alt="upload successful"></p><p>可以看到对于代码块同步，使用了monitorenter和monitorexit，而我们看到有两个monitorexit是因为保证出现异常monitor也能正确退出。对于方法同步，该方法有ACC_SYNCHRONIZED访问标志来保证同步性。</p><p>下面我们来分析下Synchronization部分的JVM源码，我们在<code>jdk10-b09e56145e11\src\hotspot\share\interpreter\interpreterRuntime.cpp</code>文件中可以找到monitorenter和monitorexit的相关方法，如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-598.jpg" alt="upload successful"></p><p>如果有启用偏向锁，则会使用<code>ObjectSynchronizer::fast_enter</code>来尝试获得偏向锁，否则会使用<code>ObjectSynchronizer::slow_enter</code>来尝试获得轻量锁。</p><p>使用<code>ObjectSynchronizer::slow_exit</code>来释放锁。</p><h3 id="偏向锁的获取"><a href="#偏向锁的获取" class="headerlink" title="偏向锁的获取"></a>偏向锁的获取</h3><p>我们来看下<code>ObjectSynchronizer::fast_enter</code>方法，它在<code>jdk10-b09e56145e11\src\hotspot\share\runtime\synchronizer.cpp</code>文件里，如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-599.jpg" alt="upload successful"></p><p>方法<code>revoke_and_rebias</code>为偏向锁的获取和撤销相关代码，它在<code>jdk10-b09e56145e11\src\hotspot\share\runtime\biasedLocking.cpp</code>文件里，相关代码量较多，这儿就不过多展示了。</p><p>偏向锁获取的相关逻辑如下：</p><ol><li>通过markOop mark = obj-&gt;mark()获取对象的markOop数据mark，即对象头的Mark Word；</li><li>判断mark是否为可偏向状态，即mark的偏向锁标志位为 1，锁标志位为 01；</li><li>判断mark中JavaThread的状态：如果为空，则进入4；如果指向当前线程，则执行同步代码块；如果指向其它线程，进入5；</li><li>通过CAS原子指令设置mark中JavaThread为当前线程ID，如果执行CAS成功，则执行同步代码块，否则进入5；</li><li>如果执行CAS失败，表示当前存在多个线程竞争锁，当达到全局安全点（safepoint），获得偏向锁的线程被挂起，撤销偏向锁，并升级为轻量级，升级完成后被阻塞在安全点的线程继续执行同步代码块；</li></ol><h3 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h3><p>偏向锁的撤销必须等待全局安全点（没有正在执行的字节码）时执行。<code>revoke_at_safepoint</code>是偏向锁撤销相关代码，它也在它在<code>jdk10-b09e56145e11\src\hotspot\share\runtime\biasedLocking.cpp</code>文件里。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-600.jpg" alt="upload successful"></p><p>偏向锁的撤销逻辑和偏向获取和撤销次数有关系，会走不同的逻辑，其相关逻辑如下：</p><ol><li>偏向锁的撤销动作必须等待全局安全点；</li><li>暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态；</li><li>撤销偏向锁，恢复到无锁（标志位为 01）或轻量级锁（标志位为 00）的状态；</li></ol><h3 id="轻量锁的获取"><a href="#轻量锁的获取" class="headerlink" title="轻量锁的获取"></a>轻量锁的获取</h3><p>当偏向锁处于关闭状态，或者多个线程竞争导致偏向锁升级为轻量锁，程序或尝试获取轻量锁。</p><p>其代码入口为<code>jdk10-b09e56145e11\src\hotspot\share\runtime\synchronizer.cpp</code>文件里的<code>ObjectSynchronizer::slow_enter</code>方法。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-601.jpg" alt="upload successful"></p><p>轻量锁的获取相关逻辑如下：</p><ol><li>markOop mark = obj-&gt;mark()方法获取对象的markOop数据mark；</li><li>mark-&gt;is_neutral()方法判断mark是否为无锁状态：mark的偏向锁标志位为 0，锁标志位为 01；</li><li>如果mark处于无锁状态，则进入4，否则执行6；</li><li>把mark保存到BasicLock对象的_displaced_header字段；</li><li>通过CAS尝试将Mark Word更新为指向BasicLock对象的指针，如果更新成功，表示竞争到锁，则执行同步代码，否则执行6；</li><li>如果当前mark处于加锁状态，且mark中的ptr指针指向当前线程的栈帧，则执行同步代码，否则说明有多个线程竞争轻量级锁，轻量级锁需要膨胀升级为重量级锁；</li></ol><p>假设线程A和B同时执行到临界区if (mark-&gt;is_neutral())：</p><ol><li>线程AB都把Mark Word复制到各自的_displaced_header字段，该数据保存在线程的栈帧上，是线程私有的；</li><li>Atomic::cmpxchg_ptr原子操作保证只有一个线程可以把指向栈帧的指针复制到Mark Word，假设此时线程A执行成功，并返回继续执行同步代码块；</li><li>线程B执行失败，退出临界区，通过ObjectSynchronizer::inflate方法开始膨胀锁；</li></ol><h3 id="轻量锁的释放"><a href="#轻量锁的释放" class="headerlink" title="轻量锁的释放"></a>轻量锁的释放</h3><p>轻量锁的释放入口为<code>jdk10-b09e56145e11\src\hotspot\share\runtime\synchronizer.cpp</code>文件里的<code>ObjectSynchronizer::slow_exit</code>方法，它最终调用的为该文件里的<code>ObjectSynchronizer::fast_exit</code>方法。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-602.jpg" alt="upload successful"></p><p>轻量锁的释放相关逻辑如下：</p><ol><li>确保处于偏向锁状态时不会执行这段逻辑；</li><li>取出在获取轻量级锁时保存在BasicLock对象的mark数据dhw；</li><li>通过CAS尝试把dhw替换到当前的Mark Word，如果CAS成功，说明成功的释放了锁，否则执行4；</li><li>如果CAS失败，说明有其它线程在尝试获取该锁，这时需要将该锁升级为重量级锁，并释放；</li></ol><h3 id="重量锁"><a href="#重量锁" class="headerlink" title="重量锁"></a>重量锁</h3><p>重量级锁通过对象内部的monitor实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。</p><h4 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h4><p>一般情况下重量级锁都是由轻量锁膨胀来的，其方法实现为<code>jdk10-b09e56145e11\src\hotspot\share\runtime\synchronizer.cpp</code>文件的<code>ObjectSynchronizer::inflate</code>方法。</p><p>如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-603.jpg" alt="upload successful"></p><p>膨胀过程的相关逻辑如下：</p><ol><li>整个膨胀过程在自旋下完成；</li><li>mark-&gt;has_monitor()方法判断当前是否为重量级锁，即Mark Word的锁标识位为 10，如果当前状态为重量级锁，执行3，否则执行4；</li><li>mark-&gt;monitor()方法获取指向ObjectMonitor的指针，并返回，说明膨胀过程已经完成；</li><li>如果当前锁处于膨胀中，说明该锁正在被其它线程执行膨胀操作，则当前线程就进行自旋等待锁膨胀完成，这里需要注意一点，虽然是自旋操作，但不会一直占用cpu资源，每隔一段时间会通过os::NakedYield方法放弃cpu资源，或通过park方法挂起；如果其他线程完成锁的膨胀操作，则退出自旋并返回；</li><li>如果当前是轻量级锁状态，即锁标识位为 00，膨胀过程如下：<ul><li>通过omAlloc方法，获取一个可用的ObjectMonitor monitor，并重置monitor数据；</li><li>通过CAS尝试将Mark Word设置为markOopDesc:INFLATING，标识当前锁正在膨胀中，如果CAS失败，说明同一时刻其它线程已经将Mark Word设置为markOopDesc:INFLATING，当前线程进行自旋等待膨胀完成；</li><li>如果CAS成功，设置monitor的各个字段：_header、_owner和_object等，并返回；</li></ul></li><li>如果是无锁，重置monitor值；</li></ol><h4 id="重量锁的获取与释放"><a href="#重量锁的获取与释放" class="headerlink" title="重量锁的获取与释放"></a>重量锁的获取与释放</h4><p>重量锁的获取包括锁的竞争、等待锁的释放与尝试获取步骤。</p><p>当锁膨胀完成并返回对应的monitor时，并不表示该线程竞争到了锁，真正的锁竞争发生在<code>jdk10-b09e56145e11\src\hotspot\share\runtime\objectMonitor.cpp</code>文件里的<code>ObjectMonitor::enter</code>方法里。</p><p>monitor竞争失败的线程，通过自旋执行<code>ObjectMonitor::EnterI</code>方法等待锁的释放。当该线程被唤醒时，会从挂起的点继续执行，通过<code>ObjectMonitor::TryLock</code>尝试获取锁。</p><p>当某个持有锁的线程执行完同步代码块时，会进行锁的释放，给其它线程机会执行同步代码，在HotSpot中，通过退出monitor的方式实现锁的释放，并通知被阻塞的线程，具体实现位于<code>ObjectMonitor::exit</code>方法中。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-604.jpg" alt="upload successful"></p><p>其具体逻辑涉及到大量C++代码，这儿就不在对代码进行过多分析。</p><p>这儿总结下重量锁的竞争逻辑大致如下（<code>ObjectMonitor::enter</code>方法相关逻辑）：</p><ol><li>通过CAS尝试把monitor的_owner字段设置为当前线程；</li><li>如果设置之前的_owner指向当前线程，说明当前线程再次进入monitor，即重入锁，执行_recursions ++ ，记录重入的次数；</li><li>如果之前的_owner指向的地址在当前线程中，这种描述有点拗口，换一种说法：之前_owner指向的BasicLock在当前线程栈上，说明当前线程是第一次进入该monitor，设置_recursions为1，_owner为当前线程，该线程成功获得锁并返回；</li><li>如果获取锁失败，则等待锁的释放；</li></ol><p>等待锁释放的逻辑大致如下（<code>ObjectMonitor::EnterI</code>方法相关逻辑）：</p><ol><li>当前线程被封装成ObjectWaiter对象node，状态设置成ObjectWaiter::TS_CXQ；</li><li>在for循环中，通过CAS把node节点push到_cxq列表中，同一时刻可能有多个线程把自己的node节点push到_cxq列表中；</li><li>node节点push到_cxq列表之后，通过自旋尝试获取锁，如果还是没有获取到锁，则通过park将当前线程挂起，等待被唤醒；</li><li>当该线程被唤醒时，会从挂起的点继续执行，通过<code>ObjectMonitor::TryLock</code>尝试获取锁；</li><li><code>ObjectMonitor::TryLock</code>方法本质就是通过CAS设置monitor的_owner字段为当前线程，如果CAS成功，则表示该线程获取了锁，跳出自旋操作，执行同步代码，否则继续被挂起；</li></ol><p>重量锁的释放相关逻辑大致如下（<code>ObjectMonitor::exit</code>方法的相关逻辑）：</p><ol><li>如果是重量级锁的释放，monitor中的_owner指向当前线程，即THREAD == _owner；</li><li>根据不同的策略（由QMode指定），从cxq或EntryList中获取头节点，通过<code>ObjectMonitor::ExitEpilog</code>方法唤醒该节点封装的线程，唤醒操作最终由unpark完成；</li><li>被唤醒的线程，继续执行monitor的竞争；</li></ol><h2 id="锁的升级情况"><a href="#锁的升级情况" class="headerlink" title="锁的升级情况"></a>锁的升级情况</h2><p>锁的升级是单向的：无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</p><p>有位笔者大神给出了锁的变换关系相关流程图，如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-605.jpg" alt="upload successful"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文主要介绍了<code>synchronized</code>的特点和实现，了解了偏向锁、轻量锁、重量锁、锁撤销和锁膨胀的一些原理。对我们更好的理解Java锁机制提供了一些帮助。</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ol><li><a href="https://blog.dreamtobe.cn/2015/11/13/java_synchronized/" rel="external nofollow noopener noreferrer" target="_blank">Java Synchronised机制</a></li><li><a href="https://www.cnblogs.com/dennyzhangdd/p/6734638.html" rel="external nofollow noopener noreferrer" target="_blank">jdk源码剖析二: 对象内存布局、synchronized终极原理</a></li><li><a href="https://wiki.openjdk.java.net/display/HotSpot/Native+Monitors+Design" rel="external nofollow noopener noreferrer" target="_blank">Native+Monitors+Design</a></li><li><a href="http://hg.openjdk.java.net/" rel="external nofollow noopener noreferrer" target="_blank">OpenJDK projects</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="synchronized" scheme="https://www.sakuratears.top/tags/synchronized/"/>
    
      <category term="重量锁" scheme="https://www.sakuratears.top/tags/%E9%87%8D%E9%87%8F%E9%94%81/"/>
    
      <category term="轻量锁" scheme="https://www.sakuratears.top/tags/%E8%BD%BB%E9%87%8F%E9%94%81/"/>
    
      <category term="偏向锁" scheme="https://www.sakuratears.top/tags/%E5%81%8F%E5%90%91%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV简介及使用（一）</title>
    <link href="https://www.sakuratears.top/blog/OpenCV%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89.html"/>
    <id>https://www.sakuratears.top/blog/OpenCV简介及使用（一）.html</id>
    <published>2019-11-10T10:05:00.000Z</published>
    <updated>2019-11-10T13:39:32.541Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>OpenCV (Open Source Computer Vision Library) 是一个基于BSD许可（开源）发行的跨平台计算机视觉库，可以运行在Linux、Windows、Android和Mac OS操作系统上。它主要由 C++ 语言编写，同时提供了Python、Ruby、MATLAB、Java等语言的接口，实现了图像处理和计算机视觉方面的很多通用算法，同时一个使用CUDA的GPU接口也于2010年9月开始实现。</p><p>该库拥有 2500 多个优化算法，其中包括一套全面的经典和最先进的计算机视觉和机器学习算法。这些算法可用于检测和识别人脸、识别对象、对视频中的人类行为进行分类、跟踪摄像机移动、跟踪移动对象、提取对象的 3D 模型、从立体摄像机生成 3D 点云、将图像拼接在一起生成整个场景的高分辨率图像，从图像数据库中查找相似图像，从使用闪光灯拍摄的图像中删除红眼，跟踪眼睛运动，识别风景，并建立标记以覆盖其增强现实等。</p><p>除了谷歌、微软、英特尔、IBM、索尼、等老牌公司，还有许多初创公司，它们广泛使用OpenCV。</p><p>我们可以通过以下网址获取各个版本的 OpenCV ，OpenCV最新版本已经进入 4.x.x 了。</p><p><a href="https://opencv.org/" rel="external nofollow noopener noreferrer" target="_blank">https://opencv.org/</a></p><h1 id="OpenCV环境搭建"><a href="#OpenCV环境搭建" class="headerlink" title="OpenCV环境搭建"></a>OpenCV环境搭建</h1><p>下面分别展示了Windows和Mac环境下的OpenCV搭建，在Linux环境下搭建和Mac环境下类似，如有机会，我会在进行补充。</p><p>本文基于 Java + IDEA + OpenCV 环境的搭建和使用来进行说明。</p><h2 id="Windows环境下的OpenCV环境搭建"><a href="#Windows环境下的OpenCV环境搭建" class="headerlink" title="Windows环境下的OpenCV环境搭建"></a>Windows环境下的OpenCV环境搭建</h2><p>首先下载 <a href="https://opencv.org/releases/" rel="external nofollow noopener noreferrer" target="_blank">OpenCV for Windows</a> 版本，我这儿下载了4.1.1 版本的OpenCV。</p><p>我们将这个exe运行，将OpenCV安装在一个方便寻找的目录下即可。</p><p>至此，OpenCV算是在Windows环境上安装了，下面我们来进行开发环境搭建。</p><p>PS：如果想获取OpenCV最新版进行安装，可以通过OpenCV的 <a href="https://github.com/opencv/" rel="external nofollow noopener noreferrer" target="_blank">GitHub</a> 获取最新版源码，在通过CMake工具进行编译生成OpenCV Lib，这块大家可以查阅相关资料，不在过多叙述。</p><p>我们打开OpenCV的安装目录，在 <code>build/java</code> 可以看到 <code>opencv-411.jar</code> 和 <code>x64、x86</code> 两个文件夹，这两个文件夹里有两个dll文件，都叫<code>opencv_java411.dll</code>，这分别是64位系统和32系统需要使用的动态链接库文件，我们如果想在Java环境下使用OpenCV，在JVM启动时，必须将dll文件加载进去，然后才能使用<code>opencv-411.jar</code>里提供的Java接口方法。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-577.jpg" alt="upload successful"></p><p>我们来看简单测试下，我们用IDEA新建一个Java项目test，同时需要引入上面的dll文件和jar文件。</p><p>新建一个Java项目：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-578.jpg" alt="upload successful"></p><p>引入必要文件：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-579.jpg" alt="upload successful"></p><p>这儿要注意两个文件同时选中，引入后如下图效果，Native Library 可以被正确加载到。否则在启动后会出现 <code>java.lang.UnsatisfiedLinkError</code>错误。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-580.jpg" alt="upload successful"></p><p>然后我们测试一下，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.loadLibrary(Core.NATIVE_LIBRARY_NAME);</span><br><span class="line">        Mat mat = <span class="keyword">new</span> Mat();</span><br><span class="line">        System.out.println(mat.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到正确输出内容。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-581.jpg" alt="upload successful"></p><p>这儿要注意<code>System.loadLibrary(Core.NATIVE_LIBRARY_NAME);</code>这句话，在使用OpenCV时，需要调用此语句以加载原生Library。</p><p>PS：上面的文件引入过程，dll和jar也是可以分别引入的，也是相当于引入到了JVM运行环境中。本质上是没有区别的，但一起引入方便理解，即<code>opencv_java411.dll</code>是为<code>opencv-411.jar</code> ”服务“ 的。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-582.jpg" alt="upload successful"></p><p>显然我们实际的项目是没有这么简单的，而且很多是Web （SpringBoot）项目，使用Maven管理，这种直接引入对我们的管理十分不方便。</p><p>对于jar包部分，我们可以使用如下配置引入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.bytedeco/opencv --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.bytedeco&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;opencv&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.1.0-1.5.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>对于dll文件，我们有三种引入方式：</p><ol><li><p>按照上面直接添加lib到项目里</p><p> 这种虽然可以正常使用，但是在Maven打包项目部署到服务器运行后仍会遇到连接不到的问题。</p></li><li><p>添加VM Options</p><p> 我们可以将dll所在路径添加到VM Options里，<code>-Djava.library.path=D:/opencv/build/java/x64</code>。</p><p> <img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-583.jpg" alt="upload successful"></p></li><li><p>使用程序在项目启动时加入</p><p> 理论上JVM启动后就不能在向其中加入参数了，但我们可以利用反射机制，在JVM启动时将<code>java.library.path</code>参数添加进去，代码如下：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 追加VM Options参数</span></span><br><span class="line"><span class="comment"> * java.library.path</span></span><br><span class="line"><span class="comment"> * 需要在启动后直接调用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> libraryPath</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addLibraryDir</span><span class="params">(String libraryPath)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Field userPathsField = ClassLoader.class.getDeclaredField(<span class="string">"usr_paths"</span>);</span><br><span class="line">    userPathsField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    String[] paths = (String[]) userPathsField.get(<span class="keyword">null</span>);</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; paths.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (libraryPath.equals(paths[i])) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(paths[i]).append(<span class="string">';'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sb.append(libraryPath);</span><br><span class="line">    System.setProperty(<span class="string">"java.library.path"</span>, sb.toString());</span><br><span class="line">    <span class="comment">//系统变量设置为空，JVM会重新加载 sys_paths 和 usr_paths</span></span><br><span class="line">    <span class="keyword">final</span> Field sysPathsField = ClassLoader.class.getDeclaredField(<span class="string">"sys_paths"</span>);</span><br><span class="line">    sysPathsField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    sysPathsField.set(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这个方法在项目启动时调用即可。</p><p> 这个方法在JDK9 及以上版本会出现警告，因为我们这样操作是不安全的，也是不建议的，未来JDK所有非法访问操作将被拒绝。</p><p> <img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-584.jpg" alt="upload successful"></p></li></ol><p>我们通常也建议使用第二种方法引入OpenCV动态链接库dll文件。</p><p>PS：有时候我们环境搭建好了，可能仍无法使用，出现动态库dll找不到的情况，如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-585.jpg" alt="upload successful"></p><p>这时候需要注意<code>Core.NATIVE_LIBRARY_NAME</code>这段代码，我们点进去，可以看到它使用的 LIBRARY_NAME 为 <code>opencv_java410</code>，加载不到的原因是我们安装的是 OpenCV 4.1.1 版本，这时候我们使用<code>System.loadLibrary(“opencv_java411”);</code>即可加载成功，出现这种情况的原因是我们上面Maven下载的jar包是 4.1.0 版本的（这也是目前Maven上的最高版本）。所以为防止出现问题，需要知道自己安装了什么版本的OpenCV，并建议设置为常量，方便引入。</p><h2 id="Mac环境下的OpenCV环境搭建"><a href="#Mac环境下的OpenCV环境搭建" class="headerlink" title="Mac环境下的OpenCV环境搭建"></a>Mac环境下的OpenCV环境搭建</h2><p>OpenCV未提供Mac版本的安装程序，我们通常有以下几种安装方式：</p><ol><li><p>使用Homebrew进行安装</p><p> 这是获取OpenCV最快的方式，安装Homebrew后，要检查Mac系统是否安装了 XCode Command Line Tools。</p><p> 在Terminal下执行如下命令 <code>xcode-select –install</code>，如果系统要求安装此工具，则进行安装即可。</p><p> 上述步骤完成后，我们可以直接使用<code>brew install opencv</code>安装OpenCV，安装好后的文件位于<code>/usr/local/Cellar/opencv4</code>文件夹下。</p><p> 我们使用此种方式安装，可以发现得到的OpenCV安装文件里是不包含支持Java接口部分的编译文件的。</p><p> 这对我们来说十分不友好。</p></li><li><p>使用Homebrew下载源码自动编译安装</p><p> 对于OpenCV，Homebrew也是可以在线自动下载源码到本地并自动进行编译安装的。</p><p> 在安装Homebrew和 XCode Command Line Tools 后，使用Homebrew安装cmake工具<code>brew install cmake</code>，这是OpenCV编译需要用到的工具。</p><p> 同时我们需要安装Apache Ant工具，<code>brew install ant</code>，因为OpenCV编译生成Java接口文件需要用到。</p><p> 然后我们使用指令<code>brew edit opencv</code>，可以打开查看opencv的编译项。如下图：</p><p> <img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-586.jpg" alt="upload successful"></p><p> 然后找到编译项里的 <code>-DBUILD_opencv_java=OFF</code>，将其改为 <code>-DBUILD_opencv_java=ON</code>，然后保存配置。</p><p> 由上面的操作可以看到 Homebrew 的 OpenCV编译默认是不包含Java相关支持的。</p><p> 我们使用<code>brew install –build-from-source opencv</code>下载源码到本地自动进行编译安装。</p><p> PS:我按照上述操作后确实会从GitHub上自动下载最新版源码并进行编译，但是在编译过程中遇到了一个”has no symbol”的错误。导致始终无法make成功，也未找到相关解决办法，于是放弃了该种安装办法。</p><p> 错误详情如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Linking CXX static library ../../lib/libopencv_core.a /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ranlib: file: ../../lib/libopencv_core.a(hal_internal.cpp.o) has no symbols /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ranlib: file: ../../lib/libopencv_core.a(opencl_clamdblas.cpp.o) has no symbols /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ranlib: file: ../../lib/libopencv_core.a(opencl_clamdfft.cpp.o) has no symbols /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ranlib: file: ../../lib/libopencv_core.a(opencl_core.cpp.o) has no symbols /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ranlib: file: ../../lib/libopencv_core.a(hal_internal.cpp.o) has no symbols /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ranlib: file: ../../lib/libopencv_core.a(opencl_clamdblas.cpp.o) has no symbols /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ranlib: file: ../../lib/libopencv_core.a(opencl_clamdfft.cpp.o) has no symbols /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ranlib: file: ../../lib/libopencv_core.a(opencl_core.cpp.o) has no symbols</span><br></pre></td></tr></table></figure><p> 我在OpenCV官网上也看到别人遇到此种情况，尚未有回复。</p><p> <a href="https://answers.opencv.org/question/104758/has-no-symbol-error-on-mac/" rel="external nofollow noopener noreferrer" target="_blank">https://answers.opencv.org/question/104758/has-no-symbol-error-on-mac/</a></p></li><li><p>手动编译OpenCV</p><p> 我们使用OpenCV的源码来编译OpenCV，同样我们需要cmake工具，使用<code>brew install cmake</code>进行安装。</p><p> 安装Apache Ant工具，<code>brew install ant</code>。</p><p> 从OpenCV官网上下载 <a href="https://opencv.org/releases/" rel="external nofollow noopener noreferrer" target="_blank">OpenCV的源码 Sources</a>，我下载的是opencv-4.1.1.zip。</p><p> 我们将它解压，得到源码文件。</p><p> 进入到opencv源码目录 <code>cd /Users/xxx/Desktop/opencv-4.1.1</code>。</p><p> 我们在该目录下创建一个build文件夹用于存放编译后的文件<code>mkdir build</code>。</p><p> 进入到build目录<code>cd build</code>。</p><p> 在此目录下，我们配置cmake的编译参数<code>cmake -DBUILD_SHARED_LIBS=OFF -D CMAKE_INSTALL_PREFIX=/Users/xxx/Applications/opencv-4.1.1 ..</code></p><p> PS：</p><p>   CMAKE_INSTALL_PREFIX 指的是编译完成后安装的路径前缀，我们会把OpenCV安装到此目录下。</p><p>   -DBUILD_SHARED_LIBS=OFF 指的是OpenCV作为一组静态库构建，不去动态依赖其它库，而是包含全部代码的编译。</p><p>   我们可以使用<code>brew info opencv</code>查看OpenCV的依赖库，如果-DBUILD_SHARED_LIBS=ON 则OpenCV会依赖已经存在的库来进行编译，可能会产生问题。</p><p> 构建完成后我们开始进行安装，使用<code>make -j6</code>来进行任务。</p><p> PS：-j6 指的是并行6个任务来进行构建，当然也可以 -j5 五个并行任务等等。</p><p> 检查cmake的输出并确保java是“待构建”模块之一。如果不是的话，很可能你缺少了一个依赖关系您应该通过查看cmake输出中未找到的与java相关的工具并安装它们来进行故障排除。</p><p> 完成后，我们使用<code>sudo make install</code>完成最后的安装任务。</p><p> 这样，在我们上面提到的安装目录里，就会找到OpenCV的安装文件，当然，也能找到Java接口部分的文件。</p><p> 位于 <code> ${CMAKE_INSTALL_PREFIX} /share/java/opencv4</code>文件夹下，如图：</p><p> <img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-594.jpg" alt="upload successful"></p></li></ol><h2 id="Linux环境下的OpenCV环境搭建"><a href="#Linux环境下的OpenCV环境搭建" class="headerlink" title="Linux环境下的OpenCV环境搭建"></a>Linux环境下的OpenCV环境搭建</h2><p>Linux环境下不再过多叙述，有需要的可以查看如下相关文章。</p><p><a href="https://opencv-java-tutorials.readthedocs.io/en/latest/01-installing-opencv-for-java.html" rel="external nofollow noopener noreferrer" target="_blank">installing-opencv-for-java</a></p><p>文章内也包含Windows和Mac的安装教程。</p><h1 id="OpenCV的使用"><a href="#OpenCV的使用" class="headerlink" title="OpenCV的使用"></a>OpenCV的使用</h1><p>这儿我们先来了解下OpenCV的简单使用，后面在深入了解。</p><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><p>先来了解下OpenCV的基本类<code>Mat</code>，它是一个图像的数据格式矩阵。用来存储图像的数据结构。</p><p>我们知道图像是由R (Red)、 G (Green) 、 B (Blue) 三原色构成，那<code>Mat</code>存储这三原色数据，会是一个三维数组？</p><p>其实不是的，<code>Mat</code>中是使用二维数组存储图像数据的，如何存储呢？如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-587.jpg" alt="upload successful"></p><p>可以看到<code>Mat</code>彩色图像的存储形式是三列当做一列，由 BGR 三个通道，存储在一个平面内，这儿彩色图的一个像素会占用3个字节。</p><p>对于灰度图，由于没有颜色要求，因此Mat的存储灰度图的格式和彩色图略有些不同，如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-588.jpg" alt="upload successful"></p><p>可以看到灰度图的一个像素在Mat中会占用1个字节。</p><p>我们使用OpenCV里的 <code>Imgcodecs</code>读取一张红色图片转为<code>Mat</code>，然后进行输出，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    addLibraryDir(vmOptions);</span><br><span class="line">    System.loadLibrary(opencvLibName);</span><br><span class="line">    Mat mat = Imgcodecs.imread(<span class="string">"C:\\Users\\DELL-3020\\Desktop\\test12.jpg"</span>);</span><br><span class="line">    System.out.println(mat.dump());</span><br><span class="line">    Color color = <span class="keyword">new</span> Color(<span class="number">250</span>,<span class="number">0</span>,  <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-589.jpg" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-590.jpg" alt="upload successful"></p><p>我们dump后可以看到<code>Mat</code>的数据内容。</p><p><code>Scalar</code>是OpenCV里的可认为是颜色的向量类，它最多可以有四个入参。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scalar scalar = <span class="keyword">new</span> Scalar(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>它的参数分别表示该颜色向量的 B G R 和 透明度，上面我们就创建了一个纯蓝色透明度为0（不透明）的颜色向量。</p><p>我们使用<code>setTo</code>方法，可以将原来<code>Mat</code>图的红色全部替换为蓝色，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    addLibraryDir(vmOptions);</span><br><span class="line">    System.loadLibrary(opencvLibName);</span><br><span class="line">    Mat mat = Imgcodecs.imread(<span class="string">"C:\\Users\\DELL-3020\\Desktop\\test13.jpg"</span>);</span><br><span class="line">    Scalar scalar = <span class="keyword">new</span> Scalar(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    mat.setTo(scalar);</span><br><span class="line">    System.out.println(mat.dump());</span><br><span class="line">    Imgcodecs.imwrite(<span class="string">"C:\\Users\\DELL-3020\\Desktop\\test15.jpg"</span>,mat);</span><br><span class="line">    Color color = <span class="keyword">new</span> Color(<span class="number">0</span>,<span class="number">0</span>, <span class="number">255</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们会生成一张蓝色图片。</p><h2 id="人脸检测"><a href="#人脸检测" class="headerlink" title="人脸检测"></a>人脸检测</h2><p><code>CascadeClassifier</code>级联分类器是OpenCV里进行图片对象识别的检测器。</p><p>一个分类器的生成： 用一个对象的几百个样本（或者更多）作为正面例子，需要将它们缩放到相同大小；负面例子样本可用任意多张（非正面例子）和正面例子相同大小的图片即可。用它们完成分类器的训练。</p><p>而对于级联分类器，则是由若干个分类器组成，它们占用不同的权重组成，比如人脸级联分类器，要检测人脸，则需要有眼睛部分，则眼睛分类器可以作为人脸级联分类器的一部分。</p><p>我们训练特定样本后，可以得到一个分类器文件（xml），加载这个xml文件后，我们可以对一些测试样本进行检测，看它是否属于目标样本。</p><p>关于训练的内容我们后面在聊，现在OpenCV内置了一些分类器文件例子，我们来看下，如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-591.jpg" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-592.jpg" alt="upload successful"></p><p>可以看到 <code>opencv\build\etc</code>文件夹下有<code>haarcascades</code>和<code>lbpcascades</code>两种模式的分类器，我们以Haar分类器来看。</p><p>可以看到它下面的一些分类器文件demo，根据英文名称还是比较好确认它们是对于哪种类型图片进行识别的。</p><p>根据以上，我们来看一个寻找图片人脸并进行裁剪的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FaceDetector</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 人脸识别xml文件地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CASCADE_FACE_FILENAME = <span class="string">"D:\\opencv\\sources\\data\\haarcascades\\haarcascade_frontalface_alt.xml"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * opencv 安装的版本号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String opencvLibName = <span class="string">"opencv_java411"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * VM Options</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String vmOptions = <span class="string">"D:/opencv/build/java/x64"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 人脸裁剪</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sourceImage</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetFilePath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getFaceImages</span><span class="params">(String sourceImage,String targetFilePath)</span></span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(sourceImage);</span><br><span class="line">        <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"文件不存在！！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        CascadeClassifier faceDetector = <span class="keyword">new</span> CascadeClassifier(CASCADE_FACE_FILENAME);</span><br><span class="line">        <span class="keyword">if</span>(faceDetector.empty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"处理文件时发生异常！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Mat image = Imgcodecs.imread(sourceImage);</span><br><span class="line">        MatOfRect faceDetections = <span class="keyword">new</span> MatOfRect();</span><br><span class="line">        <span class="comment">// 进行人脸检测</span></span><br><span class="line">        faceDetector.detectMultiScale(image, faceDetections);</span><br><span class="line"></span><br><span class="line">        Rect[] rects = faceDetections.toArray();</span><br><span class="line">        <span class="keyword">if</span>(rects.length &lt;=<span class="number">0</span> )&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"原图片上未检测到人脸！！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">"检测到人脸数量：&#123;&#125;"</span>,rects.length);</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Rect rect : rects) &#123;</span><br><span class="line">            <span class="comment">// 进行图片裁剪</span></span><br><span class="line">            Mat mat = <span class="keyword">new</span> Mat(image,<span class="keyword">new</span> Rect(rect.x, rect.y,rect.width,rect.height));</span><br><span class="line">            <span class="comment">// 输出人脸图片</span></span><br><span class="line">            String outFilePath = targetFilePath +<span class="string">"/"</span>+ i+<span class="string">".jpg"</span>;</span><br><span class="line">            Imgcodecs.imwrite(outFilePath, mat);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        addLibraryDir(vmOptions);</span><br><span class="line">        System.loadLibrary(opencvLibName);</span><br><span class="line">        getFaceImages(<span class="string">"C:/Users/DELL-3020/Desktop/test.jpg"</span>,<span class="string">"C:\\Users\\DELL-3020\\Desktop"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们寻找一张照片（包含人脸），可以看到成功生成人脸图。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-593.jpg" alt="upload successful"></p><p>其检测裁剪逻辑主要如下：</p><ul><li>级联分类器加载样本分类器文件<code>haarcascade_frontalface_alt.xml</code>，检测该文件的正确性<code>!faceDetector.empty()</code>；</li><li>将待检测图片读为<code>Mat</code>，<code>Imgcodecs.imread</code>；</li><li>进行人脸检测<code>faceDetector.detectMultiScale</code>，该方法除了传入<code>Mat</code>外，还要传入一个<code>MatOfRect</code>，它是一个<code>Rect</code>数组，用来存放识别返回的”感兴趣”的区域（人脸区域）；</li><li>“感兴趣”的区域可以有多个，如果一个也没有，我们就可以认为这张待检测图片上不存在人脸；</li><li>如果有的话，我们可以根据矩形区域裁剪得到人脸。</li></ul><p>关于这部分我们先介绍到这儿，有兴趣的可以了解下例子文件里的其他级联分类器。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面我们主要说了OpenCV的安装、开发环境的配置等内容。</p><p>对于OpenCV的安装，我们根据一些文档手册，安装还是比较简单的；开发环境的配置方面，由于OpenCV主要以C++编写、开发和使用，因此应用在Java上还是不那么方便的（需要加载原生Lib库）。</p><p>对于OpenCV的使用，这儿说的比较少，只是简单的介绍了它的一些使用，其原理也未作深入分析。</p><p>后面我们继续来看下OpenCV的一些有意思的地方（图片训练、图片识别等）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="OpenCV" scheme="https://www.sakuratears.top/tags/OpenCV/"/>
    
      <category term="人脸识别" scheme="https://www.sakuratears.top/tags/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"/>
    
      <category term="IDEA" scheme="https://www.sakuratears.top/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>MySQL规范</title>
    <link href="https://www.sakuratears.top/blog/MySQL%E8%A7%84%E8%8C%83.html"/>
    <id>https://www.sakuratears.top/blog/MySQL规范.html</id>
    <published>2019-10-29T14:26:00.000Z</published>
    <updated>2019-10-29T14:54:09.819Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="建表规约"><a href="#建表规约" class="headerlink" title="建表规约"></a>建表规约</h1><ol><li><p><strong>【强制】</strong> 表达是与否概念的字段，必须使用<code>is_xxx</code> 的方式命名，数据类型是<code>unsigned tinyint</code> (1表示是，0表示否)。 </p><p> <strong>说明:</strong> 任何字段如果为非负数，必须是<code>unsigned</code>。 </p><p> <strong>注意:</strong> <code>POJO</code>类中的任何布尔类型的变量，都不要加<code>is</code>前缀，所以，需要在设置 从<code>is_xxx</code>到<code>Xxx</code>的映射关系。数据库表示是与否的值，使用<code>tinyint</code>类型，坚持<code>is_xxx</code>的命名方式是为了明确其取值含义与取值范围。</p><p> <strong>正例:</strong> 表达逻辑删除的字段名<code>is_deleted</code>，1 表示删除，0 表示未删除。</p></li><li><p><strong>【强制】</strong> 表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。</p><p> <strong>说明:</strong> <code>MySQL</code>在<code>Windows</code>下不区分大小写，但在<code>Linux</code>下默认是区分大小写。因此，数据库名、表名、字段名，都不允许出现任何大写字母，避免节外生枝。 </p><p> <strong>正例:</strong> <code>aliyun_admin</code>，<code>rdc_config</code>，<code>level3_name</code></p><p> <strong>反例:</strong><code>AliyunAdmin</code>，<code>rdcConfig</code>，<code>level_3_name</code></p></li><li><p><strong>【强制】</strong> 表名不使用复数名词。 </p><p> <strong>说明:</strong> 表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于<code>DO</code>类名也是单数形式，符合表达习惯。</p></li><li><p><strong>【强制】</strong> 禁止保留字，如<code>desc</code>、<code>range</code>、<code>match</code>、<code>delayed</code>等，请参考<code>MySQL</code>官方保留字。</p></li><li><p><strong>【强制】</strong> 主键索引名为<code>pk_字段名</code>;唯一索引名为<code>uk_字段名</code>;普通索引名则为 <code>idx_字段名</code>。</p><p> <strong>说明:</strong> <code>pk_</code> 即 <code>primary key</code>；<code> uk_</code> 即 <code>unique key</code>;<code>idx_</code>即<code>index</code>的简称。</p></li><li><p><strong>【强制】</strong> 小数类型为<code>decimal</code>，禁止使用<code>float</code>和<code>double</code>。 </p><p> <strong>说明:</strong> <code>float</code> 和 <code>double</code> 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过 <code>decimal</code> 的范围，建议将数据拆成整数和小数分开存储。</p></li><li><p><strong>【强制】</strong> 如果存储的字符串长度几乎相等，使用 <code>char</code> 定长字符串类型。</p></li><li><p><strong>【强制】</strong> <code>varchar</code> 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 <code>text</code>，独立出来一张表，用主键来对应，避免影响其它字段索引效率。</p></li><li><p><strong>【强制】</strong> 表必备三字段:<code>id, gmt_create, gmt_modified</code>。 </p><p> <strong>说明:</strong> 其中<code>id</code>必为主键，类型为<code>bigintunsigned</code>、单表时自增、步长为1。<code>gmt_create, gmt_modified</code> 的类型均为 <code>datetime</code> 类型，前者现在时表示主动创建，后者过去分词表示被动更新。</p></li><li><p><strong>【推荐】</strong> 表的命名最好是加上“业务名称_表的作用”。</p><p><strong>正例:</strong> <code>alipay_task / force_project / trade_config</code></p></li><li><p><strong>【推荐】</strong> 库名与应用名称尽量一致。</p></li><li><p><strong>【推荐】</strong> 如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。</p></li><li><p><strong>【推荐】</strong> 字段允许适当冗余，以提高查询性能，但必须考虑数据一致。</p><p>冗余字段应遵循:</p><ul><li>不是频繁修改的字段。 </li><li>不是 <code>varchar</code> 超长字段，更不能是 <code>text</code> 字段。</li></ul><p><strong>正例:</strong> 商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存储类目名称，避免关联查询。</p></li><li><p><strong>【推荐】</strong> 单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。 </p><p><strong>说明:</strong> 如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。</p></li><li><p><strong>【参考】</strong> 合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。</p><p><strong>正例:</strong> 如下表，其中无符号值可以避免误存负数，且扩大了表示范围。</p></li></ol><table><thead><tr><th>对象</th><th>年龄区间</th><th>类型</th><th>字节</th><th>表示范围</th></tr></thead><tbody><tr><td>人</td><td>150岁之内</td><td>tinyint unsigned</td><td>1</td><td>无符号值:0 到 255</td></tr><tr><td>龟</td><td>数百岁</td><td>smallint unsigned</td><td>2</td><td>无符号值:0 到 65535</td></tr><tr><td>恐龙化石</td><td>数千万年</td><td>int unsigned</td><td>4</td><td>无符号值:0 到约 42.9 亿</td></tr><tr><td>太阳</td><td>约50亿年</td><td>bigint unsigned</td><td>8</td><td>无符号值:0 到约 10 的 19 次方</td></tr></tbody></table><h1 id="索引规约"><a href="#索引规约" class="headerlink" title="索引规约"></a>索引规约</h1><ol><li><p><strong>【强制】</strong> 业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。 </p><p> <strong>说明:</strong> 不要以为唯一索引影响了 <code>insert</code> 速度，这个速度损耗可以忽略，但提高查找速度是明显的;另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。</p></li><li><p><strong>【强制】</strong> 超过三个表禁止 <code>join</code>。需要 <code>join</code> 的字段，数据类型必须绝对一致;多表关联查询时， 保证被关联的字段需要有索引。 </p><p> <strong>说明:</strong> 即使双表 <code>join</code> 也要注意表索引、SQL 性能。</p></li><li><p><strong>【强制】</strong> 在 <code>varchar</code> 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。</p><p> <strong>说明:</strong> 索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90%以上，可以使用 <code>count(distinct left(列名, 索引长度))/count(*)</code>的区分度来确定。</p></li><li><p><strong>【强制】</strong> 页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。 </p><p> <strong>说明:</strong> 索引文件具有 <code>B-Tree</code> 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</p></li><li><p><strong>【推荐】</strong> 如果有 <code>order by</code> 的场景，请注意利用索引的有序性。<code>order by</code> 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现 <code>file_sort</code> 的情况，影响查询性能。 </p><p> <strong>正例:</strong> <code>where a=? and b=? order by c; 索引:a_b_c </code></p><p> <strong>反例:</strong> 索引中有范围查找，那么索引有序性无法利用，如:<code>WHERE a&gt;10 ORDER BY b; 索引 a_b 无法排序。</code></p></li><li><p><strong>【推荐】</strong> 利用覆盖索引来进行查询操作，避免回表。 *</p><p><strong>说明:</strong> 如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗?目录浏览一下就好，这个目录就是起到覆盖索引的作用。 </p><p> <strong>正例:</strong> 能够建立索引的种类分为主键索引、唯一索引、普通索引三种，而覆盖索引只是一种查询的一种效果，用explain的结果，extra列会出现:<code>using index</code>。</p></li><li><p><strong>【推荐】</strong> 利用延迟关联或者子查询优化超多分页场景。</p><p> <strong>说明:</strong> <code>MySQL</code> 并不是跳过 <code>offset</code> 行，而是取 <code>offset+N</code> 行，然后返回放弃前 <code>offset</code> 行，返回 <code>N</code> 行，那当 <code>offset</code> 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 <code>SQL</code> 改写。 </p><p> <strong>正例:</strong> 先快速定位需要获取的 id 段，然后再关联:<code>SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id</code></p></li><li><p><strong>【推荐】</strong> <code>SQL</code> 性能优化的目标:至少要达到 <code>range</code> 级别，要求是 <code>ref</code> 级别，如果可以是 <code>consts</code> 最好。</p><p> <code>SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id</code></p><p> <strong>说明:</strong> </p><ul><li><code>consts</code> 单表中最多只有一个匹配行(主键或者唯一索引)，在优化阶段即可读取到数据。</li><li><code>ref</code> 指的是使用普通的索引(<code>normal index</code>)。</li><li><code>range</code> 对索引进行范围检索。</li></ul><p><strong>反例:</strong> explain 表的结果，<code>type=index</code>，索引物理文件全扫描，速度非常慢，这个 <code>index</code> 级别比较<code>range</code> 还低，与全表扫描是小巫见大巫。</p></li><li><p><strong>【推荐】</strong> 建组合索引的时候，区分度最高的在最左边。 </p><p><strong>正例:</strong> 如果 <code>where a=? and b=?</code> ，如果 a 列的几乎接近于唯一值，那么只需要单建 <code>idx_a</code> 索引即可。 </p><p><strong>说明:</strong> 存在非等号和等号混合时，在建索引时，请把等号条件的列前置。如:<code>where c&gt;? and d=?</code> 那么即使 c 的区分度更高，也必须把 d 放在索引的最前列，即索引 <code>idx_d_c</code>。</p></li><li><p><strong>【推荐】</strong> 防止因字段类型不同造成的隐式转换，导致索引失效。</p></li><li><p><strong>【参考】</strong> 创建索引时避免有如下极端误解:</p><ul><li>宁滥勿缺。认为一个查询就需要建一个索引。</li><li>宁缺勿滥。认为索引会消耗空间、严重拖慢更新和新增速度。</li><li>抵制唯一索引。认为业务的唯一性一律需要在应用层通过“先查后插”方式解决。</li></ul></li></ol><h1 id="SQL-语句"><a href="#SQL-语句" class="headerlink" title="SQL 语句"></a>SQL 语句</h1><ol><li><p><strong>【强制】</strong> 不要使用 <code>count(列名)</code>或 <code>count(常量)</code>来替代 <code>count()</code>，<code>count()</code>是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。 </p><p> <strong>说明:</strong> <code>count(*)</code>会统计值为 NULL 的行，而 <code>count(列名)</code>不会统计此列为 NULL 值的行。</p></li><li><p><strong>【强制】</strong> <code>count(distinct col)</code> 计算该列除 NULL 之外的不重复行数，注意 <code>count(distinct col1, col2)</code>如果其中一列全为NULL，那么即使另一列有不同的值，也返回为0。</p></li><li><p><strong>【强制】</strong> 当某一列的值全是 NULL 时，<code>count(col)</code>的返回结果为 0，但<code>sum(col)</code>的返回结果为NULL，因此使用 <code>sum()</code>时需注意 NPE 问题。 </p><p> <strong>正例:</strong> 可以使用如下方式来避免sum的NPE问题:<code>SELECT IF(ISNULL(SUM(g)),0,SUM(g)) FROM table</code>;</p></li><li><p><strong>【强制】</strong> 使用 <code>ISNULL()</code>来判断是否为 NULL 值。 </p><p> <strong>说明:</strong> NULL 与任何值的直接比较都为 NULL。</p><ul><li>NULL&lt;&gt;NULL 的返回结果是NULL，而不是false。 </li><li>NULL=NULL 的返回结果是NULL，而不是true。 </li><li>NULL&lt;&gt;1 的返回结果是NULL，而不是true。</li></ul></li><li><p><strong>【强制】</strong>  在代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句。</p></li><li><p><strong>【强制】</strong> 不得使用外键与级联，一切外键概念必须在应用层解决。 </p><p> <strong>说明:</strong> 以学生和成绩的关系为例，学生表中的 <code>student_id</code> 是主键，那么成绩表中的 <code>student_id</code> 则为外键。</p><p> 如果更新学生表中的<code>student_id</code>，同时触发成绩表中的 <code>student_id</code> 更新，即为级联更新。</p><ul><li>外键与级联更新适用于单机低并发，不适合分布式、高并发集群;</li><li>级联更新是强阻塞，存在数据库更新风暴的风险;</li><li>外键影响数据库的插入速度。</li></ul></li><li><p><strong>【强制】</strong> 禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。</p></li><li><p><strong>【强制】</strong> 数据订正(特别是删除、修改记录操作)时，要先 select，避免出现误删除，确认无误才能执行更新语句。</p></li><li><p><strong>【推荐】</strong> in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控制在1000 个之内。</p></li><li><p><strong>【参考】</strong> 如果有国际化需要，所有的字符存储与表示，均以 <code>utf-8</code> 编码，注意字符统计函数的区别。</p><p><strong>说明:</strong> </p><p><code>SELECT LENGTH(“轻松工作”)</code>; 返回为12<br><code>SELECT CHARACTER_LENGTH(“轻松工作”)</code>; 返回为4</p><p>如果需要存储表情，那么选择 <code>utf8mb4</code> 来进行存储，注意它与 <code>utf-8</code> 编码的区别。</p></li><li><p><strong>【参考】</strong> <code>TRUNCATE TABLE</code> 比 <code>DELETE</code> 速度快，且使用的系统和事务日志资源少，但 <code>TRUNCATE</code>无事务且不触发 <code>trigger</code>，有可能造成事故，故不建议在开发代码中使用此语句。 </p><p><strong>说明:</strong> <code>TRUNCATE TABLE</code> 在功能上与不带 <code>WHERE</code> 子句的 <code>DELETE</code> 语句相同。</p></li></ol><h1 id="ORM-映射"><a href="#ORM-映射" class="headerlink" title="ORM 映射"></a>ORM 映射</h1><ol><li><p><strong>【强制】</strong> 在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。 </p><p> <strong>说明:</strong> </p><ul><li>增加查询分析器解析成本。</li><li>增减字段容易与 <code>resultMap</code> 配置不一致。</li><li>无用字段增加网络消耗，尤其是 <code>text</code> 类型的字段。</li></ul></li><li><p><strong>【强制】</strong> <code>POJO</code> 类的布尔属性不能加 is，而数据库字段必须加 is_，要求在 <code>resultMap</code> 中进行字段与属性之间的映射。 </p><p> <strong>说明:</strong> 参见定义 POJO 类以及数据库字段定义规定，在中增加映射，是必须的。 在MyBatis Generator生成的代码中，需要进行对应的修改。</p></li><li><p><strong>【强制】</strong> 不要用 <code>resultClass</code> 当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义;反过来，每一个表也必然有一个 <code>POJO</code> 类与之对应。 </p><p> <strong>说明:</strong> 配置映射关系，使字段与 <code>DO</code> 类解耦，方便维护。</p></li><li><p><strong>【强制】</strong> <code>sql.xml</code> 配置参数使用:#{}，#param# 不要使用${} 此种方式容易出现 SQL 注入。</p></li><li><p><strong>【强制】</strong> iBATIS自带的<code>queryForList(String statementName,int start,int size)</code>不推荐使用。</p><p> <strong>说明:</strong> 其实现方式是在数据库取到 <code>statementName</code> 对应的 SQL 语句的所有记录，再通过 subList取 <code>start,size</code> 的子集合。</p><p> <strong>正例:</strong> </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt; String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"start"</span>, start);</span><br><span class="line">map.put(<span class="string">"size"</span>, size);</span><br></pre></td></tr></table></figure></li><li><p><strong>【强制】</strong> 不允许直接拿 <code>HashMap</code> 与 <code>Hashtable</code> 作为查询结果集的输出。</p><p> <strong>说明:</strong> <code>resultClass=”Hashtable”</code>，会置入字段名和属性值，但是值的类型不可控。</p></li><li><p><strong>【强制】</strong> 更新数据表记录时，必须同时更新记录对应的 <code>gmt_modified</code> 字段值为当前时间。</p></li><li><p><strong>【推荐】</strong> 不要写一个大而全的数据更新接口。传入为 <code>POJO</code> 类，不管是不是自己的目标更新字段，都进行 <code>update table set c1=value1,c2=value2,c3=value3</code>; 这是不对的。</p><p> 执行 SQL 时，不要更新无改动的字段，一是易出错;二是效率低;三是增加 <code>binlog</code> 存储。</p></li><li><p><strong>【参考】</strong> <code>@Transactional</code> 事务不要滥用。事务会影响数据库的 QPS，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。</p></li><li><p><strong>【参考】</strong> 中的 <code>compareValue</code> 是与属性值对比的常量，一般是数字，表示相等时带上此条件;表示不为空且不为 null 时执行;表示不为 null 值时执行。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="MySQL" scheme="https://www.sakuratears.top/tags/MySQL/"/>
    
      <category term="规范" scheme="https://www.sakuratears.top/tags/%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>Java图片处理相关</title>
    <link href="https://www.sakuratears.top/blog/Java%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3.html"/>
    <id>https://www.sakuratears.top/blog/Java图片处理相关.html</id>
    <published>2019-10-27T10:54:00.000Z</published>
    <updated>2019-10-27T10:56:53.494Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近总结了Java处理图片的一些方法，特此分享下。</p><p>其中主要涉及到2种不同的类包。</p><p>一种是Java自带的<code>ImageIO</code>、<code>Graphics2D</code>、<code>BufferedImage</code>等类的使用；另一种是使用了<code>net.coobird.thumbnailator</code>包下的图片相关类。</p><p><code>net.coobird.thumbnailator</code>包中对图片的操作底层其实也使用了Java自带的图片操作类相关方法，这儿不做过多讨论，有兴趣的可以直接看下它的源码。</p><p>PS: <code>net.coobird.thumbnailator</code>这个工具包在2014年12月 0.4.8版本后就再也没有维护过了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.coobird<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thumbnailator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.4.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>我们来看一下相关的处理方法。</p><h2 id="获取图片真实格式（与后缀无关）"><a href="#获取图片真实格式（与后缀无关）" class="headerlink" title="获取图片真实格式（与后缀无关）"></a>获取图片真实格式（与后缀无关）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getExtension</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(filePath);</span><br><span class="line">    <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"图片地址不正确，请传入正确的图片地址！！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//图片真实格式</span></span><br><span class="line">    String format = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">try</span> (ImageInputStream iis = ImageIO.createImageInputStream(file)) &#123;</span><br><span class="line">        Iterator&lt;ImageReader&gt; iter = ImageIO.getImageReaders(iis);</span><br><span class="line">        <span class="keyword">if</span> (iter.hasNext()) &#123;</span><br><span class="line">            format = iter.next().getFormatName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"获取图片真实格式时出现异常！！"</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> format;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法可以获得图片的真实格式，这个格式和图片的后缀无关。</p><p>其返回的格式为大写，如JPEG，PNG等。</p><p>PS: jpg和jpeg类型的图片返回的格式均为JPEG。</p><h2 id="图片彩色转为黑白"><a href="#图片彩色转为黑白" class="headerlink" title="图片彩色转为黑白"></a>图片彩色转为黑白</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图片彩色转为黑白 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceImagePath 源图像地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetImagePath 生成的目标图像地址（不包含文件名称）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">gray</span><span class="params">(String sourceImagePath, String targetImagePath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//获取图片真实格式</span></span><br><span class="line">    String sourceFormat = getExtension(sourceImagePath).toLowerCase();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//黑白处理</span></span><br><span class="line">    BufferedImage src = ImageIO.read(<span class="keyword">new</span> File(sourceImagePath));</span><br><span class="line">    ColorSpace cs = ColorSpace.getInstance(ColorSpace.CS_GRAY);</span><br><span class="line">    ColorConvertOp op = <span class="keyword">new</span> ColorConvertOp(cs, <span class="keyword">null</span>);</span><br><span class="line">    src = op.filter(src, <span class="keyword">null</span>);</span><br><span class="line">    String targetFile = targetImagePath + <span class="string">"/"</span> + getUUID() + <span class="string">"."</span> + sourceFormat;</span><br><span class="line">    ImageIO.write(src, sourceFormat, <span class="keyword">new</span> File(targetFile));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> targetFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法可对彩色图片进行黑白处理。</p><h2 id="图片格式转换"><a href="#图片格式转换" class="headerlink" title="图片格式转换"></a>图片格式转换</h2><p><strong>A方法：使用Thumbnails进行图片格式转换</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图片格式转换 A 方案</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetFormat   目标格式 jpg  jpeg png 见枚举</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceFilePath 源文件路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetFilePath 生成目标文件路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">convertA</span><span class="params">(String targetFormat, String sourceFilePath, String targetFilePath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//校验</span></span><br><span class="line">    <span class="keyword">if</span> (isBlank(targetFormat) || isBlank(sourceFilePath) || isBlank(targetFilePath)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数错误！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取图片真实格式</span></span><br><span class="line">    String sourceFormat = getExtension(sourceFilePath).toLowerCase();</span><br><span class="line">    <span class="comment">//获取图片后缀格式</span></span><br><span class="line">    String suffixFormat = sourceFilePath.substring(sourceFilePath.lastIndexOf(<span class="string">"."</span>) + <span class="number">1</span>).toLowerCase();</span><br><span class="line">    <span class="comment">//目标格式</span></span><br><span class="line">    String targetFormatStr = targetFormat.toLowerCase();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是目标格式，就直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (sourceFormat.equals(targetFormatStr) &amp;&amp; suffixFormat.equals(targetFormatStr)) &#123;</span><br><span class="line">        <span class="keyword">return</span> sourceFilePath;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用Thumbnails处理</span></span><br><span class="line">    String targetFile = targetFilePath + <span class="string">"/"</span> + getUUID() + <span class="string">"."</span> + targetFormatStr;</span><br><span class="line">    Thumbnails.of(sourceFilePath).scale(<span class="number">1.0f</span>).outputFormat(targetFormatStr).toFile(targetFile);</span><br><span class="line">    <span class="keyword">return</span> targetFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>B方法：使用ImageIO进行图片格式转换</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图片格式转换 B 方案</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetFormat   目标格式 jpg  jpeg png 见枚举</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceFilePath 源文件路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetFilePath 生成目标文件路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">convertB</span><span class="params">(String targetFormat, String sourceFilePath, String targetFilePath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//校验</span></span><br><span class="line">    <span class="keyword">if</span> (isBlank(targetFormat) || isBlank(sourceFilePath) || isBlank(targetFilePath)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数错误！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取图片真实格式</span></span><br><span class="line">    String sourceFormat = getExtension(sourceFilePath).toLowerCase();</span><br><span class="line">    <span class="comment">//获取图片后缀格式</span></span><br><span class="line">    String suffixFormat = sourceFilePath.substring(sourceFilePath.lastIndexOf(<span class="string">"."</span>) + <span class="number">1</span>).toLowerCase();</span><br><span class="line">    <span class="comment">//目标格式</span></span><br><span class="line">    String targetFormatStr = targetFormat.toLowerCase();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是目标格式，就直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (sourceFormat.equals(targetFormatStr) &amp;&amp; suffixFormat.equals(targetFormatStr)) &#123;</span><br><span class="line">        <span class="keyword">return</span> sourceFilePath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getExtension方法已经校验了文件存不存在，这儿不用校验</span></span><br><span class="line">    File file = <span class="keyword">new</span> File(sourceFilePath);</span><br><span class="line">    <span class="comment">//使用ImageIO处理</span></span><br><span class="line">    String targetFile = targetFilePath + <span class="string">"/"</span> + getUUID() + <span class="string">"."</span> + targetFormatStr;</span><br><span class="line">    BufferedImage src = ImageIO.read(file);</span><br><span class="line">    ImageIO.write(src, targetFormatStr, <span class="keyword">new</span> File(targetFile));</span><br><span class="line">    <span class="keyword">return</span> targetFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种方法都可以实现图片格式转换。</p><h2 id="图片旋转相关"><a href="#图片旋转相关" class="headerlink" title="图片旋转相关"></a>图片旋转相关</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图片旋转</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceImage    原图片</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetImagePath   生成图片路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> angle          旋转角度   正数为顺时针旋转，负数为逆时针旋转</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">rotate</span><span class="params">(String sourceImage, String targetImagePath,<span class="keyword">double</span> angle)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isBlank(sourceImage)||isBlank(targetImagePath))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数错误！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取图片真实格式</span></span><br><span class="line">    String sourceFormat = getExtension(sourceImage).toLowerCase();</span><br><span class="line">    String targetFile = targetImagePath + <span class="string">"/"</span> + getUUID() + <span class="string">"."</span> + sourceFormat;</span><br><span class="line"></span><br><span class="line">    Thumbnails.of(sourceImage).scale(<span class="number">1.0f</span>).rotate(angle).outputFormat(sourceFormat).toFile(targetFile);</span><br><span class="line">    <span class="keyword">return</span> targetFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这儿我们使用Thumbnails工具来实现图片的旋转。</p><h2 id="图片缩放相关"><a href="#图片缩放相关" class="headerlink" title="图片缩放相关"></a>图片缩放相关</h2><p>图片缩放有两种类型，一种是根据比例进行缩放，另一种是按照大小进行缩放。</p><p>我们分别来看一下。</p><p><strong>A方法：使用Thumbnails进行图片比例缩放和大小缩放</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图片缩放</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceImage     原图片</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetImagePath 生成的图片地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> scaleWidth      宽度缩放比例    0&lt; scaleWidth &lt;1 表示缩小   scaleWidth &gt;1 表示放大</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> scaleHeight     高度缩放比例   0&lt; scaleWidth &lt;1 表示缩小   scaleWidth &gt;1 表示放大  （宽高缩放比相同图片将进行等比缩放）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">scale</span><span class="params">(String sourceImage, String targetImagePath, <span class="keyword">double</span> scaleWidth, <span class="keyword">double</span> scaleHeight)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isBlank(sourceImage) || isBlank(targetImagePath) || scaleWidth &lt;= <span class="number">0</span> || scaleHeight &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数错误！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取图片真实格式</span></span><br><span class="line">    String sourceFormat = getExtension(sourceImage).toLowerCase();</span><br><span class="line">    String targetFile = targetImagePath + <span class="string">"/"</span> + getUUID() + <span class="string">"."</span> + sourceFormat;</span><br><span class="line"></span><br><span class="line">    Thumbnails.of(sourceImage).scale(scaleWidth, scaleHeight).toFile(targetFile);</span><br><span class="line">    <span class="keyword">return</span> targetFile;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将图片调整到指定大小</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceImage     原图片</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetImagePath 生成目标图片地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> width           调整后的宽度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> height          调整后的高度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keep            是否保持宽高比</span></span><br><span class="line"><span class="comment"> *                        keep = false</span></span><br><span class="line"><span class="comment"> *                        比如照片长宽为 100*97 ，则</span></span><br><span class="line"><span class="comment"> *                        size(200,500) 后照片变为 200*198</span></span><br><span class="line"><span class="comment"> *                        size(300,198)后照片变为200*198</span></span><br><span class="line"><span class="comment"> *                        size(50,100)后照片变为50*49</span></span><br><span class="line"><span class="comment"> *                        size(80,49)后照片变为50*49</span></span><br><span class="line"><span class="comment"> *                        可见该种缩放会保持长宽比，可能导致长或宽有一项看起来不符合我们的预设值</span></span><br><span class="line"><span class="comment"> *                        设置了keep = true ，就会按照指定的宽高变化了</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">size</span><span class="params">(String sourceImage, String targetImagePath, <span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">boolean</span> keep)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isBlank(sourceImage) || isBlank(targetImagePath) || width &lt;= <span class="number">0</span> || height &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数错误！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取图片真实格式</span></span><br><span class="line">    String sourceFormat = getExtension(sourceImage).toLowerCase();</span><br><span class="line">    String targetFile = targetImagePath + <span class="string">"/"</span> + getUUID() + <span class="string">"."</span> + sourceFormat;</span><br><span class="line"></span><br><span class="line">    Thumbnails.of(sourceImage).size(width, height).keepAspectRatio(keep).toFile(targetFile);</span><br><span class="line">    <span class="keyword">return</span> targetFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>B方法：使用ImageIO进行图片比例缩放和大小缩放</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图片缩放，不常用，使用ImageIO进行的缩放</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceImage     原图片</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetImagePath 生成目标图片地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> scaleWidth      宽度缩放比例    0&lt; scaleWidth &lt;1 表示缩小   scaleWidth &gt;1 表示放大</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> scaleHeight     高度缩放比例   0&lt; scaleWidth &lt;1 表示缩小   scaleWidth &gt;1 表示放大</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">scaleB</span><span class="params">(String sourceImage, String targetImagePath, <span class="keyword">double</span> scaleWidth, <span class="keyword">double</span> scaleHeight)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isBlank(sourceImage) || isBlank(targetImagePath) || scaleWidth &lt;= <span class="number">0</span> || scaleHeight &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数错误！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取图片真实格式</span></span><br><span class="line">    String sourceFormat = getExtension(sourceImage).toLowerCase();</span><br><span class="line">    String targetFile = targetImagePath + <span class="string">"/"</span> + getUUID() + <span class="string">"."</span> + sourceFormat;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用ImageIO处理</span></span><br><span class="line">    BufferedImage src = ImageIO.read(<span class="keyword">new</span> File(sourceImage));</span><br><span class="line">    <span class="keyword">int</span> width = src.getWidth();</span><br><span class="line">    <span class="keyword">int</span> height = src.getHeight();</span><br><span class="line">    width = (<span class="keyword">int</span>) (width * scaleWidth);</span><br><span class="line">    height = (<span class="keyword">int</span>) (height * scaleHeight);</span><br><span class="line"></span><br><span class="line">    Image image = src.getScaledInstance(width, height, Image.SCALE_DEFAULT);</span><br><span class="line">    BufferedImage tag = <span class="keyword">new</span> BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);</span><br><span class="line">    Graphics g = tag.getGraphics();</span><br><span class="line">    g.drawImage(image, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">    g.dispose();</span><br><span class="line">    ImageIO.write(tag, sourceFormat, <span class="keyword">new</span> File(targetFile));</span><br><span class="line">    <span class="keyword">return</span> targetFile;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缩放图像（按照高度和宽度），不推荐使用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceImage     原图像</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetImagePath 生成的图像地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> width           要缩放到的宽</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> height          要缩放到的高</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keep            比例不对时是否需要补白：true为补白; false为不补白</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">sizeB</span><span class="params">(String sourceImage, String targetImagePath, <span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">boolean</span> keep)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isBlank(sourceImage) || isBlank(targetImagePath) || width &lt;= <span class="number">0</span> || height &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数错误！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取图片真实格式</span></span><br><span class="line">    String sourceFormat = getExtension(sourceImage).toLowerCase();</span><br><span class="line">    String targetFile = targetImagePath + <span class="string">"/"</span> + getUUID() + <span class="string">"."</span> + sourceFormat;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//缩放比例</span></span><br><span class="line">    <span class="keyword">double</span> ratio = <span class="number">0.0</span>;</span><br><span class="line">    BufferedImage bi = ImageIO.read(<span class="keyword">new</span> File(sourceImage));</span><br><span class="line">    Image image = bi.getScaledInstance(width, height, Image.SCALE_SMOOTH);</span><br><span class="line">    <span class="comment">// 计算比例</span></span><br><span class="line">    <span class="keyword">if</span> ((bi.getHeight() &gt; height) || (bi.getWidth() &gt; width)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bi.getHeight() &gt; bi.getWidth()) &#123;</span><br><span class="line">            ratio = (<span class="keyword">double</span>) (height / bi.getHeight());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ratio = (<span class="keyword">double</span>) (width / bi.getWidth());</span><br><span class="line">        &#125;</span><br><span class="line">        AffineTransformOp op = <span class="keyword">new</span> AffineTransformOp(AffineTransform.getScaleInstance(ratio, ratio), <span class="keyword">null</span>);</span><br><span class="line">        image = op.filter(bi, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否需要填充白色块</span></span><br><span class="line">    <span class="keyword">if</span> (keep) &#123;</span><br><span class="line">        BufferedImage temp = <span class="keyword">new</span> BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);</span><br><span class="line">        Graphics2D g = temp.createGraphics();</span><br><span class="line">        g.setColor(Color.WHITE);</span><br><span class="line">        g.fillRect(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">        <span class="keyword">if</span> (width == image.getWidth(<span class="keyword">null</span>)) &#123;</span><br><span class="line">            g.drawImage(image, <span class="number">0</span>, (height - image.getHeight(<span class="keyword">null</span>)) / <span class="number">2</span>,</span><br><span class="line">                    image.getWidth(<span class="keyword">null</span>), image.getHeight(<span class="keyword">null</span>),Color.WHITE, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            g.drawImage(image, (width - image.getWidth(<span class="keyword">null</span>)) / <span class="number">2</span>, <span class="number">0</span>,</span><br><span class="line">                    image.getWidth(<span class="keyword">null</span>), image.getHeight(<span class="keyword">null</span>),Color.WHITE, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        g.dispose();</span><br><span class="line">        image = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    ImageIO.write((BufferedImage) image, sourceFormat, <span class="keyword">new</span> File(targetFile));</span><br><span class="line">    <span class="keyword">return</span> targetFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们一般使用Thumbnails工具类提供的缩放来处理即可，这是比较常用的。</p><h2 id="图片压缩相关"><a href="#图片压缩相关" class="headerlink" title="图片压缩相关"></a>图片压缩相关</h2><p>图片压缩也大致有两种形式，一种是指定图片质量系数进行压缩，另一种是根据大小进行压缩。</p><p>PS：这儿对于根据大小进行压缩的意思是图片压缩后大小不会超过指定值，而不是压缩到指定值，因为理论上压缩到指定值是十分困难的，也是不必要的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图片压缩</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceImage     原图片</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetImagePath 生成的图片地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> quality         图片质量系数  [ 0,1]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">compress</span><span class="params">(String sourceImage, String targetImagePath, <span class="keyword">float</span> quality)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isBlank(sourceImage) || isBlank(targetImagePath) || quality &lt; <span class="number">0</span> || quality &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数错误！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取图片真实格式</span></span><br><span class="line">    String sourceFormat = getExtension(sourceImage).toLowerCase();</span><br><span class="line">    String targetFile = targetImagePath + <span class="string">"/"</span> + getUUID() + <span class="string">"."</span> + sourceFormat;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//控制图片生成质量，实际会压缩图片</span></span><br><span class="line">    Thumbnails.of(sourceImage).scale(<span class="number">1.0f</span>).outputQuality(quality).outputFormat(sourceFormat).toFile(targetFile);</span><br><span class="line">    <span class="keyword">return</span> targetFile;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 压缩图片文件 （文件大小不会超过指定值）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceImage     原文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetImagePath 生成的文件地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maxSize         文件被压缩后允许的最大大小，单位 byte</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">compress</span><span class="params">(String sourceImage, String targetImagePath, <span class="keyword">long</span> maxSize)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isBlank(sourceImage) || isBlank(targetImagePath) || maxSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数错误！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取图片真实格式</span></span><br><span class="line">    String sourceFormat = getExtension(sourceImage).toLowerCase();</span><br><span class="line">    String targetFile = targetImagePath + <span class="string">"/"</span> + getUUID() + <span class="string">"."</span> + sourceFormat;</span><br><span class="line"></span><br><span class="line">    File source = <span class="keyword">new</span> File(sourceImage);</span><br><span class="line">    <span class="keyword">long</span> size = source.length();</span><br><span class="line">    <span class="comment">//如果图片本身大小就不超过，就直接返回图片地址</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= maxSize) &#123;</span><br><span class="line">        <span class="keyword">return</span> sourceImage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算缩放比例</span></span><br><span class="line">    <span class="keyword">double</span> scale = (<span class="keyword">double</span>) (maxSize / size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//图片尺寸不变，压缩图片大小</span></span><br><span class="line">    Thumbnails.of(source).scale(<span class="number">1.0f</span>).outputQuality(scale).outputFormat(sourceFormat).toFile(targetFile);</span><br><span class="line">    <span class="keyword">return</span> targetFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们同样使用了Thumbnails工具类进行处理。</p><h2 id="图片切割相关"><a href="#图片切割相关" class="headerlink" title="图片切割相关"></a>图片切割相关</h2><p>切割主要有两种形式，一种是在原图指定位置切割一张指定大小的图片，另一种是把图片切割成若干份。</p><p><strong>A形式：从原图指定位置切割（裁剪）一张小图片</strong></p><p>可以通过Thumbnails工具类或者ImageIO实现，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从原图指定位置裁剪一张小图片</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceImage     原图</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetImagePath 生成的图片位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> positions       裁剪位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> width           裁剪宽</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> height          裁剪高</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">cutA</span><span class="params">(String sourceImage, String targetImagePath, Positions positions, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isBlank(sourceImage) || isBlank(targetImagePath) || positions == <span class="keyword">null</span> || width &lt;= <span class="number">0</span> || height &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数错误！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取图片真实格式</span></span><br><span class="line">    String sourceFormat = getExtension(sourceImage).toLowerCase();</span><br><span class="line">    String targetFile = targetImagePath + <span class="string">"/"</span> + getUUID() + <span class="string">"."</span> + sourceFormat;</span><br><span class="line"></span><br><span class="line">    Thumbnails.of(sourceImage).scale(<span class="number">1.0f</span>).sourceRegion(positions, width, height).outputFormat(sourceFormat).toFile(targetFile);</span><br><span class="line">    <span class="keyword">return</span> targetFile;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从原图指定位置裁剪一张小图片</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceImage     原图</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetImagePath 生成的图片位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x               裁剪位置x坐标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> y               裁剪位置y坐标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> width           裁剪宽</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> height          裁剪高</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">cutB</span><span class="params">(String sourceImage, String targetImagePath, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isBlank(sourceImage) || isBlank(targetImagePath) || x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || width &lt;= <span class="number">0</span> || height &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数错误！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取图片真实格式</span></span><br><span class="line">    String sourceFormat = getExtension(sourceImage).toLowerCase();</span><br><span class="line">    String targetFile = targetImagePath + <span class="string">"/"</span> + getUUID() + <span class="string">"."</span> + sourceFormat;</span><br><span class="line"></span><br><span class="line">    Thumbnails.of(sourceImage).scale(<span class="number">1.0f</span>).sourceRegion(x, y, width, height).outputFormat(sourceFormat).toFile(targetFile);</span><br><span class="line">    <span class="keyword">return</span> targetFile;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用ImageIO进行的切割，切割指定位置的一张图片</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceImage     原图</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetImagePath 生成图片位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x               切割图片的位置x</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> y               切割图片的位置y</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> width           切割图片的宽</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> height          切割图片的高</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">cutC</span><span class="params">(String sourceImage, String targetImagePath, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isBlank(sourceImage) || isBlank(targetImagePath) || x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || width &lt;= <span class="number">0</span> || height &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数错误！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取图片真实格式</span></span><br><span class="line">    String sourceFormat = getExtension(sourceImage).toLowerCase();</span><br><span class="line">    String targetFile = targetImagePath + <span class="string">"/"</span> + getUUID() + <span class="string">"."</span> + sourceFormat;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用ImageIO处理</span></span><br><span class="line">    BufferedImage bi = ImageIO.read(<span class="keyword">new</span> File(sourceImage));</span><br><span class="line">    <span class="keyword">int</span> srcWidth = bi.getHeight();</span><br><span class="line">    <span class="keyword">int</span> srcHeight = bi.getWidth();</span><br><span class="line">    Image image = bi.getScaledInstance(srcWidth, srcHeight,Image.SCALE_DEFAULT);</span><br><span class="line">    <span class="comment">// 四个参数分别为图像起点坐标和宽高</span></span><br><span class="line">    <span class="comment">// 即: CropImageFilter(int x,int y,int width,int height)</span></span><br><span class="line">    ImageFilter cropFilter = <span class="keyword">new</span> CropImageFilter(x, y, width, height);</span><br><span class="line">    Image img = Toolkit.getDefaultToolkit().createImage(<span class="keyword">new</span> FilteredImageSource(image.getSource(), cropFilter));</span><br><span class="line">    BufferedImage tag = <span class="keyword">new</span> BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);</span><br><span class="line">    Graphics g = tag.getGraphics();</span><br><span class="line">    g.drawImage(img, <span class="number">0</span>, <span class="number">0</span>, width, height, <span class="keyword">null</span>);</span><br><span class="line">    g.dispose();</span><br><span class="line">    <span class="comment">// 输出为文件</span></span><br><span class="line">    ImageIO.write(tag, sourceFormat, <span class="keyword">new</span> File(targetFile));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> targetFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>B形式：将原图分割成若干小图片</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分割图片</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> filePath           图片地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rows               纵向分割份数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cols               横向分割份数</span></span><br><span class="line"><span class="comment"> *                           rows = 2 cols = 2 则图片会分成4个相等大小的图片</span></span><br><span class="line"><span class="comment"> *                           rows = 2 cols = 1 则图片会分成2个大小相等的图片，分割为高度切割为2半</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> splitImageBasePath 输出小图片的基础路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String[][] splitImage(String filePath, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, String splitImageBasePath) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (rows &lt;= <span class="number">0</span> || cols &lt;= <span class="number">0</span> || isBlank(splitImageBasePath) || isBlank(filePath)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数错误！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String imageType = getExtension(filePath);</span><br><span class="line">    imageType = imageType.toLowerCase();</span><br><span class="line">    <span class="keyword">if</span> (!(JPG.equals(imageType) || JPEG.equals(imageType) || PNG.equals(imageType))) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"请使用jpg、jpeg、png类型的图片"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入文件</span></span><br><span class="line">    File file = <span class="keyword">new</span> File(filePath);</span><br><span class="line">    String fileName = file.getName();</span><br><span class="line">    String fileNamePrefix = fileName.substring(<span class="number">0</span>, fileName.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">    BufferedImage image = ImageIO.read(fis);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算每个小图的宽度和高度</span></span><br><span class="line">    <span class="keyword">int</span> chunkWidth = image.getWidth() / cols;</span><br><span class="line">    <span class="keyword">int</span> chunkHeight = image.getHeight() / rows;</span><br><span class="line"></span><br><span class="line">    BufferedImage[][] imgs = <span class="keyword">new</span> BufferedImage[rows][cols];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; rows; x++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; cols; y++) &#123;</span><br><span class="line">            <span class="comment">//设置小图的大小和类型</span></span><br><span class="line">            imgs[x][y] = <span class="keyword">new</span> BufferedImage(chunkWidth, chunkHeight, image.getType());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//写入图像内容</span></span><br><span class="line">            Graphics2D gr = imgs[x][y].createGraphics();</span><br><span class="line">            gr.drawImage(image, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    chunkWidth, chunkHeight,</span><br><span class="line">                    chunkWidth * y, chunkHeight * x,</span><br><span class="line">                    chunkWidth * y + chunkWidth,</span><br><span class="line">                    chunkHeight * x + chunkHeight, <span class="keyword">null</span>);</span><br><span class="line">            gr.dispose();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String[][] splitImages = <span class="keyword">new</span> String[rows][cols];</span><br><span class="line">    <span class="comment">// 输出小图</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; imgs.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; imgs[i].length; j++) &#123;</span><br><span class="line">            String splitImagePath = splitImageBasePath + <span class="string">"/"</span> + fileNamePrefix + i + <span class="string">"-"</span> + j + <span class="string">"."</span> + imageType;</span><br><span class="line">            splitImages[i][j] = splitImagePath;</span><br><span class="line">            ImageIO.write(imgs[i][j], imageType, <span class="keyword">new</span> File(splitImagePath));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> splitImages;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图片分割</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> filePath</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rows</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cols</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> splitImageBasePath</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">splitImageReturnList</span><span class="params">(String filePath, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, String splitImageBasePath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String[][] strings = splitImage(filePath, rows, cols, splitImageBasePath);</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(rows * cols);</span><br><span class="line">    <span class="keyword">for</span> (String[] strs : strings) &#123;</span><br><span class="line">        list.addAll(Arrays.asList(strs));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据单位图片大小切割图片</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> filePath            原图片</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> imageWidth          单位图片宽度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> imageHeight         单位图片高度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> splitImageBasePath   生成图片基础路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String[][] splitImageB(String filePath, <span class="keyword">int</span> imageWidth, <span class="keyword">int</span> imageHeight, String splitImageBasePath) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span>(isBlank(filePath)||imageWidth&lt;=<span class="number">0</span>||imageHeight&lt;=<span class="number">0</span>||isBlank(splitImageBasePath))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数错误！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    BufferedImage bufferedImage = ImageIO.read(<span class="keyword">new</span> File(filePath));</span><br><span class="line">    <span class="keyword">int</span> srcWidth = bufferedImage.getHeight();</span><br><span class="line">    <span class="keyword">int</span> srcHeight = bufferedImage.getWidth();</span><br><span class="line">    <span class="keyword">if</span>(srcWidth&lt;imageWidth||srcHeight&lt;imageHeight)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"基础图片长宽不符合要求！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cols;</span><br><span class="line">    <span class="keyword">int</span> rows;</span><br><span class="line">    <span class="comment">// 计算切片的横向和纵向数量</span></span><br><span class="line">    <span class="keyword">if</span> (srcWidth % imageWidth == <span class="number">0</span>) &#123;</span><br><span class="line">        cols = srcWidth / imageWidth;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cols = (<span class="keyword">int</span>) Math.floor((<span class="keyword">double</span>)(srcWidth / imageWidth)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (srcHeight % imageHeight == <span class="number">0</span>) &#123;</span><br><span class="line">        rows = srcHeight / imageHeight;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rows = (<span class="keyword">int</span>) Math.floor((<span class="keyword">double</span>)(srcHeight / imageHeight)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> splitImage(filePath,rows,cols,splitImageBasePath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述图片分割代码我们可以把一张图片分成9块来制造九宫格图片等。</p><h2 id="图片合并相关"><a href="#图片合并相关" class="headerlink" title="图片合并相关"></a>图片合并相关</h2><p>图片合并可以将两张或者多张图片按照顺序合成一整张图片。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并图片</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> images             图片列表</span></span><br><span class="line"><span class="comment"> *                           [1.jpg 2.jpg 3.jpg]</span></span><br><span class="line"><span class="comment"> *                           [4.jpg 5.jpg 6.jpg]</span></span><br><span class="line"><span class="comment"> *                           [7.jpg 8.jpg 9.jpg]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> finalImageBasePath 生成的图片要存放的位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">mergeImage</span><span class="params">(String[][] images, String finalImageBasePath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (images == <span class="keyword">null</span> || images.length == <span class="number">0</span> || isBlank(finalImageBasePath)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数不正确！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> rows = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cols = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; images.length; i++) &#123;</span><br><span class="line">        rows++;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; images[i].length; j++) &#123;</span><br><span class="line">            temp++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            cols = temp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (cols != temp) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"需要保证a * b 格式的图片"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String imageType = getExtension(images[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    imageType = imageType.toLowerCase();</span><br><span class="line">    <span class="keyword">if</span> (!(JPG.equals(imageType) || JPEG.equals(imageType) || PNG.equals(imageType))) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"请使用jpg、jpeg、png类型的图片"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> chunkWidth, chunkHeight;</span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建BufferedImage</span></span><br><span class="line">    BufferedImage[][] buffImages = <span class="keyword">new</span> BufferedImage[rows][cols];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            getExtension(images[i][j]);</span><br><span class="line">            buffImages[i][j] = ImageIO.read(<span class="keyword">new</span> File(images[i][j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    type = buffImages[<span class="number">0</span>][<span class="number">0</span>].getType();</span><br><span class="line">    chunkWidth = buffImages[<span class="number">0</span>][<span class="number">0</span>].getWidth();</span><br><span class="line">    chunkHeight = buffImages[<span class="number">0</span>][<span class="number">0</span>].getHeight();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置拼接后图的大小和类型</span></span><br><span class="line">    BufferedImage finalImg = <span class="keyword">new</span> BufferedImage(chunkWidth * cols, chunkHeight * rows, type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入图像内容</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            finalImg.createGraphics().drawImage(buffImages[i][j], chunkWidth * j, chunkHeight * i, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String filePath = finalImageBasePath + <span class="string">"/"</span> + getUUID() + <span class="string">"."</span> + imageType;</span><br><span class="line">    <span class="comment">//输出拼接后的图像</span></span><br><span class="line">    ImageIO.write(finalImg, imageType, <span class="keyword">new</span> File(filePath));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> filePath;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并图片</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> imageList</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rows</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> finalImageBasePath</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">mergeImage</span><span class="params">(List&lt;String&gt; imageList, <span class="keyword">int</span> rows, String finalImageBasePath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(imageList)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数错误"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rows &lt; <span class="number">0</span> || imageList.size() % rows != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数错误"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cols = imageList.size() / rows;</span><br><span class="line">    String[][] strings = <span class="keyword">new</span> String[rows][cols];</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strings.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; strings[i].length; j++) &#123;</span><br><span class="line">            strings[i][j] = imageList.get(temp);</span><br><span class="line">            temp++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mergeImage(strings, finalImageBasePath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图片水印相关"><a href="#图片水印相关" class="headerlink" title="图片水印相关"></a>图片水印相关</h2><h3 id="根据文字生成相应图片"><a href="#根据文字生成相应图片" class="headerlink" title="根据文字生成相应图片"></a>根据文字生成相应图片</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据文字生成JPG图片</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> text        要生成图片的文字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> picFontSize 字体大小设置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bgColor     图片整体背景色</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fontColor   文字颜色</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> font        字体</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> basePath    生成的图片地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createImageByText</span><span class="params">(String text, <span class="keyword">int</span> picFontSize, Color bgColor, Color fontColor, Font font, String basePath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//校验</span></span><br><span class="line">    <span class="keyword">if</span> (isBlank(text) || picFontSize &lt;= <span class="number">0</span> || bgColor == <span class="keyword">null</span> || fontColor == <span class="keyword">null</span> || font == <span class="keyword">null</span> || isBlank(basePath)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数错误！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于字体适应的单位长度</span></span><br><span class="line">    <span class="keyword">float</span> beautify = picFontSize / <span class="number">20.0f</span>;</span><br><span class="line">    <span class="comment">//图片宽高</span></span><br><span class="line">    <span class="keyword">int</span> width = text.length() * picFontSize + (<span class="keyword">int</span>) (<span class="number">5</span> * beautify);</span><br><span class="line">    <span class="keyword">int</span> height = picFontSize + (<span class="keyword">int</span>) (<span class="number">5</span> * beautify);</span><br><span class="line">    <span class="comment">//生成图片</span></span><br><span class="line">    BufferedImage bufferedImage = <span class="keyword">new</span> BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);</span><br><span class="line">    Graphics2D g = bufferedImage.createGraphics();</span><br><span class="line">    <span class="comment">//背景颜色</span></span><br><span class="line">    g.setColor(bgColor);</span><br><span class="line">    g.fillRect(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">    <span class="comment">//抗锯齿设置</span></span><br><span class="line">    g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);</span><br><span class="line">    <span class="comment">//字体颜色</span></span><br><span class="line">    g.setColor(fontColor);</span><br><span class="line">    g.setFont(font.deriveFont((<span class="keyword">float</span>) picFontSize));</span><br><span class="line">    <span class="comment">//在指定坐标除添加文字</span></span><br><span class="line">    g.drawString(text, beautify, picFontSize);</span><br><span class="line">    g.dispose();</span><br><span class="line">    String fileName = basePath + <span class="string">"/"</span> + getUUID() + <span class="string">"."</span> + PictureConstants.JPG;</span><br><span class="line">    <span class="keyword">try</span> (FileOutputStream out = <span class="keyword">new</span> FileOutputStream(fileName)) &#123;</span><br><span class="line">        ImageIO.write(bufferedImage, PictureConstants.JPEG, out);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fileName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法可以根据输入的文字、字体、颜色等生成一张图片。</p><h3 id="为图片添加图片水印"><a href="#为图片添加图片水印" class="headerlink" title="为图片添加图片水印"></a>为图片添加图片水印</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为图片在指定位置添加水印图片</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> watermark      水印图片</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceImage    原图片</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> positions      位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> opacity        透明度 [0.0 - 1.0]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetFilePath 目标文件生成路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">watermarkPic</span><span class="params">(String watermark, String sourceImage, Positions positions, <span class="keyword">float</span> opacity, String targetFilePath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isBlank(watermark) || isBlank(sourceImage) || isBlank(targetFilePath) || positions == <span class="keyword">null</span> || opacity &lt; <span class="number">0</span> || opacity &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数错误！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取图片真实格式</span></span><br><span class="line">    String sourceFormat = getExtension(sourceImage).toLowerCase();</span><br><span class="line">    String targetFile = targetFilePath + <span class="string">"/"</span> + getUUID() + <span class="string">"."</span> + sourceFormat;</span><br><span class="line">    Thumbnails.of(sourceImage).scale(<span class="number">1.0f</span>).watermark(positions, ImageIO.read(<span class="keyword">new</span> File(watermark)), opacity).outputFormat(sourceFormat).toFile(targetFile);</span><br><span class="line">    <span class="keyword">return</span> targetFile;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为图片在指定位置添加水印图片</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> watermark      水印图片</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceImage    原图片</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x              水印位置（距原图片中心 x方向的偏移量）  x&gt;0 在图片中心下方</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> y              水印位置（距原图片中心 y方向的偏移量）  y&gt;0 在图片中心右侧</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> opacity        透明度 [0.0 - 1.0]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetFilePath 目标文件生成路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">watermarkPic</span><span class="params">(String watermark, String sourceImage, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">float</span> opacity, String targetFilePath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isBlank(watermark) || isBlank(sourceImage) || isBlank(targetFilePath) || opacity &lt; <span class="number">0</span> || opacity &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数错误！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取图片真实格式</span></span><br><span class="line">    String sourceFormat = getExtension(sourceImage).toLowerCase();</span><br><span class="line">    String targetFile = targetFilePath + <span class="string">"/"</span> + getUUID() + <span class="string">"."</span> + sourceFormat;</span><br><span class="line"></span><br><span class="line">    Image src = ImageIO.read(<span class="keyword">new</span> File(sourceImage));</span><br><span class="line">    <span class="keyword">int</span> width = src.getWidth(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">int</span> height = src.getHeight(<span class="keyword">null</span>);</span><br><span class="line">    BufferedImage image = <span class="keyword">new</span> BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);</span><br><span class="line">    Graphics2D g = image.createGraphics();</span><br><span class="line">    g.drawImage(src, <span class="number">0</span>, <span class="number">0</span>, width, height, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 水印文件</span></span><br><span class="line">    Image waterPic = ImageIO.read(<span class="keyword">new</span> File(watermark));</span><br><span class="line">    <span class="keyword">int</span> waterWidth = waterPic.getWidth(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">int</span> waterHeight = waterPic.getHeight(<span class="keyword">null</span>);</span><br><span class="line">    g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_ATOP, opacity));</span><br><span class="line">    g.drawImage(waterPic, (width - waterWidth) / <span class="number">2</span> + x,</span><br><span class="line">            (height - waterHeight) / <span class="number">2</span> + y, waterWidth, waterHeight, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 水印文件结束</span></span><br><span class="line">    g.dispose();</span><br><span class="line">    ImageIO.write(image, sourceFormat, <span class="keyword">new</span> File(targetFile));</span><br><span class="line">    <span class="keyword">return</span> targetFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法分别使用了Thumbnails工具类和ImageIO类为原图片添加水印图片。</p><h3 id="为图片添加文字水印"><a href="#为图片添加文字水印" class="headerlink" title="为图片添加文字水印"></a>为图片添加文字水印</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加文字水印</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> text           水印文字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceImage    原图片</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fontColor      字体颜色</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> font           字体</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x              字体水印位置（距原图片中心 x方向的偏移量）  x&gt;0 在图片中心下方</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> y              字体水印位置（距原图片中心 x方向的偏移量）   y&gt;0 在图片中心右侧</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> opacity        透明度 [0.0 - 1.0]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetFilePath 目标文件生成路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">watermarkText</span><span class="params">(String text, String sourceImage, Color fontColor, Font font, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">float</span> opacity, String targetFilePath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isBlank(text) || isBlank(sourceImage) || fontColor == <span class="keyword">null</span> || font == <span class="keyword">null</span> || isBlank(targetFilePath) || opacity &lt; <span class="number">0</span> || opacity &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数错误！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取图片真实格式</span></span><br><span class="line">    String sourceFormat = getExtension(sourceImage).toLowerCase();</span><br><span class="line">    String targetFile = targetFilePath + <span class="string">"/"</span> + getUUID() + <span class="string">"."</span> + sourceFormat;</span><br><span class="line"></span><br><span class="line">    Image src = ImageIO.read(<span class="keyword">new</span> File(sourceImage));</span><br><span class="line">    <span class="keyword">int</span> width = src.getWidth(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">int</span> height = src.getHeight(<span class="keyword">null</span>);</span><br><span class="line">    BufferedImage image = <span class="keyword">new</span> BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);</span><br><span class="line">    Graphics2D g = image.createGraphics();</span><br><span class="line">    g.drawImage(src, <span class="number">0</span>, <span class="number">0</span>, width, height, <span class="keyword">null</span>);</span><br><span class="line">    g.setColor(fontColor);</span><br><span class="line">    g.setFont(font);</span><br><span class="line">    g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_ATOP, opacity));</span><br><span class="line">    <span class="comment">//抗锯齿设置</span></span><br><span class="line">    g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在指定坐标绘制水印文字</span></span><br><span class="line">    g.drawString(text, (width - (getLength(text) * font.getSize()))</span><br><span class="line">            / <span class="number">2</span> + x, (height - font.getSize()) / <span class="number">2</span> + y);</span><br><span class="line">    g.dispose();</span><br><span class="line">    ImageIO.write(image, sourceFormat, <span class="keyword">new</span> File(targetFile));</span><br><span class="line">    <span class="keyword">return</span> targetFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法可为图片在指定位置添加文字水印。</p><p>PS： </p><pre><code>这儿说下图片去水印的问题，一般情况下，对于一个项目，是保留原图，需要的时候再添加水印，从而实现添加水印和去除水印的效果。而如果就是想给一张有水印的图片去除水印，可以使用[OpenCV](https://opencv.org/)等相关进行处理。相关处理在这儿就不过多介绍了。Java在图片深度处理这方面是很一般的，一般进行图片深度处理时，都会调用其它语言的API。如上面提到的OpenCV，其核心算法就是由C++语言实现的，同时提供了其它语言的接口。</code></pre><h2 id="GIF图片的生成与转换"><a href="#GIF图片的生成与转换" class="headerlink" title="GIF图片的生成与转换"></a>GIF图片的生成与转换</h2><p>GIF相关操作可以使用<code>com.madgag.animated-gif-lib</code>相关Jar包，这个工具类Maven地址如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.madgag<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>animated-gif-lib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个工具包在 2017年7月维护到最新版本1.4后就再也没有维护过了。</p><p>这个工具包里有4个类<code>AnimatedGifEncoder.java</code>、<code>GifDecoder.java</code>、<code>LZWEncoder.java</code>、<code>NeuQuant.java</code>。</p><h3 id="将传入的若干图片生成gif"><a href="#将传入的若干图片生成gif" class="headerlink" title="将传入的若干图片生成gif"></a>将传入的若干图片生成gif</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据传入的图片生成指定间隔的gif图像</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> imageList 待处理图片</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> basePath  生成gif文件路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> delay     每张图片间隔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">imageToGif</span><span class="params">(List&lt;String&gt; imageList, String basePath, <span class="keyword">int</span> delay)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//校验</span></span><br><span class="line">    <span class="keyword">if</span>(isEmpty(imageList) || isBlank(basePath) || delay &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数错误！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String fileName = basePath + <span class="string">"/"</span> + getUUID() + <span class="string">"."</span> + PictureConstants.GIF;</span><br><span class="line">    File file = <span class="keyword">new</span> File(fileName);</span><br><span class="line">    <span class="keyword">try</span> (</span><br><span class="line">            ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="comment">//生成GIF</span></span><br><span class="line">        AnimatedGifEncoder e = <span class="keyword">new</span> AnimatedGifEncoder();</span><br><span class="line">        e.start(byteArrayOutputStream);</span><br><span class="line">        <span class="comment">//设置延迟时间</span></span><br><span class="line">        e.setDelay(delay);</span><br><span class="line">        <span class="keyword">for</span> (String imagePath : imageList) &#123;</span><br><span class="line">            e.addFrame(ImageIO.read(<span class="keyword">new</span> FileInputStream(imagePath)));</span><br><span class="line">            <span class="comment">//e.setDelay(delay);//可以设置不同的延迟时间</span></span><br><span class="line">        &#125;</span><br><span class="line">        e.finish();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写入到文件</span></span><br><span class="line">        <span class="keyword">byte</span>[] byteArray = byteArrayOutputStream.toByteArray();</span><br><span class="line">        fileOutputStream.write(byteArray);</span><br><span class="line">        fileOutputStream.flush();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fileName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用此方法，可以将传入的一系列图片生成一张gif，我们应尽量保证传入的图片格式一致。</p><h3 id="将gif图片拆分"><a href="#将gif图片拆分" class="headerlink" title="将gif图片拆分"></a>将gif图片拆分</h3><p>我们这里以jpg为例，将gif图片拆分成一张张jpg格式的图片。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * GIF 图片转 jpg</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> gifPath  GIF图片地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> basePath  生成图片地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">gifToImage</span><span class="params">(String gifPath, String basePath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//校验</span></span><br><span class="line">    <span class="keyword">if</span>(isBlank(gifPath) || isBlank(basePath))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数错误！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    File file = <span class="keyword">new</span> File(gifPath);</span><br><span class="line">    String fileName = file.getName();</span><br><span class="line">    String fileNamePrefix = fileName.substring(<span class="number">0</span>, fileName.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line">    String imagePath = basePath + <span class="string">"/"</span> + fileNamePrefix + <span class="string">"_%s."</span> + PictureConstants.JPG;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//GIF处理</span></span><br><span class="line">    GifDecoder gifDecoder = <span class="keyword">new</span> GifDecoder();</span><br><span class="line">    gifDecoder.read(gifPath);</span><br><span class="line">    <span class="comment">//frame个数</span></span><br><span class="line">    <span class="keyword">int</span> count = gifDecoder.getFrameCount();</span><br><span class="line">    List&lt;String&gt; imageList = <span class="keyword">new</span> ArrayList&lt;&gt;(count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">//得到帧</span></span><br><span class="line">        BufferedImage bufferedImage = gifDecoder.getFrame(i);</span><br><span class="line">        <span class="comment">//int delay = gifDecoder.getDelay(i);//延迟时间</span></span><br><span class="line">        String imageFileName = String.format(imagePath, i);</span><br><span class="line">        <span class="comment">//生成jpg文件</span></span><br><span class="line">        <span class="keyword">try</span> (FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(imageFileName)) &#123;</span><br><span class="line">            ImageIO.write(bufferedImage, PictureConstants.JPEG, fileOutputStream);</span><br><span class="line">        &#125;</span><br><span class="line">        imageList.add(imageFileName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> imageList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>将一些需要的代码记录下来形成自己的工具类包，提高自身经验总结，对以后是蛮有帮助的。</p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>源码详见我的 <a href="https://github.com/javazwt" rel="external nofollow noopener noreferrer" target="_blank">Github</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="图片处理" scheme="https://www.sakuratears.top/tags/%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86/"/>
    
      <category term="Thumbnailator" scheme="https://www.sakuratears.top/tags/Thumbnailator/"/>
    
  </entry>
  
  <entry>
    <title>MySQL优化</title>
    <link href="https://www.sakuratears.top/blog/MySQL%E4%BC%98%E5%8C%96.html"/>
    <id>https://www.sakuratears.top/blog/MySQL优化.html</id>
    <published>2019-10-27T09:16:00.000Z</published>
    <updated>2019-10-27T09:34:10.328Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="几个问题"><a href="#几个问题" class="headerlink" title="几个问题"></a>几个问题</h1><ol><li>如何发现慢查询？</li><li>为什么不建议使用订单号作为主键？</li><li>为什么要在需要排序的字段上加索引？</li><li>为什么字段加上函数或者计算就不走索引了？</li><li>为什么不建议字段允许为NULL？</li></ol><h1 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h1><h2 id="MySQL逻辑架构"><a href="#MySQL逻辑架构" class="headerlink" title="MySQL逻辑架构"></a>MySQL逻辑架构</h2><p>MySQL逻辑架构整体分为三层，如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-569.jpg" alt="upload successful"></p><ul><li><p>客户端：</p><ul><li>如，连接处理、授权认证、安全等功能</li></ul></li><li><p>核心服务：</p><ul><li>MySQL大多数核心服务均在这一层</li><li>包括查询解析、分析、优化、缓存、内置函数（如，时间、数学、加密等）</li><li>所有的跨存储引擎的功能也在这一层，如，存储过程、触发器、视图等</li></ul></li><li><p>存储引擎：</p><ul><li>负责MySQL中的数据存储和读取</li><li>中间的服务层通过API与存储引擎通信，这些API屏蔽了不同存储引擎间的差异</li></ul></li><li><p>重点解释下查询缓存：</p><ul><li>对于select语句，在解析查询之前，服务器会先检查查询缓存（Query Cache）。</li><li>如果命中，服务器便不再执行查询解析、优化和执行的过程，而是直接返回缓存中的结果集。</li></ul></li></ul><h2 id="MySQL执行过程"><a href="#MySQL执行过程" class="headerlink" title="MySQL执行过程"></a>MySQL执行过程</h2><p>下图是MySQL执行一个查询的过程。实际上每一步都比想象中的复杂，尤其优化器，更复杂也更难理解。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-570.jpg" alt="upload successful"></p><p><strong>MySQL查询过程如下：</strong></p><ol><li>客户端将查询发送到MySQL服务器；</li><li>服务器先检查查询缓存，如果命中，立即返回缓存中的结果，否则进入下一阶段；</li><li>服务器对SQL进行解析、预处理，再由优化器生成对象的执行计划；</li><li>MySQL根据优化器生成的执行计划，调用存储引擎API来执行查询；</li><li>服务器将结果返回给客户端，同时缓存查询结果。</li></ol><h2 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h2><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-571.jpg" alt="upload successful"></p><h3 id="InnoDB索引结构"><a href="#InnoDB索引结构" class="headerlink" title="InnoDB索引结构"></a>InnoDB索引结构</h3><p>在MySQL中索引是在存储引擎层实现的，而不是在服务器层实现的。不同存储引擎实现索引的方式也各有不同。</p><ul><li><p>Index_Type：</p><ul><li>主键</li><li>普通索引</li><li>唯一索引</li></ul></li><li><p>Index_Method：</p><ul><li><p>HASH： </p><p>  在HEAP表中，如果存储的数据重复度很低（也就是说基数很大），对该列数据以等值查询为主，没有范围查询、没有排序的时候，特别适合采用哈希索引。</p><p>  例如这种SQL：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> … <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> C1 = ?; — 仅等值查询</span><br></pre></td></tr></table></figure></li><li><p>BTREE（B+树）：</p><p>  在大多数场景下，都会有范围查询、排序、分组等查询特征，用B+树索引就可以了。B+树索引结构适用于绝大多数场景。</p><p>  为什么使用B+树？</p><p>  一、从内存⻆度上说，数据库中的索引一般时在磁盘上，数据量大的情况可能无法一次性装入内存，B+树的设计可以允许数据分批加载。</p><p>  二、从业务场景上说，如果只选择一个数据那确实是hash更快，但是数据库中经常会选中多条，这时候由于B+树索引有序，并且又有链表相连，它的查询效率比hash就快很多了。</p><ul><li><p>B-树</p><p>为了描述B-Tree，首先定义一条数据记录为一个二元组[key, data]，key为记录的键值，对于不同数据记录，key是互不相同的；data为数据记录除key外的数据。</p><p>那么B-Tree是满足下列条件的数据结构：</p><ul><li>d为大于1的一个正整数，称为B-Tree的深度。</li><li>h为一个正整数，称为B-Tree的高度。</li><li>每个非叶子节点由n-1个key和n个指针组成，其中d&lt;=n&lt;=2d。</li><li>每个叶子节点最少包含一个key和两个指针，最多包含2d-1个key和2d个指针，叶节点的指针均为null 。</li><li>所有叶节点具有相同的深度，等于树高h。</li><li>key和指针互相间隔，节点两端是指针。</li><li>一个节点中的key从左到右非递减排列。</li><li>所有节点组成树结构。</li><li>每个指针要么为null，要么指向另外一个节点。</li><li>如果某个指针在节点node最左边且不为null，则其指向节点的所有key小于v(key_1)，其中v(key_1)为node的第一个key的值。</li><li>如果某个指针在节点node最右边且不为null，则其指向节点的所有key大于v(key_m)，其中v(key_m)为node的最后一个key的值。</li><li>如果某个指针在节点node的左右相邻key分别是key_i和key{i+1}且不为null，则其指向节点的所有key小于v(key{i+1})且大于v(key_i)。</li></ul><p>下图是一个d=2的B-Tree示意图。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-572.jpg" alt="upload successful"></p></li><li><p>B+Tree</p><p>B-Tree有许多变种，其中最常用的是B+Tree，例如MySQL就普遍使⽤B+Tree实现其索引结构。</p><p>与B-Tree相比，B+Tree有以下不同点：</p><ul><li>每个节点的指针上限为2d而不是2d+1；</li><li>内节点不存储data，只存储key；</li><li>叶子节点不存储指针。</li></ul><p>下图是一个简单的B+Tree示意图。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-573.jpg" alt="upload successful"></p><p>一般来说，B+Tree比B-Tree更适合实现外存储索引结构，具体原因与外存储器原理及计算机存取原理有关。</p></li><li><p>带有顺序访问指针的B+Tree</p><p>一般在数据库系统或文件系统中使用的B+Tree结构都在经典B+Tree的基础上进行了优化，增加了顺序访问指针。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-574.jpg" alt="upload successful"></p><p>如图所示，在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。</p></li></ul></li></ul></li></ul><h3 id="InnoDB索引实现"><a href="#InnoDB索引实现" class="headerlink" title="InnoDB索引实现"></a>InnoDB索引实现</h3><ul><li><p>聚簇索引</p><p>  在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p><p>  <img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-575.jpg" alt="upload successful"></p><p>  上图是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。</p><blockquote><p>定义：数据行的物理顺序与列值（一般是主键那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引。</p></blockquote></li><li><p>辅助索引</p><p>  InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，下图为定义在Col3上的一个辅助索引：</p><p>  <img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-576.jpg" alt="upload successful"></p><p>  聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p><p>  了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。</p></li></ul><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h2 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h2><p>我们总是希望MySQL能够获得更高的查询性能，最好的办法是弄清楚MySQL是如何优化和执行查询的。一旦理解了这一点，就会发现：很多的查询优化工作实际上就是遵循一些原则让MySQL的优化器能够按照预想的合理方式运行而已。</p><ol><li><p>slow_query_log</p><p> 这个参数设置为ON，可以捕获执行时间超过一定数值的SQL语句。</p></li><li><p>long_query_time</p><p> 当SQL语句执行时间超过此数值时，就会被记录到日志中，建议设置为1或者更短。</p></li><li><p>slow_query_log_file</p><p> 记录日志的文件路径以及文件名。</p></li><li><p>log_queries_not_using_indexes</p><p> 这个参数设置为ON，可以捕获到所有未使用索引的SQL语句，尽管这个SQL语句有可能执行得很快。</p></li></ol><h2 id="慢查询解读"><a href="#慢查询解读" class="headerlink" title="慢查询解读"></a>慢查询解读</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">User@Host: <span class="title">test</span>[<span class="title">test</span>] @ [127.0.0.1] <span class="title">Id</span>: 85</span></span><br><span class="line"><span class="function"><span class="title">Query_time</span>: 3.299343 </span></span><br><span class="line"><span class="function"><span class="title">Lock_time</span>: 0.001484</span></span><br><span class="line"><span class="function"><span class="title">Rows_sent</span>: 10 </span></span><br><span class="line"><span class="function"><span class="title">Rows_examined</span>: 4844057</span></span><br><span class="line"><span class="function"><span class="title">SET</span> <span class="title">timestamp</span>=1557113299;</span></span><br><span class="line"><span class="function"><span class="title">SELECT</span></span></span><br><span class="line"><span class="function"> *</span></span><br><span class="line"><span class="function"><span class="title">FROM</span></span></span><br><span class="line"><span class="function"><span class="title">salaries</span></span></span><br><span class="line"><span class="function"><span class="title">ORDER</span> <span class="title">BY</span></span></span><br><span class="line"><span class="function"><span class="title">from_date</span>,</span></span><br><span class="line"><span class="function"><span class="title">salary</span></span></span><br><span class="line"><span class="function"><span class="title">LIMIT</span> 2000000, 10;</span></span><br></pre></td></tr></table></figure><p>从慢查询日志里面摘选一条慢查询日志，数据组成如下：</p><ol><li>用户名 、用户的IP信息、线程ID号</li><li>执行花费的时间【单位：毫秒】</li><li>执行获得锁的时间</li><li>获得的结果行数</li><li>扫描的数据行数</li><li>这SQL执行的具体时间</li><li>具体的SQL语句</li></ol><h2 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h2><h3 id="简要说明"><a href="#简要说明" class="headerlink" title="简要说明"></a>简要说明</h3><table><thead><tr><th>列名</th><th>表格查询的顺序编号</th><th>降序查看，id相同的从上到下查查看。id可以为null ，当table为(union ,m,n )类型的时候，id为null，这个时候，id的顺序为 m跟 n的后面。</th></tr></thead><tbody><tr><td>id</td><td>表查询的顺序编号</td><td>id相同，执行顺序由上至下；id不同，id值越大优先级越高，越先被执行</td></tr><tr><td>select_type</td><td>查询的方式</td><td>下文详细说明</td></tr><tr><td>table</td><td>表格名称</td><td>表名，别名，( union m,n ）</td></tr><tr><td>partitions</td><td>分区名称</td><td>查询使用到表分区的分区名</td></tr><tr><td>type</td><td>表连接的类型</td><td>下文详细说明</td></tr><tr><td>possible_keys</td><td>可能使用到的索引</td><td>这儿的索引只是可能会有到，实际不一定会用到</td></tr><tr><td>key</td><td>使用到的索引</td><td>实际使用的索引</td></tr><tr><td>key_len</td><td>使用到索引的长度</td><td>比如多列索引，只用到最左的一列，那么使用到索引的长度则为该列的长度，故该值不一定等于 key 列索引的长度</td></tr><tr><td>ref</td><td>谓词的关联信息</td><td>当 join type 为 const、eq_ref 或者 ref 时，谓词的关联信息。可能为 ：null（非 const \ eq_ref \ ref join type 时）、const（常量）、关联的谓词列名。显示该表的索引字段关联了哪张表的哪个字段</td></tr><tr><td>rows</td><td>扫描的行数</td><td>该表格扫描到的行数。这儿注意在mysql里边是嵌套链接，所以，需要把所有rows相乘就会得到查询数据行关联的次数</td></tr><tr><td>filtered</td><td>实际显示行数占扫描rows的比例</td><td>实际显示的行数 = rows * filtered / 100</td></tr><tr><td>extra</td><td>特性使用</td></tr></tbody></table><h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><ul><li><strong>SIMPLE</strong>，简单查询方式，不使用UNION跟子查询；</li><li><strong>PRIMARY</strong>，该表格位于最外层开始查询，通常会跟其他查询方式组合；</li><li><strong>SUBQUERY</strong>，子查询内层查询的第一个SELECT，结果不依赖于外部查询结果集（不会被数据库引擎改写的情况）；</li><li><strong>UNION</strong>，UNION 第一个SELECT 为PRIMARY，第二个及之后的所有SELECT 为 UNION SELECT TYPE；</li><li><strong>UNION RESULT</strong>，每个结果集的取出来后，会做合并操作，这个操作就是 UNION RESULT；</li><li><strong>DEPENDENT UNION</strong>，子查询中的UNION操作，从UNION 第二个及之后的所有SELECT语句的SELECT TYPE为 DEPENDENT UNION，这个一般跟DEPENDENT SUBQUERY⼀起结合应用，子查询中UNION 的第一个为DEPENDENT SUBQUERY；</li><li><strong>DEPENDENT SUBQUERY</strong>，子查询中内层的第一个SELECT，依赖于外部查询的结果集；</li><li><strong>DERIVED</strong>，查询使用内联视图；</li><li><strong>MATERIALIZED</strong>，子查询物化，表出现在非相关子查询中，并且需要进行物化时会出现MATERIALIZED关键词；</li><li><strong>UNCACHEABLE SUBQUERY</strong>，结果集无法缓存的子查询，需要逐次查询；</li><li><strong>UNCACHEABLE UNION</strong>，表示子查询不可被物化，需要逐次运行。</li></ul><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>性能排序：system-&gt;const-&gt;eq-ref-&gt;ref-&gt;fulltext-&gt;ref_or_null-&gt;index_merge-&gt;unique_subquery-&gt;index_subquery-&gt;range-&gt;index-&gt;ALL，一般来说，<strong>得保证查询至少达到range级别，最好能达到ref</strong>。</p><ul><li><strong>system</strong>：表只有一行记录，相当于系统表。</li><li><strong>const</strong>：通过索引一次就找到，只匹配一行数据。主键或者唯一索引的常量查询。</li><li><strong>eq_ref</strong>：join查询中，关联条件为主键或者唯一索引。</li><li><strong>ref</strong>：非唯一性索引扫描，返回匹配某个单独值的所有行，用于=、&lt;或&gt;操作符带索引的列。</li><li><strong>range</strong>：只检索给定范围的行，使用一个索引来选择行。一般使用between、&lt;、&gt;。</li><li><strong>index</strong>：只遍历索引树。使用到索引，但不是索引查找。</li><li><strong>all</strong>：全表扫描，性能最差。</li></ul><h3 id="extra"><a href="#extra" class="headerlink" title="extra"></a>extra</h3><p>重点以下几种情况：</p><ul><li><strong>Using filesort</strong>：MySQL会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。若出现有该值，应该优化SQL语句。</li><li><strong>Using temporary</strong>：使用临时表保存中间结果，比如MySQL在对查询结果排序时使用临时表，常见于group by和order by。若出现有该值，应该优化SQL语句。</li><li><strong>Using index</strong>：索引覆盖，不止用到索引，而且没有回表。避免了访问表的数据行，效率不错。</li></ul><h2 id="优化案例"><a href="#优化案例" class="headerlink" title="优化案例"></a>优化案例</h2><p>优化案例可以参考这篇文章 <a href="https://www.sakuratears.top/blog/MySql-%E4%BD%BF%E7%94%A8Explain%E5%88%86%E6%9E%90SQL%E8%AF%AD%E5%8F%A5%E5%8F%8A%E7%B4%A2%E5%BC%95.html">MySql 使用Explain分析SQL语句及索引</a></p><h2 id="优化口诀"><a href="#优化口诀" class="headerlink" title="优化口诀"></a>优化口诀</h2><blockquote><p>全职匹配我最爱，最左前缀要遵守；</p><p>带头大哥不能死，中间兄弟不能断；</p><p>索引列上少计算，范围之后全失效；</p><p>Like百分写最右，覆盖索引不写星；</p><p>不等空值还有or，索引失效要少用。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="MySQL" scheme="https://www.sakuratears.top/tags/MySQL/"/>
    
      <category term="索引" scheme="https://www.sakuratears.top/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>如何使Java项目生成可执行的exe文件</title>
    <link href="https://www.sakuratears.top/blog/%E5%A6%82%E4%BD%95%E4%BD%BFJava%E9%A1%B9%E7%9B%AE%E7%94%9F%E6%88%90%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%9A%84exe%E6%96%87%E4%BB%B6.html"/>
    <id>https://www.sakuratears.top/blog/如何使Java项目生成可执行的exe文件.html</id>
    <published>2019-10-16T14:48:00.000Z</published>
    <updated>2019-10-16T15:42:22.501Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前些天，有个朋友问我可否使用Java制作一个exe程序，要求运行程序可以实现某些功能。</p><p>我出于好奇了解了一下，是可以使用Java制作一些客户端exe程序的。</p><p>过程感觉还是比较有意思的，特此记录下来。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>因为这类程序一般都为客户端程序，涉及到较古老的<code>JFrame</code>，我就简单的使用一个例子来说明下。</p><p>我们比如说想制作一个读取文件大小的exe文件。</p><h2 id="构建Java项目"><a href="#构建Java项目" class="headerlink" title="构建Java项目"></a>构建Java项目</h2><p>我们首先构建一个普通的Java Maven项目，如下图。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-529.jpg" alt="upload successful"></p><p>随便给项目起个名称。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-530.jpg" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-531.jpg" alt="upload successful"></p><p>这儿我们不需要任何maven依赖，如果项目较复杂可以引入需要的maven依赖等。</p><p>我们新建一个Frame实现文件读取大小功能。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-532.jpg" alt="upload successful"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileHelper</span> <span class="keyword">extends</span> <span class="title">JFrame</span> <span class="keyword">implements</span> <span class="title">ActionListener</span> </span>&#123;</span><br><span class="line">    JButton open=<span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> FileHelper();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileHelper</span><span class="params">()</span></span>&#123;</span><br><span class="line">        open=<span class="keyword">new</span> JButton(<span class="string">"请选择要处理的文件"</span>);</span><br><span class="line">        <span class="keyword">this</span>.add(open);</span><br><span class="line">        <span class="keyword">this</span>.setBounds(<span class="number">400</span>, <span class="number">200</span>, <span class="number">1000</span>, <span class="number">500</span>);</span><br><span class="line">        <span class="keyword">this</span>.setVisible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        open.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">        JFileChooser jfc=<span class="keyword">new</span> JFileChooser();</span><br><span class="line">        jfc.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES );</span><br><span class="line">        jfc.showDialog(<span class="keyword">new</span> JLabel(), <span class="string">"选择"</span>);</span><br><span class="line">        File file=jfc.getSelectedFile();</span><br><span class="line">        <span class="keyword">if</span>(file.isDirectory())&#123;</span><br><span class="line">            JOptionPane.showMessageDialog(<span class="keyword">null</span>, <span class="string">"请选择一个文件"</span>, <span class="string">"信息"</span>, JOptionPane.INFORMATION_MESSAGE);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(file.isFile())&#123;</span><br><span class="line">            <span class="keyword">if</span>(file.canRead())&#123;</span><br><span class="line">                <span class="keyword">long</span> bytes = file.length();</span><br><span class="line">                String size = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">if</span>(bytes &lt; <span class="number">1024</span>)&#123;</span><br><span class="line">                    size = bytes + <span class="string">"B"</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bytes &lt; <span class="number">1048576</span>)&#123;</span><br><span class="line">                    size = bytes/<span class="number">1024</span> + <span class="string">"KB"</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    size = bytes/<span class="number">1048576</span> + <span class="string">"MB"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                String message = <span class="string">"该文件大小为:"</span>+size + <span class="string">"\r\n文件路径:"</span>+file.getPath();</span><br><span class="line">                JOptionPane.showMessageDialog(<span class="keyword">null</span>, message, <span class="string">"信息"</span>, JOptionPane.INFORMATION_MESSAGE);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                JOptionPane.showMessageDialog(<span class="keyword">null</span>, <span class="string">"该文件不可读"</span>, <span class="string">"信息"</span>, JOptionPane.INFORMATION_MESSAGE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们运行一下，可以成功启动此项目。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-533.jpg" alt="upload successful"></p><p>那我们如何将它转换为exe呢？</p><h2 id="生成可执行jar文件"><a href="#生成可执行jar文件" class="headerlink" title="生成可执行jar文件"></a>生成可执行jar文件</h2><p>在生成exe之前，我们需要先生成可执行jar文件，再将jar文件转换成exe文件。</p><p>我们打开IDEA项目结构（File -&gt; Project Structure -&gt; Artifacts），如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-534.jpg" alt="upload successful"></p><p>使项目可以生成一个可执行的jar包。</p><p>这儿要注意选择好项目和启动Main入口后，MANIFSET.MF一定到生成到src文件夹下。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-535.jpg" alt="upload successful"></p><p>完成后会看到我们项目的一些信息，这儿我们配置生成的jar输出到项目目录out下，点击OK即可。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-536.jpg" alt="upload successful"></p><p>这时候在项目src目录下可以看到META-INF文件夹及文件夹里的MANIFSET.MF文件，没有就说明配置错了。</p><p>在IDEA里找到 Build -&gt; Build Artifacts，选择这个项目，点击Build。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-537.jpg" alt="upload successful"></p><p>完成后会看到我们生成的jar包。</p><p>我们copy出来并使用Java运行一下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar framework-exe-app.jar</span><br></pre></td></tr></table></figure><p>可以看到成功运行。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-538.jpg" alt="upload successful"></p><p>显然我们只得到了一个只能在有JRT环境上运行的jar包，下一步我们来把它转成exe文件。</p><h2 id="生成exe文件"><a href="#生成exe文件" class="headerlink" title="生成exe文件"></a>生成exe文件</h2><p>将jar文件转换为exe文件，需要下载exe4j工具，<a href="https://exe4j.apponic.com/" rel="external nofollow noopener noreferrer" target="_blank">exe4j</a>。</p><p>下载完成后安装，会打开welcome界面，这个界面是用来输注册码用的，如果不输入，是可以直接next进行下去的。但若是不输入，双击生成的exe时，会alert出一段话，如图。必须点“确定”才可以执行程序。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-539.jpg" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-540.jpg" alt="upload successful"></p><p>关于License Key，网上可以找到，这儿也提供了一些。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A-XVK258563F-1p4lv7mg7sav</span><br><span class="line">A-XVK209982F-1y0i3h4ywx2h1</span><br><span class="line">A-XVK267351F-dpurrhnyarva</span><br><span class="line">A-XVK204432F-1kkoilo1jy2h3r</span><br><span class="line">A-XVK246130F-1l7msieqiwqnq</span><br><span class="line">A-XVK249554F-pllh351kcke50</span><br><span class="line">A-XVK238729F-25yn13iea25i</span><br><span class="line">A-XVK222711F-134h5ta8yxbm0</span><br></pre></td></tr></table></figure><p>配置后，直接点击Next，选择”JAR” in “EXE” mode，如下图。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-541.jpg" alt="upload successful"></p><p>点击Next，我们输入应用名（这儿我起名MyApp），然后文件输出路径我们新建一个文件夹，然后输出到这个文件夹下。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-542.jpg" alt="upload successful"></p><p>点击Next，在这个页面我们需要配置名称，应用图标可配置可以不配置，如果应用不允许多开则需要勾选 Allow 那个选项。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-543.jpg" alt="upload successful"></p><p>这儿在Advance Options里，还有一些其它可选项，有兴趣的童鞋可以自己看一下。</p><p>如果不想生成错误日志，可以去掉如图选项。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-544.jpg" alt="upload successful"></p><p>这儿我们在这里面选中生成64-bit的应用程序。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-545.jpg" alt="upload successful"></p><p>在第5步Java invocation页面，VM Parameters输入<code>-Dappdir=${EXE4J_EXEDIR}</code>，然后我们将我们生成的jar包引入，如下图：</p><p>Class Path —&gt; + —&gt; Archive —&gt; 选择jar包 —&gt; OK</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-546.jpg" alt="upload successful"></p><p>然后配置我们的程序入口。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-547.jpg" alt="upload successful"></p><p>点击Next，到达第6步，需要设置jre版本，如下图：</p><p>需要设置最小的jre版本，然后在Advance Options里，选择Search Sequence，我们设置使用自己的JRE，这样生成的应用程序可以在没有安装Java的系统上使用。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-548.jpg" alt="upload successful"></p><p>在这之前，我们需要一份JRE（Java Runtime Environment）文件，可以在Java安装目录里找到，或者在官网上下载。比如 <a href="https://www.oracle.com/technetwork/java/javase/downloads/jre8-downloads-2133155.html" rel="external nofollow noopener noreferrer" target="_blank">jre-8u231</a>。</p><p>将它复制到我们之前创建的MyApp目录里，在Search Sequence里选择它。（之前Search Sequence的默认的3个直接删除即可）。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-549.jpg" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-550.jpg" alt="upload successful"></p><p>点击Next，到达第7步，这儿是设置App启动图，可以不设置。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-551.jpg" alt="upload successful"></p><p>第8步默认即可。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-552.jpg" alt="upload successful"></p><p>点击Next，到达最后一步，可以点击<code>Click Here to start Application</code>按钮测试一下应用程序。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-553.jpg" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-554.jpg" alt="upload successful"></p><p>成功说明没有问题，点击<code>Exit</code>按钮即可。</p><p>最后它会问你要不要保存配置信息，保存的话可以下次使用这个配置，这个按自己需要来即可。</p><p>退出后我们在我们的MyApp文件夹下可以找到刚才生成的App，可以运行一下是没有问题的。</p><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><p>我们虽然制作完成了该App，可是我们发现，我们把应用程序exe文件单独移动到一个地方，运行时，就会报找不到JRE环境。</p><p>这是比较容易理解的，我们使用Java编译的class文件，最终转换成了exe文件，但是仍不能离开JRE环境运行，也就是需要将整个MyApp文件夹进行移动，或者作为一个项目（App）。</p><p>这显然和在一台机器上安装JRE没有本质区别……</p><p>就是变成了我们使用了项目自带的JRE环境。</p><p>这也是没有办法的事，因为Java的平台无关性，就是基于它的JRE环境，脱离JRE环境也无法运行class文件，我们的exe其实只是一层包装而已。</p><h2 id="可安装版本的exe文件"><a href="#可安装版本的exe文件" class="headerlink" title="可安装版本的exe文件"></a>可安装版本的exe文件</h2><p>即使是一层包装，能不能使它在优化下呢？起码别人一看起来不立马觉得别扭？</p><p>其实我们可以继续对exe文件和jre部分继续进行包装，使它成为一个安装版本的可执行文件。</p><p>这儿我们需要使用到 Inno Setup，这儿我们可以下载它 <a href="http://www.jrsoftware.org/isdl.php" rel="external nofollow noopener noreferrer" target="_blank">Inno Setup Downloads</a></p><p>下载安装完成（过程略）后打开，如下图：</p><p>我们选择使用生成向导来一步步引导我们生成exe文件。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-555.jpg" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-556.jpg" alt="upload successful"></p><p>我们可以设置自己的App名字及一些基本信息。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-557.jpg" alt="upload successful"></p><p>项目的安装路径，和是否允许用户更改安装路径参数设置我们直接取默认就好。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-558.jpg" alt="upload successful"></p><p>找到我们刚生成的exe文件，然后添加必要文件（jre文件），注意需要将jre文件夹下的全部文件添加上。</p><p>PS: 这儿我们需要新建一个temp文件夹，将jre移动进来，然后选择temp，这样生成的MyApp.exe会和jre文件夹在同一级，不然MyApp.exe找不到JRE环境。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-559.jpg" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-560.jpg" alt="upload successful"></p><p>然后下一步，是配置应用图标创建显示的，如果允许用户不在桌面创建图标，可以如下配置：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-561.jpg" alt="upload successful"></p><p>下一步关于License File 我们直接跳过就行。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-562.jpg" alt="upload successful"></p><p>下一步是安装后使用者权限，我们默认安装后所有人都可以使用即可。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-563.jpg" alt="upload successful"></p><p>下一步设置安装语言，用默认English即可。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-564.jpg" alt="upload successful"></p><p>然后设置生成的文件路径，还有应用图标等。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-565.jpg" alt="upload successful"></p><p>然后下一步到完成。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-566.jpg" alt="upload successful"></p><p>编译时会问到是否保存编译脚本，依照自己选择即可。</p><p>编译效果图如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-567.jpg" alt="upload successful"></p><p>最后会生成可安装的exe文件，我们运行下，把它安装一下。</p><p>我们安装完成可以看一下它的目录，其实和我们刚才的一模一样，只不过现在变成了一整个安装exe，而且安装包体积也被压缩了。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-568.jpg" alt="upload successful"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章没什么特别要总结的，主要就是相关工具的使用。</p><p>可以看到我们一个小小的功能，但生成的exe是巨大的，但是随着项目文件变多，jre占用比例减小，就是逐渐可以接受的了。</p><p>现在Java已经很少在桌面客户端进行一些开发工作了，但了解一下Java-exe的生成过程也是比较有意思的。</p><p>今天的内容就到这里吧。</p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>源码详见于我的 <a href="https://github.com/JavaZWT/" rel="external nofollow noopener noreferrer" target="_blank">GitHub</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="exe" scheme="https://www.sakuratears.top/tags/exe/"/>
    
      <category term="exe4j" scheme="https://www.sakuratears.top/tags/exe4j/"/>
    
      <category term="Inno Setup" scheme="https://www.sakuratears.top/tags/Inno-Setup/"/>
    
  </entry>
  
  <entry>
    <title>Java sort和parallelSort接口及其实现</title>
    <link href="https://www.sakuratears.top/blog/Java-sort%E5%92%8CparallelSort%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0.html"/>
    <id>https://www.sakuratears.top/blog/Java-sort和parallelSort接口及其实现.html</id>
    <published>2019-10-14T14:12:00.000Z</published>
    <updated>2019-10-20T08:12:23.286Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上篇文章我们介绍了 <a href="https://www.sakuratears.top/blog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B9%9D%EF%BC%89-Java%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84DualPivotQuicksort.html#more">排序算法（九）-Java源码中的DualPivotQuicksort</a>，今天我们来看下sort接口的实现，看看JDK对数据排序这块到底做了哪些优化。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="sort接口"><a href="#sort接口" class="headerlink" title="sort接口"></a>sort接口</h2><p>sort接口有多个重载的方法，我们整理下后，它们分别如下：</p><p>在 <code>java.util.Arrays</code>类里，调用 <code>Array.sort(a)</code>方法，可以对数组a进行排序，它有18个重载方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//整个int数组排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    DualPivotQuicksort.sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对int数组from到to的位置进行排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">    DualPivotQuicksort.sort(a, fromIndex, toIndex - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//long数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">long</span>[] a)</span> </span>&#123;</span><br><span class="line">    DualPivotQuicksort.sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">long</span>[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">    DualPivotQuicksort.sort(a, fromIndex, toIndex - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//short数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">short</span>[] a)</span> </span>&#123;</span><br><span class="line">    DualPivotQuicksort.sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">short</span>[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">    DualPivotQuicksort.sort(a, fromIndex, toIndex - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//char数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">char</span>[] a)</span> </span>&#123;</span><br><span class="line">    DualPivotQuicksort.sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">    DualPivotQuicksort.sort(a, fromIndex, toIndex - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//byte数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">byte</span>[] a)</span> </span>&#123;</span><br><span class="line">    DualPivotQuicksort.sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">byte</span>[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">    DualPivotQuicksort.sort(a, fromIndex, toIndex - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//float数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">float</span>[] a)</span> </span>&#123;</span><br><span class="line">    DualPivotQuicksort.sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">float</span>[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">    DualPivotQuicksort.sort(a, fromIndex, toIndex - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//double数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">double</span>[] a)</span> </span>&#123;</span><br><span class="line">    DualPivotQuicksort.sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">double</span>[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">    DualPivotQuicksort.sort(a, fromIndex, toIndex - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Object数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (LegacyMergeSort.userRequested)</span><br><span class="line">        legacyMergeSort(a);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ComparableTimSort.sort(a, <span class="number">0</span>, a.length, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Object[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">    <span class="keyword">if</span> (LegacyMergeSort.userRequested)</span><br><span class="line">        legacyMergeSort(a, fromIndex, toIndex);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ComparableTimSort.sort(a, fromIndex, toIndex, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] a, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sort(a);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (LegacyMergeSort.userRequested)</span><br><span class="line">            legacyMergeSort(a, c);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            TimSort.sort(a, <span class="number">0</span>, a.length, c, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">                            Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sort(a, fromIndex, toIndex);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">        <span class="keyword">if</span> (LegacyMergeSort.userRequested)</span><br><span class="line">            legacyMergeSort(a, fromIndex, toIndex, c);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            TimSort.sort(a, fromIndex, toIndex, c, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p><strong>可以看到对于基本数据类型，因为排序稳定性不会对数据造成影响（两个一样的数据谁前谁后都可以），故使用了DualPivotQuicksort排序算法。</strong></p><p><strong>对于Object数组(没有继承Comparator接口的数据类型)，会先判断一个<code>LegacyMergeSort.userRequested</code>的值是否为真，如果为真就使用legacyMergeSort排序算法，否则就使用ComparableTimSort排序算法。</strong></p><p><strong>对于泛型数组T []，如果比较器<code>Comparator</code>为空，就按照Object []方式进行处理；如果有比较器的话，照样先判断<code>LegacyMergeSort.userRequested</code>的值是否为真，是的话就用legacyMergeSort排序算法，否则就使用TimSort排序算法。</strong></p><p><strong>其他地方的sort最终会调用<code>Array.sort(a)</code>方法。如<code>java.util.Collections</code>类里的<code>sort(List<t> list)</t></code>方法，最终调用了<code>Array.sort(T[] a)</code>。</strong></p><p>根据上面的分析，我们先来看看<code>LegacyMergeSort.userRequested</code>这个参数吧，因为它决定非基本数据类型数组到底是使用legacyMergeSort还是TimSort（ComparableTimSort是TimSort的Object []版本，也相当于TimSort）。</p><p>追踪源码，<code>LegacyMergeSort.userRequested</code>赋值过程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LegacyMergeSort</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> userRequested =</span><br><span class="line">            java.security.AccessController.doPrivileged(</span><br><span class="line">                <span class="keyword">new</span> sun.security.action.GetBooleanAction(</span><br><span class="line">                    <span class="string">"java.util.Arrays.useLegacyMergeSort"</span>)).booleanValue();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到它是可以通过系统设置进行配置的，<code>java -Djava.util.Arrays.useLegacyMergeSort=true</code>，可以设置使用老的归并排序。</p><p>这个值默认是false，即不使用归并排序，Java之所以有这部分判断，完全是为了兼容老版本，同时归并排序这部分将在未来移除（当前介绍版本为JDK1.8，在JDK11中发现已经移除）。</p><p>legacyMergeSort这个方法涉及到的就是归并排序，关于这部分，我们不再展示源码（Java未来版本也会移除），有兴趣的可以看看我之前的文章<a href="https://www.sakuratears.top/blog/Java%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%88Merge-Sort%EF%BC%89">归并排序(MergeSort)</a>部分。这两者唯一不同的是Java的legacyMergeSort在排序部分长度小于 INSERTIONSORT_THRESHOLD = 7 的时候，会使用插入排序，相当于提高了普通归并的效率。</p><p>TimSort或者ComparableTimSort我在之前文章中也有分析了，有兴趣的可以看看，这儿不过多介绍。<a href="https://www.sakuratears.top/blog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89-TimSort.html#more">排序算法（六）- TimSort</a>。</p><p>关于Java源码里的DualPivotQuicksort内容详见这篇文章<a href="https://www.sakuratears.top/blog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B9%9D%EF%BC%89-Java%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84DualPivotQuicksort.html#more">排序算法（九）-Java源码中的DualPivotQuicksort</a>。</p><h2 id="parallelSort接口"><a href="#parallelSort接口" class="headerlink" title="parallelSort接口"></a>parallelSort接口</h2><p>看完串行排序接口，我们再来看下Java自带排序的并行版本parallelSort接口，看看它是如何实现并行排序的。</p><p>先看看它的几个重载方法,由于基本数据类型数组的parallelSort都是类似的，这儿我只拿int[]进行举例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int数据并行排序方法（其它基本数据类型数组和其类似，这儿代码就不在展示）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parallelSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.length, p, g;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= MIN_ARRAY_SORT_GRAN ||</span><br><span class="line">        (p = ForkJoinPool.getCommonPoolParallelism()) == <span class="number">1</span>)</span><br><span class="line">        DualPivotQuicksort.sort(a, <span class="number">0</span>, n - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">new</span> ArraysParallelSortHelpers.FJInt.Sorter</span><br><span class="line">            (<span class="keyword">null</span>, a, <span class="keyword">new</span> <span class="keyword">int</span>[n], <span class="number">0</span>, n, <span class="number">0</span>,</span><br><span class="line">                ((g = n / (p &lt;&lt; <span class="number">2</span>)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span><br><span class="line">                MIN_ARRAY_SORT_GRAN : g).invoke();</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parallelSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">    <span class="keyword">int</span> n = toIndex - fromIndex, p, g;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= MIN_ARRAY_SORT_GRAN ||</span><br><span class="line">        (p = ForkJoinPool.getCommonPoolParallelism()) == <span class="number">1</span>)</span><br><span class="line">        DualPivotQuicksort.sort(a, fromIndex, toIndex - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">new</span> ArraysParallelSortHelpers.FJInt.Sorter</span><br><span class="line">            (<span class="keyword">null</span>, a, <span class="keyword">new</span> <span class="keyword">int</span>[n], fromIndex, n, <span class="number">0</span>,</span><br><span class="line">                ((g = n / (p &lt;&lt; <span class="number">2</span>)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span><br><span class="line">                MIN_ARRAY_SORT_GRAN : g).invoke();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型数组并行排序方法（无比较器）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">parallelSort</span><span class="params">(T[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.length, p, g;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= MIN_ARRAY_SORT_GRAN ||</span><br><span class="line">        (p = ForkJoinPool.getCommonPoolParallelism()) == <span class="number">1</span>)</span><br><span class="line">        TimSort.sort(a, <span class="number">0</span>, n, NaturalOrder.INSTANCE, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">new</span> ArraysParallelSortHelpers.FJObject.Sorter&lt;T&gt;</span><br><span class="line">            (<span class="keyword">null</span>, a,</span><br><span class="line">                (T[])Array.newInstance(a.getClass().getComponentType(), n),</span><br><span class="line">                <span class="number">0</span>, n, <span class="number">0</span>, ((g = n / (p &lt;&lt; <span class="number">2</span>)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span><br><span class="line">                MIN_ARRAY_SORT_GRAN : g, NaturalOrder.INSTANCE).invoke();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parallelSort</span><span class="params">(T[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">    <span class="keyword">int</span> n = toIndex - fromIndex, p, g;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= MIN_ARRAY_SORT_GRAN ||</span><br><span class="line">        (p = ForkJoinPool.getCommonPoolParallelism()) == <span class="number">1</span>)</span><br><span class="line">        TimSort.sort(a, fromIndex, toIndex, NaturalOrder.INSTANCE, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">new</span> ArraysParallelSortHelpers.FJObject.Sorter&lt;T&gt;</span><br><span class="line">            (<span class="keyword">null</span>, a,</span><br><span class="line">                (T[])Array.newInstance(a.getClass().getComponentType(), n),</span><br><span class="line">                fromIndex, n, <span class="number">0</span>, ((g = n / (p &lt;&lt; <span class="number">2</span>)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span><br><span class="line">                MIN_ARRAY_SORT_GRAN : g, NaturalOrder.INSTANCE).invoke();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型数组并行排序方法（有比较器）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">parallelSort</span><span class="params">(T[] a, Comparator&lt;? <span class="keyword">super</span> T&gt; cmp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cmp == <span class="keyword">null</span>)</span><br><span class="line">        cmp = NaturalOrder.INSTANCE;</span><br><span class="line">    <span class="keyword">int</span> n = a.length, p, g;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= MIN_ARRAY_SORT_GRAN ||</span><br><span class="line">        (p = ForkJoinPool.getCommonPoolParallelism()) == <span class="number">1</span>)</span><br><span class="line">        TimSort.sort(a, <span class="number">0</span>, n, cmp, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">new</span> ArraysParallelSortHelpers.FJObject.Sorter&lt;T&gt;</span><br><span class="line">            (<span class="keyword">null</span>, a,</span><br><span class="line">                (T[])Array.newInstance(a.getClass().getComponentType(), n),</span><br><span class="line">                <span class="number">0</span>, n, <span class="number">0</span>, ((g = n / (p &lt;&lt; <span class="number">2</span>)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span><br><span class="line">                MIN_ARRAY_SORT_GRAN : g, cmp).invoke();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">parallelSort</span><span class="params">(T[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Comparator&lt;? <span class="keyword">super</span> T&gt; cmp)</span> </span>&#123;</span><br><span class="line">    rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">    <span class="keyword">if</span> (cmp == <span class="keyword">null</span>)</span><br><span class="line">        cmp = NaturalOrder.INSTANCE;</span><br><span class="line">    <span class="keyword">int</span> n = toIndex - fromIndex, p, g;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= MIN_ARRAY_SORT_GRAN ||</span><br><span class="line">        (p = ForkJoinPool.getCommonPoolParallelism()) == <span class="number">1</span>)</span><br><span class="line">        TimSort.sort(a, fromIndex, toIndex, cmp, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">new</span> ArraysParallelSortHelpers.FJObject.Sorter&lt;T&gt;</span><br><span class="line">            (<span class="keyword">null</span>, a,</span><br><span class="line">                (T[])Array.newInstance(a.getClass().getComponentType(), n),</span><br><span class="line">                fromIndex, n, <span class="number">0</span>, ((g = n / (p &lt;&lt; <span class="number">2</span>)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span><br><span class="line">                MIN_ARRAY_SORT_GRAN : g, cmp).invoke();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><p>对于基本类型数组数据，并行排序会判断排序长度n（或者数组长度）是否小于 <code>MIN_ARRAY_SORT_GRAN = 1 &lt;&lt; 13 = 8192</code>，如果小于或者<code>p = ForkJoinPool.getCommonPoolParallelism()) == 1</code>的时候，就会使用DualPivotQuicksort排序算法；否则它创建了一个<code>ArraysParallelSortHelpers.FJInt.Sorter</code>类进行并行排序。</p><p>对于Object数组或者泛型数组T[]的排序，可以看到与基本数据类型相似，只是最后的排序算法使用的是稳定的TimSort，并行帮助类使用的是<code>ArraysParallelSortHelpers.FJObject.Sorter</code>，这个类底层串行排序也是基于TimSort。</p><p>我们来分析下并行排序源码：</p><p>对于长度小于8192很好理解，就是数据长度小的时候，使用串行排序就可以了，即DualPivotQuicksort，并没有使用并行排序。</p><p>而<code>ForkJoinPool.getCommonPoolParallelism()</code>是返回公共线程池的并行级别，即允许多少个线程并行，如果是1的话说明禁用了线程，那么就无法使用多线程，也就只能使用串行排序，关于这个值和ForkJoinPool相关，后面我们会看下这个类，来了解一下它的实现，这儿就不过多叙述。</p><p>我们重点来看下<code>ArraysParallelSortHelpers.FJInt.Sorter</code>这个类，这个是针对于int数组的并行工具类，当然我们还可以看到其它数据类型的并行工具类，如<code>ArraysParallelSortHelpers.FJByte.Sorter</code>，他们都在<code>ArraysParallelSortHelpers</code>这个类里。</p><p>这个类的并行实现是根据<a href="http://supertech.lcs.mit.edu/cilk/" rel="external nofollow noopener noreferrer" target="_blank">Cilk算法</a>来实现的。</p><blockquote><p>Cilk是一种多线程算法语言。Cilk背后的理念是，程序员应该集中精力构建程序，以暴露并行性和利用局部性，让Cilk的运行时系统负责调度计算，以便在给定平台上高效运行。因此，Cilk运行时系统负责诸如负载平衡、分页和通信协议等细节。然而，与其他多线程语言不同，Cilk是算法语言，因为运行时系统保证了高效和可预测的性能。</p></blockquote><p>算法内容大致如下：</p><ol><li>如果数组长度 n 过小（小于临界值 threshold ），就使用串行排序；</li><li><p>否则，将数组分为两半：</p><ul><li>将一半数组再分为两半（n/4），对于每一半，继续分割下去，直到数组长度小于临界值threshold，不再进行分割；</li><li>对前一半串行排序，对后一半串行排序，两半排序是并行进行的； </li><li>需要注意的是 n/2排序时需要保证两个n/4的并行排序合并完成，以此类推，n/4排序时需要保证两个n/8的并行排序合并完成……</li><li>将两部分合并</li></ul></li></ol><p>其伪代码大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parallelSort</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = high - low +<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; threshold)&#123;</span><br><span class="line">        sort(a);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> half = n &gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        ForkJoinTaskTest task1 = ForkJoinTaskTest(a,low,half-<span class="number">1</span>);</span><br><span class="line">        task1.fork();</span><br><span class="line">        ForkJoinTaskTest task2 = ForkJoinTaskTest(a,half,high-<span class="number">1</span>);</span><br><span class="line">        task2.compute();</span><br><span class="line">        task1.join();</span><br><span class="line">        merge(a,low,half,high-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个分割过程和我们之前说到过的 <a href="https://www.sakuratears.top/blog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89-%E5%8F%8C%E8%B0%83%E6%8E%92%E5%BA%8F.html">双调排序</a>的并行版本有些许类似。</p><p>我们先不看Java源码的相关实现，我们想，如果我们自己实现一个并行版本的排序如何实现呢？</p><p>我们需要使用到<code>ForkJoinPool</code>，我们可以参考我的另一篇文章<a href="https://www.sakuratears.top/blog/%E4%B8%80%E9%81%93Java%E8%AF%95%E9%A2%98%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83.html">一道Java试题引发的思考</a>。</p><p>这篇文章里使用了分支/合并框架（ForkJoinPool）来使用并行处理累加数据，我们参照这个模式，可以根据伪代码写出使用 Java DualPivotQuicksort的并行版本，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParallelSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100000000</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">100000000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] b = a.clone();</span><br><span class="line">        System.out.println(<span class="string">"ParallelSort排序开始："</span>);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        ForkJoinParallelSort task = <span class="keyword">new</span> ForkJoinParallelSort(a);</span><br><span class="line">        <span class="keyword">new</span> ForkJoinPool().invoke(task);</span><br><span class="line">        System.out.println(<span class="string">"ParallelSort耗时："</span> + (System.currentTimeMillis() - start) + <span class="string">"ms"</span>);</span><br><span class="line">        System.out.println(<span class="string">"ParallelSort排序完成！"</span>);</span><br><span class="line">        System.out.println(<span class="string">"数组是否有序："</span> + isOrdered(a));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"ArrayParallelSort排序开始："</span>);</span><br><span class="line">        <span class="keyword">long</span> start1 = System.currentTimeMillis();</span><br><span class="line">        Arrays.parallelSort(b);</span><br><span class="line">        System.out.println(<span class="string">"ArrayParallelSort耗时："</span> + (System.currentTimeMillis() - start1) + <span class="string">"ms"</span>);</span><br><span class="line">        System.out.println(<span class="string">"ArrayParallelSort排序完成！"</span>);</span><br><span class="line">        System.out.println(<span class="string">"数组是否有序："</span> + isOrdered(b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ForkJoinParallelSort</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要排序的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] array;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组起始下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组结束下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> end;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组最小长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">8192</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinParallelSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ForkJoinParallelSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Void <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = end - start + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> half = length &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//小于等于阈值，串行排序处理</span></span><br><span class="line">        <span class="keyword">if</span> (length &lt;= THRESHOLD) &#123;</span><br><span class="line">            computeSequentially(array, start, end);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建一个子任务来为数组的前一半排序</span></span><br><span class="line">        ForkJoinParallelSort leftTask = <span class="keyword">new</span> ForkJoinParallelSort(array, start, start + half - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//利用另一个ForkJoinPool线程异步执行新创建的子任务</span></span><br><span class="line">        leftTask.fork();</span><br><span class="line">        <span class="comment">//创建一个任务为数组的后一半排序</span></span><br><span class="line">        ForkJoinParallelSort rightTask = <span class="keyword">new</span> ForkJoinParallelSort(array, start + half, end);</span><br><span class="line">        <span class="comment">//同步执行第二个子任务，有可能允许进一步递归划分</span></span><br><span class="line">        rightTask.compute();</span><br><span class="line">        <span class="comment">//读取第一个子任务的结果，没有完成就等待</span></span><br><span class="line">        leftTask.join();</span><br><span class="line">        <span class="comment">//合并结果</span></span><br><span class="line">        <span class="comment">//long startTime = System.currentTimeMillis();</span></span><br><span class="line">        merge(array, start, start + half - <span class="number">1</span>, start + half, end);</span><br><span class="line">        <span class="comment">//System.out.println("耗时："+(System.currentTimeMillis()-startTime)+"ms");</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用JavaDualPivotQuickSort串行处理较小的数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">computeSequentially</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//直接调用Arrays.sort 也可以</span></span><br><span class="line">        JavaDualPivotQuicksort.sort(array, start, end, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 快速合并两个有序数组   O(min(m,n))</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> leftStart</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> leftEnd</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rightStart</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rightEnd</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> leftStart, <span class="keyword">int</span> leftEnd, <span class="keyword">int</span> rightStart, <span class="keyword">int</span> rightEnd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array[leftEnd] &lt;= array[rightStart]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = leftStart;</span><br><span class="line">        <span class="keyword">int</span> j = rightStart;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len1 = leftEnd - leftStart + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len2 = rightEnd - rightStart + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[len1 + len2];</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= leftEnd &amp;&amp; j &lt;= rightEnd) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &lt;= array[j]) &#123;</span><br><span class="line">                temp[k++] = array[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[k++] = array[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == leftEnd + <span class="number">1</span> &amp;&amp; j &lt;= rightEnd) &#123;</span><br><span class="line">            System.arraycopy(array, j, temp, k, rightEnd - j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == rightEnd + <span class="number">1</span> &amp;&amp; i &lt;= leftEnd) &#123;</span><br><span class="line">            System.arraycopy(array, i, temp, k, leftEnd - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理完后将temp赋值给array</span></span><br><span class="line">        System.arraycopy(temp, <span class="number">0</span>, array, leftStart, len1);</span><br><span class="line">        System.arraycopy(temp, len1, array, rightStart, len2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码是比较好理解的，其要注意的地方是在排完序的两个有序数组合并上。</p><p>运行一下可以看到对于1亿数据量该方法耗时稳定在6~7s，Java源码的ParallelSort方法耗时在3~4s左右。</p><p>它们结果如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-525.jpg" alt="upload successful"></p><p>可以看到Java源码的排序处理速度要比我们实现的更高效的，速度差异主要在哪儿呢？</p><p>其实Java并行源码中借鉴了Cilk算法，但是有些不同的地方是，会把原数组分成四份进行并行排序。</p><p>算法说明如下：</p><ol><li>将数组分成4个子数组。</li><li>对前面两个子数组进行排序然后合并。</li><li>对后面的两个进行排序然后合并。<br>上面着几个步骤会重复递归，每个子数组都要求容量小于上面计算出来的临界值。</li></ol><p>我们回到<code>ArraysParallelSortHelpers</code>这个类从它里面的FJInt这个类入手，其他的类的实现和其类似。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-526.jpg" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-527.jpg" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-528.jpg" alt="upload successful"></p><p>根据上图的一些介绍，我再简单说明下。</p><p>其实上面图中Java源码这段代码是相当晦涩的，我们如何看出它每次是拆分成4个子任务并处理的呢？</p><p>我们可以根据第一次调用来看，这时候代码中的<code>b = this.base = 0</code>，<code>wb = this.wbase = 0</code>，则三个Sorter如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Sorter(rc, a, w, b+u, n-u, wb+u, g).fork();</span><br><span class="line"><span class="keyword">new</span> Sorter(rc, a, w, b+h, q, wb+h, g).fork();;</span><br><span class="line"><span class="keyword">new</span> Sorter(bc, a, w, b+q, h-q, wb+q, g).fork();</span><br></pre></td></tr></table></figure><p>代入b =0 可以看到，它们分别处理了[ u , u + n - u ],[ h , h + q ],[ q , q + h -q ] 三部分，正好是[ 3/4 , 1 ],[ 1/2 , 3/4 ],[ 1/4 , 1/2 ] 三部分。</p><p>而对于剩下的1/4 ，直接在当前线程处理（不需要fork），代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DualPivotQuicksort.sort(a, b, b + n - <span class="number">1</span>, w, wb, n);<span class="comment">//注：此时 n = q （对于当前线程）,可以看源码的赋值过程</span></span><br></pre></td></tr></table></figure><p>分别排序完了，需要进行合并，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (n &gt; g) &#123;</span><br><span class="line">    <span class="keyword">int</span> h = n &gt;&gt;&gt; <span class="number">1</span>, q = h &gt;&gt;&gt; <span class="number">1</span>, u = h + q; <span class="comment">// quartiles</span></span><br><span class="line">    Relay fc = <span class="keyword">new</span> Relay(<span class="keyword">new</span> Merger(s, w, a, wb, h, wb+h, n-h, b, g));</span><br><span class="line">    Relay rc = <span class="keyword">new</span> Relay(<span class="keyword">new</span> Merger(fc, a, w, b+h, q,b+u, n-u, wb+h, g));</span><br><span class="line">    <span class="keyword">new</span> Sorter(rc, a, w, b+u, n-u, wb+u, g).fork();</span><br><span class="line">    <span class="keyword">new</span> Sorter(rc, a, w, b+h, q, wb+h, g).fork();;</span><br><span class="line">    Relay bc = <span class="keyword">new</span> Relay(<span class="keyword">new</span> Merger(fc, a, w, b, q,b+q, h-q, wb, g));</span><br><span class="line">    <span class="keyword">new</span> Sorter(bc, a, w, b+q, h-q, wb+q, g).fork();</span><br><span class="line">    s = <span class="keyword">new</span> EmptyCompleter(bc);</span><br><span class="line">    n = q;</span><br><span class="line">&#125;</span><br><span class="line">DualPivotQuicksort.sort(a, b, b + n - <span class="number">1</span>, w, wb, n);</span><br><span class="line">s.tryComplete();</span><br></pre></td></tr></table></figure><p>这段Relay的依存关系是 rc （合并后1/2部分）和 bc （合并前1/2部分） 是并行的，fc 会合并rc和bc （排序好的数据）。</p><p>Java中把并行分成四份的优势在哪里呢？</p><p>明显这段代码和使用我们Cilk算法每次分成两份的本质是一样的，而且分成4份代码变得更加晦涩。</p><p>具体原因就要说说这个Merger了，这个Merger是关于两个有序数组并行合并的实现，它的效率是非常高的，我们回到我们自己实现的那个<code>ParallelSort</code>类，可以看到我们设计的merge就是比较常规的合并，当两个数组数据量越大时，耗时越长，我在代码中注掉了耗时计算，有兴趣的童鞋可以打开观察下，在数据量较小情况下，其耗时基本是0~10ms，但是运行中随着两部分待合并的数据越来越大，耗时越来越大。</p><p>比如对于1亿数据的排序，其耗时主要消耗在2个5000w的数据合并成最终结果、4个2500w的数据两两合并成2个5000w数据、8个1250w的数据两两合并成4个2500w数据……的合并上。</p><p>Java中的这个Merger对合并进行了优化，使用了并行合并，其原理如下：</p><ol><li>对于两个待合并数组A，B；</li><li>找到较大（或等于）的一个数组（比如A），如果长度小于阈值8192，就不分割了；如果大于8192，找到较大数组A的中点作为切割点M，使用二分法找到较小数组B中比这个切割点大的最小位置索引P；</li><li>这时候其实我们可以发现A中[lowA , M]和B中[lowB , P]位置数据合并后是始终 小于等于 A中[M , highA]和B中[P , highB]位置数据合并的，这就是分割合并有序的原则；</li><li>如果长度比较大，还会继续并行分割下去；</li><li>然后我们对上面拆分的数据两两合并，最终多线程执行完也就得到了有序数据。</li></ol><p>有兴趣的童鞋可以参考原理结合上图看一下。</p><p>而我们在排序及合并时，会用到工作数组，分成4份后，可以保证最后的排序完成数组在原数组中，而不是在工作数组中，也避免了一次数据拷贝。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于Java自带排序的内容就介绍到这儿，可以看到相比于串行排序，并行排序更加复杂，但是Cilk并行算法的原理还是比较简单的，Java并排代码之所以复杂是因为它尽可能的优化了算法耗时。</p><p>这也是软件开发者应当具有的品质：精益求精。</p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>关于自写的ParallelSort排序可见于我的 <a href="https://github.com/javazwt" rel="external nofollow noopener noreferrer" target="_blank">GitHub</a>。</p><p>关于 ArraysParallelSortHelpers相关代码可以参考JDK源码（1.8及以上版本）。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>JDK ArraysParallelSortHelpers源码</li><li>JDK Arrays源码</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="排序算法" scheme="https://www.sakuratears.top/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
      <category term="并行排序" scheme="https://www.sakuratears.top/tags/%E5%B9%B6%E8%A1%8C%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
</feed>
