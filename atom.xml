<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SakuraTears的博客</title>
  
  <subtitle>越努力越幸运</subtitle>
  <link href="https://www.sakuratears.top/atom.xml" rel="self"/>
  
  <link href="https://www.sakuratears.top/"/>
  <updated>2021-10-31T15:01:20.773Z</updated>
  <id>https://www.sakuratears.top/</id>
  
  <author>
    <name>SakuraTears</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Springboot MongoDB 实现自定义主键</title>
    <link href="https://www.sakuratears.top/blog/Springboot-MongoDB-%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%BB%E9%94%AE.html"/>
    <id>https://www.sakuratears.top/blog/Springboot-MongoDB-%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%BB%E9%94%AE.html</id>
    <published>2021-10-31T14:51:00.000Z</published>
    <updated>2021-10-31T15:01:20.773Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>MongoDB</code>使用<code>_id</code>作为文档内部数据主键，正常情况下，我们也默认使用它作为文档内部数据的主键，它默认是个<code>ObjectId</code>对象。</p><p>如下形式：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-949.png"></p><p>在<code>Java</code>中，它表现为字符串类型。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-950.png"></p><p>它在<code>MongoDB</code>中使用12字节的存储空间，每个字节两位十六进制数字，是一个24位的字符串。</p><p><code>ObjectId</code>的生成方式如下图：</p><table>    <tr>        <td>61</td>        <td>7b</td>        <td>db</td>        <td>ff</td>        <td>69</td>        <td>a0</td>        <td>5c</td>        <td>6d</td>        <td>95</td>        <td>4d</td>        <td>22</td>        <td>35</td>    </tr>    <tr>        <td><font color="blue">0</font></td>        <td><font color="blue">1</font></td>        <td><font color="blue">2</font></td>        <td><font color="blue">3</font></td>        <td><font color="red">4</font></td>        <td><font color="red">5</font></td>        <td><font color="red">6</font></td>        <td><font color="green">7</font></td>        <td><font color="green">8</font></td>        <td><font color="orange">9</font></td>        <td><font color="orange">10</font></td>        <td><font color="orange">11</font></td>    </tr>    <tr>        <td colspan = 4><font color="blue"><center>时间戳</center></font></td>        <td colspan = 3><font color="red"><center>机器</center></font></td>        <td colspan = 2><font color="green"><center>PID</center></font></td>        <td colspan = 3><font color="orange"><center>计数器</center></font></td>    </tr></table><ul><li>前4位是一个从标准纪元开始的时间戳，是一个<code>int</code>类别，只不过从十进制转换为了十六进制。这意味着这4个字节隐含了文档的创建时间，将会带来一些有用的属性。并且时间戳处于字符的最前面，同时意味着<code>ObjectId</code>大致会按照插入顺序进行排序，这对于某些方面起到很大作用，如作为索引提高搜索效率等等。使用时间戳还有一个好处是，某些客户端驱动可以通过<code>ObjectId</code>解析出该记录是何时插入的，这也解答了我们平时快速连续创 建多个<code>ObjectId</code>时，会发现前几位数字很少发现变化的现实，因为使用的是当前时间，很多用户担心要对服务器进行时间同步，其实这个时间戳的真实值并 不重要，只要其总不停增加就好。</li><li>接下来的3个字节，是所在主机的唯一标识符，一般是机器主机名的散列值，这样就确保了不同主机生成不同的机器<code>hash</code>值，确保在分布式中不造成冲突，这也就是在同一台机器生成的<code>ObjectId</code>中间的字符串都是一模一样的原因。</li><li>上面的机器字节是为了确保在不同机器产生的<code>ObjectId</code>不冲突，而<code>PID</code>就是为了在同一台机器不同的<code>MongoDB</code>进程产生了<code>ObjectId</code>不冲突。</li><li>前面的9个字节是保证了一秒内不同机器不同进程生成<code>ObjectId</code>不冲突，最后的3个字节是一个自动增加的计数器，用来确保在同一秒内产生的<code>ObjectId</code>也不会冲突，允许256的3次方等于16777216条记录的唯一性。</li></ul><p>由于<code>MongoDB</code>一开始设计就是用来做分布式数据库的，因此相比于关系型数据库（如<code>Mysql</code>）里的自增<code>id</code>，或者一些场景的<code>UUID</code>，其不仅能保证数据处理速度、唯一性要求，而且通过<code>ObjectId</code>本身，也能提供一些有用的信息。</p><table><thead><tr><th>主键类型</th><th>随机性</th><th>占用空间</th><th>并发支持</th><th>自身意义（自身包含的信息）</th></tr></thead><tbody><tr><td>自增Id</td><td>差</td><td>低</td><td>差</td><td>差</td></tr><tr><td>UUID</td><td>好</td><td>高</td><td>好</td><td>差</td></tr><tr><td>ObjectId</td><td>好</td><td>中</td><td>好</td><td>好</td></tr></tbody></table><p>但是，总有一些特殊情况，我们可能需要在<code>MongoDB</code>中使用自增<code>id</code>或者<code>UUID</code>，这种情况，我们应该如何处理呢？</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p><code>MongoDB</code>本身并没有提供自增主键或者<code>UUID</code>等的生成逻辑，但是我们可以通过程序，为指定的字段赋值。</p><p><strong>注</strong>：</p><blockquote><p>以下代码基于 springboot+mongodb</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb-reactive<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><p>我们先来看下<code>MongoDB</code>自身<code>ObjectId</code>的处理方式。</p><p>比如对于下面的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Document(collection = &quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String _id;</span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line">    <span class="keyword">private</span> Long longId;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String userSex;</span><br><span class="line">    <span class="keyword">private</span> String birthday;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其对应<code>MongoDB</code>中的<code>user</code>集合。</p><p><code>_id</code>表示文档的唯一<code>id</code>，即<code>ObjectId</code>，我们为其添加<code>@Id</code>注解，新增文档时，就会生成一个唯一的文档<code>id</code>。这是<code>Spring data</code>通用注解，当然我们也可以直接指定<code>@MongoDB</code>注解，而且<code>@MongoDB</code>注解可以自定义<code>Id</code>的转换形式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Document(collection = &quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MongoId(FieldType.OBJECT_ID)</span></span><br><span class="line">    <span class="comment">//默认FieldType.IMPLICIT，不填的话会根据_id的类型进行转换，转换方法：</span></span><br><span class="line">    <span class="comment">//org.springframework.data.mongodb.core.convert.MongoConverter.convertId(Object, Class).</span></span><br><span class="line">    <span class="keyword">private</span> String _id;</span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line">    <span class="keyword">private</span> Long longId;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String userSex;</span><br><span class="line">    <span class="keyword">private</span> String birthday;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，对于<code>ObjectId</code>，我们只需要添加注解即可以生成，无需过多关心。</p><p><strong>注</strong>：</p><blockquote><p>这儿要注意<code>FieldType</code>一旦确定了类型不要随便改哦，否则可能出现下面这样的问题。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-951.png"></p></blockquote><blockquote><p>这两个文档<code>_id</code>其实是不一样的，一个是用<code>FieldType.OBJECT_ID</code>生成的，一个是用<code>FieldType.STRING</code>生成的，我们改了<code>FieldType</code>类型，进行更新的时候，就会出现两个看起来很相似的文档了……</p></blockquote><p>再回到我们正题，假设我们想要一个唯一的<code>userId</code>（UUID）和一个唯一的<code>longId</code>（自增id）字段呢？</p><p>对于<code>userId</code>或者<code>longId</code>，当然我们可以在每次新增文档时，手动去进行设置，大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">......</span><br><span class="line">user.setUserId(UUID.randomUUID());<span class="comment">//UUID.randomUUID() 生成一个UUID</span></span><br><span class="line">user.setLongId(getNextLongId());<span class="comment">//getNextLongId()通过某种方法获取自增longId</span></span><br><span class="line">......</span><br><span class="line">userDao.save(user);</span><br></pre></td></tr></table></figure><p>这种操作并不方便，并且可能会有遗漏。</p><p>其实我们也可以和上面提到的<code>@Id</code>注解一样，自定义两个注解，一个代表自增主键，一个代表<code>UUID</code>。</p><p>然后通过获取注解并进行一些操作，为两个字段赋值。</p><p>我们来看下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> IncKey &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> UUIDKey &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义了两个注解<code>@IncKey</code>和<code>@UUIDKey</code>，一个代表自增主键，一个代表<code>UUID</code>。</p><p>要解析它们并且进行处理，需要在一个公共点，即应该在保存文档之前，所有文档的保存都应该过这个点。</p><p><code>spring-data-mongo</code>中恰好给我们提供了这样一个类，它在常用事件的生命周期内提供一些方法，我们来看下。</p><p><code>AbstractMongoEventListener</code>就是可以监听常用事件生命周期的一个<code>Abstract</code>类，其结构如下：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-952.png"></p><ul><li><p><code>onBeforeConvert</code>:在将对象转换为<code>Document</code>之前，在<code>MongoTemplate</code>中调用<code>insert</code>、<code>insertList</code>和<code>save</code>操作。  </p></li><li><p><code>onBeforeSave</code>:在数据库中插入或保存<code>Document</code>之前，在<code>MongoTemplate</code>中调用<code>insert</code>、<code>insertList</code>和<code>save</code>操作。  </p></li><li><p><code>onAfterSave</code>:在数据库中插入或保存<code>Document</code>之后，在<code>MongoTemplate</code> 中调用<code>insert</code>、<code>insertList</code>和<code>save</code>操作。  </p></li><li><p><code>onAfterLoad</code>:在从数据库检索文档之后，在<code>MongoTemplate</code>的<code>find</code>、<code>findAndRemove</code>、<code>findOne</code>和<code>getCollection</code>方法中调用。  </p></li><li><p><code>onAfterConvert</code>:在从数据库中检索到文档并转换为<code>POJO</code>之后，在<code>MongoTemplate</code>的<code>find</code>、<code>findAndRemove</code>、<code>findOne</code>和<code>getCollection</code>方法中调用。  </p></li><li><p><code>onAfterDelete</code>：在从数据库中删除一个或一组文档之后，在<code>MongoTemplate</code>的<code>remove</code>方法中调用。</p></li><li><p><code>onBeforeDelete</code>：在从数据库中删除一个或一组文档之前，在<code>MongoTemplate</code>的<code>remove</code>方法中调用。</p></li></ul><p>对于我们上述两个字段的赋值，我们可以在对象被转为<code>Documnet</code>之前进行设置，也就是重写<code>onBeforeConvert</code>方法。</p><p>方法中我们需要通过反射拿到有我们自定义注解的字段，然后对字段值进行赋值操作。</p><p>对于<code>UUID</code>的生成，还是比较简单的。然而如何生成自增主键呢？</p><p>我们先来看下整体代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MongoSaveEventListener</span> <span class="keyword">extends</span> <span class="title">AbstractMongoEventListener</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MongoTemplate mongoTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBeforeConvert</span><span class="params">(BeforeConvertEvent&lt;Object&gt; event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Object source = event.getSource();</span><br><span class="line">        <span class="keyword">if</span> (source != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ReflectionUtils.doWithFields(source.getClass(), field -&gt; &#123;</span><br><span class="line">                ReflectionUtils.makeAccessible(field);</span><br><span class="line">                <span class="comment">// 如果字段添加了我们自定义的IncKey注解</span></span><br><span class="line">                <span class="keyword">if</span> (field.isAnnotationPresent(IncKey.class)) &#123;</span><br><span class="line">                    Object value = field.get(source);</span><br><span class="line">                    <span class="keyword">if</span>(value == <span class="keyword">null</span>)&#123;</span><br><span class="line">                        <span class="comment">// 通过反射设置自增ID</span></span><br><span class="line">                        field.set(source, getNextId(source.getClass().getSimpleName()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(field.isAnnotationPresent(UUIDKey.class))&#123;</span><br><span class="line">                    <span class="comment">//如果字段添加了我们定义的UUIDKey注解 (两个注解不能同时添加，默认自增主键优先级高即可)</span></span><br><span class="line">                    Object value = field.get(source);</span><br><span class="line">                    <span class="keyword">if</span>(value == <span class="keyword">null</span>)&#123;</span><br><span class="line">                        <span class="comment">// 通过反射设置自增ID</span></span><br><span class="line">                        field.set(source,randomUUID());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取下一个自增id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> collName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Long <span class="title">getNextId</span><span class="params">(String collName)</span> </span>&#123;</span><br><span class="line">        Query query = <span class="keyword">new</span> Query(Criteria.where(<span class="string">&quot;collName&quot;</span>).is(collName));</span><br><span class="line">        Update update = <span class="keyword">new</span> Update();</span><br><span class="line">        update.inc(<span class="string">&quot;seqId&quot;</span>, <span class="number">1</span>);  <span class="comment">//每次自增1</span></span><br><span class="line">        FindAndModifyOptions options = <span class="keyword">new</span> FindAndModifyOptions();</span><br><span class="line">        options.upsert(<span class="keyword">true</span>); <span class="comment">//更新</span></span><br><span class="line">        options.returnNew(<span class="keyword">true</span>);<span class="comment">//返回更新后的文档</span></span><br><span class="line">        <span class="comment">//操作Sequence表,对其seqId加一并且返回最终值</span></span><br><span class="line">        Sequence seq = mongoTemplate.findAndModify(query, update, options, Sequence.class);</span><br><span class="line">        <span class="keyword">return</span> seq.getSeqId();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断字符串是否为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cs</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">(CharSequence cs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cs == <span class="keyword">null</span> || cs.length() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成uuid</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">randomUUID</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UUID.randomUUID().toString()</span><br><span class="line">                .replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，对于自增主键，我们使用了<code>getNextId</code>来获取，需要传入<code>collName</code>，这是针对于每个集合，自增主键都是从0开始单独计数。</p><p>我们创建了一个<code>sequence</code>集合用来保存其它需要自增主键的集合当前的自增主键<code>id</code>值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Document(collection = &quot;sequence&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String _id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 集合名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String collName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 唯一自增id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long seqId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用了<code>mongoTemplate</code>的<code>findAndModify</code>操作，该操作具有原子性，可以保证并发情况下的数据正确性。</p><p>我们写上<code>Dao</code>层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MongoTemplate mongoTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">save</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        mongoTemplate.save(user);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getByLongId</span><span class="params">(Long longId)</span></span>&#123;</span><br><span class="line">        Criteria criteria = Criteria.where(<span class="string">&quot;longId&quot;</span>).is(longId);</span><br><span class="line">        Query query = <span class="keyword">new</span> Query(criteria);</span><br><span class="line">        <span class="keyword">return</span> mongoTemplate.findOne(query,User.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后用测试类进行测试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Document(collection = &quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String _id;</span><br><span class="line">    <span class="meta">@UUIDKey</span></span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line">    <span class="meta">@IncKey</span></span><br><span class="line">    <span class="keyword">private</span> Long longId;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String userSex;</span><br><span class="line">    <span class="keyword">private</span> String birthday;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">user.setUserName(<span class="string">&quot;zwt&quot;</span>);</span><br><span class="line">user.setUserSex(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">user.setBirthday(<span class="string">&quot;1991-09-09&quot;</span>);</span><br><span class="line">userDao.save(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后可以看到生成的<code>Document</code>携带 <code>longId</code>和<code>userId</code>。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-953.png"></p><p>我们把<code>User</code>上的两个自定义注解去掉，运行就会发现新生成的文档不会携带这两个字段。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-954.png"></p><p>由于我们判断的是有自定义注解时，该字段为空才当作新增处理，因此如果我们对文档进行修改或删除（非此两个字段），并不会影响到它们。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//User user = new User();</span></span><br><span class="line"><span class="comment">//user.setUserName(&quot;zwt&quot;);</span></span><br><span class="line"><span class="comment">//user.setUserSex(&quot;男&quot;);</span></span><br><span class="line"><span class="comment">//user.setBirthday(&quot;1991-09-09&quot;);</span></span><br><span class="line">User user = userDao.getByLongId(<span class="number">4L</span>);</span><br><span class="line">user.setUserName(<span class="string">&quot;112121212&quot;</span>);</span><br><span class="line">userDao.save(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-955.png"></p><p>最后<code>demo</code>项目整体结构如下图，上述代码既是该<code>demo</code>的全部代码。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-956.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文我们学到了如何操作<code>mongoTemplate</code>生成自定义主键的问题。</p><p>其实<code>mongodb</code>大部分场景不需要我们去手动生成主键，既不方便也不实用。</p><p>但通过这篇文章，我们还可以了解到一些方法，如想在文档保存前进行其他一些操作，那么根据上述方法，也能轻松应对处理。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://spring.getdocs.org/en-US/spring-data-docs/spring-data-mongodb/reference/mongo.core/mongodb.mapping-usage.events.html">Spring data docs - Lifecycle Events</a></li><li><a href="https://docs.mongodb.com/manual/reference/command/findAndModify/#behavior">mongodb API - findAndModify</a></li><li><a href="https://blog.csdn.net/qq_16313365/article/details/72781469">Java中实现MongoDB自增主键ID</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;MongoDB&lt;/code&gt;使用&lt;code&gt;_id&lt;/code&gt;作为文档内部数据主键，正常情况下，我们也默认使用它作为文档内部数据的主键，它默认是个&lt;code&gt;ObjectId&lt;/code&gt;对象。&lt;/p&gt;
&lt;p&gt;如下形式：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&quot;https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-949.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Springboot" scheme="https://www.sakuratears.top/tags/Springboot/"/>
    
    <category term="MongoDB" scheme="https://www.sakuratears.top/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>记一次线上OOM问题排查</title>
    <link href="https://www.sakuratears.top/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8AOOM%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5.html"/>
    <id>https://www.sakuratears.top/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8AOOM%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5.html</id>
    <published>2021-09-21T06:26:00.000Z</published>
    <updated>2021-09-21T06:48:32.673Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前几天，我们生产环境的管理后台出现了问题，运营给我们反映说后台无法正常登陆，无法打开，我们根据日志，查询到了后台程序出现了<code>OutOfMemoryError</code>异常，这个问题我们处理了很久，主要原因是由于我们优化不够造成的问题。</p><p>特此用此文章记录一下自己的处理过程。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="一波三折"><a href="#一波三折" class="headerlink" title="一波三折"></a>一波三折</h2><p>我的处理流程大致是这样的。</p><p>首先，我在日志里使用<code>grep</code>指令分析了下<code>OutOfMemoryError</code>异常数量，发现有很多。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &#x27;OutOfMemoryError&#x27; -A 10 -B 10 catalina.out</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-920.png"></p><p>出现的记录非常多。</p><p>然后，通过<code>top</code>指令分析当前<code>java</code>进程情况。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-921.png"></p><p>可以看到此时管理后台<code>java</code>进程已经使用了<code>2.4G</code>内存，其进程<code>pid</code>为<code>10070</code>。</p><p>而后我想使用<code>jmap</code>指令分析下堆内存使用情况。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -heap 10070</span><br></pre></td></tr></table></figure><p>但是却失败了，有如下提示。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error attaching to process: sun.jvm.hotspot.debugger.DebuggerException: cannot open binary file</span><br></pre></td></tr></table></figure><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-922.png"></p><p>后续经过查阅相关资料，确定是自己用户权限不足的问题导致的。</p><p>遂请运维管理员帮忙执行相关语句。</p><p>主要有三个语句。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jmap -heap 10070</span><br><span class="line">jmap -histo 10070</span><br><span class="line">jmap -dump:format=b,file=20210901Heap.dump 10070</span><br></pre></td></tr></table></figure><p>第一条语句<code>jmap -heap 10070</code>用来查看当前<code>OOM</code>后堆内存使用情况。</p><p>第二条语句<code>jmap -histo 10070</code>用来查看当前<code>OOM</code>后堆内存对象分布情况。</p><p>第三条语句<code>jmap -dump:format=b,file=20210901Heap.dump 10070</code>用来导出<code>dump</code>文件。</p><p>不幸的是运维管理员跟我们反馈执行不成功，输出如下。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-923.png"></p><p>提示<code>Unable to open socket file: target process not responding or HotSpot VM not loaded</code>错误。</p><p>这个异常查阅相关资料后，我确定为启动用户不一致导致的问题，就是<code>java</code>进程是<code>hcadmin</code>用户启动的，而管理员用的<code>root</code>用户。</p><p>而后其切换到<code>hcadmin</code>用户，运行正常，导出数据。</p><p>接下来我们就分析<code>OOM</code>异常的主要原因。</p><h2 id="进入正题"><a href="#进入正题" class="headerlink" title="进入正题"></a>进入正题</h2><h3 id="jmap-heap"><a href="#jmap-heap" class="headerlink" title="jmap -heap"></a>jmap -heap</h3><p>首先我们先看从运维管理员拿到的第一条命令生成的数据。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -heap 10070</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">Attaching to process ID 10070, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.112-b15</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with 2 thread(s)</span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         = 0</span><br><span class="line">   MaxHeapFreeRatio         = 100</span><br><span class="line">   MaxHeapSize              = 2051014656 (1956.0MB)</span><br><span class="line">   NewSize                  = 42991616 (41.0MB)</span><br><span class="line">   MaxNewSize               = 683671552 (652.0MB)</span><br><span class="line">   OldSize                  = 87031808 (83.0MB)</span><br><span class="line">   NewRatio                 = 2</span><br><span class="line">   SurvivorRatio            = 8</span><br><span class="line">   MetaspaceSize            = 21807104 (20.796875MB)</span><br><span class="line">   CompressedClassSpaceSize = 1073741824 (1024.0MB)</span><br><span class="line">   MaxMetaspaceSize         = 17592186044415 MB</span><br><span class="line">   G1HeapRegionSize         = 0 (0.0MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = 228589568 (218.0MB)</span><br><span class="line">   used     = 150133920 (143.17886352539062MB)</span><br><span class="line">   free     = 78455648 (74.82113647460938MB)</span><br><span class="line">   65.67837776394066% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = 227540992 (217.0MB)</span><br><span class="line">   used     = 1238272 (1.180908203125MB)</span><br><span class="line">   free     = 226302720 (215.819091796875MB)</span><br><span class="line">   0.5441973286290323% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = 227540992 (217.0MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 227540992 (217.0MB)</span><br><span class="line">   0.0% used</span><br><span class="line">PS Old Generation</span><br><span class="line">   capacity = 1367343104 (1304.0MB)</span><br><span class="line">   used     = 829379544 (790.9579696655273MB)</span><br><span class="line">   free     = 537963560 (513.0420303344727MB)</span><br><span class="line">   60.656286017295045% used</span><br><span class="line"></span><br><span class="line">67634 interned Strings occupying 7793656 bytes.</span><br></pre></td></tr></table></figure><p>可以看到使用的是<code>Parallel GC</code>。</p><p>先看下目前堆内存配置情况，<code>NewRatio=2</code>即<code>年轻代：老年代=1:2</code>。</p><p>可以看到<code>MaxHeapSize=1956.0MB</code>，老年代占<code>2/3</code>，老年代大小应为<code>1304M</code>。</p><p>正好对应上面<code>PS Old Generation</code>的<code>capacity</code>。</p><p>我们这儿还可以看到配置的<code>SurvivorRatio=8</code>，即 <code>Eden:From:To=8:1:1</code>。</p><p>这儿可以算出<code>Eden Space</code>大小为 521.6M。<br>$$<br>1956 \times \frac{1}{3} \times \frac{8}{8+1+1} = 521.6<br>$$<br>但实际我们看到<code>Heap Usage</code>里面，<code>Eden:From:To</code>的比例根据<code>capacity</code>来说是<code>1:1:1</code>。</p><p>这儿的原因是因为<code>JDK 1.8</code> 默认使用 <code>UseParallelGC</code> 垃圾回收器，该垃圾回收器默认启动了 <code>AdaptiveSizePolicy</code>(自适应大小策略)，会根据<code>GC</code>的情况自动计算计算 <code>Eden</code>、<code>From</code> 和 <code>To</code> 区的大小，要使<code>-XX:SurvivorRatio</code>生效，就需要关闭该策略 <code>-XX:-UseAdaptiveSizePolicy</code>。</p><p>PS：开启策略参数为<code>-XX:+UseAdaptiveSizePolicy</code>。</p><p>也可以看到目前我们管理后台的<code>JVM</code>都是采用的默认值，未进行相关优化。</p><p>根据<code>Heap Usage</code>，我们可以看到年老代使用了<code>61%</code>，年轻代使用了<code>66%</code>。</p><p>我们可以看到，<code>OOM</code>时，年轻代或老年代并没有被打满，我们继续分析下面的脚本结果。</p><h3 id="jmap-histo"><a href="#jmap-histo" class="headerlink" title="jmap -histo"></a>jmap -histo</h3><p>我们再来看下第二个指令生成的结果。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -histo 10070</span><br></pre></td></tr></table></figure><p>由于结果数据较多，我们以图片的形式来看关键的部分。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-924.png"></p><p>其中<code>#instances</code> 为实例个数， <code>#bytes</code>为字节大小， <code>class name</code> 是对应的对象类型。</p><blockquote><p>B  表示byte</p></blockquote><blockquote><p>C  表示char</p></blockquote><blockquote><p>D  表示double</p></blockquote><blockquote><p>F  表示float</p></blockquote><blockquote><p>S  表示short</p></blockquote><blockquote><p>I   表示int</p></blockquote><blockquote><p>J   表示long</p></blockquote><blockquote><p>Z  表示boolean</p></blockquote><blockquote><p><code>[</code>  表示数组，如<code>[I</code>表示<code>int[]</code></p></blockquote><blockquote><p><code>[L</code>+类名  表示其他对象</p></blockquote><p>可以看到<code>[C</code>即<code>char</code>数组占用了<code>382M</code>左右，这一般是创建了大量<code>String</code>导致的，<code>String</code>底层就是由<code>char</code>数组构成的。</p><p>属于我们项目的一个<code>VO</code>类，即<code>LateAccountVO</code>占用了<code>220M</code>左右。</p><p><code>LateAccountVO</code>有多处地方被使用，且里面<code>String</code>字段也较多，这也是<code>[C</code>内存占用量大的原因。</p><p><code>LateAccountVO</code>主要服务于我们管理后台的一个报表功能，这个功能关联表比较多，涉及到的显示项也是比较多的。</p><h3 id="jmap-dump"><a href="#jmap-dump" class="headerlink" title="jmap -dump"></a>jmap -dump</h3><p>我们再来分析下下述指令产生的<code>dump</code>文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format=b,file=20210901Heap.dump 10070</span><br></pre></td></tr></table></figure><p>文件比较大，我们使用<code>dump</code>分析工具来分析一下，把后缀改成<code>hprof</code>以便后续处理。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-925.png"></p><p>我们这儿使用<code>MAT</code>来分析一下它。</p><p><code>MAT</code>的下载地址：<a href="https://www.eclipse.org/mat/downloads.php">https://www.eclipse.org/mat/downloads.php</a></p><p>下载安装好后，直接打开我们的<code>dump</code>文件即可。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-926.png"></p><p>在<code>Overview</code>页面，我们主要看这几项。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-927.png"></p><ul><li>Histogram：内存对象直方图。</li></ul><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-928.png"></p><p>上图可以看到占用较多的也是<code>char[]</code>。</p><ul><li>Dominator Tree：对象内存占用情况树图</li></ul><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-929.png"></p><p>​    可以看到占用内存最多的为<code>WebappClassLoader</code>，占用了大概<code>11.90%</code>。</p><ul><li>Top Consumers：对象内存占用扇形图</li></ul><p>​    <img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-930.png"></p><p>它也能帮我们找到大对象相关的一些信息。</p><ul><li>Leak Suspects：内存泄漏分析</li></ul><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-931.png"></p><p>可以看到它为我们分析出了两处可能存在内存泄漏的对象。</p><p>一个是<code>WebappClassLoader</code>，一个是<code>TaskThread</code>。</p><p>但这两个类是三方<code>jar</code>包相关的类，目前看来没法给我们提供有效帮助。</p><h2 id="曲折过程"><a href="#曲折过程" class="headerlink" title="曲折过程"></a>曲折过程</h2><p>我们重启了线上项目，并和运维相关人员申请了<code>hcadmin</code>的相关权限，当然只能申请到<code>sudo</code>权限。</p><p>这样我们就可以在线上实时查看<code>jvm</code>的运行情况。</p><p>操作如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo su hcadmin</span><br><span class="line">jmap -heap xxxx</span><br><span class="line">jmap -histo xxxx | more</span><br></pre></td></tr></table></figure><p>我们实时分析结果如下，先来看下<code>jmap -heap</code>，某一次的分析如下。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-932.png"></p><p>可以看到其实开始时<code>jvm</code>内存是动态分配的，不够时再尝试扩容。</p><p>申请到<code>hcadmin</code>的权限后，我们看了下<code>tomcat</code>的参数配置，如下：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-948.png"></p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-933.png"></p><p>可以看到未对<code>jvm</code>有任何优化操作。</p><p>这儿我们尝试对<code>jvm</code>做出如下优化：</p><p><strong>优化点 一</strong></p><p>我们可以设置<code>-Xms</code>和<code>-Xmx</code>参数，让其它两个相等，避免<code>jvm</code>动态扩充内存进而导致的时间浪费，每个线程大小也可以设置下。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms2048M -Xmx2048M -Xss256K</span><br></pre></td></tr></table></figure><p><strong>优化点 二</strong></p><p>新生代、<code>Eden Space</code>和<code>Survivor Space</code>的比例设置下。</p><p>这儿参考最上面<code>jmap -heap</code>的参数，我的设置如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:NewRatio=2 -XX:SurvivorRatio=6</span><br></pre></td></tr></table></figure><p>这样年轻代占用内存为：<br>$$<br>2048 \times \frac{1}{3} = 682.7 (M)<br>$$<br>年老代占用内存为： 1365.3 M</p><p>这样分的话是参考上面<code>OOM</code>时的一些配置，我们先设置此配置，如果后续仍有问题，需要继续调整。</p><p><strong>优化点 三</strong></p><p>垃圾回收器的选择。</p><p><code>JDK 1.8</code>支持的垃圾回收器及其使用场景如下表：</p><table><thead><tr><th>垃圾收集器</th><th>分类</th><th>作用位置</th><th>使用算法</th><th>特点</th><th>适用场景</th></tr></thead><tbody><tr><td>Serial</td><td>串行运行</td><td>新生代</td><td>复制算法</td><td>响应速度优先</td><td>适用于单CPU下的client模式</td></tr><tr><td>ParNew</td><td>并行运行</td><td>新生代</td><td>复制算法</td><td>响应速度优先</td><td>多CPU环境server模式下与CMS配合使用</td></tr><tr><td>Parallel</td><td>并行运行</td><td>新生代</td><td>复制算法</td><td>吞吐量优先</td><td>适用于后台运算而不需要太多交互的场景</td></tr><tr><td>Serial Old</td><td>串行运行</td><td>老年代</td><td>标记-压缩算法</td><td>响应速度优先</td><td>适用于单CPU下的client模式</td></tr><tr><td>Parallel Old</td><td>并行运行</td><td>老年代</td><td>标记-压缩算法</td><td>吞吐量优先</td><td>适用于后台运算而不需要太多交互的场景</td></tr><tr><td>CMS</td><td>并发运行</td><td>老年代</td><td>标记-清除算法</td><td>响应速度优先</td><td>适用于互联网或B/S业务</td></tr><tr><td>G1</td><td>并行、并发运行</td><td>新生代、老年代</td><td>标记-压缩算法、复制算法</td><td>响应速度优先</td><td>面向服务端应用</td></tr></tbody></table><p>我们的管理后台目前采用的默认的垃圾收集器。</p><p>即 Parallel + Parallel Old。</p><p>由于管理后台提供给业务方，涉及到不少的用户行为交互操作，应该以响应速度为较高优先级目标。</p><p>因此这儿我们改用组合 ParNew + CMS 的垃圾回收器策略。</p><p>由于CMS使用的是标记-清除算法，我们老年代会产生内存碎片，因此开启CMS后，需要添加压缩参数。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSFullGCsBeforeCompaction=0 -XX:+UseCMSCompactAtFullCollection -XX:CMSInitiatingOccupancyFraction=70</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>-XX:+UseParNewGC ：指定新生代使用 ParNew 垃圾收集器。</li><li>-XX:+UseConcMarkSweepGC ： 指定老年代使用 CMS 垃圾收集器。</li><li>-XX:CMSFullGCsBeforeCompaction=0 ： 表示CMS执行了多少次不压缩的FullGC后，来一次压缩的FullGC，这儿设置的0，表示每次FullGC都会进行内存碎片压缩。</li><li>-XX:+UseCMSCompactAtFullCollection ：开启 CMS 的 FullGC后的压缩，默认就是开启的。</li><li>-XX:CMSInitiatingOccupancyFraction=70 ：表示老年代空间使用到 70% 后就开始执行 CMS 收集，以确保老年代有足够的空间接纳新的对象。</li></ul><p>我们的最终配置如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPTS=<span class="string">&quot; -server -Xms2048M -Xmx2048M -Xss256K -XX:NewRatio=2 -XX:SurvivorRatio=6 -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSFullGCsBeforeCompaction=0 -XX:+UseCMSCompactAtFullCollection -XX:CMSInitiatingOccupancyFraction=70 -XX:-PrintGCDetails -XX:-PrintGCTimeStamps -javaagent:/usr/local/jmx_exporter/jmx_prometheus_javaagent-0.12.0.jar=9982:/usr/local/jmx_exporter/jmx_exporter.yml&quot;</span></span><br></pre></td></tr></table></figure><p>我们需要修改<code>tomcat</code>下的<code>catalina.sh</code>文件，在<code>linux</code>下可以使用<code>vi</code>命令修改。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-934.png"></p><p>配置好后，我们重启应用。如下：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-935.png"></p><p>可以看到我们的配置已经生效了。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-936.png"></p><p>我们需要继续监控一段时间看看系统运行情况，及是否可能存在内存泄漏情况。</p><h2 id="实时监控"><a href="#实时监控" class="headerlink" title="实时监控"></a>实时监控</h2><p>由于我们上面的<code>jvm</code>参数配置只是实验性的，我们后续需要实时跟踪<code>jvm</code>的运行情况。</p><p>连续监控了2-3后，发现老年代内存占用已经达到了 48% 左右，这对我们来说不是正常情况。</p><p>我们通过命令分析当前内存对象分布。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jmap -heap xxxx</span><br><span class="line">jmap -histo xxxx | more</span><br></pre></td></tr></table></figure><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-937.png"></p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-938.png"></p><p>我们发现<code>String</code>对象（char[]）占用大量内存，并且发现了一个一直存在的类<code>OjkReportAFPI</code>。</p><p>这个类是我们一个数据上报任务用的，有个定时任务，每天会执行一次。</p><p>而且我监控发现每隔一天，内存就有较大幅度占用上涨。</p><p>经过检查代码，我们跟踪这个类的相关调用方，发现了一些可能是代码导致内存膨胀（泄漏）的原因。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-939.png"></p><p>此段代码存在大量<code>String</code>拼接，建议使用<code>StringJoiner</code>或者<code>StringBuilder</code>类来处理。</p><p>另外额外发现了前同事自己封装的工具类一些流未关闭的问题。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-940.png"></p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-941.png"></p><p>上述都是流未关闭的部分，可能存在内存泄漏问题。</p><h2 id="进一步分析"><a href="#进一步分析" class="headerlink" title="进一步分析"></a>进一步分析</h2><p>我们使用<code>jstat</code>相关指令进行分析。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -gcutil 21729</span><br></pre></td></tr></table></figure><p>此命令可以分析<code>GC</code>情况。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-942.png"></p><p>上图比较重要的结果就是<code>YGC（Young GC）</code>发生了215次，<code>FGC (Full GC)</code>发生了6次，并记录了<code>GC</code>时间等相关信息。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -gccause 21729</span><br></pre></td></tr></table></figure><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-943.png"></p><p><code>gccause</code>指令可以让我们看到最近发生的一次<code>GC</code>的原因，我们看到为<code>Allocation Failure</code>。</p><p>而后我们使用了一次如下指令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -histo:live 21729|more</span><br></pre></td></tr></table></figure><p>使用<code>live</code>指令后，在观察<code>jvm</code>内存使用情况，如下：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-944.png"></p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-945.png"></p><p>可以看到内存占用减小了，并且<code>OjkReportAFPI</code>对象消失了。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-946.png"></p><p><code>GC</code>原因是<code>Heap Inspection Initiated GC</code> ，这是由于<code>jmap -histo:live</code>命令会触发<code>FullGC</code>。</p><p>也就可以证明其实我们的<code>OjkReportAFPI</code>对象被分配到了老年代（或者到了年龄移动到了老年代）。其实就是大对象的分配问题。</p><p>我们这个数据上报任务，每天运行会拉取大量数据，组成一个<code>OjkReportAFPI</code> <code>VOList</code>，这个对象由于比较大，在年轻代空间不足时会直接分配到老年代。</p><p>导致我们只有经过<code>Full GC</code>才能回收掉此对象。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-947.png"></p><p>关于这一部分，我们的优化方案是将该部分改为批处理，这样每批占用内存较小，可以保证其生成在<code>Eden Space</code>，而不是直接进入老年代。</p><p>另外年轻代与老年代的比例也可能需要在调整优化下。</p><h2 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h2><p>根据上面的分析，我们最终处理过程如下：</p><ol><li>优化代码（流未关闭的问题，String的问题，业务批量处理等）；</li><li>为年轻代多分配一些内存，由于我们目前业务内存8G，目前只有我们这一个应用，因此我们又给应用多分配了一些内存，针对于年轻代。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过本次对JVM的调整，我学到了不少知识，同时发现并解决了系统中的一些问题。</p><p>还是蛮不错的一次经历。</p>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前几天，我们生产环境的管理后台出现了问题，运营给我们反映说后台无法正常登陆，无法打开，我们根据日志，查询到了后台程序出现了&lt;code&gt;OutOfMemoryError&lt;/code&gt;异常，这个问题我们处理了很久，主要原因是由于我们优化不够造成的问题。&lt;/p&gt;
&lt;p&gt;特此用此文章记录一下自己的处理过程。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h1&gt;</summary>
    
    
    
    <category term="工作" scheme="https://www.sakuratears.top/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
    <category term="OOM" scheme="https://www.sakuratears.top/tags/OOM/"/>
    
    <category term="JVM调优" scheme="https://www.sakuratears.top/tags/JVM%E8%B0%83%E4%BC%98/"/>
    
    <category term="线上问题" scheme="https://www.sakuratears.top/tags/%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>荣耀上机试题两道分享</title>
    <link href="https://www.sakuratears.top/blog/%E8%8D%A3%E8%80%80%E4%B8%8A%E6%9C%BA%E8%AF%95%E9%A2%98%E4%B8%A4%E9%81%93%E5%88%86%E4%BA%AB.html"/>
    <id>https://www.sakuratears.top/blog/%E8%8D%A3%E8%80%80%E4%B8%8A%E6%9C%BA%E8%AF%95%E9%A2%98%E4%B8%A4%E9%81%93%E5%88%86%E4%BA%AB.html</id>
    <published>2021-09-14T13:16:00.000Z</published>
    <updated>2021-09-14T13:21:49.058Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前些日子面试了荣耀终端，面试过程是比较漫长的，但结果还是比较满意的。</p><p>目前已全部面试通过，处于等<code>offer</code>的阶段。</p><p>荣耀面试总共分为下面几部分：</p><ol><li>上机心理测评（填一些心理测试题）；</li><li>上机试题；</li><li>技术一面；</li><li>技术二面；</li><li>HR面试；</li><li>综合面试。</li></ol><p>其实上机试题完就想找时间整理下自己做的两道机试题，但苦于前面一直腾不出太多时间。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>好了，废话不多说，我下面直接分享下我上机实验的两道试题吧。</p><h2 id="试题一"><a href="#试题一" class="headerlink" title="试题一"></a>试题一</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>题目大意如下：</p><p>现定义一种字符编码，编码格式为：<br>9个字符为一个编码组；<br>第一个字符表示之后8个字符的字节序，‘0’表示小端，‘1’表示大端；<br>编码之后按照大端排序；<br>例如编码组：‘012345678’，解析之后为’87654321’，‘112345678’，解析之后为’12345678’；</p><blockquote><p>输入：<br>第一行输入字符串中编码组个数N；<br>第二行为字符串；<br>输出：<br>输出只有一行，包含N个编码组的解析结果，按照大端排序，每一个编码组结果以一个空格分开，行末没有空格。</p></blockquote><p>样例：<br>输入：</p><blockquote><p>2<br>0abcdefgh1abcdefgh</p></blockquote><p>输出：</p><blockquote><p>hgfedcba abcdefgh</p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>可以看到这道题主要考察字符串解析以及字符串逆序等内容。</p><p>当时在做试题的时候，写下的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> a = in.nextInt();</span><br><span class="line">        String b = in.next();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> flag = b.startsWith(<span class="string">&quot;0&quot;</span>)||b.startsWith(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="keyword">boolean</span> flag1 = b.length()/<span class="number">9</span> == a;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!flag||(!flag1))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;参数错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a;i++)&#123;</span><br><span class="line">            String sub = b.substring(p,p+<span class="number">9</span>);</span><br><span class="line">            <span class="keyword">if</span>(sub.startsWith(<span class="string">&quot;0&quot;</span>))&#123;</span><br><span class="line">                <span class="comment">//倒叙</span></span><br><span class="line">                sub = sub.substring(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">char</span>[] c = sub.toCharArray();</span><br><span class="line">                StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i1 = c.length - <span class="number">1</span>; i1 &gt;= <span class="number">0</span>; i1--) &#123;</span><br><span class="line">                    sb.append(c[i1]);</span><br><span class="line">                &#125;</span><br><span class="line">                stringBuilder.append(sb).append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                stringBuilder.append(sub.substring(<span class="number">1</span>)).append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            p=p+<span class="number">9</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(stringBuilder.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>PS：因为考试时允许使用本地IDEA，我是在本地IDEA上编码完成放到试卷上的。因此我IDEA上还保留着之前试题的代码。</p></blockquote><p>通过上述代码可以了解到我的简单思路：</p><ol><li>校验（需要保证每9个字符一组，编码个数和算出来的相等）；</li><li>拆分（根据’0’与’1’来进行拆分，即大端小端）；</li><li>小端的话字符串顺序要倒过来（倒序时使用了<code>StringBuilder</code>进行辅助）。</li></ol><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>上面的代码看了一下，自己对其还是不太满意的，现在时间充裕，我们就来优化一下。</p><p>我上述代码有四个问题，如下图：</p><ul><li><p>一些判断可以整合；</p></li><li><p>除法精度问题；</p></li><li><p><code>if(sub.startsWith(&quot;0&quot;))</code>后接<code>else</code>，如果输入的一个串不是<code>0</code>，那么会进入<code>1</code>的逻辑（大端）,这就会有问题；</p></li><li><p>字符串倒序这块，有没有更好的处理方法？</p></li></ul><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-916.png"></p><p>我们带着这些问题，重新编写代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPrefectDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> a = in.nextInt();</span><br><span class="line">        String b = in.next();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更严谨的校验</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = b.length() / <span class="number">9</span> == a &amp;&amp; b.length() % <span class="number">9</span> ==<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;参数错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a; i++) &#123;</span><br><span class="line">            String sub = b.substring(p,p+<span class="number">9</span>);</span><br><span class="line">            <span class="keyword">if</span>(sub.startsWith(<span class="string">&quot;0&quot;</span>))&#123;</span><br><span class="line">                <span class="comment">//小端模式，需要翻转</span></span><br><span class="line">                sub = sub.substring(<span class="number">1</span>);</span><br><span class="line">                <span class="comment">//字符串翻转</span></span><br><span class="line">                sb.append(<span class="keyword">new</span> StringBuilder(sub).reverse()).append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sub.startsWith(<span class="string">&quot;1&quot;</span>))&#123;</span><br><span class="line">                <span class="comment">//大端模式</span></span><br><span class="line">                sb.append(sub.substring(<span class="number">1</span>)).append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//既不为0也不为1的处理</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;参数错误&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            p+=<span class="number">9</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码我把出现的问题都修复了，并且了解到了<code>AbstractStringBuilder</code>类中的<code>reverse</code>方法，可以实现字符串的翻转。</p><p><code>AbstractStringBuilder</code>是<code>StringBuffer</code>和<code>StringBuilder</code>的父类，我们来看下它是如何实现字符串翻转的。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-917.png"></p><p>可以看到字符串翻转时，只需要循环一半长度，而后进行交换即可，同时代码里还处理了<code>unicode</code>的情况。</p><h2 id="试题二"><a href="#试题二" class="headerlink" title="试题二"></a>试题二</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>查找组成一个偶数最接近的两个素数。</p><p>任意一个偶数（大于2）都可以由2个素数组成，组成偶数的2个素数有很多种情况，本题目要求输出组成指定偶数的两个素数差值最小的素数对。</p><p>如果找不到或者输入错误，返回0即可。</p><p>样例：</p><p>输入：</p><blockquote><p>6</p></blockquote><p>输出：</p><blockquote><p>3 3</p></blockquote><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>这道题目主要考察对素数的认知和二分法的概念。</p><p>当时在做试题时，我提交的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> k = scanner.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//k为偶数</span></span><br><span class="line">        <span class="keyword">if</span>(k%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> half = k/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (half &gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isPrime(half))&#123;</span><br><span class="line">                <span class="keyword">if</span>(isPrime(k-half))&#123;</span><br><span class="line">                    System.out.println(half+<span class="string">&quot; &quot;</span>+(k-half));</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            half--;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;x;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x%i==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述代码可以了解到我的思路：</p><ol><li>校验输入；</li><li>需要提供一个判断素数的方法；</li><li>对提供的偶数进行二分法处理，而后判断得到的两个值是否符合条件。</li></ol><h3 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h3><p>上述代码有没有可以优化的地方呢？我们来看一下。</p><h4 id="优化点一"><a href="#优化点一" class="headerlink" title="优化点一"></a>优化点一</h4><p>首先关于素数的校验，经过网上查阅，我发现我是使用了一种可以说是最慢的处理方法。</p><p>判断一个数是不是素数，通常情况下有3种方法。</p><h5 id="暴力求解法"><a href="#暴力求解法" class="headerlink" title="暴力求解法"></a>暴力求解法</h5><p>也就是上面我用到的方法。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrime1</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;x;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x % i==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法从<code>2</code>遍历到<code>n-1</code>，然后依次判断，时间复杂度为<code>O(n)</code>。</p><h5 id="二分开方遍历法"><a href="#二分开方遍历法" class="headerlink" title="二分开方遍历法"></a>二分开方遍历法</h5><p>额，这个名字起得也不太好，方法的主要内容如下：</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个数若可以进行因数分解，那么分解时得到的两个数一定是一个小于等于 sqrt (n)，一个大于等于 sqrt (n)</span><br></pre></td></tr></table></figure></blockquote><p>我们以素数17来看，它能被分成1和17，<code>sqrt(17)=4.123......</code>。</p><p>我们再以16来举例，它可以被分成<code>4</code>和<code>4</code>、<code>2</code>和<code>8</code>、<code>1</code>和<code>16</code>，它们均一个小于等于<code>sqrt(16)</code>，一个大于等于<code>sqrt(16)</code>。</p><p>依据这个原理，我们只需从<code>2</code>遍历到<code>sqrt(n)</code>即可，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrime2</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> temp = (<span class="keyword">int</span>) Math.sqrt(x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= temp; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这种方法的时间复杂度为<code>O(sqrt(N))</code>，相较于第一种暴力破解法会好很多。</p><h5 id="六步循环法"><a href="#六步循环法" class="headerlink" title="六步循环法"></a>六步循环法</h5><p>素数分布是否有规律呢？我们来看下：</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">大于等于 5 的质数一定和 6 的倍数相邻。</span><br></pre></td></tr></table></figure></blockquote><p>比如 5 和 7，11 和 13，17 和 19等。</p><p>下面我们来证明一下。</p><blockquote><p>证明：令 x=1，则大于等于 5 的自然数表示如下：</p></blockquote><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6x-1，6x，6x+1，6x+2，6x+3，6x+4，6x+5，6(x+1），6(x+1)+1 ......</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>可以看到，如果一个数不在6的倍数的两侧，则其可以如下表示：</p></blockquote><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6x+2，6x+3，6x+4,6(x+1)+2,6(x+1)+3,6(x+1)+4 ......</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>它们可以进行如下转换:</p></blockquote><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6x+2 = 2(3x+1) , 6x+3 = 3(2x+1) , 6x+4 = 2(3x+2) ......</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>它们一定不是素数！</p><p>同时 <code>6x = 2 * 3x</code> ，因此 <code>6x</code> 也不是素数。</p><p>所以我们只需要判断<code>6x-1，6x+1，6(x+1)-1,6(x+1)+1 ......</code>这些数据是否为素数即可。</p></blockquote><p>因此可以设置循环步长为6，从2循环到<code>sqrt(n)即可。</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrime3</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 小于5的素数只有2和3</span></span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x==<span class="number">2</span> || x==<span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果该数不在6的两侧，则一定不是素数</span></span><br><span class="line">    <span class="keyword">if</span> (x % <span class="number">6</span> != <span class="number">1</span> &amp;&amp; x%<span class="number">6</span> != <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> temp = (<span class="keyword">int</span>)Math.sqrt(x);</span><br><span class="line">    <span class="comment">// 循环步长为6，每次判断i和i+2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">5</span>; i&lt;=temp; i+=<span class="number">6</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x%i == <span class="number">0</span> || x%(i+<span class="number">2</span>)==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法比上一种方法更快，我们来简单看下它们的效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">long</span> start3 = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">//生成 1-1000000 之间的素数。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isPrime3(i))&#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> end3 = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;生成素数耗时：&quot;</span>+ (end3-start3)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isPrime1(integer))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;数据有问题&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;暴力求解法耗时：&quot;</span>+ (end-start)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> start1 = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isPrime2(integer))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;数据有问题&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> end1 = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;二分开方遍历法耗时：&quot;</span>+ (end1-start1)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> start2 = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isPrime3(integer))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;数据有问题&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> end2 = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;6步循环法耗时：&quot;</span>+ (end2-start2)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后运行后结果如下：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-918.png"></p><p>可以看到最后一种方法是相当快的。</p><h4 id="优化点二"><a href="#优化点二" class="headerlink" title="优化点二"></a>优化点二</h4><p>回到我们的试题，确定了判断素数的方法，我们再来看下还是否可以进行优化。</p><p>上面我们对于一个偶数，寻找其两个相近素数，用二分法来进行的处理，只需要找最多一半的数据。</p><p>我们通过上面寻找素数的方法，也可以不用一步步的寻找，部分数据可以跳过。</p><p>我们来看下有几种情况可以多跳一些数据。我们可以根据表格来看下。</p><table><thead><tr><th>数据</th><th>6x-1</th><th>6x</th><th>6x+1</th><th>6x+2</th><th>6x+3</th><th>6x+4</th><th>6x+5   或   6(x+1)-1</th><th>6(x+1)</th><th>6(x+1)+1</th></tr></thead><tbody><tr><td>x=1</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td><td>11</td><td>12</td><td>13</td></tr><tr><td>x=6</td><td>35</td><td>36</td><td>37</td><td>38</td><td>39</td><td>40</td><td>41</td><td>42</td><td>43</td></tr><tr><td>x=10</td><td>59</td><td>60</td><td>61</td><td>62</td><td>63</td><td>64</td><td>65</td><td>66</td><td>67</td></tr><tr><td>x=15</td><td>89</td><td>90</td><td>91</td><td>92</td><td>93</td><td>94</td><td>95</td><td>96</td><td>97</td></tr></tbody></table><p>我们看上面表格数据，根据<strong>六步循环法</strong>我们知道，寻找素数时我们最多是可以跳6位的。</p><p>有下面几种情况，我们都来看下：</p><ol><li><p>我们将偶数 <code>k</code> 二分后 ,  <strong>其一半  <code>half </code> 不是素数</strong> ：</p><ul><li><p>如果<code>half</code> 是6的倍数，但是<code> 6x+1</code> 也是有素数可能，所以还是要<code>half++</code>，不能跳；</p></li><li><p>如果<code>half+1</code> 是6的倍数，以上面<code>x=6</code>举例，<code>half=35</code>不是素数，<code>half+1=36</code>，这种情况我们可以直接跳过<code>6x</code>，判断<code>6x+1</code>，即 <code>half+=2</code>；</p></li><li><p>如果<code>half+2</code> 是 6的倍数，以上面x=6举例，此时half=40，这种情况我们可以跳1步，即half+=1；</p></li><li><p>如果<code>half+3</code> 是 6的倍数，以上面<code>x=6</code>举例，此时<code>half=39</code>，这种情况我们可以跳2步，即<code>half+=2</code>；</p></li><li><p>如果<code>half+4</code> 是 6的倍数，以上面<code>x=6</code>举例，此时<code>half=38</code>，这种情况我们可以跳3步，即<code>half+=3</code>；</p></li><li><p>如果<code>half-1</code> 是 6的倍数，还是以上面<code>x=6</code>举例，此时<code>half = 37</code>，这种情况下我们可以直接跳4步，判断41是否符合条件，即<code>half+=4</code>;</p></li><li><p>如果<code>half-2</code> 是 6的倍数，以上面<code>x=6</code>举例，此时<code>half=38</code>，这种情况我们可以跳3步，即<code>half+=3</code>；</p></li><li><p>如果<code>half-3</code> 是 6的倍数，以上面<code>x=6</code>举例，此时<code>half=39</code>，这种情况我们可以跳2步，即<code>half+=2</code>；</p></li><li><p>如果<code>half-4</code> 是 6的倍数，以上面<code>x=6</code>举例，此时<code>half=40</code>，这种情况我们可以跳1步，即<code>half+=1</code>；</p></li><li><p>其实说了这么多，就是和half除6的余数有关系。</p></li><li><p>如果余4，就可以跳3步；如果余3，就可以跳2步；如果余2，就可以跳1步；如果余1，也是跳1步；如果余0，也是跳1步；</p></li><li><p>如果余5呢？我们以x=10为例， <code>6x+5 = 65 % 6 = 5</code>，它也符合我们的half不是素数，可以看到我们也是只能跳2步，到 half=67。</p></li></ul></li><li><p>需要注意上述规则是<strong>针对于大于5的素数</strong>得出来的，也就是 <code>half</code>不是素数，则<code>half</code>应该大于等于6。</p><p>我举个例子，比如 <code>k=8</code> ，可以得到<code>half = 4</code>，按照1的规则，余数为4，需要跳3个，<code>half+3 = 7 ,k-half = 8-7 =1</code> 不是素数，这样就找不到合适的素数对了，其实 <code>8 = 3+5</code> ，<code>half=4</code>的时候只能跳一个，也就是我们<strong>需要保证<code>half &gt;=6</code> 这个条件</strong>。</p></li><li><p>如果**<code>half</code>是素数，但是<code>k-half</code>不是素数**呢？</p><p>这种情况要比上面简单些，如何理解呢？因为针对于大于等于5的素数，其只可能出现在<code>6x-1</code>和<code>6x+1</code>这两个里面。</p><p>如果是<code>6x-1</code>即除6余数为5，那么可以跳2个，到<code>6x+1</code>，即 half+=2;</p><p>如果是<code>6x+1</code>即除6余数为1，那么可以跳4个，到<code>6(x+1)-1</code>，即<code>half+=4</code>;</p></li><li><p>如果**<code>half</code>是素数，但是<code>k-half</code>是素数**呢？</p><p>那就找到满足条件的数据了，因为我们是从中间开始查找，找到的第一组素数一定是相差最小的。</p></li></ol><p>故二分法核心代码优化如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> half = k/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (half &lt; k)&#123;</span><br><span class="line">    <span class="keyword">if</span>(isPrime3(half))&#123;</span><br><span class="line">        <span class="keyword">if</span>(isPrime3(k-half))&#123;</span><br><span class="line">            <span class="comment">//全部为素数，返回结果</span></span><br><span class="line">            System.out.println(k +<span class="string">&quot; = &quot;</span>+ (k-half)+<span class="string">&quot; + &quot;</span>+half);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// half 是素数，但是 k-half 不是素数</span></span><br><span class="line">            <span class="keyword">if</span>(half &gt;= <span class="number">5</span>)&#123;</span><br><span class="line">                <span class="comment">//针对于大于5的素数</span></span><br><span class="line">                <span class="keyword">int</span> m = half % <span class="number">6</span>;</span><br><span class="line">                <span class="keyword">if</span>(m==<span class="number">5</span>)&#123;</span><br><span class="line">                    half+=<span class="number">2</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(m==<span class="number">1</span>)&#123;</span><br><span class="line">                    half+=<span class="number">4</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//理论上不会有数据</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;half = &quot;</span> + half);</span><br><span class="line">                    half++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//否则还是一个个跳</span></span><br><span class="line">                half ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// half 不是素数，寻找下一个判断位置</span></span><br><span class="line">        <span class="keyword">if</span>(half &gt;= <span class="number">6</span>)&#123;</span><br><span class="line">            <span class="comment">// half &gt;=6 就可以使用此规则</span></span><br><span class="line">            <span class="keyword">int</span> m = half % <span class="number">6</span>;</span><br><span class="line">            <span class="keyword">if</span>(m == <span class="number">4</span>)&#123;</span><br><span class="line">                half+=<span class="number">3</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(m==<span class="number">3</span> || m==<span class="number">5</span>)&#123;</span><br><span class="line">                half+=<span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                half++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则还是一个个跳</span></span><br><span class="line">            half++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优化点三"><a href="#优化点三" class="headerlink" title="优化点三"></a>优化点三</h4><p>因为输入要求为偶数，我们对输入数字有个校验。原来代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//k为偶数</span></span><br><span class="line"><span class="keyword">if</span>(k%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">    System.out.println(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用位运算来提高下效率。</p><p>我们知道，对于偶数来说，其二进制末尾一定为0。对于奇数来说，其末尾一定为1。</p><table><thead><tr><th>十进制</th><th>二进制</th></tr></thead><tbody><tr><td>2</td><td>10</td></tr><tr><td>100</td><td>1100100</td></tr><tr><td>200</td><td>11001000</td></tr><tr><td>7</td><td>111</td></tr><tr><td>99</td><td>1100011</td></tr><tr><td>233</td><td>11101001</td></tr></tbody></table><p>……</p><p>当我们与1进行按位’”与”运算时，对于偶数，其总等于0；对于奇数，其总等于1。</p><blockquote><p>与（&amp;）运算规则：0&amp;0=0;  0&amp;1=0;  1&amp;0=0;   1&amp;1=1;</p></blockquote><p>我们来看下：</p><p>对于偶数：</p><blockquote><p>2 &amp; 1 = 10 &amp; 01 = 00</p><p>100 &amp; 1 = 1100100 &amp; 0000001 = 0000000</p><p>200 &amp; 1 =   11001000 = 00000001 = 00000000</p><p>……</p></blockquote><p>对于奇数：</p><blockquote><p>7 &amp; 1 = 111 &amp; 001 = 001</p><p>99 &amp; 1 =   1100011 &amp; 0000001 = 0000001</p><p>233 &amp; 1 =   11101001 &amp; 00000001 = 00000001</p><p>…….</p></blockquote><p>所以偶数校验可以如下判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//k为偶数</span></span><br><span class="line"><span class="keyword">if</span>((k &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">    System.out.println(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，最后的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="comment">//k为偶数</span></span><br><span class="line">    <span class="keyword">if</span>((k &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">        System.out.println(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> half = k/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (half &lt; k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isPrime3(half))&#123;</span><br><span class="line">            <span class="keyword">if</span>(isPrime3(k-half))&#123;</span><br><span class="line">                <span class="comment">//全部为素数，返回结果</span></span><br><span class="line">                System.out.println(k +<span class="string">&quot; = &quot;</span>+ (k-half)+<span class="string">&quot; + &quot;</span>+half);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// half 是素数，但是 k-half 不是素数</span></span><br><span class="line">                <span class="keyword">if</span>(half &gt;= <span class="number">5</span>)&#123;</span><br><span class="line">                    <span class="comment">//针对于大于5的素数</span></span><br><span class="line">                    <span class="keyword">int</span> m = half % <span class="number">6</span>;</span><br><span class="line">                    <span class="keyword">if</span>(m==<span class="number">5</span>)&#123;</span><br><span class="line">                        half+=<span class="number">2</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(m==<span class="number">1</span>)&#123;</span><br><span class="line">                        half+=<span class="number">4</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//理论上不会有数据</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;half = &quot;</span> + half);</span><br><span class="line">                        half++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//否则还是一个个跳</span></span><br><span class="line">                    half ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// half 不是素数，寻找下一个判断位置</span></span><br><span class="line">            <span class="keyword">if</span>(half &gt;= <span class="number">6</span>)&#123;</span><br><span class="line">                <span class="comment">// half &gt;=6 就可以使用此规则</span></span><br><span class="line">                <span class="keyword">int</span> m = half % <span class="number">6</span>;</span><br><span class="line">                <span class="keyword">if</span>(m == <span class="number">4</span>)&#123;</span><br><span class="line">                    half+=<span class="number">3</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(m==<span class="number">3</span> || m==<span class="number">5</span>)&#123;</span><br><span class="line">                    half+=<span class="number">2</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    half++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//否则还是一个个跳</span></span><br><span class="line">                half++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们准备一些数据来测试一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//speedTest();</span></span><br><span class="line">    <span class="comment">//search(70);</span></span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//生成 4-1000 之间的偶数。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>((i &amp; <span class="number">1</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">        search(integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们生成了 <code>4 - 1000</code> 之间的偶数，结果如下：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-919.png"></p><p>看了下结果是没什么问题的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面两道就是我在机试中遇到的，总体上还是比较简单的。</p><p>当时由于考试，由于时间限制，思路比较狭隘，回过来看自己的代码还是有不少问题及优化点的。</p><p>以上就是本篇文章的全部内容。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://blog.csdn.net/qq_33945246/article/details/103045738">如何高效判断一个数是不是素数</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前些日子面试了荣耀终端，面试过程是比较漫长的，但结果还是比较满意的。&lt;/p&gt;
&lt;p&gt;目前已全部面试通过，处于等&lt;code&gt;offer&lt;/code&gt;的阶段。&lt;/p&gt;
&lt;p&gt;荣耀面试总共分为下面几部分：&lt;/p&gt;</summary>
    
    
    
    <category term="工作" scheme="https://www.sakuratears.top/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
    <category term="机试题" scheme="https://www.sakuratears.top/tags/%E6%9C%BA%E8%AF%95%E9%A2%98/"/>
    
    <category term="荣耀" scheme="https://www.sakuratears.top/tags/%E8%8D%A3%E8%80%80/"/>
    
  </entry>
  
  <entry>
    <title>线程相关方法说明总结</title>
    <link href="https://www.sakuratears.top/blog/%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95%E8%AF%B4%E6%98%8E%E6%80%BB%E7%BB%93.html"/>
    <id>https://www.sakuratears.top/blog/%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95%E8%AF%B4%E6%98%8E%E6%80%BB%E7%BB%93.html</id>
    <published>2021-09-04T07:46:00.000Z</published>
    <updated>2021-09-04T07:55:18.534Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天我们来看下在多线程环境处理中可能会遇到的一些方法，来了解下它们。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><p><code>sleep</code>即线程休眠，该方法属于<code>Thread</code>类，是一个<code>static native</code>方法。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-892.png"></p><p>调用<code>sleep</code>方法需要指定线程休眠时间。</p><p>需要注意的是，执行该方法是让程序暂停一定时间，让出<code>cpu</code>资源，但是它的监控状态依然保持，当指定的时间到了又会自动恢复运行状态，并且<strong>在调用该方法的过程中，线程不会释放对象锁</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object o = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MySleep(o));</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MySleep(o));</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySleep</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object o;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySleep</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.o = o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getId()+<span class="string">&quot; --&gt; 开始休眠 start：&quot;</span>+System.currentTimeMillis());</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getId()+<span class="string">&quot; --&gt; 休眠结束 end： &quot;</span>+System.currentTimeMillis());</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-893.png"></p><p>上述例子我们可以看到，在线程休眠时，线程会一直保持对象锁，其它线程无法拿到该对象锁。</p><p><code>sleep</code>是<code>JVM</code>基于操作系统底层的实现而封装实现的。</p><p>其原理大家可以了解一下：</p><ol><li><p>挂起进程（或线程）并修改其运行状态，即让出<code>CPU</code>控制权限；</p></li><li><p>用<code>sleep()</code>提供的参数来设置一个定时器；</p></li><li><p>当时间结束，定时器会触发，内核收到中断后修改进程（或线程）的运行状态。例如线程会被标志为就绪而进入就绪队列等待调度。</p></li></ol><h2 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h2><p><code>wait</code>方法也是常被用到的一个方法，其经常和<code>sleep</code>方法一起被问到来比较区别。</p><p>首先应该知道的是<code>wait</code>方法属于<code>Object</code>类，是其一个普通方法。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-894.png"></p><p>当然，<code>wait</code>最后调用了<code>Object</code>类中的<code>wait(long timeout)</code>方法，它是一个<code>native</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure><p>需要注意的是，当线程调用<code>wait</code>方法时，该线程会放弃（释放）当前持有的对象锁，同时该线程进入线程等待队列（挂起）。</p><p>线程调用<code>wait</code>方法后，我们需要显式的调用<code>notify()</code>或<code>notiftAll</code>方法来结束线程的等待状态。</p><p>我们来看下下面的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object o =<span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyWait1(o));</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyWait2(o));</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWait1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object o;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyWait1</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.o = o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getId() +<span class="string">&quot;获得对象锁&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                o.wait();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getId() +<span class="string">&quot;开始休眠&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getId() +<span class="string">&quot;休眠结束&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWait2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object o;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyWait2</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.o = o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">            <span class="comment">// doSomething</span></span><br><span class="line">            System.out.println(Thread.currentThread().getId() +<span class="string">&quot;获得对象锁&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到如下输出：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-895.png"></p><p>说明线程<code>11</code>获得对象锁，后续执行<code>wait</code>方法后，线程<code>11</code>释放了对象锁，而后被线程<code>12</code>获取。</p><p>并且我们看到程序无法停止，<code>MyWait1</code>也不会输出<code>开始休眠</code>或者<code>结束休眠</code>等日志，因为线程<code>11</code>已经被挂起。</p><p>此时需要调用<code>notify</code>或<code>notiftAll</code>方法来唤醒线程。</p><p>我们可以在线程<code>MyWait2</code>执行完后唤醒<code>MyWait1</code>线程，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWait2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object o;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyWait2</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.o = o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">            <span class="comment">// doSomething</span></span><br><span class="line">            System.out.println(Thread.currentThread().getId() +<span class="string">&quot;获得对象锁&quot;</span>);</span><br><span class="line">            <span class="comment">//唤醒</span></span><br><span class="line">            o.notify();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-896.png"></p><p>可以看到线程<code>11</code>被唤醒，执行后续逻辑。</p><p>我们来总结下<code>sleep</code>和<code>wait</code>方法的不同之处：</p><ul><li>属于不同的两个类，<code>sleep</code>是<code>Thread</code>类里的<code>static native</code>方法，<code>wait</code>是<code>Object</code>类里的方法；</li><li><code>sleep</code>方法不会释放对象锁，<code>wait</code>方法会释放对象锁；</li><li><code>sleep</code>方法可以在任何地方使用，<strong>wait方法则只能在同步方法或同步块中使用</strong>；</li><li><code>sleep</code>需要指定休眠时间，<code>wait</code>可以指定时间，也可以不指定，如果不指定时间，需要调用<code>notify</code>或<code>notiftAll</code>方法来唤醒线程；</li><li><code>sleep</code>方法使线程进入阻塞状态（线程休眠），<code>wait</code>方法使线程进入等待队列（线程挂起），也就是阻塞类别不同；</li></ul><h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p>我们再来看下<code>join</code>方法。</p><p>我们知道<code>join</code>方法可以把指定线程加入到当前线程，可以将两个并行的线程合并，让其顺序执行。</p><p>那么它是怎么实现的呢？</p><p>我们直接来看下源码。</p><p><code>join</code>方法位于<code>Thread</code>类中，如下：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-897.png"></p><p>我们上面说了<code>wait</code>方法后，这段代码就非常容易理解了。</p><p>可以看到<code>join</code>方法内部调用了<code>wait</code>方法，其实现逻辑就是等加入的线程执行完（或者执行若干时间后）在执行其他线程。</p><p>我们来测试一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyJoin1());</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyJoin2());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyJoin1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程&quot;</span>+Thread.currentThread().getId()+<span class="string">&quot;; 值：&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyJoin2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">10</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程&quot;</span>+Thread.currentThread().getId()+<span class="string">&quot;; 值：&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们首先构造两个线程，线程1输出<code>0-9</code>，线程2输出<code>10-19</code>.</p><p>我们运行可以看到结果乱序输出。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-898.png"></p><p>我们改造上述代码，让线程2加入线程1，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyJoin1());</span><br><span class="line">        <span class="comment">//Thread t2 = new Thread(new MyJoin2());</span></span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">//t2.start();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyJoin1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程&quot;</span>+Thread.currentThread().getId()+<span class="string">&quot;; 值：&quot;</span>+i);</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">5</span>)&#123;</span><br><span class="line">                    Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyJoin2());</span><br><span class="line">                    t2.start();</span><br><span class="line">                    t2.join();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyJoin2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">10</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程&quot;</span>+Thread.currentThread().getId()+<span class="string">&quot;; 值：&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们线程1执行判断当<code>i==5</code>时，<code>join</code>线程2.</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-899.png"></p><p>可以看到线程1执行到5后，线程2开始执行，线程1进入<code>wait</code>，待线程2退出后线程1继续执行。</p><p><strong>疑问</strong>：不知道大家有没有这个疑问，我们上面说到<code>wait</code>方法时说过，调用<code>wait</code>方法后应该显式调用<code>notify</code>或<code>notiftAll</code>方法来唤醒线程，那么<code>join</code>后，它在哪儿被执行的呢？</p><p><strong>解答</strong>：我们找到<code>Thread</code>类的<code>exit</code>方法，可以看到如下代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (group != <span class="keyword">null</span>) &#123;</span><br><span class="line">        group.threadTerminated(<span class="keyword">this</span>);</span><br><span class="line">        group = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Aggressively null out all reference fields: see bug 4006245 */</span></span><br><span class="line">    target = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/* Speed the release of some of these resources */</span></span><br><span class="line">    threadLocals = <span class="keyword">null</span>;</span><br><span class="line">    inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line">    inheritedAccessControlContext = <span class="keyword">null</span>;</span><br><span class="line">    blocker = <span class="keyword">null</span>;</span><br><span class="line">    uncaughtExceptionHandler = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该段代码在线程结束时都会被调用，其中的<code>group.threadTerminated(this)</code>方法内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadTerminated</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        remove(t);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nthreads == <span class="number">0</span>) &#123;</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (daemon &amp;&amp; (nthreads == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">            (nUnstartedThreads == <span class="number">0</span>) &amp;&amp; (ngroups == <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            destroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到了我们所说的<code>notifyAll</code>方法。</p><p>也就是比如两个线程1和2，线程2调用<code>join</code>方法加入线程1后，线程1进入<code>wait</code>，等到线程2结束时触发<code>notifyAll</code>，线程1被唤醒，继续执行。</p><p>如果是有超时时间的<code>join</code>呢，我们改造下代码，继续来看下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyJoin1());</span><br><span class="line">        <span class="comment">//Thread t2 = new Thread(new MyJoin2());</span></span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">//t2.start();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyJoin1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程&quot;</span>+Thread.currentThread().getId()+<span class="string">&quot;; 值：&quot;</span>+i);</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">5</span>)&#123;</span><br><span class="line">                    Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyJoin2());</span><br><span class="line">                    t2.start();</span><br><span class="line">                    t2.join(<span class="number">2000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyJoin2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">10</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程&quot;</span>+Thread.currentThread().getId()+<span class="string">&quot;; 值：&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这儿可以看到我把<code>join</code>时间设置为了2000ms，线程2需要<code>sleep</code> 2000ms后才会执行。</p><p>输出结果如下：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-900.png"></p><p>可以看到，线程1继续执行，不会等待线程2执行完后再执行。也就是<code>wait(long timeout)</code>方法当达到超时时间后，会由底层去唤醒线程继续执行。</p><p>也就是比如两个线程1和2，线程2调用<code>join</code>方法加入线程1后，此时设置了<code>join</code>的超时时间，线程1进入<code>wait</code>，会<code>wait</code>该超时时间，时间过后会被唤醒，如果此时先从2还没有执行完，会和线程2并行执行。</p><h2 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h2><p><code>interrupt</code>方法其作用是中断此线程（此线程不一定是当前线程，而是指调用该方法的Thread实例所代表的线程），但实际上只是给线程设置一个中断标志，线程仍会继续运行。</p><p>但使用时我们需要注意的地方如下。</p><ul><li><code>interrupt</code>不能改变正在运行中的线程，它只是改变中断状态而已，具体线程何去何从，是由代码决定的；</li><li>相关的两个方法：<code>isInterrupted</code>可以判断线程中断状态；<code>interrupted</code>可以恢复线程中断状态。</li></ul><p>我们根据例子来看下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyInterrupt());</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInterrupt</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 &quot;</span>+Thread.currentThread().getId()+<span class="string">&quot; 中断状态：&quot;</span>+Thread.currentThread().isInterrupted());</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">2</span>)&#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 &quot;</span>+Thread.currentThread().getId()+<span class="string">&quot; 正在运行 i = &quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码还是比较好理解的，我们在<code>i=2</code>是中断线程，但我们可以看到输出结果是说明中断后线程仍是在运行着的。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-901.png"></p><p>因此这种情况下，我们需要结合代码来控制线程的中断、执行等逻辑。</p><p>如何中断呢？显然，我们直接在<code>i=2</code>时添加<code>return</code>就行。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-902.png"></p><p>可以看到线程执行到<code>i=2</code>时退出。</p><p>这个方法不中断正在运行的线程，它有什么作用呢？</p><p>其实，<code>interrupt</code>的主要作用目标是阻塞线程，它会给阻塞线程发出中断信号，以结束受阻塞线程的阻塞状态。</p><p>或者直接这样说，如果一个线程被<code>Object.wait</code>、<code>Thread.join</code>、<code>Thread.sleep</code>阻塞，那么调用<code>interrupt</code>可以快速结束其阻塞状态，释放资源。</p><p>但要注意，此时调用<code>interrupt</code>将会抛出<code>InterruptedException</code>异常，我们需要处理它。</p><p>我们以上述例子为例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyInterrupt());</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        t1.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInterrupt</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 &quot;</span>+Thread.currentThread().getId()+<span class="string">&quot; 中断状态：&quot;</span>+Thread.currentThread().isInterrupted());</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 &quot;</span>+Thread.currentThread().getId()+<span class="string">&quot; 正在运行 i = &quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码我们线程启动后，在<code>i=2</code>时进入<code>sleep</code>，让线程中断，可以看到抛出<code>InterruptedException</code>，后续线程的流程由我们异常处理处的方法控制，可以看到我们直接<code>return</code>表示退出线程，线程退出。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-903.png"></p><p>需要注意的是，我们也可以先设置中断状态，而后线程阻塞的时候就会直接抛出异常，这两个的先后关系并不重要。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-904.png"></p><p>上图我们可以看到在<code>i=1</code>的时候设置中断状态，在<code>i=2</code>的时候尝试阻塞线程，抛出异常，线程结束。</p><p>以上就是关于<code>interrupt</code>的全部内容，需要知道的点：</p><ul><li>调用<code>interrupt</code>只会改变线程中断状态；</li><li>如果线程处于运行状态，则对线程无影响；如果线程处于阻塞或者进入阻塞状态，就会抛出中断异常，我们应该捕获异常并规定线程的后续逻辑。</li></ul><h2 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h2><p>这个方法用到的不多，我们来了解一下。</p><p><code>yield</code>方法可以<strong>使当前线程回到可运行状态，以允许其他线程获得运行机会</strong>。但要注意的是，<code>yield</code>无法保证<code>100%</code>让步，因为让步的线程可能还会被线程调度选中。</p><p>我们结合例子来看下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YieldTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService e = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            e.submit(<span class="keyword">new</span> MyYield(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyYield</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> k;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyYield</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.k = k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程 &quot;</span>+Thread.currentThread().getId()+ <span class="string">&quot; 获得执行机会, k =&quot;</span>+k);</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程 &quot;</span>+Thread.currentThread().getId()+ <span class="string">&quot; 执行完成, k =&quot;</span>+k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码，我们构建一个5个线程的定长线程池，每个线程记录序号<code>k</code>，当<code>k=0</code>的时候，就是第一个放入的线程，我们让它<code>yield</code>一下。</p><p>我们多次运行测试代码，可以看到如下结果。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-905.png"></p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-906.png"></p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-907.png"></p><p>可以看到<code>k=0</code>线程作出让步，但线程调度是有可能在调用到它的，所以上述输出结果会多样。这也说明<code>yield</code>不能保证100%让步。</p><p>另外，<code>yield</code>让步后，具体哪个线程拿到<code>CPU</code>运行权取决于优先级，但优先级也不能保证100%优先。</p><p>如下，我们设置5个线程，设置其优先级为1-5（优先级范围1-10，默认5，越小优先级越低）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;线程 &quot;</span>+Thread.currentThread().getId()+ <span class="string">&quot; 获得执行机会, k =&quot;</span>+k);</span><br><span class="line">    Thread.currentThread().setPriority(k+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">        Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;线程 &quot;</span>+Thread.currentThread().getId()+ <span class="string">&quot; 执行完成, k =&quot;</span>+k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，大多数情况优先级高的会优先执行完成，同时<code>k=0</code>线程优先级最低，还作了<code>yield</code>，理论上会在最后执行完成。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-908.png"></p><p>但也会有一些特殊情况。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-909.png"></p><p>以上就是关于<code>yield</code>的全部内容。</p><p>通常情况下，如果使用<code>yield</code>，其主要作用是可能想让相同优先级的线程之间能适当的轮转执行。</p><h2 id="run"><a href="#run" class="headerlink" title="run"></a>run</h2><p><code>run</code>方法来自接口<code>Runnable</code>.</p><p>而<code>Thread</code>方法中的<code>run</code>实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* What will be run. */</span></span><br><span class="line"><span class="keyword">private</span> Runnable target;</span><br><span class="line">......</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到十分简单，也就是线程<code>Thread</code>里定义了<code>Runnable</code>，当<code>Runnable</code>不为空时，就会调用它的<code>run</code>方法。</p><p>我们知道，我们要使用实现<code>Runnable</code>的方法来实现一个线程，必须有如下操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable(......));</span><br><span class="line">t.start;</span><br></pre></td></tr></table></figure><p>如下例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRun());</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRun());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRun</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 &quot;</span>+Thread.currentThread().getId()+<span class="string">&quot; i =&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样两个线程就会并行执行。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-910.png"></p><p>如果我们不调用<code>start</code>，直接使用<code>run</code>，就会变为同步执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRun());</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRun());</span><br><span class="line"> <span class="comment">// t1.start();</span></span><br><span class="line"> <span class="comment">// t2.start();</span></span><br><span class="line">    t1.run();</span><br><span class="line">    t2.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-911.png"></p><p>其实就是相当于我们<strong>仅仅是调用了<code>Thread</code>类的<code>run</code>方法，而没有开启一个线程去执行相关操作。相当于还是主线程在串行做相关事情</strong>。</p><p>我们上面也可以看到，调用<code>start</code>方法后，程序会开启一个线程，然后调用其<code>run</code>方法，所以我们再来看下<code>start</code>方法。</p><h2 id="start"><a href="#start" class="headerlink" title="start"></a>start</h2><p>上面分析到调用<code>start</code>方法后，程序会开启一个线程执行<code>run</code>方法，我们直接来看相关代码吧。</p><p><code>start</code>方法代码如下：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-912.png"></p><p>可以看到，其相关调用<code>run</code>方法的内容应该在原生方法<code>start0</code>里面。</p><p><code>start0</code>方法实际上是通过<code>Thread</code>类里的如下方法<code>registerNatives</code>定义的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Make sure registerNatives is the first thing &lt;clinit&gt; does. */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        registerNatives();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>registerNatives</code>方法的原生方法定义在<code>Thread.c</code>文件中，如下：<a href="http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/00cd9dc3c2b5/src/share/native/java/lang/Thread.c">http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/00cd9dc3c2b5/src/share/native/java/lang/Thread.c</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> JNINativeMethod methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;start0&quot;</span>,           <span class="string">&quot;()V&quot;</span>,        (<span class="keyword">void</span> *)&amp;JVM_StartThread&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;stop0&quot;</span>,            <span class="string">&quot;(&quot;</span> OBJ <span class="string">&quot;)V&quot;</span>, (<span class="keyword">void</span> *)&amp;JVM_StopThread&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;isAlive&quot;</span>,          <span class="string">&quot;()Z&quot;</span>,        (<span class="keyword">void</span> *)&amp;JVM_IsThreadAlive&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;suspend0&quot;</span>,         <span class="string">&quot;()V&quot;</span>,        (<span class="keyword">void</span> *)&amp;JVM_SuspendThread&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;resume0&quot;</span>,          <span class="string">&quot;()V&quot;</span>,        (<span class="keyword">void</span> *)&amp;JVM_ResumeThread&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;setPriority0&quot;</span>,     <span class="string">&quot;(I)V&quot;</span>,       (<span class="keyword">void</span> *)&amp;JVM_SetThreadPriority&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;yield&quot;</span>,            <span class="string">&quot;()V&quot;</span>,        (<span class="keyword">void</span> *)&amp;JVM_Yield&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;sleep&quot;</span>,            <span class="string">&quot;(J)V&quot;</span>,       (<span class="keyword">void</span> *)&amp;JVM_Sleep&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;currentThread&quot;</span>,    <span class="string">&quot;()&quot;</span> THD,     (<span class="keyword">void</span> *)&amp;JVM_CurrentThread&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;countStackFrames&quot;</span>, <span class="string">&quot;()I&quot;</span>,        (<span class="keyword">void</span> *)&amp;JVM_CountStackFrames&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;interrupt0&quot;</span>,       <span class="string">&quot;()V&quot;</span>,        (<span class="keyword">void</span> *)&amp;JVM_Interrupt&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;isInterrupted&quot;</span>,    <span class="string">&quot;(Z)Z&quot;</span>,       (<span class="keyword">void</span> *)&amp;JVM_IsInterrupted&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;holdsLock&quot;</span>,        <span class="string">&quot;(&quot;</span> OBJ <span class="string">&quot;)Z&quot;</span>, (<span class="keyword">void</span> *)&amp;JVM_HoldsLock&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;getThreads&quot;</span>,        <span class="string">&quot;()[&quot;</span> THD,   (<span class="keyword">void</span> *)&amp;JVM_GetAllThreads&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;dumpThreads&quot;</span>,      <span class="string">&quot;([&quot;</span> THD <span class="string">&quot;)[[&quot;</span> STE, (<span class="keyword">void</span> *)&amp;JVM_DumpThreads&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> THD</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> OBJ</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> STE</span></span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_java_lang_Thread_registerNatives</span><span class="params">(JNIEnv *env, jclass cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (*env)-&gt;RegisterNatives(env, cls, methods, ARRAY_LENGTH(methods));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码中可以看到，调用<code>start0</code>方法会执行<code>JVM_StartThread</code>方法。</p><p>我们可以在<code>OpenJDK hotspot</code>源码中找到关于<code>JVM_StartThread</code>方法的定义，其位于<code>jvm.cpp</code>中。</p><p><a href="https://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/87ee5ee27509/src/share/vm/prims/jvm.cpp">https://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/87ee5ee27509/src/share/vm/prims/jvm.cpp</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="built_in">JVM_ENTRY</span>(<span class="keyword">void</span>, <span class="built_in">JVM_StartThread</span>(JNIEnv* env, jobject jthread))</span><br><span class="line">  <span class="built_in">JVMWrapper</span>(<span class="string">&quot;JVM_StartThread&quot;</span>);</span><br><span class="line">  JavaThread *native_thread = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We cannot hold the Threads_lock when we throw an exception,</span></span><br><span class="line">  <span class="comment">// due to rank ordering issues. Example:  we might need to grab the</span></span><br><span class="line">  <span class="comment">// Heap_lock while we construct the exception.</span></span><br><span class="line">  <span class="keyword">bool</span> throw_illegal_thread_state = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We must release the Threads_lock before we can post a jvmti event</span></span><br><span class="line">  <span class="comment">// in Thread::start.</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Ensure that the C++ Thread and OSThread structures aren&#x27;t freed before</span></span><br><span class="line">    <span class="comment">// we operate.</span></span><br><span class="line">    <span class="function">MutexLocker <span class="title">mu</span><span class="params">(Threads_lock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Since JDK 5 the java.lang.Thread threadStatus is used to prevent</span></span><br><span class="line">    <span class="comment">// re-starting an already started thread, so we should usually find</span></span><br><span class="line">    <span class="comment">// that the JavaThread is null. However for a JNI attached thread</span></span><br><span class="line">    <span class="comment">// there is a small window between the Thread object being created</span></span><br><span class="line">    <span class="comment">// (with its JavaThread set) and the update to its threadStatus, so we</span></span><br><span class="line">    <span class="comment">// have to check for this</span></span><br><span class="line">    <span class="keyword">if</span> (java_lang_Thread::<span class="built_in">thread</span>(JNIHandles::<span class="built_in">resolve_non_null</span>(jthread)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      throw_illegal_thread_state = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// We could also check the stillborn flag to see if this thread was already stopped, but</span></span><br><span class="line">      <span class="comment">// for historical reasons we let the thread detect that itself when it starts running</span></span><br><span class="line"></span><br><span class="line">      jlong size =</span><br><span class="line">             java_lang_Thread::<span class="built_in">stackSize</span>(JNIHandles::<span class="built_in">resolve_non_null</span>(jthread));</span><br><span class="line">      <span class="comment">// Allocate the C++ Thread structure and create the native thread.  The</span></span><br><span class="line">      <span class="comment">// stack size retrieved from java is signed, but the constructor takes</span></span><br><span class="line">      <span class="comment">// size_t (an unsigned type), so avoid passing negative values which would</span></span><br><span class="line">      <span class="comment">// result in really large stacks.</span></span><br><span class="line">      <span class="keyword">size_t</span> sz = size &gt; <span class="number">0</span> ? (<span class="keyword">size_t</span>) size : <span class="number">0</span>;</span><br><span class="line">      native_thread = <span class="keyword">new</span> <span class="built_in">JavaThread</span>(&amp;thread_entry, sz);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// At this point it may be possible that no osthread was created for the</span></span><br><span class="line">      <span class="comment">// JavaThread due to lack of memory. Check for this situation and throw</span></span><br><span class="line">      <span class="comment">// an exception if necessary. Eventually we may want to change this so</span></span><br><span class="line">      <span class="comment">// that we only grab the lock if the thread was created successfully -</span></span><br><span class="line">      <span class="comment">// then we can also do this check and throw the exception in the</span></span><br><span class="line">      <span class="comment">// JavaThread constructor.</span></span><br><span class="line">      <span class="keyword">if</span> (native_thread-&gt;<span class="built_in">osthread</span>() != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// Note: the current thread is not being used within &quot;prepare&quot;.</span></span><br><span class="line">        native_thread-&gt;<span class="built_in">prepare</span>(jthread);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (throw_illegal_thread_state) &#123;</span><br><span class="line">    <span class="built_in">THROW</span>(vmSymbols::<span class="built_in">java_lang_IllegalThreadStateException</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert</span>(native_thread != <span class="literal">NULL</span>, <span class="string">&quot;Starting null thread?&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (native_thread-&gt;<span class="built_in">osthread</span>() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// No one should hold a reference to the &#x27;native_thread&#x27;.</span></span><br><span class="line">    <span class="keyword">delete</span> native_thread;</span><br><span class="line">    <span class="keyword">if</span> (JvmtiExport::<span class="built_in">should_post_resource_exhausted</span>()) &#123;</span><br><span class="line">      JvmtiExport::<span class="built_in">post_resource_exhausted</span>(</span><br><span class="line">        JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR | JVMTI_RESOURCE_EXHAUSTED_THREADS,</span><br><span class="line">        <span class="string">&quot;unable to create new native thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">THROW_MSG</span>(vmSymbols::<span class="built_in">java_lang_OutOfMemoryError</span>(),</span><br><span class="line">              <span class="string">&quot;unable to create new native thread&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Thread::<span class="built_in">start</span>(native_thread);</span><br><span class="line"></span><br><span class="line">JVM_END</span><br><span class="line">.......</span><br></pre></td></tr></table></figure><p>上述代码比较多，简化如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JVM_ENTRY</span>(<span class="keyword">void</span>, <span class="built_in">JVM_StartThread</span>(JNIEnv* env, jobject jthread))</span><br><span class="line">  <span class="built_in">JVMWrapper</span>(<span class="string">&quot;JVM_StartThread&quot;</span>);</span><br><span class="line">  JavaThread *native_thread = <span class="literal">NULL</span>;</span><br><span class="line">  .......</span><br><span class="line">  <span class="comment">//创建一个线程</span></span><br><span class="line">  native_thread = <span class="keyword">new</span> <span class="built_in">JavaThread</span>(&amp;thread_entry, sz);</span><br><span class="line">  ......</span><br><span class="line">  <span class="comment">//启动线程</span></span><br><span class="line">  Thread::<span class="built_in">start</span>(native_thread);</span><br></pre></td></tr></table></figure><p>创建线程关键部分就是<code>native_thread = new JavaThread(&amp;thread_entry, sz);</code>，这个<code>thread_entry</code>的定义我们来看一下。</p><p>也是在当前文件里。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thread_entry</span><span class="params">(JavaThread* thread, TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="function">HandleMark <span class="title">hm</span><span class="params">(THREAD)</span></span>;</span><br><span class="line">  <span class="function">Handle <span class="title">obj</span><span class="params">(THREAD, thread-&gt;threadObj())</span></span>;</span><br><span class="line">  <span class="function">JavaValue <span class="title">result</span><span class="params">(T_VOID)</span></span>;</span><br><span class="line">  JavaCalls::<span class="built_in">call_virtual</span>(&amp;result,</span><br><span class="line">                          obj,</span><br><span class="line">                          <span class="built_in">KlassHandle</span>(THREAD, SystemDictionary::<span class="built_in">Thread_klass</span>()),</span><br><span class="line">                          vmSymbols::<span class="built_in">run_method_name</span>(),</span><br><span class="line">                          vmSymbols::<span class="built_in">void_method_signature</span>(),</span><br><span class="line">                          THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法中有个参数<code>vmSymbols::run_method_name()</code>，定义了回调方法，其回调方法就是回调了<code>Java</code>中的<code>run</code>方法。</p><p>我们可以在<code>vmSymbols.hpp</code>里找到其定义，<a href="https://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/9d15b81d5d1b/src/share/vm/classfile/vmSymbols.hpp%E3%80%82">https://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/9d15b81d5d1b/src/share/vm/classfile/vmSymbols.hpp。</a></p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-913.png"></p><p>可以看到底层回调了<code>run</code>方法。</p><p>另外关于底层线程如何启动运行的，这儿暂时不过多叙述，有时间我再整理一下。</p><h2 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h2><p>这个方法目前已经过时了，在<code>Java</code>源码中，我们可以看到官方给出的过时原因。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-914.png"></p><p>上述注释中说明了该方法停掉一个线程将会导致所有已锁定的监听器被解锁（解锁的原因是当 <code>ThreadDeath</code>异常在堆栈中传播时，监视器被解锁），这个之前被监听器锁定的对象被解锁，其他线程就能随意操作这个对象，将导致任何可能的结果。</p><p>官方给出的网页说明了不能捕获<code>ThreadDeath</code>异常并修复对象的原因：</p><ol><li>一个线程几乎可以在任何地方抛出一个<code>ThreadDeath</code>异常。考虑到这一点，所有同步的方法和块都必须详细研究处理。</li><li>一个线程可以抛出第二个<code>ThreadDeath</code>异常，同时从第一个线程清除（在 <code>catch</code> 或 <code>finally</code> 子句中）。清理将不得不重复进行，直到它成功。确保这一点的代码将非常复杂。</li></ol><p>所以捕获<code>ThreadDeath</code>异常是不可取的。</p><p>我们下面举个例子来看一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread t0 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;thread-&gt;&quot;</span> + Thread.currentThread().getName()</span><br><span class="line">                                + <span class="string">&quot; acquire lock.&quot;</span>);</span><br><span class="line">                        <span class="comment">// sleep for 3s</span></span><br><span class="line">                        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                        System.out.println(<span class="string">&quot;thread-&gt;&quot;</span> + Thread.currentThread().getName()</span><br><span class="line">                                + <span class="string">&quot; release lock.&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Caught in run: &quot;</span> + ex);</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;thread-&gt;&quot;</span> + Thread.currentThread().getName()</span><br><span class="line">                            + <span class="string">&quot; acquire lock.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            t0.start();</span><br><span class="line"><span class="comment">//            Thread.sleep(1000);</span></span><br><span class="line"><span class="comment">//            t0.stop();</span></span><br><span class="line">            t1.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Caught in main: &quot;</span> + e);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的意思是，线程<code>t0</code>和线程<code>t1</code>共享对象<code>lock</code>，开始时<code>t0</code>启动，拿到<code>lock</code>，经过3s后释放<code>lock</code>，而后<code>t1</code>拿到<code>lock</code>。</p><p>所以输出如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread-&gt;Thread-<span class="number">0</span> acquire lock.</span><br><span class="line">thread-&gt;Thread-<span class="number">0</span> release lock.</span><br><span class="line">thread-&gt;Thread-<span class="number">1</span> acquire lock.</span><br></pre></td></tr></table></figure><p>但当我们把上述注释部分打开时，即线程<code>t0</code>获得锁后<code>stop</code>，此时其会释放对象锁，<code>t1</code>获取到了锁，此时<code>t0</code>又尝试继续操作，就会出现异常。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-915.png"></p><p>如果想实现<code>stop</code>的相关功能，可以使用上面的<code>interrupt</code>方法来实现。</p><h2 id="其它过时方法"><a href="#其它过时方法" class="headerlink" title="其它过时方法"></a>其它过时方法</h2><p>除了上面说到的<code>stop</code>，线程类中的<code>suspend</code>、<code>resume</code> 、<code>destroy</code>等方法也已经过时弃用了。</p><p>它们的弃用原因大家可以看下这篇官方文档，这儿我就不过多叙述了。</p><p><a href="https://docs.oracle.com/javase/1.5.0/docs/guide/misc/threadPrimitiveDeprecation.html">Why Are <code>Thread.stop</code>, <code>Thread.suspend</code>, <code>Thread.resume</code> and <code>Runtime.runFinalizersOnExit</code> Deprecated?</a></p><p>其原因主要是不安全、容易死锁等。</p><p>官方给出的策略是：</p><ol><li>对于<code>stop</code>方法，可以使用<code>interrupt</code>或者<code>sleep</code>等替代；</li><li>对于<code>suspend</code>和<code>resume</code> 方法，可以使用 <code>Object.wait</code>和<code>Object.notify</code>来实现；</li><li><code>destroy</code>方法就从来没被实现过。</li></ol><p>我们来看下<code>suspend</code>造成死锁的情况，其实主要原因就是<code>suspend</code>不会释放对象锁，因此可能造成死锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuspendAndResumeTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> Object o2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MySuspend1(o1,o2));</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MySuspend2(o1,o2));</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.resume();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySuspend1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object o1;</span><br><span class="line">    <span class="keyword">private</span> Object o2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySuspend1</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.o1 = o1;</span><br><span class="line">        <span class="keyword">this</span>.o2 = o2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (o1)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 &quot;</span>+Thread.currentThread().getId() +<span class="string">&quot;获得对象锁 o1&quot;</span>);</span><br><span class="line">            Thread.currentThread().suspend();</span><br><span class="line">            <span class="keyword">synchronized</span> (o2)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程 &quot;</span>+Thread.currentThread().getId() +<span class="string">&quot;获得对象锁 o2&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySuspend2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object o1;</span><br><span class="line">    <span class="keyword">private</span> Object o2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySuspend2</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.o1 = o1;</span><br><span class="line">        <span class="keyword">this</span>.o2 = o2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (o2)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程 &quot;</span>+Thread.currentThread().getId() +<span class="string">&quot;获得对象锁 o2&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (o1)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程 &quot;</span>+Thread.currentThread().getId() +<span class="string">&quot;获得对象锁 o1&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述例子中，对象<code>o1</code>、<code>o2</code>，当线程<code>t1</code>获取到<code>o1</code>对象锁后，进入<code>suspend</code>，而此时线程<code>t2</code>来临，获取到了<code>o2</code>对象锁，并再尝试获取<code>o1</code>对象锁，这样<code>t1</code>持有<code>o1</code>并尝试获取<code>o2</code>，<code>t2</code>持有<code>o2</code>并尝试获取<code>t1</code>，从而导致程序死锁。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇文章讲述了线程的一些常使用的方法，及它们使用中要注意到的一些点。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://hg.openjdk.java.net/jdk8/jdk8/hotspot/">Hotspot 源码</a></li><li><a href="https://docs.oracle.com/javase/1.5.0/docs/guide/misc/threadPrimitiveDeprecation.html">Why Are <code>Thread.stop</code>, <code>Thread.suspend</code>, <code>Thread.resume</code> and <code>Runtime.runFinalizersOnExit</code> Deprecated?</a></li><li><a href="https://www.cnblogs.com/hongten/p/hongten_java_sleep_wait.html">sleep与wait的区别</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天我们来看下在多线程环境处理中可能会遇到的一些方法，来了解下它们。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h1&gt;&lt;h2 id=&quot;sleep&quot;&gt;&lt;a href=&quot;#sleep&quot; class=&quot;headerlink&quot; title=&quot;sleep&quot;&gt;&lt;/a&gt;sleep&lt;/h2&gt;</summary>
    
    
    
    <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="线程" scheme="https://www.sakuratears.top/tags/%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="Thread" scheme="https://www.sakuratears.top/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>Java中的浅拷贝与深拷贝</title>
    <link href="https://www.sakuratears.top/blog/Java%E4%B8%AD%E7%9A%84%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D.html"/>
    <id>https://www.sakuratears.top/blog/Java%E4%B8%AD%E7%9A%84%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D.html</id>
    <published>2021-08-23T14:21:00.000Z</published>
    <updated>2021-09-04T07:45:33.969Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Java</code>中的对象拷贝(Object Copy)指的是将一个对象的所有属性（成员变量）拷贝到另一个有着相同类类型的对象中去。</p><p>在程序中对象属性拷贝还是非常常见的，主要是为了在新的上下文环境中复用现有对象的部分或全部数据。</p><p><code>Java</code>中的对象拷贝主要有 <strong>浅拷贝(Shallow Copy)</strong> 和 <strong>深拷贝(Deep Copy)</strong> 两种。</p><p>下面我们来具体看一下。</p><p>在了解对象拷贝之前，我们应该对数据的值传递和引用传递有一定了解，这样就非常容易理解本文内容。</p><p>可以看下这篇文章 <a href="https://www.sakuratears.top/blog/Java%E4%B8%AD%E7%9A%84%E5%A0%86%E5%92%8C%E6%A0%88%E5%AD%98%E6%94%BE%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html#more">Java中的堆和栈存放的数据类型</a>。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>在分析对象拷贝之前，我们先来看下一个例子。</p><p>比如有如下<code>Person</code>和<code>Name</code>两个类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Name name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Name <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(Name name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;age= &quot;</span>+age+<span class="string">&quot;;name = &quot;</span>+name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Name</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> String middleName;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Name</span><span class="params">(String firstName, String middleName, String lastName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">        <span class="keyword">this</span>.middleName = middleName;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirstName</span><span class="params">(String firstName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMiddleName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> middleName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMiddleName</span><span class="params">(String middleName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.middleName = middleName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastName</span><span class="params">(String lastName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> firstName + middleName + lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们创建一个”张三”的<code>person0</code>对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Name name = <span class="keyword">new</span> Name(<span class="string">&quot;张&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;三&quot;</span>);</span><br><span class="line">Person person0 = <span class="keyword">new</span> Person();</span><br><span class="line">person0.setAge(<span class="number">20</span>);</span><br><span class="line">person0.setName(name);</span><br></pre></td></tr></table></figure><p>如果我们新建两个<code>person</code>对象，<code>person1</code>和<code>person2</code>对<code>person0</code>进行属性拷贝。</p><p>两个对象的拷贝方式如代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Name name = <span class="keyword">new</span> Name(<span class="string">&quot;张&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;三&quot;</span>);</span><br><span class="line">    Person person0 = <span class="keyword">new</span> Person();</span><br><span class="line">    person0.setAge(<span class="number">20</span>);</span><br><span class="line">    person0.setName(name);</span><br><span class="line"></span><br><span class="line">    Person person1 = <span class="keyword">new</span> Person();</span><br><span class="line">    person1.setName(person0.getName());</span><br><span class="line">    person1.setAge(person0.getAge());</span><br><span class="line"></span><br><span class="line">    Person person2 = <span class="keyword">new</span> Person();</span><br><span class="line">    Name name2 = <span class="keyword">new</span> Name(name.getFirstName(),name.getMiddleName(),name.getLastName());</span><br><span class="line">    person2.setName(name2);</span><br><span class="line">    person2.setAge(person0.getAge());</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;修改前，person0 =&gt; &quot;</span> + person0);</span><br><span class="line">    System.out.println(<span class="string">&quot;修改前，person1 =&gt; &quot;</span> + person1);</span><br><span class="line">    System.out.println(<span class="string">&quot;修改前，person2 =&gt; &quot;</span> + person2);</span><br><span class="line"></span><br><span class="line">    person0.getName().setMiddleName(<span class="string">&quot;三&quot;</span>);</span><br><span class="line">    person0.setAge(<span class="number">21</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;修改后，person0 =&gt; &quot;</span> + person0);</span><br><span class="line">    System.out.println(<span class="string">&quot;修改后，person1 =&gt; &quot;</span> + person1);</span><br><span class="line">    System.out.println(<span class="string">&quot;修改后，person2 =&gt; &quot;</span> + person2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-885.png"></p><p>这段代码还是比较好理解的，<code>person1</code>对象使用的<code>name</code>和<code>person0</code>使用的<code>name</code>指向的堆内存中的同一个对象地址，当通过<code>person0</code>修改<code>name</code>对象属性时，<code>person1</code>中<code>name</code>对象的属性也会发生变化。</p><p>而<code>person2</code>中的<code>name</code>对象在堆内存中是一个新的地址，与<code>person0</code>中的<code>name</code>对象毫无关系，因此不受改动影响。</p><p>这也是我们要说的两种拷贝方式：<strong>浅拷贝(Shallow Copy)</strong> 和 **深拷贝(Deep Copy)**。</p><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>上述例子中<code>person1</code>的拷贝就为浅拷贝。</p><ul><li>对于数据类型是<strong>基本数据类型</strong>的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。因为是两份不同的数据，所以对其中一个对象的该成员变量值进行修改，不会影响另一个对象拷贝得到的数据。</li><li>对于数据类型是<strong>引用数据类型</strong>的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个对象实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。</li></ul><p>浅拷贝的模型图如下所示：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-886.png"></p><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>上述例子中的<code>person2</code>即为深拷贝。</p><ul><li>对于数据类型是<strong>基本数据类型</strong>的成员变量，深拷贝也会直接进行值传递，也就是将该属性值复制一份给新的对象。因为是两份不同的数据，所以对其中一个对象的该成员变量值进行修改，不会影响另一个对象拷贝得到的数据。</li><li>对于数据类型是<strong>引用数据类型</strong>的成员变量，比如说成员变量是某个数组、某个类的对象等，深拷贝会为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象图进行拷贝。</li></ul><p>深拷贝的模型图如下所示：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-887.png"></p><h2 id="clone方法"><a href="#clone方法" class="headerlink" title="clone方法"></a>clone方法</h2><p>我们知道，<code>clone</code>方法来自<code>Object</code>类，也就是所有<code>class</code>都会有此方法，那么它默认是使用的浅拷贝还是深拷贝呢？</p><p>我们来测一下即可。</p><p>由于<code>Object</code>类的<code>clone</code>方法是<code>protected</code>的，因此我们需要重写并实现相关方法，同时相关类要继承<code>Cloneable</code>接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Name name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Name <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(Name name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;age= &quot;</span>+age+<span class="string">&quot;;name = &quot;</span>+name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Name</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> String middleName;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Name</span><span class="params">(String firstName, String middleName, String lastName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">        <span class="keyword">this</span>.middleName = middleName;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirstName</span><span class="params">(String firstName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMiddleName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> middleName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMiddleName</span><span class="params">(String middleName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.middleName = middleName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastName</span><span class="params">(String lastName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> firstName + middleName + lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Name name = <span class="keyword">new</span> Name(<span class="string">&quot;张&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;三&quot;</span>);</span><br><span class="line">    Person person0 = <span class="keyword">new</span> Person();</span><br><span class="line">    person0.setAge(<span class="number">20</span>);</span><br><span class="line">    person0.setName(name);</span><br><span class="line"></span><br><span class="line">    Person person1 = <span class="keyword">new</span> Person();</span><br><span class="line">    person1.setName(person0.getName());</span><br><span class="line">    person1.setAge(person0.getAge());</span><br><span class="line"></span><br><span class="line">    Person person2 = <span class="keyword">new</span> Person();</span><br><span class="line">    Name name2 = <span class="keyword">new</span> Name(name.getFirstName(),name.getMiddleName(),name.getLastName());</span><br><span class="line">    person2.setName(name2);</span><br><span class="line">    person2.setAge(person0.getAge());</span><br><span class="line"></span><br><span class="line">    Person person3 = (Person) person0.clone();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;修改前，person0 =&gt; &quot;</span> + person0);</span><br><span class="line">    System.out.println(<span class="string">&quot;修改前，person1 =&gt; &quot;</span> + person1);</span><br><span class="line">    System.out.println(<span class="string">&quot;修改前，person2 =&gt; &quot;</span> + person2);</span><br><span class="line">    System.out.println(<span class="string">&quot;修改前，person3 =&gt; &quot;</span> + person3);</span><br><span class="line"></span><br><span class="line">    person0.getName().setMiddleName(<span class="string">&quot;三&quot;</span>);</span><br><span class="line">    person0.setAge(<span class="number">21</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;修改后，person0 =&gt; &quot;</span> + person0);</span><br><span class="line">    System.out.println(<span class="string">&quot;修改后，person1 =&gt; &quot;</span> + person1);</span><br><span class="line">    System.out.println(<span class="string">&quot;修改后，person2 =&gt; &quot;</span> + person2);</span><br><span class="line">    System.out.println(<span class="string">&quot;修改后，person3 =&gt; &quot;</span> + person3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-888.png"></p><p>我们可以看到，<code>person3</code>的<code>name</code>属性会发生变化，也就是**<code>Object</code>类的<code>clone</code>方法默认是浅拷贝**。</p><p>当然，我们也可以对其进行重写，使其变为深拷贝，代码大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    Person person = (Person)<span class="keyword">super</span>.clone();</span><br><span class="line">    person.setName((Name) <span class="keyword">this</span>.getName().clone());</span><br><span class="line">    <span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-889.png"></p><p>注意：上面我们<code>name</code>属性对象并未继续嵌套对象，如果还有嵌套对象，需要继续对其进行拷贝，直到该对象可达的所有对象。</p><h2 id="对象序列化实现深拷贝"><a href="#对象序列化实现深拷贝" class="headerlink" title="对象序列化实现深拷贝"></a>对象序列化实现深拷贝</h2><p>上面我们可以看到，如果一个对象关联的层级对象比较多，层次调用<code>clone</code>方法或者直接赋值操作等虽然可以实现深拷贝，但是代码量巨大。</p><p>我们可以使用序列化实现相关深拷贝的功能。</p><p>序列化有多种实现方式，有兴趣的可以看下这篇文章。<a href="https://www.sakuratears.top/blog/Java%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F.html">Java序列化和反序列化的几种方式</a></p><p>我们这儿用<code>Serializable</code>接口结合数据流来实现即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7366706869071951960L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Name name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Name <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(Name name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;age= &quot;</span>+age+<span class="string">&quot;;name = &quot;</span>+name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line"><span class="comment">//        Person person = (Person)super.clone();</span></span><br><span class="line"><span class="comment">//        person.setName((Name) this.getName().clone());</span></span><br><span class="line"><span class="comment">//        return person;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Name</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>,<span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2295042992462505660L</span>;</span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> String middleName;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Name</span><span class="params">(String firstName, String middleName, String lastName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">        <span class="keyword">this</span>.middleName = middleName;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirstName</span><span class="params">(String firstName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMiddleName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> middleName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMiddleName</span><span class="params">(String middleName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.middleName = middleName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastName</span><span class="params">(String lastName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> firstName + middleName + lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还是以上述两个类为例，为它们添加<code>Serializable</code>接口。</p><p>测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过序列化方法实现深拷贝</span></span><br><span class="line">Person person4 = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    ByteArrayOutputStream bos=<span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    ObjectOutputStream oos=<span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">    oos.writeObject(person0);</span><br><span class="line">    oos.flush();</span><br><span class="line">    ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">    ObjectInputStream ois=<span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line">    person4 =(Person) ois.readObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//应该放在finally里</span></span><br><span class="line">    bos.close();</span><br><span class="line">    oos.close();</span><br><span class="line">    bis.close();</span><br><span class="line">    ois.close();</span><br><span class="line">&#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-890.png"></p><p>可以看到<code>person0</code>的<code>name</code>修改后，<code>person4</code>属性并未发生变化，因此实现了深拷贝。</p><p>不过这种方式需要注意的一点是：<strong>被<code>transient</code>关键字修饰的属性是没法进行序列化的</strong>。</p><p>比如我们将<code>age</code>字段加上该关键字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> age;</span><br></pre></td></tr></table></figure><p>再来看下输出结果：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-891.png"></p><p>可以看到<code>person4</code>的<code>age</code>字段没有被赋值<code>20</code>，而是取的<code>int</code>默认值<code>0</code>。</p><p>这也是需要注意的一点。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是本篇文章的全部内容。</p><p>本文通过例子来分析对象浅拷贝及深拷贝的区别及特点，并了解了各自的一些实现方式。</p><p>了解对象的浅拷贝及深拷贝，对我们学习及工作都是有不小帮助的。</p>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Java&lt;/code&gt;中的对象拷贝(Object Copy)指的是将一个对象的所有属性（成员变量）拷贝到另一个有着相同类类型的对象中去。&lt;/p&gt;
&lt;p&gt;在程序中对象属性拷贝还是非常常见的，主要是为了在新的上下文环境中复用现有对象的部分或全部数据。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Java&lt;/code&gt;中的对象拷贝主要有 &lt;strong&gt;浅拷贝(Shallow Copy)&lt;/strong&gt; 和 &lt;strong&gt;深拷贝(Deep Copy)&lt;/strong&gt; 两种。&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="深拷贝" scheme="https://www.sakuratears.top/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    
    <category term="浅拷贝" scheme="https://www.sakuratears.top/tags/%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>Mysql limit 查询相关优化</title>
    <link href="https://www.sakuratears.top/blog/Mysql-limit-%E6%9F%A5%E8%AF%A2%E7%9B%B8%E5%85%B3%E4%BC%98%E5%8C%96.html"/>
    <id>https://www.sakuratears.top/blog/Mysql-limit-%E6%9F%A5%E8%AF%A2%E7%9B%B8%E5%85%B3%E4%BC%98%E5%8C%96.html</id>
    <published>2021-08-22T11:42:00.000Z</published>
    <updated>2021-08-22T11:49:59.031Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们知道，<code>Mysql</code>分页查询中<code>limit</code>查询，比如如下语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from my_table where index_col = xxx limit offset,limit; </span><br></pre></td></tr></table></figure><p>是会读取<code>offset</code>前面的数据的。</p><p>其表现为根据<code>index_col = xxx</code>条件定位到<code>offset</code>，再向后取<code>limit</code>行。</p><p>当数据量变大时，执行效率会下降。</p><p>什么意思呢？</p><p>我们通过一个例子来看下，并了解相关的优化方法。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>我们准备一张<code>student</code>表（随便一张测试表就行），其结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `student` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;,</span><br><span class="line">  `stu_no` varchar(20) NOT NULL COMMENT &#x27;学号&#x27;,</span><br><span class="line">  `stu_sex` char(1) DEFAULT NULL COMMENT &#x27;学生性别&#x27;,</span><br><span class="line">  `stu_birthday` date DEFAULT NULL COMMENT &#x27;学生生日&#x27;,</span><br><span class="line">  `stu_class` char(2) DEFAULT NULL COMMENT &#x27;学生班级&#x27;,</span><br><span class="line">  `stu_name` varchar(50) DEFAULT NULL COMMENT &#x27;学生姓名&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `idx_stu_no` (`stu_no`) USING BTREE</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><p>并向其中灌入200w数据（越多越好）。</p><p>部分相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LimitTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StudentMapper studentMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">2000000</span>;</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> n = num/step;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">            List&lt;StudentModel&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;step;i++) &#123;</span><br><span class="line">                StudentModel studentModel = <span class="keyword">new</span> StudentModel();</span><br><span class="line">                studentModel.setStuNo(k*step+i+<span class="string">&quot;&quot;</span>);</span><br><span class="line">                studentModel.setStuSex(<span class="keyword">new</span> Random().nextBoolean() ? <span class="string">&quot;1&quot;</span> : <span class="string">&quot;0&quot;</span>);</span><br><span class="line">                studentModel.setStuClass(<span class="keyword">new</span> Random().nextInt(<span class="number">4</span>)+<span class="number">1</span>+<span class="string">&quot;&quot;</span>);</span><br><span class="line">                studentModel.setStuBirthday(<span class="keyword">new</span> Date());</span><br><span class="line">                studentModel.setStuName(getChineseName());</span><br><span class="line">                list.add(studentModel);</span><br><span class="line">            &#125;</span><br><span class="line">            studentMapper.insertBatch(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getChineseName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String str = <span class="keyword">null</span>;</span><br><span class="line">        String name = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> highPos, lowPos;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="comment">//区码，0xA0打头，从第16区开始，即0xB0=11*16=176,16~55一级汉字，56~87二级汉字</span></span><br><span class="line">        highPos = (<span class="number">176</span> + Math.abs(random.nextInt(<span class="number">72</span>)));</span><br><span class="line">        random=<span class="keyword">new</span> Random();</span><br><span class="line">        <span class="comment">//位码，0xA0打头，范围第1~94列</span></span><br><span class="line">        lowPos = <span class="number">161</span> + Math.abs(random.nextInt(<span class="number">94</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bArr = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</span><br><span class="line">        bArr[<span class="number">0</span>] = (<span class="keyword">new</span> Integer(highPos)).byteValue();</span><br><span class="line">        bArr[<span class="number">1</span>] = (<span class="keyword">new</span> Integer(lowPos)).byteValue();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//区位码组合成汉字</span></span><br><span class="line">            str = <span class="keyword">new</span> String(bArr, <span class="string">&quot;GB2312&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> index=random.nextInt(Surname.length-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//获得一个随机的姓氏</span></span><br><span class="line">            name = Surname[index] +str;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//百家姓</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] Surname= &#123;<span class="string">&quot;赵&quot;</span>,<span class="string">&quot;钱&quot;</span>,<span class="string">&quot;孙&quot;</span>,<span class="string">&quot;李&quot;</span>,<span class="string">&quot;周&quot;</span>,<span class="string">&quot;吴&quot;</span>,<span class="string">&quot;郑&quot;</span>,<span class="string">&quot;王&quot;</span>,<span class="string">&quot;冯&quot;</span>,<span class="string">&quot;陈&quot;</span>,<span class="string">&quot;褚&quot;</span>,<span class="string">&quot;卫&quot;</span>,<span class="string">&quot;蒋&quot;</span>,<span class="string">&quot;沈&quot;</span>,<span class="string">&quot;韩&quot;</span>,<span class="string">&quot;杨&quot;</span>,<span class="string">&quot;朱&quot;</span>,<span class="string">&quot;秦&quot;</span>,<span class="string">&quot;尤&quot;</span>,<span class="string">&quot;许&quot;</span>,<span class="string">&quot;何&quot;</span>,<span class="string">&quot;吕&quot;</span>,<span class="string">&quot;施&quot;</span>,<span class="string">&quot;张&quot;</span>,<span class="string">&quot;孔&quot;</span>,<span class="string">&quot;曹&quot;</span>,<span class="string">&quot;严&quot;</span>,<span class="string">&quot;华&quot;</span>,<span class="string">&quot;金&quot;</span>,<span class="string">&quot;魏&quot;</span>,<span class="string">&quot;陶&quot;</span>,<span class="string">&quot;姜&quot;</span>,<span class="string">&quot;戚&quot;</span>,<span class="string">&quot;谢&quot;</span>,<span class="string">&quot;邹&quot;</span>,<span class="string">&quot;喻&quot;</span>,<span class="string">&quot;柏&quot;</span>,<span class="string">&quot;水&quot;</span>,<span class="string">&quot;窦&quot;</span>,<span class="string">&quot;章&quot;</span>,<span class="string">&quot;云&quot;</span>,<span class="string">&quot;苏&quot;</span>,<span class="string">&quot;潘&quot;</span>,<span class="string">&quot;葛&quot;</span>,<span class="string">&quot;奚&quot;</span>,<span class="string">&quot;范&quot;</span>,<span class="string">&quot;彭&quot;</span>,<span class="string">&quot;郎&quot;</span>,<span class="string">&quot;鲁&quot;</span>,<span class="string">&quot;韦&quot;</span>,<span class="string">&quot;昌&quot;</span>,<span class="string">&quot;马&quot;</span>,<span class="string">&quot;苗&quot;</span>,<span class="string">&quot;凤&quot;</span>,<span class="string">&quot;花&quot;</span>,<span class="string">&quot;方&quot;</span>,<span class="string">&quot;俞&quot;</span>,<span class="string">&quot;任&quot;</span>,<span class="string">&quot;袁&quot;</span>,<span class="string">&quot;柳&quot;</span>,<span class="string">&quot;酆&quot;</span>,<span class="string">&quot;鲍&quot;</span>,<span class="string">&quot;史&quot;</span>,<span class="string">&quot;唐&quot;</span>,<span class="string">&quot;费&quot;</span>,<span class="string">&quot;廉&quot;</span>,<span class="string">&quot;岑&quot;</span>,<span class="string">&quot;薛&quot;</span>,<span class="string">&quot;雷&quot;</span>,<span class="string">&quot;贺&quot;</span>,<span class="string">&quot;倪&quot;</span>,<span class="string">&quot;汤&quot;</span>,<span class="string">&quot;滕&quot;</span>,<span class="string">&quot;殷&quot;</span>,<span class="string">&quot;罗&quot;</span>,<span class="string">&quot;毕&quot;</span>,<span class="string">&quot;郝&quot;</span>,<span class="string">&quot;邬&quot;</span>,<span class="string">&quot;安&quot;</span>,<span class="string">&quot;常&quot;</span>,<span class="string">&quot;乐&quot;</span>,<span class="string">&quot;于&quot;</span>,<span class="string">&quot;时&quot;</span>,<span class="string">&quot;傅&quot;</span>,<span class="string">&quot;皮&quot;</span>,<span class="string">&quot;卞&quot;</span>,<span class="string">&quot;齐&quot;</span>,<span class="string">&quot;康&quot;</span>,<span class="string">&quot;伍&quot;</span>,<span class="string">&quot;余&quot;</span>,<span class="string">&quot;元&quot;</span>,<span class="string">&quot;卜&quot;</span>,<span class="string">&quot;顾&quot;</span>,<span class="string">&quot;孟&quot;</span>,<span class="string">&quot;平&quot;</span>,<span class="string">&quot;黄&quot;</span>,<span class="string">&quot;和&quot;</span>,<span class="string">&quot;穆&quot;</span>,<span class="string">&quot;萧&quot;</span>,<span class="string">&quot;尹&quot;</span>,<span class="string">&quot;姚&quot;</span>,<span class="string">&quot;邵&quot;</span>,<span class="string">&quot;湛&quot;</span>,<span class="string">&quot;汪&quot;</span>,<span class="string">&quot;祁&quot;</span>,<span class="string">&quot;毛&quot;</span>,<span class="string">&quot;禹&quot;</span>,<span class="string">&quot;狄&quot;</span>,<span class="string">&quot;米&quot;</span>,<span class="string">&quot;贝&quot;</span>,<span class="string">&quot;明&quot;</span>,<span class="string">&quot;臧&quot;</span>,<span class="string">&quot;计&quot;</span>,<span class="string">&quot;伏&quot;</span>,<span class="string">&quot;成&quot;</span>,<span class="string">&quot;戴&quot;</span>,<span class="string">&quot;谈&quot;</span>,<span class="string">&quot;宋&quot;</span>,<span class="string">&quot;茅&quot;</span>,<span class="string">&quot;庞&quot;</span>,<span class="string">&quot;熊&quot;</span>,<span class="string">&quot;纪&quot;</span>,<span class="string">&quot;舒&quot;</span>,<span class="string">&quot;屈&quot;</span>,<span class="string">&quot;项&quot;</span>,<span class="string">&quot;祝&quot;</span>,<span class="string">&quot;董&quot;</span>,<span class="string">&quot;梁&quot;</span>,<span class="string">&quot;杜&quot;</span>,<span class="string">&quot;阮&quot;</span>,<span class="string">&quot;蓝&quot;</span>,<span class="string">&quot;闵&quot;</span>,<span class="string">&quot;席&quot;</span>,<span class="string">&quot;季&quot;</span>,<span class="string">&quot;麻&quot;</span>,<span class="string">&quot;强&quot;</span>,<span class="string">&quot;贾&quot;</span>,<span class="string">&quot;路&quot;</span>,<span class="string">&quot;娄&quot;</span>,<span class="string">&quot;危&quot;</span>,<span class="string">&quot;江&quot;</span>,<span class="string">&quot;童&quot;</span>,<span class="string">&quot;颜&quot;</span>,<span class="string">&quot;郭&quot;</span>,<span class="string">&quot;梅&quot;</span>,<span class="string">&quot;盛&quot;</span>,<span class="string">&quot;林&quot;</span>,<span class="string">&quot;刁&quot;</span>,<span class="string">&quot;钟&quot;</span>,<span class="string">&quot;徐&quot;</span>,<span class="string">&quot;邱&quot;</span>,<span class="string">&quot;骆&quot;</span>,<span class="string">&quot;高&quot;</span>,<span class="string">&quot;夏&quot;</span>,<span class="string">&quot;蔡&quot;</span>,<span class="string">&quot;田&quot;</span>,<span class="string">&quot;樊&quot;</span>,<span class="string">&quot;胡&quot;</span>,<span class="string">&quot;凌&quot;</span>,<span class="string">&quot;霍&quot;</span>,<span class="string">&quot;虞&quot;</span>,<span class="string">&quot;万&quot;</span>,<span class="string">&quot;支&quot;</span>,<span class="string">&quot;柯&quot;</span>,<span class="string">&quot;昝&quot;</span>,<span class="string">&quot;管&quot;</span>,<span class="string">&quot;卢&quot;</span>,<span class="string">&quot;莫&quot;</span>,<span class="string">&quot;经&quot;</span>,<span class="string">&quot;房&quot;</span>,<span class="string">&quot;裘&quot;</span>,<span class="string">&quot;缪&quot;</span>,<span class="string">&quot;干&quot;</span>,<span class="string">&quot;解&quot;</span>,<span class="string">&quot;应&quot;</span>,<span class="string">&quot;宗&quot;</span>,<span class="string">&quot;丁&quot;</span>,<span class="string">&quot;宣&quot;</span>,<span class="string">&quot;贲&quot;</span>,<span class="string">&quot;邓&quot;</span>,<span class="string">&quot;郁&quot;</span>,<span class="string">&quot;单&quot;</span>,<span class="string">&quot;杭&quot;</span>,<span class="string">&quot;洪&quot;</span>,<span class="string">&quot;包&quot;</span>,<span class="string">&quot;诸&quot;</span>,<span class="string">&quot;左&quot;</span>,<span class="string">&quot;石&quot;</span>,<span class="string">&quot;崔&quot;</span>,<span class="string">&quot;吉&quot;</span>,<span class="string">&quot;钮&quot;</span>,<span class="string">&quot;龚&quot;</span>,<span class="string">&quot;程&quot;</span>,<span class="string">&quot;嵇&quot;</span>,<span class="string">&quot;邢&quot;</span>,<span class="string">&quot;滑&quot;</span>,<span class="string">&quot;裴&quot;</span>,<span class="string">&quot;陆&quot;</span>,<span class="string">&quot;荣&quot;</span>,<span class="string">&quot;翁&quot;</span>,<span class="string">&quot;荀&quot;</span>,<span class="string">&quot;羊&quot;</span>,<span class="string">&quot;于&quot;</span>,<span class="string">&quot;惠&quot;</span>,<span class="string">&quot;甄&quot;</span>,<span class="string">&quot;曲&quot;</span>,<span class="string">&quot;家&quot;</span>,<span class="string">&quot;封&quot;</span>,<span class="string">&quot;芮&quot;</span>,<span class="string">&quot;羿&quot;</span>,<span class="string">&quot;储&quot;</span>,<span class="string">&quot;靳&quot;</span>,<span class="string">&quot;汲&quot;</span>,<span class="string">&quot;邴&quot;</span>,<span class="string">&quot;糜&quot;</span>,<span class="string">&quot;松&quot;</span>,<span class="string">&quot;井&quot;</span>,<span class="string">&quot;段&quot;</span>,<span class="string">&quot;富&quot;</span>,<span class="string">&quot;巫&quot;</span>,<span class="string">&quot;乌&quot;</span>,<span class="string">&quot;焦&quot;</span>,<span class="string">&quot;巴&quot;</span>,<span class="string">&quot;弓&quot;</span>,<span class="string">&quot;牧&quot;</span>,<span class="string">&quot;隗&quot;</span>,<span class="string">&quot;山&quot;</span>,<span class="string">&quot;谷&quot;</span>,<span class="string">&quot;车&quot;</span>,<span class="string">&quot;侯&quot;</span>,<span class="string">&quot;宓&quot;</span>,<span class="string">&quot;蓬&quot;</span>,<span class="string">&quot;全&quot;</span>,<span class="string">&quot;郗&quot;</span>,<span class="string">&quot;班&quot;</span>,<span class="string">&quot;仰&quot;</span>,<span class="string">&quot;秋&quot;</span>,<span class="string">&quot;仲&quot;</span>,<span class="string">&quot;伊&quot;</span>,<span class="string">&quot;宫&quot;</span>,<span class="string">&quot;宁&quot;</span>,<span class="string">&quot;仇&quot;</span>,<span class="string">&quot;栾&quot;</span>,<span class="string">&quot;暴&quot;</span>,<span class="string">&quot;甘&quot;</span>,<span class="string">&quot;钭&quot;</span>,<span class="string">&quot;厉&quot;</span>,<span class="string">&quot;戎&quot;</span>,<span class="string">&quot;祖&quot;</span>,<span class="string">&quot;武&quot;</span>,<span class="string">&quot;符&quot;</span>,<span class="string">&quot;刘&quot;</span>,<span class="string">&quot;景&quot;</span>,<span class="string">&quot;詹&quot;</span>,<span class="string">&quot;束&quot;</span>,<span class="string">&quot;龙&quot;</span>,<span class="string">&quot;叶&quot;</span>,<span class="string">&quot;幸&quot;</span>,<span class="string">&quot;司&quot;</span>,<span class="string">&quot;韶&quot;</span>,<span class="string">&quot;郜&quot;</span>,<span class="string">&quot;黎&quot;</span>,<span class="string">&quot;蓟&quot;</span>,<span class="string">&quot;溥&quot;</span>,<span class="string">&quot;印&quot;</span>,<span class="string">&quot;宿&quot;</span>,<span class="string">&quot;白&quot;</span>,<span class="string">&quot;怀&quot;</span>,<span class="string">&quot;蒲&quot;</span>,<span class="string">&quot;邰&quot;</span>,<span class="string">&quot;从&quot;</span>,<span class="string">&quot;鄂&quot;</span>,<span class="string">&quot;索&quot;</span>,<span class="string">&quot;咸&quot;</span>,<span class="string">&quot;籍&quot;</span>,<span class="string">&quot;赖&quot;</span>,<span class="string">&quot;卓&quot;</span>,<span class="string">&quot;蔺&quot;</span>,<span class="string">&quot;屠&quot;</span>,<span class="string">&quot;蒙&quot;</span>,<span class="string">&quot;池&quot;</span>,<span class="string">&quot;乔&quot;</span>,<span class="string">&quot;阴&quot;</span>,<span class="string">&quot;郁&quot;</span>,<span class="string">&quot;胥&quot;</span>,<span class="string">&quot;能&quot;</span>,<span class="string">&quot;苍&quot;</span>,<span class="string">&quot;双&quot;</span>,<span class="string">&quot;闻&quot;</span>,<span class="string">&quot;莘&quot;</span>,<span class="string">&quot;党&quot;</span>,<span class="string">&quot;翟&quot;</span>,<span class="string">&quot;谭&quot;</span>,<span class="string">&quot;贡&quot;</span>,<span class="string">&quot;劳&quot;</span>,<span class="string">&quot;逄&quot;</span>,<span class="string">&quot;姬&quot;</span>,<span class="string">&quot;申&quot;</span>,<span class="string">&quot;扶&quot;</span>,<span class="string">&quot;堵&quot;</span>,<span class="string">&quot;冉&quot;</span>,<span class="string">&quot;宰&quot;</span>,<span class="string">&quot;郦&quot;</span>,<span class="string">&quot;雍&quot;</span>,<span class="string">&quot;却&quot;</span>,</span><br><span class="line"><span class="string">&quot;璩&quot;</span>,<span class="string">&quot;桑&quot;</span>,<span class="string">&quot;桂&quot;</span>,<span class="string">&quot;濮&quot;</span>,<span class="string">&quot;牛&quot;</span>,<span class="string">&quot;寿&quot;</span>,<span class="string">&quot;通&quot;</span>,<span class="string">&quot;边&quot;</span>,<span class="string">&quot;扈&quot;</span>,<span class="string">&quot;燕&quot;</span>,<span class="string">&quot;冀&quot;</span>,<span class="string">&quot;浦&quot;</span>,<span class="string">&quot;尚&quot;</span>,<span class="string">&quot;农&quot;</span>,<span class="string">&quot;温&quot;</span>,<span class="string">&quot;别&quot;</span>,<span class="string">&quot;庄&quot;</span>,<span class="string">&quot;晏&quot;</span>,<span class="string">&quot;柴&quot;</span>,<span class="string">&quot;瞿&quot;</span>,<span class="string">&quot;阎&quot;</span>,<span class="string">&quot;充&quot;</span>,<span class="string">&quot;慕&quot;</span>,<span class="string">&quot;连&quot;</span>,<span class="string">&quot;茹&quot;</span>,<span class="string">&quot;习&quot;</span>,<span class="string">&quot;宦&quot;</span>,<span class="string">&quot;艾&quot;</span>,<span class="string">&quot;鱼&quot;</span>,<span class="string">&quot;容&quot;</span>,<span class="string">&quot;向&quot;</span>,<span class="string">&quot;古&quot;</span>,<span class="string">&quot;易&quot;</span>,<span class="string">&quot;慎&quot;</span>,<span class="string">&quot;戈&quot;</span>,<span class="string">&quot;廖&quot;</span>,<span class="string">&quot;庾&quot;</span>,<span class="string">&quot;终&quot;</span>,<span class="string">&quot;暨&quot;</span>,<span class="string">&quot;居&quot;</span>,<span class="string">&quot;衡&quot;</span>,<span class="string">&quot;步&quot;</span>,<span class="string">&quot;都&quot;</span>,<span class="string">&quot;耿&quot;</span>,<span class="string">&quot;满&quot;</span>,<span class="string">&quot;弘&quot;</span>,<span class="string">&quot;匡&quot;</span>,<span class="string">&quot;国&quot;</span>,<span class="string">&quot;文&quot;</span>,<span class="string">&quot;寇&quot;</span>,<span class="string">&quot;广&quot;</span>,<span class="string">&quot;禄&quot;</span>,<span class="string">&quot;阙&quot;</span>,<span class="string">&quot;东&quot;</span>,<span class="string">&quot;欧&quot;</span>,<span class="string">&quot;殳&quot;</span>,<span class="string">&quot;沃&quot;</span>,<span class="string">&quot;利&quot;</span>,<span class="string">&quot;蔚&quot;</span>,<span class="string">&quot;越&quot;</span>,<span class="string">&quot;夔&quot;</span>,<span class="string">&quot;隆&quot;</span>,<span class="string">&quot;师&quot;</span>,<span class="string">&quot;巩&quot;</span>,<span class="string">&quot;厍&quot;</span>,<span class="string">&quot;聂&quot;</span>,<span class="string">&quot;晁&quot;</span>,<span class="string">&quot;勾&quot;</span>,<span class="string">&quot;敖&quot;</span>,<span class="string">&quot;融&quot;</span>,<span class="string">&quot;冷&quot;</span>,<span class="string">&quot;訾&quot;</span>,<span class="string">&quot;辛&quot;</span>,<span class="string">&quot;阚&quot;</span>,<span class="string">&quot;那&quot;</span>,<span class="string">&quot;简&quot;</span>,<span class="string">&quot;饶&quot;</span>,<span class="string">&quot;空&quot;</span>,<span class="string">&quot;曾&quot;</span>,<span class="string">&quot;毋&quot;</span>,<span class="string">&quot;沙&quot;</span>,<span class="string">&quot;乜&quot;</span>,<span class="string">&quot;养&quot;</span>,<span class="string">&quot;鞠&quot;</span>,<span class="string">&quot;须&quot;</span>,<span class="string">&quot;丰&quot;</span>,<span class="string">&quot;巢&quot;</span>,<span class="string">&quot;关&quot;</span>,<span class="string">&quot;蒯&quot;</span>,<span class="string">&quot;相&quot;</span>,<span class="string">&quot;查&quot;</span>,<span class="string">&quot;后&quot;</span>,<span class="string">&quot;荆&quot;</span>,<span class="string">&quot;红&quot;</span>,<span class="string">&quot;游&quot;</span>,<span class="string">&quot;郏&quot;</span>,<span class="string">&quot;竺&quot;</span>,<span class="string">&quot;权&quot;</span>,<span class="string">&quot;逯&quot;</span>,<span class="string">&quot;盖&quot;</span>,<span class="string">&quot;益&quot;</span>,<span class="string">&quot;桓&quot;</span>,<span class="string">&quot;公&quot;</span>,<span class="string">&quot;仉&quot;</span>,<span class="string">&quot;督&quot;</span>,<span class="string">&quot;岳&quot;</span>,<span class="string">&quot;帅&quot;</span>,<span class="string">&quot;缑&quot;</span>,<span class="string">&quot;亢&quot;</span>,<span class="string">&quot;况&quot;</span>,<span class="string">&quot;郈&quot;</span>,<span class="string">&quot;有&quot;</span>,<span class="string">&quot;琴&quot;</span>,<span class="string">&quot;归&quot;</span>,<span class="string">&quot;海&quot;</span>,<span class="string">&quot;晋&quot;</span>,<span class="string">&quot;楚&quot;</span>,<span class="string">&quot;闫&quot;</span>,<span class="string">&quot;法&quot;</span>,<span class="string">&quot;汝&quot;</span>,<span class="string">&quot;鄢&quot;</span>,<span class="string">&quot;涂&quot;</span>,<span class="string">&quot;钦&quot;</span>,<span class="string">&quot;商&quot;</span>,<span class="string">&quot;牟&quot;</span>,<span class="string">&quot;佘&quot;</span>,<span class="string">&quot;佴&quot;</span>,<span class="string">&quot;伯&quot;</span>,<span class="string">&quot;赏&quot;</span>,<span class="string">&quot;墨&quot;</span>,<span class="string">&quot;哈&quot;</span>,<span class="string">&quot;谯&quot;</span>,<span class="string">&quot;篁&quot;</span>,<span class="string">&quot;年&quot;</span>,<span class="string">&quot;爱&quot;</span>,<span class="string">&quot;阳&quot;</span>,<span class="string">&quot;佟&quot;</span>,<span class="string">&quot;言&quot;</span>,<span class="string">&quot;福&quot;</span>,<span class="string">&quot;南&quot;</span>,<span class="string">&quot;火&quot;</span>,<span class="string">&quot;铁&quot;</span>,<span class="string">&quot;迟&quot;</span>,<span class="string">&quot;漆&quot;</span>,<span class="string">&quot;官&quot;</span>,<span class="string">&quot;冼&quot;</span>,<span class="string">&quot;真&quot;</span>,<span class="string">&quot;展&quot;</span>,<span class="string">&quot;繁&quot;</span>,<span class="string">&quot;檀&quot;</span>,<span class="string">&quot;祭&quot;</span>,<span class="string">&quot;密&quot;</span>,<span class="string">&quot;敬&quot;</span>,<span class="string">&quot;揭&quot;</span>,<span class="string">&quot;舜&quot;</span>,<span class="string">&quot;楼&quot;</span>,<span class="string">&quot;疏&quot;</span>,<span class="string">&quot;冒&quot;</span>,<span class="string">&quot;浑&quot;</span>,<span class="string">&quot;挚&quot;</span>,<span class="string">&quot;胶&quot;</span>,<span class="string">&quot;随&quot;</span>,<span class="string">&quot;高&quot;</span>,<span class="string">&quot;皋&quot;</span>,<span class="string">&quot;原&quot;</span>,<span class="string">&quot;种&quot;</span>,<span class="string">&quot;练&quot;</span>,<span class="string">&quot;弥&quot;</span>,<span class="string">&quot;仓&quot;</span>,<span class="string">&quot;眭&quot;</span>,<span class="string">&quot;蹇&quot;</span>,<span class="string">&quot;覃&quot;</span>,<span class="string">&quot;阿&quot;</span>,<span class="string">&quot;门&quot;</span>,<span class="string">&quot;恽&quot;</span>,<span class="string">&quot;来&quot;</span>,<span class="string">&quot;綦&quot;</span>,<span class="string">&quot;召&quot;</span>,<span class="string">&quot;仪&quot;</span>,<span class="string">&quot;风&quot;</span>,<span class="string">&quot;介&quot;</span>,<span class="string">&quot;巨&quot;</span>,<span class="string">&quot;木&quot;</span>,<span class="string">&quot;京&quot;</span>,<span class="string">&quot;狐&quot;</span>,<span class="string">&quot;郇&quot;</span>,<span class="string">&quot;虎&quot;</span>,<span class="string">&quot;枚&quot;</span>,<span class="string">&quot;抗&quot;</span>,<span class="string">&quot;达&quot;</span>,<span class="string">&quot;杞&quot;</span>,<span class="string">&quot;苌&quot;</span>,<span class="string">&quot;折&quot;</span>,<span class="string">&quot;麦&quot;</span>,<span class="string">&quot;庆&quot;</span>,<span class="string">&quot;过&quot;</span>,<span class="string">&quot;竹&quot;</span>,<span class="string">&quot;端&quot;</span>,<span class="string">&quot;鲜&quot;</span>,<span class="string">&quot;皇&quot;</span>,<span class="string">&quot;亓&quot;</span>,<span class="string">&quot;老&quot;</span>,<span class="string">&quot;是&quot;</span>,<span class="string">&quot;秘&quot;</span>,<span class="string">&quot;畅&quot;</span>,<span class="string">&quot;邝&quot;</span>,<span class="string">&quot;还&quot;</span>,<span class="string">&quot;宾&quot;</span>,<span class="string">&quot;闾&quot;</span>,<span class="string">&quot;辜&quot;</span>,<span class="string">&quot;纵&quot;</span>,<span class="string">&quot;侴&quot;</span>,<span class="string">&quot;万俟&quot;</span>,<span class="string">&quot;司马&quot;</span>,<span class="string">&quot;上官&quot;</span>,<span class="string">&quot;欧阳&quot;</span>,<span class="string">&quot;夏侯&quot;</span>,<span class="string">&quot;诸葛&quot;</span>,<span class="string">&quot;闻人&quot;</span>,<span class="string">&quot;东方&quot;</span>,<span class="string">&quot;赫连&quot;</span>,<span class="string">&quot;皇甫&quot;</span>,<span class="string">&quot;羊舌&quot;</span>,<span class="string">&quot;尉迟&quot;</span>,<span class="string">&quot;公羊&quot;</span>,<span class="string">&quot;澹台&quot;</span>,<span class="string">&quot;公冶&quot;</span>,<span class="string">&quot;宗正&quot;</span>,<span class="string">&quot;濮阳&quot;</span>,<span class="string">&quot;淳于&quot;</span>,<span class="string">&quot;单于&quot;</span>,<span class="string">&quot;太叔&quot;</span>,<span class="string">&quot;申屠&quot;</span>,<span class="string">&quot;公孙&quot;</span>,<span class="string">&quot;仲孙&quot;</span>,<span class="string">&quot;轩辕&quot;</span>,<span class="string">&quot;令狐&quot;</span>,<span class="string">&quot;钟离&quot;</span>,<span class="string">&quot;宇文&quot;</span>,<span class="string">&quot;长孙&quot;</span>,<span class="string">&quot;慕容&quot;</span>,<span class="string">&quot;鲜于&quot;</span>,<span class="string">&quot;闾丘&quot;</span>,<span class="string">&quot;司徒&quot;</span>,<span class="string">&quot;司空&quot;</span>,<span class="string">&quot;兀官&quot;</span>,<span class="string">&quot;司寇&quot;</span>,<span class="string">&quot;南门&quot;</span>,<span class="string">&quot;呼延&quot;</span>,<span class="string">&quot;子车&quot;</span>,<span class="string">&quot;颛孙&quot;</span>,<span class="string">&quot;端木&quot;</span>,<span class="string">&quot;巫马&quot;</span>,<span class="string">&quot;公西&quot;</span>,<span class="string">&quot;漆雕&quot;</span>,<span class="string">&quot;车正&quot;</span>,<span class="string">&quot;壤驷&quot;</span>,<span class="string">&quot;公良&quot;</span>,<span class="string">&quot;拓跋&quot;</span>,<span class="string">&quot;夹谷&quot;</span>,<span class="string">&quot;宰父&quot;</span>,<span class="string">&quot;谷梁&quot;</span>,<span class="string">&quot;段干&quot;</span>,<span class="string">&quot;百里&quot;</span>,<span class="string">&quot;东郭&quot;</span>,<span class="string">&quot;微生&quot;</span>,<span class="string">&quot;梁丘&quot;</span>,<span class="string">&quot;左丘&quot;</span>,<span class="string">&quot;东门&quot;</span>,<span class="string">&quot;西门&quot;</span>,<span class="string">&quot;南宫&quot;</span>,<span class="string">&quot;第五&quot;</span>,<span class="string">&quot;公仪&quot;</span>,<span class="string">&quot;公乘&quot;</span>,<span class="string">&quot;太史&quot;</span>,<span class="string">&quot;仲长&quot;</span>,<span class="string">&quot;叔孙&quot;</span>,<span class="string">&quot;屈突&quot;</span>,<span class="string">&quot;尔朱&quot;</span>,<span class="string">&quot;东乡&quot;</span>,<span class="string">&quot;相里&quot;</span>,<span class="string">&quot;胡母&quot;</span>,<span class="string">&quot;司城&quot;</span>,<span class="string">&quot;张廖&quot;</span>,<span class="string">&quot;雍门&quot;</span>,<span class="string">&quot;毋丘&quot;</span>,<span class="string">&quot;贺兰&quot;</span>,<span class="string">&quot;綦毋&quot;</span>,<span class="string">&quot;屋庐&quot;</span>,<span class="string">&quot;独孤&quot;</span>,<span class="string">&quot;南郭&quot;</span>,<span class="string">&quot;北宫&quot;</span>,<span class="string">&quot;王孙&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-875.png"></p><p>以上便完成了我们的前期数据准备工作。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>我们开始使用分页语句<code>limit</code>进行多次测试。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student ORDER BY stu_no LIMIT 10,10;</span><br></pre></td></tr></table></figure><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-876.png"></p><p>我们可以看到查询还是比较快的。</p><p>我们增大<code>offset</code>进行测试，这次我们来查询1000000条后的10条。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student ORDER BY stu_no LIMIT 1000000,10;</span><br></pre></td></tr></table></figure><p>可以看到耗时已经达到了 3.6s。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-877.png"></p><p>当我们继续增大<code>offset</code>时，花费的时间会更多。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>在上面建表时，我们<code>stu_no</code>是有索引的，我们用 <code>explain</code>分析一下如下两条语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN select * from student ORDER BY stu_no LIMIT 10,10;</span><br></pre></td></tr></table></figure><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-878.png"></p><p>可以看到当<code>offset</code>较小时是使用到了<code>stu_no</code>索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN select * from student ORDER BY stu_no LIMIT 1000000,10;</span><br></pre></td></tr></table></figure><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-879.png"></p><p>可以看到，当<code>offset</code>较大时，该语句就会进行全表扫描，这就是效率低的原因。</p><p>为什么会这样呢？</p><p>因为我们给<code>stu_no</code>创建了索引，为B+Tree，普通索引其子节点上存储的是主键值，我们按照<code>stu_no</code>排序时，其逻辑为先根据<code>stu_no</code>找到主键<code>id</code>，再根据主键索引找到记录（回表），数据量较大时，<code>Mysql</code>由于需要拉出<code>offset</code>前的所有数据，因此查询优化器分析后，认为还不如走全表扫描，因此就会走全表扫描。</p><p>这也就是上面我们看到的结果。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>定位到上面问题后，我们该如何优化呢？</p><p>我们先来看下如果强制使用<code>stu_no</code>进行查询，结果如何？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student force INDEX(idx_stu_no) ORDER BY stu_no  LIMIT 1000000,10;</span><br></pre></td></tr></table></figure><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-880.png"></p><p>可以看到耗时5s，比全表扫描要慢，看来<code>Mysql</code>的查询优化器分析的是没错的。</p><p>我们有什么优化手段呢？</p><p>我们想要的是1000000条后的10条数据，也就是前面的数据是没用的，但是<code>Mysql</code>查询的时候是要分析前1000000条数据的。</p><p>因此我们可以只保留最简单的信息，即主键，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from student ORDER BY stu_no LIMIT 1000000,10;</span><br></pre></td></tr></table></figure><p>可以看到这条语句查询很快，也用到了索引（就相当于在<code>stu_no</code>的B+Tree索引中找数据，不用回表）。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-881.png"></p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-882.png"></p><p>这样相当于拿到了1000000条后的10条数据的主键，我们用它们作为临时表，关联一下即可拿到数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student s,(select id from student ORDER BY stu_no LIMIT 1000000,10) temp where temp.id=s.id;</span><br></pre></td></tr></table></figure><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-883.png"></p><p>可以看到优化后的耗时大大缩短，我们使用<code>explain</code>可以看到分析结果。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-884.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上述就是关于<code>Mysql</code>分页语句<code>limit</code>的优化总结。</p><p>其关键思路如下：</p><ul><li>根据条件（默认条件字段有索引）及 <code>limit</code> 拿到主键列表（会直接查询索引树，不用回表）；</li><li>根据拿到的主键列表关联主表查询。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from my_table s,(select id from my_table ORDER BY index_col LIMIT 1000000,10) temp where temp.id=s.id;</span><br></pre></td></tr></table></figure><p>普通的<code>limit</code>语句慢的原因：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from my_table ORDER BY index_col LIMIT 1000000,10;</span><br></pre></td></tr></table></figure><ul><li><code>Mysql</code> 需要查询前1000000行，而后再取后面10行数据，其实前1000000行我们遍历直接通过<code>index_col</code>建立的B+Tree来处理就行。</li></ul>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我们知道，&lt;code&gt;Mysql&lt;/code&gt;分页查询中&lt;code&gt;limit&lt;/code&gt;查询，比如如下语句：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;select * from my_table where index_col = xxx limit offset,limit; &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;是会读取&lt;code&gt;offset&lt;/code&gt;前面的数据的。&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="MySQL" scheme="https://www.sakuratears.top/tags/MySQL/"/>
    
    <category term="limit" scheme="https://www.sakuratears.top/tags/limit/"/>
    
  </entry>
  
  <entry>
    <title>Java中的堆和栈存放的数据类型</title>
    <link href="https://www.sakuratears.top/blog/Java%E4%B8%AD%E7%9A%84%E5%A0%86%E5%92%8C%E6%A0%88%E5%AD%98%E6%94%BE%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html"/>
    <id>https://www.sakuratears.top/blog/Java%E4%B8%AD%E7%9A%84%E5%A0%86%E5%92%8C%E6%A0%88%E5%AD%98%E6%94%BE%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html</id>
    <published>2021-08-22T11:39:00.000Z</published>
    <updated>2021-08-22T11:48:12.799Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因为面试中经常被问到关于Java中堆和栈的数据存放问题，今天我们就来简单了解下堆和栈。</p><p>这篇文章仅仅是Java堆和栈的一个入门，我们结合实际例子来了解下堆和栈的关系及区别。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>我们常说堆栈堆栈，其实堆和栈是两个不同的地方，那么什么样的数据会放在堆中，什么样的数据会放在栈中呢？</p><p>这儿先说结论：</p><ul><li>Java 栈（Stack）中存放如下类型数据：基本数据类型、引用类型变量、方法函数。</li><li>Java 堆（Heap）中存放如下类型数据：实例对象。</li></ul><p>如下表：</p><table><thead><tr><th>栈（Stack）存放的数据</th><th>堆（Heap）存放的数据</th></tr></thead><tbody><tr><td>基本类型变量</td><td>实例对象</td></tr><tr><td>引用类型变量</td><td></td></tr><tr><td>方法函数</td><td></td></tr></tbody></table><p>栈的优点：存取速度比堆快，仅次于寄存器，栈数据可以共享。</p><p>栈的缺点：存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。</p><p>在函数中定义的一些<strong>基本类型的变量和对象的引用变量</strong>都是在函数的<strong>栈Stack</strong>内存中分配。当在一段代码块中定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量分配的内存空间，该内存空间可以立刻被另作他用。</p><p><strong>堆Heap</strong>内存用于存放由新创建的对象和数组。在堆中分配的内存，由java虚拟机自动垃圾回收器来管理。在堆中产生了一个数组或者对象后，<strong>还可以在栈中定义一个特殊的变量</strong>，这个变量的取值等于数组或者对象在堆内存中的首地址，在栈中的这个特殊的变量就变成了数组或者对象的引用变量，以后就可以在程序中使用栈内存中的引用变量来访问堆中的数组或者对象，引用变量相当于为数组或者对象起的一个别名，或者代号。</p><p><strong>引用变量是普通变量，定义时在栈中分配内存</strong>，引用变量在程序运行到作用域外释放。而数组＆对象本身在堆中分配，即使程序运行到使用new产生数组和对象的语句所在地代码块之外，数组和对象本身占用的堆内存也不会被释放，数组和对象在没有引用变量指向它的时候，才变成垃圾，不能再被使用，但是仍然占着内存，在随后的一个不确定的时间被垃圾回收器释放掉。这个也是java比较占内存的主要原因，实际上，栈中的变量指向堆内存中的变量，这就是 Java 中的指针。</p><p>我们来看下一个例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LearnHeap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">10</span>;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.age =<span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        change(a,person);</span><br><span class="line">        System.out.println(<span class="string">&quot;a=&quot;</span>+ a+<span class="string">&quot;,and person.age = &quot;</span>+person.age);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> a, Person person)</span></span>&#123;</span><br><span class="line">        a = <span class="number">11</span>;</span><br><span class="line">        person.age= <span class="number">21</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;a=&quot;</span>+ a+<span class="string">&quot;,and person.age = &quot;</span>+person.age);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的输出结果是什么呢？如下：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-869.png"></p><p>我们如何理解上述输出？</p><p>我们画图来看下：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-870.png"></p><p>我们对上图加以分析：</p><ol><li>开始时，<code>main</code>方法是入口，<code>JVM</code>执行，首先将<code>main</code>方法压入栈，在栈内存中开辟空间，用来存放<code>int</code>类型变量<code>a</code>，同时在堆内存中开辟空间，用来创建并存放对象<code>Person</code>，这块内存会有自己的内存地址，我们假设是001，然后赋值成员变量<code>age=20</code>，完成后，将<code>Person</code>对象的内存地址传给<code>main</code>方法中的<code>person</code>；</li><li>而后执行<code>change</code>函数，在栈内存中又会开辟一个新的空间，用于存放<code>int</code>类型变量<code>a</code>还有<code>person</code>，这儿就是我们常说的地址传递和值传递，这一步在<code>change</code>方法区，<code>a</code>变量开始会被赋值为<code>main</code>方法传进来的10，<code>person</code>变量被赋值为堆内存中的地址（此时它<code>age=20</code>）；</li><li><code>change</code>方法执行，<code>a</code>变量被赋值为11，但是它是无法影响到<code>main</code>方法中的<code>a</code>变量的，因为不在同一片栈内存，<code>person.age</code>被赋值为21，此时会更改堆内存中<code>Person</code>对象的<code>age</code>为21；</li><li><code>change</code>方法结束后，其栈空间释放，<code>main</code>方法空间仍然存在，此时输出<code>a=10,age=21</code>。</li></ol><p>也就是我们经常说到的：</p><blockquote><p>基本数据类型是值传递，引用数据类型是地址传递</p></blockquote><p>我们上面说到的基本数据类型有8种，我们测试一下即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LearnHeap1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">short</span> s=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> l = <span class="number">1L</span>;</span><br><span class="line">        <span class="keyword">char</span> c = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        <span class="keyword">float</span> f = <span class="number">1.0f</span>;</span><br><span class="line">        <span class="keyword">double</span> d = <span class="number">1.0d</span>;</span><br><span class="line">        <span class="keyword">boolean</span> bo = <span class="keyword">true</span>;</span><br><span class="line">        change(b,i,s,l,c,f,d,bo);</span><br><span class="line">        System.out.println(b+<span class="string">&quot;,&quot;</span>+i+<span class="string">&quot;,&quot;</span>+s+<span class="string">&quot;,&quot;</span>+l+<span class="string">&quot;,&quot;</span>+c+<span class="string">&quot;,&quot;</span>+f+<span class="string">&quot;,&quot;</span>+d+<span class="string">&quot;,&quot;</span>+bo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">byte</span> b,<span class="keyword">int</span> i,<span class="keyword">short</span> s,<span class="keyword">long</span> l,<span class="keyword">char</span> c,<span class="keyword">float</span> f,<span class="keyword">double</span> d,<span class="keyword">boolean</span> bo)</span></span>&#123;</span><br><span class="line">        b = <span class="number">2</span>;</span><br><span class="line">        i=<span class="number">2</span>;</span><br><span class="line">        s=<span class="number">2</span>;</span><br><span class="line">        l = <span class="number">2L</span>;</span><br><span class="line">        c = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">        f = <span class="number">2.0f</span>;</span><br><span class="line">        d = <span class="number">2.0d</span>;</span><br><span class="line">        bo = <span class="keyword">false</span>;</span><br><span class="line">        System.out.println(b+<span class="string">&quot;,&quot;</span>+i+<span class="string">&quot;,&quot;</span>+s+<span class="string">&quot;,&quot;</span>+l+<span class="string">&quot;,&quot;</span>+c+<span class="string">&quot;,&quot;</span>+f+<span class="string">&quot;,&quot;</span>+d+<span class="string">&quot;,&quot;</span>+bo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到输出如下：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-871.png"></p><p>说明基本数据类型都是值传递。</p><p>那它们的包装类呢？</p><p>我们对<code>Integer</code>做下测试即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LearnHeap2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer i = <span class="number">1</span>;</span><br><span class="line">        Integer i1 = <span class="keyword">new</span> Integer(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        Integer i2 = <span class="keyword">new</span> Integer(<span class="string">&quot;300&quot;</span>);</span><br><span class="line">        change(i,i1,i2);</span><br><span class="line">        System.out.println(i+<span class="string">&quot;,&quot;</span>+i1+<span class="string">&quot;,&quot;</span>+i2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(Integer i,Integer i1,Integer i2)</span></span>&#123;</span><br><span class="line">        i = <span class="number">2</span>;</span><br><span class="line">        i1 = <span class="keyword">new</span> Integer(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        i2 = <span class="keyword">new</span> Integer(<span class="string">&quot;301&quot;</span>);</span><br><span class="line">        System.out.println(i+<span class="string">&quot;,&quot;</span>+i1+<span class="string">&quot;,&quot;</span>+i2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-872.png"></p><p>可以看到包装类型是值传递的<strong>表现</strong>。</p><p>另外数组，集合，<code>Map</code>的传递也为引用传递，我们来看下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LearnHeap3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        map.put(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">        map.put(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">        change(array,list,map);</span><br><span class="line">        sout(array,list,map);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span>[] array,List&lt;Integer&gt; list,Map&lt;Integer,Integer&gt; map)</span></span>&#123;</span><br><span class="line">        array[<span class="number">0</span>]=<span class="number">4</span>;</span><br><span class="line">        array[<span class="number">1</span>]=<span class="number">5</span>;</span><br><span class="line">        array[<span class="number">2</span>]=<span class="number">6</span>;</span><br><span class="line">        list.set(<span class="number">0</span>,<span class="number">4</span>);</span><br><span class="line">        list.set(<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line">        list.set(<span class="number">2</span>,<span class="number">6</span>);</span><br><span class="line">        map.put(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">        map.put(<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line">        map.put(<span class="number">3</span>,<span class="number">6</span>);</span><br><span class="line">        sout(array,list,map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sout</span><span class="params">(<span class="keyword">int</span>[] array,List&lt;Integer&gt; list,Map&lt;Integer,Integer&gt; map)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : array) &#123;</span><br><span class="line">            System.out.print(i+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">            System.out.print(integer+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        map.forEach((k,v)-&gt;&#123;</span><br><span class="line">            System.out.print(k+<span class="string">&quot;:&quot;</span>+v+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-873.png"></p><p>我们再来看下<code>String</code>，看看它遵循怎样的规则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LearnHeap4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String a = <span class="string">&quot;A&quot;</span>;</span><br><span class="line">        String a1 = <span class="keyword">new</span> String(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        System.out.println(a==a1);</span><br><span class="line">        change(a,a1);</span><br><span class="line">        System.out.println(a+<span class="string">&quot;,&quot;</span>+a1);</span><br><span class="line">        System.out.println(a==a1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String a,String a1)</span></span>&#123;</span><br><span class="line">        a = <span class="string">&quot;B&quot;</span>;</span><br><span class="line">        a1 = <span class="keyword">new</span> String(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        System.out.println(a+<span class="string">&quot;,&quot;</span>+a1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-874.png"></p><p>可以看到<code>String</code>也是值传递的<strong>表现</strong>，但是两种创建<code>String</code>的地址比较后，是不相同的。</p><ul><li><code>String a =&quot;A&quot;</code>：此种创建方式，先在栈中创建一个对<code>String</code>类的对象引用变量<code>a</code>，然后查找栈中有没有存放”A”，如果没有，则将”A”存放进栈，并令其指向<code>a</code>，如果已经有 ”A” ，则直接令<code>a</code>指向”A”；</li><li><code>String a1 = new String(&quot;A&quot;) </code>：此种创建方式，是在堆内存中新建一个”A”对象，同时栈中存放其地址引用<code>a1</code>，每调用一次，就会新建一个对象。</li></ul><p>注意：</p><blockquote><p>这儿需要有些注意的地方，可以看到上面我说到包装类型和String测试结果表现为值传递，我们的结论是<strong>值传递的表现</strong>。</p><p>其实对于包装类或者String，new这种创建方式，会在堆内存上开辟空间存放对象，在堆内存上开辟空间，底层肯定就是将<strong>堆内存的地址传递过去</strong>。</p><p>但由于包装类或者String其类型为final，赋值后就不可更改，我们更改相当于再创建一个对象，将当前变量指向那个地址。</p><p>所以我们看到了值传递的表现。</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是我们本文的全部内容。</p><p>我们用下表来总结下：</p><table><thead><tr><th>类型</th><th>参数传递类型</th></tr></thead><tbody><tr><td>基本数据类型（byte、short、long、int、boolean、float、double、char）</td><td>值传递</td></tr><tr><td>常规对象</td><td>引用传递</td></tr><tr><td>Array、List、Map</td><td>引用传递</td></tr><tr><td>包装类和String</td><td>值传递表现（底层引用传递）</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;因为面试中经常被问到关于Java中堆和栈的数据存放问题，今天我们就来简单了解下堆和栈。&lt;/p&gt;
&lt;p&gt;这篇文章仅仅是Java堆和栈的一个入门，我们结合实际例子来了解下堆和栈的关系及区别。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h1&gt;</summary>
    
    
    
    <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="堆" scheme="https://www.sakuratears.top/tags/%E5%A0%86/"/>
    
    <category term="栈" scheme="https://www.sakuratears.top/tags/%E6%A0%88/"/>
    
    <category term="引用传递" scheme="https://www.sakuratears.top/tags/%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"/>
    
  </entry>
  
  <entry>
    <title>Mybaits缓存机制</title>
    <link href="https://www.sakuratears.top/blog/Mybaits%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6.html"/>
    <id>https://www.sakuratears.top/blog/Mybaits%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6.html</id>
    <published>2021-08-02T14:38:00.000Z</published>
    <updated>2021-08-02T14:48:35.874Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们知道<code>Mybatis</code>作为常见的<code>Java</code>数据库访问层的<code>ORM</code>框架，其缓存分为一级缓存和二级缓存。</p><p>大多数情况下，我们使用的都是<code>Mybatis</code>缓存的默认配置，但是<code>Mybatis</code>缓存机制有一些不足之处，在使用中容易引起脏数据问题，形成一些潜在隐患。</p><p>今天，我们就来看下<code>Mybatis</code>的缓存机制，了解其底层的一些原理，来方便我们排查、解决以后可能出现的由<code>Mybatis</code>缓存引起的问题。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="缓存实现"><a href="#缓存实现" class="headerlink" title="缓存实现"></a>缓存实现</h2><p>我们通过<code>Mybatis</code>提供的<code>jar</code>包来看下缓存的整体结构，如下：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-834.png"></p><p>可以看到其缓存相关类位于<code>cache</code>包下，其中有一个<code>Cache</code>接口，有一个默认的实现类 <code>PerpetualCache</code>，它是用<code>HashMap</code>实现的。</p><p>其他的实现类使用了装饰器模式，这些装饰器可以额外实现很多的功能，如回收策略、日志记录、定时刷新等等。使用装饰器模式的好处就是这些类可以互相组装，提供丰富的缓存操控能力。</p><p>这些缓存实现类可以总结如下表：</p><table><thead><tr><th>缓存实现类</th><th>描述</th><th>作用</th><th>装饰条件</th></tr></thead><tbody><tr><td>PerpetualCache</td><td>基本缓存</td><td>默认就是<code>PerpetualCache</code>，当然我们也可以自定义具备基本功能的缓存实现类，如<code>RedisCache</code>、<code>ESCache</code>等，来借助三方工具实现缓存</td><td>无</td></tr><tr><td>LruCache</td><td>LRU策略的缓存</td><td>当缓存达到上限的时候，删除最近最少使用的对象（Least Recently Used）。默认上限<code>1024</code>，其底层是使用的<code>LinkedHashMap</code>实现的</td><td><code>eviction=&quot;LRU&quot;</code>（默认配置）</td></tr><tr><td>FifoCache</td><td>FIFO策略的缓存</td><td>当缓存对象达到上限时，首先删除最先入队的对象。默认上限1024，底层使用<code>LinkedList</code>实现。</td><td><code>eviction=&quot;FIFO&quot;</code></td></tr><tr><td>SoftCache</td><td>软引用清理策略的缓存</td><td>通过软引用来实现缓存，当<code>JVM</code>内存不足时，会自动清理掉这些缓存，基于<code>SoftReference</code></td><td><code>eviction=&quot;SOFT&quot;</code></td></tr><tr><td>WeakCache</td><td>弱引用清理策略的缓存</td><td>通过弱引用来实现缓存，当<code>JVM</code>内存不足时，会自动清理掉这些缓存，基于<code>WeakReference</code></td><td><code>eviction=&quot;WEAK&quot;</code></td></tr><tr><td>LoggingCache</td><td>带日志功能的缓存</td><td>记录部分缓存处理情况，如：输出缓存的命中率</td><td>基本</td></tr><tr><td>SynchronizedCache</td><td>同步缓存</td><td>基于<code>synchronized</code>关键字实现，解决并发问题</td><td>基本</td></tr><tr><td>BlockingCache</td><td>阻塞缓存</td><td>通过对 <code>get/set</code>方法里加锁，保证只有一个线程操作缓存，基于<code>ReentrantLock</code>实现</td><td><code>blocking=true</code></td></tr><tr><td>SerializedCache</td><td>支持序列化的缓存</td><td>将对象序列化后存入缓存，取出时反序列化</td><td><code>readOnly=false</code>（默认配置）</td></tr><tr><td>ScheduledCache</td><td>定时调度的缓存</td><td>在进行<code>get/set/remove/getSize</code>等操作前，判断缓存时间是否超过了设置的最长缓存时间，默认一小时，如果是则清空缓存。</td><td><code>flushinterval</code>不为空</td></tr><tr><td>TransactionalCache</td><td>事务缓存</td><td>在二级缓存中使用，可以一次存入多个缓存，移除多个缓存</td><td><code>TransactionalCacheManager</code>中用<code>Map</code>维护对应关系</td></tr></tbody></table><p>对缓存实现结构有了大致了解后，我们分别来看下一级缓存和二级缓存。</p><h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>在应用程序中，我们有可能在一次数据库会话中，执行多次查询条件完全相同的<code>SQL</code>，<code>Mybatis</code>提供了一级缓存的方案优化此场景，如果是相同的<code>SQL</code>语句，会优先命中一级缓存，避免直接对数据库进行查询，提高性能。其过程具体如下：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-835.png"></p><p>每个<code>SqlSession</code>中持有<code>Executor</code>，每个<code>Executor</code>中有一个<code>Local Cache</code>。当用户发起查询时，<code>Mybaits</code>根据当前执行的语句生成<code>MappedStatement</code>，在<code>Local Cache</code>中进行查询，如果缓存命中的话，直接返回结果给用户，如果缓存未命中，查询数据库，并将结果写入<code>Local Cache</code>，最后返回结果给用户。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>如何使用<code>Mybatis</code>的一级缓存呢？</p><p>我们只需在<code>Mybatis</code>配置文件<code>mybatis-config.xml</code>中，添加如下语句，就可以使用一级缓存了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;localCacheScope&quot;</span> <span class="attr">value</span>=<span class="string">&quot;SESSION&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>对于集成<code>Mybaits</code>的<code>springboot</code>项目，也可以直接在<code>properties</code>或者<code>yml</code> 文件里直接进行配置，如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mybatis.configuration.local-cache-scope</span>=<span class="string">session</span></span><br></pre></td></tr></table></figure><p><code>value</code>共有两个选项，<code>SESSION</code>和<code>STATEMENT</code>，默认是<code>SESSION</code>级别，即在一个<code>Mybatis</code>会话中执行的所有语句，都会共享这个缓存。另一种是<code>STATEMENT</code>级别，可以理解为缓存只对当前执行的这一个<code>Statement</code>有效。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>我们接下来通过实验来了解<code>Mybaits</code>一级缓存的效果。</p><p>我们首先创建表<code>student</code>，并向表中添加一些数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `student` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">  `stu_no` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;学号&#x27;</span>,</span><br><span class="line">  `stu_sex` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;学生性别&#x27;</span>,</span><br><span class="line">  `stu_birthday` <span class="type">date</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;学生生日&#x27;</span>,</span><br><span class="line">  `stu_class` <span class="type">char</span>(<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;学生班级&#x27;</span>,</span><br><span class="line">  `stu_name` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;学生姓名&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">0</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` (`id`, `stu_no`, `stu_sex`, `stu_birthday`, `stu_class`, `stu_name`) <span class="keyword">VALUES</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2004-03-03&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;张三&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` (`id`, `stu_no`, `stu_sex`, `stu_birthday`, `stu_class`, `stu_name`) <span class="keyword">VALUES</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;2005-06-02&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;李四&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` (`id`, `stu_no`, `stu_sex`, `stu_birthday`, `stu_class`, `stu_name`) <span class="keyword">VALUES</span> (<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2003-01-07&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;王五&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>同时提供<code>Mapper</code>及<code>pojo</code>类，过程略。</p><h4 id="测试一"><a href="#测试一" class="headerlink" title="测试一"></a>测试一</h4><p>我们通过单元测试，测试如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cacheTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line">        StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);</span><br><span class="line">        System.out.println(studentMapper.selectByPrimaryKey(<span class="number">1</span>));</span><br><span class="line">        System.out.println(studentMapper.selectByPrimaryKey(<span class="number">1</span>));</span><br><span class="line">        System.out.println(studentMapper.selectByPrimaryKey(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记得开启日志的 <code>DEBUG</code>级别。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-836.png"></p><p>可以看到三次查询，实际只有第一次真正查询了数据库，后续的查询使用的是一级缓存。</p><h4 id="测试二"><a href="#测试二" class="headerlink" title="测试二"></a>测试二</h4><p>上述代码中，我们增加对数据库的修改操作，验证在一次数据库会话中，如果对数据库发生了修改操作，一级缓存是否失效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cacheTest1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqlSession sqlSession = sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line">    StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);</span><br><span class="line">    studentMapper.selectByPrimaryKey(<span class="number">1</span>);</span><br><span class="line">    StudentModel studentModel = <span class="keyword">new</span> StudentModel();</span><br><span class="line">    studentModel.setStuName(<span class="string">&quot;赵六&quot;</span>);</span><br><span class="line">    studentModel.setStuNo(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">    studentModel.setStuClass(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    studentModel.setStuSex(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    studentMapper.insert(studentModel);</span><br><span class="line">    studentMapper.selectByPrimaryKey(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下日志：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-837.png"></p><p>可以看到，在修改操作后执行相同的查询，<strong>一级缓存失效</strong>，会再次查询数据库。</p><h4 id="测试三"><a href="#测试三" class="headerlink" title="测试三"></a>测试三</h4><p>开启两个<code>SqlSession</code>，在<code>sqlSession1</code>中查询数据，使一级缓存生效，在<code>sqlSession2</code>中更新数据库，验证一级缓存只在数据库会话内部共享。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cacheTest3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqlSession sqlSession1 = sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line">    SqlSession sqlSession2 = sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    StudentMapper studentMapper1 = sqlSession1.getMapper(StudentMapper.class);</span><br><span class="line">    StudentMapper studentMapper2 = sqlSession2.getMapper(StudentMapper.class);</span><br><span class="line">    System.out.println(<span class="string">&quot;studentMapper1-&gt;&quot;</span>+studentMapper1.selectByPrimaryKey(<span class="number">1</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;studentMapper1-&gt;&quot;</span>+studentMapper1.selectByPrimaryKey(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    studentMapper2.updateStudentName(<span class="string">&quot;张二&quot;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;studentMapper1-&gt;&quot;</span>+studentMapper1.selectByPrimaryKey(<span class="number">1</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;studentMapper2-&gt;&quot;</span>+studentMapper2.selectByPrimaryKey(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日志如下：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-838.png"></p><p>可以看到，<code>sqlSession2</code>更新了<code>id</code>为1的学生的姓名，从<code>张三</code>变为<code>张二</code>，但在<code>session1</code>之后的查询中，<code>id</code>为1的学生名字还是<code>张三</code>，出现了脏数据，也说明了一级缓存只在数据库会话内部共享。</p><h3 id="工作流程及源码"><a href="#工作流程及源码" class="headerlink" title="工作流程及源码"></a>工作流程及源码</h3><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>一级缓存执行的时序图可以用下图来表示：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-839.png"></p><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>下面我们来看下<code>Mybaits</code>查询相关的核心类和一级缓存源码，这对我们后面的二级缓存学习也有帮助。</p><p><strong>SqlSession</strong>：对外提供了用户和数据库之间交互需要的方法，隐藏了底层细节。默认实现类是<code>DefaultSqlSession</code>。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-840.png"></p><p><strong>Executor</strong>：<code>SqlSession</code>向用户提供操作数据库的方法，但和数据库操作有关的职责都会委托给<code>Executor</code>。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-841.png"></p><p>如下图所示，<code>Executor</code>有若干个实现类，为<code>Executor</code>赋予了不同的能力。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-842.png"></p><p>在一级缓存源码中，我们主要来看下<code>BaseExecutor</code>的内部实现。</p><p><strong>BaseExecutor</strong>：是一个实现了<code>Executor</code>接口的抽象类，定义了若干抽象方法，在执行的时候，把具体的操作委托给子类进行执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">doUpdate</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> List&lt;BatchResult&gt; <span class="title">doFlushStatements</span><span class="params">(<span class="keyword">boolean</span> isRollback)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;E&gt; <span class="function">Cursor&lt;E&gt; <span class="title">doQueryCursor</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException</span>;</span><br></pre></td></tr></table></figure><p>在 <code>BaseExecutor</code>中，我们可以看到 <code>Local Cache</code>是其内部的一个成员变量，如下：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-843.png"></p><p>也就到了我们最开始所说的部分，<code>Cache</code>接口及其实现类。</p><p>总体流程如下：</p><p>为了执行和数据库交互，首先需要初始化<code>SqlSession</code>，通过<code>DefaultSqlSessionFactory</code>开启<code>SqlSession</code>：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-844.png"></p><p>可以看到会用<code>Configuration</code>类创建一个全新的<code>Executor</code>，作为<code>DefaultSqlSession</code> 的参数。</p><p>创建<code>Executor</code>的代码如下：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-845.png"></p><p><code>SqlSession</code>创建完毕后，根据<code>Statement</code>的不同类型，会进入<code>SqlSession</code>的不同方法中，如果是<code>select</code>语句，最后会执行到<code>SqlSession</code>的<code>selectList</code>方法：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-846.png"></p><p><code>SqlSession</code>把具体的查询职责委托给了<code>Executor</code>。如果只开启了一级缓存的话，会进入<code>BaseExecutor</code>的<code>query</code>方法。如下：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-847.png"></p><p>上述代码中，会先根据传入的参数生成<code>CacheKey</code>，我们来看下：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-848.png"></p><p>上述代码中，将<code>MappedStatement</code>的<code>id</code>、<code>SQL</code>的<code>offset</code>及<code>limit</code>、<code>SQL</code>本身以及<code>SQL</code>中的参数传入了<code>CacheKey</code>这个类。</p><p>其<code>update</code>方法如下：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-849.png"></p><p>它重写了<code>equals</code>方法，如下：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-850.png"></p><p>我们可以看到除去<code>hashcode</code>、<code>checksum</code>、<code>count</code>的比较外，只要<code>updatelist</code>中的元素一一对应相等，那么就认为<code>CacheKey</code>相等。</p><p>也就是只要两条<code>SQL</code>的下面五个值相同，即可以认为是相同<code>SQL</code>。</p><blockquote><p>Statement Id + Offset + Limit + Sql + Params</p></blockquote><p><code>BaseExecutor</code>的<code>query</code>继续往下走，如下：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-851.png"></p><p>可以看到如果一级缓存里没有，就会去数据库查询。</p><p>在<code>queryFromDatabase</code>中，会对<code>localCache</code>进行写入。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-852.png"></p><p>在上面<code>query</code>方法的最后，可以看到会判断一级缓存的级别，如果是<code>STATEMENT</code>级别，就会清空缓存，也就是<code>STATEMENT</code>级别无法共享一级缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">        <span class="comment">// issue #482</span></span><br><span class="line">        clearLocalCache();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>最后，我们再来看下<code>insert/update/delete</code>操作，缓存会刷新的原因。</p><p><code>SqlSession</code>找到<code>insert/delete</code>方法，都会走<code>update</code>流程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insert</span><span class="params">(String statement, Object parameter)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> update(statement, parameter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(String statement, Object parameter)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> update(statement, parameter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看下<code>update</code>方法，它也是委托给了<code>Executor</code>执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(String statement, Object parameter)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    dirty = <span class="keyword">true</span>;</span><br><span class="line">    MappedStatement ms = configuration.getMappedStatement(statement);</span><br><span class="line">    <span class="keyword">return</span> executor.update(ms, wrapCollection(parameter));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error updating database.  Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到<code>BaseExecutor</code>实现，我们可以看到它每次执行都会清空<code>Local Cache</code>。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-853.png"></p><p>上面就是<code>Mybaits</code>的一级缓存的工作流程原理。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们来总结下一级缓存的部分内容。</p><ul><li><code>Mybatis</code>一级缓存的生命周期和<code>SqlSession</code>一致。</li><li><code>Mybatis</code>一级缓存结构简单，只是个没有容量限定的<code>HashMap</code>，在缓存功能上有所缺陷。</li><li><code>Mybatis</code>的一级缓存最大范围是<code>SqlSession</code>内部，有多个<code>SqlSession</code>或者分布式环境下，数据库写操作可能会引起脏数据问题，建议设定缓存级别为<code>STATEMENT</code>。</li></ul><h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>上面我们说的一级缓存，其最大共享范围就是一个<code>SqlSession</code>的内部，如果多个<code>SqlSession</code>需要共享缓存，则需要使用二级缓存。</p><p>开启二级缓存后，会使用<code>CachingExecutor</code> 装饰<code>Executor</code>，我们可以在<code>newExecutor</code>方法逻辑里发现这段代码：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-854.png"></p><p>进入一级缓存的查询流程前，先在<code>CachingExecutor</code> 进行二级缓存的查询，具体工作流程如下。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-855.png"></p><p>二级缓存开启后，同一个<code>namespace</code>下所有操作语句，都影响着同一个<code>Cache</code>，即二级缓存被多个<code>SqlSession</code>共享，是一个全局变量。</p><p>当开启缓存后，数据的查询执行流程为：<strong>二级缓存 -&gt; 一级缓存 -&gt; 数据库</strong>。</p><h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><p>要正确使用二级缓存，需要完成如下配置。</p><ul><li><p><code>Mybatis</code>配置文件中开启二级缓存。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>或者如果使用的是<code>springboot</code>集成，需要如下配置。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mybatis.configuration.cache-enabled</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure></li><li><p>在<code>Mybatis</code>的映射<code>XML</code>中配置<code>cache</code>或者<code>cache-ref</code>。</p><p><code>cache</code>标签用于声明这个<code>namespace</code>使用二级缓存，并且可以自定义配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>type</strong>：<code>cache</code>使用的类型，默认是<code>PerpetualCache</code>。</li><li><strong>eviction</strong>：定义回收的策略，常见的有<code>FIFO</code>、<code>LRU</code>。</li><li><strong>flushInterval</strong>：配置一定时间自动刷新缓存，单位是毫秒。</li><li><strong>size</strong>：最多缓存的对象个数。</li><li><strong>readOnly</strong>：是否只读，若配置可读写，则需要对应的实体类能够序列化。</li><li><strong>blocking</strong>：若缓存中找不到对应的<code>key</code>，是否会一直<code>blocking</code>，直到有对应的数据进入缓存。</li></ul><p><code>cache-ref</code>代表引用别的命名空间的<code>Cache</code>配置，两个命名空间的操作使用的是同一个<code>Cache</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache-ref</span> <span class="attr">namespace</span>=<span class="string">&quot;com.zwt.demo.mapper.StudentMapper&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p>我们来看几个二级缓存的测试，来了解下二级缓存的一些特点。</p><h4 id="测试一-1"><a href="#测试一-1" class="headerlink" title="测试一"></a>测试一</h4><p>测试二级缓存效果，不提交事务，<code>sqlSession1</code>查询完数据后，<code>sqlSession2</code>相同的查询是否会从缓存中获取数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cacheTest4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqlSession sqlSession1 = sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line">    SqlSession sqlSession2 = sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    StudentMapper studentMapper1 = sqlSession1.getMapper(StudentMapper.class);</span><br><span class="line">    StudentMapper studentMapper2 = sqlSession2.getMapper(StudentMapper.class);</span><br><span class="line">    System.out.println(<span class="string">&quot;studentMapper1-&gt;&quot;</span>+studentMapper1.selectByPrimaryKey(<span class="number">1</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;studentMapper2-&gt;&quot;</span>+studentMapper2.selectByPrimaryKey(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-856.png"></p><p>可以看到，当<code>sqlSession</code>没有调用<code>commit()</code>方法时，二级缓存并没有起到作用。</p><h4 id="测试二-1"><a href="#测试二-1" class="headerlink" title="测试二"></a>测试二</h4><p>这回我们测试当提交事务后，二级缓存是否可以起到作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cacheTest5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqlSession sqlSession1 = sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line">    SqlSession sqlSession2 = sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    StudentMapper studentMapper1 = sqlSession1.getMapper(StudentMapper.class);</span><br><span class="line">    StudentMapper studentMapper2 = sqlSession2.getMapper(StudentMapper.class);</span><br><span class="line">    System.out.println(<span class="string">&quot;studentMapper1-&gt;&quot;</span>+studentMapper1.selectByPrimaryKey(<span class="number">1</span>));</span><br><span class="line">    sqlSession1.commit();</span><br><span class="line">    System.out.println(<span class="string">&quot;studentMapper2-&gt;&quot;</span>+studentMapper2.selectByPrimaryKey(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-857.png"></p><p>可以看到只进行了一次查询，<code>sqlSession2</code>的查询使用了缓存，缓存命中率为0.5。</p><p>PS：为什么是0.5？ 因为进行了两次查询，第一次未命中，查询数据库，第二次命中缓存，故命中率是 1/2 = 0.5。</p><h4 id="测试三-1"><a href="#测试三-1" class="headerlink" title="测试三"></a>测试三</h4><p>测试<code>update</code>操作是否会刷新该<code>namespace</code>下的二级缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cacheTest6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqlSession sqlSession1 = sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line">    SqlSession sqlSession2 = sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line">    SqlSession sqlSession3 = sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    StudentMapper studentMapper1 = sqlSession1.getMapper(StudentMapper.class);</span><br><span class="line">    StudentMapper studentMapper2 = sqlSession2.getMapper(StudentMapper.class);</span><br><span class="line">    StudentMapper studentMapper3 = sqlSession3.getMapper(StudentMapper.class);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;studentMapper1-&gt;&quot;</span>+studentMapper1.selectByPrimaryKey(<span class="number">1</span>));</span><br><span class="line">    sqlSession1.commit();</span><br><span class="line">    System.out.println(<span class="string">&quot;studentMapper2-&gt;&quot;</span>+studentMapper2.selectByPrimaryKey(<span class="number">1</span>));</span><br><span class="line">    studentMapper3.updateStudentName(<span class="string">&quot;张二二&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    sqlSession3.commit();</span><br><span class="line">    System.out.println(<span class="string">&quot;studentMapper2-&gt;&quot;</span>+studentMapper2.selectByPrimaryKey(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-858.png"></p><p>可以看到，<code>sqlSession3</code>更新数据库，提交事务后，<code>sqlSession2</code>后面的查询走了数据库，没有走<code>Cache</code>。</p><h4 id="测试四"><a href="#测试四" class="headerlink" title="测试四"></a>测试四</h4><p>验证<code>Mybatis</code>二级缓存不适用用映射文件中存在多表查询的情况。</p><p>通常我们会为每个单表创建单独的映射文件，由于<code>Mybatis</code>的二级缓存是基于<code>namespace</code>的，多表查询语句所在的<code>namespace</code>无法感应到其他<code>namespace</code>中的语句对多表查询中涉及的表进行的修改，引发脏数据问题。</p><p>这儿我们在引入一张表，<code>score</code>学生分数表，并创建几条数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `score` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">  `stu_no` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;学号&#x27;</span>,</span><br><span class="line">  `cou_no` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;课程号&#x27;</span>,</span><br><span class="line">  `score` <span class="type">decimal</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;分数&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uq_stu_cou` (`stu_no`,`cou_no`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">5</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `score` (`id`, `stu_no`, `cou_no`, `score`) <span class="keyword">VALUES</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;80&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `score` (`id`, `stu_no`, `cou_no`, `score`) <span class="keyword">VALUES</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;90&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `score` (`id`, `stu_no`, `cou_no`, `score`) <span class="keyword">VALUES</span> (<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;70&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `score` (`id`, `stu_no`, `cou_no`, `score`) <span class="keyword">VALUES</span> (<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;60&#x27;</span>);</span><br></pre></td></tr></table></figure><p>涉及到的 <code>ScoreMapper</code>不再附上。</p><p>我们假设在<code>StudentMapper</code>里有个根据学生<code>id</code>和课程号查询学生分数的方法，<code>ScoreMapper</code>里有个更新学生分数的方法。</p><p><code>StudentMapper</code>中获取学生分数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">selectStudentScore</span><span class="params">(<span class="meta">@Param(&quot;stuNo&quot;)</span> String stuNo,<span class="meta">@Param(&quot;couNo&quot;)</span> String couNo)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectStudentScore&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;java.lang.Integer&quot;</span>&gt;</span></span><br><span class="line">  select c.score from student s left join score c on s.stu_no = c.stu_no where s.stu_no = #&#123;stuNo&#125; and c.cou_no = #&#123;couNo&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>ScoreMapper</code>更新分数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">updateScore</span><span class="params">(<span class="meta">@Param(&quot;stuNo&quot;)</span> String stuNo,<span class="meta">@Param(&quot;couNo&quot;)</span> String couNo,<span class="meta">@Param(&quot;score&quot;)</span>Integer score)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateScore&quot;</span>&gt;</span></span><br><span class="line">   update score set score = #&#123;score&#125; where stu_no = #&#123;stuNo&#125; and cou_no = #&#123;couNo&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cacheTest7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqlSession sqlSession1 = sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line">    SqlSession sqlSession2 = sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line">    SqlSession sqlSession3 = sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    StudentMapper studentMapper1 = sqlSession1.getMapper(StudentMapper.class);</span><br><span class="line">    StudentMapper studentMapper2 = sqlSession2.getMapper(StudentMapper.class);</span><br><span class="line">    ScoreMapper scoreMapper = sqlSession3.getMapper(ScoreMapper.class);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;studentMapper1-&gt;&quot;</span>+studentMapper1.selectStudentScore(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;A&quot;</span>));</span><br><span class="line">    sqlSession1.close();</span><br><span class="line">    System.out.println(<span class="string">&quot;studentMapper2-&gt;&quot;</span>+studentMapper2.selectStudentScore(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;A&quot;</span>));</span><br><span class="line">    scoreMapper.updateScore(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="number">99</span>);</span><br><span class="line">    sqlSession3.commit();</span><br><span class="line">    System.out.println(<span class="string">&quot;studentMapper2-&gt;&quot;</span>+studentMapper2.selectStudentScore(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;A&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-859.png"></p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-860.png"></p><p>可以看到，<code>sqlSession1</code> 的 <code>studentMapper1</code> 查询数据库后，二级缓存生效。其保存在<code>StudentMapper</code> 的<code>namespace</code>的<code>cache</code>中。当<code>sqlSession3</code>的<code>scoreMapper</code>更新数据时，其方法不属于<code>StudentMapper</code> 的<code>namespace</code>，无法感应到缓存变化，因此读取了脏数据。</p><h4 id="测试五"><a href="#测试五" class="headerlink" title="测试五"></a>测试五</h4><p>为了解决测试四出现的问题，我们可以使用<code>cache-ref</code>，让<code>ScoreMapper</code>引用<code>StudentMapper</code>的命名空间，这样两个映射文件对应的<code>SQL</code>操作就会使用同一块缓存。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.zwt.demo.mapper.ScoreMapper&quot;</span> &gt;</span></span><br><span class="line">......</span><br><span class="line">    <span class="tag">&lt;<span class="name">cache-ref</span> <span class="attr">namespace</span>=<span class="string">&quot;com.zwt.demo.mapper.StudentMapper&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">cache-ref</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>继续执行测试四代码：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-861.png"></p><p>可以看到，更新后，会重新进行查询，得到99的结果。</p><p>PS：不过这样做的后果是，缓存的粒度变粗了，多个<code>Mapper namespace</code>下的所有操作都会对缓存的使用造成影响。</p><h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><p><code>Mybatis</code>二级缓存的工作流程和上面提到的一级缓存类似，只是在一级缓存处理前，用<code>CachingExecutor</code>装饰了<code>BaseExecutor</code>的子类，在委托具体职责给<code>delegate</code>之前，实现了二级缓存的查询和写入功能。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-862.png"></p><p>我们从<code>CachingExecutor</code>的<code>query</code>方法看起，来了解下二级缓存的一些内容。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-863.png"></p><p><code>CachingExecutor</code>的<code>query</code>方法，首先会从<code>MappedStatement</code>中获得在配置初始化时赋予的<code>Cache</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache cache = ms.getCache();</span><br></pre></td></tr></table></figure><p>其也是装饰器模式的使用，装饰链如下：</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SynchronizedCache -&gt; LoggingCache -&gt; SerializedCache -&gt; LruCache -&gt; PerpetualCache</span><br></pre></td></tr></table></figure></blockquote><p>这些缓存的具体能力我们上面都有讲到。</p><p>然后判断是否需要刷新缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flushCacheIfRequired(ms);</span><br></pre></td></tr></table></figure><p>默认设置中<code>SELECT</code>语句不会刷新，<code>INSERT/UPDATE/DELETE</code>语句会刷新缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushCacheIfRequired</span><span class="params">(MappedStatement ms)</span> </span>&#123;</span><br><span class="line">    Cache cache = ms.getCache();</span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;      </span><br><span class="line">      tcm.clear(cache);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>上述代码中我们可以看到<code>tcm</code>，它是<code>TransactionalCacheManager</code>。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-864.png"></p><p>底层是由<code>TransactionalCache</code> 实现的，作用就是如果事务提交，对缓存的操作才会生效，如果事务回滚或者不提交事务，则不会对缓存产生影响。</p><p>在<code>TransactionalCache</code>中的<code>clear</code>方法，清空了需要在提交时加入缓存的列表，同时设定提交时清空缓存。有以下代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  clearOnCommit = <span class="keyword">true</span>;</span><br><span class="line">  entriesToAddOnCommit.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回到<code>CachingExecutor</code>，我们继续向下看，<code>ensureNoOutParams</code> 方法用来处理存储过程的，暂时不用考虑。</p><p>之后会尝试从<code>tcm</code>中获取缓存列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</span><br></pre></td></tr></table></figure><p><code>getObject</code>方法中，可以看到未命中会把<code>key</code>加入Miss集合，这个主要是为了统计命中率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// issue #116</span></span><br><span class="line">    Object object = delegate.getObject(key);</span><br><span class="line">    <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">        entriesMissedInCache.add(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// issue #146</span></span><br><span class="line">    <span class="keyword">if</span> (clearOnCommit) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回到<code>CachingExecutor</code>，我们继续向下看，如果查询到数据，则调用<code>putObject</code>方法，向缓存中放入值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">    list = delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">    tcm.putObject(cache, key, list); <span class="comment">// issue #578 and #116</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><code>putObject</code>方法最终调用<code>tcm.put</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object object)</span> </span>&#123;</span><br><span class="line">  entriesToAddOnCommit.put(key, object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这儿是将数据放入待提交的<code>Map</code>中，而不是直接操作缓存。</p><p>上面代码我们可以看到，如果不调用<code>commit</code>方法的话，由于<code>TransactionalCache</code> 的作用，不会对二级缓存造成直接影响。因此我们来看看<code>SqlSession</code>的<code>commit</code>方法中做了什么。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-865.png"></p><p>因为我们使用的是<code>CachingExecutor</code>，因此我们来看下其<code>commit</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  delegate.commit(required);</span><br><span class="line">  tcm.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会把具体<code>commit</code>的职责委托给包装的<code>Executor</code>。而后<code>tcm.commit</code>方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TransactionalCache txCache : transactionalCaches.values()) &#123;</span><br><span class="line">        txCache.commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终调用了<code>TransactionalCache</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (clearOnCommit) &#123;</span><br><span class="line">        delegate.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    flushPendingEntries();</span><br><span class="line">    reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到真正的清理<code>Cache</code>实在这里进行的。具体的清理职责委托给了包装的<code>Cache</code>类。</p><p>之后进入到<code>flushPendingEntries()</code>方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushPendingEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; entry : entriesToAddOnCommit.entrySet()) &#123;</span><br><span class="line">        delegate.putObject(entry.getKey(), entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Object entry : entriesMissedInCache) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!entriesToAddOnCommit.containsKey(entry)) &#123;</span><br><span class="line">            delegate.putObject(entry, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在 <code>flushPendingEntries</code>中，会将待提交的<code>Map</code>进行循环处理，委托给包装的<code>Cache</code>类，进行<code>putObject</code>操作。</p><p>后续的查询操作会重复这套流程。</p><p>如果是<code>INSERT/UPDATE/DELETE</code>语句的话，会统一进入<code>CachingExecutor</code>的<code>update</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(MappedStatement ms, Object parameterObject)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    flushCacheIfRequired(ms);</span><br><span class="line">    <span class="keyword">return</span> delegate.update(ms, parameterObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>flushCacheIfRequired</code>我们上面有提到过。</p><p>在二级缓存执行流程后就会进入一级缓存的执行流程，这儿我们就不过多介绍了。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li><code>Mybatis</code>的二级缓存相对于一级缓存来说，实现了<code>SqlSession</code>之间缓存数据的共享，同时粒度更加细致，能够到<code>namespace</code>级别，通过<code>Cache</code>接口实现不同的组合，对<code>Cache</code>的可控性也更强。</li><li>二级缓存开启状态下，<code>Mybatis</code>在多表查询时，很有可能会出现脏数据，有设计上的缺陷，安全使用二级缓存条件比较苛刻。</li><li>在分布式环境下，由于默认的<code>Mybatis Cache</code>实现都是基于本地的，因此也很可能出现脏数据问题，此时可以使用集中式缓存将<code>Mybaits</code>的<code>Cache</code>接口实现，但会有一定的开发成本，直接使用<code>Redis</code>等分布式缓存成本可能更低，安全性也更好。</li></ul><h1 id="自定义缓存实现"><a href="#自定义缓存实现" class="headerlink" title="自定义缓存实现"></a>自定义缓存实现</h1><p>我们在正文的缓存实现里说到，我们可以借助一些缓存工具来实现<code>Mybatis</code>的自定义缓存，这儿我们使用<code>Redis</code>来举例。</p><p>首先需要引入<code>Redis</code>，我的项目配置如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/test1?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">123456</span></span><br><span class="line"></span><br><span class="line"><span class="meta">mybatis.mapper-locations</span>=<span class="string">classpath:sqlmap/mapper/*.xml</span></span><br><span class="line"><span class="meta">mybatis.type-aliases-package</span>=<span class="string">com.zwt.demo.model</span></span><br><span class="line"><span class="meta">mybatis.configuration.local-cache-scope</span>=<span class="string">session</span></span><br><span class="line"><span class="meta">mybatis.configuration.cache-enabled</span>=<span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="meta">spring.redis.database</span>=<span class="string">0</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="meta">spring.redis.timeout</span>=<span class="string">3600ms</span></span><br><span class="line"><span class="meta">spring.redis.jedis.pool.max-active</span>=<span class="string">8</span></span><br><span class="line"><span class="meta">spring.redis.jedis.pool.max-wait</span>=<span class="string">-1ms</span></span><br><span class="line"><span class="meta">spring.redis.jedis.pool.max-idle</span>=<span class="string">8</span></span><br><span class="line"><span class="meta">spring.redis.jedis.pool.min-idle</span>=<span class="string">0</span></span><br></pre></td></tr></table></figure><p>其项目结构如下：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-866.png"></p><p>可以看到在<code>cache</code>包下的内容就是我对于<code>Mybatis</code>二级缓存的自定义实现。</p><p>主要有两个类：<code>RedisCache</code>和<code>RedisCacheHelp</code>，<code>RedisCache1</code>是<code>RedisCache</code>的另一种实现。</p><p>我们来看下，首先看下<code>RedisCache</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisCache</span> <span class="keyword">implements</span> <span class="title">Cache</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RedisCache.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RedisTemplate&lt;String,Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String HASH_KEY = <span class="string">&quot;mybatis_redis_cache&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReadWriteLock <span class="title">getReadWriteLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.readWriteLock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setRedisTemplate</span><span class="params">(RedisTemplate redisTemplate)</span></span>&#123;</span><br><span class="line">        RedisCache.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisCache</span><span class="params">(<span class="keyword">final</span> String id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;需要指定id&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span></span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;MybatisRedisCache -&gt; putObject: key=&quot;</span> + key + <span class="string">&quot;,value=&quot;</span> + value);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span>!=value) &#123;</span><br><span class="line">            redisTemplate.opsForHash().put(HASH_KEY,key.toString(),value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;MybatisRedisCache -&gt; getObject: key=&quot;</span>+key);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> != key) &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForHash().get(HASH_KEY,key.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">removeObject</span><span class="params">(Object key)</span></span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;MybatisRedisCache -&gt; removeObject: key=&quot;</span>+key);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> != key) &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForHash().delete(HASH_KEY,key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Long size = redisTemplate.opsForHash().size(HASH_KEY);</span><br><span class="line">        redisTemplate.delete(HASH_KEY);</span><br><span class="line">        logger.info(<span class="string">&quot;MybatisRedisCache -&gt; clear: 清除了&quot;</span> + size + <span class="string">&quot;个对象&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Long size = redisTemplate.opsForHash().size(HASH_KEY);</span><br><span class="line">        <span class="keyword">return</span> size == <span class="keyword">null</span> ? <span class="number">0</span> : size.intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码非常好理解，就是实现<code>org.apache.ibatis.cache.Cache</code> 接口，通过<code>Redis</code>操作实现缓存的操作，这儿我们使用到了<code>Hash</code>表。</p><p>关于如何是上述代码中的<code>redisTemplate</code>生效，就要用到了<code>RedisCacheHelp</code>类，这个类代码如下，主要是实现<code>redisTemplate</code>的注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisCacheHelp</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRedisTemplate</span><span class="params">(RedisTemplate redisTemplate)</span> </span>&#123;</span><br><span class="line">        RedisCache.setRedisTemplate(redisTemplate);</span><br><span class="line">        <span class="comment">//RedisCache1.setRedisTemplate(redisTemplate);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码弄好后，我们还需要在具体的<code>xml</code>（如StudentMapper.xml）指定缓存类型为我们的<code>RedisCache</code>，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;com.zwt.demo.cache.RedisCache&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-867.png"></p><p>以上配置完成，我们就可以使用我们自定义的二级缓存了。</p><p>我们运行一下测试代码，比如上面的这一个测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cacheTest6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqlSession sqlSession1 = sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line">    SqlSession sqlSession2 = sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line">    SqlSession sqlSession3 = sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    StudentMapper studentMapper1 = sqlSession1.getMapper(StudentMapper.class);</span><br><span class="line">    StudentMapper studentMapper2 = sqlSession2.getMapper(StudentMapper.class);</span><br><span class="line">    StudentMapper studentMapper3 = sqlSession3.getMapper(StudentMapper.class);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;studentMapper1-&gt;&quot;</span>+studentMapper1.selectByPrimaryKey(<span class="number">1</span>));</span><br><span class="line">    sqlSession1.commit();</span><br><span class="line">    System.out.println(<span class="string">&quot;studentMapper2-&gt;&quot;</span>+studentMapper2.selectByPrimaryKey(<span class="number">1</span>));</span><br><span class="line">    studentMapper3.updateStudentName(<span class="string">&quot;张二二&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    sqlSession3.commit();</span><br><span class="line">    System.out.println(<span class="string">&quot;studentMapper2-&gt;&quot;</span>+studentMapper2.selectByPrimaryKey(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到如下输出：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-868.png"></p><p>说明已经使用了我们自定义的缓存策略。</p><p>大家可以看到我写了<code>RedisCache</code>和<code>RedisCache1</code>两个类，是这样的，我们可以看到<code>RedisCache</code>使用的是<code>Redis Hash</code>表结构来实现的二级缓存，其增加、删除、获取、统计数量、清空等操作十分方便，但有一个问题，就是<code>Hash</code>表没有办法设置其内部的单个<code>key</code>的过期时间，只能指定<code>Hash</code>表过期时间。</p><p>如果我们使用不当，可能会出现一些问题。</p><p><code>RedisCache1</code>的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisCache1</span> <span class="keyword">implements</span> <span class="title">Cache</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RedisCache1.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RedisTemplate&lt;String,Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String KEY_ALL_PREFIX = <span class="string">&quot;mybatis_redis_cache_%s&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReadWriteLock <span class="title">getReadWriteLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.readWriteLock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setRedisTemplate</span><span class="params">(RedisTemplate redisTemplate)</span></span>&#123;</span><br><span class="line">        RedisCache1.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisCache1</span><span class="params">(<span class="keyword">final</span> String id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;需要指定id&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span></span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;MybatisRedisCache -&gt; putObject: key=&quot;</span> + key + <span class="string">&quot;,value=&quot;</span> + value);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span>!=value) &#123;</span><br><span class="line">            redisTemplate.opsForValue().set(String.format(KEY_ALL_PREFIX,key.toString()),value,<span class="number">60</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;MybatisRedisCache -&gt; getObject: key=&quot;</span>+key);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> != key) &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForValue().get(String.format(KEY_ALL_PREFIX,key.toString()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">removeObject</span><span class="params">(Object key)</span></span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;MybatisRedisCache -&gt; removeObject: key=&quot;</span>+key);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> != key) &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.delete(String.format(KEY_ALL_PREFIX,key.toString()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; keys = redisTemplate.keys(String.format(KEY_ALL_PREFIX,<span class="string">&quot;*&quot;</span>));</span><br><span class="line">        redisTemplate.delete(keys);</span><br><span class="line">        logger.info(<span class="string">&quot;MybatisRedisCache -&gt; clear: 清除了&quot;</span> + keys.size() + <span class="string">&quot;个对象&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; keys = redisTemplate.keys(String.format(KEY_ALL_PREFIX,<span class="string">&quot;*&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> keys.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个类主要是利用<code>Redis key</code>前缀来处理缓存内容，其<code>K,V</code>都是单个存储的，其增加、删除、获取是非常方便的，而且可以指定<code>key</code>的过期时间，防止出现问题，但其清空、统计数量操作需要查出全部前缀数据的<code>Set</code>集合，在进行处理。</p><p>以上就是我们关于实现自定义<code>Mybatis</code>缓存的一些代码。</p><blockquote><p>这儿需要说的一点是：我们上述这种使用Redis实现<code>Mybatis</code>二级缓存的方式，在分布式环境下，可以将各个单机缓存归一，避免了一些查库操作，但实际上我们不使用二级缓存，只使用Redis也是可以解决的。</p><p>另外这种形式的二级缓存，出现（测试四）映射文件中存在多表查询的情况，如果不使用cache-ref，也会有脏数据问题。</p></blockquote><h1 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h1><p>本文通过对<code>Mybaits</code>一二级缓存的介绍，并从实验及源码角度分析了<code>Mybaits</code>缓存的特点、机制及可能产生的问题，并对缓存机制做了一定的总结。</p><p>而后我们又借助<code>Redis</code>实现了一个自定义的二级缓存处理器，加深对<code>Mybatis</code>缓存的理解。</p><p>在实际生产中，我们一般建议关闭<code>Mybatis</code>缓存特性，单纯将其作为一个<code>ORM</code>框架来使用。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://tech.meituan.com/2018/01/19/mybatis-cache.html">聊聊Mybatis缓存机制</a></li><li><a href="https://www.cnblogs.com/wuzhenzhao/p/11103043.html">mybatis缓存机制</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我们知道&lt;code&gt;Mybatis&lt;/code&gt;作为常见的&lt;code&gt;Java&lt;/code&gt;数据库访问层的&lt;code&gt;ORM&lt;/code&gt;框架，其缓存分为一级缓存和二级缓存。&lt;/p&gt;
&lt;p&gt;大多数情况下，我们使用的都是&lt;code&gt;Mybatis&lt;/code&gt;缓存的默认配置，但是&lt;code&gt;Mybatis&lt;/code&gt;缓存机制有一些不足之处，在使用中容易引起脏数据问题，形成一些潜在隐患。&lt;/p&gt;
&lt;p&gt;今天，我们就来看下&lt;code&gt;Mybatis&lt;/code&gt;的缓存机制，了解其底层的一些原理，来方便我们排查、解决以后可能出现的由&lt;code&gt;Mybatis&lt;/code&gt;缓存引起的问题。&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Mybatis" scheme="https://www.sakuratears.top/tags/Mybatis/"/>
    
    <category term="一级缓存" scheme="https://www.sakuratears.top/tags/%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98/"/>
    
    <category term="二级缓存" scheme="https://www.sakuratears.top/tags/%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁续期问题</title>
    <link href="https://www.sakuratears.top/blog/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%BB%AD%E6%9C%9F%E9%97%AE%E9%A2%98.html"/>
    <id>https://www.sakuratears.top/blog/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%BB%AD%E6%9C%9F%E9%97%AE%E9%A2%98.html</id>
    <published>2021-07-26T14:01:00.000Z</published>
    <updated>2021-07-26T14:17:37.406Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们在工作等一些场景中，一定是用到过分布式锁的。</p><p>无论采用<code>Zookeeper</code>还是<code>Redis</code>做分布式锁，锁是应该有一个有效期的。</p><p>如果我们不设置有效期，可能会出现死锁问题，导致锁不能释放，影响系统功能。</p><p>但是如果我们锁释放时间设置的不合理，导致锁释放后实际业务逻辑还没处理完，那也是不行的。</p><p>当然，我们可以预估业务逻辑的处理时间范围，合理的设置锁的释放时间，但是总归会可能出现业务处理时间过长的情况，这时候锁已经释放了，业务逻辑执行过程中就会处于不安全的环境里。</p><p>我们如何完全避免这种情况呢？</p><p>这就是我们这节要说的锁续期的一些知识。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>上述的情况其实非常好理解，就是如果有这种情况，我们直接让当前线程持有的锁在续期一段时间，保证业务逻辑能正常走完。</p><p>我们这儿以<code>Redis</code>分布式锁来进行说明。</p><h2 id="分布式锁举例"><a href="#分布式锁举例" class="headerlink" title="分布式锁举例"></a>分布式锁举例</h2><p>关于<code>Redis</code>分布式锁，我们可以使用开源类库，如 <code>Redisson</code> 就是一款优秀的工具包，其中包含了<code>Redis</code>分布式锁的实现。</p><p>其获取分布式锁的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置，这些东西可以放到配置文件里</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> RedissonClient <span class="title">redissonClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Config config = <span class="keyword">new</span> Config();</span><br><span class="line">    config.useSingleServer().setAddress(<span class="string">&quot;redis://127.0.0.1:6379&quot;</span>).setDatabase(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    RedissonClient client = redissonClient();</span><br><span class="line">    <span class="comment">//通过客户端获取Redis分布式锁</span></span><br><span class="line">    RLock lock = client.getLock(REDIS_KEY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：</strong>这儿我们为了方便，使用了单一 <code>Redis</code>实例，当然也是支持 <code>Redis</code> 集群和主从模式的，这儿就不过多介绍了。</p><p>我们拿到<code>lock</code>后，可以进行加锁、解锁等逻辑，如下图。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-820.png"></p><p>可以看到它继承<code>Lock</code>接口，当然<code>Lock</code>接口的几个方法也会实现。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-821.png"></p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-822.png"></p><p>我们知道，对于没有设置锁超时时间的方法，如<code>tryLock()</code> ,如果加锁后某些原因导致锁不能释放，会出现死锁问题。</p><p> <code>Redisson</code> 对于这种情况是怎么处理的呢？我们来看一下。</p><p>首先，我们先来看如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedissonRenewalLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试续期锁key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REDIS_KEY = <span class="string">&quot;redisson_renewal_lock&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> RedissonClient <span class="title">redissonClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Config config = <span class="keyword">new</span> Config();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://127.0.0.1:6379&quot;</span>).setDatabase(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RedissonClient client = redissonClient();</span><br><span class="line">        RLock lock = client.getLock(REDIS_KEY);</span><br><span class="line">        <span class="keyword">boolean</span> isLock = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            isLock = lock.tryLock(<span class="number">1</span>,<span class="number">30</span>,TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span>(isLock)&#123;</span><br><span class="line">                <span class="comment">// do something</span></span><br><span class="line">                <span class="comment">//假设执行任务花费了50s</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50</span>;i++)&#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    System.out.println(lock.remainTimeToLive());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;未成功获得锁......&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(isLock)&#123;</span><br><span class="line">                <span class="keyword">if</span>(lock.isHeldByCurrentThread())&#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的意思是获取锁后，我们设置锁超时时间为30s，假设我们需要处理一个耗时50s的任务，每隔1s输出下锁的剩余时间。</p><p>可以看到30s后返回时间变为-2，表示锁已经被释放，此时业务逻辑还没执行完，执行处于不安全环境中。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-823.png"></p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-824.png"></p><p>我们这样使用，如果业务逻辑处理时间超过我们锁的超时时间，就会有些问题。</p><p><strong>我们将上述的<code>lock.tryLock(1,30,TimeUnit.SECONDS);</code> 改为 <code>lock.tryLock();</code>方法来看下。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">//isLock = lock.tryLock(1,30,TimeUnit.SECONDS);</span></span><br><span class="line">   isLock = lock.tryLock();<span class="comment">//改为tryLock();</span></span><br><span class="line">   <span class="keyword">if</span>(isLock)&#123;</span><br><span class="line">       ......</span><br></pre></td></tr></table></figure><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-825.png"></p><p>查看日志我们可以发现锁的剩余时间每隔一段时间就会增加，这就是我们今天要说的锁续期。</p><h2 id="分布式锁续期原理"><a href="#分布式锁续期原理" class="headerlink" title="分布式锁续期原理"></a>分布式锁续期原理</h2><p>上面代码我们肯定有所疑问，我们来看下。</p><ul><li>我们通过<code>tryLock()</code>没有设置锁的超时时间，看日志它好像是默认30s计时？</li><li>当每隔10s后，如果业务逻辑还没执行完，会进行锁的续期？</li></ul><p>这些问题我们都需要通过源码来看下。</p><p>首先通过 <code>tryLock()</code>方法找到 <code>RedissonLock</code>的 <code>tryLock()</code> 方法实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(tryLockAsync());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>tryLockAsync()</code>方法可以找到具体实现逻辑，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RFuture&lt;Boolean&gt; <span class="title">tryLockAsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tryLockAsync(Thread.currentThread().getId());</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RFuture&lt;Boolean&gt; <span class="title">tryLockAsync</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tryAcquireOnceAsync(-<span class="number">1</span>, <span class="keyword">null</span>, threadId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-826.png"></p><p>关键方法<code>tryAcquireOnceAsync</code> ，其中<code>leaseTime</code> 传入 -1，会执行<code>tryLockInnerAsync</code>方法，传入一个过期时间，同时会有一个续期的逻辑。</p><p><code>tryLockInnerAsync</code> 方法就是去执行一段 <code>Lua</code>脚本，设置锁。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-827.png"></p><p>这段<code>Lua</code>脚本的**KEYS<code>[1]</code>**代表的是加锁的那个key，比如<code>redisson_renewal_lock</code>；</p><p>**ARGV<code>[1]</code>**代表的是锁key的默认生存时间，默认30秒；</p><p>**ARGV<code>[2]</code>**代表的是加锁的客户端的ID，如 <code>25008516-595b-4a9f-af59-165a14330820:1</code>。</p><p>逻辑如下：</p><p><strong>加锁逻辑</strong></p><ol><li><p>第一段<code>if</code>判断语句，用<code>exists redisson_renewal_lock</code>命令判断一下，如果要加锁的那个key不存在的话，就进行加锁;</p></li><li><p>加锁操作，<code>hset redisson_renewal_lock  25008516-595b-4a9f-af59-165a14330820:1 1</code>；</p></li><li><p><code>redisson_renewal_lock </code> 的数据如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redisson_renewal_lock</span><br><span class="line">&#123;</span><br><span class="line">    25008516-595b-4a9f-af59-165a14330820:<span class="number">1</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>设置锁过期时间，<code>pexpire redisson_renewal_lock 30000</code> ；</p></li><li><p>至此加锁完成。</p></li></ol><p><strong>锁互斥逻辑</strong></p><ol><li>当客户端2想尝试获取锁时，此时只有客户端id不同，比如 <code>ARGV[2]</code>为 <code>f0b30905-e2a0-43c4-91a2-9aa608a3ba1e:1</code>;</li><li>第一段<code>if</code>判断语句，明显锁已被客户端1持有，判断逻辑进不去；</li><li>来到第二段<code>if</code>判断语句，判断 <code>hash</code>数据结构中是否包含客户端2的id，显然不存在，里面是客户端1的id；</li><li>所以客户端2会获取到<code>pttl redisson_renewal_lock </code>返回的一个数字，这个数字代表了<code>redisson_renewal_lock</code> 这个锁key的<strong>剩余生存时间。</strong></li><li>客户端2会等待，并尝试重新获取锁。</li></ol><p><strong>重入锁逻辑</strong></p><ol><li><p>当客户端1未释放锁，又想获取该锁时（重入）；</p></li><li><p>第一段<code>if</code>判断语句，明显锁已经存在，判断逻辑进不去；</p></li><li><p>来到第二段<code>if</code>判断语句，<code>hexists redisson_renewal_lock 25008516-595b-4a9f-af59-165a14330820:1 </code> ,判断通过，存在客户端1的id；</p></li><li><p>调用 <code>hincrby redisson_renewal_lock 25008516-595b-4a9f-af59-165a14330820:1 1 </code>，意思是为其+1；</p></li><li><p>因此<code>redisson_renewal_lock </code> 的数据变为了如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redisson_renewal_lock</span><br><span class="line">&#123;</span><br><span class="line">    25008516-595b-4a9f-af59-165a14330820:<span class="number">1</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>设置锁过期时间，<code>pexpire redisson_renewal_lock 30000</code> ；</p></li><li><p>至此重入锁逻辑完成。</p></li></ol><p><strong>注：</strong> 这儿使用<code>Lua</code>脚本的原因就是为了保证操作的<strong>原子性</strong>。</p><p>上述传入的时间我们也可以很快找到，默认设置的是30s。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> lockWatchdogTimeout = <span class="number">30</span> * <span class="number">1000</span>;</span><br></pre></td></tr></table></figure><p>这也就解决了我们的第一个疑问。</p><p>可以看到，<code>Redisson</code>的 <code>tryLock()</code>方法默认设置的30s的锁有效期，每隔一定时间，就会为锁续期，续期是通过<code>scheduleExpirationRenewal</code> 保证的。</p><p>我们来看下这个方法，关键调用方法如下：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-828.png"></p><p>其关键部分就是创建一个<code>TimerTask</code> 执行续约逻辑，该任务的间隔时间是<code>internalLockLeaseTime / 3</code>，默认的情况下是10s，也就是我们在日志中看到的每个10s，锁的超时时间又变为了30s的原因。</p><p>其锁续约的代码也是一段<code>Lua</code>脚本。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-829.png"></p><p>这段<code>Lua</code>脚本就不过多介绍了。</p><p><strong>锁续期的原理图</strong>如下：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-830.png"></p><p>我们再来看下<strong>释放锁的逻辑</strong>，这儿只上关键性部分，如下：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-831.png"></p><p>释放锁的<code>Lua</code>脚本如下：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-832.png"></p><p>其主要逻辑是：</p><ol><li>判断当前线程锁存不存在，不存在就不用处理了；</li><li>如果存在，进行次数-1操作；</li><li>如果次数还是大于0的（重入锁），就重新设置过期时间；</li><li>否则就删除锁key（释放锁），同时进行通知。</li></ol><p>这里的**KEYS<code>[1]</code>**代表的是加锁的那个key，比如<code>redisson_renewal_lock</code>；</p><p>**ARGV<code>[1]</code><strong>和</strong>KEYS<code>[2]</code>**代表的是释放锁后通知的消息信息；</p><p>**ARGV<code>[2]</code>**代表的是锁key的默认生存时间，默认30秒；</p><p>**ARGV<code>[3]</code>**代表的是加锁的客户端的ID，如 <code>25008516-595b-4a9f-af59-165a14330820:1</code>。</p><h2 id="自写Redis续期锁"><a href="#自写Redis续期锁" class="headerlink" title="自写Redis续期锁"></a>自写Redis续期锁</h2><p>我们根据上面逻辑，可以手写一个<code>Redis</code>续期锁，这儿我们依靠守护线程来延期锁<code>key</code>。</p><p>首先我们需要锁<code>key</code>、加锁时间、守护线程参数等，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRedisLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String lockKey;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁持有时间，默认30s</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lockTime;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否加锁成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 守护线程参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> DaemonCheckProcessor checkProcessor;</span><br><span class="line">    <span class="keyword">private</span> Thread checkThread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加锁id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String clientId = UUID.randomUUID().toString()+<span class="string">&quot;:&quot;</span>+Thread.currentThread().getId();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * redis操作类，直接用redisTemplate也可以，这儿为了main运行方便直接引入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> RedisRepository redisRepository;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>success</code>用来记录锁状态，<code>clientId</code>用于标识该锁的持有者。</p><p>构造方法只要传入锁<code>key</code>就行，我们这儿还传入了<code>RedisRepository（即 RedisTemplate）</code>，其实可以用<code>Spring</code>注入，我们这儿为了方便就直接引入了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyRedisLock</span><span class="params">(String lockKey,RedisRepository redisRepository)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.lockKey = lockKey;</span><br><span class="line">    <span class="keyword">this</span>.redisRepository = redisRepository;</span><br><span class="line">    <span class="keyword">this</span>.lockTime = <span class="number">30000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>锁需要有几个关键方法：<code>tryLock</code>、<code>unLock</code>等，此外还需要能判断锁是否加锁成功及是否当前线程持有锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String script = <span class="string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot;</span> +</span><br><span class="line">        <span class="string">&quot;redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">        <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">        <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">        <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">        <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">        <span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">        <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">        <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">        <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">        <span class="string">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span>;</span><br><span class="line">    Long waitTime = redisRepository.eval(script,Long.class,lockKey,lockTime,clientId);</span><br><span class="line">    <span class="keyword">if</span>(waitTime!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//如果存在并且不是当前线程，返回加锁失败，这儿也可以返回需要等待的时间waitTime</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开启一个守护线程计时</span></span><br><span class="line">    checkProcessor = <span class="keyword">new</span> DaemonCheckProcessor(lockKey, clientId, lockTime,redisRepository);</span><br><span class="line">    checkThread = <span class="keyword">new</span> Thread(checkProcessor);</span><br><span class="line">    checkThread.setDaemon(Boolean.TRUE);</span><br><span class="line">    checkThread.start();</span><br><span class="line">    success = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String script = <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 0) then &quot;</span> +</span><br><span class="line">        <span class="string">&quot;return nil;&quot;</span> +</span><br><span class="line">        <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">        <span class="string">&quot;local counter = redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], -1); &quot;</span> +</span><br><span class="line">        <span class="string">&quot;if (counter &gt; 0) then &quot;</span> +</span><br><span class="line">        <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">        <span class="string">&quot;return 0; &quot;</span> +</span><br><span class="line">        <span class="string">&quot;else &quot;</span> +</span><br><span class="line">        <span class="string">&quot;redis.call(&#x27;del&#x27;, KEYS[1]); &quot;</span> +</span><br><span class="line">        <span class="string">&quot;return 1; &quot;</span>+</span><br><span class="line">        <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">        <span class="string">&quot;return nil;&quot;</span>;</span><br><span class="line">    redisRepository.eval(script,Integer.class,lockKey,lockTime,clientId);</span><br><span class="line">    <span class="comment">//需要释放守护线程资源</span></span><br><span class="line">    <span class="keyword">if</span>(checkProcessor != <span class="keyword">null</span>)&#123;</span><br><span class="line">        checkProcessor.stop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(checkThread!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        checkThread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    success =<span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这儿我们构建一个守护线程类，该类每隔 <code>2/3 lockTime</code>就会去尝试延期一下，如果锁还没被释放的话。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DaemonCheckProcessor</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MARK_EXPIRE_SUCCESS = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String clientId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lockTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RedisRepository redisRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DaemonCheckProcessor</span><span class="params">(String key, String clientId, <span class="keyword">long</span> lockTime,RedisRepository redisRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.clientId = clientId;</span><br><span class="line">        <span class="keyword">this</span>.lockTime = lockTime;</span><br><span class="line">        <span class="keyword">this</span>.signal = Boolean.TRUE;</span><br><span class="line">        <span class="keyword">this</span>.redisRepository = redisRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 守护线程停止标记</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Boolean signal;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.signal = Boolean.FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//每隔 2/3 时间自动检测</span></span><br><span class="line">        <span class="keyword">long</span> waitTime = lockTime * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">while</span> (signal) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(waitTime);</span><br><span class="line">                <span class="comment">//延长过期时间</span></span><br><span class="line">                <span class="keyword">if</span> (expandLockTime(key, clientId, lockTime) != MARK_EXPIRE_SUCCESS) &#123;</span><br><span class="line">                    <span class="comment">//如果不成功就停掉任务</span></span><br><span class="line">                    <span class="keyword">this</span>.stop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁续期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clientId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockTime</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Long <span class="title">expandLockTime</span><span class="params">(String key,String clientId,<span class="keyword">long</span> lockTime)</span></span>&#123;</span><br><span class="line">        String script = <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">                <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                <span class="string">&quot;return 1; &quot;</span> +</span><br><span class="line">                <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                <span class="string">&quot;return 0;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> redisRepository.eval(script,Long.class,key,lockTime,clientId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本流程就是这样，我下面附上自写的完整代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zwt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 自定义续期锁</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/7/26 10:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRedisLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String lockKey;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁持有时间，默认30s</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lockTime;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否加锁成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 守护线程参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> DaemonCheckProcessor checkProcessor;</span><br><span class="line">    <span class="keyword">private</span> Thread checkThread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加锁id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String clientId = UUID.randomUUID().toString()+<span class="string">&quot;:&quot;</span>+Thread.currentThread().getId();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * redis操作类，直接用redisTemplate也可以，这儿为了main运行方便直接引入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> RedisRepository redisRepository;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> redisRepository</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRedisLock</span><span class="params">(String lockKey,RedisRepository redisRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lockKey = lockKey;</span><br><span class="line">        <span class="keyword">this</span>.redisRepository = redisRepository;</span><br><span class="line">        <span class="keyword">this</span>.lockTime = <span class="number">30000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRedisLock</span><span class="params">(String lockKey,RedisRepository redisRepository,<span class="keyword">long</span> lockTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lockKey = lockKey;</span><br><span class="line">        <span class="keyword">this</span>.redisRepository = redisRepository;</span><br><span class="line">        <span class="keyword">this</span>.lockTime = lockTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String script = <span class="string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot;</span> +</span><br><span class="line">                <span class="string">&quot;redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">                <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">                <span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">                <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                <span class="string">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span>;</span><br><span class="line">        Long waitTime = redisRepository.eval(script,Long.class,lockKey,lockTime,clientId);</span><br><span class="line">        <span class="keyword">if</span>(waitTime!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果存在并且不是当前线程，返回加锁失败，这儿也可以返回需要等待的时间waitTime</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开启一个守护线程计时</span></span><br><span class="line">        checkProcessor = <span class="keyword">new</span> DaemonCheckProcessor(lockKey, clientId, lockTime,redisRepository);</span><br><span class="line">        checkThread = <span class="keyword">new</span> Thread(checkProcessor);</span><br><span class="line">        checkThread.setDaemon(Boolean.TRUE);</span><br><span class="line">        checkThread.start();</span><br><span class="line">        success = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询剩余时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">remainTimeToLive</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String script = <span class="string">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> redisRepository.eval(script,Long.class,lockKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String script = <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 0) then &quot;</span> +</span><br><span class="line">                <span class="string">&quot;return nil;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                <span class="string">&quot;local counter = redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], -1); &quot;</span> +</span><br><span class="line">                <span class="string">&quot;if (counter &gt; 0) then &quot;</span> +</span><br><span class="line">                <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                <span class="string">&quot;return 0; &quot;</span> +</span><br><span class="line">                <span class="string">&quot;else &quot;</span> +</span><br><span class="line">                <span class="string">&quot;redis.call(&#x27;del&#x27;, KEYS[1]); &quot;</span> +</span><br><span class="line">                <span class="string">&quot;return 1; &quot;</span>+</span><br><span class="line">                <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                <span class="string">&quot;return nil;&quot;</span>;</span><br><span class="line">        redisRepository.eval(script,Integer.class,lockKey,lockTime,clientId);</span><br><span class="line">        <span class="comment">//需要释放守护线程资源</span></span><br><span class="line">        <span class="keyword">if</span>(checkProcessor != <span class="keyword">null</span>)&#123;</span><br><span class="line">            checkProcessor.stop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(checkThread!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            checkThread.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        success =<span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否加锁成功</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSuccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> success;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否当前线程持有锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHeldByCurrentThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String script = <span class="string">&quot;return redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1])&quot;</span>;</span><br><span class="line">        Long val = redisRepository.eval(script,Long.class,lockKey,clientId);</span><br><span class="line">        <span class="keyword">if</span>(val !=<span class="keyword">null</span> &amp;&amp; val &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//存在并且大于0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构建RedisTemplate</span></span><br><span class="line"></span><br><span class="line">        RedisStandaloneConfiguration config = <span class="keyword">new</span> RedisStandaloneConfiguration();</span><br><span class="line">        config.setDatabase(<span class="number">0</span>);</span><br><span class="line">        config.setHostName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        config.setPort(<span class="number">6379</span>);</span><br><span class="line">        JedisConnectionFactory conn = <span class="keyword">new</span> JedisConnectionFactory(config);</span><br><span class="line"></span><br><span class="line">        RedisTemplate&lt;String,String&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(conn);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        RedisRepository redisRepository = <span class="keyword">new</span> RedisRepository(template);</span><br><span class="line">        <span class="comment">//测试一下是不是能用</span></span><br><span class="line">        redisRepository.set(<span class="string">&quot;test&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        System.out.println(redisRepository.get(<span class="string">&quot;test&quot;</span>));</span><br><span class="line">        redisRepository.del(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试自写的续期锁</span></span><br><span class="line">        MyRedisLock lock = <span class="keyword">new</span> MyRedisLock(<span class="string">&quot;lock_test&quot;</span>,redisRepository);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(lock.tryLock())&#123;</span><br><span class="line">                <span class="comment">//do something</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50</span>;i++)&#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    System.out.println(lock.remainTimeToLive());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(lock.isSuccess())&#123;</span><br><span class="line">                <span class="keyword">if</span>(lock.isHeldByCurrentThread())&#123;</span><br><span class="line">                    lock.unLock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 守护进程类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DaemonCheckProcessor</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MARK_EXPIRE_SUCCESS = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String clientId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lockTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RedisRepository redisRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DaemonCheckProcessor</span><span class="params">(String key, String clientId, <span class="keyword">long</span> lockTime,RedisRepository redisRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.clientId = clientId;</span><br><span class="line">        <span class="keyword">this</span>.lockTime = lockTime;</span><br><span class="line">        <span class="keyword">this</span>.signal = Boolean.TRUE;</span><br><span class="line">        <span class="keyword">this</span>.redisRepository = redisRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 守护线程停止标记</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Boolean signal;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.signal = Boolean.FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//每隔 2/3 时间自动检测</span></span><br><span class="line">        <span class="keyword">long</span> waitTime = lockTime * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">while</span> (signal) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(waitTime);</span><br><span class="line">                <span class="comment">//延长过期时间</span></span><br><span class="line">                <span class="keyword">if</span> (expandLockTime(key, clientId, lockTime) != MARK_EXPIRE_SUCCESS) &#123;</span><br><span class="line">                    <span class="comment">//如果不成功就停掉任务</span></span><br><span class="line">                    <span class="keyword">this</span>.stop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁续期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clientId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockTime</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Long <span class="title">expandLockTime</span><span class="params">(String key,String clientId,<span class="keyword">long</span> lockTime)</span></span>&#123;</span><br><span class="line">        String script = <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">                <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                <span class="string">&quot;return 1; &quot;</span> +</span><br><span class="line">                <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                <span class="string">&quot;return 0;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> redisRepository.eval(script,Long.class,key,lockTime,clientId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外这儿还涉及到了 <code>RedisRepository</code> 这个类，这个类其实就是包装了下 <code>RedisTemplate</code>，如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisRepository</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Spring Redis Template</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisRepository</span><span class="params">(RedisTemplate&lt;String, String&gt; redisTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......部分方法略，见RedisTemplate</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 RedisSerializer</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the redis serializer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> RedisSerializer&lt;String&gt; <span class="title">getRedisSerializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.getStringSerializer();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Lua 脚本执行器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">eval</span><span class="params">(<span class="keyword">final</span> String luaScript, Class&lt;T&gt; resultClass, String key, Object... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.execute((RedisCallback&lt;T&gt;) connection -&gt; &#123;</span><br><span class="line">            RedisSerializer&lt;String&gt; serializer = getRedisSerializer();</span><br><span class="line">            List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            list.add(key);</span><br><span class="line">            list.addAll(Arrays.asList(args));</span><br><span class="line">            List&lt;<span class="keyword">byte</span>[]&gt; var1 = list.stream().map(x -&gt; serializer.serialize(<span class="string">&quot;&quot;</span> + x)).collect(Collectors.toList());</span><br><span class="line">            <span class="keyword">byte</span>[][] var2 = var1.toArray(<span class="keyword">new</span> <span class="keyword">byte</span>[var1.size()][]);</span><br><span class="line">            <span class="keyword">return</span> connection.eval(serializer.serialize(luaScript), ReturnType.fromJavaType(resultClass), <span class="number">1</span>, var2);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用上面的类运行一下，可以看到输出日志，锁在剩余10s左右的时候续期了。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-833.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是关于分布式锁续期的一些内容，我们通过分析<code>Redisson</code>的加锁逻辑，发现其锁续期的一些内容，其通过<code>Lua</code>脚本+ <code>TimeTask</code>等实现锁续期，使用到了<code>Redis</code>哈希表及其一些操作<code>hset、hexists</code> 等来实现分布式锁，保证其唯一性和可重入性。</p><p>而后我们又自己手写了一个基于<code>Redis</code>的续期锁，加深对续期锁的理解。</p><p>到这儿差不多就结束了，另外我们需要补充一点，是一种有可能发生的情况。</p><p>这儿需要注意的是我们以上是针对的单机<code>Redis</code>来说的，如果是主从服务或者集群<code>Redis</code>，这种分布式锁可能会有一个小问题。如下：</p><ol><li>客户端1对某个<code>redis master</code>实例，写入了锁<code>key</code>的<code>value</code>，此时会异步复制给对应的<code>master slave</code>实例；</li><li>但是在复制过程中发生了<code>redis master</code>宕机，主备切换，<code>redis slave</code>变为了<code>redis master</code>，<code>redis slave</code>上并不存在锁<code>key</code>；</li><li>客户端2来尝试加锁的时候，在新的<code>redis master</code>上完成了加锁，而客户端1也以为自己成功加了锁；</li><li>此时就会导致多个客户端对一个分布式锁完成了加锁，这样就有可能在业务上产生一些问题。</li></ol><p>关于上面这种情况，我们可以使用红锁<code>RedLock</code>来解决，这部分内容可以查看 <a href="https://www.sakuratears.top/blog/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%B9%8B%E7%BA%A2%E9%94%81%EF%BC%88RedLock%EF%BC%89.html">Redis分布式锁之红锁（RedLock）</a> 这篇文章。</p>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我们在工作等一些场景中，一定是用到过分布式锁的。&lt;/p&gt;
&lt;p&gt;无论采用&lt;code&gt;Zookeeper&lt;/code&gt;还是&lt;code&gt;Redis&lt;/code&gt;做分布式锁，锁是应该有一个有效期的。&lt;/p&gt;
&lt;p&gt;如果我们不设置有效期，可能会出现死锁问题，导致锁不能释放，影响系统功能。&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Redis" scheme="https://www.sakuratears.top/tags/Redis/"/>
    
    <category term="分布式锁" scheme="https://www.sakuratears.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
    <category term="续期锁" scheme="https://www.sakuratears.top/tags/%E7%BB%AD%E6%9C%9F%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Mysql锁相关知识</title>
    <link href="https://www.sakuratears.top/blog/Mysql%E9%94%81%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86.html"/>
    <id>https://www.sakuratears.top/blog/Mysql%E9%94%81%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86.html</id>
    <published>2021-07-20T13:37:00.000Z</published>
    <updated>2021-07-20T13:38:27.590Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天我们来看下<code>Mysql</code>中锁相关的一些内容。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="简单对比"><a href="#简单对比" class="headerlink" title="简单对比"></a>简单对比</h2><p><code>Mysql</code> 存储引擎相关对比如下：</p><table><thead><tr><th>Mysql存储引擎</th><th>事务</th><th>行锁</th><th>表锁</th></tr></thead><tbody><tr><td>MyISAM</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>InnoDB</td><td>支持</td><td>支持</td><td>支持</td></tr></tbody></table><p>行锁与表锁的对比如下：</p><table><thead><tr><th>锁</th><th>开销</th><th>加锁速度</th><th>是否可能死锁</th><th>粒度范围</th><th>冲突概率</th><th>并发度</th></tr></thead><tbody><tr><td>行锁</td><td>开销大</td><td>加锁慢</td><td>可能会出现死锁</td><td>粒度小</td><td>冲突概率低</td><td>并发度高</td></tr><tr><td>表锁</td><td>开销小</td><td>加锁快</td><td>不会出现死锁</td><td>粒度大</td><td>冲突概率高</td><td>并发度低</td></tr></tbody></table><p><code>Mysql</code> <code>InnoDB</code> 存储引擎默认使用<strong>行锁</strong>。</p><h2 id="InnoDB锁的争用情况"><a href="#InnoDB锁的争用情况" class="headerlink" title="InnoDB锁的争用情况"></a>InnoDB锁的争用情况</h2><p>对于 <code>InnoDB</code> 存储引擎，可以通过检查 <code>InnoDB_row_lock</code> 状态变量来分析<code>Mysql</code>上的行锁的争夺情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show status like &#x27;innodb_row_lock%&#x27;;</span><br></pre></td></tr></table></figure><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-782.png"></p><p>如果<code>innodb_row_lock_waits</code>和<code>innodb_row_lock_time_avg</code>的值比较高，说明可能锁的争夺比较严重。</p><p>我们可以通过设置 <code>InnoDB Monitors</code> 来进一步观察发生锁冲突的表、数据行等，并分析锁争用的原因。</p><p>如下语句：</p><ol><li><p>开启监视器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE innodb_monitor(a INT) ENGINE=INNODB;</span><br></pre></td></tr></table></figure><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-783.png"></p></li><li><p>查询信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show engine innodb status;</span><br></pre></td></tr></table></figure><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-784.png"></p><p><code>Status</code> 字段内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">=====================================</span><br><span class="line">2021-07-13 10:32:09 0x7ff568255700 INNODB MONITOR OUTPUT</span><br><span class="line">=====================================</span><br><span class="line">Per second averages calculated from the last 52 seconds</span><br><span class="line">-----------------</span><br><span class="line">BACKGROUND THREAD</span><br><span class="line">-----------------</span><br><span class="line">srv_master_thread loops: 177362 srv_active, 0 srv_shutdown, 932030 srv_idle</span><br><span class="line">srv_master_thread log flush and writes: 1109392</span><br><span class="line">----------</span><br><span class="line">SEMAPHORES</span><br><span class="line">----------</span><br><span class="line">OS WAIT ARRAY INFO: reservation count 389051</span><br><span class="line">OS WAIT ARRAY INFO: signal count 362447</span><br><span class="line">RW-shared spins 0, rounds 543070, OS waits 271365</span><br><span class="line">RW-excl spins 0, rounds 25094, OS waits 703</span><br><span class="line">RW-sx spins 278, rounds 7602, OS waits 187</span><br><span class="line">Spin rounds per wait: 543070.00 RW-shared, 25094.00 RW-excl, 27.35 RW-sx</span><br><span class="line">------------</span><br><span class="line">TRANSACTIONS</span><br><span class="line">------------</span><br><span class="line">Trx id counter 63028783</span><br><span class="line"></span><br><span class="line">.................略去部分内容</span><br><span class="line"></span><br><span class="line">0 read views open inside InnoDB</span><br><span class="line">Process ID=17317, Main thread ID=140694730979072, state: sleeping</span><br><span class="line">Number of rows inserted 227880, updated 171667, deleted 2140, read 9979111369</span><br><span class="line">0.00 inserts/s, 0.13 updates/s, 0.00 deletes/s, 9813.50 reads/s</span><br><span class="line">----------------------------</span><br><span class="line">END OF INNODB MONITOR OUTPUT</span><br><span class="line">============================</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>移除监视器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE innodb_monitor;</span><br></pre></td></tr></table></figure></li></ol><p>注意：设置监视器后，在<code>show engine innodb status</code>的显示内容中，会有详细的当前锁等待的信息，包括表名、锁类型、锁定记录的情况等，便于进行进一步的分析和问题的确定。打开监视器以后，默认情况下每15秒会向日志中记录监控的内容，如果长时间打开会导致<code>.err</code>文件变得非常的巨大，所以用户在确认问题原因之后，要记得删除监控表以关闭监视器，或者通过使用<code>--console</code>选项来启动服务器以关闭写日志文件。</p><p>PS：<code>MySQL 8.0</code> 版本弃用了<code>innodb_monitor</code>，新增了全新的锁观测方式，在<code>performance_schema</code>下新增了<code>data_locks</code>表和<code>data_lock_waits</code>表。</p><p><a href="https://dev.mysql.com/worklog/task/?id=5533">MySQL 文档</a></p><h2 id="InnoDB-的行锁模式及加锁方法"><a href="#InnoDB-的行锁模式及加锁方法" class="headerlink" title="InnoDB 的行锁模式及加锁方法"></a>InnoDB 的行锁模式及加锁方法</h2><p><code>InnoDB</code> 实现了以下两种类型的行锁（Row Locks）。</p><ul><li>共享锁（shared lock）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</li><li>排他锁（exclusive lock）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。</li></ul><p>另外，为了允许行锁和表锁（Table Locks）共存，实现多粒度锁机制，<code>InnoDB</code>还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁。</p><ul><li>意向共享锁（Intention shared lock）：事务打算给数据行共享锁，事务在给一个数据行加共享锁前必须先取得该表的意向共享锁。</li><li>意向排他锁（Intention exclusive lock）：事务打算给数据行加排他锁，事务在给一个数据行加排他锁前必须先取得该表的意向排他锁。</li></ul><p>上述锁模式的兼容情况具体如下表所示。</p><table><thead><tr><th>请求锁模式<br>             是否兼容<br>当前锁模式</th><th>排他锁</th><th>意向排他锁</th><th>共享锁</th><th>意向共享锁</th></tr></thead><tbody><tr><td><strong>排他锁</strong></td><td>冲突</td><td>冲突</td><td>冲突</td><td>冲突</td></tr><tr><td><strong>意向排他锁</strong></td><td>冲突</td><td>兼容</td><td>冲突</td><td>兼容</td></tr><tr><td><strong>共享锁</strong></td><td>冲突</td><td>冲突</td><td>兼容</td><td>兼容</td></tr><tr><td><strong>意向共享锁</strong></td><td>冲突</td><td>兼容</td><td>兼容</td><td>兼容</td></tr></tbody></table><p>如果一个事务请求的锁模式与当前的锁兼容，<code>InnoDB</code>就将请求的锁授予该事务；反之，如果两者不兼容，该事务就要等待锁释放。</p><p>意向锁是<code>InnoDB</code>自动加的，不需用户干预。</p><p>对于<code>UPDATE</code>、<code>DELETE</code>和<code>INSERT</code>语句，<code>InnoDB</code>会自动给涉及数据集加排他锁；</p><p>对于普通<code>SELECT</code>语句，<code>InnoDB</code>不会加任何锁；</p><p>事务可以通过以下语句显式给记录集加共享锁或排他锁。</p><ul><li><p>共享锁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE</span><br></pre></td></tr></table></figure></li><li><p>排他锁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table_name WHERE ... FOR UPDATE</span><br></pre></td></tr></table></figure></li></ul><p>用<code>SELECT ... IN SHARE MODE</code>获得共享锁，主要用在需要数据依存关系时来确认某行记录是否存在，并确保没有人对这个记录进行<code>UPDATE</code>或者<code>DELETE</code>操作。但是如果当前事务也需要对该记录进行更新操作，则很有可能造成死锁，对于锁定行记录后需要进行更新操作的应用，应该使用<code>SELECT... FOR UPDATE</code>方式获得排他锁。</p><p>假设有一张如下表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `course` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `cou_no` varchar(10) DEFAULT NULL,</span><br><span class="line">  `cou_name` varchar(255) DEFAULT NULL,</span><br><span class="line">  `teach_no` varchar(20) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `idx_teach_no` (`teach_no`) USING BTREE,</span><br><span class="line">  KEY `idx_cou_no` (`cou_no`) USING BTREE</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><p>表数据如下：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-785.png"></p><p>我们以此表来看下<code>InnoDB</code>存储引擎的<strong>共享锁</strong>例子。</p><table><thead><tr><th>session_1</th><th>session_2</th></tr></thead><tbody><tr><td><code>set autocommit = 0;</code><br/><code>select id,cou_no,cou_name,teach_no from course where id= 1;</code><br>结果如下：<br><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-786.png"></td><td><code>set autocommit = 0;</code><br/><code>select id,cou_no,cou_name,teach_no from course where id= 1;</code><br/>结果如下：<br/><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-786.png"></td></tr><tr><td>当前<code>session</code> 对<code>id=1</code>的记录加<code>share mode</code> 的共享锁。<br><code>select id,cou_no,cou_name,teach_no from course where id= 1 LOCK in SHARE MODE;</code><br>结果如下：<br><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-787.png"></td><td></td></tr><tr><td></td><td>其他<code>session</code>仍然可以查询记录，并也可以对该记录加<code>share mode</code>的共享锁。<br><code>select id,cou_no,cou_name,teach_no from course where id= 1 LOCK in SHARE MODE;</code><br>结果如下：<br><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-787.png"></td></tr><tr><td>当前<code>session</code>对锁定的记录进行更新操作，会等待锁。<br><code>update course set cou_name = &#39;语文1&#39; where id = 1;</code><br><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-788.png"></td><td></td></tr><tr><td></td><td>其他<code>session</code>也对该记录进行更新操作，则会导致死锁退出。<br><code>update course set cou_name = &#39;语文2&#39; where id = 1;</code><br><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-789.png"></td></tr><tr><td>获得锁后，可以成功更新。<br><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-790.png"></td><td></td></tr></tbody></table><p>我们再来看下<code>InnoDB</code>存储引擎的<strong>排他锁</strong>例子。</p><table><thead><tr><th>session_1</th><th>session_2</th></tr></thead><tbody><tr><td><code>set autocommit = 0;</code><br/><code>select id,cou_no,cou_name,teach_no from course where id= 1;</code><br/>结果如下：<br/><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-791.png"></td><td><code>set autocommit = 0;</code><br/><code>select id,cou_no,cou_name,teach_no from course where id= 1;</code><br/>结果如下：<br/><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-791.png"></td></tr><tr><td>当前<code>session</code> 对<code>id=1</code>的记录加<code>for update</code> 的排他锁。<br/><code>select id,cou_no,cou_name,teach_no from course where id= 1 FOR UPDATE;</code><br/>结果如下：<br/><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-791.png"></td><td></td></tr><tr><td></td><td>其他<code>session</code>可以查询该记录，但是不能对该记录加排他锁，会等待获得锁。<br><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-792.png"></td></tr><tr><td>当前<code>session</code>可以对锁定的记录进行更新操作，更新后释放锁。<br><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-793.png"></td><td></td></tr><tr><td></td><td>其他<code>session</code>获得锁，得到其他session提交的记录。<br><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-794.png"></td></tr></tbody></table><h2 id="InnoDB-行锁实现方式"><a href="#InnoDB-行锁实现方式" class="headerlink" title="InnoDB 行锁实现方式"></a>InnoDB 行锁实现方式</h2><h3 id="行锁及表锁"><a href="#行锁及表锁" class="headerlink" title="行锁及表锁"></a>行锁及表锁</h3><p><strong><code>InnoDB</code>行锁是通过给索引上的索引项加锁来实现的，这一点<code>MySQL</code>与<code>Oracle</code>不同，后者是通过在数据块中对相应数据行加锁来实现的。<code>InnoDB</code>这种行锁实现特点意味着：只有通过索引条件检索数据，<code>InnoDB</code>才使用行级锁，否则，<code>InnoDB</code>将使用表锁！</strong></p><p>在实际应用中，要特别注意<code>InnoDB</code>行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。</p><p>我们通过例子来看一下这一特性。</p><ol><li><p><strong>在不通过索引条件查询的时候，<code>InnoDB</code>使用的是表锁，而不是行锁。</strong></p><p>新建表<code>tab_no_index</code>，没有索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create table tab_no_index(id int,name varchar(10)) engine=innodb; </span><br><span class="line">insert into tab_no_index values(1,&#x27;1&#x27;),(2,&#x27;2&#x27;),(3,&#x27;3&#x27;),(4,&#x27;4&#x27;);  </span><br></pre></td></tr></table></figure><p> <code>InnoDB</code>存储引擎的表在不使用索引时会使用表锁。</p><table><thead><tr><th>session_1</th><th>session_2</th></tr></thead><tbody><tr><td><code>set autocommit=0;</code><br/><code>select * from tab_no_index where id = 1 ;</code><br><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-795.png"></td><td>set autocommit=0;<br/>select * from tab_no_index where id = 2 ;<br><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-796.png"></td></tr><tr><td><code>select * from tab_no_index where id = 1 for update;</code><br><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-797.png"></td><td></td></tr><tr><td></td><td><code>select * from tab_no_index where id = 2 for update;</code><br>会一直等待锁释放<br><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-798.png"></td></tr></tbody></table><p>在如上表所示的例子中，看起来<code>session_1</code>只给<code>id=1</code>这一行加了排他锁，但<code>session_2</code>在请求其他行的排他锁时，却出现了锁等待！</p><p>原因就是在没有索引的情况下，<code>InnoDB</code>只能使用表锁。</p><p>当我们给其增加一个索引后，<code>InnoDB</code>就只锁定了符合条件的行，如下。</p><p>我们使用有索引的一张表<code>tab_with_index</code> 来看下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create table tab_with_index(id int,name varchar(10)) engine=innodb;</span><br><span class="line">alter table tab_with_index add index id(id); </span><br><span class="line">insert into tab_with_index values(1,&#x27;1&#x27;),(2,&#x27;2&#x27;),(3,&#x27;3&#x27;),(4,&#x27;4&#x27;); </span><br></pre></td></tr></table></figure><p> <code>InnoDB</code>存储引擎的表在使用索引时使用行锁。</p><table><thead><tr><th>session_1</th><th>session_2</th></tr></thead><tbody><tr><td><code>set autocommit=0;</code><br/><code>select * from tab_with_index where id = 1 ;</code><br/><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-799.png"></td><td>set autocommit=0;<br/>select * from tab_with_index where id = 2 ;<br/><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-800.png"></td></tr><tr><td><code>select * from tab_with_index where id = 1 for update;</code><br/><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-801.png"></td><td></td></tr><tr><td></td><td><code>select * from tab_with_index where id = 2 for update;</code><br/><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-802.png"></td></tr></tbody></table><p>可以看到 <code>session_2</code>不会出现锁等待的问题。</p></li><li><p><strong>由于<code>MySQL</code>的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的。应用设计的时候要注意这一点。</strong></p><p>上述<code>tab_with_index</code>表中，<code>id</code>字段有索引，<code>name</code>字段没有索引。</p><p>我们再添加一条记录，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into tab_with_index  values(1,&#x27;4&#x27;);</span><br><span class="line">select * from tab_with_index where id = 1; </span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-803.png"></p><p><code>InnoDB</code>存储引擎使用相同索引键获取锁导致阻塞。</p><table><thead><tr><th>session_1</th><th>session_2</th></tr></thead><tbody><tr><td><code>set autocommit=0;</code></td><td><code> set autocommit=0;</code></td></tr><tr><td><code>select * from tab_with_index where id = 1 and name = &#39;1&#39; for update;</code><br><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-804.png"></td><td></td></tr><tr><td></td><td>虽然<code>session_2</code>访问的是和<code>session_1</code>不同的记录，但是因为使用了相同的索引，所以需要等待锁。<br><code>select * from tab_with_index where id = 1 and name = &#39;4&#39; for update;</code><br><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-805.png"></td></tr></tbody></table></li><li><p><strong>当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，<code>InnoDB</code>都会使用行锁来对数据加锁。</strong></p><p>我们对表 <code>tab_with_index</code> 的 <code>name</code>字段添加普通索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table tab_with_index add index name(name); </span><br></pre></td></tr></table></figure><p> <code>InnoDB</code>存储引擎的表使用不同索引锁定不同的行。</p><table><thead><tr><th>session_1</th><th>session_2</th></tr></thead><tbody><tr><td><code>set autocommit=0;</code></td><td><code>set autocommit=0;</code></td></tr><tr><td><code>select * from tab_with_index where id = 1 for update;</code><br><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-806.png"></td><td></td></tr><tr><td></td><td><code>session_2</code>使用<code>name</code>的索引访问记录，因为记录没有被索引，所以可以获得锁。<br><code>select * from tab_with_index where name = &#39;2&#39; for update;</code><br><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-807.png"></td></tr><tr><td></td><td><code>select * from tab_with_index where name = &#39;4&#39; for update;</code><br>由于访问的记录已经被<code>session_1</code>锁定，所以等待获得锁。<br><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-808.png"></td></tr></tbody></table></li><li><p><strong>即便在条件中使用了索引字段，但是否使用索引来检索数据是由<code>MySQL</code>通过判断不同执行计划的代价来决定的，如果<code>MySQL</code>认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下<code>InnoDB</code>将使用表锁，而不是行锁。因此，在分析锁冲突时，别忘了检查<code>SQL</code>的执行计划，以确认是否真正使用了索引。</strong></p><p>在下面的例子中，检索值的数据类型与索引字段不同，虽然<code>MySQL</code>能够进行数据类型转换，但却不会使用索引，从而导致<code>InnoDB</code>使用表锁。通过用<code>explain</code>检查两条<code>SQL</code>的执行计划，我们可以清楚地看到了这一点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN select * from tab_with_index where name = &#x27;1&#x27;;</span><br></pre></td></tr></table></figure><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-809.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN select * from tab_with_index where name = 1;</span><br></pre></td></tr></table></figure><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-810.png"></p><p>可以看到第二条语句没有使用到索引，即会触发<code>MySQL</code>的行锁。</p><table><thead><tr><th>session_1</th><th>session_2</th></tr></thead><tbody><tr><td><code>set autocommit=0;</code></td><td><code>set autocommit=0;</code></td></tr><tr><td><code>select * from tab_with_index where name = 1 for update;</code><br>该语句不走<code>name</code>索引，<code>InnoDB</code>会使用表锁<br><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-811.png"></td><td></td></tr><tr><td></td><td><code>select * from tab_with_index where name = &#39;2&#39; for update;</code><br>我们此时<code>session_2</code>访问其他记录，也会进入锁等待。<br><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-812.png"></td></tr></tbody></table></li></ol><h3 id="间隙锁（Next-Key锁）"><a href="#间隙锁（Next-Key锁）" class="headerlink" title="间隙锁（Next-Key锁）"></a>间隙锁（Next-Key锁）</h3><p><strong>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，<code>InnoDB</code>会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，<code>InnoDB</code>也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。</strong></p><p>比如对于上述<code>tab_with_index</code>例子中，我们执行如下<code>SQL</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tab_with_index where id &gt;=4 for update;</span><br></pre></td></tr></table></figure><p>可以看到只能查到一条<code>id=4</code>的记录，但是事务情况下，我们向表中插入<code>id=5</code>的数据时，就会出现锁等待。</p><p>InnoDB存储引擎的间隙锁情况。</p><table><thead><tr><th>session_1</th><th>session_2</th></tr></thead><tbody><tr><td><code>set autocommit = 0;</code></td><td><code>set autocommit = 0;</code></td></tr><tr><td><code>select * from tab_with_index where id &gt;=4 for update;</code><br><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-813.png"></td><td></td></tr><tr><td></td><td><code>insert into tab_with_index  values(1,&#39;100&#39;);</code><br>我们向表中插入<code>id&lt;4</code>的数据，可以成功处理，可以说明不是表锁。<br><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-814.png"></td></tr><tr><td></td><td><code>insert into tab_with_index  values(5,&#39;5&#39;);</code><br>我们向表中插入<code>id&gt;=4</code>的数据，比如<code>id=5</code>，这个id不存在，但是也会等待<code>session_1</code>释放锁，出现锁等待。<br><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-815.png"></td></tr></tbody></table><p>可以看到，上述<code>SQL</code>是一个范围查找，不仅会对符合条件的记录加锁（id=4），也会对符合条件但不存在的记录加锁（id &gt;=5）。</p><p><code>InnoDB</code>使用间隙锁的目的，一方面是为了防止幻读，以满足相关隔离级别的要求，对于上面的例子，要是不使用间隙锁，如果其它事务插入了<code>id</code>大于4的任何记录，那么本事务如果再次执行上述语句，就会发生幻读；另外一方面，是为了满足其恢复和复制的需要。</p><p>很显然，在使用范围条件检索并锁定记录时，<code>InnoDB</code>这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。因此，在实际应用开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。</p><p>还要特别说明的是，<code>InnoDB</code>除了通过范围条件加锁时使用间隙锁外，如果使用相等条件请求给一个不存在的记录加锁，<code>InnoDB</code>也会使用间隙锁！</p><h2 id="恢复和复制对InnoDB锁机制的影响"><a href="#恢复和复制对InnoDB锁机制的影响" class="headerlink" title="恢复和复制对InnoDB锁机制的影响"></a>恢复和复制对InnoDB锁机制的影响</h2><p><code>MySQL</code>通过<code>BINLOG</code>记录执行成功的<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>等更新数据的<code>SQL</code>语句，并由此实现<code>MySQL</code>数据库的恢复和主从复制。<code>MySQL</code>的恢复机制（复制其实就是在<code>Slave Mysql</code>不断做基于<code>BINLOG</code>的恢复）有以下特点。</p><ul><li><p> 一是<code>MySQL</code>的恢复是<code>SQL</code>语句级的，也就是重新执行<code>BINLOG</code>中的<code>SQL</code>语句。这与<code>Oracle</code>数据库不同，<code>Oracle</code>是基于数据库文件块的。</p></li><li><p>二是<code>MySQL</code>的<code>BINLOG</code>是按照事务提交的先后顺序记录的，恢复也是按这个顺序进行的。这点也与<code>Oralce</code>不同，<code>Oracle</code>是按照系统更新号（System Change Number，SCN）来恢复数据的，每个事务开始时，<code>Oracle</code>都会分配一个全局唯一的<code>SCN</code>，<code>SCN</code>的顺序与事务开始的时间顺序是一致的。</p></li></ul><p>从上面两点可知，<code>MySQL</code>的恢复机制要求：在一个事务未提交前，其他并发事务不能插入满足其锁定条件的任何记录，也就是不允许出现幻读，这已经超过了<code>ISO/ANSI SQL92</code> “可重复读”隔离级别的要求，实际上是要求事务要串行化。这也是许多情况下，<code>InnoDB</code>要用到间隙锁的原因，比如在用范围条件更新记录时，无论在<code>Read Commited</code>或是<code>Repeatable Read</code>隔离级别下，<code>InnoDB</code>都要使用间隙锁，但这并不是隔离级别要求的。</p><p>另外，对于以下语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into target_tab select * from source_tab where ...</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table new_tab ...select ... from source_tab where ...</span><br></pre></td></tr></table></figure><p>这种<code>SQL</code>语句，用户并没有对<code>source_tab</code>做任何更新操作，但<code>MySQL</code>对这种<code>SQL</code>语句做了特别处理。</p><p>我们来看下下面这个例子。</p><p>我们创建两张一样的表<code>source_tab</code>和 <code>target_tab</code> ，并向<code>source_tab</code>里添加一些数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `source_tab` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(50) DEFAULT NULL,</span><br><span class="line">  `sex` char(1) NOT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br><span class="line">CREATE TABLE `target_tab` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(50) DEFAULT NULL,</span><br><span class="line">  `sex` char(1) NOT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br><span class="line">INSERT INTO `source_tab` (`id`, `name`, `sex`) VALUES (&#x27;1&#x27;, &#x27;1&#x27;, &#x27;1&#x27;);</span><br><span class="line">INSERT INTO `source_tab` (`id`, `name`, `sex`) VALUES (&#x27;2&#x27;, &#x27;2&#x27;, &#x27;0&#x27;);</span><br><span class="line">INSERT INTO `source_tab` (`id`, `name`, `sex`) VALUES (&#x27;3&#x27;, &#x27;3&#x27;, &#x27;1&#x27;);</span><br><span class="line">INSERT INTO `source_tab` (`id`, `name`, `sex`) VALUES (&#x27;4&#x27;, &#x27;4&#x27;, &#x27;0&#x27;);</span><br></pre></td></tr></table></figure><table><thead><tr><th>session_1</th><th>session_2</th></tr></thead><tbody><tr><td><code>set autocommit = 0;</code><br/><code>select * from target_tab;</code><br/><code>select * from source_tab where sex = &#39;0&#39;;</code><br><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-816.png"></td><td><code>set autocommit = 0;</code><br/><code>select * from target_tab;</code><br/><code>select * from source_tab where sex = &#39;0&#39;;</code><br/><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-816.png"></td></tr><tr><td><code>insert into target_tab select id,name,sex from source_tab where sex = &#39;0&#39;;</code><br><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-817.png"></td><td></td></tr><tr><td></td><td><code>update source_tab set name = &#39;1&#39; where sex = &#39;1&#39;;</code><br>会一直等待。<br><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-818.png"></td></tr><tr><td><code>commit;</code></td><td></td></tr><tr><td></td><td><code>session_1</code>事务提交后<code>session_2</code>事务执行成功。<br><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-819.png"></td></tr><tr><td></td><td><code>commit;</code></td></tr></tbody></table><p>在上面的例子中，只是简单地读 <code>source_tab</code>表的数据，相当于执行一个普通的<code>SELECT</code>语句，用一致性读就可以了。<code>ORACLE</code>正是这么做的，它通过<code>MVCC</code>技术实现的多版本数据来实现一致性读，不需要给<code>source_tab</code>加任何锁。我们知道<code>InnoDB</code>也实现了多版本数据，对普通的<code>SELECT</code>一致性读，也不需要加任何锁；但这里<code>InnoDB</code>却给<code>source_tab</code>加了共享锁，并没有使用多版本数据一致性读技术！</p><p><code>MySQL</code>为什么要这么做呢？其原因还是为了保证恢复和复制的正确性。因为不加锁的话，如果在上述语句执行过程中，其他事务对<code>source_tab</code>做了更新操作，就可能导致数据恢复的结果错误。</p><p><code>INSERT...SELECT...</code>和 <code>CREATE TABLE...SELECT...</code>语句，可能会阻止对源表的并发更新，造成对源表锁的等待。如果查询比较复杂的话，会造成严重的性能问题，我们在应用中应尽量避免使用。实际上，<code>MySQL</code>将这种<code>SQL</code>叫作不确定（<code>non-deterministic</code>）的<code>SQL</code>，不推荐使用。</p><p>如果应用中一定要用这种<code>SQL</code>来实现业务逻辑，又不希望对源表的并发更新产生影响，可以采取以下两种措施：</p><ul><li>一是将<code>innodb_locks_unsafe_for_binlog</code>的值设置为<code>on</code>，强制<code>MySQL</code>使用多版本数据一致性读。但付出的代价是可能无法用<code>binlog</code>正确地恢复或复制数据，因此，不推荐使用这种方式。</li><li>二是通过使用<code>select * from source_tab ... Into outfile</code>和<code>load data infile ...</code>语句组合来间接实现，采用这种方式<code>MySQL</code>不会给<code>source_tab</code>加锁。</li></ul><h2 id="InnoDB在不同隔离级别下的一致性读及锁的差异"><a href="#InnoDB在不同隔离级别下的一致性读及锁的差异" class="headerlink" title="InnoDB在不同隔离级别下的一致性读及锁的差异"></a>InnoDB在不同隔离级别下的一致性读及锁的差异</h2><p>上面讲过，锁和多版本数据是<code>InnoDB</code>实现一致性读和<code>ISO/ANSI SQL92</code>隔离级别的手段，因此，在不同的隔离级别下，<code>InnoDB</code>处理<code>SQL</code>时采用的一致性读策略和需要的锁是不同的。同时，数据恢复和复制机制的特点，也对一些<code>SQL</code>的一致性读策略和锁策略有很大影响。</p><p>它们如下表所示：</p><table>   <tr>    <th colspan="2">隔离级别  <br>         一致性读和锁   <br>        SQL</th>    <th>Read Uncommited</th>    <th>Read Commited</th>    <th>Repeatable Read</th>    <th>Serializable</th>   </tr>   <tr>    <td>SQL</td>    <td>条件</td>    <td></td>    <td></td>    <td></td>    <td></td>   </tr>   <tr>    <td rowspan="2">select</td>    <td>相等</td>    <td>None locks</td>    <td>Consisten read/None lock</td>    <td>Consisten read/None lock</td>    <td>Share locks</td>   </tr>   <tr>    <td>范围</td>    <td>None locks</td>    <td>Consisten read/None lock</td>    <td>Consisten read/None lock</td>    <td>Share Next-Key</td>   </tr>   <tr>    <td rowspan="2">update</td>    <td>相等</td>    <td>exclusive locks</td>    <td>exclusive locks</td>    <td>exclusive locks</td>    <td>exclusive locks</td>   </tr>   <tr>    <td>范围</td>    <td>exclusive next-key</td>    <td>exclusive next-key</td>    <td>exclusive next-key</td>    <td>exclusive next-key</td>   </tr>   <tr>    <td>insert</td>    <td>N/A</td>    <td>exclusive locks</td>    <td>exclusive locks</td>    <td>exclusive locks</td>    <td>exclusive locks</td>   </tr>   <tr>    <td rowspan="2">replace</td>    <td>无键冲突</td>    <td>exclusive locks</td>    <td>exclusive locks</td>    <td>exclusive locks</td>    <td>exclusive locks</td>   </tr>   <tr>    <td>键冲突</td>    <td>exclusive next-key</td>    <td>exclusive next-key</td>    <td>exclusive next-key</td>    <td>exclusive next-key</td>   </tr>   <tr>    <td rowspan="2">delete</td>    <td>相等</td>    <td>exclusive locks</td>    <td>exclusive locks</td>    <td>exclusive locks</td>    <td>exclusive locks</td>   </tr>   <tr>    <td>范围</td>    <td>exclusive next-key</td>    <td>exclusive next-key</td>    <td>exclusive next-key</td>    <td>exclusive next-key</td>    </tr>    <tr>    <td rowspan="2">select ... from ... Lock in share mode</td>    <td>相等</td>    <td>Share locks</td>    <td>Share locks</td>    <td>Share locks</td>    <td>Share locks</td>   </tr>   <tr>    <td>范围</td>    <td>Share locks</td>    <td>Share locks</td>    <td>Share Next-Key</td>    <td>Share Next-Key</td>    </tr>   <tr>    <td rowspan="2">select * from ... for update</td>    <td>相等</td>    <td>exclusive locks</td>    <td>exclusive locks</td>    <td>exclusive locks</td>    <td>exclusive locks</td>   </tr>   <tr>    <td>范围</td>    <td>exclusive locks</td>    <td>Share locks</td>    <td>exclusive next-key</td>    <td>exclusive next-key</td>    </tr>    <tr>    <td rowspan="2">insert into ... select ...（指源表锁）</td>    <td>innodb_locks_unsafe_for_binlog=off</td>    <td>Share Next-Key</td>    <td>Share Next-Key</td>    <td>Share Next-Key</td>    <td>Share Next-Key</td>   </tr>   <tr>    <td>innodb_locks_unsafe_for_binlog=on</td>    <td>None locks</td>    <td>Consisten read/None lock</td>    <td>Consisten read/None lock</td>    <td>Share Next-Key</td>    </tr>   <tr>    <td rowspan="2">create table ... select ...（指源表锁）</td>    <td>innodb_locks_unsafe_for_binlog=off</td>    <td>Share Next-Key</td>    <td>Share Next-Key</td>    <td>Share Next-Key</td>    <td>Share Next-Key</td>   </tr>   <tr>    <td>innodb_locks_unsafe_for_binlog=on</td>    <td>None locks</td>    <td>Consisten read/None lock</td>    <td>Consisten read/None lock</td>    <td>Share Next-Key</td>   </tr>  </table><p>从上表可以看出：对于许多<code>SQL</code>，隔离级别越高，<code>InnoDB</code>给记录集加的锁就越严格（尤其是使用范围条件的时候），产生锁冲突的可能性也就越高，从而对并发性事务处理性能的影响也就越大。因此，我们在应用中，应该尽量使用较低的隔离级别，以减少锁争用的机率。实际上，通过优化事务逻辑，大部分应用使用<code>Read Commited</code>隔离级别就足够了。对于一些确实需要更高隔离级别的事务，可以通过在程序中执行<code>SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ</code>或<code>SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE</code>动态改变隔离级别的方式满足需求。</p><h2 id="什么时候使用表锁"><a href="#什么时候使用表锁" class="headerlink" title="什么时候使用表锁"></a>什么时候使用表锁</h2><p>对于<code>InnoDB</code>表，在绝大部分情况下都应该使用行级锁，因为事务和行锁往往是我们之所以选择<code>InnoDB</code>表的理由。但在个别特殊事务中，也可以考虑使用表级锁。</p><ul><li>第一种情况是：事务需要更新大部分或全部数据，表又比较大，如果使用默认的行锁，不仅这个事务执行效率低，而且可能造成其他事务长时间锁等待和锁冲突，这种情况下可以考虑使用表锁来提高该事务的执行速度。</li><li>第二种情况是：事务涉及多个表，比较复杂，很可能引起死锁，造成大量事务回滚。这种情况也可以考虑一次性锁定事务涉及的表，从而避免死锁、减少数据库因事务回滚带来的开销。</li></ul><p>当然，应用中这两种事务不能太多，否则，就应该考虑使用<code>MyISAM</code>表了。</p><p>在<code>InnoDB</code>下，使用表锁要注意以下两点。</p><ul><li><p>使用<code>LOCK TABLES</code>虽然可以给<code>InnoDB</code>加表级锁，但必须说明的是，表锁不是由<code>InnoDB</code>存储引擎层管理的，而是由其上一层  ──  <code>MySQL Server</code>负责的，仅当<code>autocommit=0</code>、<code>innodb_table_locks=1</code>（默认设置）时，<code>InnoDB</code>层才能知道<code>MySQL</code>加的表锁，<code>MySQL Server</code>也才能感知<code>InnoDB</code>加的行锁，这种情况下，<code>InnoDB</code>才能自动识别涉及表级锁的死锁；否则，<code>InnoDB</code>将无法自动检测并处理这种死锁。</p></li><li><p>在用 <code>LOCK TABLES</code>对<code>InnoDB</code>表加锁时要注意，要将<code>AUTOCOMMIT</code>设为<code>0</code>，否则<code>MySQL</code>不会给表加锁；事务结束前，不要用<code>UNLOCK TABLES</code>释放表锁，因为<code>UNLOCK TABLES</code>会隐含地提交事务；<code>COMMIT</code>或<code>ROLLBACK</code>并不能释放用<code>LOCK TABLES</code>加的表级锁，必须用<code>UNLOCK TABLES</code>释放表锁。正确的方式见如下语句：</p></li></ul><p>例如，如果需要写表<code>t1</code>并从表<code>t</code>读，可以按如下做：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. SET AUTOCOMMIT=0; </span><br><span class="line">2. LOCK TABLES t1 WRITE, t2 READ, ...; </span><br><span class="line">3. [do something with tables t1 and t2 here]; </span><br><span class="line">4. COMMIT; </span><br><span class="line">5. UNLOCK TABLES; </span><br></pre></td></tr></table></figure><h2 id="关于死锁"><a href="#关于死锁" class="headerlink" title="关于死锁"></a>关于死锁</h2><p><code>MyISAM</code>表锁是<code>deadlock free</code>的，这是因为<code>MyISAM</code>总是一次获得所需的全部锁，要么全部满足，要么等待，因此不会出现死锁。但在<code>InnoDB</code>中，除单个<code>SQL</code>组成的事务外，锁是逐步获得的，这就决定了在<code>InnoDB</code>中发生死锁是可能的。如下所示的就是一个发生死锁的例子。</p><table><thead><tr><th>session_1</th><th>session_2</th></tr></thead><tbody><tr><td><code>set autocommit = 0;</code><br><code>select * from table_1 where where id=1 for update;</code><br>– 做一些其他处理…</td><td><code>set autocommit = 0;</code><br/><code>select * from table_2 where where id=1 for update;</code><br/></td></tr><tr><td><code>select * from table_2 where id =1 for update;</code><br>因<code>session_2</code>已取得<code>table_2</code>的排他锁，等待</td><td>做一些其他处理…</td></tr><tr><td></td><td><code> select * from table_1 where where id=1 for update;</code><br><code>session_2</code>想取得<code>table_1</code>的排他锁，但因<code>session_1</code>已取得<code>table_1</code>的排他锁，导致互相等待，造成死锁</td></tr></tbody></table><p>在上面的例子中，两个事务都需要获得对方持有的排他锁才能继续完成事务，这种循环锁等待就是典型的死锁。</p><p>发生死锁后，<code>InnoDB</code>一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及表锁的情况下，<code>InnoDB</code>并不能完全自动检测到死锁，这需要通过设置锁等待超时参数 <code>innodb_lock_wait_timeout</code>来解决。需要说明的是，这个参数并不是只用来解决死锁问题，在并发访问比较高的情况下，如果大量事务因无法立即获得所需的锁而挂起，会占用大量计算机资源，造成严重性能问题，甚至拖跨数据库。我们通过设置合适的锁等待超时阈值，可以避免这种情况发生。</p><p>通常来说，死锁都是应用设计的问题，通过调整业务流程、数据库对象设计、事务大小，以及访问数据库的<code>SQL</code>语句，绝大部分死锁都可以避免。下面就通过实例来介绍几种避免死锁的常用方法。</p><ol><li><strong>在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会。</strong></li><li><strong>在程序以批量方式处理数据的时候，如果事先对数据排序，保证每个线程按固定的顺序来处理记录，也可以大大降低出现死锁的可能。</strong></li><li><strong>在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应先申请共享锁，更新时再申请排他锁，因为当用户申请排他锁时，其他事务可能又已经获得了相同记录的共享锁，从而造成锁冲突，甚至死锁。</strong></li><li><strong>在<code>REPEATABLE-READ</code>隔离级别下，如果两个线程同时对相同条件记录用SELECT…FOR UPDATE加排他锁，在没有符合该条件记录情况下，两个线程都会加锁成功。程序发现记录尚不存在，就试图插入一条新记录，如果两个线程都这么做，就会出现死锁。这种情况下，将隔离级别改成<code>READ COMMITTED</code>，就可避免问题。</strong></li><li><strong>当隔离级别为<code>READ COMMITTED</code>时，如果两个线程都先执行<code>SELECT...FOR UPDATE</code>，判断是否存在符合条件的记录，如果没有，就插入记录。此时，只有一个线程能插入成功，另一个线程会出现锁等待，当第1个线程提交后，第2个线程会因主键重出错，但虽然这个线程出错了，却会获得一个排他锁！这时如果有第3个线程又来申请排他锁，也会出现死锁。对于这种情况，可以直接做插入操作，然后再捕获主键重复异常，或者在遇到主键重复错误时，总是执行<code>ROLLBACK</code>释放获得的排他锁。</strong></li></ol><p>尽管通过上面介绍的设计和<code>SQL</code>优化等措施，可以大大减少死锁，但死锁很难完全避免。因此，在程序设计中总是捕获并处理死锁异常是一个很好的编程习惯。</p><p>如果出现死锁，可以用<code>show engine innodb status</code>命令来确定最后一个死锁产生的原因。返回结果中包括死锁相关事务的详细信息，如引发死锁的<code>SQL</code>语句，事务已经获得的锁，正在等待什么锁，以及被回滚的事务等。据此可以分析死锁产生的原因和改进措施。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是关于<code>MySQL</code> <code>InnoDB</code> 存储引擎及锁的一些内容。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/mysteryhaohao/article/details/51669741">MySQL学习之——锁(行锁、表锁、页锁、乐观锁、悲观锁等)</a></p>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天我们来看下&lt;code&gt;Mysql&lt;/code&gt;中锁相关的一些内容。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h1&gt;&lt;h2 id=&quot;简单对比&quot;&gt;&lt;a href=&quot;#简单对比&quot; class=&quot;headerlink&quot; title=&quot;简单对比&quot;&gt;&lt;/a&gt;简单对比&lt;/h2&gt;</summary>
    
    
    
    <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="MySQL" scheme="https://www.sakuratears.top/tags/MySQL/"/>
    
    <category term="行锁及表锁" scheme="https://www.sakuratears.top/tags/%E8%A1%8C%E9%94%81%E5%8F%8A%E8%A1%A8%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>不思议迷宫英雄之村1201分享</title>
    <link href="https://www.sakuratears.top/blog/%E4%B8%8D%E6%80%9D%E8%AE%AE%E8%BF%B7%E5%AE%AB%E8%8B%B1%E9%9B%84%E4%B9%8B%E6%9D%911201%E5%88%86%E4%BA%AB.html"/>
    <id>https://www.sakuratears.top/blog/%E4%B8%8D%E6%80%9D%E8%AE%AE%E8%BF%B7%E5%AE%AB%E8%8B%B1%E9%9B%84%E4%B9%8B%E6%9D%911201%E5%88%86%E4%BA%AB.html</id>
    <published>2021-07-17T10:17:00.000Z</published>
    <updated>2021-07-17T10:22:40.347Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上次大号爬完布拉卡达学院1201后，又用小号去了英雄之村，如今终于出图了，特来分享一下爬高流程。</p><p>本次爬高用的深渊系冈，其实我一直比较喜欢用深渊冈爬高的，从低语之森、德古拉城堡到诸神的棋盘，如今加上了今天的英雄之村。</p><p>其实深渊爬高还是比较看机制的，目前爬高也没太多较好的套路，主要以小强和八爪鱼为主。</p><p>希望自己以后能再找到一些适合深渊的爬高套路吧。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>好了，扯了较多题外话，我们来看下英雄之村1201的攻略、要点及难点吧。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>迷宫：英雄之村（也称猪村）</p><p>阵容：地穴刺客出战链接克苏鲁、黑武士</p><p>药剂：棱光药剂</p><p>神器：菩提佛珠</p><p>称号：冒险系大精灵王、战斗系见习战士1级走重装骑士转镇龙骑士、魔法系走气系传奇、巨龙系亚龙血统只点一级（一般走邪龙）</p><p>挂树：时之术士、特种兵</p><h2 id="简单说明"><a href="#简单说明" class="headerlink" title="简单说明"></a>简单说明</h2><h3 id="主要怪物"><a href="#主要怪物" class="headerlink" title="主要怪物"></a>主要怪物</h3><ol><li>刺客：4轮主动发动一次4倍攻击，当属最恶心的小怪，优先击杀。</li><li>屠夫：生命值低于50%攻击翻倍，不主动攻击。</li><li>酒鬼：在场时提高屠夫和强盗生命值和攻击，不主动攻击。</li><li>强盗：每死亡一个队友攻击降低（20%），不主动攻击。</li><li>火枪手：每两轮发动一次远程攻击，远程怪。</li><li>Boss：每3轮主动发动一次攻击，3倍伤害，附带2轮燃烧；每有一个小怪死亡，降低20%物理及魔法抗性。</li></ol><h3 id="选择分析"><a href="#选择分析" class="headerlink" title="选择分析"></a>选择分析</h3><ol><li>地穴刺客（小强）：攻击概率释放地刺几率斩杀小怪，过普通层和处理Boss层小怪都有帮助。出战自带尖刺铠甲+20%反伤。</li><li>黑武士：黑暗原力+龙力斩杀稳定带走一个小怪，满能量可以释放两次，优先处理刺客。</li><li>克苏鲁（八爪鱼）：奴役一个小怪10轮，过普通层和Boss层都有帮助。</li><li>野猪：英雄之村特色产物，救下野猪随我们一起战斗，可为冈布奥抵挡大量伤害，用于反伤。</li><li>棱光药剂：+25%反伤。</li><li>菩提佛珠：增加魔法效果及轮数，获得更高的控制技能轮数。</li><li>称号：大精灵王可以提高猪猪的血量（和攻击）及奴役怪的攻击（和血量），而且英雄之村帐篷里有概率遇到铁砧，可以做出龙鳞套及魔导套，因此不需要铸剑师或者铸魔师称号；重装骑士称号+执政官铠甲（+特种兵挂树）远程怪攻击变为1，镇龙骑士称号增加地刺概率，由于需要反伤，见习战士不反击只需1级；魔法系没什么好说的，肯定气传增加魔法效果；需要反伤，亚龙血统降攻只点一级。</li></ol><h2 id="爬高准备"><a href="#爬高准备" class="headerlink" title="爬高准备"></a>爬高准备</h2><ol><li>在60层之前凑齐龙鳞套魔导套（包括1张大地回退）：龙鳞和魔导优先级没要求，觉得打怪吃力可以优先龙鳞，缺卷轴可以优先魔导。10层、20层需要黑龙鳞魔导套件，黑到需要强化1<code>~</code>2次的就行，比如真理套件、暗影套件、恶魔套件…..同时黑帐篷铁砧强化。10层拿2件（大地回退）、20层拿2件（大地回退），30层、40层、50层、60层各一件（保守计算，不考虑商店，实际应该要快）。</li><li>100层左右拿到执政官，因为后面远程怪也难撕了。</li><li>尽快拿到气书、水书、土书，气书要时停，水书要治疗、痊愈和冰锥，土书要石肤、地刺、地震、重力。</li><li>日记和法老面具也有用，能早拿到就早拿到。</li><li>一龙优先龙力，不是建议跳楼重开，尽快龙语（2<code>~</code>3龙），而后优先收藏品时停（阿斯塔纳的时间函数）。</li></ol><h2 id="爬高流程"><a href="#爬高流程" class="headerlink" title="爬高流程"></a>爬高流程</h2><p>手撕到120层左右，根据个人情况而定，有能力的可以多撕10<code>~</code>20层（此时要注意每10层都要带一只猪以防万一）。</p><p><strong>普通层</strong>过法（要点）：</p><ol><li>优先击杀刺客，建议怪物击杀顺序（显形怪）：刺客&gt;钥匙怪&gt;屠夫=酒鬼&gt;强盗&gt;=火枪。</li><li>小强斩杀序列不好可以sl，也可以末日+龙威+奴役过。</li><li>注意需要进boss层需要黑武士满能量（欧皇小强刀刀地刺斩杀忽略），八爪鱼至少能释放一次奴役。</li><li>x8层x9层需要sl猪，注意当前不能有猪，有的话帐篷不会出猪，因此需要提前卖掉。x9层如果有帐篷，看看帐篷位置，小sl调整到可以快速进入，<strong>暂离</strong>锁住帐篷及其位置，而后进入看是不是猪，不是直接大sl。如果x9层没帐篷，直接大sl，直到有帐篷，重复上面操作。</li><li>黑武士技能灵活使用，主要还是用来秒刺客。</li><li>强盗视情况可以最后杀，因为它的特性可以使它的攻击降低到1。</li><li>龙鳞魔导水书（土书、气书）下楼，打小怪时换上法老面具、执政官、第三只手和佛珠。</li></ol><p><strong>Boss层</strong>过法（要点）：</p><ol><li>中期每进入Boss层都需要携带一只崭新的猪猪（120~950 层）。</li><li>龙鳞+魔导+水书（土书、气书）进入Boss层：<ul><li>换上执政官、法老面具、佛珠、日记（气球）；</li><li>A一刀Boss，出一只怪，如果是刺客，黑暗原力，冰锥boss，a刺客（龙力斩杀）；如果是其他，视情况可以用黑暗原力杀，也可以观察一下小强能否斩杀等；</li><li>冰锥boss后，当boss沙漏剩1准备攻击时，如果不处理场上应该有4只小怪（需要至少处理掉一只非强盗怪，否则下一个小怪出不来），而且右边帐篷轮数为5；</li><li>火把烧掉右侧帐篷，boss攻击，猪猪抵挡一轮，治疗（神恩、痊愈）清除燃烧状态；</li><li>A一下小怪或者boss，左侧帐篷出来一只小怪，龙威全体，火把烧掉左侧帐篷；</li><li>杀小怪至场上剩余1只强盗，或者1只强盗1只其它怪。</li><li>上面的这些操作需要在使用两次黑暗原力+概率地刺斩杀做到，同时尽量保证不吃到boss的第二次攻击（没办法可以石肤抗）；</li><li>时停瓦解（发条音乐盒），或者静电瓦解时停（取决于boss剩余攻击轮数），奴役强盗，如果还有一只怪没被击杀（此时boss还有20%双抗），看看强盗是不是A它，如果A它直接龙力带走，需要保证强盗的前1,2次攻击能达到小怪一次（提前击杀小怪，降低双抗，boss受到的伤害更高）。</li><li>也就是需要boss 0抗性吃到11轮伤害或者 10轮强盗伤害（少的话实际上问题不大，可以用反伤补）。</li><li>时间结束最后一轮，换上尖刺铠甲，脱鞋，上石肤，A boss 反伤，boss主动攻击时记得清下燃烧或者重生硬抗。石肤、治疗、瓦解反到boss死即可。</li></ul></li></ol><h2 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h2><ol><li>上述过程只是参考，对于boss层的处理，最终保证在受到boss较少攻击的情况下，击杀 3<code>~</code>4 只小怪（降低boss 60%<code>~</code>80% 双抗），使boss双抗降至 0<code>~</code>20%，同时至少需要剩余1只强盗用来奴役，烧掉两个帐篷。</li><li>强盗有高攻强盗和低攻强盗两种，不幸的是，只能奴役后才能分辨，奴役到高攻强盗，boss层会更好打些。</li><li>普通层帐篷的储物箱里有概率拿到发条音乐盒，群体99轮瓦解，boss层上一个，反伤就不用关心瓦解问题了，强力推荐sl一些（有猪的情况下sl可以排除一个错误选项）。</li><li>中期比较缺的卷轴有治疗、石肤和时停。治疗有痊愈、神恩和十字架代替；石肤有残破的恶徒魂代替（戴法老面具的原因）；时停如果不够只能x5层sl宝箱或者黑收藏品。</li><li>每10层固定消耗一张时停，必须，建议至少有5张时停在身上。（系统卷轴数量可能分类不正确，只留1，2张太危险了！）</li><li>控制卷轴在小强斩杀不给力的情况下也是比较缺的，比较缺的有毁灭（完整的恶徒之魂可以替代），超重力，失明，冰锥……因此尽量魔导下楼。</li><li>水书治疗、冰锥、痊愈有用，土书石肤、地震、重力、地刺有用，而且一般水书容易出治疗，土书容易出石肤，在时停够的情况下，根据石肤和治疗数量调整这两种书下楼。</li><li>各种球不是必须，如果可以拿到气球当然更好。（我爬完1201也没拿到气球的时光沙漏，火球最后一件石板1195层出，暗球最后一件项链1199层出……）</li><li>120~950 层 每打完boss必须换一只猪猪，不然没法反伤。（880层左右boss血量上限，奴役怪攻击越来越高，越来越简单）</li><li>帐篷不想进去清可以用火把，注意控制火把数量，一般boss层需要消耗2个，保持10个以上，正常情况下火把是够用的。</li></ol><h2 id="附上1201登顶图片及视频"><a href="#附上1201登顶图片及视频" class="headerlink" title="附上1201登顶图片及视频"></a>附上1201登顶图片及视频</h2><p><strong>登顶图片</strong></p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/game/pasted-5.jpg"></p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/game/pasted-6.jpg"></p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/game/pasted-7.jpg"></p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/game/pasted-8.jpg"></p><p><strong>登顶视频</strong></p><iframe src="//player.bilibili.com/player.html?aid=546641842&bvid=BV1Gq4y1W7mH&cid=371563905&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本次英雄之村1201爬高也算是我爬的时间比较长的图之一了吧，好的是爬高过程中只经历了一次比较垃圾的活动。</p><p>本人还是比较喜欢玩深渊的，后续也会看看有没有新的爬高套路和思路。</p><p>期待下一次和大家的分享吧~</p>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上次大号爬完布拉卡达学院1201后，又用小号去了英雄之村，如今终于出图了，特来分享一下爬高流程。&lt;/p&gt;
&lt;p&gt;本次爬高用的深渊系冈，其实我一直比较喜欢用深渊冈爬高的，从低语之森、德古拉城堡到诸神的棋盘，如今加上了今天的英雄之村。&lt;/p&gt;
&lt;p&gt;其实深渊爬高还是比较看机制的，目前爬高也没太多较好的套路，主要以小强和八爪鱼为主。&lt;/p&gt;</summary>
    
    
    
    <category term="游戏" scheme="https://www.sakuratears.top/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
    <category term="不思议迷宫" scheme="https://www.sakuratears.top/tags/%E4%B8%8D%E6%80%9D%E8%AE%AE%E8%BF%B7%E5%AE%AB/"/>
    
    <category term="英雄之村" scheme="https://www.sakuratears.top/tags/%E8%8B%B1%E9%9B%84%E4%B9%8B%E6%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>字符串子串搜索算法</title>
    <link href="https://www.sakuratears.top/blog/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%90%E4%B8%B2%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95.html"/>
    <id>https://www.sakuratears.top/blog/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%90%E4%B8%B2%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95.html</id>
    <published>2021-07-05T13:57:00.000Z</published>
    <updated>2021-07-05T14:24:37.250Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如何在一个给定的字符串中搜索子串第一次出现的起始位置？</p><p>今天我们就来看下这个问题，这个问题涉及到的几个算法还是比较有意思的。</p><p>比如对于字符串 “Hello world”，如何知道子串 ”or“ 出现是否匹配？以及第一次出现的位置？</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>话不多说，我们来看下字符串子串搜索涉及到的几种算法。</p><h2 id="暴力搜索（蛮力搜索）法"><a href="#暴力搜索（蛮力搜索）法" class="headerlink" title="暴力搜索（蛮力搜索）法"></a>暴力搜索（蛮力搜索）法</h2><p>根据字面意思也很容易理解，也是我们比较容易想到的一种方法。</p><p>将字符串和子串截成字符，从头开始一个个进行比对，与子串完全相等则匹配成功。</p><p>如下图所示：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-755.png"></p><p>这种方法用 <code>Java</code> 代码表示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Brute</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回第一个匹配的位置</span></span><br><span class="line"><span class="comment">     * 如果不匹配返回 -1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pat</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> txt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search1</span><span class="params">(String pat, String txt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = pat.length();</span><br><span class="line">        <span class="keyword">int</span> n = txt.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - m; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (txt.charAt(i+j) != pat.charAt(j)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到子串匹配，返回位置</span></span><br><span class="line">            <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不匹配</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回第一个匹配的位置</span></span><br><span class="line"><span class="comment">     * 如果不匹配返回 -1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pat</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> txt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search2</span><span class="params">(String pat, String txt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = pat.length();</span><br><span class="line">        <span class="keyword">int</span> n = txt.length();</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n &amp;&amp; j &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (txt.charAt(i) == pat.charAt(j))&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                i -= j;</span><br><span class="line">                j = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == m)&#123;</span><br><span class="line">            <span class="comment">//找到匹配子串</span></span><br><span class="line">            <span class="keyword">return</span> i - m;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//不匹配</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回第一个匹配的位置</span></span><br><span class="line"><span class="comment">     * 如果不匹配返回 -1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pattern</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search3</span><span class="params">(<span class="keyword">char</span>[] pattern, <span class="keyword">char</span>[] text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = pattern.length;</span><br><span class="line">        <span class="keyword">int</span> n = text.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - m; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (text[i+j] != pattern[j]) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == m)&#123;</span><br><span class="line">                <span class="comment">//找到匹配子串</span></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//未找到匹配子串</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回第一个匹配的位置</span></span><br><span class="line"><span class="comment">     * 如果不匹配返回 -1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pattern</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search4</span><span class="params">(<span class="keyword">char</span>[] pattern, <span class="keyword">char</span>[] text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = pattern.length;</span><br><span class="line">        <span class="keyword">int</span> n = text.length;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n &amp;&amp; j &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text[i] == pattern[j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                i -= j;</span><br><span class="line">                j = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == m)&#123;</span><br><span class="line">            <span class="comment">//找到匹配子串</span></span><br><span class="line">            <span class="keyword">return</span> i - m;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//未找到</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String pat = <span class="string">&quot;or&quot;</span>;</span><br><span class="line">        String txt = <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">        <span class="keyword">char</span>[] pattern = pat.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] text    = txt.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> offset1 = search1(pat, txt);</span><br><span class="line">        <span class="keyword">int</span> offset2 = search2(pat, txt);</span><br><span class="line">        <span class="keyword">int</span> offset3 = search3(pattern, text);</span><br><span class="line">        <span class="keyword">int</span> offset4 = search4(pattern, text);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;text:    &quot;</span> + txt);</span><br><span class="line">        System.out.println(<span class="string">&quot;pattern: &quot;</span> + pat);</span><br><span class="line"></span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;search1是否匹配：%s ，匹配位置：%s&quot;</span>,offset1!=-<span class="number">1</span>?<span class="string">&quot;是&quot;</span>:<span class="string">&quot;否&quot;</span>,offset1));</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;search2是否匹配：%s ，匹配位置：%s&quot;</span>,offset2!=-<span class="number">1</span>?<span class="string">&quot;是&quot;</span>:<span class="string">&quot;否&quot;</span>,offset2));</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;search3是否匹配：%s ，匹配位置：%s&quot;</span>,offset3!=-<span class="number">1</span>?<span class="string">&quot;是&quot;</span>:<span class="string">&quot;否&quot;</span>,offset3));</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;search4是否匹配：%s ，匹配位置：%s&quot;</span>,offset4!=-<span class="number">1</span>?<span class="string">&quot;是&quot;</span>:<span class="string">&quot;否&quot;</span>,offset4));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到如下输出：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-756.png"></p><p>这里大家看下 <code>search1</code> 方法即可， <code>search2</code> 方法是另一种写法， <code>search3</code>是 <code>search1</code> 方法的 <code>char</code> 数组版本， <code>search4</code> 是 <code>search2</code> 方法的 <code>char</code> 数组版本。</p><p>上述代码过程还是比较容易理解的。</p><p>根据上图，其实我们可以知道这种方法匹配的缺点，比如对于一个比较长的模式串，在匹配主字符串时，如果大部分相同，但最后一两个字符不同，下一次匹配时，我们这一次的匹配信息有些部分是可以利用的，这样可以减少我们的比较次数，进而提高效率。</p><p>我们假设字符主串长度为N，模式串长度为M （N&gt;=M）：</p><ul><li>如果匹配字符正好位于字符主串头部，需要比较M次，这是最好情况；</li><li>如果匹配字符位于字符串尾部，且字符主串相似度高，例如“AAAAAAAAAAAAAB”字符串，我们匹配”AB”子串，可以看到需要比较（N-M+1）*M次，这是最坏情况；</li><li>其平均时间复杂度可以记为 O(M*N)</li></ul><h2 id="Rabin-Karp-算法"><a href="#Rabin-Karp-算法" class="headerlink" title="Rabin-Karp 算法"></a>Rabin-Karp 算法</h2><p>这个算法是由Richard M. Karp和Michael O. Rabin在1987年发表，它也是用来解决多模式串匹配问题的。</p><p><strong>基本思想：</strong>长度为M的子串对应着一个<strong>R进制的M位数</strong>。<strong>使用除留余数法构造一个能够将 R 进制的 M 位数转化为一个0到Q-1之间的 int 值的散列函数。</strong>我们在不溢出的情况下选择一个尽可能大的随机<strong>素数</strong>Q（因为我们并不真正需要一张散列表，故Q越大越好，冲突越少）。接下来对文本所有长度为M的子串计算散列值并寻找匹配。</p><p><strong>计算散列函数：</strong>思想很简单，只需将所有子串散列值求出，一个一个匹配即可，但是如果依次计算每个子串的散列值，时间复杂度与 M*N 成正比，故问题变成了如何在线性时间求出散列值。</p><p><strong>关键思想：</strong>既然子串长度确定为M，那我们每次只需向后移动一位，将第一个元素去掉，最后一个元素加上即可更新散列值，再与子串散列值比较即可。在这种情况下时间复杂度与N成正比。</p><p>我们来看下图：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-757.png"></p><p><strong>具体步骤</strong>：</p><ol><li>得到子串长度M；</li><li>选择一个恰当的R，尽可能大的随机素数Q，构造散列函数；</li><li>计算出子串的散列值patHash；</li><li>从文本第一个子串开始，依次向右移动，判断其散列值是否与patHash相等。</li></ol><p>相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabinKarp</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模式串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String pat;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模式串hash值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> patHash;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模式串长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 大素数（用于减少hash冲突，防止hash溢出等）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> q;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基数（char取256）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> R;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  R^(m-1) % q</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> RM;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RabinKarp</span><span class="params">(String pat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pat = pat;</span><br><span class="line">        R = <span class="number">256</span>;</span><br><span class="line">        m = pat.length();</span><br><span class="line">        q = longRandomPrime();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 预计算R^(m-1) % q，用于去掉前导数</span></span><br><span class="line">        RM = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            RM = (R * RM) % q;</span><br><span class="line">        &#125;</span><br><span class="line">        patHash = hash(pat, m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算key的hash值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">hash</span><span class="params">(String key, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            h = (R * h + key.charAt(j)) % q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验是否真正相等，因为可能存在hash冲突</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> txt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(String txt, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pat.charAt(j) != txt.charAt(i + j)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回第一个匹配的位置</span></span><br><span class="line"><span class="comment">     * 如果不匹配返回 -1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> txt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String txt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = txt.length();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; m) &#123;</span><br><span class="line">            <span class="comment">//待匹配子串长度不能比字符主串长</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">long</span> txtHash = hash(txt, m);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 快速校验0位置子串是否匹配</span></span><br><span class="line">        <span class="keyword">if</span> ((patHash == txtHash) &amp;&amp; check(txt, <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 校验字符串是否匹配，如果hash值相等，还要字符串是否真实相等</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//删除前导数，添加尾导数，继续验证</span></span><br><span class="line">            txtHash = (txtHash + q - RM*txt.charAt(i-m) % q) % q;</span><br><span class="line">            txtHash = (txtHash*R + txt.charAt(i)) % q;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 找到匹配位置</span></span><br><span class="line">            <span class="keyword">int</span> offset = i - m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> ((patHash == txtHash) &amp;&amp; check(txt, offset)) &#123;</span><br><span class="line">                <span class="keyword">return</span> offset;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不匹配返回 -1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 随机一个31位的大素数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">longRandomPrime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BigInteger prime = BigInteger.probablePrime(<span class="number">31</span>, <span class="keyword">new</span> Random());</span><br><span class="line">        <span class="keyword">return</span> prime.longValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String pat = <span class="string">&quot;wor&quot;</span>;</span><br><span class="line">        String txt = <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">        RabinKarp rabinKarp = <span class="keyword">new</span> RabinKarp(pat);</span><br><span class="line">        <span class="keyword">int</span> offset = rabinKarp.search(txt);</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;search是否匹配：%s ，匹配位置：%s&quot;</span>,offset!=-<span class="number">1</span>?<span class="string">&quot;是&quot;</span>:<span class="string">&quot;否&quot;</span>,offset));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们假设字符主串长度为N，模式串长度为M （N&gt;=M）：</p><ul><li>最坏情况，我们需要滑动 （N-M+1）个窗口进行匹配，复杂度为O(N)；</li><li>开始时计算子串的hash值，复杂度为O(M);</li><li>hash 值比较时由于为数字比较，复杂度为O(1)；注：Hash冲突应尽量低。</li><li>因此总的复杂度为O(N+M)。</li></ul><p><strong>备注</strong>：</p><p>上述代码可能部分同学不明白，我们来举个简单例子：</p><p>比如说字符串 12345 ，模式串 345 ，为方便理解，我们暂时不考虑取余素数部分，即越界或冲突问题。</p><p>这儿由于是数字，我们可以设定 R 基数为 10（十进制，0-9只有数字，方便理解），根据上面的 hash 公式，可以得到 345 的 hash为 345，123的hash值为123。</p><p>其实上述 hash 计算过程大致如下：<br>$$<br>Hash(345)=3\ast,10^{3-1}+4\ast,10^{3-2}+5\ast,10^0<br>$$</p><p>假设字符主串长度为 <code>n</code>，表示为 <code>t[0,n-1]</code> ; 模式串长度为<code>m</code> ，表示为 <code>p[0,m-1]</code>。</p><p>则有<br>$$<br>Hash(t[0, m-1])=t[0]\ast,R^{m-1}+t[1]\ast,R^{m-2}+…+t[m-1]\ast,R^0<br>$$</p><p>因此上述这部分代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RM = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m-<span class="number">1</span>; i++) &#123;</span><br><span class="line">    RM = (R * RM) % q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>预计算RM也非常好理解，我们在这个例子里面可以算出 m=3 时它是100（其实就是最前面那一位数字的“位置”，可以明白如果要配2345，此时m=4，那么RM=1000）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">txtHash = (txtHash + q - RM*txt.charAt(i-m) % q) % q;</span><br><span class="line">txtHash = (txtHash*R + txt.charAt(i)) % q;</span><br></pre></td></tr></table></figure><p>这两段代码的意思就是：<br>$$<br>Hash(temp)=Hash(123) - 100\ast,1<br>$$</p><p>$$<br>Hash(234)=Hash(temp)*10 + 4<br>$$</p><h2 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h2><h3 id="KMP算法核心内容"><a href="#KMP算法核心内容" class="headerlink" title="KMP算法核心内容"></a>KMP算法核心内容</h3><p>Knuth-Morris-Pratt 算法（简称 KMP）是由高德纳（Donald Ervin Knuth）和沃恩·普拉特在 1974 年构思，同年詹姆斯·H·莫里斯也独立地设计出该算法，最终三人于 1977 年联合发表一种解决字符串模式匹配的算法。</p><p>假设m为模式串strM的长度，n为字符主串strN的长度，则 KMP 算法的时间复杂度记为 <em>O(m+n)</em></p><p>在讲算法之前，我们先来了解两个概念，即<strong>一个字符串除本身的全部前缀和全部后缀</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">字符串：Hello</span><br><span class="line">除本身的全部前缀：H、He、Hel、Hell</span><br><span class="line">除本身的全部后缀：ello、llo、lo、o</span><br></pre></td></tr></table></figure><p>假设我们有一个字符串 “BBC ABCDAB ABCDABCDABDE” ，模式串 “ABCDABD”。</p><p>如果我们按照暴力搜索法应该如何匹配呢？</p><p>肯定是如下过程：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-758.png"></p><p>上述过程我们可以发现，在（图5）比较到最后发现<code>T[10]</code>与<code>P[6]</code>不匹配时，我们其实不用从头让<code>T[5]</code>与<code>P[0]</code>再进行匹配 （图6）。</p><p>因为在图5中，<code>T[5]</code>和<code>P[1]</code>已经比较过相等，而根据模式串，我们明显知道<code>P[0]≠P[1]</code>，即 <code>T[5]≠P[0]</code>。</p><p>由上面也可以得出 <code>T[6]≠P[0]</code>,<code>T[7]≠P[0]</code>。</p><p>我们可以将模式串移动到如下位置：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-759.png"></p><p>然后继续匹配，同理，会发现<code>T[10]≠P[2],此时会移动到如下位置：</code></p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-760.png"></p><p>因为图8匹配中知道了<code>T[9]=P[1]≠P[0]</code>，因此图9匹配时<code>T[9]</code>和<code>P[0]</code>就没必要对比了。</p><p>后面的图10，图11，图12，我不用说大家也应该明白了。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-761.png"></p><p>上述我们说到的过程就是KMP算法的关键。</p><p>相比于暴力查找算法，这种算法关键是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。</p><p>正如上述所说，匹配失败后，如何知道下次匹配要从哪儿开始正是KMP算法的关键。</p><p>KMP算法主要有三个步骤：</p><ol><li>寻找待匹配串的每个子串前缀和后缀最长公共元素长度；</li><li>求next数组；</li><li>根据next数组进行匹配；</li></ol><p>其中的 next 数组相当于告诉我们：当待匹配串中的某个字符跟文本串中的某个字符匹配失配时，待匹配串下一步应该跳到哪个位置。</p><p>我们以上述例子结合步骤来看一下。</p><p><strong>一、 寻找待匹配串的每个子串前缀和后缀最长公共元素长度</strong></p><p>结合开头我们所说，待匹配串 “ABCDABD” 的各个子串的前缀后缀及公共元素如下表：</p><table><thead><tr><th>待匹配串的全部子串</th><th>前缀</th><th>后缀</th><th>最大公共元素长度</th></tr></thead><tbody><tr><td>A</td><td></td><td></td><td>0</td></tr><tr><td>AB</td><td>A</td><td>B</td><td>0</td></tr><tr><td>ABC</td><td>A，AB</td><td>BC，C</td><td>0</td></tr><tr><td>ABCD</td><td>A，AB，ABC</td><td>BCD，CD，D</td><td>0</td></tr><tr><td>ABCDA</td><td><font color=red>A</font>，AB，ABC，ABCD</td><td>BCDA，CDA，DA，<font color=red>A</font></td><td>1</td></tr><tr><td>ABCDAB</td><td>A，<font color=red>AB</font>，ABC，ABCD，ABCDA</td><td>BCDAB，CDAB，DAB，<font color=red>AB</font>，B</td><td>2</td></tr><tr><td>ABCDABD</td><td>A，AB，ABC，ABCD，ABCDA，ABCDAB</td><td>BCDABD，CDABD，DABD，ABD，BD，D</td><td>0</td></tr></tbody></table><p>也就是说，模式串子串对应的各个前缀后缀的公共元素的最大长度表为：</p><table><thead><tr><th>字符</th><th>A</th><th>B</th><th>C</th><th>D</th><th>A</th><th>B</th><th>D</th></tr></thead><tbody><tr><td>前缀后缀最大公共元素长度</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>2</td><td>0</td></tr></tbody></table><p><strong>二、求next数组</strong></p><p>因为待匹配串的子串中首尾可能会有重复的字符，故可得出下述结论：</p><blockquote><p>匹配失败时，待匹配串向右移动的位数为：已匹配字符数 - 失败匹配字符的上一位字符所对应的最大公共元素长度值</p></blockquote><p>上述图5中，D 匹配失败，即<code> T[10]</code> 和<code> P[6]</code> 不匹配，则待匹配串需要向右移动位数 = 6 - 2 = 4 。</p><p>可以看到待匹配串移动4位正好是图8的结果。</p><p>在进一步，我们可以发现，当匹配到一个字符不匹配配时，其实没必要考虑当前不匹配配的字符，我们每次不匹配时，都是看的不匹配字符的上一位字符对应的最大公共元素长度值。如此，便引出了next 数组。</p><p>如下：</p><table><thead><tr><th>字符</th><th>A</th><th>B</th><th>C</th><th>D</th><th>A</th><th>B</th><th>D</th></tr></thead><tbody><tr><td>前缀后缀最大公共元素长度</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>2</td><td>0</td></tr><tr><td>next数组</td><td>-1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>2</td></tr></tbody></table><p>结合上表我们不难发现 next 数组相当于“前缀后缀最大公共元素长度” 整体向右移动一位，然后初始值赋为-1。</p><blockquote><p> 不匹配时，待匹配串向右移动的位数为：不匹配字符所在位置- 不匹配字符对应的next 值</p></blockquote><p>我们来分析一下正确性：</p><ul><li><p>当 A 不匹配时，不匹配字符所在位置- 不匹配字符对应的next 值 = 0 - （-1）=1，向右移动一位，如图1。</p></li><li><p>当 AB 的B不匹配时，不匹配字符所在位置- 不匹配字符对应的next 值 = 1 - 0 =1，向右移动一位。</p></li><li><p>当 ABC 的 C 不匹配时，不匹配字符所在位置- 不匹配字符对应的next 值 = 2 - 0 =2，向右移动二位，如图8。</p></li><li><p>当 ABCD 的 D 不匹配时，不匹配字符所在位置- 不匹配字符对应的next 值 = 3 - 0 =3，向右移动三位。</p></li><li><p>当 ABCDA 的 末位A 不匹配时，不匹配字符所在位置- 不匹配字符对应的next 值 = 4 - 0 =4，向右移动四位。</p></li><li><p>当 ABCDAB 的 末位B 不匹配时，不匹配字符所在位置- 不匹配字符对应的next 值 = 5 - 1 =4，向右移动四位。</p></li><li><p>当 ABCDABD 的 末位D 不匹配时，不匹配字符所在位置- 不匹配字符对应的next 值 = 6 - 2 =4，向右移动四位，如图11。</p></li></ul><p>我们可以写出获取 next 数组的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getNext</span><span class="params">(String pattern)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = pattern.length();</span><br><span class="line">    <span class="keyword">char</span>[] p = pattern.toCharArray();</span><br><span class="line">    <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> k = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; p.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//p[k]表示前缀，p[j]表示后缀</span></span><br><span class="line">        <span class="keyword">if</span> (k == -<span class="number">1</span> || p[k] == p[j]) &#123;</span><br><span class="line">            <span class="comment">//即当p[k] == p[j]时，next[j+1] == next[j] + 1=k+1</span></span><br><span class="line">            next[++j] = ++k;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;next[&quot;</span> + i + <span class="string">&quot;] = &quot;</span> + next[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的 KMP 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KMPNext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String pattern;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KMPNext</span><span class="params">(String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pattern = pattern;</span><br><span class="line">        <span class="keyword">int</span> m = pattern.length();</span><br><span class="line">        <span class="keyword">char</span>[] p = pattern.toCharArray();</span><br><span class="line">        next = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">        next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> k = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; p.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//p[k]表示前缀，p[j]表示后缀</span></span><br><span class="line">            <span class="keyword">if</span> (k == -<span class="number">1</span> || p[k] == p[j]) &#123;</span><br><span class="line">                <span class="comment">//即当p[k] == p[j]时，next[j+1] == next[j] + 1=k+1</span></span><br><span class="line">                next[++j] = ++k;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                k = next[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;next[&quot;</span> + i + <span class="string">&quot;] = &quot;</span> + next[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回第一个匹配的位置</span></span><br><span class="line"><span class="comment">     * 如果不匹配返回 -1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = pattern.length();</span><br><span class="line">        <span class="keyword">int</span> n = text.length();</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n &amp;&amp; j &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; text.charAt(i) != pattern.charAt(j)) &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">            <span class="keyword">return</span> i - m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String pat = <span class="string">&quot;ABCDABD&quot;</span>;</span><br><span class="line">        String txt = <span class="string">&quot;BBC ABCDAB ABCDABCDABDE&quot;</span>;</span><br><span class="line"></span><br><span class="line">        KMPNext pplus = <span class="keyword">new</span> KMPNext(pat);</span><br><span class="line">        <span class="keyword">int</span> offset = pplus.search(txt);</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;search是否匹配：%s ，匹配位置：%s&quot;</span>,offset!=-<span class="number">1</span>?<span class="string">&quot;是&quot;</span>:<span class="string">&quot;否&quot;</span>,offset));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KMP-算法的优化"><a href="#KMP-算法的优化" class="headerlink" title="KMP 算法的优化"></a>KMP 算法的优化</h3><p>我们还以模式串为 “ABCDABD” 为例，我们假设字符主串为 “ABCDACDDAB ABCDABCDABDE”。</p><p>如下图13：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-762.png"></p><p>则我们按照匹配逻辑，开始时依次比较<code> T[0]</code>与<code>P[0]</code>，<code>T[1]</code>与<code>P[1]</code>……</p><p>比较到<code>T[5]</code>与<code>P[5]</code>，发现两者不匹配。</p><p>根据我们上面的KMP算法，我们需要将模式串移动（不匹配字符所在位置- 不匹配字符对应的next 值）=5-1 =4</p><p>即如下图14所示:</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-763.png"></p><p>这时候我们再进行匹配， <code>T[5]</code>和<code>P[1]</code>必然不匹配。为什么呢？</p><p>在图13中，我们已经知道 <code>T[5]≠P[5]</code>，而我们知道 <code>P[1]=P[5]</code>，因此<code>T[5]≠P[1]</code>。这些信息在图13匹配时就可以得到，没必要在图14在进行一次匹配！</p><p>问题出在 <code>P[5]</code> 不应该等于 <code>P[next[5]]=P[2]</code>，即不应该出现<code>P[j]=P[next[j]]</code>。</p><p>我们来分析一下：</p><p>当<code>P[j]≠T[i]</code>时，下次匹配必然是<code>P[next [j]]</code> 跟<code>T[i]</code>匹配（为方便理解，可以把j=5，i=5，结合图13，14理解）,如果<code>P[j] = P[next[j]]</code>，必然导致后一步匹配失败。</p><p>如果出现了<code>p[j] = p[next[j]]</code>，则我们需要再次递归，即令<code>next[j] = next[next[j]]</code>。</p><p>如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getNext1</span><span class="params">(String pattern)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] p = pattern.toCharArray();</span><br><span class="line">    <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[p.length];</span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> k = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; p.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//p[k]表示前缀，p[j]表示后缀</span></span><br><span class="line">        <span class="keyword">if</span> (k == -<span class="number">1</span> || p[j] == p[k]) &#123;</span><br><span class="line">            <span class="comment">//较之前next数组求法，改动如下</span></span><br><span class="line">            <span class="keyword">if</span> (p[++j] == p[++k]) &#123;</span><br><span class="line">                <span class="comment">// 当两个字符相等时要跳过</span></span><br><span class="line">                next[j]=next[k];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//之前只有这一行</span></span><br><span class="line">                next[j]=k;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            k = next[k];</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; p.length; s++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;next[&quot;</span> + s + <span class="string">&quot;] = &quot;</span> + next[s]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到优化后的next数组如下：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-764.png"></p><p>优化后的完整的KMP代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KMPNextPlus</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String pattern;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KMPNextPlus</span><span class="params">(String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pattern = pattern;</span><br><span class="line">        <span class="keyword">char</span>[] p = pattern.toCharArray();</span><br><span class="line">        next = <span class="keyword">new</span> <span class="keyword">int</span>[p.length];</span><br><span class="line">        next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> k = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; p.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//p[k]表示前缀，p[j]表示后缀</span></span><br><span class="line">            <span class="keyword">if</span> (k == -<span class="number">1</span> || p[j] == p[k]) &#123;</span><br><span class="line">                <span class="comment">//较之前next数组求法，改动如下</span></span><br><span class="line">                <span class="keyword">if</span> (p[++j] == p[++k]) &#123;</span><br><span class="line">                    <span class="comment">// 当两个字符相等时要跳过</span></span><br><span class="line">                    next[j]=next[k];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//之前只有这一行</span></span><br><span class="line">                    next[j]=k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                k = next[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; p.length; s++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;next[&quot;</span> + s + <span class="string">&quot;] = &quot;</span> + next[s]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回第一个匹配的位置</span></span><br><span class="line"><span class="comment">     * 如果不匹配返回 -1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = pattern.length();</span><br><span class="line">        <span class="keyword">int</span> n = text.length();</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n &amp;&amp; j &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; text.charAt(i) != pattern.charAt(j)) &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">            <span class="keyword">return</span> i - m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String pat = <span class="string">&quot;ABCDABD&quot;</span>;</span><br><span class="line">        String txt = <span class="string">&quot;BBC ABCDAB ABCDABCDABDE&quot;</span>;</span><br><span class="line"></span><br><span class="line">        KMPNextPlus pplus = <span class="keyword">new</span> KMPNextPlus(pat);</span><br><span class="line">        <span class="keyword">int</span> offset = pplus.search(txt);</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;search是否匹配：%s ，匹配位置：%s&quot;</span>,offset!=-<span class="number">1</span>?<span class="string">&quot;是&quot;</span>:<span class="string">&quot;否&quot;</span>,offset));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KMP算法的DFA版本"><a href="#KMP算法的DFA版本" class="headerlink" title="KMP算法的DFA版本"></a>KMP算法的DFA版本</h3><p>KMP算法还有使用DFA数组来处理的版本。这儿我没过多研究，仅附上代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KMP</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> R;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 待匹配子串长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] dfa;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KMP</span><span class="params">(String pat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.R = <span class="number">256</span>;</span><br><span class="line">        <span class="keyword">this</span>.m = pat.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建DFA用于匹配</span></span><br><span class="line">        dfa = <span class="keyword">new</span> <span class="keyword">int</span>[R][m];</span><br><span class="line">        dfa[pat.charAt(<span class="number">0</span>)][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>, j = <span class="number">1</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; R; c++) &#123;</span><br><span class="line">                <span class="comment">//复制不匹配的情况</span></span><br><span class="line">                dfa[c][j] = dfa[c][x];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//设置匹配的情况</span></span><br><span class="line">            dfa[pat.charAt(j)][j] = j+<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//更新状态</span></span><br><span class="line">            x = dfa[pat.charAt(j)][x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KMP</span><span class="params">(<span class="keyword">char</span>[] pattern, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.R = R;</span><br><span class="line">        <span class="keyword">this</span>.m = pattern.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建DFA用于匹配</span></span><br><span class="line">        <span class="keyword">int</span> m = pattern.length;</span><br><span class="line">        dfa = <span class="keyword">new</span> <span class="keyword">int</span>[R][m];</span><br><span class="line">        dfa[pattern[<span class="number">0</span>]][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>, j = <span class="number">1</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; R; c++) &#123;</span><br><span class="line">                dfa[c][j] = dfa[c][x];</span><br><span class="line">            &#125;</span><br><span class="line">            dfa[pattern[j]][j] = j+<span class="number">1</span>;</span><br><span class="line">            x = dfa[pattern[j]][x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回第一个匹配的位置</span></span><br><span class="line"><span class="comment">     * 如果不匹配返回 -1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> txt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String txt)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = txt.length();</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n &amp;&amp; j &lt; m; i++) &#123;</span><br><span class="line">            j = dfa[txt.charAt(i)][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">            <span class="comment">//找到匹配位置</span></span><br><span class="line">            <span class="keyword">return</span> i - m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//未找到</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回第一个匹配的位置</span></span><br><span class="line"><span class="comment">     * 如果不匹配返回 -1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">char</span>[] text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = text.length;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n &amp;&amp; j &lt; m; i++) &#123;</span><br><span class="line">            j = dfa[text[i]][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == m)&#123;</span><br><span class="line">            <span class="keyword">return</span> i - m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String pat = <span class="string">&quot;word&quot;</span>;</span><br><span class="line">        String txt = <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">        KMP kmp = <span class="keyword">new</span> KMP(pat);</span><br><span class="line">        <span class="keyword">int</span> offset = kmp.search(txt);</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;search是否匹配：%s ，匹配位置：%s&quot;</span>,offset!=-<span class="number">1</span>?<span class="string">&quot;是&quot;</span>:<span class="string">&quot;否&quot;</span>,offset));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Boyer-Moore-算法"><a href="#Boyer-Moore-算法" class="headerlink" title="Boyer-Moore 算法"></a>Boyer-Moore 算法</h2><h3 id="Boyer-Moore算法原理"><a href="#Boyer-Moore算法原理" class="headerlink" title="Boyer-Moore算法原理"></a>Boyer-Moore算法原理</h3><p>上面我们介绍了KMP算法和Rabin-Karp 算法，但它们并不是效率最高的查找算法。实际采用也不多。</p><p>各种文本编辑器的 “查找” 功能（Ctrl+F），大多采用 Boyer-Moore 算法。Boyer-Moore 算法不仅效率高，而且构思巧妙。</p><p>1977 年，德克萨斯大学的 Robert S. Boyer 教授和 J Strother Moore 教授发明了这种算法。</p><p>假设文本串text长度为n，模式串pattern长度为m，BM算法的主要特征为：</p><ul><li><p>从右往左进行比较匹配（一般的字符串匹配算法如KMP都是从左往右进行匹配）；</p></li><li><p>算法分为两个阶段：预处理阶段和搜索阶段；</p></li><li><p>预处理阶段时间和空间复杂度都是是 O(<em>m</em>+)，是字符集大小，一般为256；</p></li><li><p>搜索阶段时间复杂度是 O(<em>mn</em>)；</p></li><li><p>当模式串是非周期性的，在最坏的情况下算法需要进行 <code>3n</code> 次字符比较操作；</p></li><li><p>算法在最好的情况下达到 O(<em>n</em>/<em>m</em>)，比如在文本串 <code>b</code>中搜索模式串 <code>ab</code> ，只需要 <code>n/m</code> 次比较。</p></li></ul><p>我们来看一下：</p><p>假定字符串为 “HERE IS A SIMPLE EXAMPLE”，搜索词为 “EXAMPLE”。</p><p>首先，搜索词与字符串头部对齐，从尾部开始匹配。</p><p>如下图：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-765.png"></p><p>这是一种非常聪明的想法，这样如果尾字符不匹配，就说明前7个字符（整体）不是要查找的结果。</p><p>我们看到，”S” 与 “E” 不匹配。这时，**”S” 就被称为 “坏字符”（bad character），即不匹配的字符**。</p><p>我们还发现，”S” 不包含在搜索词 “EXAMPLE” 之中，这意味着可以把搜索词直接移到 “S” 的后一位。</p><p>如下图：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-766.png"></p><p>依然从尾部开始比较，发现 “P” 与 “E” 不匹配，所以 “P” 是 “坏字符”。但是，”P” 包含在搜索词 “EXAMPLE” 之中。所以，将搜索词后移两位，两个 “P” 对齐。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-767.png"></p><p>我们由此总结出 <strong>“坏字符规则”：后移位数 = 坏字符的位置 - 搜索词中的上一次出现位置。</strong></p><p>我们约定，如果 “坏字符” 不包含在搜索词之中，则上一次出现位置为 -1。</p><p>举个例子，以前面第三步的 “P” 为例，它作为 “坏字符”，出现在（相对）搜索词的第 6 位，在搜索词中的上一次出现位置为 4，所以后移 6 - 4 = 2 位。再以前面第二步的 “S” 为例，它出现在第 6 位，上一次出现位置是 -1（即未出现），则整个搜索词后移 6 - (-1) = 7 位。</p><p>依然从尾部开始比较，如下图：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-768.png"></p><p>可以看到匹配到 “MPLE” 都是符合的，<strong>我们把这种情况称为 “好后缀”（good suffix），即所有尾部匹配的字符串。</strong>注意，”MPLE”、”PLE”、”LE”、”E” 都是好后缀。</p><p>为了接下来方便说明，在这里作一下区分：<strong>我们统一称 “MPLE”、”PLE”、”LE”、”E” 为 “好后缀”，其中 “MPLE” 为 “最长好后缀”，”PLE”、”LE”、”E” 统一称为 “真好后缀”。</strong></p><p>继续比较。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-769.png"></p><p>发现 “I” 与 “A” 不匹配，所以，”I” 是 “坏字符”。</p><p>根据 “坏字符规则”，此时搜索词应该后移 2 - (-1) = 3 位。问题是，此时有没有更好的移法？</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-770.png"></p><p>在图20中，我们知道此时存在 “好后缀”。</p><p>所以，可以采用 <strong>“好后缀规则”：后移位数 = 好后缀的位置 - 搜索词中的上一次出现位置。</strong></p><p>这个规则有三个注意点：</p><ol><li>“好后缀” 的位置以最后一个字符为准。假定 “ABCDEF” 的 “好后缀” 是 “EF”、”F”，则它的位置以 “F” 为准，即 5（从 0 开始计算）。</li><li>如果 “好后缀” 在搜索词中都只出现一次，则它们的上一次出现位置为 -1。比如，”ABCDEF” 的好后缀是 “EF”、”F”，但它们在 “ABCDEF” 之中都只出现一次，则它们的上一次出现位置为 -1（即未出现）。</li><li>如果有多个 “好后缀” 在搜索词中都出现多次，那我们应该选哪个作为上一次出现的位置呢？我们采取的策略是：先查看 “最长好后缀” 是否也出现多次，如果是，直接选用这个 “最长好后缀” 作为上一次出现的位置；如果不是，则在 “真好后缀” 中选取 “长度最长且也属于前缀” 的那个 “好后缀”。</li></ol><p>举几个例子来具体说明上述的 3 个注意点。</p><ol><li>如果 “ABCDEF” 的 “好后缀” 是 “EF”、”F”。那么 “好后缀” 的位置是 5（从 0 开始计算，取最后的 “F” 的值），观察发现 “好后缀” 只出现一次，则它们的上一次出现位置为 -1，则后移位数为 5 - (-1) = 6；</li><li>如果 “ABEFCDEF” 的 “好后缀” 是 “EF”、”F”。那么 “好后缀” 的位置是 7，观察发现这两个 “好后缀” 都出现多次，则先查看 “最长好后缀(EF)” 是否出现多次，观察发现出现 2 次，所以选用 “EF” 为上一次出现的位置，”EF” 上一次出现的位置为 3，则后移位数为 7 - 3 = 4；</li><li>如果 “EFABCDEF” 的 “好后缀” 是 “CDEF”、”DEF”、”EF”、”F”。那么 “好后缀” 的位置是 7，观察发现有两个 “好后缀” 出现多次，则先查看 “最长好后缀(CDEF)” 是否出现多次，观察发现不是，则在 “真好后缀(DEF、EF、F)” 中选取 “长度最长且也属于前缀” 的那个 “好后缀”，是 “EF”，其上一次出现的位置是 1，则后移位数为 7 - 1 = 6。</li></ol><p>回到当前步骤的这个例子。此时，所有的 “好后缀”（MPLE、PLE、LE、E）之中，只有 “E” 在 “EXAMPLE” 还出现在头部，所以后移 6 - 0 = 6 位。</p><p>如下图，移动到<code>T[15]</code>位置：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-771.png"></p><p>可以看到，”坏字符规则” 只能移 3 位，”好后缀规则” 可以移 6 位。所以，Boyer-Moore 算法的基本思想是，每次后移这两个规则之中的较大值。</p><p>更巧妙的是，这两个规则的移动位数，只与搜索词有关，与原字符串无关。因此，可以预先计算生成《坏字符规则表》和《好后缀规则表》。使用时，只要查表比较一下就可以了。</p><p>继续从尾部开始比较，”P” 与 “E” 不匹配，因此 “P” 是”坏字符”。根据 “坏字符规则”，后移 6 - 4 = 2 位。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-772.png"></p><p>后移后如下图：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-773.png"></p><p>此时继续从尾部开始比较，可以看到已经找到了符合条件的字符串。</p><p>如果还要继续查找（即找出全部匹配），则根据 “好后缀规则”，后移 6 - 0 = 6 位，即头部的 “E” 移到尾部的 “E” 的位置。</p><h3 id="如何求坏字符表和好后缀表"><a href="#如何求坏字符表和好后缀表" class="headerlink" title="如何求坏字符表和好后缀表"></a>如何求坏字符表和好后缀表</h3><h4 id="坏字符算法（Bad-Character）"><a href="#坏字符算法（Bad-Character）" class="headerlink" title="坏字符算法（Bad Character）"></a>坏字符算法（Bad Character）</h4><p>当出现一个坏字符时， BM 算法向右移动搜索词，让搜索词中最靠右的对应字符与坏字符相对，然后继续匹配。坏字符算法有两种情况。</p><ul><li><p><strong>搜索词中有对应的坏字符时，让搜索词中最靠右的对应字符与坏字符相对。</strong></p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-774.png"></p><p>第二个 <code>x</code> 即为移动后的位置。</p></li><li><p><strong>搜索词中不存在坏字符，那就直接右移整个搜索词长度这么大步数。</strong></p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-775.png"></p><p>第二个 <code>x</code> 即为移动后的位置。</p></li></ul><p><strong>代码实现：</strong></p><p>利用哈希空间换时间的思想，使用字符作为下标而不是位置作为下标。这样只需要遍历一遍即可。如果是纯 8 位字符也只需要 256 个空间大小，而且对于大数据，可能本身长度就超过了 256，所以这样做是值得的（这也是为什么数据越大，BM 算法越高效的原因之一）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] buildBadTable(String pattern)&#123;</span><br><span class="line">    <span class="keyword">int</span>[] badTable = <span class="keyword">new</span> <span class="keyword">int</span>[R];</span><br><span class="line">    <span class="keyword">int</span> pLen = pattern.length();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; badTable.length; i++) &#123;</span><br><span class="line">        <span class="comment">//默认初始化全部为匹配字符串长度</span></span><br><span class="line">        badTable[i] = pLen;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pLen - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        badTable[pattern.charAt(i)] = pLen - <span class="number">1</span> - i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> badTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="好后缀算法（Good-Suffix）"><a href="#好后缀算法（Good-Suffix）" class="headerlink" title="好后缀算法（Good Suffix）"></a>好后缀算法（Good Suffix）</h4><p>如果程序匹配了一个 “好后缀”，那就把前面的 “好后缀” 移动到当前 “好后缀” 位置。这样，好后缀算法有三种情况。</p><ul><li><p><strong>搜索词中有子串和 “最长好后缀” 完全匹配，则将最靠右的那个完全匹配的子串移动到 “最长好后缀” 的位置继续进行匹配。</strong></p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-776.png"></p><p>第二个 <code>x</code> 即为移动后的位置。</p></li><li><p><strong>如果不存在和 “最长好后缀” 完全匹配的子串，则选取长度最长且也属于前缀的那个 “真好后缀”。</strong></p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-777.png"></p><p>第二个 <code>x</code> 即为移动后的位置。</p></li><li><p><strong>如果完全不存在和 “好后缀” 匹配的子串，则右移整个搜索词。</strong></p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-778.png"></p><p>第二个 <code>x</code> 即为移动后的位置。</p></li></ul><p><strong>代码实现</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] buildGoodSuffixTable(String pattern)&#123;</span><br><span class="line">    <span class="keyword">int</span> pLen = pattern.length();</span><br><span class="line">    <span class="keyword">int</span>[] goodTable = <span class="keyword">new</span> <span class="keyword">int</span>[pLen];</span><br><span class="line">    <span class="keyword">int</span> lastPrefixPosition = pLen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = pLen - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPrefix(pattern, i + <span class="number">1</span>)) &#123;</span><br><span class="line">            lastPrefixPosition = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        goodTable[pLen - <span class="number">1</span> - i] = lastPrefixPosition - i + pLen - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pLen - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> slen = suffixLength(pattern, i);</span><br><span class="line">        goodTable[slen] = pLen - <span class="number">1</span> - i + slen;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> goodTable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPrefix</span><span class="params">(String pattern, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> patternLength = pattern.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p, j = <span class="number">0</span>; i &lt; patternLength; ++i, ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pattern.charAt(i) != pattern.charAt(j)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">suffixLength</span><span class="params">(String pattern, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pLen = pattern.length();</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p, j = pLen - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; pattern.charAt(i) == pattern.charAt(j); i--, j--) &#123;</span><br><span class="line">        len += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Boyer-Moore算法完整代码"><a href="#Boyer-Moore算法完整代码" class="headerlink" title="Boyer-Moore算法完整代码"></a>Boyer-Moore算法完整代码</h3><p>算法完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoyerMoore</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> R;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 坏字符表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] badTable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 好后缀表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] goodSuffixTable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 待匹配数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] pattern;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 待匹配数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String pat;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BoyerMoore</span><span class="params">(String pat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.R = <span class="number">256</span>;</span><br><span class="line">        <span class="keyword">this</span>.pat = pat;</span><br><span class="line">        <span class="keyword">this</span>.badTable = buildBadTable(pat);</span><br><span class="line">        <span class="keyword">this</span>.goodSuffixTable = buildGoodSuffixTable(pat);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建坏字符匹配数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pattern</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] buildBadTable(String pattern)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] badTable = <span class="keyword">new</span> <span class="keyword">int</span>[R];</span><br><span class="line">        <span class="keyword">int</span> pLen = pattern.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; badTable.length; i++) &#123;</span><br><span class="line">            <span class="comment">//默认初始化全部为匹配字符串长度</span></span><br><span class="line">            badTable[i] = pLen;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pLen - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            badTable[pattern.charAt(i)] = pLen - <span class="number">1</span> - i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> badTable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 好后缀匹配规则数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pattern</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] buildGoodSuffixTable(String pattern)&#123;</span><br><span class="line">        <span class="keyword">int</span> pLen = pattern.length();</span><br><span class="line">        <span class="keyword">int</span>[] goodTable = <span class="keyword">new</span> <span class="keyword">int</span>[pLen];</span><br><span class="line">        <span class="keyword">int</span> lastPrefixPosition = pLen;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pLen - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrefix(pattern, i + <span class="number">1</span>)) &#123;</span><br><span class="line">                lastPrefixPosition = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            goodTable[pLen - <span class="number">1</span> - i] = lastPrefixPosition - i + pLen - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pLen - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> slen = suffixLength(pattern, i);</span><br><span class="line">            goodTable[slen] = pLen - <span class="number">1</span> - i + slen;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> goodTable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前缀匹配</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pattern</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPrefix</span><span class="params">(String pattern, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> patternLength = pattern.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = p, j = <span class="number">0</span>; i &lt; patternLength; ++i, ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pattern.charAt(i) != pattern.charAt(j)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后缀匹配</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pattern</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">suffixLength</span><span class="params">(String pattern, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pLen = pattern.length();</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = p, j = pLen - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; pattern.charAt(i) == pattern.charAt(j); i--, j--) &#123;</span><br><span class="line">            len += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回第一个匹配的位置</span></span><br><span class="line"><span class="comment">     * 如果不匹配返回 -1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> txt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String txt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tLen = txt.length();</span><br><span class="line">        <span class="keyword">int</span> pLen = pat.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pLen &gt; tLen) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pLen - <span class="number">1</span>, j; i &lt; tLen;) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;跳跃位置：&quot;</span> + i);</span><br><span class="line">            <span class="keyword">for</span> (j = pLen - <span class="number">1</span>; txt.charAt(i) == pat.charAt(j); i--, j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;匹配成功，位置：&quot;</span> + i);</span><br><span class="line"><span class="comment">//i++;   // 多次匹配</span></span><br><span class="line"><span class="comment">//break;</span></span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//跳跃值取两者里面的最大值</span></span><br><span class="line">            i += Math.max(goodSuffixTable[pLen - j - <span class="number">1</span>], badTable[txt.charAt(i)]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String pat = <span class="string">&quot;EXAMPLE&quot;</span>;</span><br><span class="line">        String txt = <span class="string">&quot;HERE IS A SIMPLE EXAMPLE&quot;</span>;</span><br><span class="line"></span><br><span class="line">        BoyerMoore boyerMoore = <span class="keyword">new</span> BoyerMoore(pat);</span><br><span class="line">        <span class="keyword">int</span> offset = boyerMoore.search(txt);</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;search是否匹配：%s ，匹配位置：%s&quot;</span>,offset!=-<span class="number">1</span>?<span class="string">&quot;是&quot;</span>:<span class="string">&quot;否&quot;</span>,offset));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据测试结果如下：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-779.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是关于字符串子串搜索算法的全部内容，内容还是比较多的，里面我们介绍了4种算法，每种算法都有各自的特点。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><p><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html">字符串匹配的KMP算法</a></p></li><li><p><a href="http://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html">字符串匹配的Boyer-Moore算法</a></p></li><li><p><a href="https://algs4.cs.princeton.edu/53substring/">Substring Search</a></p></li><li><p><a href="https://ethsonliu.com/2019/11/boyer-moore.html">Boyer-Moore 算法</a></p></li><li><p><a href="https://ethsonliu.com/2018/04/kmp.html">KMP 算法</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;如何在一个给定的字符串中搜索子串第一次出现的起始位置？&lt;/p&gt;
&lt;p&gt;今天我们就来看下这个问题，这个问题涉及到的几个算法还是比较有意思的。&lt;/p&gt;
&lt;p&gt;比如对于字符串 “Hello world”，如何知道子串 ”or“ 出现是否匹配？以及第一次出现的位置？&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="字符串搜索算法" scheme="https://www.sakuratears.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
    
    <category term="KMP" scheme="https://www.sakuratears.top/tags/KMP/"/>
    
    <category term="Rabin-Karp" scheme="https://www.sakuratears.top/tags/Rabin-Karp/"/>
    
    <category term="Boyer-Moore" scheme="https://www.sakuratears.top/tags/Boyer-Moore/"/>
    
  </entry>
  
  <entry>
    <title>Java 锁相关问题</title>
    <link href="https://www.sakuratears.top/blog/Java-%E9%94%81%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98.html"/>
    <id>https://www.sakuratears.top/blog/Java-%E9%94%81%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98.html</id>
    <published>2021-06-27T11:15:00.000Z</published>
    <updated>2021-07-11T08:22:09.199Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近总结了 Java 锁的一些相关问题，整理如下，希望对自己和大家的学习略有帮助。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>可重入锁通俗来说是<strong>当线程请求一个由其它线程持有的对象锁时，该线程会阻塞，而当线程请求由自己持有的对象锁时，如果该锁是可重入锁，请求就会成功，否则阻塞</strong>。</p><p>我们可以根据一个简单例子来看下。</p><p>这儿我们首先构造一个不可重入锁，也就是当该线程持有锁后，再进来获取锁的线程（包括自己）都会失败（或者等待锁释放）。</p><p>这儿我们用等待来模拟，便于更直观了解不可重入锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isLocked = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(isLocked)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;等待Thread：&quot;</span>+Thread.currentThread().getId()+<span class="string">&quot;释放锁&quot;</span>);</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        isLocked = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        isLocked = <span class="keyword">false</span>;</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码可以看到，当一个线程拿到锁后，另外线程（包括自己）在获得锁时需要等待当前线程释放锁。</p><p>我们写个测试类来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line">    MyLock lock = <span class="keyword">new</span> MyLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread:&quot;</span>+Thread.currentThread().getId()+<span class="string">&quot; 尝试加锁&quot;</span>);</span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread:&quot;</span>+Thread.currentThread().getId()+<span class="string">&quot; 加锁成功&quot;</span>);</span><br><span class="line">        doSomethingAgain();</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread:&quot;</span>+Thread.currentThread().getId()+<span class="string">&quot; 尝试解锁&quot;</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread:&quot;</span>+Thread.currentThread().getId()+<span class="string">&quot; 解锁成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSomethingAgain</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread:&quot;</span>+Thread.currentThread().getId()+<span class="string">&quot; 尝试加锁&quot;</span>);</span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread:&quot;</span>+Thread.currentThread().getId()+<span class="string">&quot; 加锁成功&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;do Something&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread:&quot;</span>+Thread.currentThread().getId()+<span class="string">&quot; 尝试解锁&quot;</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread:&quot;</span>+Thread.currentThread().getId()+<span class="string">&quot; 解锁成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        LockTest test = <span class="keyword">new</span> LockTest();</span><br><span class="line">        test.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述测试代码的意思是一个线程加锁后，在用该线程去尝试获取锁（可重入）。</p><p>可以看到如下输出：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-749.png"></p><p>而后该段程序会卡住（死锁），因为自己拿到锁还未释放，不能再去获取锁。</p><p>我们知道 Java 中的 <code>ReentrantLock</code> 是可重入锁，我们用它来替换我们的 <code>MyLock</code> 再来测试一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br></pre></td></tr></table></figure><p>可以看到当前线程是可以重入的。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-750.png"></p><h2 id="synchronized-是不是可重入锁"><a href="#synchronized-是不是可重入锁" class="headerlink" title="synchronized 是不是可重入锁"></a>synchronized 是不是可重入锁</h2><p>根据上面定义，我们简单来找个例子验证下即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> <span class="keyword">extends</span> <span class="title">MySynchronized</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ThreadId:&quot;</span>+Thread.currentThread().getId());</span><br><span class="line">        doSomethingAgain();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSomethingAgain</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.superDoSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynchronizedTest test = <span class="keyword">new</span> SynchronizedTest();</span><br><span class="line">        System.out.println(<span class="string">&quot;ThreadId:&quot;</span>+Thread.currentThread().getId());</span><br><span class="line">        test.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySynchronized</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">superDoSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ThreadId:&quot;</span>+Thread.currentThread().getId());</span><br><span class="line">        System.out.println(<span class="string">&quot;do Something&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到如下输出：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-751.png"></p><p>说明 <code>synchronized</code> 是<strong>可重入</strong>的。</p><p>关于更多 <code>synchronized</code> 内容请看这篇文章 <a href="http://www.sakuratears.top/blog/Java-synchronized%E9%94%81%E6%9C%BA%E5%88%B6.html">Java synchronized锁机制</a> .</p><h2 id="ReentrantLock-可重入实现"><a href="#ReentrantLock-可重入实现" class="headerlink" title="ReentrantLock 可重入实现"></a>ReentrantLock 可重入实现</h2><p><code>ReentrantLock</code> 底层是根据一个状态 <code>state</code> 参数来控制可重入的，默认为0，加锁后状态会变更。</p><ol><li><p>一个线程尝试获取锁时，判断 <code>state</code> 是不是0，如果是0，表示没锁，就尝试获取锁；</p></li><li><p>如果不是0，判断是不是当前线程持有的改锁，是的话就改变 <code>state</code>状态（可重入）；</p></li><li><p>如果不是当前线程，说明其他线程正在持有锁，返回加锁失败（或者根据等待时间尝试等待锁释放）。</p></li></ol><p><strong>注意</strong>，这儿有以下几点要注意：</p><ul><li>重入是有次数限制的，根据代码来看，最大值为 Integer 最大值。</li></ul><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-752.png"></p><ul><li><code>ReentrantLock</code> 内部实现了公平锁和非公平锁两种。非公平锁就是线程自由尝试抢占锁；公平锁会有一个线程队列，获取锁时根据队列里数据的先后顺序尝试获取锁。</li></ul><p>更多详细内容可以参考这篇文章 <a href="https://www.sakuratears.top/blog/%E8%B0%88%E8%B0%88ReentrantLock.html">ReentrantLock那些事</a> 。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h3><p>死锁指的是多个线程因竞争资源而造成的一种僵局（相互等待），若无外部作用，这些线程将一直这样下去。</p><h3 id="死锁的必要条件"><a href="#死锁的必要条件" class="headerlink" title="死锁的必要条件"></a>死锁的必要条件</h3><ul><li>互斥条件：指的是资源在一定时间内只能由一个线程占有并使用。如果有其他线程请求该资源，需要等待。</li><li>不剥夺条件：指的是当前线程在未使用完资源之前，不会被其他线程剥夺，资源只能由自己释放。</li><li>请求和保持条件：指的是线程1至少已经占用了一个资源，比如A，又提出了新的资源B请求，而此时资源B已被线程2占用，此时请求会被阻塞，线程1此时不会释放资源A。</li><li>循环等待条件：存在一种线程资源的循环等待链，链中每一个线程已获得的资源同时被链中下一个线程所请求。</li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>我们来看一个死锁的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object o2 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> type;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeadLock</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DeadLock thread1 = <span class="keyword">new</span> DeadLock(<span class="number">0</span>);</span><br><span class="line">        DeadLock thread2 = <span class="keyword">new</span> DeadLock(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(thread1).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(thread2).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">if</span>(type == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o1)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">1000</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;doSomethingWith O1&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (o2)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;doSomethingWith O2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o2)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">1000</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;doSomethingWith O2&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (o1)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;doSomethingWith O1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码很好理解：我们根据 <code>type</code>参数来决定先锁定 <code>o1</code>还是<code>o2</code>，然后启动两个线程，一个先锁定  <code>o1</code>，一个先锁定 <code>o2</code>，而后就会出现死锁。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-753.png"></p><h3 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h3><ol><li><p><strong>破坏占用并等待（加锁全部所需资源）</strong></p><p>即线程启动时就拿到所有需要的资源；或者线程启动拿到初步启动所需的资源，后续再逐步释放已有的资源，申请需要的资源。</p></li><li><p><strong>不可强占资源（锁应有超时时间）</strong></p><p>即当一个已经持有了一些资源的进程在提出新的资源请求没有得到满足时，等待一定时间后它必须释放已经保持的所有资源，待以后需要使用的时候再重新申请。这就意味着进程已占有的资源会被短暂地释放或者说是被抢占了。</p></li><li><p><strong>破坏循环等待条件（按照一定顺序加锁）</strong></p><p>可以通过定义资源类型的线性顺序来预防，比如可将每个资源编号，当一个进程占有编号为 <code>i</code>的资源时，那么它下一次申请资源只能申请编号大于<code>i</code>的资源。</p></li></ol><p>比如上面的例子，我们改成线程池访问模式，将 <code>main</code> 方法内容改造如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> type = random.nextInt(<span class="number">2</span>);</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> DeadLock(type));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到会出现死锁，这种情况我们可以使用单一线程池来处理，相当于我们上面说的 1. 加锁全部所需资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ThreadFactory namedThreadFactory = <span class="keyword">new</span> ThreadFactoryBuilder()</span><br><span class="line">    .setNameFormat(<span class="string">&quot;demo-pool-%d&quot;</span>).build();</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> ExecutorService executorService =</span><br><span class="line">    <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">5L</span>, TimeUnit.SECONDS,</span><br><span class="line">                           <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">100</span>),namedThreadFactory,<span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> type = random.nextInt(<span class="number">2</span>);</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> DeadLock(type));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下输出：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-754.png"></p><p>可以看到不会出现死锁情况。</p><h3 id="死锁定位分析解决"><a href="#死锁定位分析解决" class="headerlink" title="死锁定位分析解决"></a>死锁定位分析解决</h3><p>主要有三步：</p><ol><li><code>jps</code>命令定位进程号；</li><li><code>jstack</code>找到死锁查看；</li><li>解决死锁问题。</li></ol><p><code>jps</code> 是 <code>java</code> 提供的一个显示当前所有 <code>java</code> 进程 <code>pid</code>的命令。</p><p>比如上述线程池死锁的例子，我们使用 <code>jps</code> 来看下。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-780.png"></p><p>而后我们可以使用 <code>jstack</code> 查看 死锁情况。</p><p>注：这里我们只看 2780 进程，其他的也可以使用 <code>jstack</code> 看，可以发现是没有死锁信息的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack 2780</span><br></pre></td></tr></table></figure><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-781.png"></p><p>如上图，可以看到可以找到死锁信息。</p><p>而后就是解决死锁，快速方法是保留死锁信息后，找到其中一个死锁资源占用线程杀掉，但死锁的出现一般都是程序问题，需要认真分析程序出现死锁的情况并解决掉。</p><h2 id="Synchronized和CAS区别"><a href="#Synchronized和CAS区别" class="headerlink" title="Synchronized和CAS区别"></a>Synchronized和CAS区别</h2><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><code>CAS</code> 采用的是一种乐观锁机制。它是使用硬件特性来保证原子性。在底层调用<code>unsafe.compareAndSwapObject</code>方法实现原子操作，当然该方法内部也是一个硬件加锁的操作。流程就是该方法会指定要修改的对象、对象的现有值和修改值。如果对象实际值跟指定现有值一致，就用修改值替换现有值。如果正在被其他线程加锁就返回修改失败。然后会有自旋检查，循环执行该原子操作，直到获取锁并执行成功。如果不限制执行次数，可能会造成死循环。</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点</strong></p><ol><li>不用阻塞线程，并让线程在用户态和内核态直接切换，省去切换的时间，一次阻塞和唤醒操作就需要两次切换。</li></ol><p><strong>缺点</strong></p><ol><li>如果锁一直被其他线程占用，并且自旋操作没有设置最大次数，就会造成死循环，造成 <code>CPU</code> 占用过高。</li><li>只能保证某一个对象的原子性，并不能保证几个对象或一个线程同步操作。</li></ol><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p><code>java.util.concurrent</code>下的很多类，比如 <code>Atomic</code>开头的原子操作变量，<code>ReentrantLock</code>，都是根据 <code>CAS</code> 实现的。</p><h4 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h4><ol><li><a href="https://www.sakuratears.top/blog/CAS%E8%AF%A6%E8%A7%A3.html">CAS详解</a></li></ol><h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p><code>synchronized</code> 采用的是 <code>CPU</code>的悲观锁机制。<br>即线程获得的是独占锁，意味着其他线程只能依靠阻塞等待线程释放锁。在 <code>CPU</code> 进行转换线程阻塞会引起线程上下文的切换，如果线程很多发生竞争的时候，<code>CPU</code>来回上下文切换会导致效率很低。在 <code>Java 1.6</code>对 <code>synchronized</code> 进行了优化，锁的状态：无锁，偏向锁，轻量级锁，重量级锁。但是最后转变为重量级锁，性能依然很低。</p><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点</strong></p><ol><li>在并发非常高的情况下，<code>CAS</code> 操作失败率会非常高，这时候可以采用 <code>synchronized</code>.</li><li>由于优化后的 <code>synchronized</code> 引入偏向锁、轻量锁（<code>CAS</code>、自旋）等，而且可以通过参数灵活控制偏向锁开启与否，轻量锁的最大自旋次数等参数，导致 <code>synchronized</code> 可以根据并发情况及特点灵活参数配置，适应范围更广。</li></ol><p><strong>缺点</strong></p><ol><li>升级为重量锁后，阻塞（挂起线程/恢复线程）需要转入内核态完成，性能很低。</li></ol><h4 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h4><p>太多了，略。</p><h4 id="学习资料-1"><a href="#学习资料-1" class="headerlink" title="学习资料"></a>学习资料</h4><ol><li><a href="https://www.sakuratears.top/blog/Java-synchronized%E9%94%81%E6%9C%BA%E5%88%B6.html">Java synchronized锁机制</a></li></ol><h3 id="区别总结"><a href="#区别总结" class="headerlink" title="区别总结"></a>区别总结</h3><ol><li><code>CAS</code> 是乐观锁，<code>synchronized</code> 可以称得上是悲观锁。</li><li>优化后的 <code>synchronized</code> 的轻量锁部分类似于 <code>CAS</code>（其中也使用到了 <code>CAS</code>）。</li><li><code>synchronized</code> 会有一个锁升级的过程，且不可逆，也有设置偏向锁、轻量锁及自旋次数等配置参数；<code>CAS</code>正常只需要指定自旋次数。</li><li><code>CAS</code> 操作不会阻塞线程，但使用不当会造成 <code>CPU</code>资源浪费；<code>synchronized</code> 升级为重量锁后会阻塞线程，导致性能降低。</li><li>并发不高的情况下可以考虑使用 <code>CAS</code>；当数据并发量很高，应当考虑使用 <code>synchronized</code>。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过上述文章，我们了解到了 Java 中关于锁的一些内容。</p>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近总结了 Java 锁的一些相关问题，整理如下，希望对自己和大家的学习略有帮助。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h1&gt;&lt;h2 id=&quot;可重入锁&quot;&gt;&lt;a href=&quot;#可重入锁&quot; class=&quot;headerlink&quot; title=&quot;可重入锁&quot;&gt;&lt;/a&gt;可重入锁&lt;/h2&gt;</summary>
    
    
    
    <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="CAS" scheme="https://www.sakuratears.top/tags/CAS/"/>
    
    <category term="锁" scheme="https://www.sakuratears.top/tags/%E9%94%81/"/>
    
    <category term="Synchronized" scheme="https://www.sakuratears.top/tags/Synchronized/"/>
    
    <category term="死锁" scheme="https://www.sakuratears.top/tags/%E6%AD%BB%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch学习笔记（9）</title>
    <link href="https://www.sakuratears.top/blog/Elasticsearch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%889%EF%BC%89.html"/>
    <id>https://www.sakuratears.top/blog/Elasticsearch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%889%EF%BC%89.html</id>
    <published>2021-06-20T14:03:00.000Z</published>
    <updated>2021-06-20T14:04:29.375Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Elasticsearch-映射参数"><a href="#Elasticsearch-映射参数" class="headerlink" title="Elasticsearch 映射参数"></a>Elasticsearch 映射参数</h2><h3 id="analyzer"><a href="#analyzer" class="headerlink" title="analyzer"></a>analyzer</h3><p>定义文本字段的分词器，默认对索引和查询都是有效的。</p><p>假设不用分词器，我们先来看一下索引的结果，创建一个索引并添加一个文档。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT blog</span><br><span class="line"></span><br><span class="line">PUT blog/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;:&quot;定义文本字段的分词器，默认对索引和查询都是有效的。&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看词条向量（term vectors）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET blog/_termvectors/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;fields&quot;: [&quot;title&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看结果如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;blog&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;found&quot;</span> : <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;took&quot;</span> : <span class="number">124</span>,</span><br><span class="line">  <span class="attr">&quot;term_vectors&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;title&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;field_statistics&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;sum_doc_freq&quot;</span> : <span class="number">22</span>,</span><br><span class="line">        <span class="attr">&quot;doc_count&quot;</span> : <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;sum_ttf&quot;</span> : <span class="number">23</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;terms&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;义&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;term_freq&quot;</span> : <span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;position&quot;</span> : <span class="number">1</span>,</span><br><span class="line">              <span class="attr">&quot;start_offset&quot;</span> : <span class="number">1</span>,</span><br><span class="line">              <span class="attr">&quot;end_offset&quot;</span> : <span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;分&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;term_freq&quot;</span> : <span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;position&quot;</span> : <span class="number">7</span>,</span><br><span class="line">              <span class="attr">&quot;start_offset&quot;</span> : <span class="number">7</span>,</span><br><span class="line">              <span class="attr">&quot;end_offset&quot;</span> : <span class="number">8</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;和&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;term_freq&quot;</span> : <span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;position&quot;</span> : <span class="number">15</span>,</span><br><span class="line">              <span class="attr">&quot;start_offset&quot;</span> : <span class="number">16</span>,</span><br><span class="line">              <span class="attr">&quot;end_offset&quot;</span> : <span class="number">17</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;器&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;term_freq&quot;</span> : <span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;position&quot;</span> : <span class="number">9</span>,</span><br><span class="line">              <span class="attr">&quot;start_offset&quot;</span> : <span class="number">9</span>,</span><br><span class="line">              <span class="attr">&quot;end_offset&quot;</span> : <span class="number">10</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;字&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;term_freq&quot;</span> : <span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;position&quot;</span> : <span class="number">4</span>,</span><br><span class="line">              <span class="attr">&quot;start_offset&quot;</span> : <span class="number">4</span>,</span><br><span class="line">              <span class="attr">&quot;end_offset&quot;</span> : <span class="number">5</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;定&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;term_freq&quot;</span> : <span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;position&quot;</span> : <span class="number">0</span>,</span><br><span class="line">              <span class="attr">&quot;start_offset&quot;</span> : <span class="number">0</span>,</span><br><span class="line">              <span class="attr">&quot;end_offset&quot;</span> : <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;对&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;term_freq&quot;</span> : <span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;position&quot;</span> : <span class="number">12</span>,</span><br><span class="line">              <span class="attr">&quot;start_offset&quot;</span> : <span class="number">13</span>,</span><br><span class="line">              <span class="attr">&quot;end_offset&quot;</span> : <span class="number">14</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;引&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;term_freq&quot;</span> : <span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;position&quot;</span> : <span class="number">14</span>,</span><br><span class="line">              <span class="attr">&quot;start_offset&quot;</span> : <span class="number">15</span>,</span><br><span class="line">              <span class="attr">&quot;end_offset&quot;</span> : <span class="number">16</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;效&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;term_freq&quot;</span> : <span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;position&quot;</span> : <span class="number">21</span>,</span><br><span class="line">              <span class="attr">&quot;start_offset&quot;</span> : <span class="number">22</span>,</span><br><span class="line">              <span class="attr">&quot;end_offset&quot;</span> : <span class="number">23</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;文&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;term_freq&quot;</span> : <span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;position&quot;</span> : <span class="number">2</span>,</span><br><span class="line">              <span class="attr">&quot;start_offset&quot;</span> : <span class="number">2</span>,</span><br><span class="line">              <span class="attr">&quot;end_offset&quot;</span> : <span class="number">3</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;是&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;term_freq&quot;</span> : <span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;position&quot;</span> : <span class="number">19</span>,</span><br><span class="line">              <span class="attr">&quot;start_offset&quot;</span> : <span class="number">20</span>,</span><br><span class="line">              <span class="attr">&quot;end_offset&quot;</span> : <span class="number">21</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;有&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;term_freq&quot;</span> : <span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;position&quot;</span> : <span class="number">20</span>,</span><br><span class="line">              <span class="attr">&quot;start_offset&quot;</span> : <span class="number">21</span>,</span><br><span class="line">              <span class="attr">&quot;end_offset&quot;</span> : <span class="number">22</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;本&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;term_freq&quot;</span> : <span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;position&quot;</span> : <span class="number">3</span>,</span><br><span class="line">              <span class="attr">&quot;start_offset&quot;</span> : <span class="number">3</span>,</span><br><span class="line">              <span class="attr">&quot;end_offset&quot;</span> : <span class="number">4</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;查&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;term_freq&quot;</span> : <span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;position&quot;</span> : <span class="number">16</span>,</span><br><span class="line">              <span class="attr">&quot;start_offset&quot;</span> : <span class="number">17</span>,</span><br><span class="line">              <span class="attr">&quot;end_offset&quot;</span> : <span class="number">18</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;段&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;term_freq&quot;</span> : <span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;position&quot;</span> : <span class="number">5</span>,</span><br><span class="line">              <span class="attr">&quot;start_offset&quot;</span> : <span class="number">5</span>,</span><br><span class="line">              <span class="attr">&quot;end_offset&quot;</span> : <span class="number">6</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;的&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;term_freq&quot;</span> : <span class="number">2</span>,</span><br><span class="line">          <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;position&quot;</span> : <span class="number">6</span>,</span><br><span class="line">              <span class="attr">&quot;start_offset&quot;</span> : <span class="number">6</span>,</span><br><span class="line">              <span class="attr">&quot;end_offset&quot;</span> : <span class="number">7</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;position&quot;</span> : <span class="number">22</span>,</span><br><span class="line">              <span class="attr">&quot;start_offset&quot;</span> : <span class="number">23</span>,</span><br><span class="line">              <span class="attr">&quot;end_offset&quot;</span> : <span class="number">24</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;索&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;term_freq&quot;</span> : <span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;position&quot;</span> : <span class="number">13</span>,</span><br><span class="line">              <span class="attr">&quot;start_offset&quot;</span> : <span class="number">14</span>,</span><br><span class="line">              <span class="attr">&quot;end_offset&quot;</span> : <span class="number">15</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;认&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;term_freq&quot;</span> : <span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;position&quot;</span> : <span class="number">11</span>,</span><br><span class="line">              <span class="attr">&quot;start_offset&quot;</span> : <span class="number">12</span>,</span><br><span class="line">              <span class="attr">&quot;end_offset&quot;</span> : <span class="number">13</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;词&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;term_freq&quot;</span> : <span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;position&quot;</span> : <span class="number">8</span>,</span><br><span class="line">              <span class="attr">&quot;start_offset&quot;</span> : <span class="number">8</span>,</span><br><span class="line">              <span class="attr">&quot;end_offset&quot;</span> : <span class="number">9</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;询&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;term_freq&quot;</span> : <span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;position&quot;</span> : <span class="number">17</span>,</span><br><span class="line">              <span class="attr">&quot;start_offset&quot;</span> : <span class="number">18</span>,</span><br><span class="line">              <span class="attr">&quot;end_offset&quot;</span> : <span class="number">19</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;都&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;term_freq&quot;</span> : <span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;position&quot;</span> : <span class="number">18</span>,</span><br><span class="line">              <span class="attr">&quot;start_offset&quot;</span> : <span class="number">19</span>,</span><br><span class="line">              <span class="attr">&quot;end_offset&quot;</span> : <span class="number">20</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;默&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;term_freq&quot;</span> : <span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;position&quot;</span> : <span class="number">10</span>,</span><br><span class="line">              <span class="attr">&quot;start_offset&quot;</span> : <span class="number">11</span>,</span><br><span class="line">              <span class="attr">&quot;end_offset&quot;</span> : <span class="number">12</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，默认情况下，中文就是一个字一个字的分，这种分词方式没有任何意义。如果这样分词，查询就只能一个字一个字来查，如下，这样查询没有任何意义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET blog/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;title&quot;: &#123;</span><br><span class="line">        &quot;value&quot;: &quot;定&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们要根据实际情况，配置合适的分词器。</p><p>给字段设定分词器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PUT blog</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;title&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">        &quot;analyzer&quot;: &quot;ik_smart&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存储文档</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUT blog/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;:&quot;定义文本字段的分词器，默认对索引和查询都是有效的。&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看词条向量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET blog/_termvectors/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;fields&quot;: [&quot;title&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;blog&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;found&quot;</span> : <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;took&quot;</span> : <span class="number">121</span>,</span><br><span class="line">  <span class="attr">&quot;term_vectors&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;title&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;field_statistics&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;sum_doc_freq&quot;</span> : <span class="number">12</span>,</span><br><span class="line">        <span class="attr">&quot;doc_count&quot;</span> : <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;sum_ttf&quot;</span> : <span class="number">13</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;terms&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;分词器&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;term_freq&quot;</span> : <span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;position&quot;</span> : <span class="number">4</span>,</span><br><span class="line">              <span class="attr">&quot;start_offset&quot;</span> : <span class="number">7</span>,</span><br><span class="line">              <span class="attr">&quot;end_offset&quot;</span> : <span class="number">10</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;和&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;term_freq&quot;</span> : <span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;position&quot;</span> : <span class="number">8</span>,</span><br><span class="line">              <span class="attr">&quot;start_offset&quot;</span> : <span class="number">16</span>,</span><br><span class="line">              <span class="attr">&quot;end_offset&quot;</span> : <span class="number">17</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;字段&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;term_freq&quot;</span> : <span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;position&quot;</span> : <span class="number">2</span>,</span><br><span class="line">              <span class="attr">&quot;start_offset&quot;</span> : <span class="number">4</span>,</span><br><span class="line">              <span class="attr">&quot;end_offset&quot;</span> : <span class="number">6</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;定义&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;term_freq&quot;</span> : <span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;position&quot;</span> : <span class="number">0</span>,</span><br><span class="line">              <span class="attr">&quot;start_offset&quot;</span> : <span class="number">0</span>,</span><br><span class="line">              <span class="attr">&quot;end_offset&quot;</span> : <span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;对&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;term_freq&quot;</span> : <span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;position&quot;</span> : <span class="number">6</span>,</span><br><span class="line">              <span class="attr">&quot;start_offset&quot;</span> : <span class="number">13</span>,</span><br><span class="line">              <span class="attr">&quot;end_offset&quot;</span> : <span class="number">14</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;文本&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;term_freq&quot;</span> : <span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;position&quot;</span> : <span class="number">1</span>,</span><br><span class="line">              <span class="attr">&quot;start_offset&quot;</span> : <span class="number">2</span>,</span><br><span class="line">              <span class="attr">&quot;end_offset&quot;</span> : <span class="number">4</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;有效&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;term_freq&quot;</span> : <span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;position&quot;</span> : <span class="number">11</span>,</span><br><span class="line">              <span class="attr">&quot;start_offset&quot;</span> : <span class="number">21</span>,</span><br><span class="line">              <span class="attr">&quot;end_offset&quot;</span> : <span class="number">23</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;查询&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;term_freq&quot;</span> : <span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;position&quot;</span> : <span class="number">9</span>,</span><br><span class="line">              <span class="attr">&quot;start_offset&quot;</span> : <span class="number">17</span>,</span><br><span class="line">              <span class="attr">&quot;end_offset&quot;</span> : <span class="number">19</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;的&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;term_freq&quot;</span> : <span class="number">2</span>,</span><br><span class="line">          <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;position&quot;</span> : <span class="number">3</span>,</span><br><span class="line">              <span class="attr">&quot;start_offset&quot;</span> : <span class="number">6</span>,</span><br><span class="line">              <span class="attr">&quot;end_offset&quot;</span> : <span class="number">7</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;position&quot;</span> : <span class="number">12</span>,</span><br><span class="line">              <span class="attr">&quot;start_offset&quot;</span> : <span class="number">23</span>,</span><br><span class="line">              <span class="attr">&quot;end_offset&quot;</span> : <span class="number">24</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;索引&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;term_freq&quot;</span> : <span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;position&quot;</span> : <span class="number">7</span>,</span><br><span class="line">              <span class="attr">&quot;start_offset&quot;</span> : <span class="number">14</span>,</span><br><span class="line">              <span class="attr">&quot;end_offset&quot;</span> : <span class="number">16</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;都是&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;term_freq&quot;</span> : <span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;position&quot;</span> : <span class="number">10</span>,</span><br><span class="line">              <span class="attr">&quot;start_offset&quot;</span> : <span class="number">19</span>,</span><br><span class="line">              <span class="attr">&quot;end_offset&quot;</span> : <span class="number">21</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;默认&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;term_freq&quot;</span> : <span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;position&quot;</span> : <span class="number">5</span>,</span><br><span class="line">              <span class="attr">&quot;start_offset&quot;</span> : <span class="number">11</span>,</span><br><span class="line">              <span class="attr">&quot;end_offset&quot;</span> : <span class="number">13</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以通过词去搜索了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET blog/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;title&quot;: &#123;</span><br><span class="line">        &quot;value&quot;: &quot;定义&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="search-analyzer"><a href="#search-analyzer" class="headerlink" title="search_analyzer"></a>search_analyzer</h3><p>查询时候的分词器。默认情况下，如果没有配置 search_analyzer ，则查询时首先查看有没有 search_analyzer  ，有的话，就用 search_analyzer  来进行分词，如果没有，则看看有没有 analyzer ，如果有，则用 analyzer 进行分词。否则使用 ES 默认的分词器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PUT blog</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;title&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">        &quot;analyzer&quot;: &quot;ik_smart&quot;,</span><br><span class="line">        &quot;search_analyzer&quot;: &quot;ik_smart&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="normalizer"><a href="#normalizer" class="headerlink" title="normalizer"></a>normalizer</h3><p>normalizer 参数用于解析前（索引或查询）的标准化配置。</p><p>比如说，在 ES 中，对于一些我们不想切分的字符串，我们会通常将其设为 keyword，搜索时也是使用整个词进行搜索。</p><p>比如 如果在索引前没有做好数据清洗，导致大小写不一致，例如 SakuraTears 和 sakuratears ，此时，我们就可以使用 normalizer 在索引之前以及查询之前进行文档的标准化。</p><p>反例，创建一个名为blog的索引，设置 author 字段类型为 keyword</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PUT blog</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;author&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加两个文档，大小写不一致。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PUT blog/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;author&quot;:&quot;sakuratears&quot;</span><br><span class="line">&#125;</span><br><span class="line">PUT blog/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;author&quot;:&quot;SakuraTears&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后进行搜索。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET blog/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;author&quot;: &#123;</span><br><span class="line">        &quot;value&quot;: &quot;sakuratears&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到只能搜索到一个文档，受字母大小写影响。</p><p>如果使用 normalizer，可以在索引和查询时分别对文档进行预处理。</p><p>normalizer定义方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">PUT blog</span><br><span class="line">&#123;</span><br><span class="line">  &quot;settings&quot;: &#123;</span><br><span class="line">    &quot;analysis&quot;: &#123;</span><br><span class="line">      &quot;normalizer&quot;:&#123;</span><br><span class="line">        &quot;my_normalizer&quot;:&#123;</span><br><span class="line">          &quot;type&quot;: &quot;custom&quot;,</span><br><span class="line">          &quot;filter&quot;:[&quot;lowercase&quot;]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, </span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;author&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;,</span><br><span class="line">        &quot;normalizer&quot;: &quot;my_normalizer&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 settings 中定义 normalizer ，然后在 mappings 中引用。</p><p>测试方式和前面一致，可以看到此时大小写都可以查出两个文档。</p><p>因为无论索引还是查询，都会将大写转为小写。</p><h3 id="boost"><a href="#boost" class="headerlink" title="boost"></a>boost</h3><p>boost 参数可以设置字段的权重。</p><p>boost有两种使用思路，一种就是在定义mappings的时候使用，在指定字段类型时使用；另一种就是在查询时使用。</p><p>实际开发中建议使用后者，前者有问题：如果不重新索引文档，权重无法更改。</p><ul><li>mappings 中使用 boost（不推荐）：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PUT blog</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;content&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">        &quot;boost&quot;: 2</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>查询时指定boost：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET blog/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;content&quot;: &#123;</span><br><span class="line">        &quot;query&quot;: &quot;你好&quot;,</span><br><span class="line">        &quot;boost&quot;: 2</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="coerce"><a href="#coerce" class="headerlink" title="coerce"></a>coerce</h3><p>coerce 用来清除脏数据，默认为true。</p><p>例如一个数字，在 JSON 中，用户可能写错了：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;age&quot;</span>:<span class="string">&quot;99&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;age&quot;</span>:<span class="string">&quot;99.0&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>这些都不是正确的数字格式。</p><p>通过coerce 可以解决该问题。</p><p>默认情况下，以下操作没问题，就是 coerce 在起作用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PUT blog</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;age&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;integer&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">POST blog/_doc</span><br><span class="line">&#123;</span><br><span class="line">  &quot;age&quot;:&quot;99.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要修改 coerce ，方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PUT blog</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;age&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;integer&quot;,</span><br><span class="line">        &quot;coerce&quot;: false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 coerce 设为 false 后 ，age 字段传入 数字字符串就会报错。</p><h3 id="copy-to"><a href="#copy-to" class="headerlink" title="copy_to"></a>copy_to</h3><p>这个属性可以将多个字段的值，复制到同一个字段中。</p><p>定义方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">PUT blog</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;title&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">        &quot;copy_to&quot;: &quot;full_content&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;content&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">        &quot;copy_to&quot;: &quot;full_content&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;full_content&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加文档：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT blog/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;:&quot;你好，sakuratears&quot;,</span><br><span class="line">  &quot;content&quot;:&quot;Elasticsearch 学习笔记&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">GET blog/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;full_content&quot;: &#123;</span><br><span class="line">        &quot;value&quot;: &quot;记&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET blog/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;full_content&quot;: &#123;</span><br><span class="line">        &quot;value&quot;: &quot;你&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="doc-values-和-fielddata"><a href="#doc-values-和-fielddata" class="headerlink" title="doc_values 和 fielddata"></a>doc_values 和 fielddata</h3><p>ES 中的搜索主要是用到倒排索引，doc_values 参数是为了加快排序、聚合操作而生的。当建立倒排索引的时候，会额外增加列式存储映射。</p><p>doc_values 默认是开启的，如果确定某个字段不需要排序或者不需要聚合，那么可以关闭doc_values 以节省空间。</p><p>大部分的字段在索引时都会生成 doc_values，除了 text 。 text 字段在查询时会生成一个fielddata 的数据结构，fielddata 在字段首次被 聚合、排序的时候生成。</p><table><thead><tr><th>doc_values</th><th>fielddata</th></tr></thead><tbody><tr><td>索引时创建</td><td>使用时动态创建</td></tr><tr><td>磁盘</td><td>内存</td></tr><tr><td>不占用内存</td><td>不占用磁盘</td></tr><tr><td>索引速度稍低</td><td>文档很多时，动态创建慢，占内存</td></tr></tbody></table><p>doc_values 默认开启，fielddata默认关闭。</p><p>doc_values 举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">PUT user</span><br><span class="line"></span><br><span class="line">PUT user/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;age&quot;: 100</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT user/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;age&quot;: 99</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT user/_doc/3</span><br><span class="line">&#123;</span><br><span class="line">  &quot;age&quot;: 98</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT user/_doc/4</span><br><span class="line">&#123;</span><br><span class="line">  &quot;age&quot;: 101</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET user/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;age&quot;: &#123;</span><br><span class="line">        &quot;order&quot;: &quot;desc&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 doc_values 默认开启的，所以可以直接使用 age 进行排序，如果想关闭 doc_values ，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">PUT user</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;age&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;integer&quot;,</span><br><span class="line">        &quot;doc_values&quot;: false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">PUT user/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;age&quot;: 100</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT user/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;age&quot;: 99</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT user/_doc/3</span><br><span class="line">&#123;</span><br><span class="line">  &quot;age&quot;: 98</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT user/_doc/4</span><br><span class="line">&#123;</span><br><span class="line">  &quot;age&quot;: 101</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET user/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;age&quot;: &#123;</span><br><span class="line">        &quot;order&quot;: &quot;desc&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dynamic"><a href="#dynamic" class="headerlink" title="dynamic"></a>dynamic</h3><p>dynamic 有三种取值：</p><ul><li>true ： 默认，自动添加新字段。</li><li>false： 忽略新字段。</li><li>strict： 严格模式，发现新字段，会抛出异常。</li></ul><p>见学习笔记 （7）</p><h3 id="enabled"><a href="#enabled" class="headerlink" title="enabled"></a>enabled</h3><p>ES 默认会索引所有的字段，但是有的字段可能只需要存储，不需要索引。此时可以通过 enabled 来进行控制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">PUT blog</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;url&quot;:&#123;</span><br><span class="line">        &quot;enabled&quot;:false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT blog/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;url&quot;:&quot;sakuratears&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET blog/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;url&quot;: &quot;sakuratears&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置了 enabled 为 false 之后，就不可以通过 该字段搜索了。</p><h3 id="format"><a href="#format" class="headerlink" title="format"></a>format</h3><p>日期格式。format 规范日期格式，而且一次可以定义多个 format。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PUT user</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;birthday&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;date&quot;,</span><br><span class="line">        &quot;format&quot;: &quot;yyyy-MM-dd||yyyy-MM-dd HH:mm:ss&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT user/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;birthday&quot;:&quot;2021-11-03&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>多个日期格式之间使用 <code>||</code> 符号连接，注意没有空格。</p></li><li><p>如果用户没有指定日期的format，默认的日期格式 是 <code>strict_date_optional_time||epoch_mills</code></p></li></ul><p>另外，所有的日期格式都可以在 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-date-format.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-date-format.html</a> 网址查看。</p><h3 id="ignore-above"><a href="#ignore-above" class="headerlink" title="ignore_above"></a>ignore_above</h3><p>ignore_above 用于指定分词和索引的字符串最大长度，超过最大长度的话，该字段将不会被索引，这个字段只适用于 keyword 类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">PUT blog</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;title&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;,</span><br><span class="line">        &quot;ignore_above&quot;: 10</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT blog/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;:&quot;sakuratears&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT blog/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;:&quot;sakura&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET blog/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;terms&quot;: &#123;</span><br><span class="line">      &quot;title&quot;: [</span><br><span class="line">        &quot;sakura&quot;,</span><br><span class="line">        &quot;sakuratears&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中 查询 sakuratears 是无结果的，因为其未被索引，但是文档是存在的。</p><h3 id="ignore-malformed"><a href="#ignore-malformed" class="headerlink" title="ignore_malformed"></a>ignore_malformed</h3><p>ignore_malformed 可以忽略不规则的数据，该参数默认为 false 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">PUT users</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;birthday&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;date&quot;,</span><br><span class="line">        &quot;format&quot;: &quot;yyyy-MM-dd||yyyy-MM-dd HH:mm:ss&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;age&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;integer&quot;,</span><br><span class="line">        &quot;ignore_malformed&quot;: true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT users/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;birthday&quot;:&quot;2021-06-10&quot;,</span><br><span class="line">  &quot;age&quot;:99</span><br><span class="line">&#125;</span><br><span class="line">PUT users/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;birthday&quot;:&quot;2021-06-10&quot;,</span><br><span class="line">  &quot;age&quot;:&quot;abc&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> doc 2 可以被存储，不会出错，但是 abc 不能被索引。</p><h3 id="include-in-all"><a href="#include-in-all" class="headerlink" title="include_in_all"></a>include_in_all</h3><p>这个是针对 <code>_all</code>字段的，但是在 ES7 中，该字段已经被废弃了。</p><p>替代品是 copy_to ， 原先ES 会将所有字段存储在一个叫 <code>xxx_all</code>字段里，当我们只知道词，并不知道其属于哪个 field，ES查询的时候会方便。</p><h3 id="index"><a href="#index" class="headerlink" title="index"></a>index</h3><p>index 指定一个字段是否被索引。该属性为true表示该字段被索引，false表示该字段不被索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">PUT users</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;age&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;integer&quot;,</span><br><span class="line">        &quot;index&quot;: false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT users/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;age&quot;: 20</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET users/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;age&quot;: &#123;</span><br><span class="line">        &quot;value&quot;: &quot;20&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询会报错，提示age字段未被索引。index 为 false，不能通过对应的字段搜索。</p><h3 id="index-options"><a href="#index-options" class="headerlink" title="index_options"></a>index_options</h3><p>index_options 控制索引时哪些信息被存储到倒排索引中（用在text字段中），有四种取值：</p><table><thead><tr><th>index_options</th><th>备注</th></tr></thead><tbody><tr><td>docs</td><td>只存储文档编号，默认</td></tr><tr><td>freqs</td><td>在 docs的基础上，存储词项频率</td></tr><tr><td>positions</td><td>在 freqs基础上，存储词项偏移位置</td></tr><tr><td>offsets</td><td>在positions基础上，存储词项开始和结束的字符位置</td></tr></tbody></table><h3 id="norms"><a href="#norms" class="headerlink" title="norms"></a>norms</h3><p>norms 对字段评分有用，text上默认开启 norms，如果不是特别需要，不要开启norms。</p><h3 id="null-value"><a href="#null-value" class="headerlink" title="null_value"></a>null_value</h3><p>在 ES 中，值为 null 的字段，不索引也不可以被搜索，null_value 可以让值为 null 的字段显式的可索引、可搜索。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">PUT users</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;name&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;,</span><br><span class="line">        &quot;null_value&quot;: &quot;-&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT users/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET users/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &#123;</span><br><span class="line">        &quot;value&quot;: &quot;-&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于用 “-” 字符串去代替null。</p><h3 id="position-increment-gap"><a href="#position-increment-gap" class="headerlink" title="position_increment_gap"></a>position_increment_gap</h3><p>被解析的text字段会将 term 的位置考虑进去，目的是为了支持近似查询和短语查询，当我们去索引一个含有多个值的text字段时，会在各个值之间添加一个假想的空间，将值隔开，这样就可以避免一些无意义的短语匹配，间隔大小通过 position_increment_gap 来控制，默认是100.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PUT users</span><br><span class="line"></span><br><span class="line">PUT users/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;names&quot;: [&quot;zhang san&quot;,&quot;Li si&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET users/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_phrase&quot;: &#123;</span><br><span class="line">      &quot;names&quot;: &quot;san li&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>san Li 搜索不到，因为两个短语之间有一个假想的空隙，为100。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET users/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_phrase&quot;: &#123;</span><br><span class="line">      &quot;names&quot;: &#123;</span><br><span class="line">        &quot;query&quot;: &quot;san Li&quot;,</span><br><span class="line">        &quot;slop&quot;: 100</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过 slop 指定容忍的空隙大小。</p><p>也可以在定义索引的时候指定空隙：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">PUT users</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;names&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">        &quot;position_increment_gap&quot;: 0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT users/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;names&quot;: [&quot;zhang san&quot;,&quot;Li si&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET users/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_phrase&quot;: &#123;</span><br><span class="line">      &quot;names&quot;: &#123;</span><br><span class="line">        &quot;query&quot;: &quot;san Li&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h3><p>略</p><h3 id="similarity"><a href="#similarity" class="headerlink" title="similarity"></a>similarity</h3><p>similarity 指定文档的评分模型，默认有三种。</p><table><thead><tr><th>similarity</th><th>备注</th></tr></thead><tbody><tr><td>BM25</td><td>ES和Lucene默认的评分模型</td></tr><tr><td>classic</td><td>TF/IDF 评分</td></tr><tr><td>boolean</td><td>boolean 评分模型</td></tr></tbody></table><h3 id="store"><a href="#store" class="headerlink" title="store"></a>store</h3><p>默认情况下，字段会被索引，也可以搜索，但是不会存储。虽然不会被存储，但是 <code>_source</code>中有一个字段的备份。</p><p>如果想将字段存储下来，可以通过配置 store 来实现。</p><h3 id="term-vector"><a href="#term-vector" class="headerlink" title="term_vector"></a>term_vector</h3><p>term_vector 是通过分词器产生的信息，包括：</p><ul><li>一组 terms</li><li>每个 term 的位置</li><li>term 的首字符/尾字符与原始字符串原点的偏移量</li></ul><p>term_vector 取值如下：</p><table><thead><tr><th>term_vector</th><th>备注</th></tr></thead><tbody><tr><td>no</td><td>不存储信息，默认</td></tr><tr><td>yes</td><td>term被存储</td></tr><tr><td>with_positions</td><td>在yes的基础上增加位置信息</td></tr><tr><td>with_offsets</td><td>在yes的基础上增加偏移信息</td></tr><tr><td>with_positions_offsets</td><td>term、位置、偏移信息都存储</td></tr></tbody></table><h3 id="fields"><a href="#fields" class="headerlink" title="fields"></a>fields</h3><p>fields 参数可以让同一字段有多种不同的索引方式。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">PUT blog</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;title&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">        &quot;fields&quot;: &#123;</span><br><span class="line">          &quot;raw&quot;:&#123;</span><br><span class="line">            &quot;type&quot;:&quot;keyword&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT blog/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;: &quot;sakura&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET blog/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;title&quot;: &#123;</span><br><span class="line">        &quot;value&quot;: &quot;sakura&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">GET blog/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;title.raw&quot;: &#123;</span><br><span class="line">        &quot;value&quot;: &quot;sakura&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mapping 参数 地址 ： <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-params.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-params.html</a></p><h2 id="Elasticsearch-映射模板"><a href="#Elasticsearch-映射模板" class="headerlink" title="Elasticsearch 映射模板"></a>Elasticsearch 映射模板</h2><p>ES 中有动态映射，但有的时候默认的动态映射规则并不能满足我们的需求，这个时候可以通过映射模板来解决。</p><p>例子，将所有的数字默认映射为integer。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">PUT blog</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;dynamic_templates&quot;:[</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;long2integer&quot;:&#123;</span><br><span class="line">          &quot;match_mapping_type&quot;:&quot;long&quot;,</span><br><span class="line">          &quot;mapping&quot;:&#123;</span><br><span class="line">            &quot;type&quot;:&quot;integer&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT blog/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;count&quot;:99</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET blog/_mapping</span><br></pre></td></tr></table></figure><p>存储完成后，默认会被识别为long类型的数据，现在就被识别为integer了。</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">PUT blog</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;dynamic_templates&quot;:[</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;string2integer&quot;:&#123;</span><br><span class="line">          &quot;match_mapping_type&quot;:&quot;string&quot;,</span><br><span class="line">          &quot;match&quot;:&quot;num_*&quot;,</span><br><span class="line">          &quot;unmatch&quot;:&quot;*_text&quot;,</span><br><span class="line">          &quot;mapping&quot;:&#123;</span><br><span class="line">            &quot;type&quot;:&quot;integer&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT blog/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;num_count&quot;:&quot;99&quot;,</span><br><span class="line">  &quot;num_text&quot;: &quot;sakura&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PUT blog/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;num_count&quot;:&quot;99&quot;,</span><br><span class="line">  &quot;num_text&quot;: &quot;sakura&quot;,</span><br><span class="line">  &quot;num_aaa&quot;: 999</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET blog/_mapping</span><br></pre></td></tr></table></figure><ul><li>num_count 字段为字符串 99 ，会进入 匹配逻辑，99变为 integer。</li><li>num_text 满足unmatch ，不会变为 integer，按照默认的text处理</li><li>num_aaa 字段为 999，不是字符串，不进入匹配逻辑，按默认的long处理。</li></ul><p>结果如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;blog&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;mappings&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;dynamic_templates&quot;</span> : [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;string2integer&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;match&quot;</span> : <span class="string">&quot;num_*&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;unmatch&quot;</span> : <span class="string">&quot;*_text&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;match_mapping_type&quot;</span> : <span class="string">&quot;string&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;mapping&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;integer&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;properties&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;num_aaa&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;long&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;num_count&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;integer&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;num_text&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;fields&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;keyword&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;ignore_above&quot;</span> : <span class="number">256</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h2 id=&quot;Elasticsearch-映射参数&quot;&gt;&lt;a href=&quot;#Elasticsearch-映射参数&quot; class=&quot;headerlink&quot; title=&quot;Elasticsearch 映射参数&quot;&gt;&lt;/a&gt;Elasticsearch 映射参数&lt;/h2&gt;&lt;h3 id=&quot;analyzer&quot;&gt;&lt;a href=&quot;#analyzer&quot; class=&quot;headerlink&quot; title=&quot;analyzer&quot;&gt;&lt;/a&gt;analyzer&lt;/h3&gt;&lt;p&gt;定义文本字段的分词器，默认对索引和查询都是有效的。&lt;/p&gt;
&lt;p&gt;假设不用分词器，我们先来看一下索引的结果，创建一个索引并添加一个文档。&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Elasticsearch" scheme="https://www.sakuratears.top/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch学习笔记（8）</title>
    <link href="https://www.sakuratears.top/blog/Elasticsearch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%888%EF%BC%89.html"/>
    <id>https://www.sakuratears.top/blog/Elasticsearch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%888%EF%BC%89.html</id>
    <published>2021-06-14T08:46:00.000Z</published>
    <updated>2021-06-14T08:47:05.742Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Elasticsearch-字段类型"><a href="#Elasticsearch-字段类型" class="headerlink" title="Elasticsearch 字段类型"></a>Elasticsearch 字段类型</h2><h3 id="核心类型"><a href="#核心类型" class="headerlink" title="核心类型"></a>核心类型</h3><h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><ul><li>string ： 这是一个已经过期的字符串类型。在 ES 5 之前用这个来描述字符串，现在已经被 text 和 keyword 替代了。</li><li>text ： 如果一个字段是要被全文检索的，比如说文章内容，那么可以使用 text。用了 text 之后，字段内容会被分析，在生成倒排索引之前，字符串会被分词器分成一个个的词项，text 类型的字段不用于排序，很少用于聚合。这种字符串也被称之为 analyzed 字段。</li><li>keyword ： 这种类型适用于结构化的字段，例如标签、手机号码等等，这种类型的字段可以用作过滤、排序、聚合等。这种字符串也称之为 not-analyzed 字段。</li></ul><h4 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h4><table><thead><tr><th>类型</th><th>取值范围</th></tr></thead><tbody><tr><td>long</td><td>-2^63 到 -2^63-1</td></tr><tr><td>integer</td><td>-2^31 到 -2^31-1</td></tr><tr><td>short</td><td>-2^15 到 -2^15-1</td></tr><tr><td>byte</td><td>-2^7 到 -2^7-1</td></tr><tr><td>double</td><td>64 位的双精度 IEEE754 浮点类型</td></tr><tr><td>float</td><td>32 位的双精度 IEEE754 浮点类型</td></tr><tr><td>half_float</td><td>16 位的双精度 IEEE754 浮点类型</td></tr><tr><td>scaled_float</td><td>缩放类型的浮点类型</td></tr></tbody></table><ul><li><p>在满足需求的情况下，优先使用范围小的字段。字段长度越短，索引和搜索的效率越高。</p></li><li><p>浮点数，优先考虑使用 scaled_float 。</p><p>scaled_float  举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PUT product</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;name&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;price&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;scaled_float&quot;,</span><br><span class="line">        &quot;scaling_factor&quot;: 100</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码，比如我们商品价格精确到分，那么一个88.88元的商品在ES底层存储的为8888，但是由于缩放因子为100，ES给我们提供的所有API返回的为88.88，在底层，long类型比float类型更易压缩存储。</p></li></ul><h4 id="日期类型（date）"><a href="#日期类型（date）" class="headerlink" title="日期类型（date）"></a>日期类型（date）</h4><p>由于JSON中没有日期类型，所以ES中的日期类型形式就比较多样。</p><ul><li>2021-06-09 或者 2021-06-09 11:00:00</li><li>一个从1970.1.1 零点 到现在的一个秒数或者毫秒数。</li></ul><p>ES 内部将时间转为 UTC ，然后将时间按照 millseconds-since-the-epoch 的长整型来存储。</p><p>自定义日期类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PUT product</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;date&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;date&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个能够解析的时间类型比较多。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PUT product/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;date&quot;:&quot;2021-06-09&quot;</span><br><span class="line">&#125;</span><br><span class="line">PUT product/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;date&quot;:&quot;2021-06-09T11:00:00Z&quot;</span><br><span class="line">&#125;</span><br><span class="line">PUT product/_doc/3</span><br><span class="line">&#123;</span><br><span class="line">  &quot;date&quot;:&quot;1623208124&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面三个文档中的日期都可以被解析，内部存储的是毫秒计时的长整型数。</p><h4 id="布尔类型（boolean）"><a href="#布尔类型（boolean）" class="headerlink" title="布尔类型（boolean）"></a>布尔类型（boolean）</h4><p>JSON 中的 “ture”，“false”，true，false。</p><h4 id="二进制类型（binary）"><a href="#二进制类型（binary）" class="headerlink" title="二进制类型（binary）"></a>二进制类型（binary）</h4><p>二进制接受的是base64编码的字符串，默认不存储，也不可搜索。</p><h4 id="范围类型"><a href="#范围类型" class="headerlink" title="范围类型"></a>范围类型</h4><ul><li>integer_range</li><li>float_range</li><li>long_range</li><li>double_range</li><li>date_range</li><li>ip_range</li></ul><p>定义的时候，指定范围类型即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PUT product</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;name&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;pirce&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;float_range&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入文档时，需要指定文档的界限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PUT product/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;apple&quot;,</span><br><span class="line">  &quot;pirce&quot;:&#123;</span><br><span class="line">    &quot;gt&quot;:9,</span><br><span class="line">    &quot;lt&quot;:19.9</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指定范围时，可以使用gt、gte、lt、lte。</p><h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><h4 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h4><p>ES 中没有专门的数组类型。默认情况下，任何字段都可以有一个或多个值。需要注意的是，数组中的元素必须是同一种类型。</p><p>添加数组时，数组中的第一个元素就决定了整个数组类型。</p><h4 id="对象类型-object"><a href="#对象类型-object" class="headerlink" title="对象类型(object)"></a>对象类型(object)</h4><p>由于 JSON 本身具有层级关系，所以文档包含内部对象。内部对象中还可以再包含内部对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PUT product/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;apple&quot;,</span><br><span class="line">  &quot;ext&quot;:&#123;</span><br><span class="line">    &quot;adderss&quot;:&quot;China&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="嵌套类型-nested"><a href="#嵌套类型-nested" class="headerlink" title="嵌套类型(nested)"></a>嵌套类型(nested)</h4><p>nested 是object 中的一个特例。</p><p>如果只使用 object 类型，假如有如下文档：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PUT product/_doc/3</span><br><span class="line">&#123;</span><br><span class="line">  &quot;users&quot;:[</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;first_name&quot;:&quot;Zhang&quot;,</span><br><span class="line">      &quot;last_name&quot;:&quot;San&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;first_name&quot;:&quot;Li&quot;,</span><br><span class="line">      &quot;last_name&quot;:&quot;Si&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于Luncene 没有内部对象的概念，所以 ES 会将对象层次扁平化，将一个对象转为字段名和值构成的简单列表。即上面的文档最终存储形式如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;users.first_name&quot;</span>:[<span class="string">&quot;Zhang&quot;</span>,<span class="string">&quot;Li&quot;</span>],</span><br><span class="line">  <span class="attr">&quot;users.last_name&quot;</span>:[<span class="string">&quot;San&quot;</span>,<span class="string">&quot;Si&quot;</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扁平化之后，用户名之间的关系没了。这样会导致如果搜索 Zhang Si 这个人，会搜索到。</p><p>此时可以通过nested 类型来解决问题，nested 对象类型可以保持数组中每个对象的独立性。nested 类型 将数组中的每一个对象作为独立隐藏稳定来索引，这样每一个嵌套对象都可以独立被索引。如下结构：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="attr">&quot;user.first_name&quot;</span>:<span class="string">&quot;Zhang&quot;</span>,</span><br><span class="line"><span class="attr">&quot;user.last_name&quot;</span>:<span class="string">&quot;San&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"> &#123;</span><br><span class="line">    <span class="attr">&quot;user.first_name&quot;</span>:<span class="string">&quot;Li&quot;</span>,</span><br><span class="line"><span class="attr">&quot;user.last_name&quot;</span>:<span class="string">&quot;Si&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>：</p><p>文档存储1在一起，读取性能高。</p><p><strong>缺点</strong>：</p><p>更新父或者子文档时需要更新整个文档。</p><h3 id="地理类型"><a href="#地理类型" class="headerlink" title="地理类型"></a>地理类型</h3><p>使用场景：</p><ul><li>查找某一个范围内的地理位置</li><li>通过地理位置或者相对中心点的距离来聚合文档</li><li>把距离整合到文档的评分中</li><li>通过距离对文档进行排序</li></ul><h4 id="geo-point"><a href="#geo-point" class="headerlink" title="geo_point"></a>geo_point</h4><p>geo_point 就是一个坐标点。定义方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PUT people</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;location&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;geo_point&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建时指定字段类型，存储时有四种方式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">PUT people/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;location&quot;:&#123;</span><br><span class="line">    &quot;lat&quot;: 34.27,</span><br><span class="line">    &quot;lon&quot;: 108.94</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT people/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;location&quot;: &quot;34.27,108.94&quot;</span><br><span class="line">&#125;</span><br><span class="line">//geo_hash</span><br><span class="line">PUT people/_doc/3</span><br><span class="line">&#123;</span><br><span class="line">  &quot;location&quot;: &quot;wqj6yyx&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PUT people/_doc/4</span><br><span class="line">&#123;</span><br><span class="line">  &quot;location&quot;: [108.94,34.27]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，使用数组描述时，数组中先经度后纬度。</p><h4 id="geo-shape"><a href="#geo-shape" class="headerlink" title="geo_shape"></a>geo_shape</h4><p>GeoJSON : <a href="https://geojson.org/">https://geojson.org/</a></p><table><thead><tr><th>GeoJson</th><th>Elasticsearch</th><th>备注</th></tr></thead><tbody><tr><td>Point</td><td>point</td><td>一个由经纬度描述的点</td></tr><tr><td>LineString</td><td>linestring</td><td>一个任意的线条，由两个以上的点组成</td></tr><tr><td>Polygon</td><td>polygon</td><td>一个封闭多边形</td></tr><tr><td>MultiPoint</td><td>multipoint</td><td>一组不连续的点</td></tr><tr><td>MultiLineString</td><td>multilinestring</td><td>多条不关联的线</td></tr><tr><td>MultiPolygon</td><td>multipolygon</td><td>多个多边形</td></tr><tr><td>GeometryCollection</td><td>geometrycollection</td><td>几何对象的集合</td></tr><tr><td></td><td>circle</td><td>一个圆形</td></tr><tr><td></td><td>envelope</td><td>通过左上角和右下角确定的矩形</td></tr></tbody></table><p>指定 geo_shape 的类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PUT people</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;location&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;geo_shape&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加文档时需要指定具体的类型（点坐标先经度后纬度）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PUT people/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;location&quot;:&#123;</span><br><span class="line">    &quot;type&quot;:&quot;point&quot;,</span><br><span class="line">    &quot;coordinates&quot;: [108.94,34.27]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是linestring，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PUT people/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;location&quot;:&#123;</span><br><span class="line">    &quot;type&quot;:&quot;linestring&quot;,</span><br><span class="line">    &quot;coordinates&quot;: [[108.94,34.27],[100,33]]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特殊类型"><a href="#特殊类型" class="headerlink" title="特殊类型"></a>特殊类型</h3><h4 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h4><p>存储IP地址，类型是IP。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PUT blog</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;ip_address&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;ip&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUT blog/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;ip_address&quot;:&quot;192.168.1.1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET blog/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;ip_address&quot;: &quot;192.168.0.0/16&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加 ipv4，ipv6 地址均可以。</p><h4 id="token-count"><a href="#token-count" class="headerlink" title="token_count"></a>token_count</h4><p>用于统计字符串分词后的词项个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PUT blog</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;title&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">        &quot;fields&quot;: &#123;</span><br><span class="line">          &quot;length&quot;:&#123;</span><br><span class="line">            &quot;type&quot;:&quot;token_count&quot;,</span><br><span class="line">            &quot;analyzer&quot;:&quot;standard&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于新增了 title.length 字段用来统计分词后词项的个数。查询方便。</p><p>添加文档：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUT blog/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;:&quot;zhang san&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过 token_count 去查询。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET blog/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;title.length&quot;: 2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;took&quot; : 438,</span><br><span class="line">  &quot;timed_out&quot; : false,</span><br><span class="line">  &quot;_shards&quot; : &#123;</span><br><span class="line">    &quot;total&quot; : 1,</span><br><span class="line">    &quot;successful&quot; : 1,</span><br><span class="line">    &quot;skipped&quot; : 0,</span><br><span class="line">    &quot;failed&quot; : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;hits&quot; : &#123;</span><br><span class="line">    &quot;total&quot; : &#123;</span><br><span class="line">      &quot;value&quot; : 1,</span><br><span class="line">      &quot;relation&quot; : &quot;eq&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;max_score&quot; : 1.0,</span><br><span class="line">    &quot;hits&quot; : [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;_index&quot; : &quot;blog&quot;,</span><br><span class="line">        &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">        &quot;_id&quot; : &quot;1&quot;,</span><br><span class="line">        &quot;_score&quot; : 1.0,</span><br><span class="line">        &quot;_source&quot; : &#123;</span><br><span class="line">          &quot;title&quot; : &quot;zhang san&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h2 id=&quot;Elasticsearch-字段类型&quot;&gt;&lt;a href=&quot;#Elasticsearch-字段类型&quot; class=&quot;headerlink&quot; title=&quot;Elasticsearch 字段类型&quot;&gt;&lt;/a&gt;Elasticsearch 字段类型&lt;/h2&gt;&lt;h3 id=&quot;核心类型&quot;&gt;&lt;a href=&quot;#核心类型&quot; class=&quot;headerlink&quot; title=&quot;核心类型&quot;&gt;&lt;/a&gt;核心类型&lt;/h3&gt;&lt;h4 id=&quot;字符串类型&quot;&gt;&lt;a href=&quot;#字符串类型&quot; class=&quot;headerlink&quot; title=&quot;字符串类型&quot;&gt;&lt;/a&gt;字符串类型&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;string ： 这是一个已经过期的字符串类型。在 ES 5 之前用这个来描述字符串，现在已经被 text 和 keyword 替代了。&lt;/li&gt;
&lt;li&gt;text ： 如果一个字段是要被全文检索的，比如说文章内容，那么可以使用 text。用了 text 之后，字段内容会被分析，在生成倒排索引之前，字符串会被分词器分成一个个的词项，text 类型的字段不用于排序，很少用于聚合。这种字符串也被称之为 analyzed 字段。&lt;/li&gt;
&lt;li&gt;keyword ： 这种类型适用于结构化的字段，例如标签、手机号码等等，这种类型的字段可以用作过滤、排序、聚合等。这种字符串也称之为 not-analyzed 字段。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Elasticsearch" scheme="https://www.sakuratears.top/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch学习笔记（7）</title>
    <link href="https://www.sakuratears.top/blog/Elasticsearch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%887%EF%BC%89.html"/>
    <id>https://www.sakuratears.top/blog/Elasticsearch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%887%EF%BC%89.html</id>
    <published>2021-06-14T08:42:00.000Z</published>
    <updated>2021-06-14T08:46:03.786Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Elasticsearch-映射"><a href="#Elasticsearch-映射" class="headerlink" title="Elasticsearch 映射"></a>Elasticsearch 映射</h2><p>映射就是Mapping，它用来定义一个文档以及文档所包含的字段该如何被存储和索引。所以，它其实有点类似于关系型数据库中表的定义。</p><h3 id="映射分类"><a href="#映射分类" class="headerlink" title="映射分类"></a>映射分类</h3><p><strong>动态映射</strong> / <strong>静态映射</strong></p><p>动态映射，顾名思义，就是自动创建出来的映射。</p><p>静态映射指定是手动创建的映射。</p><p>ES 根据存入的文档，自动分析出来文档中字段的类型以及存储方式，这种就是动态映射。</p><p>例如，新建一个索引，查看索引信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUT blog</span><br><span class="line">GET blog</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;blog&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;aliases&quot;</span> : &#123; &#125;,</span><br><span class="line">    <span class="attr">&quot;mappings&quot;</span> : &#123; &#125;,</span><br><span class="line">    <span class="attr">&quot;settings&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;index&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;routing&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;allocation&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;include&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;_tier_preference&quot;</span> : <span class="string">&quot;data_content&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;number_of_shards&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;provided_name&quot;</span> : <span class="string">&quot;blog&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;creation_date&quot;</span> : <span class="string">&quot;1623142050956&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;number_of_replicas&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;uuid&quot;</span> : <span class="string">&quot;JubS67p8Q7egZll5MQ9GAw&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;version&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;created&quot;</span> : <span class="string">&quot;7120199&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在创建好的索引信息中，我们可以看到，mappings 为空，这个 mappings 中保存的就是映射信息。</p><p>现在我们向索引中添加一个文档，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT blog/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;:&quot;blog1&quot;,</span><br><span class="line">  &quot;date&quot;:&quot;2021-06-08&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文档添加成功后，就会自动生成mappings。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET blog/_mapping</span><br></pre></td></tr></table></figure><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-745.png"></p><p>可以看到， date 字段的类型为 date， title 的类型有两个， text 和 keyword。（ES 5 之前字符串类型只有一个 string类型）</p><p>默认情况下，文档中如果新增了字段，mappings中也会自动新增进来。</p><p>有的时候，如果希望新增字段时，能够抛出异常来提醒开发者，这个可以通过 mappings 中的 dynamic 属性来配置。</p><p>dynamic 有三种取值：</p><ul><li>true ： 默认，自动添加新字段。</li><li>false： 忽略新字段。</li><li>strict： 严格模式，发现新字段，会抛出异常。</li></ul><p>具体配置方式如下，创建索引时指定mappings（其实就是静态映射）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PUT blog</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;dynamic&quot;: &quot;strict&quot;,</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;title&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;age&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;long&quot;</span><br><span class="line">      &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们此时添加文档，如下图：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-746.png"></p><p>可以看到我们没有配置 date 字段的映射，添加文档时出现错误。</p><p>动态映射还有一个日期检测的问题。</p><p>例如新建一个索引，然后添加一个含有日期的文档，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT blog</span><br><span class="line"></span><br><span class="line">PUT blog/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;remark&quot;:&quot;2021-06-08&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加成功后，remark字段会被推断为日期类型。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-747.png"></p><p>此时remark字段就无法存储其他类型数据。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-748.png"></p><p>要解决这个问题，可以使用静态映射，即在索引定义时，将remark指定为text类型。也可以关闭日期检测。</p><p>关闭日期检测：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT blog</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;date_detection&quot;: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时日期类型就会被当成文本来处理。</p><h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><p>ES 中动态映射类型推断方式如下：</p><table><thead><tr><th>JSON中的数据</th><th>自动推断出来的数据类型</th></tr></thead><tbody><tr><td>null</td><td>没有字段被添加</td></tr><tr><td>true/false</td><td>boolean</td></tr><tr><td>浮点数字</td><td>float</td></tr><tr><td>数字</td><td>long</td></tr><tr><td>JSON 对象</td><td>object</td></tr><tr><td>数组</td><td>数组中的第一个非空值决定</td></tr><tr><td>String</td><td>text/keyword/date/double/long 都有可能</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h2 id=&quot;Elasticsearch-映射&quot;&gt;&lt;a href=&quot;#Elasticsearch-映射&quot; class=&quot;headerlink&quot; title=&quot;Elasticsearch 映射&quot;&gt;&lt;/a&gt;Elasticsearch 映射&lt;/h2&gt;&lt;p&gt;映射就是Mapping，它用来定义一个文档以及文档所包含的字段该如何被存储和索引。所以，它其实有点类似于关系型数据库中表的定义。&lt;/p&gt;
&lt;h3 id=&quot;映射分类&quot;&gt;&lt;a href=&quot;#映射分类&quot; class=&quot;headerlink&quot; title=&quot;映射分类&quot;&gt;&lt;/a&gt;映射分类&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;动态映射&lt;/strong&gt; / &lt;strong&gt;静态映射&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Elasticsearch" scheme="https://www.sakuratears.top/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch学习笔记（6）</title>
    <link href="https://www.sakuratears.top/blog/Elasticsearch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89.html"/>
    <id>https://www.sakuratears.top/blog/Elasticsearch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%886%EF%BC%89.html</id>
    <published>2021-06-14T08:40:00.000Z</published>
    <updated>2021-06-14T08:42:03.802Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><p>倒排索引是 ES 中非常重要的索引结构，是从 <strong>文档词项到文档ID</strong> 的一个映射过程。</p><h3 id="“-正排索引-”"><a href="#“-正排索引-”" class="headerlink" title="“ 正排索引 ”"></a>“ 正排索引 ”</h3><p>我们在关系型数据库中见到的索引，就是“正排索引”。</p><p>关系型数据库中的索引如下，假设我们有一张博客表，内容如下：</p><table><thead><tr><th>id</th><th>作者</th><th>标题</th><th>内容</th></tr></thead><tbody><tr><td>1</td><td>sakura1</td><td>倒排索引</td><td>1234567890</td></tr><tr><td>2</td><td>sakura2</td><td>正排索引</td><td>adcdefghi</td></tr></tbody></table><p>我们可以针对这个表建立索引（正排索引）：</p><p>比如根据id，根据作者，根据标题去建立索引。</p><p>这样我们搜索文章时，无论根据id，作者，标题都可以快速搜索到。</p><p>但是当我们按照文章内容去搜索时，先不考虑内容字段是否适合建立索引，即使给内容字段建立索引，我们在查询时，也不可能将全部内容作为搜索条件去搜索。</p><p>如果我们按照文章关键字去搜索，比如哪篇文章内容包含abcd，那么只能去做字符匹配了，这样效率也非常低。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> blog <span class="keyword">where</span> content <span class="keyword">like</span> <span class="string">&#x27;%abcd%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>为了提高查询效率，就要考虑使用到倒排索引。</p><h3 id="倒排索引-1"><a href="#倒排索引-1" class="headerlink" title="倒排索引"></a>倒排索引</h3><p>倒排索引就是以内容的关键字建立索引，通过索引找到文档id，再进而找到整个文档。</p><p>比如对于上面博客表，有4条数据，如下：</p><table><thead><tr><th>id</th><th>author</th><th>title</th><th>content</th></tr></thead><tbody><tr><td>1</td><td>javazwt</td><td>java</td><td>java is very good，and I like elasticsearch</td></tr><tr><td>2</td><td>sakura</td><td>elasticsearch</td><td>elasticsearch is very very good</td></tr><tr><td>3</td><td>sakuratears</td><td>php</td><td>I like php and elasticsearch</td></tr><tr><td>4</td><td>sakura</td><td>12345</td><td>php is very good</td></tr></tbody></table><p>则我们根据内容content关键字建立倒排索引，结果如下：</p><table><thead><tr><th>索引</th><th>ids</th><th>id=1</th><th>id=2</th><th>id=3</th><th>id4</th></tr></thead><tbody><tr><td>java</td><td>1</td><td>*</td><td></td><td></td><td></td></tr><tr><td>is</td><td>1,2,4</td><td>*</td><td>*</td><td></td><td>*</td></tr><tr><td>very</td><td>1,2,4</td><td>*</td><td>*</td><td></td><td>*</td></tr><tr><td>good</td><td>1,2,4</td><td>*</td><td>*</td><td></td><td>*</td></tr><tr><td>and</td><td>1,3</td><td>*</td><td></td><td>*</td><td></td></tr><tr><td>I</td><td>1,3</td><td>*</td><td></td><td>*</td><td></td></tr><tr><td>like</td><td>1,3</td><td>*</td><td></td><td>*</td><td></td></tr><tr><td>elasticsearch</td><td>1,2,3</td><td>*</td><td>*</td><td>*</td><td></td></tr><tr><td>php</td><td>3,4</td><td></td><td></td><td>*</td><td>*</td></tr></tbody></table><p>比如此时我们想搜索elasticsearch相关文章内容，则根据倒排索引可以快速定位到文档1,2,3，进而快速拿到整个文档信息。</p><p>我们之前提到过停用词，比如我们建立文档时指定了停用词，比如is，那么建立倒排索引时 is 便不会被索引。</p><p>之前说过的分词器，其功能就是将我们的content正确分词。</p><p>一般来说，倒排索引分为两个部分：</p><ul><li>单词词典：记录所有文档词项，以及词项到倒排列表的关联关系。</li><li>倒排列表：记录单词与对应的关系，由一系列倒排索引项组成，倒排索引项：文档id、词频（TF）（词项在文档中出现的次数，比如上例中的very，在文章2中出现了两次，可以认为文档2搜索相关度更高一些）、位置（词项在文档中分词的位置）、偏移（记录词项开始和结束的位置）。我们上例仅仅使用了文档id倒排索引项。</li></ul><p>当我们去索引一个文档时，就会建立倒排索引，搜索时，直接根据倒排索引进行搜索。</p>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h2 id=&quot;倒排索引&quot;&gt;&lt;a href=&quot;#倒排索引&quot; class=&quot;headerlink&quot; title=&quot;倒排索引&quot;&gt;&lt;/a&gt;倒排索引&lt;/h2&gt;&lt;p&gt;倒排索引是 ES 中非常重要的索引结构，是从 &lt;strong&gt;文档词项到文档ID&lt;/strong&gt; 的一个映射过程。&lt;/p&gt;
&lt;h3 id=&quot;“-正排索引-”&quot;&gt;&lt;a href=&quot;#“-正排索引-”&quot; class=&quot;headerlink&quot; title=&quot;“ 正排索引 ”&quot;&gt;&lt;/a&gt;“ 正排索引 ”&lt;/h3&gt;&lt;p&gt;我们在关系型数据库中见到的索引，就是“正排索引”。&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Elasticsearch" scheme="https://www.sakuratears.top/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch学习笔记（5）</title>
    <link href="https://www.sakuratears.top/blog/Elasticsearch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89.html"/>
    <id>https://www.sakuratears.top/blog/Elasticsearch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89.html</id>
    <published>2021-06-14T08:33:00.000Z</published>
    <updated>2021-06-14T08:39:29.012Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Elasticsearch文档基本操作"><a href="#Elasticsearch文档基本操作" class="headerlink" title="Elasticsearch文档基本操作"></a>Elasticsearch文档基本操作</h2><h3 id="新建文档"><a href="#新建文档" class="headerlink" title="新建文档"></a>新建文档</h3><p>首先新建一个索引，比如 blog。</p><p>然后向索引中添加一个文档。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT blog/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;:&quot;Elasticsearch 文档基本操作&quot;,</span><br><span class="line">  &quot;date&quot;:&quot;2021-06-04&quot;,</span><br><span class="line">  &quot;content&quot;:&quot;Elasticsearch 文档基本操作，如何新建文档，删除文档，更新文档等&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-739.png"></p><p>Kibana添加成功响应结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;blog&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;result&quot;</span> : <span class="string">&quot;created&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;_seq_no&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;_primary_term&quot;</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>_index表示文档索引。</li><li>_type表示文档类型。</li><li>_id 表示文档id。</li><li>_version 表示文档版本（更新文档，版本会自动+1，针对文档的）</li><li>result表示执行结果类型。</li><li>_shards表示分片信息。</li><li><code>_seq_no </code>和<code>_primary_term</code>也是版本控制使用的（针对当前索引的）。</li></ul><p>当然，添加文档时也可以不指定id，此时系统会默认给出一个id。如果不指定id，则需要使用 POST 请求，而不能使用 PUT 请求。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST blog/_doc</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;:&quot;Elasticsearch 文档基本操作1&quot;,</span><br><span class="line">  &quot;date&quot;:&quot;2021-06-04&quot;,</span><br><span class="line">  &quot;content&quot;:&quot;Elasticsearch 文档基本操作，如何新建文档，删除文档，更新文档等1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;blog&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;8Ld91nkBirAhYR49g5lr&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;result&quot;</span> : <span class="string">&quot;created&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;_seq_no&quot;</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;_primary_term&quot;</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h3><p>Elasticsearch 提供了 GET API 来查看文档。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET blog/_doc/1</span><br></pre></td></tr></table></figure><p>返回信息：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;blog&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;_seq_no&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;_primary_term&quot;</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;found&quot;</span> : <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;_source&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;title&quot;</span> : <span class="string">&quot;Elasticsearch 文档基本操作&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;date&quot;</span> : <span class="string">&quot;2021-06-04&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;content&quot;</span> : <span class="string">&quot;Elasticsearch 文档基本操作，如何新建文档，删除文档，更新文档等&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果获取不存在的文档，会返回未找到。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET blog/_doc/2</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;blog&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;2&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;found&quot;</span> : <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果只是想知道某个文档是否存在，使用 HEAD 请求。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">请求：</span><br><span class="line">HEAD blog/_doc/1</span><br><span class="line">返回：</span><br><span class="line">200 - OK</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">请求：</span><br><span class="line">HEAD blog/_doc/2</span><br><span class="line">返回：</span><br><span class="line">&#123;&quot;statusCode&quot;:404,&quot;error&quot;:&quot;Not Found&quot;,&quot;message&quot;:&quot;404 - Not Found&quot;&#125;</span><br></pre></td></tr></table></figure><p>当然也可以批量获取文档。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET blog/_mget</span><br><span class="line">&#123;</span><br><span class="line">  &quot;ids&quot;:[&quot;1&quot;,&quot;8Ld91nkBirAhYR49g5lr&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>GET 请求携带请求体的问题？</p><p>某些特定的语言，例如 JavaScript 的HTTP请求是不允许 GET请求有请求体的，实际上在 RFC7231 文档中，并没有规定GET 请求的请求体改如何处理，这样造成了一定程度的混乱，有的HTTP服务器支持GET请求携带请求体，有的HTTP服务器则不支持。虽然ES工程师倾向于使用GET做查询，但是为了保证兼容性，ES同时也支持使用POST查询。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST blog/_mget</span><br><span class="line">&#123;</span><br><span class="line">  &quot;ids&quot;:[&quot;1&quot;,&quot;8Ld91nkBirAhYR49g5lr&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面方法也是可以的。</p><h3 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h3><h4 id="普通更新"><a href="#普通更新" class="headerlink" title="普通更新"></a>普通更新</h4><p>注意，文档更新一次，_version就会加1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUT blog/_doc/8Ld91nkBirAhYR49g5lr</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;:&quot;123456&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式更新的文档会覆盖原文档内容，如果我们只想更新某个字段，这种方式需要把其他未变化的字段也带上。</p><p>大多数时候，我们只想更新文档字段，这个可以通过脚本来实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">POST blog/_update/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;script&quot;:&#123;</span><br><span class="line">    &quot;lang&quot;: &quot;painless&quot;,</span><br><span class="line">    &quot;source&quot;: &quot;ctx._source.title=params.title&quot;,</span><br><span class="line">    &quot;params&quot;: &#123;</span><br><span class="line">      &quot;title&quot;:&quot;123456&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新请求格式：POST {index}/_update/{id}</p><p>在脚本中，lang 表示脚本语言，painless 是ES 内置的一种脚本语言。source 表示具体执行的脚本，ctx是一个上下文对象，通过 ctx可以访问到 <code>_source</code> 、<code>_title</code>等字段。</p><p>也可以向文档中添加字段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST blog/_update/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;script&quot;:&#123;</span><br><span class="line">    &quot;lang&quot;: &quot;painless&quot;,</span><br><span class="line">    &quot;source&quot;: &quot;ctx._source.tags=[\&quot;java\&quot;,\&quot;php\&quot;]&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;blog&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span> : <span class="number">3</span>,</span><br><span class="line">  <span class="attr">&quot;_seq_no&quot;</span> : <span class="number">4</span>,</span><br><span class="line">  <span class="attr">&quot;_primary_term&quot;</span> : <span class="number">2</span>,</span><br><span class="line">  <span class="attr">&quot;found&quot;</span> : <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;_source&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;title&quot;</span> : <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;date&quot;</span> : <span class="string">&quot;2021-06-04&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;content&quot;</span> : <span class="string">&quot;Elasticsearch 文档基本操作，如何新建文档，删除文档，更新文档等&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;tags&quot;</span> : [</span><br><span class="line">      <span class="string">&quot;java&quot;</span>,</span><br><span class="line">      <span class="string">&quot;php&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过脚本语言，也可以修改数组字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST blog/_update/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;script&quot;:&#123;</span><br><span class="line">    &quot;lang&quot;: &quot;painless&quot;,</span><br><span class="line">    &quot;source&quot;: &quot;ctx._source.tags.add(\&quot;javascript\&quot;)&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;blog&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span> : <span class="number">4</span>,</span><br><span class="line">  <span class="attr">&quot;_seq_no&quot;</span> : <span class="number">5</span>,</span><br><span class="line">  <span class="attr">&quot;_primary_term&quot;</span> : <span class="number">2</span>,</span><br><span class="line">  <span class="attr">&quot;found&quot;</span> : <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;_source&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;title&quot;</span> : <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;date&quot;</span> : <span class="string">&quot;2021-06-04&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;content&quot;</span> : <span class="string">&quot;Elasticsearch 文档基本操作，如何新建文档，删除文档，更新文档等&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;tags&quot;</span> : [</span><br><span class="line">      <span class="string">&quot;java&quot;</span>,</span><br><span class="line">      <span class="string">&quot;php&quot;</span>,</span><br><span class="line">      <span class="string">&quot;javascript&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然。也可以使用 if else 构造稍微复杂一点的逻辑。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST blog/_update/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;script&quot;:&#123;</span><br><span class="line">    &quot;lang&quot;: &quot;painless&quot;,</span><br><span class="line">    &quot;source&quot;: &quot;if(ctx._source.tags.contains(\&quot;java\&quot;))&#123;ctx.op=\&quot;delete\&quot;&#125;else&#123;ctx.op=\&quot;none\&quot;&#125;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;blog&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span> : <span class="number">5</span>,</span><br><span class="line">  <span class="attr">&quot;result&quot;</span> : <span class="string">&quot;deleted&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;_seq_no&quot;</span> : <span class="number">6</span>,</span><br><span class="line">  <span class="attr">&quot;_primary_term&quot;</span> : <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查询更新"><a href="#查询更新" class="headerlink" title="查询更新"></a>查询更新</h4><p>通过条件查询找到文档，然后再去更新。</p><p>将title中包含12345的文档的content修改为 12345.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST blog/_update_by_query</span><br><span class="line">&#123;</span><br><span class="line">  &quot;script&quot;: &#123;</span><br><span class="line">    &quot;source&quot;: &quot;ctx._source.content=\&quot;12345\&quot;&quot;,</span><br><span class="line">    &quot;lang&quot;: &quot;painless&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;title&quot;: &quot;12345&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><h4 id="根据id删除"><a href="#根据id删除" class="headerlink" title="根据id删除"></a>根据id删除</h4><p>从索引中删除一个文档</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE blog/_doc/1</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;blog&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span> : <span class="number">4</span>,</span><br><span class="line">  <span class="attr">&quot;result&quot;</span> : <span class="string">&quot;deleted&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;_seq_no&quot;</span> : <span class="number">14</span>,</span><br><span class="line">  <span class="attr">&quot;_primary_term&quot;</span> : <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在添加文档时指定了路由，则删除文档时也需要指定路由，否则删除失败。</p><h4 id="查询删除"><a href="#查询删除" class="headerlink" title="查询删除"></a>查询删除</h4><p>查询删除是POST请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST blog/_delete_by_query</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;:&#123;</span><br><span class="line">    &quot;term&quot;:&#123;</span><br><span class="line">      &quot;title&quot;:&quot;12345&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以删除某一个索引下的所有文档。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST blog/_delete_by_query</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;:&#123;</span><br><span class="line">    &quot;match_all&quot;:&#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h3><p>ES中通过bulk API 可以执行批量索引、批量删除、批量更新等操作。</p><p>首先需要将所有的批量操作写入到一个JSON文件中，然后通过POST请求将该JSON文件上传并执行。</p><p>例如新建一个名为aaa.json的文件，内容如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;index&quot;</span>:&#123;<span class="attr">&quot;_index&quot;</span>:<span class="string">&quot;user&quot;</span>,<span class="attr">&quot;_id&quot;</span>:<span class="string">&quot;666&quot;</span>&#125;&#125;</span><br><span class="line">&#123;<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;sakuratears&quot;</span>&#125;</span><br><span class="line">&#123;<span class="attr">&quot;update&quot;</span>:&#123;<span class="attr">&quot;_index&quot;</span>:<span class="string">&quot;user&quot;</span>,<span class="attr">&quot;_id&quot;</span>:<span class="string">&quot;666&quot;</span>&#125;&#125;</span><br><span class="line">&#123;<span class="attr">&quot;doc&quot;</span>:&#123;<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;sakura&quot;</span>&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第一行：index表示执行索引操作（表示一个action，其他action还有 create、delete、update）。</p><p>第二行是第一行的操作参数。</p><p>第三行的update则表示更新操作。</p><p>第四行是第三行的操作参数。</p><p>注意，结尾要空出一行。</p><p>index创建索引和create创建索引的区别是create创建索引如果索引已经存在则会创建失败。</p><p>文件创建成功后，直接在该目录下执行请求命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST &quot;http://localhost:9200/user/_bulk&quot; -H &quot;content-type:application/json&quot; --data-binary @aaa.json</span><br></pre></td></tr></table></figure><p>当然，我们如果不新建文件，直接在 Kibana 开发者工具里也是可以执行的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST _bulk</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;user&quot;,&quot;_id&quot;:&quot;666&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;:&quot;sakuratears&quot;&#125;</span><br><span class="line">&#123;&quot;update&quot;:&#123;&quot;_index&quot;:&quot;user&quot;,&quot;_id&quot;:&quot;666&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;doc&quot;:&#123;&quot;name&quot;:&quot;sakura&quot;&#125;&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;took&quot;</span> : <span class="number">2358</span>,</span><br><span class="line">  <span class="attr">&quot;errors&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;items&quot;</span> : [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;index&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;user&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;666&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_version&quot;</span> : <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;result&quot;</span> : <span class="string">&quot;created&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_shards&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;total&quot;</span> : <span class="number">2</span>,</span><br><span class="line">          <span class="attr">&quot;successful&quot;</span> : <span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;failed&quot;</span> : <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;_seq_no&quot;</span> : <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;_primary_term&quot;</span> : <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;status&quot;</span> : <span class="number">201</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;update&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;user&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;666&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_version&quot;</span> : <span class="number">2</span>,</span><br><span class="line">        <span class="attr">&quot;result&quot;</span> : <span class="string">&quot;updated&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_shards&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;total&quot;</span> : <span class="number">2</span>,</span><br><span class="line">          <span class="attr">&quot;successful&quot;</span> : <span class="number">1</span>,</span><br><span class="line">          <span class="attr">&quot;failed&quot;</span> : <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;_seq_no&quot;</span> : <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;_primary_term&quot;</span> : <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;status&quot;</span> : <span class="number">200</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Elasticsearch-文档路由"><a href="#Elasticsearch-文档路由" class="headerlink" title="Elasticsearch 文档路由"></a>Elasticsearch 文档路由</h2><p>ES 是一个分布式系统，当我们存储一个文档到 ES 上之后，这个文档实际是被存储到 master 节点中的某一个主分片上。</p><p>那么就存在一个问题，ES如何知道这个文档被存放到哪一个分片上？</p><p>例如，新建一个索引，该索引有两个分片，0个副本，如下：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-740.png"></p><p>接下来，向索引中保存一个文档。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUT blog/_doc/a</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;:&quot;a&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文档保存成功后，可以查看该文档被保存到哪个分片。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET _cat/shards/blog?v</span><br></pre></td></tr></table></figure><p>查看结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">index shard prirep state   docs store ip        node</span><br><span class="line">blog  1     p      STARTED    0  208b 127.0.0.1 slave02</span><br><span class="line">blog  0     p      STARTED    1 4.7kb 127.0.0.1 slave01</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从这个结果中可以看出，文档被保存在分片 0 上。</p><p>我们在保存一个文档。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUT blog/_doc/b</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;:&quot;b&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续查看分片，可以看到它被保存在分片 1 上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">index shard prirep state   docs store ip        node</span><br><span class="line">blog  1     p      STARTED    1 4.7kb 127.0.0.1 slave02</span><br><span class="line">blog  0     p      STARTED    1 4.9kb 127.0.0.1 slave01</span><br></pre></td></tr></table></figure><p>那么ES 是按照什么样的规则去分配分片的呢？</p><p>ES中的路由机制是通过哈希算法，将具有相同哈希值的文档放到同一个主分片中，分片位置的计算方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shard = hash(routing)%number_of_primary_shards</span><br></pre></td></tr></table></figure><p>routing可以是一个任意字符串，ES默认是将文档的id作为routing值，通过哈希函数根据routing生成一个数字，然后将该数字和分片数取余。取余的结果就是分片的位置。</p><p>默认的这种路由模式，最大的优势在于负载均衡，这种方式可以保证数据平均分配在不同的分片上。但是有一个很大的劣势。就是查询时候无法确定文档位置，此时它会将请求广播到所有的分片上去执行。另一方面，使用默认的路由模式，后期修改分片数量十分不方便。</p><p>开发者也可以自定义routing的值，方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUT blog/_doc/d?routing=sakura</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;:&quot;d&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果文档在添加时指定了routing，则查询、删除、更新是也需要指定routing。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET blog/_doc/d?routing=sakura</span><br></pre></td></tr></table></figure><p>自定义routing可能导致负载不均衡，这需要结合实际情况选择。</p><p>典型场景：</p><p>对于用户数据，我们可以将 userId 作为 routing，这样就能保证同一个用户的数据保存在同一个分片中，检索时，同样使用userId作为routing，这样就可以精确的从某一个分片中获取数据。</p><h2 id="Elasticsearch-文档版本控制"><a href="#Elasticsearch-文档版本控制" class="headerlink" title="Elasticsearch 文档版本控制"></a>Elasticsearch 文档版本控制</h2><p>当我们使用 ES API 进行文档更新时，它首先读取原文档，然后对文档进行更新，然后再重新索引整个文档。无论执行多少次更新，最终保存在 ES 中的是最后一次更新的文档。</p><p>但是如果有两个线程同时更新，就可能会出现问题。</p><p>要解决问题，就要用到锁。</p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p><strong>悲观锁</strong></p><p>每一次读取数据时，都认为数据可能会被修改，所以屏蔽一切可能破坏数据完整性的操作。关系型数据库中，悲观锁使用较多，例如行锁、表锁等。</p><p><strong>乐观锁</strong></p><p>每次读取数据时，都认为数据不会被修改，因此不锁定数据，只有在提交数据时，检查数据完整性。这种方式可以省去锁的开销，进而提高吞吐量。</p><p>在 ES 中，实际上使用的就是乐观锁。</p><h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><p><strong>ES 6.7</strong> 版本之前，使用 <code>_version</code> + <code>_version_type</code> 来进行乐观并发控制。根据前面的介绍，文档每被修改一次，<code>_version</code>就会自增1次，ES 通过 <code>_version</code> 字段来确保所有的操作都有序进行。</p><p>version 分为内部版本控制和外部版本控制。</p><h4 id="内部版本控制"><a href="#内部版本控制" class="headerlink" title="内部版本控制"></a>内部版本控制</h4><p>ES 自己维护的就是内部版本，当创建一个文档时，ES 会给文档版本赋值为1。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-741.png"></p><p>每当用户修改一次文档，版本号就会自增1。</p><p>如果使用内部版本，ES 要求 <code>_version</code> 参数必须和 ES 文档中 <code>_version</code>的值相等才能操作成功。</p><h4 id="外部版本控制"><a href="#外部版本控制" class="headerlink" title="外部版本控制"></a>外部版本控制</h4><p>ES也可以通过外部版本进行版本控制。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-742.png"></p><p>添加文档时，PUT请求后添加参数 version 和 version_type。</p><p>version_type 有 external 和 external_gte 两种。</p><p>external 表示更新时版本号参数必须大于文档版本号。</p><p>external_gte 表示更新时版本号参数必须大于等于文档版本号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUT blog/_doc/1?version=200&amp;version_type=external</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;:&quot;2222&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-743.png"></p><h4 id="新版本控制（ES-6-7之后）"><a href="#新版本控制（ES-6-7之后）" class="headerlink" title="新版本控制（ES 6.7之后）"></a>新版本控制（ES 6.7之后）</h4><p>现在使用 <code>_seq_no</code> 和 <code>_primary_term</code> 两个参数来进行并发控制。</p><p><code>_seq_no</code> 不属于某一个文档，它属于整个索引的。（<code>_version</code> 则是属于某一个文档的，每个文档的<code>_version</code>互不影响）</p><p>现在更想文档时，使用 <code>_seq_no</code> 来做并发。由于 <code>_seq_no</code>  是属于整个 索引的，所以索引下任何文档的修改或者新增，<code>_seq_no</code> 都会自增。</p><p>现在就可以通过 <code>_seq_no</code> 和 <code>_primary_term</code> 来做并发控制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUT blog/_doc/e?if_seq_no=3&amp;if_primary_term=1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;:&quot;1212121&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-744.png"></p>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h2 id=&quot;Elasticsearch文档基本操作&quot;&gt;&lt;a href=&quot;#Elasticsearch文档基本操作&quot; class=&quot;headerlink&quot; title=&quot;Elasticsearch文档基本操作&quot;&gt;&lt;/a&gt;Elasticsearch文档基本操作&lt;/h2&gt;&lt;h3 id=&quot;新建文档&quot;&gt;&lt;a href=&quot;#新建文档&quot; class=&quot;headerlink&quot; title=&quot;新建文档&quot;&gt;&lt;/a&gt;新建文档&lt;/h3&gt;&lt;p&gt;首先新建一个索引，比如 blog。&lt;/p&gt;
&lt;p&gt;然后向索引中添加一个文档。&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Elasticsearch" scheme="https://www.sakuratears.top/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch学习笔记（4）</title>
    <link href="https://www.sakuratears.top/blog/Elasticsearch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89.html"/>
    <id>https://www.sakuratears.top/blog/Elasticsearch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89.html</id>
    <published>2021-06-14T08:22:00.000Z</published>
    <updated>2021-06-14T08:31:31.672Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Elasticsearch索引管理"><a href="#Elasticsearch索引管理" class="headerlink" title="Elasticsearch索引管理"></a>Elasticsearch索引管理</h2><p>启动一个master节点和两个slave节点进行测试。</p><p>启动Kibana，访问地址 <a href="http://localhost:5601/">http://localhost:5601</a></p><h3 id="新建索引"><a href="#新建索引" class="headerlink" title="新建索引"></a>新建索引</h3><h4 id="通过head插件新建索引"><a href="#通过head插件新建索引" class="headerlink" title="通过head插件新建索引"></a>通过head插件新建索引</h4><p>在head插件中选择索引选项卡，然后点击新建索引。新建索引时，需要填入索引名称、分片数及副本数。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-729.png"></p><p>索引创建成功后，如下图：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-730.png"></p><p>0,1,2,3,4 分别表示索引的分片，粗框表示主分片，细框表示副本（点击框显示primary属性）。.kibana索引只有一个分片和一个副本。</p><h4 id="通过请求创建"><a href="#通过请求创建" class="headerlink" title="通过请求创建"></a>通过请求创建</h4><p>这儿我们使用Elastic官方提供的工具Kibana，该工具的 DevTools 功能可以使我们可以轻松方便的创建索引，及一些其它操作。</p><p>并且该工具还会进行关键字提示，相比Postman等工具更友好。</p><p>创建索引请求：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUT book</span><br></pre></td></tr></table></figure><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-731.png"></p><p>创建成功后通过head查看索引信息：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-732.png"></p><p>注意：</p><ul><li>索引名称不能有大写字母；</li><li>索引名唯一，不能重复，重复创建会报错。</li></ul><h3 id="更新索引"><a href="#更新索引" class="headerlink" title="更新索引"></a>更新索引</h3><p>索引创建好，可以修改其属性。</p><p>例如修改索引的副本数（从1变为2）。</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUT book/<span class="emphasis">_settings</span></span><br><span class="line"><span class="emphasis">&#123;</span></span><br><span class="line"><span class="emphasis">  &quot;number_</span>of<span class="emphasis">_replicas&quot;: 2</span></span><br><span class="line"><span class="emphasis">&#125;</span></span><br></pre></td></tr></table></figure><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-733.png"></p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-734.png"></p><h3 id="修改索引的读写权限"><a href="#修改索引的读写权限" class="headerlink" title="修改索引的读写权限"></a>修改索引的读写权限</h3><p>索引创建创建成功后，可以写入文档。</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUT book/<span class="emphasis">_doc/1</span></span><br><span class="line"><span class="emphasis">&#123;</span></span><br><span class="line"><span class="emphasis">  &quot;title&quot;:&quot;累觉不爱&quot;</span></span><br><span class="line"><span class="emphasis">&#125;</span></span><br></pre></td></tr></table></figure><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-735.png"></p><p>默认情况下，索引是具备读写权限的，这个读写权限可以关闭。</p><p>例如，关闭索引的写权限。</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUT book/<span class="emphasis">_settings</span></span><br><span class="line"><span class="emphasis">&#123;</span></span><br><span class="line"><span class="emphasis">  &quot;blocks.write&quot;: true</span></span><br><span class="line"><span class="emphasis">&#125;</span></span><br></pre></td></tr></table></figure><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-736.png"></p><p>如果想打开写权限将上述改为false即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUT book/_settings</span><br><span class="line">&#123;</span><br><span class="line">  &quot;blocks.write&quot;: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他权限有：</p><ul><li>blocks.read</li><li>blocks.read_only</li></ul><h3 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h3><p>head 插件可以查看，略。</p><p>Kibana请求查看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET book/_settings</span><br></pre></td></tr></table></figure><p>查看多个索引信息，用逗号隔开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET book,test/_settings</span><br></pre></td></tr></table></figure><p>查看所有索引信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET _all/_settings</span><br></pre></td></tr></table></figure><h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><p>head插件可以删除，略。</p><p>Kibana请求删除：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE book</span><br></pre></td></tr></table></figure><p>注意：删除不存在的索引会报错。</p><h3 id="索引的打开-关闭"><a href="#索引的打开-关闭" class="headerlink" title="索引的打开/关闭"></a>索引的打开/关闭</h3><p>关闭索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST book/_close</span><br></pre></td></tr></table></figure><p>打开索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST book/_open</span><br></pre></td></tr></table></figure><p>也可以同时打开或关闭多个索引，多个索引用”,”隔开，或者用“_all”表示全部索引。</p><h3 id="复制索引"><a href="#复制索引" class="headerlink" title="复制索引"></a>复制索引</h3><p>索引复制只会复制数据，不会复制索引配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST _reindex</span><br><span class="line">&#123;</span><br><span class="line">  &quot;source&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;book&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dest&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;book_new&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-737.png"></p><p>复制的时候可以添加查询条件。</p><h3 id="索引的别名"><a href="#索引的别名" class="headerlink" title="索引的别名"></a>索引的别名</h3><p>可以为索引创建别名，如果这个别名是唯一的，则该别名可以代替索引名称。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">POST /_aliases</span><br><span class="line">&#123;</span><br><span class="line">  &quot;actions&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;add&quot;: &#123;</span><br><span class="line">        &quot;index&quot;: &quot;book&quot;,</span><br><span class="line">        &quot;alias&quot;: &quot;book_alias&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-738.png"></p><p>将add改为remove即可以移除别名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">POST /_aliases</span><br><span class="line">&#123;</span><br><span class="line">  &quot;actions&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;remove&quot;: &#123;</span><br><span class="line">        &quot;index&quot;: &quot;book&quot;,</span><br><span class="line">        &quot;alias&quot;: &quot;book_alias&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以处理多个别名，添加或者删除，因为actions接受一个数组。</p><p>查看索引对应的别名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET book/_alias</span><br></pre></td></tr></table></figure><p>查看别名对应的索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET book_alias/_alias</span><br></pre></td></tr></table></figure><p>查看集群上所有的可用别名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /_alias</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h2 id=&quot;Elasticsearch索引管理&quot;&gt;&lt;a href=&quot;#Elasticsearch索引管理&quot; class=&quot;headerlink&quot; title=&quot;Elasticsearch索引管理&quot;&gt;&lt;/a&gt;Elasticsearch索引管理&lt;/h2&gt;&lt;p&gt;启动一个master节点和两个slave节点进行测试。&lt;/p&gt;
&lt;p&gt;启动Kibana，访问地址 &lt;a href=&quot;http://localhost:5601/&quot;&gt;http://localhost:5601&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;新建索引&quot;&gt;&lt;a href=&quot;#新建索引&quot; class=&quot;headerlink&quot; title=&quot;新建索引&quot;&gt;&lt;/a&gt;新建索引&lt;/h3&gt;</summary>
    
    
    
    <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Elasticsearch" scheme="https://www.sakuratears.top/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch学习笔记（3）</title>
    <link href="https://www.sakuratears.top/blog/Elasticsearch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89.html"/>
    <id>https://www.sakuratears.top/blog/Elasticsearch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89.html</id>
    <published>2021-06-03T13:56:00.000Z</published>
    <updated>2021-06-14T08:05:37.438Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇文章我们介绍了Elasticsearch的一些核心概念，本篇文章我们来看下Elasticsearch的分词器。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Elasticsearch分词器介绍"><a href="#Elasticsearch分词器介绍" class="headerlink" title="Elasticsearch分词器介绍"></a>Elasticsearch分词器介绍</h2><h3 id="内置分词器"><a href="#内置分词器" class="headerlink" title="内置分词器"></a>内置分词器</h3><p>Elasticsearch 核心功能就是数据检索，首先通过索引将文档写入es。查询分析则主要分为两个步骤：</p><ol><li>词条化：分词器将输入的文本转为一个个的词条流。</li><li>过滤：比如停用词过滤器会从词条中除去不相干的词条；另外还有同义词过滤器，小写过滤器等。</li></ol><p>Elasticsearch中内置了多种分词器可以供使用。</p><p>内置分词器：</p><table><thead><tr><th>分词器</th><th>作用</th></tr></thead><tbody><tr><td>Standard Analyzer</td><td>标准分词器，适用于英语等</td></tr><tr><td>Simple Analyzer</td><td>简单分词器，基于非字母字符进行分词，单词会被转为小写字母</td></tr><tr><td>Whitespace Analyzer</td><td>空格分词器，按照空格进行切分</td></tr><tr><td>Stop Analyzer</td><td>停用词分词器，类似于简单分词器，但是增加了停用词的功能</td></tr><tr><td>Keyword Analyzer</td><td>关键词分词器，输入文本等于输出文本（不分词）</td></tr><tr><td>Pattern Analyzer</td><td>利用正则表达式对文本进行切分的分词器，支持停用词</td></tr><tr><td>Language Analyzer</td><td>针对特定语言的分词器</td></tr><tr><td>Fingerprint Analyzer</td><td>指纹分析仪分词器，通过创建标记进行重复检测</td></tr></tbody></table><h3 id="中文分词器"><a href="#中文分词器" class="headerlink" title="中文分词器"></a>中文分词器</h3><p>在 ES 中，使用比较多的中文分词器是 elasticsearch-analysis-ik，这个是es的一个第三方插件，代码托管在 GitHub上：</p><ul><li><a href="https://github.com/medcl/elasticsearch-analysis-ik">https://github.com/medcl/elasticsearch-analysis-ik</a></li></ul><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>它提供了两种使用方式：</p><p>第一种：</p><ol><li>首先打开上述中文分词器地址：<a href="https://github.com/medcl/elasticsearch-analysis-ik">https://github.com/medcl/elasticsearch-analysis-ik</a></li><li>在 <a href="https://github.com/medcl/elasticsearch-analysis-ik/releases">https://github.com/medcl/elasticsearch-analysis-ik/releases</a> 页面找到最新的正式版，下载下来。</li><li>将下载文件解压。</li><li>在 es/plugins 目录下，新建ik目录，并将解压后的所有文件拷贝进去。</li><li>重启 es 服务。</li></ol><p>第二种：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.12.1/elasticsearch-analysis-ik-7.12.1.zip</span><br></pre></td></tr></table></figure><p>PS：</p><p>需要注意ES版本：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-722.png"></p><p>推荐第一种安装方式，我们可以方便的找到配置文件更改配置。</p><p>我们如果不下载安装包的话也可以自己编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/medcl/elasticsearch-analysis-ik</span><br><span class="line"><span class="built_in">cd</span> elasticsearch-analysis-ik</span><br><span class="line">git checkout tags/&#123;version&#125;</span><br><span class="line">mvn clean</span><br><span class="line">mvn compile</span><br><span class="line">mvn package</span><br></pre></td></tr></table></figure><p>需要注意版本。</p><p>Elasticsearch启动时会提示加载我们插件：</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-723.png"></p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>我们创建一个索引来测试一下：</p><p>这儿先使用Postman来测试一下，使用PUT请求创建TEST索引。</p><p>PUT <a href="http://localhost:9200/test">http://localhost:9200/test</a></p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-724.png"></p><p>在该索引中进行分词测试：</p><p>POST <a href="http://localhost:9200/test/_analyze">http://localhost:9200/test/_analyze</a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;analyzer&quot;</span>:<span class="string">&quot;ik_max_word&quot;</span>,</span><br><span class="line"><span class="attr">&quot;text&quot;</span>:<span class="string">&quot;美国留给伊拉克的是个烂摊子吗&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-725.png"></p><p>两种分词模式 <code>ik_max_word</code> 和 <code>ik_smart</code>， <code>ik_max_word</code> 的分词更细致。</p><p>如果我们对 累觉不爱 进行分析呢？</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-726.png"></p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-727.png"></p><p>可以看到哪种分法都不太符合我们的期望，我们想把 累觉不爱 看做一个词，该如何处理呢。</p><p>这就需要自定义扩展词库。</p><h4 id="自定义扩展词库"><a href="#自定义扩展词库" class="headerlink" title="自定义扩展词库"></a>自定义扩展词库</h4><h5 id="本地自定义"><a href="#本地自定义" class="headerlink" title="本地自定义"></a>本地自定义</h5><p>在 plugins/ik/config 目录下，新建 ext.dic 文件（文件名任意），在该文件中可以配置自定义词库。</p><p>在新建文件里添上我们的 累觉不爱 。（如果有多个词，换行写入即可）</p><p>同时打开该目录下的 IKAnalyzer.cfg.xml 文件，如下配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">properties</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;http://java.sun.com/dtd/properties.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">comment</span>&gt;</span>IK Analyzer 扩展配置<span class="tag">&lt;/<span class="name">comment</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--用户可以在这里配置自己的扩展字典 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ext_dict&quot;</span>&gt;</span>ext.dic<span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--用户可以在这里配置自己的扩展停止词字典--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ext_stopwords&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--用户可以在这里配置远程扩展字典 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;entry key=&quot;remote_ext_dict&quot;&gt;words_location&lt;/entry&gt; --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--用户可以在这里配置远程扩展停止词字典--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;entry key=&quot;remote_ext_stopwords&quot;&gt;words_location&lt;/entry&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>重启ES。</p><p>我们再用分词测试，可以看到两种分词模式都能得到我们想要的结果。</p><p><img data-src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-728.png"></p><h5 id="远程词库"><a href="#远程词库" class="headerlink" title="远程词库"></a>远程词库</h5><p>也可以配置远程词库，远程词库支持热更新（不用重启ES）。</p><p>热更新只需要提供一个接口，接口返回扩展词即可。</p><p>具体使用方式如下，新建一个 SpringBoot 项目，引入 Web 依赖即可，然后在 resource/static 文件夹下新建 ext.dic ，写入扩展词。</p><p>接下来在IKAnalyzer.cfg.xml 文件里配置远程扩展接口。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">comment</span>&gt;</span>IK Analyzer 扩展配置<span class="tag">&lt;/<span class="name">comment</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--用户可以在这里配置自己的扩展字典 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ext_dict&quot;</span>&gt;</span>ext.dic<span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--用户可以在这里配置自己的扩展停止词字典--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ext_stopwords&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--用户可以在这里配置远程扩展字典 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;remote_ext_dict&quot;</span>&gt;</span>http://localhost:8080/ext.dic<span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--用户可以在这里配置远程扩展停止词字典--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;entry key=&quot;remote_ext_stopwords&quot;&gt;words_location&lt;/entry&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>热更新，主要是响应头的 <code>Last_Modified</code> 或者 <code>ETag</code> 字段发生变化， ik 就会自动重新加载远程依赖扩展词典。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本文介绍了Elasticsearch 分词器，以及如何使用中文分词器，以及分词器的词库配置。</p>]]></content>
    
    
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; class=&quot;aplayer-secondary-script-marker&quot;&gt;&lt;/script&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上一篇文章我们介绍了Elasticsearch的一些核心概念，本篇文章我们来看下Elasticsearch的分词器。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h1&gt;&lt;h2 id=&quot;Elasticsearch分词器介绍&quot;&gt;&lt;a href=&quot;#Elasticsearch分词器介绍&quot; class=&quot;headerlink&quot; title=&quot;Elasticsearch分词器介绍&quot;&gt;&lt;/a&gt;Elasticsearch分词器介绍&lt;/h2&gt;</summary>
    
    
    
    <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Elasticsearch" scheme="https://www.sakuratears.top/tags/Elasticsearch/"/>
    
  </entry>
  
</feed>
