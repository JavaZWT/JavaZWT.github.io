<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SakuraTears的博客</title>
  
  <subtitle>越努力越幸运</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.sakuratears.top/"/>
  <updated>2018-10-14T03:56:00.987Z</updated>
  <id>https://www.sakuratears.top/</id>
  
  <author>
    <name>SakuraTears</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java8 接口</title>
    <link href="https://www.sakuratears.top/blog/Java8-%E6%8E%A5%E5%8F%A320181014/"/>
    <id>https://www.sakuratears.top/blog/Java8-接口20181014/</id>
    <published>2018-10-14T03:35:00.000Z</published>
    <updated>2018-10-14T03:56:00.987Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java 8已经推出相当长一段时间了，其中，接口部分有一些变化。我们来研究下它。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>我们知道，对于一个接口，如果我们声明好后，如果再想对其增加新的方法是困难的，因为我们要改变所有其实现类，也就是每个实现类都要对其新方法进行实现。如下图：</p><p><img src="/images/pasted-82.png" alt="upload successful"></p><p>这显然是不现实的，如果我们直接把方法写在实现类里，接口中没有此方法，就破坏了我们的多态性。</p><p>对于某些已经发布的应用，无论哪种做法都是比较繁重且不被推荐的。</p><h1 id="接口默认实现"><a href="#接口默认实现" class="headerlink" title="接口默认实现"></a>接口默认实现</h1><p>还好，Java大神们已经意识到了这个问题，于是在Java8中，引入了对接口的<strong>默认方法</strong>实现。</p><p>什么是默认方法实现呢？</p><p>简单来说，就是允许接口定义默认方法，在接口中需要有方法体的具体实现，实现类默认继承该方法（如果不重写默认方法的话）。同时为区分默认方法，默认方法在接口中采用default关键字标明。如下图：</p><p><img src="/images/pasted-83.png" alt="upload successful"></p><p>这样，如果我们新增一个接口方法（对于已经发布的接口），可以使用默认实现，就不会出现我们上述的问题。</p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>你一定会说，这和抽象类有什么区别呢？</p><p>当然还是有区别的，Java8以后，接口和抽象类的几点总结如下：</p><p><img src="/images/pasted-84.png" alt="upload successful"></p><h1 id="新的问题"><a href="#新的问题" class="headerlink" title="新的问题"></a>新的问题</h1><p>接口引入了默认方法后，就会有新的问题，好在Java已经替我们解决了，我们来看下。</p><h2 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Interface A"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Interface B"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span>, <span class="title">B</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> C().doSomething();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：输出 Interface B</p><h2 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">A</span>, <span class="title">B</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> C().doSomething();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：输出 Interface B</p><h2 id="情况三"><a href="#情况三" class="headerlink" title="情况三"></a>情况三</h2><p>如果D是这样呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Class D"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：输出Class D</p><p>如果D不对doSomething提供实现（D为抽象的类），则C需要为doSomething提供实现。</p><h2 id="情况四"><a href="#情况四" class="headerlink" title="情况四"></a>情况四</h2><p>如果B接口不在继承A接口。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Interface A"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Interface B"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们C类必须为doSomething提供实现，当然我们可以具体制定使用哪个接口的doSomething方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span>, <span class="title">B</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">B.<span class="keyword">super</span>.doSomething();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="情况五"><a href="#情况五" class="headerlink" title="情况五"></a>情况五</h2><p>如果两个函数不一样但差距很小呢？如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">long</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span>, <span class="title">B</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> C().doSomething();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在IDEA里我们可以看到，类C是无法编译的，这是不被允许的。</p><h2 id="情况六"><a href="#情况六" class="headerlink" title="情况六"></a>情况六</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Interface A"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">B</span>,<span class="title">C</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> D().doSomething();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果Interface A</p><p>因为只有A声明了一个默认方法，这个接口是D的父接口，故输出Interface A。如果B也提供了一个默认方法，签名和A一致，那么编译器会选择B的默认方法，如果B添加一个相同签名的抽象方法，则D需要为其提供实现，如果B,C都有相同签名的默认方法doSomething，则会出现冲突，需要我们为doSomething提供实现或者指定使用B，C中的哪个方法。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>解决问题的三条规则：</p><p>如果一个类使用相同的函数签名从多个地方（比如另一个类或者接口）继承了方法，通过三条规则可进行判断。</p><ol><li><p><strong>类中的方法优先级最高。类或者父类中声明的方法优先级高于任何声明为默认方法的优先级。</strong></p></li><li><p><strong>如果无法依据第一条判断，那么子接口的优先级更高：函数签名相同时，优先选择拥有最具体实现的默认方法的接口，及如果B继承了A，那么B就比A更加具体。</strong></p></li><li><p><strong>最后，如果还是无法判断，继承了多个接口的类必须通过显式覆盖和调用期望的方法，显式地选择使用哪一个默认方法的实现。</strong></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Java 8已经推出相当长一段时间了，其中，接口部分有一些变化。我们来研究下它。&lt;/p&gt;
&lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot;
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Callable原理分析</title>
    <link href="https://www.sakuratears.top/blog/Callable%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%9020181014/"/>
    <id>https://www.sakuratears.top/blog/Callable原理分析20181014/</id>
    <published>2018-10-14T03:21:00.000Z</published>
    <updated>2018-10-14T03:34:37.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天我们来分析实现多线程的一种方式，实现Callable接口。这种方式有种特殊的地方，就是可以拿到线程返回值。具体怎么实现的呢？我们来研究下。</p><h1 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h1><p>我们先举个简单的栗子来看下Callable接口吧。<br>要首先明白，线程池提交实现Callable接口的线程后会返回一个Future对象，这个对象里包含程序的运行结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException,TimeoutException</span>&#123;</span><br><span class="line">        <span class="comment">//创建一个线程池</span></span><br><span class="line">        ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">        Future&lt;String&gt; future = executor.submit(()-&gt; &#123;</span><br><span class="line">                <span class="comment">//System.out.println("CallableTest");</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"CallableTest"</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们可以通过future.get()拿到结果”CallableTest”。<br>我们也可以设置指定时间后拿到结果，如指定6s后拿到结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(future.get(<span class="number">4</span>,TimeUnit.SECONDS));</span><br></pre></td></tr></table></figure><p>可以看到也拿到了返回结果，如果我们设置4s拿到结果，小于程序运行时间5s，可以看到它抛出了超时异常。java.util.concurrent.TimeoutException。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>是不是很神奇？</p><p>我们来研究下Callable接口获取返回值的原理。</p><p>我们先来看看ExecutorService的submit方法，它接受一个Callable对象，返回一个Future对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br></pre></td></tr></table></figure><p>及它的实现。AbstractExecutorService的submit方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(callable);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br></pre></td></tr></table></figure><p>ThreadPoolExecutor的execute是对其实现。</p><p><img src="/images/pasted-80.png" alt="upload successful"></p><p>可以看到创建了一个FutureTask对象并执行。</p><p>FutureTask对象实现了Runable接口，我们来看下它。</p><p><img src="/images/pasted-81.png" alt="upload successful"></p><p>看一下它的run方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                     <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            <span class="keyword">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//拿到结果设置ran为true</span></span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="comment">//异常设置结果为空ran为false并设置异常</span></span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">                ran = <span class="keyword">false</span>;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//ran为true时放入结果</span></span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">        <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">        runner = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">        <span class="comment">// leaked interrupts</span></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="comment">//会一直挂起知道处理业务的线程完成，唤醒等待线程</span></span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们调用get方法时，他先查询线程状态，如果未完成，就调用awaitDone方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">     <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     <span class="comment">//如果设置了超时时间就获取截止时间</span></span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">     WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">     /循环监视线程的状态</span><br><span class="line">     <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">         <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">             removeWaiter(q);</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">int</span> s = state;</span><br><span class="line">         <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">             <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                 q.thread = <span class="keyword">null</span>;</span><br><span class="line">             <span class="keyword">return</span> s;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet</span></span><br><span class="line">             Thread.yield();</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</span><br><span class="line">             q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">             queued = UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,</span><br><span class="line">                                                  q.next = waiters, q);</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">             nanos = deadline - System.nanoTime();</span><br><span class="line">             <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                 removeWaiter(q);</span><br><span class="line">                 <span class="keyword">return</span> state;</span><br><span class="line">             &#125;</span><br><span class="line">             LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>带有超时时间的get，到达时间后，会判断线程状态，如果未完成，抛出超时异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING &amp;&amp;</span><br><span class="line">        (s = awaitDone(<span class="keyword">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>因此，带有返回值得异步线程基本上可以这样理解。</p><p>由于有返回值，如果未设置等待时间，会等线程执行完成后返回，基本类似同步。其原理是线程运行后，如果未完成，会放入等待队列。直到线程状态变化（完成或者异常等）。如果设置了等待时间，则到时间后无论线程状态是否完成都会返回线程状态。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天我们来分析实现多线程的一种方式，实现Callable接口。这种方式有种特殊的地方，就是可以拿到线程返回值。具体怎么实现的呢？我们来研究下
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>一道Java试题引发的思考</title>
    <link href="https://www.sakuratears.top/blog/%E4%B8%80%E9%81%93Java%E8%AF%95%E9%A2%98%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%8320181013/"/>
    <id>https://www.sakuratears.top/blog/一道Java试题引发的思考20181013/</id>
    <published>2018-10-13T15:47:00.000Z</published>
    <updated>2018-10-13T16:09:33.701Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>无意中看到了自己入门Java时的一本Java基础书，看到了其中一个小结的习题，颇为简单。<br>求一个数组所有数据的和。</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>那时入门Java，看到以前自己在书上写下的for循环。大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">sum</span><span class="params">(<span class="keyword">int</span> [] numbers)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> result=<span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.length;i++)&#123;</span><br><span class="line">        result+=numbers[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现已入行Java颇有时日，遂想到当n逐渐变大时，其执行效率会逐渐降低的。</p><p>近日对多线程有些许研究，故想到可以将数据平均分为2份，3份或者多份，每份进行和值，最后相加得到结果。也是一个不错的想法。</p><p>好在Java里有这么一个框架，名字叫<strong>分支/合并框架</strong>。我们来配合例子研究下。</p><h1 id="分支-合并框架"><a href="#分支-合并框架" class="headerlink" title="分支/合并框架"></a>分支/合并框架</h1><p><strong>分支/合并框架的目的是以递归的方式将可以并行的任务分为更小的任务，然后将每个子任务的结果合并起来生成整体的结果。它是ExecutorService接口的一个实现，它把子任务分配给线程池（ForkJoinPool）中的工作线程</strong>。那我们如何来定义任务和子任务呢？</p><p>要把任务提交到ForkJoinPool，必须创建<strong>RecursiveTask&lt; R &gt;的一个子类</strong>，其中R是并行化任务产生的结果类型。它其中有唯一一个抽象方法<strong>compute</strong>，用来定义将任务拆分成子任务的逻辑，以及无法再拆分或不方便拆分时，生成单个子任务结果的逻辑。</p><p>伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(任务足够小或者不可分)&#123;</span><br><span class="line">    顺序执行该任务</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">将任务分为两个子任务</span><br><span class="line">递归调用本方法，拆分每个子任务，等待所有子任务完成</span><br><span class="line">合并每个子任务结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那如何定义一个任务是否可以在拆分呢？</p><p>一般来说没有明确的标准决定一个任务是否可以在拆分，但是有几种试探方法可以帮助我们做出决定，分支/合并框架采用了一种称为<strong>工作窃取</strong>的技术来解决这个问题。每个线程的子任务都保存在一个双向链式队列里，每完成一个任务，就从队列头部获取一个任务，<strong>如果有线程先执行完成，它不会“闲”下来，而是去未完成的队列尾部“窃取”一个任务进行完成</strong>，直至所有子任务完成返回结果。</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>我们用分支/合并框架对数组数据进行并行求和。</p><p>代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinSumCalculator</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//要求和的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] numbers;</span><br><span class="line">    <span class="comment">//子任务处理的数组的起始位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="comment">//子任务处理的数组的终止位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不再将任务划分的子任务数组大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> THRESHOLD=<span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinSumCalculator</span><span class="params">(<span class="keyword">int</span>[] numbers)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(numbers,<span class="number">0</span>,numbers.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ForkJoinSumCalculator</span><span class="params">(<span class="keyword">int</span>[] numbers,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.numbers=numbers;</span><br><span class="line">        <span class="keyword">this</span>.start=start;</span><br><span class="line">        <span class="keyword">this</span>.end=end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length=end-start;</span><br><span class="line">        <span class="comment">//小于等于阈值，计算结果</span></span><br><span class="line">        <span class="keyword">if</span>(length&lt;=THRESHOLD)&#123;</span><br><span class="line">            <span class="keyword">return</span> computeSequentially();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建一个子任务来为数组的前一半求和</span></span><br><span class="line">        ForkJoinSumCalculator leftTask=<span class="keyword">new</span> ForkJoinSumCalculator(numbers,start,start+length/<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//利用另一个ForkJoinPool线程异步执行新创建的子任务</span></span><br><span class="line">        leftTask.fork();</span><br><span class="line">        <span class="comment">//创建一个任务为数组的后一半求和</span></span><br><span class="line">        ForkJoinSumCalculator rightTask=<span class="keyword">new</span> ForkJoinSumCalculator(numbers,start+length/<span class="number">2</span>,end);</span><br><span class="line">        <span class="comment">//同步执行第二个子任务，有可能允许进一步递归划分</span></span><br><span class="line">        Long rightResult=rightTask.compute();</span><br><span class="line">        <span class="comment">//读取第一个子任务的结果，没有完成就等待</span></span><br><span class="line">        Long leftResult=leftTask.join();</span><br><span class="line">        <span class="comment">//合并结果</span></span><br><span class="line">        <span class="keyword">return</span> rightResult+leftResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子任务数组求和</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">computeSequentially</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;end;i++)&#123;</span><br><span class="line">            sum+=numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们在编写一个方法并行对数组求和就很简单了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">forkJoinSum</span><span class="params">(<span class="keyword">int</span> [] numbers)</span></span>&#123;</span><br><span class="line">    ForkJoinTask&lt;Long&gt; task=<span class="keyword">new</span> ForkJoinSumCalculator(numbers);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool().invoke(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以写一个测试方法，测试这两种方法的执行效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//构建一个数组</span></span><br><span class="line">     <span class="keyword">int</span> [] numbers=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100000000</span>];</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.length;i++)&#123;</span><br><span class="line">         numbers[i]=(<span class="keyword">int</span>)(Math.random() * Integer.MAX_VALUE);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//分支/合并框架计算执行速度</span></span><br><span class="line">     <span class="keyword">long</span> fastest=Long.MAX_VALUE;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">         <span class="keyword">long</span> start=System.nanoTime();</span><br><span class="line">         forkJoinSum(numbers);</span><br><span class="line">         <span class="keyword">long</span> duration=(System.nanoTime()-start);</span><br><span class="line">         <span class="keyword">if</span>(duration&lt;fastest)&#123;</span><br><span class="line">             fastest=duration;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println(<span class="string">"分支/合并最快执行速度为"</span>+fastest+<span class="string">"ns"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="comment">//普通方法计算执行速度</span></span><br><span class="line">     <span class="keyword">long</span> fastest1=Long.MAX_VALUE;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">         <span class="keyword">long</span> start=System.nanoTime();</span><br><span class="line">         sum(numbers);</span><br><span class="line">         <span class="keyword">long</span> duration=(System.nanoTime()-start);</span><br><span class="line">         <span class="keyword">if</span>(duration&lt;fastest1)&#123;</span><br><span class="line">             fastest1=duration;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println(<span class="string">"普通算法最快执行速度为"</span>+fastest1+<span class="string">"ns"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">分支/合并最快执行速度为<span class="number">25894038</span>ns</span><br><span class="line">普通算法最快执行速度为<span class="number">38811709</span>ns</span><br></pre></td></tr></table></figure><p>可以看到速度是有明显提升的。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="源数据问题"><a href="#源数据问题" class="headerlink" title="源数据问题"></a>源数据问题</h2><p><strong>这个计算的数组之所以随机，是因为我之前测试了1-n的和计算，发现for循环居然比分支/合并框架快！！我加大了n值也是如此，所以对于这种比较特殊的计算，Java虚拟机或者编译器对它们的计算做了优化，因此用这些数据测试时，可能得不到我们想要的结果，这也是并发处理比较难的地方。有的时候我们多线程处理的代码可能还没有单线程快，或者快是快了，但结果错了。</strong></p><h2 id="拥抱Java8"><a href="#拥抱Java8" class="headerlink" title="拥抱Java8"></a>拥抱Java8</h2><p>看到上面我们为了求个和冒着出错的风险写了一个sum类，是不是心里退却了？不过啊，Java 8已经给我们提供了类似的功能啦。</p><p>它就是全新的Stream API，这个我们有时间在介绍。先看看Stream API对于这个是如何求和的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arrays.stream(numbers).sum();</span><br><span class="line">Arrays.stream(numbers).parallel().sum();</span><br></pre></td></tr></table></figure><p>是不是很简单？？</p><p>第一个为串行求和，即单线程，第二个为并行求和。</p><p>我们来测试下他们的效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Stream API 串行方法计算执行速度</span></span><br><span class="line">        <span class="keyword">long</span> fastest2=Long.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">long</span> start=System.nanoTime();</span><br><span class="line">            <span class="comment">//sum(numbers);</span></span><br><span class="line">            Arrays.stream(numbers).sum();</span><br><span class="line">            <span class="keyword">long</span> duration=(System.nanoTime()-start);</span><br><span class="line">            <span class="keyword">if</span>(duration&lt;fastest2)&#123;</span><br><span class="line">                fastest2=duration;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Stream API 串行 最快执行速度为"</span>+fastest2+<span class="string">"ns"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Stream API 并行方法计算执行速度</span></span><br><span class="line">        <span class="keyword">long</span> fastest3=Long.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">long</span> start=System.nanoTime();</span><br><span class="line">            <span class="comment">//sum(numbers);</span></span><br><span class="line">            Arrays.stream(numbers).parallel().sum();</span><br><span class="line">            <span class="keyword">long</span> duration=(System.nanoTime()-start);</span><br><span class="line">            <span class="keyword">if</span>(duration&lt;fastest3)&#123;</span><br><span class="line">                fastest3=duration;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Stream API 并行 最快执行速度为"</span>+fastest3+<span class="string">"ns"</span>);</span><br></pre></td></tr></table></figure><p>输出如下结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">分支/合并最快执行速度为<span class="number">25316712</span>ns</span><br><span class="line">普通算法最快执行速度为<span class="number">38812671</span>ns</span><br><span class="line">Stream API 串行 最快执行速度为<span class="number">36572646</span>ns</span><br><span class="line">Stream API 并行 最快执行速度为<span class="number">24291637</span>ns</span><br></pre></td></tr></table></figure><p>可以看到，并行情况下时间与刚才写的分支/合并框架相近。</p><p>其实：<strong>并行流背后使用的基础框架就是分支/合并框架。</strong></p><p>这只是最简单的求和例子，遇到实际问题，可能使用Stream流比普通实现简单快速，因此，Stream是值得我们学习的。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>学习就是不断思考不断进步的过程，有的时候看看自己之前写的代码，应该少一些“我去，写的什么玩意，原来？”之类的抱怨，多一些深入的思考及优化。</p><p>相关代码均已上传Github ： <a href="https://github.com/JavaZWT/framework-base" target="_blank" rel="noopener">https://github.com/JavaZWT/framework-base</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;无意中看到了自己入门Java时的一本Java基础书，看到了其中一个小结的习题，颇为简单。&lt;br&gt;求一个数组所有数据的和。&lt;/p&gt;
&lt;h1 i
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Spring Transactional注解</title>
    <link href="https://www.sakuratears.top/blog/Spring-Transactional%E6%B3%A8%E8%A7%A320181013/"/>
    <id>https://www.sakuratears.top/blog/Spring-Transactional注解20181013/</id>
    <published>2018-10-13T15:16:00.000Z</published>
    <updated>2018-10-13T15:45:49.549Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用@Transactional 注解有一段时间了，今天来对它进行下总结。</p><p>再说这个之前先说下事务。</p><p><strong>事务的基本要素（ACID）</strong></p><ol><li><p><strong>原子性（Atomicity）：</strong>事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。</p></li><li><p><strong>一致性（Consistency）：</strong>事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。</p></li><li><p><strong>隔离性（Isolation）：</strong>同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。</p></li><li><p><strong>持久性（Durability）：</strong>事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。</p></li></ol><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>Transactional注解的主要参数如下：</p><p><img src="/images/pasted-71.png" alt="upload successful"></p><p>下面来简单介绍下它的参数：</p><p><strong>value：一般用来配置指定的事务管理器。</strong></p><p><strong>propagation：事务的传播属性，有七种。见枚举Propagation，默认REQUIRED。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//支持当前事务，如果不存在就创建一个</span></span><br><span class="line">REQUIRED(TransactionDefinition.PROPAGATION_REQUIRED),</span><br><span class="line"><span class="comment">//支持当前事务，如果不存在就以非事务的方式运行</span></span><br><span class="line">SUPPORTS(TransactionDefinition.PROPAGATION_SUPPORTS),</span><br><span class="line"><span class="comment">//支持当前事务，不存在就抛出异常</span></span><br><span class="line">MANDATORY(TransactionDefinition.PROPAGATION_MANDATORY),</span><br><span class="line"><span class="comment">//创建一个新事务，如果当前有事务就暂停当前事务</span></span><br><span class="line">REQUIRES_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW),</span><br><span class="line"><span class="comment">//以非事务方式运行，如果当前有事务就暂停当前事务</span></span><br><span class="line">NOT_SUPPORTED(TransactionDefinition.PROPAGATION_NOT_SUPPORTED),</span><br><span class="line"><span class="comment">//以非事务的方式运行，如果当前有事务就抛出异常</span></span><br><span class="line">NEVER(TransactionDefinition.PROPAGATION_NEVER),</span><br><span class="line"><span class="comment">//如果当前有事务，就加入当前事务。</span></span><br><span class="line">NESTED(TransactionDefinition.PROPAGATION_NESTED);</span><br></pre></td></tr></table></figure><p><strong>isolation：隔离级别。事务的隔离级别有4种。我们看一下Isolation枚举类。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用默认的隔离级别，取决于底层数据库的默认隔离级别</span></span><br><span class="line">DEFAULT(TransactionDefinition.ISOLATION_DEFAULT),</span><br><span class="line"><span class="comment">//读未提交，这种隔离级别最低，会出现脏读，不可重复读，虚读（幻读）等情况。一般不用。</span></span><br><span class="line">READ_UNCOMMITTED(TransactionDefinition.ISOLATION_READ_UNCOMMITTED),</span><br><span class="line"><span class="comment">//读已提交，这种隔离级别可以防止脏读的产生，但是无法避免不可重复读和虚读（幻读）的出现。</span></span><br><span class="line">READ_COMMITTED(TransactionDefinition.ISOLATION_READ_COMMITTED),</span><br><span class="line"><span class="comment">//可重复读，这种隔离级别可以防止脏读、不可重复读的出现，但是无法避免虚读（幻读）的产生。</span></span><br><span class="line">REPEATABLE_READ(TransactionDefinition.ISOLATION_REPEATABLE_READ),</span><br><span class="line"><span class="comment">//串行化，这种隔离级别最高，可以避免脏读、不可重复读和虚读（幻读）的产生。</span></span><br><span class="line">SERIALIZABLE(TransactionDefinition.ISOLATION_SERIALIZABLE);</span><br></pre></td></tr></table></figure><p><strong>隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。</strong></p><p><strong>Mysql默认隔离级别为可重复读。</strong></p><p><strong>关于事务的并发问题</strong></p><ol><li><p><strong>脏读：</strong>事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</p></li><li><p><strong>不可重复读：</strong>事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。</p></li><li><p><strong>幻读：</strong>系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</p></li></ol><p>小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。</p><p><strong>timeout : 事务的超时时间，默认为-1，即事务直到完成都不会超时。</strong></p><p><strong>readOnly：是否只读，一般用来标识。拥有这个标识，写入操作不一定会失败，取决于数据库系统。</strong></p><p><strong>rollbackFor：事务回滚条件。参数为继承Throwable的class类。</strong></p><p><strong>rollbackForClassName：事务回滚条件。可以接受String数组。</strong></p><p><strong>noRollbackFor： 事务不会回滚条件。</strong></p><p><strong>noRollbackForClassName：事务不会回滚条件。</strong></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>Spring的Transaction注解是如何实现并生效的呢？我们来探究下。</p><ol><li><p>我们首先来看看SpringTransactionAnnotationParser这个类，这个是解析transaction注解的类。<br><img src="/images/pasted-72.png" alt="upload successful"><br>调用AnnotationUtils类的getAnnotation方法拿到注解信息。<br><img src="/images/pasted-73.png" alt="upload successful"></p></li><li><p>可以看到AnnotationTransactionAttributeSource这个类调用了parseTransactionAnnotation方法。<br><img src="/images/pasted-74.png" alt="upload successful"><br><img src="/images/pasted-75.png" alt="upload successful"></p></li><li><p>我们来看下AbstractFallbackTransactionAttributeSource这个类的computeTransactionAttribute方法。调用了上图的findTransactionAttribute方法。<br><img src="/images/pasted-76.png" alt="upload successful"><br><img src="/images/pasted-77.png" alt="upload successful"><br>getTransactionAttribute方法，由于获取注解信息耗时，故spring先从缓存里获取注解事务信息，查不到在用程序获取。</p></li><li><p>TransactionAspectSupport这个类的createTransactionIfNecessary方法，调用getTransactionAttribute方法。<br><img src="/images/pasted-78.png" alt="upload successful"></p></li><li><p>我们可以看到AbstractTransactionAspect.aj文件使用了createTransactionIfNecessary方法。<br><img src="/images/pasted-79.png" alt="upload successful"><br>这个应用了aspectj。<br>Before指在事务开始之前获取注解信息。<br>After throwing 指当方法抛出异常后的执行动作。这里一般会进行回滚操作。<br>After returning指当方法返回前的执行动作。这里一般会提交事务。<br>After 指当事务完成后的动作。这里会清空当前事务注解信息。</p></li></ol><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>事务的隔离级别和传播属性都是我们应该掌握和学习的，对于Spring的@Transactional 注解，我们不但要会使用，而且应该深入去理解它的实现原理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;使用@Transactional 注解有一段时间了，今天来对它进行下总结。&lt;/p&gt;
&lt;p&gt;再说这个之前先说下事务。&lt;/p&gt;
&lt;p&gt;&lt;stro
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>一道面试题引发的思考（递归）</title>
    <link href="https://www.sakuratears.top/blog/%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%8320181003/"/>
    <id>https://www.sakuratears.top/blog/一道面试题引发的思考20181003/</id>
    <published>2018-10-03T00:43:00.000Z</published>
    <updated>2018-10-03T03:31:00.830Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>某日，去某互联网公司面试，被问到了如下一道面试题：</p><p><strong>题目很简单，有一队人，已知第一个人8岁，后一个人比前一个人大两岁，以此类推，问第8个人多少岁？第N个人多少岁。</strong></p><p>我拿过笔和纸，不假思索的写下了如下答案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getAge(n-<span class="number">1</span>)+<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>面试官又问我还有什么需要注意的吗？我说要注意参数不能小于1.</p><p>显然，面试官不是很满意，又问我如果N很大会怎么样？</p><p>我想了想，说，会出现OOM异常吧，或者超了int的范围。</p><p>感觉他还是不满意。</p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>自那过去一段时间，我自认为答得没有问题，也答到了点上（只可惜面试没过~O(∩_∩)O哈哈~）。</p><p>最近又想到了这个问题，决定研究研究。</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>我用自己的方法，进行了数据测试。当然我把为了测试效果明显，我加大了测试值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">System.out.println(getAge(<span class="number">1000000</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果使我惊讶，不是OOM异常，而是堆栈异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.StackOverflowError</span><br></pre></td></tr></table></figure><p>后面我了解到，递归调用，可以假想成一个函数调用另一个函数，而每个函数相当于占用一个栈帧，这些栈帧以先进后出的方式排列起来形成栈。如下图：</p><p><img src="/images/pasted-68.png" alt="upload successful"></p><p>这样，函数会追寻到栈顶，拿到getAge(1)的值后逐渐返回。如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getAge(<span class="number">1</span>)=<span class="number">8</span></span><br><span class="line">getAge(<span class="number">2</span>)=getAge(<span class="number">1</span>)+<span class="number">2</span>=<span class="number">10</span></span><br><span class="line">getAge(<span class="number">3</span>)=getAge(<span class="number">2</span>)+<span class="number">2</span>=<span class="number">12</span></span><br><span class="line">getAge(<span class="number">4</span>)=getAge(<span class="number">3</span>)+<span class="number">2</span>=<span class="number">14</span></span><br></pre></td></tr></table></figure><p>可以知道，如果堆栈深度不够的话，就会出现异常。</p><p>我们上图所示的异常就是这个原因。</p><h1 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h1><h2 id="改进一"><a href="#改进一" class="headerlink" title="改进一"></a>改进一</h2><p>在研究这个问题时，我发现了一种递归，尾递归。</p><p>如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getAge1</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> result)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getAge1(n-<span class="number">1</span>,result+<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种递归我们可以看到，带了一个参数result，当他运行到n==1时，直接返回了result，不用在一层层回退进行计算。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  getAge(<span class="number">4</span>,<span class="number">8</span>)</span><br><span class="line">= getAge(<span class="number">3</span>,<span class="number">8</span>+<span class="number">2</span>)</span><br><span class="line">= getAge(<span class="number">2</span>,<span class="number">8</span>+<span class="number">2</span>+<span class="number">2</span>)</span><br><span class="line">= getAge(<span class="number">1</span>,<span class="number">8</span>+<span class="number">2</span>+<span class="number">2</span>+<span class="number">2</span>)</span><br><span class="line">= <span class="number">14</span></span><br></pre></td></tr></table></figure><p>一些编译器发现这些函数可以在一个栈帧里进行完成，就会复用栈帧，优化代码。</p><p>可惜的是，到目前为止，JAVA在HotSpot（Oracle的JVM）上使用时，并不支持尾递归优化。<br>据说IBM的JVM支持尾递归优化，有兴趣的童鞋可以试下。</p><p>所以这种方案的测试结果肯定也是StackOverflowError啦。</p><h2 id="改进二"><a href="#改进二" class="headerlink" title="改进二"></a>改进二</h2><p>循环解决:</p><p>那时脑子笨，现在想想，这道题用循环也是可以解决的，且不用担心堆栈溢出问题。如下：</p><p>While循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getAge2</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> result,<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        result+=step;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>For循环:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getAge3</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> firstValue,<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;end;i++)&#123;</span><br><span class="line">        firstValue+=step;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> firstValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>且速度也提高了不少。</p><h2 id="改进三"><a href="#改进三" class="headerlink" title="改进三"></a>改进三</h2><p>这么有规律的数据，当然乘法就可以解决，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getAge4</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> firstValue,<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> firstValue+(end-start)*step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上例子没有对入参做校验处理，结合实际场景，其实需要处理的，在此略掉了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>JDK源码中很少有递归，因为递归不能被优化，当数据过大时，很容易出现堆栈溢出，我们也应该慎用，基本能有递归解决的问题也可以用循环解决。</p><p>可以看出，对于一个问题，实现的方案可能不止一种。</p><p>看到自己想了及总结了多种方法，感觉很诧异，面试时却只想到了递归一种，而且实现很不好。还是自己基础不够扎实，应该多学多看多练。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>上面都说要多学多看多练啦…..</p><p>这是我测试IBM JDK对于尾递归（getAge1方法）的结果。</p><p><img src="/images/pasted-69.png" alt="upload successful"></p><p><img src="/images/pasted-70.png" alt="upload successful"></p><p>说明IBM JDK确实对尾递归有优化，我又测试了getAge方法（普通递归），结果和Oracle JDK一样，抛出 java.lang.StackOverflowError 异常。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;某日，去某互联网公司面试，被问到了如下一道面试题：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题目很简单，有一队人，已知第一个人8岁，后一个人比前一个人
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>基于注解的通用数据验证</title>
    <link href="https://www.sakuratears.top/blog/%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E9%80%9A%E7%94%A8%E6%95%B0%E6%8D%AE%E9%AA%8C%E8%AF%8120180924/"/>
    <id>https://www.sakuratears.top/blog/基于注解的通用数据验证20180924/</id>
    <published>2018-09-24T04:31:00.000Z</published>
    <updated>2018-09-24T05:11:29.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在项目开发交互过程中，难免会遇到一些数据校验。以校验客户端发送数据的合法性，对于一些非空校验，我们也许可以使用@NonNull，@NotNull 等注解，可是对于一些常规的，如手机号，身份证等等的校验，我们就还要判断处理每个请求的参数的合法性。</p><p>但是合法性的判断是难以避免的，我们是否可以精简工作量、提高工作效率呢。</p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>我们或许应该从@NonNull @NotNull等其他注解那里受到些启发。</p><p>我们或许可以结合正则表达式及注解对某些通用数据进行验证。</p><p>注解可以设置参数，我们可以设置参数为校验规则，通过枚举列举出来，同时也应该允许用户自定义正则等校验。</p><p>我们知道，注解有三种类型</p><p>RetentionPolicy.SOURCE</p><p>RetentionPolicy.CLASS</p><p>RetentionPolicy.RUNTIME。</p><p>SOURCE主要用于编译之前，编译过程中会被丢弃如@Override注解。</p><p>CLASS主要用于编译，运行时会被丢弃。</p><p>RUNTIME在源码，编译，运行时始终会存在。</p><p>可以利用反射，拿到具有特定注解的bean，并处理。所以我们定义的注解应该是RUNTIME类型。同时声明注作用范围为FIELD及PARAMETER。</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据验证注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD,ElementType.PARAMETER&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DataValid &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否可以为空</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">nullable</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供几种常用的正则验证</span></span><br><span class="line"><span class="function">RegexType <span class="title">regexType</span><span class="params">()</span> <span class="keyword">default</span> RegexType.NONE</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义正则验证</span></span><br><span class="line"><span class="function">String <span class="title">regexExpression</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数或者字段描述</span></span><br><span class="line"><span class="function">String <span class="title">description</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义如上注解，nullable用来校验参数是否可空，默认不可以为空，false。</p><p>同时提供几种通用的正则校验，用枚举列出，如手机号码校验，身份证信息校验等等。</p><p>同时如果没有规定的正则表达式，可以让用户自定义自己的正则表达式。</p><p>另增加描述字段，用来说明这个paramer的用途。</p><h2 id="定义常用正则枚举"><a href="#定义常用正则枚举" class="headerlink" title="定义常用正则枚举"></a>定义常用正则枚举</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正则类型枚举</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RegexType &#123;</span><br><span class="line"></span><br><span class="line">NONE,</span><br><span class="line">SPECIALCHAR,</span><br><span class="line">CHINESE,</span><br><span class="line">EMAIL,</span><br><span class="line">IP, </span><br><span class="line">NUMBER,</span><br><span class="line">NUMBERORNIL,</span><br><span class="line">PHONENUMBER,</span><br><span class="line">ID;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>列出几种常用枚举。非空，特殊字符，中文，邮箱，IP，数字等等</p><h2 id="枚举规则"><a href="#枚举规则" class="headerlink" title="枚举规则"></a>枚举规则</h2><p>定义了枚举，要定义它们的具体对应的方法，以便后续调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 常用正则表达式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegexUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否是正确的IP地址</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ip</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean true,通过，false，没通过</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isIp</span><span class="params">(String ip)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == ip || <span class="string">""</span>.equals(ip))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">String regex = <span class="string">"^(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|[1-9])\\."</span></span><br><span class="line">+ <span class="string">"(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\."</span></span><br><span class="line">+ <span class="string">"(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\."</span></span><br><span class="line">+ <span class="string">"(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)$"</span>;</span><br><span class="line"><span class="keyword">return</span> ip.matches(regex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否是正确的邮箱地址</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> email</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean true,通过，false，没通过</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isEmail</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == email || <span class="string">""</span>.equals(email))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">String regex = <span class="string">"\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*"</span>;</span><br><span class="line"><span class="keyword">return</span> email.matches(regex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否含有中文，仅适合中国汉字，不包括标点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> text</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean true,通过，false，没通过</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isChinese</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == text || <span class="string">""</span>.equals(text))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">Pattern p = Pattern.compile(<span class="string">"[\u4e00-\u9fa5]"</span>);</span><br><span class="line">Matcher m = p.matcher(text);</span><br><span class="line"><span class="keyword">return</span> m.find();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否正整数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> number</span></span><br><span class="line"><span class="comment"> *            数字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean true,通过，false，没通过</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String number)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == number || <span class="string">""</span>.equals(number))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">String regex = <span class="string">"[0-9]*"</span>;</span><br><span class="line"><span class="keyword">return</span> number.matches(regex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否正整数(可以为空)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> number</span></span><br><span class="line"><span class="comment"> *            数字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean true,通过，false，没通过</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNumberOrNil</span><span class="params">(String number)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">null</span> == number) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">""</span>.equals(number.trim())) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">String regex = <span class="string">"[0-9]*"</span>;</span><br><span class="line"><span class="keyword">return</span> number.matches(regex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断几位小数(正数)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> decimal</span></span><br><span class="line"><span class="comment"> *            数字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> count</span></span><br><span class="line"><span class="comment"> *            小数位数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean true,通过，false，没通过</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isDecimal</span><span class="params">(String decimal, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == decimal || <span class="string">""</span>.equals(decimal))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">String regex = <span class="string">"^(-)?(([1-9]&#123;1&#125;\\d*)|([0]&#123;1&#125;))(\\.(\\d)&#123;"</span> + count</span><br><span class="line">+ <span class="string">"&#125;)?$"</span>;</span><br><span class="line"><span class="keyword">return</span> decimal.matches(regex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否是手机号码</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> phoneNumber</span></span><br><span class="line"><span class="comment"> *            手机号码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean true,通过，false，没通过</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPhoneNumber</span><span class="params">(String phoneNumber)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == phoneNumber || <span class="string">""</span>.equals(phoneNumber))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">String regex = <span class="string">"^1[3|4|5|6|7|8|9][0-9]\\d&#123;8&#125;$"</span>;</span><br><span class="line"><span class="keyword">return</span> phoneNumber.matches(regex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断身份证号格式正确性</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ID</span></span><br><span class="line"><span class="comment"> *        身份证号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean true,通过，false，没通过</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isID</span><span class="params">(String ID)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == ID || <span class="string">""</span>.equals(ID))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">String regex = <span class="string">"^(\\d&#123;14&#125;[0-9a-zA-Z])|(\\d&#123;17&#125;[0-9a-zA-Z])$"</span>;</span><br><span class="line"><span class="keyword">return</span> ID.matches(regex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否含有特殊字符</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> text</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean true,通过，false，没通过</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasSpecialChar</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == text || <span class="string">""</span>.equals(text))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (text.replaceAll(<span class="string">"[a-z]*[A-Z]*\\d*-*_*\\s*"</span>, <span class="string">""</span>).length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 如果不包含特殊字符</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适应CJK（中日韩）字符集，部分中日韩的字是一样的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isChinese2</span><span class="params">(String strName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span>[] ch = strName.toCharArray();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ch.length; i++) &#123;</span><br><span class="line"><span class="keyword">char</span> c = ch[i];</span><br><span class="line"><span class="keyword">if</span> (isChinese(c)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isChinese</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">Character.UnicodeBlock ub = Character.UnicodeBlock.of(c);</span><br><span class="line"><span class="keyword">if</span> (ub == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS</span><br><span class="line">|| ub == Character.UnicodeBlock.CJK_COMPATIBILITY_IDEOGRAPHS</span><br><span class="line">|| ub == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A</span><br><span class="line">|| ub == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS_EXTENSION_B</span><br><span class="line">|| ub == Character.UnicodeBlock.CJK_SYMBOLS_AND_PUNCTUATION</span><br><span class="line">|| ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS</span><br><span class="line">|| ub == Character.UnicodeBlock.GENERAL_PUNCTUATION) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现及调用"><a href="#实现及调用" class="headerlink" title="实现及调用"></a>实现及调用</h2><p>基本数据都定义及处理好了，我们应该建立注解与方法之间的关联，RUNTIME类型的注解在程序运行时也会被保留，我们可以利用反射，拿到具体注解参数信息，进行相关处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解解析Service</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidateService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*private static DataValid dataValid;*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ValidateService</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析入口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">valid</span><span class="params">(Object object)</span> <span class="keyword">throws</span>  Exception</span>&#123;</span><br><span class="line"><span class="comment">//获取object的类型</span></span><br><span class="line">Class&lt;? extends Object&gt; clazz=object.getClass();</span><br><span class="line"><span class="comment">//获取该类型声明的成员</span></span><br><span class="line">Field[] fields=clazz.getDeclaredFields();</span><br><span class="line"><span class="comment">//遍历属性</span></span><br><span class="line"><span class="keyword">for</span>(Field field:fields)&#123;</span><br><span class="line"><span class="comment">//对于private私有化的成员变量，通过setAccessible来修改器访问权限</span></span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">validate(field,object);</span><br><span class="line"><span class="comment">//重新设置会私有权限</span></span><br><span class="line">field.setAccessible(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">(Field field,Object object)</span> <span class="keyword">throws</span>  Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">String  description = <span class="keyword">null</span>;</span><br><span class="line">Object        value = <span class="keyword">null</span>;</span><br><span class="line">DataValid dataValid = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取对象的成员的注解信息</span></span><br><span class="line">dataValid=field.getAnnotation(DataValid.class);</span><br><span class="line">value=field.get(object);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dataValid==<span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">description=dataValid.description().equals(<span class="string">""</span>)?field.getName():dataValid.description();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************注解解析工作开始******************/</span></span><br><span class="line"><span class="keyword">if</span>(!dataValid.nullable() &amp;&amp; dataValid.regexType() != RegexType.NUMBERORNIL)&#123;</span><br><span class="line"><span class="keyword">if</span>(value==<span class="keyword">null</span>|| StringUtils.isBlank(value.toString()))&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception(description+<span class="string">"不能为空"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dataValid.regexType()!=RegexType.NONE)&#123;</span><br><span class="line"><span class="keyword">switch</span> (dataValid.regexType()) &#123;</span><br><span class="line"><span class="keyword">case</span> NONE:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SPECIALCHAR:</span><br><span class="line"><span class="keyword">if</span>(RegexUtils.hasSpecialChar(value.toString()))&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception(description+<span class="string">"不能含有特殊字符"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CHINESE:</span><br><span class="line"><span class="keyword">if</span>(RegexUtils.isChinese2(value.toString()))&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception(description+<span class="string">"不能含有中文字符"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> EMAIL:</span><br><span class="line"><span class="keyword">if</span>(!RegexUtils.isEmail(value.toString()))&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception(description+<span class="string">"邮箱地址格式不正确"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> IP:</span><br><span class="line"><span class="keyword">if</span>(!RegexUtils.isIp(value.toString()))&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception(description+<span class="string">"IP地址格式不正确"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> NUMBER:</span><br><span class="line"><span class="keyword">if</span>(!RegexUtils.isNumber(value.toString()))&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception(description+<span class="string">"不是数字"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> NUMBERORNIL:</span><br><span class="line"><span class="keyword">if</span>(value == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!RegexUtils.isNumberOrNil(value.toString()))&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception(description+<span class="string">"格式不正确"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> PHONENUMBER:</span><br><span class="line"><span class="keyword">if</span>(!RegexUtils.isPhoneNumber(value.toString()))&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"手机号格式不正确"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> ID:</span><br><span class="line"><span class="keyword">if</span>(!RegexUtils.isID(value.toString()))&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"身份证号格式不正确"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!dataValid.regexExpression().equals(<span class="string">""</span>))&#123;</span><br><span class="line"><span class="keyword">if</span>(value.toString().matches(dataValid.regexExpression()))&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception(description+<span class="string">"格式不正确"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*************注解解析工作结束******************/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码。</p><p>当然，到具体业务层，应该调用这个Service的valid方法去校验参数。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>可以看到，经过这样，我们可以把一些常用的校验通过这种方式封装，大大简化代码量，使业务层更注重业务。</p><p>这种也可以添加自己的通用类型，灵活性很强。</p><p>这个小小的简单工具最主要的就是利用了Java的反射机制。</p><p>以上。</p><p>今天就到这里啦，中秋节快乐～～</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在项目开发交互过程中，难免会遇到一些数据校验。以校验客户端发送数据的合法性，对于一些非空校验，我们也许可以使用@NonNull，@NotNu
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JDK里那些有趣的代码（1）</title>
    <link href="https://www.sakuratears.top/blog/JDK%E9%87%8C%E9%82%A3%E4%BA%9B%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%881%EF%BC%8920180916/"/>
    <id>https://www.sakuratears.top/blog/JDK里那些有趣的代码（1）20180916/</id>
    <published>2018-09-16T15:34:00.000Z</published>
    <updated>2018-09-16T16:19:25.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天我们来看一下JDK里一些好玩的代码。我们来分析下。</p><p>在Integer源码里，我们可以看到这样一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> [] sizeTable = &#123; <span class="number">9</span>, <span class="number">99</span>, <span class="number">999</span>, <span class="number">9999</span>, <span class="number">99999</span>, <span class="number">999999</span>, <span class="number">9999999</span>,<span class="number">99999999</span>, <span class="number">999999999</span>, Integer.MAX_VALUE &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Requires positive x</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">stringSize1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; ; i++)</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= sizeTable[i])</span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是在干啥？？？</p><p>我们仔细读下，其实就会发现他其实是计算传入的int型x的位数，要求x为正数。</p><p>嗯，不难理解。</p><p>他为什么要这么写呢？</p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>对于我们来讲，当拿到一个int型正整数，如何用程序算出它的位数呢？</p><p>一般不假思索的可能想到String的length方法计算。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">myStringSize1</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> String.valueOf(x).length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯，代码量很少。。。。。。</p><p>还有吗？</p><p>对，还可以用除法，除以10，计算位数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">myStringSize2</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> num=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">while</span>(x&gt;<span class="number">10</span>)&#123;</span><br><span class="line">        x=x/<span class="number">10</span>;</span><br><span class="line">        num++;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯。。。。不错不错～</p><p>当然能用除法解决的基本上也可以用乘法解决，int的最大位数为10位，所以可以乘以10，判断大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Requires positive x</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">stringSize2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">11</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; p)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        p = <span class="number">10</span>*p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好吧，目前我就想到了除JDK以外的这三种方法。</p><p>我们测试一下我们的代码正确性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> [] x=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">5</span>,<span class="number">10</span>,<span class="number">333</span>,<span class="number">6666</span>,<span class="number">77777</span>,<span class="number">123456</span>,<span class="number">1234567</span>,<span class="number">87654321</span>,<span class="number">999999999</span>,<span class="number">1111111111</span>,Integer.MAX_VALUE&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;x.length;i++)&#123;</span><br><span class="line">       <span class="keyword">int</span> a1=Test.stringSize1(x[i]);</span><br><span class="line">       <span class="keyword">int</span> a2=Test.stringSize2(x[i]);</span><br><span class="line">       <span class="keyword">int</span> a3=Test.myStringSize1(x[i]);</span><br><span class="line">       <span class="keyword">int</span> a4=Test.myStringSize2(x[i]);</span><br><span class="line">       System.out.println(a1+<span class="string">"---"</span>+a2+<span class="string">"---"</span>+a3+<span class="string">"---"</span>+a4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/images/pasted-65.png" alt="upload successful"></p><p>结果还是木有问题哒。</p><h1 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h1><p><strong>JDK的这种写法有什么好处呢？？？</strong></p><p>可以看到，JDK的方法把一部分数据计算变成了数据比较，相当于优化吧。</p><p>那它的执行效率怎么样呢？</p><p>我们写的方法的效率又如何呢？</p><p>我们来测试下吧！</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>我们可以制造一个随机的定长int数组，看看它们执行耗时，同时统计若干组数据，进行比较。</p><p>话不多说，直接写代码并记录到Excel里供分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>  Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;Long&gt;&gt; rowList= Lists.newArrayList();</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; titleList=Lists.newArrayList();</span><br><span class="line">        titleList.add(<span class="string">"JDK方法"</span>);</span><br><span class="line">        titleList.add(<span class="string">"乘法"</span>);</span><br><span class="line">        titleList.add(<span class="string">"String方法"</span>);</span><br><span class="line">        titleList.add(<span class="string">"除法"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>;s&lt;<span class="number">50</span>;s++)&#123;</span><br><span class="line"></span><br><span class="line">            List&lt;Long&gt; cellList=Lists.newArrayList();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> [] xArrays=<span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">10000</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;xArrays.length;i++)&#123;</span><br><span class="line">                xArrays[i]=<span class="number">1</span> + (<span class="keyword">int</span>)(Math.random()*Integer.MAX_VALUE);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//System.out.println("当前S值为"+s);</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> start1=System.nanoTime();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;xArrays.length;i++) &#123;</span><br><span class="line">                stringSize1(xArrays[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> end1=System.nanoTime();</span><br><span class="line">            <span class="keyword">long</span> time1=(end1-start1)/<span class="number">1000</span>;</span><br><span class="line">            System.out.println(<span class="string">"JDK方法耗时---》"</span>+time1+<span class="string">"ms"</span>);</span><br><span class="line">            cellList.add(time1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> start4=System.nanoTime();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;xArrays.length;i++) &#123;</span><br><span class="line">                stringSize2(xArrays[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> end4=System.nanoTime();</span><br><span class="line">            <span class="keyword">long</span> time4=(end4-start4)/<span class="number">1000</span>;</span><br><span class="line">            System.out.println(<span class="string">"乘法耗时---》"</span>+time4+<span class="string">"ms"</span>);</span><br><span class="line">            cellList.add(time4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> start2=System.nanoTime();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;xArrays.length;i++) &#123;</span><br><span class="line">                myStringSize1(xArrays[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> end2=System.nanoTime();</span><br><span class="line">            <span class="keyword">long</span> time2=(end2-start2)/<span class="number">1000</span>;</span><br><span class="line">            System.out.println(<span class="string">"String方法耗时---》"</span>+time2+<span class="string">"ms"</span>);</span><br><span class="line">            cellList.add(time2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> start3=System.nanoTime();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;xArrays.length;i++) &#123;</span><br><span class="line">                myStringSize2(xArrays[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> end3=System.nanoTime();</span><br><span class="line">            <span class="keyword">long</span> time3=(end3-start3)/<span class="number">1000</span>;</span><br><span class="line">            System.out.println(<span class="string">"除法耗时---》"</span>+time3+<span class="string">"ms"</span>);</span><br><span class="line">            cellList.add(time3);</span><br><span class="line"></span><br><span class="line">            rowList.add(cellList);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        WriteExcelUtil.writeExecl(titleList,rowList,<span class="string">"/Users/zhangwentong/Desktop/workbook.xlsx"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我记录了50组数据，每组里面每个计算位数的方法执行10000次，得到如下结果。</p><p><img src="/images/pasted-66.png" alt="upload successful"></p><p>把它绘制成折线图。</p><p><img src="/images/pasted-67.png" alt="upload successful"></p><p>可以看到，String的length方法效率是最差的。。。。</p><p>我们其实看一下String.valueOf(x).length()这个源码，就知道为什么这么慢了。</p><p>然后除法也稍微逊色一点。。。</p><p>乘法和JDK的效率都可以说不错。。。。。但JDK方法其实要好一点。。。。</p><p>而且开始创建的sizeTable是占据较少空间，但却降低了CPU的计算次数（乘法需要每次乘以十在比较计算）。</p><p>当然，因为int的位数只有10位，可以写一个sizeTable，当数据量大时，比如long，最大19位，写一个19个数的sizeTable？ 一堆9？？？</p><p>哈哈，我们可以看看Long里面的计算位数的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Requires positive x</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">stringSize</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> p = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">19</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; p)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        p = <span class="number">10</span>*p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">19</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>人家当然用的乘法啦。。。。。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>我们可以看到，我们最容易想到的String.length方法确是效率最低的。。。。</p><p>JDK源码里一些方法会被大量调用，当然要做到最好的优化啦。。。</p><p>多读些源码，深入思考，多加练习，有助于提升自己。</p><p>今天就到这儿吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天我们来看一下JDK里一些好玩的代码。我们来分析下。&lt;/p&gt;
&lt;p&gt;在Integer源码里，我们可以看到这样一段代码：&lt;/p&gt;
&lt;figu
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>（转）线上某应用的FULLGC分析</title>
    <link href="https://www.sakuratears.top/blog/%E8%BD%AC-%E7%BA%BF%E4%B8%8A%E6%9F%90%E5%BA%94%E7%94%A8%E7%9A%84FULLGC%E5%88%86%E6%9E%9020180831/"/>
    <id>https://www.sakuratears.top/blog/转-线上某应用的FULLGC分析20180831/</id>
    <published>2018-08-31T13:28:00.000Z</published>
    <updated>2018-08-31T13:35:47.260Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接：<a href="http://jm.taobao.org/2016/03/23/3782/" target="_blank" rel="noopener">http://jm.taobao.org/2016/03/23/3782/</a></p></blockquote><p>这2天，排除线上某应用启动内存变化频繁的问题时，额外发现了一个fullgc的问题，分享给大家。</p><p>过程如下：抽了台线上机器，想看下这段时间机器的gc情况，发现里面有好几个FullGc的日志：</p><pre><code>T23:23:02.009+0800: 21860.015: [Full GC 21860.015: [CMS: 2361237K-&amp;gt;1111804K(4718592K), 4.9917540 secs] 2532961K-&amp;gt;1111804K(5190464K), [CMS Perm : 17397K-&amp;gt;17240K(131072K)], 4.9918770 secs] [Times: user=4.96 sys=0.03, real=4.99 secs]</code></pre><p>JVM参数设置如下：</p><pre><code>-XX:+UseCMSInitiatingOccupancyOnly-XX:CMSInitiatingOccupancyFraction=60</code></pre><p>参数的意思是：在旧区到60％的时候，会触发一次cmsgc，应该出现如下日志：</p><pre><code>T20:10:37.803+0800: 3246087.559: [CMS-concurrent-mark-start]T20:10:38.463+0800: 3246088.220: [CMS-concurrent-mark: 0.661/0.661 secs] [Times: user=3.17 sys=0.56, real=0.66 secs]T20:10:38.463+0800: 3246088.220: [CMS-concurrent-preclean-start]T20:10:38.552+0800: 3246088.309: [CMS-concurrent-preclean: 0.069/0.089 secs] [Times: user=0.14 sys=0.04, real=0.09 secs]_&lt;/span&gt;T20:10:38.552+0800: 3246088.309: [CMS-concurrent-abortable-preclean-start]</code></pre><p>而现在日志里面都是old区到2.3G（50%）的时候，就会触发一次FullGc，而且gc日志里面没有一次正常的cmsgc，现在是什么原因在半路截胡了？</p><p>开始怀疑JVM参数是否设置生效，通过jinfo进行查看：</p><pre><code>jinfo -flag UseCMSInitiatingOccupancyOnly 20195jinfo -flag CMSInitiatingOccupancyFraction 20195</code></pre><p>一切正常。</p><p>出现Fullgc，当时我想可能的原因有以下几个情况：</p><ol><li>cmsgc失败导致（GC日志中没有相关cmsgc失败的日志）</li><li>JMAP -histo：现场（人为执行肯定不是）</li><li>大对象分配时，空间不够导致（当时还剩下50%内存，并且如果大对象分配，gc日志里面是会有如下WARN的）</li><li>内存碎片导致？（由于系统会经常分配一些大数组，这个会加剧碎片化）</li></ol><p>第四点是最可能的原因了。于是，接下来怎么验证是否是它导致的呢？加上PrintGCReason，先打印出fullgc的原因,</p><p>命令如下：</p><pre><code>/java/bin/jinfo -flag +PrintGCReason</code></pre><p>第二天，查看日志，如下：</p><pre><code>GC Cause: Heap Inspection Initiated GC T16:16:01.880+0800: 687439.886: [Full GC 687439.886: [CMS: 2362138K-&amp;gt;1180717K(4718592K), 5.6573690 secs] 2700275K-&amp;gt;1180717K(5190464K), [C MS Perm : 17531K-&amp;gt;17488K(131072K)], 5.6574950 secs] [Times: user=5.59 sys=0.06, real=5.65 secs]</code></pre><p>GC原因：堆检查启动GC，FullGc的原因是这个，看不明白，咨询过后，说这个很可能是因为JAMP -hist继：活导致的FullGc。</p><p>那如果是这样，就有可能是有脚本或者定时任务，也可能是什么其他东西，去执行了这个命令，反正据我了解的cs没有做这事。接下来就是找这个“凶手”了，这事情没做过，没啥头绪，看进程也看不出什么，想grep所有脚本，懒癌又发作了，还是先去群里咨询下有啥简单又省力的办法吧，一下搞定：</p><pre><code>[ ~]$ crontab -l */1 * * * * /home/bin/config-monitor.sh &amp;gt;&amp;gt; /home/logs/config-monitor.log 2&amp;gt;&amp;amp;1 [logs]$ cat /home/bin/config-monitor.sh |grep &quot;jmap&quot; jmaplog=&quot;/home/jmap.log&quot;; if (count == 3) { / run jmap print &quot;run jmap command : /java/bin/jmap -histo:live &quot;pid&quot; |head -n 20&quot;; system(&quot;/java/bin/jmap -histo:live &quot;pid&quot; |head -n 20&quot;)&amp;gt;jmaplog; print &quot;#######Server has recovered after running jmap######&quot;;</code></pre><p>有个定时任务跑一个叫config-monitor.sh的脚本，里面做的事情，基本就是监视内存各个区的比例，超过一定比例，就通过jamp -histo：现场触发下fullgc，防止溢出===》这个定时任务是cs以前遗留下来的，一直没发现，后续就是评估是否去掉这个定时任务，整个过程告一段落。</p><p>总结：</p><ol><li>问题可能出现的原因，要尽快动手去验证，不要只停留在思考的层面;</li><li>出现fullgc的时候，可以通过加上PrintGCReason，查看具体GC原因。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;http://jm.taobao.org/2016/03/23/3782/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://jm.taobao.org/2016/03/23/3782/&lt;/a
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>（转）为什么 String hashCode 方法选择数字31作为乘子</title>
    <link href="https://www.sakuratears.top/blog/%E4%B8%BA%E4%BB%80%E4%B9%88-String-hashCode-%E6%96%B9%E6%B3%95%E9%80%89%E6%8B%A9%E6%95%B0%E5%AD%9731%E4%BD%9C%E4%B8%BA%E4%B9%98%E5%AD%9020180829/"/>
    <id>https://www.sakuratears.top/blog/为什么-String-hashCode-方法选择数字31作为乘子20180829/</id>
    <published>2018-08-29T12:47:00.000Z</published>
    <updated>2018-08-29T13:24:10.269Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址：<a href="https://segmentfault.com/a/1190000010799123" target="_blank" rel="noopener">https://segmentfault.com/a/1190000010799123</a></p></blockquote><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>某天，我在写代码的时候，无意中点开了 String hashCode 方法。然后大致看了一下 hashCode 的实现，发现并不是很复杂。但是我从源码中发现了一个奇怪的数字，也就是本文的主角31。这个数字居然不是用常量声明的，所以没法从字面意思上推断这个数字的用途。后来带着疑问和好奇心，到网上去找资料查询一下。在看完资料后，默默的感叹了一句，原来是这样啊。那么到底是哪样呢？在接下来章节里，请大家带着好奇心和我揭开数字31的用途之谜。</p><h1 id="选择数字31的原因"><a href="#选择数字31的原因" class="headerlink" title="选择数字31的原因"></a>选择数字31的原因</h1><p>在详细说明 String hashCode 方法选择数字31的作为乘子的原因之前，我们先来看看 String hashCode 方法是怎样实现的，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码就是 String hashCode 方法的实现，是不是很简单。实际上 hashCode 方法核心的计算逻辑只有三行，也就是代码中的 for 循环。我们可以由上面的 for 循环推导出一个计算公式，hashCode 方法注释中已经给出。如下：</p><blockquote><p>s[0]<em>31^(n-1) + s<a href="https://stackoverflow.com/questions/299304/why-does-javas-hashcode-in-string-use-31-as-a-multiplier" target="_blank" rel="noopener">1</a></em>31^(n-2) + … + s[n-1]</p></blockquote><p>这里说明一下，上面的 s 数组即源码中的 val 数组，是 String 内部维护的一个 char 类型数组。这里我来简单推导一下这个公式：</p><pre><code>假设 n=3    i=0 -&gt; h = 31 * 0 + val[0]    i=1 -&gt; h = 31 * (31 * 0 + val[0]) + val[1]    i=2 -&gt; h = 31 * (31 * (31 * 0 + val[0]) + val[1]) + val[2]           h = 31*31*31*0 + 31*31*val[0] + 31*val[1] + val[2]           h = 31^(n-1)*val[0] + 31^(n-2)*val[1] + val[2]</code></pre><p>上面的公式包括公式的推导并不是本文的重点，大家了解了解即可。接下来来说说本文的重点，即选择31的理由。从网上的资料来看，一般有如下两个原因：</p><p><strong>第一</strong>、31是一个不大不小的质数，是作为 hashCode 乘子的优选质数之一。另外一些相近的质数，比如37、41、43等等，也都是不错的选择。那么为啥偏偏选中了31呢？请看第二个原因。</p><p><strong>第二</strong>、31可以被 JVM 优化，<span style="color:red"><strong>31 * i = (i &lt;&lt; 5) - i</strong></span>。</p><p>上面两个原因中，第一个需要解释一下，第二个比较简单，就不说了。下面我来解释第一个理由。一般在设计哈希算法时，会选择一个特殊的质数。至于为啥选择质数，我想应该是可以降低哈希算法的冲突率。至于原因，这个就要问数学家了，我几乎可以忽略的数学水平解释不了这个原因。上面说到，31是一个不大不小的质数，是优选乘子。那为啥同是质数的2和101（或者更大的质数）就不是优选乘子呢，分析如下。</p><p>这里先分析质数2。首先，假设 <span style="color:red"><strong>n = 6</strong></span>，然后把质数2和 n 带入上面的计算公式。并仅计算公式中次数最高的那一项，结果是<span style="color:red"><strong>2^5 = 32</strong></span>，是不是很小。所以这里可以断定，当字符串长度不是很长时，用质数2做为乘子算出的哈希值，数值不会很大。也就是说，哈希值会分布在一个较小的数值区间内，分布性不佳，最终可能会导致冲突率上升。</p><p>上面说了，质数2做为乘子会导致哈希值分布在一个较小区间内，那么如果用一个较大的大质数101会产生什么样的结果呢？根据上面的分析，我想大家应该可以猜出结果了。就是不用再担心哈希值会分布在一个小的区间内了，因为<span style="color:red"><strong>101^5 = 10,510,100,501</strong></span>。但是要注意的是，这个计算结果太大了。如果用 int 类型表示哈希值，结果会溢出，最终导致数值信息丢失。尽管数值信息丢失并不一定会导致冲突率上升，但是我们暂且先认为质数101（或者更大的质数）也不是很好的选择。最后，我们再来看看质数31的计算结果： <span style="color:red"><strong>31^5 = 28629151</strong></span>，结果值相对于<span style="color:red"><strong>32</strong></span>和<span style="color:red"><strong>10,510,100,501</strong></span>来说。是不是很nice，不大不小。</p><p>上面用了比较简陋的数学手段证明了数字31是一个不大不小的质数，是作为 hashCode 乘子的优选质数之一。接下来我会用详细的实验来验证上面的结论，不过在验证前，我们先看看 Stack Overflow 上关于这个问题的讨论，<a href="https://stackoverflow.com/questions/299304/why-does-javas-hashcode-in-string-use-31-as-a-multiplier" target="_blank" rel="noopener">Why does Java’s hashCode() in String use 31 as a multiplier?</a>。其中排名第一的答案引用了《Effective Java》中的一段话，这里也引用一下：</p><blockquote><p>The value 31 was chosen because it is an odd prime. If it were even and the multiplication overflowed, information would be lost, as multiplication by 2 is equivalent to shifting. The advantage of using a prime is less clear, but it is traditional. A nice property of 31 is that the multiplication can be replaced by a shift and a subtraction for better performance: <span style="color:red">31 * i == (i &lt;&lt; 5) - i</span>. Modern VMs do this sort of optimization automatically.</p></blockquote><p>简单翻译一下：</p><blockquote><p>选择数字31是因为它是一个奇质数，如果选择一个偶数会在乘法运算中产生溢出，导致数值信息丢失，因为乘二相当于移位运算。选择质数的优势并不是特别的明显，但这是一个传统。同时，数字31有一个很好的特性，即乘法运算可以被移位和减法运算取代，来获取更好的性能：<span style="color:red">31 * i == (i &lt;&lt; 5) - i</span>，现代的 Java 虚拟机可以自动的完成这个优化。</p></blockquote><p>排名第二的答案设这样说的：</p><blockquote><p>As Goodrich and Tamassia point out, If you take over 50,000 English words (formed as the union of the word lists provided in two variants of Unix), using the constants 31, 33, 37, 39, and 41 will produce less than 7 collisions in each case. Knowing this, it should come as no surprise that many Java implementations choose one of these constants.</p></blockquote><p>这段话也翻译一下：</p><blockquote><p>正如 Goodrich 和 Tamassia 指出的那样，如果你对超过 50,000 个英文单词（由两个不同版本的 Unix 字典合并而成）进行 hash code 运算，并使用常数 31, 33, 37, 39 和 41 作为乘子，每个常数算出的哈希值冲突数都小于7个，所以在上面几个常数中，常数 31 被 Java 实现所选用也就不足为奇了。</p></blockquote><p>上面的两个答案完美的解释了 Java 源码中选用数字 31 的原因。接下来，我将针对第二个答案就行验证，请大家继续往下看。</p><h1 id="实验及数据可视化"><a href="#实验及数据可视化" class="headerlink" title="实验及数据可视化"></a>实验及数据可视化</h1><p>本节，我将使用不同的数字作为乘子，对超过23万个英文单词进行哈希运算，并计算哈希算法的冲突率。同时，我也将针对不同乘子算出的哈希值分布情况进行可视化处理，让大家可以直观的看到数据分布情况。本次实验所使用的数据是 Unix/Linux 平台中的英文字典文件，文件路径为 /usr/share/dict/words。</p><h2 id="哈希值冲突率计算"><a href="#哈希值冲突率计算" class="headerlink" title="哈希值冲突率计算"></a>哈希值冲突率计算</h2><p>计算哈希算法冲突率并不难，比如可以一次性将所有单词的 hash code 算出，并放入 Set 中去除重复值。之后拿单词数减去 set.size() 即可得出冲突数，有了冲突数，冲突率就可以算出来了。当然，如果使用 JDK8 提供的流式计算 API，则可更方便算出，代码片段如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">hashCode</span><span class="params">(String str, Integer multiplier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        hash = multiplier * hash + str.charAt(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算 hash code 冲突率，顺便分析一下 hash code 最大值和最小值，并输出</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> multiplier</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hashs</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">calculateConflictRate</span><span class="params">(Integer multiplier, List&lt;Integer&gt; hashs)</span> </span>&#123;</span><br><span class="line">    Comparator&lt;Integer&gt; cp = (x, y) -&gt; x &gt; y ? <span class="number">1</span> : (x &lt; y ? -<span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> maxHash = hashs.stream().max(cp).get();</span><br><span class="line">    <span class="keyword">int</span> minHash = hashs.stream().min(cp).get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算冲突数及冲突率</span></span><br><span class="line">    <span class="keyword">int</span> uniqueHashNum = (<span class="keyword">int</span>) hashs.stream().distinct().count();</span><br><span class="line">    <span class="keyword">int</span> conflictNum = hashs.size() - uniqueHashNum;</span><br><span class="line">    <span class="keyword">double</span> conflictRate = (conflictNum * <span class="number">1.0</span>) / hashs.size();</span><br><span class="line"></span><br><span class="line">    System.out.println(String.format(<span class="string">"multiplier=%4d, minHash=%11d, maxHash=%10d, conflictNum=%6d, conflictRate=%.4f%%"</span>,</span><br><span class="line">                multiplier, minHash, maxHash, conflictNum, conflictRate * <span class="number">100</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/images/pasted-59.png" alt="upload successful"></p><p>从上图可以看出，使用较小的质数做为乘子时，冲突率会很高。尤其是质数2，冲突率达到了 55.14%。同时我们注意观察质数2作为乘子时，哈希值的分布情况。可以看得出来，哈希值分布并不是很广，仅仅分布在了整个哈希空间的正半轴部分，即 0 ~ 2^31-1。而负半轴 -2^31 ~ -1，则无分布。这也证明了我们上面断言，即质数2作为乘子时，对于短字符串，生成的哈希值分布性不佳。然后再来看看我们之前所说的 31、37、41 这三个不大不小的质数，表现都不错，冲突数都低于7个。而质数 101 和 199 表现的也很不错，冲突率很低，这也说明哈希值溢出并不一定会导致冲突率上升。但是这两个家伙一言不合就溢出，我们认为他们不是哈希算法的优选乘子。最后我们再来看看 32 和 36 这两个偶数的表现，结果并不好，尤其是 32，冲突率超过了了50%。尽管 36 表现的要好一点，不过和 31，37相比，冲突率还是比较高的。当然并非所有的偶数作为乘子时，冲突率都会比较高，大家有兴趣可以自己验证。</p><h2 id="哈希值分布可视化"><a href="#哈希值分布可视化" class="headerlink" title="哈希值分布可视化"></a>哈希值分布可视化</h2><p>上一节分析了不同数字作为乘子时的冲突率情况，这一节来分析一下不同数字作为乘子时，哈希值的分布情况。在详细分析之前，我先说说哈希值可视化的过程。我原本是打算将所有的哈希值用一维散点图进行可视化，但是后来找了一圈，也没找到合适的画图工具。加之后来想了想，一维散点图可能不合适做哈希值可视化，因为这里有超过23万个哈希值。也就意味着会在图上显示超过23万个散点，如果不出意外的话，这23万个散点会聚集的很密，有可能会变成一个大黑块，就失去了可视化的意义了。所以这里选择了另一种可视化效果更好的图表，也就是 excel 中的平滑曲线的二维散点图（下面简称散点曲线图）。当然这里同样没有把23万散点都显示在图表上，太多了。所以在实际绘图过程中，我将哈希空间等分成了64个子区间，并统计每个区间内的哈希值数量。最后将分区编号做为X轴，哈希值数量为Y轴，就绘制出了我想要的二维散点曲线图了。这里举个例子说明一下吧，以第0分区为例。第0分区数值区间是[-2147483648, -2080374784)，我们统计落在该数值区间内哈希值的数量，得到 <span style="color:red">&lt;分区编号, 哈希值数量&gt;</span> 数值对，这样就可以绘图了。分区代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将整个哈希空间等分成64份，统计每个空间内的哈希值数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hashs</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Integer, Integer&gt; <span class="title">partition</span><span class="params">(List&lt;Integer&gt; hashs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// step = 2^32 / 64 = 2^26</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> step = <span class="number">67108864</span>;</span><br><span class="line">    List&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Map&lt;Integer, Integer&gt; statistics = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = Integer.MIN_VALUE; i &lt;= Integer.MAX_VALUE; i += step) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> min = i;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> max = min + step;</span><br><span class="line">        <span class="keyword">int</span> num = (<span class="keyword">int</span>) hashs.parallelStream()</span><br><span class="line">                .filter(x -&gt; x &gt;= min &amp;&amp; x &lt; max).count();</span><br><span class="line"></span><br><span class="line">        statistics.put(start++, num);</span><br><span class="line">        nums.add(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了防止计算出错，这里验证一下</span></span><br><span class="line">    <span class="keyword">int</span> hashNum = nums.stream().reduce((x, y) -&gt; x + y).get();</span><br><span class="line">    <span class="keyword">assert</span> hashNum == hashs.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> statistics;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本文中的哈希值是用整形表示的，整形的数值区间是<span style="color:red"> [-2147483648, 2147483647]</span>，区间大小为 <span style="color:red">2^32</span>。所以这里可以将区间等分成64个子区间，每个自子区间大小为 <span style="color:red">2^26</span>。详细的分区对照表如下：</p><table><thead><tr><th>分区编号</th><th>分区下限</th><th>分区上限</th><th>分区编号</th><th>分区下限</th><th>分区上限</th></tr></thead><tbody><tr><td>0</td><td>-2147483648</td><td>-2080374784</td><td>32</td><td>0</td><td>67108864</td></tr><tr><td>1</td><td>-2080374784</td><td>-2013265920</td><td>33</td><td>67108864</td><td>134217728</td></tr><tr><td>2</td><td>-2013265920</td><td>-1946157056</td><td>34</td><td>134217728</td><td>201326592</td></tr><tr><td>3</td><td>-1946157056</td><td>-1879048192</td><td>35</td><td>201326592</td><td>268435456</td></tr><tr><td>4</td><td>-1879048192</td><td>-1811939328</td><td>36</td><td>268435456</td><td>335544320</td></tr><tr><td>5</td><td>-1811939328</td><td>-1744830464</td><td>37</td><td>335544320</td><td>402653184</td></tr><tr><td>6</td><td>-1744830464</td><td>-1677721600</td><td>38</td><td>402653184</td><td>469762048</td></tr><tr><td>7</td><td>-1677721600</td><td>-1610612736</td><td>39</td><td>469762048</td><td>536870912</td></tr><tr><td>8</td><td>-1610612736</td><td>-1543503872</td><td>40</td><td>536870912</td><td>603979776</td></tr><tr><td>9</td><td>-1543503872</td><td>-1476395008</td><td>41</td><td>603979776</td><td>671088640</td></tr><tr><td>10</td><td>-1476395008</td><td>-1409286144</td><td>42</td><td>671088640</td><td>738197504</td></tr><tr><td>11</td><td>-1409286144</td><td>-1342177280</td><td>43</td><td>738197504</td><td>805306368</td></tr><tr><td>12</td><td>-1342177280</td><td>-1275068416</td><td>44</td><td>805306368</td><td>872415232</td></tr><tr><td>13</td><td>-1275068416</td><td>-1207959552</td><td>45</td><td>872415232</td><td>939524096</td></tr><tr><td>14</td><td>-1207959552</td><td>-1140850688</td><td>46</td><td>939524096</td><td>1006632960</td></tr><tr><td>15</td><td>-1140850688</td><td>-1073741824</td><td>47</td><td>1006632960</td><td>1073741824</td></tr><tr><td>16</td><td>-1073741824</td><td>-1006632960</td><td>48</td><td>1073741824</td><td>1140850688</td></tr><tr><td>17</td><td>-1006632960</td><td>-939524096</td><td>49</td><td>1140850688</td><td>1207959552</td></tr><tr><td>18</td><td>-939524096</td><td>-872415232</td><td>50</td><td>1207959552</td><td>1275068416</td></tr><tr><td>19</td><td>-872415232</td><td>-805306368</td><td>51</td><td>1275068416</td><td>1342177280</td></tr><tr><td>20</td><td>-805306368</td><td>-738197504</td><td>52</td><td>1342177280</td><td>1409286144</td></tr><tr><td>21</td><td>-738197504</td><td>-671088640</td><td>53</td><td>1409286144</td><td>1476395008</td></tr><tr><td>22</td><td>-671088640</td><td>-603979776</td><td>54</td><td>1476395008</td><td>1543503872</td></tr><tr><td>23</td><td>-603979776</td><td>-536870912</td><td>55</td><td>1543503872</td><td>1610612736</td></tr><tr><td>24</td><td>-536870912</td><td>-469762048</td><td>56</td><td>1610612736</td><td>1677721600</td></tr><tr><td>25</td><td>-469762048</td><td>-402653184</td><td>57</td><td>1677721600</td><td>1744830464</td></tr><tr><td>26</td><td>-402653184</td><td>-335544320</td><td>58</td><td>1744830464</td><td>1811939328</td></tr><tr><td>27</td><td>-335544320</td><td>-268435456</td><td>59</td><td>1811939328</td><td>1879048192</td></tr><tr><td>28</td><td>-268435456</td><td>-201326592</td><td>60</td><td>1879048192</td><td>1946157056</td></tr><tr><td>29</td><td>-201326592</td><td>-134217728</td><td>61</td><td>1946157056</td><td>2013265920</td></tr><tr><td>30</td><td>-134217728</td><td>-67108864</td><td>62</td><td>2013265920</td><td>2080374784</td></tr><tr><td>31</td><td>-67108864</td><td>0</td><td>63</td><td>2080374784</td><td>2147483648</td></tr></tbody></table><p>接下来，让我们对照上面的分区表，对数字2、3、17、31、101的散点曲线图进行简单的分析。先从数字2开始，数字2对于的散点曲线图如下：</p><p><img src="/images/pasted-60.png" alt="upload successful"></p><p>上面的图还是很一幕了然的，乘子2算出的哈希值几乎全部落在第32分区，也就是 <span style="color:red">[0, 67108864)</span>数值区间内，落在其他区间内的哈希值数量几乎可以忽略不计。这也就不难解释为什么数字2作为乘子时，算出哈希值的冲突率如此之高的原因了。所以这样的哈希算法要它有何用啊，拖出去斩了吧。接下来看看数字3作为乘子时的表现：</p><p><img src="/images/pasted-61.png" alt="upload successful"></p><p>3作为乘子时，算出的哈希值分布情况和2很像，只不过稍微好了那么一点点。从图中可以看出绝大部分的哈希值最终都落在了第32分区里，哈希值的分布性很差。这个也没啥用，拖出去枪毙5分钟吧。在看看数字17的情况怎么样：</p><p><img src="/images/pasted-62.png" alt="upload successful"></p><p>数字17作为乘子时的表现，明显比上面两个数字好点了。虽然哈希值在第32分区和第34分区有一定的聚集，但是相比较上面2和3，情况明显好好了很多。除此之外，17作为乘子算出的哈希值在其他区也均有分布，且较为均匀，还算是一个不错的乘子吧。</p><p><img src="/images/pasted-63.png" alt="upload successful"></p><p>接下来来看看我们本文的主角31了，31作为乘子算出的哈希值在第33分区有一定的小聚集。不过相比于数字17，主角31的表现又好了一些。首先是哈希值的聚集程度没有17那么严重，其次哈希值在其他区分布的情况也要好于17。总之，选31，准没错啊。</p><p><img src="/images/pasted-64.png" alt="upload successful"></p><p>最后再来看看大质数101的表现，不难看出，质数101作为乘子时，算出的哈希值分布情况要好于主角31，有点喧宾夺主的意思。不过不可否认的是，质数101的作为乘子时，哈希值的分布性确实更加均匀。所以如果不在意质数101容易导致数据信息丢失问题，或许其是一个更好的选择。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>经过上面的分析与实践，我想大家应该明白了 String hashCode 方法中选择使用数字31作为乘子的原因了。</p><p>本文为转载，原文地址：<a href="https://segmentfault.com/a/1190000010799123" target="_blank" rel="noopener">https://segmentfault.com/a/1190000010799123</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;https://segmentfault.com/a/1190000010799123&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://segmentfault.com/a/1190000
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantLock那些事</title>
    <link href="https://www.sakuratears.top/blog/%E8%B0%88%E8%B0%88ReentrantLock20180826/"/>
    <id>https://www.sakuratears.top/blog/谈谈ReentrantLock20180826/</id>
    <published>2018-08-26T10:11:00.000Z</published>
    <updated>2018-08-26T11:16:50.426Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在说ReentrantLock之前，我们先说说并发吧。</p><p>在JDK1.5之前，并发处理常用的关键字synchronized。使用synchronized关键字，锁的获取和释放是隐式的，synchronized主要通过系统的monitorenter指令实现的。</p><p>那时候synchronized可以称为重量级锁，执行效率不是很高。</p><p>而Doug Lea编写的util.concurrent 包被纳入JSR-166标准。这里面就包含了ReentrantLock。</p><p>ReentrantLock为编写并发提供了更多选择。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>ReentrantLock的通常用法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     lock.lock();  </span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//TODO</span></span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>ReentrantLock主要是通过AbstractQueuedSynchronizer实现的，是一个重入锁，即一个线程加锁后仍然可以获得锁，不会出现自己阻塞自己的情况。</p><h2 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h2><p>我们看一下它们的UML图。</p><p><img src="/images/pasted-56.png" alt="upload successful"></p><p>可以看到ReentrantLock实现了Lock接口。</p><h2 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h2><p>ReentrantLock的两种锁类型，公平锁和非公平锁。</p><p><img src="/images/pasted-57.png" alt="upload successful"></p><p><img src="/images/pasted-58.png" alt="upload successful"></p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>我们先来看下ReentrantLock的构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到默认无参构造方法为非公平锁实现。如果想定义公平锁实现，可以传入true来控制。</p><p>它的lock方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       sync.acquire(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">           acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">           selfInterrupt();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>公平锁和非公平锁各有自己的实现方式。我们来看下他们的tryAcquire方法。</p><p><strong>非公平锁源码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到，非公平锁首先判断AQS（AbstractQueuedSynchronizer）中的state是否为0，0表示没有线程持有该锁，当前线程就尝试获取锁。</p><p>如果不是0，那在判断是不是当前线程持有该锁，如果是，就会增加state，改变state状态。（因此ReentranLock支持重入）。</p><p><strong>公平锁源码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line">    <span class="meta">@ReservedStackAccess</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = tail; </span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>公平锁的tryAcquire方法，可以看到，相比非公平锁，多了hasQueuedPredecessors方法，这个方法是判断队列中是否有其他线程，如果没有，线程才会尝试获取锁，如果有，会先把锁分配给队列的线程，因此称为公平锁。</p><p><strong>这儿可以看到，非公平锁的效率比公平锁要高。</strong></p><p>这是tryAcquire方法，如果尝试获取锁失败了呢？</p><p>那就会执行acquireQueued(addWaiter(Node.EXCLUSIVE), arg)方法啦。</p><p>我们先来看一下addWaiter方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(mode);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node oldTail = tail;</span><br><span class="line">        <span class="keyword">if</span> (oldTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.setPrevRelaxed(oldTail);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(oldTail, node)) &#123;</span><br><span class="line">                oldTail.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            initializeSyncQueue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这个方法会把线程添加到队列尾，同时，for(;;)循环保证添加成功，直到return出去。</p><p>添加后，调用acquireQueued方法，这个方法为挂起等待线程。</p><p>看下该方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，如果节点为头节点，就尝试获取一次锁，如果成功，就返回。</p><p>否则判断该线程是否需要挂起，如果需要的化就调用parkAndCheckInterrupt挂起。</p><p>调用LockSupport.park方法挂起线程，直到被唤醒。</p><p>selfInterrupt方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())</span><br><span class="line">        checkAccess();</span><br><span class="line">    <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">        Interruptible b = blocker;</span><br><span class="line">        <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">            interrupt0();</span><br><span class="line">            b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用interrupt方法，中断正在执行的线程（如果不是当前线程的话）。</p><p>释放锁unlock方法：</p><p>公平锁和非公平锁释放锁的方法是一样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       sync.release(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">           Node h = head;</span><br><span class="line">           <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">               unparkSuccessor(h);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">           <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">           <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">               free = <span class="keyword">true</span>;</span><br><span class="line">               setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           setState(c);</span><br><span class="line">           <span class="keyword">return</span> free;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>可以看到首先会判断当前线程是否是获得锁的线程，如果是重入锁需要将state减完才算是完全释放锁。</p><p>释放后调用unparkSuccessor唤起挂起线程。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>非公平锁的效率是比公平锁要高的。</li><li>ReentranLock支持重入，因为增加了对自身线程的处理，通过state可以控制。</li><li>解锁操作应放到finally块里，避免使用锁时出现资源无法释放的问题。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在说ReentrantLock之前，我们先说说并发吧。&lt;/p&gt;
&lt;p&gt;在JDK1.5之前，并发处理常用的关键字synchronized。使用
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>越努力越幸运</title>
    <link href="https://www.sakuratears.top/blog/%E6%94%BE%E5%B9%B3%E5%BF%83%E6%80%81%E5%8E%BB%E5%86%99%E4%BD%9C20180825/"/>
    <id>https://www.sakuratears.top/blog/放平心态去写作20180825/</id>
    <published>2018-08-25T08:02:00.000Z</published>
    <updated>2018-08-25T08:26:46.097Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>感觉最近自己浮躁的很，不知为什么。</p><p>准备写些东西源自3个月前了，那时候想自己记录些知识，一方面便于加深记忆，一方面不让自己太“闲”。</p><p>或许心态本来就不太正，浮浮躁躁，有的时候写点东西感觉就是为了应付内心那个自己。</p><h1 id="兴趣与工作"><a href="#兴趣与工作" class="headerlink" title="兴趣与工作"></a>兴趣与工作</h1><p>从事Java开发已经3-4年了，也算是个半路出家的吧，总应该比别人多付出些努力。</p><p>人如何克服惰性？</p><p>关键是培养自己的兴趣爱好吧。</p><p>3-4年工作期间，换了2、3家公司，每次面试的时候，总感觉自己欠点什么，说不出来的感觉。大概是基础比较薄弱吧。</p><p>回想起自己曾经从采矿专业转到软件开发，培训的时间，那时候是为了什么？那时候不是对软件的兴趣吗？</p><p>初心呢？初衷呢？</p><p>自己也渴望成为一个大牛，无论是架构师、全栈还是资深大咖。</p><h1 id="阅读与写作"><a href="#阅读与写作" class="headerlink" title="阅读与写作"></a>阅读与写作</h1><p>曾说写作可以平复心态，阅读可以使人优秀。</p><p>是的呀，无论是阅读或者写作，都可以使人思考。</p><p>思考是什么、为什么、怎么办。</p><h1 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h1><p>任何的辉煌与成功都是一步步慢慢实现的。</p><p>越努力越幸运。</p><p>创造性的思维也是必须的。</p><p>时刻牢记你想要的是什么。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>兄台，就和我一起干了这碗鸡汤吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;感觉最近自己浮躁的很，不知为什么。&lt;/p&gt;
&lt;p&gt;准备写些东西源自3个月前了，那时候想自己记录些知识，一方面便于加深记忆，一方面不让自己太“
      
    
    </summary>
    
      <category term="生活" scheme="https://www.sakuratears.top/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="思维" scheme="https://www.sakuratears.top/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList、LinkedList和Vector分析</title>
    <link href="https://www.sakuratears.top/blog/ArrayList%E5%92%8CVector%E5%88%86%E6%9E%9020180814/"/>
    <id>https://www.sakuratears.top/blog/ArrayList和Vector分析20180814/</id>
    <published>2018-08-14T14:49:00.000Z</published>
    <updated>2018-08-16T15:28:48.104Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>List家族常用的类有3个，ArrayList、LinkedList、Vector。</p><p>ArrayList和Vector的底层是基于数组实现的，LinkedList的底层是基于链表实现的。</p><p>三者的比较如下：</p><ol><li>ArrayList和LinkedList不是线程安全的，Vector是线程安全的。</li><li>对于随机访问（get和set），ArrayList的性能要优于LinkedList。</li><li>对于add和remove操作，LinkedList和ArrayList性能差距不是很大。</li><li>三者均实现了Collection接口。</li></ol><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h2><p>三者与其他类的继承实现关系UML图如下。</p><p>ArrayList：</p><p><img src="/images/pasted-53.png" alt="upload successful"></p><p>LinkedList：</p><p><img src="/images/pasted-54.png" alt="upload successful"></p><p>Vector：</p><p><img src="/images/pasted-55.png" alt="upload successful"></p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="核心实现"><a href="#核心实现" class="headerlink" title="核心实现"></a>核心实现</h3><p>ArrayList是基于数组实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><p>LinkedList是基于链表实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure><p>Vector是基于数组实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object[] elementData;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> elementCount;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> capacityIncrement;</span><br></pre></td></tr></table></figure><h2 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h2><p>ArrayList 可以设置初始大小（由于数组实现的原因），不设置默认为10。</p><p>LinkedList不需要设置参数（由于使用链表实现，无界）。</p><p>Vector不仅可以设置初始大小，还可以设置容量增幅。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ArrayList传参构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//LinkedList构造函数</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="comment">//Vector传参构造函数 </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>();</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">       <span class="keyword">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>关于初始化大小和扩容机制下面讲。</p><h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><p>我们主要分析get、set、add、remove这几个方法。对于ArrayList和Vector，还要分析扩容方法。</p><h3 id="get、set方法"><a href="#get、set方法" class="headerlink" title="get、set方法"></a>get、set方法</h3><p>ArrayList get，set方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    Objects.checkIndex(index, size);</span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    Objects.checkIndex(index, size);</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Vector get，set方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line"></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二者的逻辑一样，get方法判断是否下标越界，不越界返回index下的数值。set方法判断是否越界，不越界将新值放到指定下标上。它俩的区别在与synchronized关键字，正好说明了Vector是线程安全的。</p><p>LinkedList get，set方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    E oldVal = x.item;</span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到LinkedList的get方法会先检查是否越界，不越界返回指定下标node的item值。<br>set方法也是先检查越界情况，不越界将该点的node的item赋为新值。取node指定位置上的值时要循环遍历，所以对于随机的get，set，ArrayList的性能要优于LinkedList的。</p><h3 id="add、remove方法"><a href="#add、remove方法" class="headerlink" title="add、remove方法"></a>add、remove方法</h3><p>ArrayList add、remove方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    add(e, elementData, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e, Object[] elementData, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == elementData.length)</span><br><span class="line">        elementData = grow();</span><br><span class="line">    elementData[s] = e;</span><br><span class="line">    size = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> s;</span><br><span class="line">    Object[] elementData;</span><br><span class="line">    <span class="keyword">if</span> ((s = size) == (elementData = <span class="keyword">this</span>.elementData).length)</span><br><span class="line">        elementData = grow();</span><br><span class="line">    System.arraycopy(elementData, index,</span><br><span class="line">                     elementData, index + <span class="number">1</span>,</span><br><span class="line">                     s - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    Objects.checkIndex(index, size);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Vector add、remove方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    add(e, elementData, elementCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e, Object[] elementData, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == elementData.length)</span><br><span class="line">        elementData = grow();</span><br><span class="line">    elementData[s] = e;</span><br><span class="line">    elementCount = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = elementCount - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--elementCount] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它们里面有add、remove方法不止一个，我们只拿一个来举例。</p><p>可以看到，Vector和ArrayList十分相近了，除了synchronized关键字。</p><p>add方法当elementData.length和elementCount相等时（容量满），会执行扩容操作，并将元素放到指定位置。</p><p>remove方法先判断下标是否越界，不越界会删除指定位置的元素，并且将数组重新拷贝合并。</p><p>同时它们有一个计数器modCount，在HashMap那边已经讲过，是用来fast-fail的，当多个线程同时操作，modCount不一致，就会抛出异常。</p><p>LinkedList的add、remove方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，LinkedList的add方法开始也会校验指针位置，然后如果在末尾，就在链表最后面添加节点，否则就插入到链表指定位置上。</p><p>remove方法校验指针位置后，会删除指定位置上的node。</p><p>上面可以看到，对于add和remove，ArrayList数组要进行扩容或者删除部分长度，执行Sysetm.arraycopy方法，这是要消耗一些性能的，对于LinkedList，不需要维护容量问题，但是每次新增或者删除时，都会创建或删除一个Node对象，也是要消耗一些性能的。</p><h3 id="扩容方法"><a href="#扩容方法" class="headerlink" title="扩容方法"></a>扩容方法</h3><p>对于ArrayList或者Vector，扩容方法如下：</p><p>ArrayList 扩容方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">newCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// overflow-conscious code</span></span><br><span class="line">       <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">       <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">       <span class="keyword">if</span> (newCapacity - minCapacity &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">               <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">           <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">           <span class="keyword">return</span> minCapacity;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> (newCapacity - MAX_ARRAY_SIZE &lt;= <span class="number">0</span>)</span><br><span class="line">           ? newCapacity</span><br><span class="line">           : hugeCapacity(minCapacity);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">       <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE)</span><br><span class="line">           ? Integer.MAX_VALUE</span><br><span class="line">           : MAX_ARRAY_SIZE;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>Vector扩容方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">newCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// overflow-conscious code</span></span><br><span class="line">       <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">       <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                        capacityIncrement : oldCapacity);</span><br><span class="line">       <span class="keyword">if</span> (newCapacity - minCapacity &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">           <span class="keyword">return</span> minCapacity;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> (newCapacity - MAX_ARRAY_SIZE &lt;= <span class="number">0</span>)</span><br><span class="line">           ? newCapacity</span><br><span class="line">           : hugeCapacity(minCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">       <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">           Integer.MAX_VALUE :</span><br><span class="line">           MAX_ARRAY_SIZE;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>上面代码可以看到，对于ArrayList，如果不传入初始容量，默认为10。容量达到最值，执行扩容，每次扩容 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</p><p>默认原容量的1.5倍。</p><p>Vector，如果不传入初始容量和自增容量，默认初始容量也为10.扩容时执行<br>int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?capacityIncrement : oldCapacity);</p><p>默认为原容量的2倍。</p><p>两者的最大值容量均为Integer.MAX_VALUE.</p><p>LinkedList由于是链表实现，没有容量限制。无需扩容。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>我们从代码的角度比较下ArrayList和LinkedList，Vector。</p><p>我们构建一个有200W数据的ArrayList和LinkedList。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="comment">//List&lt;Integer&gt; list = new LinkedList&lt;Integer&gt;();</span></span><br><span class="line">    <span class="comment">//Vector&lt;Integer&gt; list=new Vector&lt;&gt;();</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2000000</span>; i++) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Integer tmp;</span><br><span class="line">    <span class="keyword">long</span> start=System.currentTimeMillis() ;   <span class="comment">//ForEach</span></span><br><span class="line">    <span class="keyword">for</span>(Integer s:list)&#123;</span><br><span class="line">        tmp=s;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"foreach spend:"</span>+(System.currentTimeMillis()-start));</span><br><span class="line">    start = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span>(Iterator&lt;Integer&gt; it = list.iterator(); it.hasNext();)&#123;</span><br><span class="line">        tmp=it.next();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"Iterator spend;"</span>+(System.currentTimeMillis()-start));</span><br><span class="line">    start=System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">int</span> size=list.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">        tmp=list.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"for spend;"</span>+(System.currentTimeMillis()-start));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>某一次的结果：</p><table><thead><tr><th>数组</th><th style="text-align:center">forEach遍历</th><th style="text-align:center">Iterator遍历</th><th style="text-align:center">for遍历</th></tr></thead><tbody><tr><td>ArrayList</td><td style="text-align:center">9ms</td><td style="text-align:center">9ms</td><td style="text-align:center">12ms</td></tr><tr><td>LinkedList</td><td style="text-align:center">17ms</td><td style="text-align:center">16ms</td><td style="text-align:center">???</td></tr><tr><td>Vector</td><td style="text-align:center">44ms</td><td style="text-align:center">55ms</td><td style="text-align:center">41ms</td></tr></tbody></table><p>由于for循环遍历是随机访问，故LinkedList在数据量很大的情况下时间消耗会很长，基本不能接受。由于Vector线程安全，synchronized，故其整体效率会比ArrayList低些。在实际开发中，应用的ArrayList还是比较多的。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>以上就是对ArrayList、LinkedList、Vector的全部分析。对于不同的应用场景，合理的选择List的类型也是至关重要的。三种List都是比较基础的知识，应当学习和掌握。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;List家族常用的类有3个，ArrayList、LinkedList、Vector。&lt;/p&gt;
&lt;p&gt;ArrayList和Vector的底层是
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>StringBuffer和StringBuilder</title>
    <link href="https://www.sakuratears.top/blog/StringBuffer%E5%92%8CStringBuilder20180813/"/>
    <id>https://www.sakuratears.top/blog/StringBuffer和StringBuilder20180813/</id>
    <published>2018-08-13T14:41:00.000Z</published>
    <updated>2018-08-13T15:18:12.919Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们知道，对于一般大量频繁的String操作，我们不建议也不应该直接用String进行相加操作，而我们应借助StringBuffer或者StringBuilder来实现。</p><p>StringBuffer是线程安全的，而StringBuilder是线程不安全的。</p><p>由此看来，StringBuilder对String的操作快，不安全，适合单线程；StringBuilder对String的操作较StringBuilder慢，安全，适合多线程和单线程。</p><p>我们今天分析一下二者的源码。</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="class定义"><a href="#class定义" class="headerlink" title="class定义"></a>class定义</h2><p>两者的class定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//StringBuffer</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuffer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractStringBuilder</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">CharSequence</span></span></span><br><span class="line"><span class="class"></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//StringBuilder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilder</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractStringBuilder</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">CharSequence</span></span></span><br><span class="line"><span class="class"></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>二者的UML图如下：</p><p><img src="/images/pasted-50.png" alt="upload successful"></p><p><img src="/images/pasted-51.png" alt="upload successful"></p><p>可以看到二者均继承AbstractStringBuilder类，且都实现了Serializable和CharSequence接口。即二者分别是AbstractStringBuilder类的安全和不安全的一种实现。</p><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p>我们先来分析下StringBuffer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(capacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(str.length() + <span class="number">16</span>);</span><br><span class="line">    append(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，当我们new StringBuffer时，如果什么也不传，默认赋予16数组长度，如果传入一个String，则长度为String.length()+16。</p><h2 id="append方法"><a href="#append方法" class="headerlink" title="append方法"></a>append方法</h2><p>在看一下append方法。关键字synchronized 对该方法进行了加锁，保证安全，toStringCache 赋值为空。然后调用AbstractStringBuilder的append方法。</p><p>StringBuffer append方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>AbstractStringBuilder里的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> appendNull();</span><br><span class="line">    <span class="keyword">int</span> len = str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">    count += len;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> AbstractStringBuilder <span class="title">appendNull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = count;</span><br><span class="line">    ensureCapacityInternal(c + <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">char</span>[] value = <span class="keyword">this</span>.value;</span><br><span class="line">    value[c++] = <span class="string">'n'</span>;</span><br><span class="line">    value[c++] = <span class="string">'u'</span>;</span><br><span class="line">    value[c++] = <span class="string">'l'</span>;</span><br><span class="line">    value[c++] = <span class="string">'l'</span>;</span><br><span class="line">    count = c;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        value = Arrays.copyOf(value,</span><br><span class="line">                newCapacity(minimumCapacity));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>String里的getChars方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getChars</span><span class="params">(<span class="keyword">int</span> srcBegin, <span class="keyword">int</span> srcEnd, <span class="keyword">char</span> dst[], <span class="keyword">int</span> dstBegin)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (srcBegin &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(srcBegin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (srcEnd &gt; value.length) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(srcEnd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (srcBegin &gt; srcEnd) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(srcEnd - srcBegin);</span><br><span class="line">    &#125;</span><br><span class="line">    System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这段代码的理解。追加一个Str时，如果是null，则调用appendNull方法，在后面直接加一个null字符串。如果不为空，拿到字符串长度，进行容量扩容为当前容量+str的长度，调用String的getChars方法，将字符串数组加在后面，这最后是个char数组。</p><p><img src="/images/pasted-52.png" alt="upload successful"></p><p>通过上图可以看到 AbstractStringBuilder是基于char数组实现的，count用于统计当前长度。</p><h2 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h2><p>我们看一下toString方法。可以发现他把字符串数组先放到了缓存数组，然后在返回一个String。当StringBuffer变化时，如append，则直接把toStringCache 赋值为空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (toStringCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">        toStringCache = Arrays.copyOfRange(value, <span class="number">0</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(toStringCache, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="insert方法"><a href="#insert方法" class="headerlink" title="insert方法"></a>insert方法</h2><p>我们再来分析一下StringBuffer的insert，由于重载方法较多，我们只分析insert String的代码。</p><p>StringBuffer insert方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset, String str)</span> </span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.insert(offset, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>AbstractStringBuilder里的insert方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset, String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((offset &lt; <span class="number">0</span>) || (offset &gt; length()))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset);</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>)</span><br><span class="line">        str = <span class="string">"null"</span>;</span><br><span class="line">    <span class="keyword">int</span> len = str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    System.arraycopy(value, offset, value, offset + len, count - offset);</span><br><span class="line">    str.getChars(value, offset);</span><br><span class="line">    count += len;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到与append大致相同，就是调用System.arraycopy的时候插入的位置发生了变化。</p><h2 id="其他方法（delete，replace等）"><a href="#其他方法（delete，replace等）" class="headerlink" title="其他方法（delete，replace等）"></a>其他方法（delete，replace等）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//StringBuffer</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">delete</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">       toStringCache = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">super</span>.delete(start, end);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//AbstractStringBuilder</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">delete</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (start &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(start);</span><br><span class="line">       <span class="keyword">if</span> (end &gt; count)</span><br><span class="line">           end = count;</span><br><span class="line">       <span class="keyword">if</span> (start &gt; end)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException();</span><br><span class="line">       <span class="keyword">int</span> len = end - start;</span><br><span class="line">       <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           System.arraycopy(value, start+len, value, start, count-end);</span><br><span class="line">           count -= len;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//StringBuffer</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">replace</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, String str)</span> </span>&#123;</span><br><span class="line">       toStringCache = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">super</span>.replace(start, end, str);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//AbstractStringBuilder</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">replace</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, String str)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (start &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(start);</span><br><span class="line">       <span class="keyword">if</span> (start &gt; count)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(<span class="string">"start &gt; length()"</span>);</span><br><span class="line">       <span class="keyword">if</span> (start &gt; end)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(<span class="string">"start &gt; end"</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (end &gt; count)</span><br><span class="line">           end = count;</span><br><span class="line">       <span class="keyword">int</span> len = str.length();</span><br><span class="line">       <span class="keyword">int</span> newCount = count + len - (end - start);</span><br><span class="line">       ensureCapacityInternal(newCount);</span><br><span class="line"></span><br><span class="line">       System.arraycopy(value, end, value, start + len, count - end);</span><br><span class="line">       str.getChars(value, start);</span><br><span class="line">       count = newCount;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可以看到他们均使用了System.arraycopy方法。这儿不再一一赘述。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>我们再看一下StringBuilder的源码。发现它与StringBuffer差别很小。</strong></p><p><strong>不同点：</strong></p><ol><li><p>增删改操作上没有synchronized关键字。</p></li><li><p>没有private transient char[] toStringCache;的定义。</p></li></ol><p>第一点正好验证了StringBuilder不是线程安全的，第二点StringBuffer中toStringCache的引入是为了在多线程并发下读取写入数据起到一定的缓存缓冲作用。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>我们可以看到，无论StringBuilder还是StringBuffer，都是AbstractStringBuilder的实现类。</p><p>AbstractStringBuilder对字符串的操作，实质是将它存储在一个char数组中，这样减小了内存开销。我们知道，如果使用String连加，会创造大量String对象，GC来不及回收，导致OOM异常或内存开销增大。StringBuffer和StringBuilder对String的操作完美的解决了这个问题，且相当于提供了操作字符串更加直观的方法（如insert，delete，append等）。这是值得我们借鉴和学习的。</p><p>以上就是StringBuffer和StringBuilder的源码分析。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我们知道，对于一般大量频繁的String操作，我们不建议也不应该直接用String进行相加操作，而我们应借助StringBuffer或者St
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Integer源码解析</title>
    <link href="https://www.sakuratears.top/blog/Integer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%9020180811/"/>
    <id>https://www.sakuratears.top/blog/Integer源码解析20180811/</id>
    <published>2018-08-11T06:56:00.000Z</published>
    <updated>2018-08-11T07:36:07.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天我们来分析一下Integer源码。</p><p>Integer是八种包装类里面的比较常用的一种。那在使用时有什么注意及学习的地方呢？</p><p>让我们一起来看一下</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>Integer是包java.lang下的一个类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Integer</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">//code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其被定义成final类型，继承Number类实现Comparable接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Native</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>   MIN_VALUE = <span class="number">0x80000000</span>;</span><br><span class="line"><span class="meta">@Native</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>   MAX_VALUE = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;Integer&gt;  TYPE = (Class&lt;Integer&gt;) Class.getPrimitiveClass(<span class="string">"int"</span>);</span><br></pre></td></tr></table></figure><p>可以看出，其定义了Integer的最大值为2^31-1，最小值为-2^31。Integer的基本数据类型为int。</p><p>我们来看一下Integer的toString方法，是比较有趣的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == Integer.MIN_VALUE)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"-2147483648"</span>;</span><br><span class="line">    <span class="keyword">int</span> size = (i &lt; <span class="number">0</span>) ? stringSize(-i) + <span class="number">1</span> : stringSize(i);</span><br><span class="line">    <span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[size];</span><br><span class="line">    getChars(i, size, buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法中使用到了stringSize函数，就是求这个Integer数的长度，我们来看看他是如何实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> [] sizeTable = &#123; <span class="number">9</span>, <span class="number">99</span>, <span class="number">999</span>, <span class="number">9999</span>, <span class="number">99999</span>, <span class="number">999999</span>, <span class="number">9999999</span>,</span><br><span class="line">                                  <span class="number">99999999</span>, <span class="number">999999999</span>, Integer.MAX_VALUE &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Requires positive x</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">stringSize</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; ; i++)</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= sizeTable[i])</span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这段代码在计算Integer数长度时，构建了一个一维数组，然后拿x与数组每个值进行比较。而未使用我们经常说的除法或乘法计算长度。我们可以看下源码里的注释。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// I use the "invariant division by multiplication" trick to</span></span><br><span class="line"><span class="comment">// accelerate Integer.toString.  In particular we want to</span></span><br><span class="line"><span class="comment">// avoid division by 10.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The "trick" has roughly the same performance characteristics</span></span><br><span class="line"><span class="comment">// as the "classic" Integer.toString code on a non-JIT VM.</span></span><br><span class="line"><span class="comment">// The trick avoids .rem and .div calls but has a longer code</span></span><br><span class="line"><span class="comment">// path and is thus dominated by dispatch overhead.  In the</span></span><br><span class="line"><span class="comment">// JIT case the dispatch overhead doesn't exist and the</span></span><br><span class="line"><span class="comment">// "trick" is considerably faster than the classic code.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// TODO-<span class="doctag">FIXME:</span> convert (x * 52429) into the equiv shift-add</span></span><br><span class="line"><span class="comment">// sequence.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// RE:  Division by Invariant Integers using Multiplication</span></span><br><span class="line"><span class="comment">//      T Gralund, P Montgomery</span></span><br><span class="line"><span class="comment">//      ACM PLDI 1994</span></span><br></pre></td></tr></table></figure><p>我们知道计算机在计算除法效率要比加减乘法低。所以为了避免除法，提高计算效率，采用此种方法。</p><p>正好我们可以看看Long的toString方法里的stringSize方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Requires positive x</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">stringSize</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> p = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">19</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; p)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        p = <span class="number">10</span>*p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">19</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到使用了乘法。你或许会问为什么没有像Integer那样构建一个数组去比较？额，如果要构造数组，那要构造一个19位的数组，里面有1-19位的数，代码写起来很多很臃肿吧，而且构造好的数组会长期放在内存中，我们知道，在实际应用中，Integer的使用频率要比Long高多了，长期让Long里面的一个数组占据内存空间也不太合理。以上是我个人见解。</p><p>我们再来看一下parseInt方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s, <span class="keyword">int</span> radix)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> NumberFormatException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * WARNING: This method may be invoked early during VM initialization</span></span><br><span class="line"><span class="comment">     * before IntegerCache is initialized. Care must be taken to not use</span></span><br><span class="line"><span class="comment">     * the valueOf method.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NumberFormatException(<span class="string">"null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (radix &lt; Character.MIN_RADIX) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NumberFormatException(<span class="string">"radix "</span> + radix +</span><br><span class="line">                                        <span class="string">" less than Character.MIN_RADIX"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (radix &gt; Character.MAX_RADIX) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NumberFormatException(<span class="string">"radix "</span> + radix +</span><br><span class="line">                                        <span class="string">" greater than Character.MAX_RADIX"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> negative = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, len = s.length();</span><br><span class="line">    <span class="keyword">int</span> limit = -Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> multmin;</span><br><span class="line">    <span class="keyword">int</span> digit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> firstChar = s.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (firstChar &lt; <span class="string">'0'</span>) &#123; <span class="comment">// Possible leading "+" or "-"</span></span><br><span class="line">            <span class="keyword">if</span> (firstChar == <span class="string">'-'</span>) &#123;</span><br><span class="line">                negative = <span class="keyword">true</span>;</span><br><span class="line">                limit = Integer.MIN_VALUE;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstChar != <span class="string">'+'</span>)</span><br><span class="line">                <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (len == <span class="number">1</span>) <span class="comment">// Cannot have lone "+" or "-"</span></span><br><span class="line">                <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        multmin = limit / radix;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">            <span class="comment">// Accumulating negatively avoids surprises near MAX_VALUE</span></span><br><span class="line">            digit = Character.digit(s.charAt(i++),radix);</span><br><span class="line">            <span class="keyword">if</span> (digit &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (result &lt; multmin) &#123;</span><br><span class="line">                <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">            &#125;</span><br><span class="line">            result *= radix;</span><br><span class="line">            <span class="keyword">if</span> (result &lt; limit + digit) &#123;</span><br><span class="line">                <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">            &#125;</span><br><span class="line">            result -= digit;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> negative ? result : -result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到此方法首先进行异常处理，然后判断传入String是否有正负号，然后截取位数，使用乘法，用减法得到int值，然后判断正负并返回结果。</p><p>我们再来看下Integer的内部类IntegerCache。</p><p>这儿可以说是一个坑，也是比较有意思的地方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很容易理解这段代码，初始化Integer后，IntegerCache会缓存[-128,127]之间的数据，这个区间的上限可以配置，取决于java.lang.Integer.IntegerCache.high这个属性，这个属性在VM参数里为-XX:AutoBoxCacheMax=2000进行设置调整或者VM里设置-Djava.lang.Integer.IntegerCache.high=2000。所以Integer在初始化完成后会缓存[-128,max]之间的数据。</p><p>并且我们可以看到valueOf方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到valueOf方法，在cache范围内，返回的是缓存的值，是相同的对象，不在cache范围内，才会新建Integer。</p><p>由于有了Integer缓存，我们可以测试以下代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Integer a=<span class="number">1</span>;</span><br><span class="line">Integer b=<span class="number">1</span>;</span><br><span class="line">Integer c=<span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">Integer d=<span class="number">1000</span>;</span><br><span class="line">Integer e=<span class="number">1000</span>;</span><br><span class="line">System.out.println(a==b);</span><br><span class="line">System.out.println(b==c);</span><br><span class="line">System.out.println(d==e);</span><br></pre></td></tr></table></figure><p>可以看到结果为true,false,false。</p><p>这样，我们在比较Integer时，如果仅仅比较值相等，建议使用equals方法比较。</p><p>我们可以看下Integer的equals方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">        <span class="keyword">return</span> value == ((Integer)obj).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到它会先判断类型是否符合，然后进行拆箱比较操作。</p><p>同样，在Long，Byte，Short，我们也可以看到缓存，其缓存数据长度均是-128到127。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Long</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LongCache</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="title">LongCache</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> Long cache[] = <span class="keyword">new</span> Long[-(-<span class="number">128</span>) + <span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">       <span class="keyword">static</span> &#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">               cache[i] = <span class="keyword">new</span> Long(i - <span class="number">128</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//Byte</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteCache</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="title">ByteCache</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> Byte cache[] = <span class="keyword">new</span> Byte[-(-<span class="number">128</span>) + <span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">       <span class="keyword">static</span> &#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">               cache[i] = <span class="keyword">new</span> Byte((<span class="keyword">byte</span>)(i - <span class="number">128</span>));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//Short</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ShortCache</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="title">ShortCache</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> Short cache[] = <span class="keyword">new</span> Short[-(-<span class="number">128</span>) + <span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">       <span class="keyword">static</span> &#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">               cache[i] = <span class="keyword">new</span> Short((<span class="keyword">short</span>)(i - <span class="number">128</span>));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>关于缓存的意义：在该范围内数据比较常用，添加缓存提高性能。不用每次都新建，浪费系统资源。</p><p>同时根据Integer的hashCode方法，我们可以看到，Integer的hashCode返回本身的int值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.hashCode(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>以上就是Integer的源码分析，可以看到，对于偏底层的一些调用频繁的类，Java都做了很多方面的优化。包括从性能及内存开销等诸多方面。是值得我们学习和理解的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天我们来分析一下Integer源码。&lt;/p&gt;
&lt;p&gt;Integer是八种包装类里面的比较常用的一种。那在使用时有什么注意及学习的地方呢？&lt;
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 数据结构之链表</title>
    <link href="https://www.sakuratears.top/blog/Java-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A820180805/"/>
    <id>https://www.sakuratears.top/blog/Java-数据结构之链表20180805/</id>
    <published>2018-08-05T08:18:00.000Z</published>
    <updated>2018-08-06T12:41:23.329Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 </p><p>由于链表不必按照顺序存储，故在插入数据时可以达到O(1)的复杂度，但是查找的时候就需要遍历，时间复杂度为O(n)。</p><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p>链表根据实现方式一般有三种分类：单向链表、循环链表、双向链表。</p><h2 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h2><p>单向链表指的是链表中的元素的指向只能指向链表中的下一个元素或者为空，元素之间不能相互指向。也就是一种线性链表。</p><p><strong>图示：</strong></p><p><img src="/images/pasted-47.png" alt="upload successful"></p><h3 id="普通单向链表"><a href="#普通单向链表" class="headerlink" title="普通单向链表"></a>普通单向链表</h3><p>用Java代码实现一普通的单向链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;<span class="comment">//链表节点的个数</span></span><br><span class="line">    <span class="keyword">private</span> Node head;<span class="comment">//头节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SingleLinkList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        head = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//链表的每个节点类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Object data;<span class="comment">//每个节点的数据</span></span><br><span class="line">        <span class="keyword">private</span> Node next;<span class="comment">//每个节点指向下一个节点的连接</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Object data)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在链表头添加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">addHead</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        Node newHead = <span class="keyword">new</span> Node(obj);</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            head = newHead;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            newHead.next = head;</span><br><span class="line">            head = newHead;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在链表头删除元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deleteHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Object obj = head.data;</span><br><span class="line">        head = head.next;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//查找指定元素，找到了返回节点Node，找不到返回null</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">find</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        Node current = head;</span><br><span class="line">        <span class="keyword">int</span> tempSize = size;</span><br><span class="line">        <span class="keyword">while</span>(tempSize &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obj.equals(current.data))&#123;</span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            tempSize--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//删除指定的元素，删除成功返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(Object value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node current = head;</span><br><span class="line">        Node previous = head;</span><br><span class="line">        <span class="keyword">while</span>(current.data != value)&#123;</span><br><span class="line">            <span class="keyword">if</span>(current.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                previous = current;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果删除的节点是第一个节点</span></span><br><span class="line">        <span class="keyword">if</span>(current == head)&#123;</span><br><span class="line">            head = current.next;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//删除的节点不是第一个节点</span></span><br><span class="line">            previous.next = current.next;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断链表是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (size == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//显示节点信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span>(size &gt;<span class="number">0</span>)&#123;</span><br><span class="line">            Node node = head;</span><br><span class="line">            <span class="keyword">int</span> tempSize = size;</span><br><span class="line">            <span class="keyword">if</span>(tempSize == <span class="number">1</span>)&#123;<span class="comment">//当前链表只有一个节点</span></span><br><span class="line">                sb.append(<span class="string">"["</span>+node.data+<span class="string">"]"</span>);</span><br><span class="line">                <span class="keyword">return</span> sb.toString();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(tempSize&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(node.equals(head))&#123;</span><br><span class="line">                    sb.append(<span class="string">"["</span>+node.data+<span class="string">"-&gt;"</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(node.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                sb.append(node.data+<span class="string">"]"</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sb.append(node.data+<span class="string">"-&gt;"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.next;</span><br><span class="line">                tempSize--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果链表一个节点都没有，直接打印[]</span></span><br><span class="line">        sb.append(<span class="string">"[]"</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>栈具有先进后出的原则，所以单向链表可以用来实现栈。Java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackSingleLinkList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackSingleLink</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SingleLinkList link;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StackSingleLink</span><span class="params">()</span></span>&#123;</span><br><span class="line">        link = <span class="keyword">new</span> SingleLinkList();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//添加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        link.addHead(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//移除栈顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Object obj = link.deleteHead();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> link.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//打印栈内元素信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> link.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看出，如果对链表的最后一个元素进行操作，需要遍历到链表尾部，在进行操作，十分消耗资源。</p><h3 id="双端链表"><a href="#双端链表" class="headerlink" title="双端链表"></a>双端链表</h3><p>还有一种单向链表称为<strong>双端链表</strong>。这种链表有一个特点，即在链表内添加了对链表尾部的引用。这使得链表可以方便的操作尾部元素。</p><p>Java代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoublePointLinkList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node head;<span class="comment">//头节点</span></span><br><span class="line">    <span class="keyword">private</span> Node tail;<span class="comment">//尾节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;<span class="comment">//节点的个数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Object data;</span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Object data)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoublePointLinkList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        head = <span class="keyword">null</span>;</span><br><span class="line">        tail = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//链表头新增节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addHead</span><span class="params">(Object data)</span></span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(data);</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;<span class="comment">//如果链表为空，那么头节点和尾节点都是该新增节点</span></span><br><span class="line">            head = node;</span><br><span class="line">            tail = node;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            node.next = head;</span><br><span class="line">            head = node;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//链表尾新增节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTail</span><span class="params">(Object data)</span></span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(data);</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;<span class="comment">//如果链表为空，那么头节点和尾节点都是该新增节点</span></span><br><span class="line">            head = node;</span><br><span class="line">            tail = node;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            tail.next = node;</span><br><span class="line">            tail = node;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//删除头部节点，成功返回true，失败返回false</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;<span class="comment">//当前链表节点数为0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="keyword">null</span>)&#123;<span class="comment">//当前链表节点数为1</span></span><br><span class="line">            head = <span class="keyword">null</span>;</span><br><span class="line">            tail = <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (size ==<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获得链表的节点个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//显示节点信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span>(size &gt;<span class="number">0</span>)&#123;</span><br><span class="line">            Node node = head;</span><br><span class="line">            <span class="keyword">int</span> tempSize = size;</span><br><span class="line">            <span class="keyword">if</span>(tempSize == <span class="number">1</span>)&#123;<span class="comment">//当前链表只有一个节点</span></span><br><span class="line">                sb.append(<span class="string">"["</span>+node.data+<span class="string">"]"</span>);</span><br><span class="line">                <span class="keyword">return</span> sb.toString();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(tempSize&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(node.equals(head))&#123;</span><br><span class="line">                    sb.append(<span class="string">"["</span>+node.data+<span class="string">"-&gt;"</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(node.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                sb.append(node.data+<span class="string">"]"</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sb.append(node.data+<span class="string">"-&gt;"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.next;</span><br><span class="line">                tempSize--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果链表一个节点都没有，直接打印[]</span></span><br><span class="line">        sb.append(<span class="string">"[]"</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双端链表可以用来实现队列，相关实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueLinkList</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> DoublePointLinkList dp;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">QueueLinkList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        dp = <span class="keyword">new</span> DoublePointLinkList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Object data)</span></span>&#123;</span><br><span class="line">        dp.addTail(data);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>&#123;</span><br><span class="line">        dp.deleteHead();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dp.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dp.getSize();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dp.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有序链表"><a href="#有序链表" class="headerlink" title="有序链表"></a>有序链表</h3><p>上面所说的单链表数据都是无序的，我们可以构建一个有序的单向链表。即有序链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderLinkList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderLinkList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    size=<span class="number">0</span>;</span><br><span class="line">        head = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//插入节点，并按照从小打到的顺序排列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(value);</span><br><span class="line">        Node pre = <span class="keyword">null</span>;</span><br><span class="line">        Node current = head;</span><br><span class="line">        <span class="keyword">while</span>(current != <span class="keyword">null</span> &amp;&amp; value &gt; current.data)&#123;</span><br><span class="line">            pre = current;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre == <span class="keyword">null</span>)&#123;</span><br><span class="line">            head = node;</span><br><span class="line">            head.next = current;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre.next = node;</span><br><span class="line">            node.next = current;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//删除头节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">        head = head.next;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (size ==<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">    StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        Node current = head;</span><br><span class="line">        <span class="keyword">while</span>(current != <span class="keyword">null</span>)&#123;</span><br><span class="line">            sb.append(current.data+<span class="string">" "</span>);</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于有序链表，可以看出，插入或删除某一项最多需要O(n)的时间复杂度（遍历），但如果我们每次只删除最小值，且对插入没有过高要求的话，有序链表是一个不错的选择，比如优先级队列就可以利用有序链表实现。</p><p>比如我们插入int数并以最小值为优先级，每次取最小的int值的队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueOrderLinkList</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> OrderLinkList dp;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">QueueOrderLinkList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        dp = <span class="keyword">new</span> OrderLinkList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        dp.insert(data);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>&#123;</span><br><span class="line">        dp.deleteHead();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dp.getSize();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dp.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dp.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单向链表的用途可以说是十分广泛的。</p><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>双向链表即是这样一个有序的结点序列，每个链表元素既有指向下一个元素的指针，又有指向前一个元素的指针，其中每个结点都有两种指针，即left和right。left指针指向左边结点，right指针指向右边结点。所以双向链表是可以从两个方向进行遍历的。</p><p><strong>图示：</strong></p><p><img src="/images/pasted-48.png" alt="upload successful"></p><p>双向链表的Java实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleWayLinkList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node head;<span class="comment">//表示链表头</span></span><br><span class="line">    <span class="keyword">private</span> Node tail;<span class="comment">//表示链表尾</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;<span class="comment">//表示链表的节点个数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Object data;</span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line">        <span class="keyword">private</span> Node prev;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Object data)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoubleWayLinkList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        head = <span class="keyword">null</span>;</span><br><span class="line">        tail = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在链表头增加节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addHead</span><span class="params">(Object value)</span></span>&#123;</span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            head = newNode;</span><br><span class="line">            tail = newNode;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            head.prev = newNode;</span><br><span class="line">            newNode.next = head;</span><br><span class="line">            head = newNode;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在链表尾增加节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTail</span><span class="params">(Object value)</span></span>&#123;</span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            head = newNode;</span><br><span class="line">            tail = newNode;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            newNode.prev = tail;</span><br><span class="line">            tail.next = newNode;</span><br><span class="line">            tail = newNode;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//删除链表头</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">deleteHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="keyword">if</span>(size != <span class="number">0</span>)&#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            head.prev = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//删除链表尾</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">deleteTail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node temp = tail;</span><br><span class="line">        <span class="keyword">if</span>(size != <span class="number">0</span>)&#123;</span><br><span class="line">            tail = tail.prev;</span><br><span class="line">            tail.next = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获得链表的节点个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断链表是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (size == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//显示节点信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">    StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span>(size &gt;<span class="number">0</span>)&#123;</span><br><span class="line">            Node node = head;</span><br><span class="line">            <span class="keyword">int</span> tempSize = size;</span><br><span class="line">            <span class="keyword">if</span>(tempSize == <span class="number">1</span>)&#123;<span class="comment">//当前链表只有一个节点</span></span><br><span class="line">                sb.append(<span class="string">"["</span>+node.data+<span class="string">"]"</span>);</span><br><span class="line">                <span class="keyword">return</span> sb.toString();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(tempSize&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(node.equals(head))&#123;</span><br><span class="line">                sb.append(<span class="string">"["</span>+node.data+<span class="string">"-&gt;"</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(node.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                sb.append(node.data+<span class="string">"]"</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sb.append(node.data+<span class="string">"-&gt;"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.next;</span><br><span class="line">                tempSize--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果链表一个节点都没有，直接打印[]</span></span><br><span class="line">        sb.append(<span class="string">"[]"</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用双向链表可以构建双端队列。在这儿就不上代码了，和之前的队列构造类似。</p><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>循环链表指的是在单向链表和双向链表的基础上，将两种链表的最后一个结点指向第一个结点从而实现循环。</p><p><strong>图示：</strong></p><p><img src="/images/pasted-49.png" alt="upload successful"></p><p>循环链表的Java实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleLinkList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">// 链表的每个节点类</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Object data;<span class="comment">// 每个节点的数据</span></span><br><span class="line"><span class="keyword">private</span> Node&lt;T&gt; next;<span class="comment">// 每个节点指向下一个节点的连接</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.data = data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node&lt;T&gt; head, tail;</span><br><span class="line">Node&lt;T&gt; p;</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CircleLinkList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.head = <span class="keyword">null</span>;</span><br><span class="line">tail = head;</span><br><span class="line">p = head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加节点</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">Node node = <span class="keyword">new</span> Node&lt;T&gt;(data);</span><br><span class="line"><span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">head = node;</span><br><span class="line">tail = head;</span><br><span class="line">p = head;</span><br><span class="line">size++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">node.next = head;</span><br><span class="line">head = node;</span><br><span class="line">tail.next = head;</span><br><span class="line">p = head;</span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 得到数据</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">p = head;</span><br><span class="line"><span class="keyword">while</span> (i != index &amp;&amp; p != tail) &#123;</span><br><span class="line">i++;</span><br><span class="line">p = p.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (T) p.data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head != <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，使用循环链表可以实现循环队列。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>链表作为数据结构的一部分，应用是十分广泛的，我们上面说明了几种链表在不同情况下的应用，链表是我们应当学会掌握和使用的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>一款基于JQuery和bootstrap的单页面WebApp框架</title>
    <link href="https://www.sakuratears.top/blog/%E4%B8%80%E6%AC%BE%E5%9F%BA%E4%BA%8EJQuery%E5%92%8Cbootstrap%E7%9A%84%E5%8D%95%E9%A1%B5%E9%9D%A2WebApp%E6%A1%86%E6%9E%B620180730/"/>
    <id>https://www.sakuratears.top/blog/一款基于JQuery和bootstrap的单页面WebApp框架20180730/</id>
    <published>2018-07-30T08:25:00.000Z</published>
    <updated>2018-07-30T10:42:44.936Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>现在React.js，Vue.js等MVVM框架逐渐火了起来，今天，先暂时不说这些。</p><p>我在之前呆过一家公司，他们前端封装了一套基于JQuery和bootstrap的单页面WebApp框架，虽然技术栈方面可能比较落后了，且是基于CSS，Html，JavaScript分层的。与现在的模块化开发有些不同。但是它的一些封装思想是值得我们学习的。</p><p>而且这个框架，让我这个前端小白（我是后端开发）对前端JS产生了很大兴趣，特此写下这篇文章来分析和纪念这个框架。</p><p>框架主页：<a href="https://github.com/JavaZWT/JQueryApp" target="_blank" rel="noopener">https://github.com/JavaZWT/JQueryApp</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><p>这款框架也是基于Node.js搭建的，主要是用了gulp，还包含了css,html,js压缩，js校验等包。其环境启动包依赖如下图：</p><p><img src="/images/pasted-30.png" alt="upload successful"></p><p>在项目的package.json里可以看到。</p><p><strong>关于为什么引用这些插件的说明：</strong></p><ol><li>js，img，png等的压缩，可大幅度减小生成的资源包体积，在生成APK后用户当然是希望安装包要小越好。如果gulp到服务器WebRoot目录下，当用户访问项目资源时，体积小的静态资源更能减小用户流量开支，提高系统响应速度，增强用户体验。</li><li>创建一个前端webserver服务器，相当于提供了一个前端APK环境（可以这么理解），大部分bug在浏览器上就可以复现和解决，减少了打包到apk里的繁琐流程，提高开发效率。</li></ol><p>根据以上介绍，大家应该知道node_modules,gulpfile.js,package.json,package-lock.json都不会被打到前台资源包中。</p><p>package.json里的依赖，都可以通过npm install （同级目录执行）的方式安装，安装后就会生成node_modules文件夹。</p><p><strong>安装启动前端环境主要有以下三个步骤。</strong></p><ol><li><p>npm install -g gulp</p><p> 安装全局gulp，使gulp可以在任何目录下使用，和java环境变量差不多。</p></li><li><p>npm install  </p><p> 安装环境依赖，需要到有package.json的文件夹下执行。</p></li><li><p>gulp</p><p> 启动前端webserver</p></li></ol><h2 id="gulpfile-js"><a href="#gulpfile-js" class="headerlink" title="gulpfile.js"></a>gulpfile.js</h2><p>再来说下gulpfile.js</p><p>光有插件也不行啊，这个文件就是把插件们拿来用的。</p><p>关于这个js，我们简单说下配置及使用。</p><ol><li><p>参数配置envConfig</p><p> env：启动模式，有三种，DEV，DEBUG，PRO。DEV和DEBUG模式下不会压缩js和图片，节省时间，便于调试。</p><p> distPath: 生成的前端资源文件路径，有的gulpfile.js里面没有它，其他是分开的，那个可以生成发布在webapp目录下的资源文件。</p><p> <img src="/images/pasted-45.png" alt="upload successful"></p></li><li><p>webserverConfig</p><p> 服务器启动配置参数</p><p> port ：默认打开的端口号</p><p> open：默认代开的文件名</p><p> host：默认打开的地址，不配置的话默认localhost</p><p> livereload:即时刷新，主要用来检测文件变化。</p><p> <img src="/images/pasted-46.png" alt="upload successful"></p></li></ol><h2 id="项目架构图"><a href="#项目架构图" class="headerlink" title="项目架构图"></a>项目架构图</h2><p><img src="/images/pasted-31.png" alt="upload successful"></p><h2 id="架构说明："><a href="#架构说明：" class="headerlink" title="架构说明："></a>架构说明：</h2><ol><li><p>public</p><p> 前端项目文件夹。</p></li><li><p>css</p><p> 用于存放页面css样式的文件夹，理论上里面的文件都会被放入生成的前端资源包。</p></li><li><p>html</p><p> 用于放置前端页面的文件夹，理论上里面的文件都会被放入生成的前端资源包。</p></li><li><p>js</p><p> 用于放置前端js的文件夹，理论上里面的文件都会被放入生成的前端资源包。</p></li><li><p>node_modules</p><p> npm install 后生成的文件夹，是前端资源包的打包环境及在Web浏览器上查看及debug App提供支持。</p></li><li><p>resources</p><p> 用于放置前端静态资源的文件夹，如图片，字体，静态json等，理论上里面的文件都会被放入前端资源包。</p></li><li><p>gulpfile.js</p><p> 构建前端环境，生成前端资源包的主要文件。</p></li><li><p>index.html</p><p> 前端主要页面，所有资源理论上都会被按需加载进来。</p></li><li><p>package-lock.json</p><p> npm install 之后生成的文件，存放着一些npm之后的包的信息。</p></li><li><p>package.json</p><p>构建前端环境，生成前端资源包的主要文件，里面放置着构建环境及生成资源包所需的依赖。</p></li></ol><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>分析这个框架，我们先从index.html入手，单页面的操作实现主要是将目标html移到这个index.html里实现的。</p><p><img src="/images/pasted-32.png" alt="upload successful"></p><p>可以看下index.html里面的几个主要id，如上图。</p><p>index.html引入了相关js及css。</p><p><img src="/images/pasted-33.png" alt="upload successful"></p><p><img src="/images/pasted-34.png" alt="upload successful"></p><p>我们看下api.js和app.js</p><p>项目启动后会调用到此方法，详见index.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadViewport</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="keyword">var</span> path;</span><br><span class="line"> <span class="keyword">if</span>(location.hash.indexOf(<span class="string">"?"</span>)&gt;<span class="number">-1</span>)&#123;</span><br><span class="line"> path = location.hash.substr(<span class="number">0</span>,location.hash.indexOf(<span class="string">"?"</span>));</span><br><span class="line"> &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> path = location.hash;</span><br><span class="line"> &#125;</span><br><span class="line"> path = (path || <span class="string">'#'</span> + api.route.default.path).slice(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//如果没有配置路径则不做操作</span></span><br><span class="line">     <span class="keyword">if</span>(!api.route[path])&#123;</span><br><span class="line">         api.globalLoading.hide();</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">'[APP] 没有查询到路径:'</span>+ path + <span class="string">',不进行加载'</span>);</span><br><span class="line">     &#125;<span class="keyword">else</span> <span class="keyword">if</span>(api.curr.clean)&#123;</span><br><span class="line">         <span class="keyword">switch</span>(api.curr.clean.length)&#123;</span><br><span class="line">             <span class="keyword">case</span> <span class="number">0</span>:<span class="comment">//如果不包含参数 则认为这是一个同步 直接执行完成后 加载页面</span></span><br><span class="line">                 api.curr.clean();</span><br><span class="line">                 load();</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> <span class="number">1</span>:<span class="comment">//如果只接收一个参数,则传入回调函数 等待页面完成后自行处理</span></span><br><span class="line">                 api.curr.clean(load);</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> <span class="number">2</span>:<span class="comment">//如果接收两个参数 则分别是 要跳转页面的hash,回调函数</span></span><br><span class="line">                 api.curr.clean(path,load);</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">default</span>:<span class="comment">//如果接收大于2个参数 则只传入三个 分别是 要跳转页面的hash,要跳转页面的配置在route中的数据,回调函数</span></span><br><span class="line">                 api.curr.clean(path,api.route[path],load);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         load();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         api.globalLoading.show();</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">'[APP] 开始加载页面['</span>+path+<span class="string">']'</span>);</span><br><span class="line">         api.loadPath(path,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">             <span class="built_in">console</span>.log(<span class="string">'[APP] 加载页面&lt;p&gt;['</span>+path+<span class="string">']&lt;/p&gt;完成'</span>);</span><br><span class="line"></span><br><span class="line">             api.plugins.header(data,path);</span><br><span class="line"></span><br><span class="line">             <span class="comment">//如果页面没有设置 则默认隐藏全局loading</span></span><br><span class="line">             <span class="keyword">if</span>(!data || !data.selfHideLoading) api.globalLoading.hide();</span><br><span class="line">         &#125;);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> api.loadViewport = loadViewport;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 当浏览器的hash发生变化时进行页面的加载</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="built_in">window</span>.onhashchange = loadViewport;</span><br></pre></td></tr></table></figure><p><strong>其原理就是利用location.hash的？后半段，进行地址跳转，加载在route里配置的相关html及js，加载之前移除原来的html和js，以实现页面跳转。</strong></p><h1 id="方法及使用"><a href="#方法及使用" class="headerlink" title="方法及使用"></a>方法及使用</h1><h2 id="api-js"><a href="#api-js" class="headerlink" title="api.js"></a>api.js</h2><p><strong>1、route,modal</strong></p><p><img src="/images/pasted-35.png" alt="upload successful"></p><p>新增一个页面，可以添加在route里，新增一个模态框，可以添加在modal里。</p><p><strong>2、api.globalLoading</strong></p><p>全局loading，有两个方法:</p><p>api.globalLoading.show();</p><p>api.globalLoading.hide();</p><p>一般应用在ajax发送前后，当需要等待操作处理时，也可以直接调用。</p><p><img src="/images/pasted-36.png" alt="upload successful"></p><p><strong>3、api.globalShadow</strong></p><p>全局shadow，是一个z-index为2000的透明遮罩层。</p><p>有两个方法：</p><p>api.globalShadow.hide();</p><p>api.globalShadow.show();</p><p>一般调用模态框时会被加载，自己写一些插件集成在里面时可以自己控制处理下。</p><p><strong>4、api.modal.exec</strong></p><p>调用模态框时会使用此方法，由于模态框和页面不太一样，模态框关闭后再打开可以保证数据不用重新加载。</p><p><img src="/images/pasted-37.png" alt="upload successful"></p><p><strong>5、api.loadJS</strong></p><p>框架中加载js用到的方法，分为串行加载和并行加载，各有利弊。</p><p><img src="/images/pasted-38.png" alt="upload successful"></p><p><strong>6、api.loadModal</strong></p><p>modal加载方法，刚才提到的那个是这一个的进一步封装，这里面的方法显示了modal是如何被加载的，这里应注意，modal默认只会被加载一次。</p><p><img src="/images/pasted-39.png" alt="upload successful"></p><p><strong>7、api.loadPath</strong></p><p>页面跳转实现的主要方法，这个方法制定跳转path后，会在route里寻找，若没有此页面，则不会跳转。</p><p><img src="/images/pasted-40.png" alt="upload successful"></p><p><strong>8、loadViewport</strong></p><p>刚才提到了，这个可以控制页面hash路由跳转。也是页面跳转的主要方法。</p><h2 id="app-js"><a href="#app-js" class="headerlink" title="app.js"></a>app.js</h2><p><strong>1、app.alert</strong></p><p>消息提示框方法，只有一个确认键。</p><p><img src="/images/pasted-41.png" alt="upload successful"></p><p><strong>2、app.confirm</strong></p><p>消息提示框，有确认和取消两个按钮。</p><p><img src="/images/pasted-42.png" alt="upload successful"></p><p><strong>3、app.ajax</strong></p><p>基于JQuery ajax后自己封装的一套ajax，增加里请求头签名等等。</p><p><img src="/images/pasted-43.png" alt="upload successful"></p><h2 id="cordova-js"><a href="#cordova-js" class="headerlink" title="cordova.js"></a>cordova.js</h2><p>自己封装的一个cordova工具，根据设备类型不同（Android，iOS）调用不同的cordova插件。</p><h2 id="GlobalValue-js"><a href="#GlobalValue-js" class="headerlink" title="GlobalValue.js"></a>GlobalValue.js</h2><p>全局变量控制插件，通过sessionStorage存储变量。</p><p><img src="/images/pasted-44.png" alt="upload successful"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>还有很多部分没有介绍到，但框架的关键部分都介绍了，要想清楚明白，可以自己在框架上写个页面或者完善个插件来试试。加深对它的理解。</p><p>虽然在现在前端框架日新月异的今天，虚拟dom流行的今天，感觉这个框架已经过时了，但是思想永不过时，框架设计上的一些思想还是值得我们学习和借鉴的。</p><p>关于这个框架有什么问题欢迎留言，也可以直接在GitHub上提问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;现在React.js，Vue.js等MVVM框架逐渐火了起来，今天，先暂时不说这些。&lt;/p&gt;
&lt;p&gt;我在之前呆过一家公司，他们前端封装了一套
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="JavaScript" scheme="https://www.sakuratears.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Java Stack类简介</title>
    <link href="https://www.sakuratears.top/blog/Java-Stack%E7%B1%BB%E7%AE%80%E4%BB%8B20180726/"/>
    <id>https://www.sakuratears.top/blog/Java-Stack类简介20180726/</id>
    <published>2018-07-26T09:45:00.000Z</published>
    <updated>2018-07-28T16:19:43.234Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>栈（Stack）是限定只能在一段进行插入和删除操作的线性表。</p><p>进行插入和删除操作的一端称为“栈顶”（top），另一端称为“栈底”（bottom）。</p><p>栈的插入操作称为“入栈”(push)，栈的删除 操作称为“出栈”（pop）。</p><p>栈具有后进先出（LIFO），先进后出(FILO)的特性。</p><h1 id="Stack类"><a href="#Stack类" class="headerlink" title="Stack类"></a>Stack类</h1><p>Java工具包下的Stack类继承于Vector，由此可见Stack底层是由数组实现的。</p><p><strong>Stack和Collection的关系如下图：</strong></p><p><img src="/images/pasted-29.png" alt="upload successful"></p><p>我们来看下Stack的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将一个元素压入栈顶</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">push</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">        addElement(item);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取出栈顶的一个元素，并删除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        E       obj;</span><br><span class="line">        <span class="keyword">int</span>     len = size();</span><br><span class="line"></span><br><span class="line">        obj = peek();</span><br><span class="line">        removeElementAt(len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取出栈顶元素，不删除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>     len = size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        <span class="keyword">return</span> elementAt(len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断栈是不是空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找元素在栈的位置，没有返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = lastIndexOf(o);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> size() - i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1224463164541339165L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据源码，可以发现Stack的方法调用了Vector类的方法，实现了线程安全。</p><p>我们主要看一下Vector里的下面三个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加一个元素</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addElement</span><span class="params">(E obj)</span> </span>&#123;</span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="comment">//确认容量，不够会扩容</span></span><br><span class="line">       ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">       elementData[elementCount++] = obj;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//移除指定位置的元素</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">removeElementAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="keyword">if</span> (index &gt;= elementCount) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">" &gt;= "</span> +</span><br><span class="line">                                                    elementCount);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> j = elementCount - index - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index, j);</span><br><span class="line">       &#125;</span><br><span class="line">       elementCount--;</span><br><span class="line">       <span class="comment">//赋空，便于垃圾回收</span></span><br><span class="line">       elementData[elementCount] = <span class="keyword">null</span>; </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//找出在指定位置的元素</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">elementAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (index &gt;= elementCount) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">" &gt;= "</span> + elementCount);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> elementData(index);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>关联方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityHelper</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       如果长度超了就扩容</span><br><span class="line">       <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">           grow(minCapacity);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//扩容方法</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">       <span class="comment">//新的容量定义：如果有容量增量且大于0，取增量，否则执行2倍扩容</span></span><br><span class="line">       <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                        capacityIncrement : oldCapacity);</span><br><span class="line">       <span class="comment">//扩容后容量比传入容量还小，就取传入容量。</span></span><br><span class="line">       <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           newCapacity = minCapacity;</span><br><span class="line">       <span class="comment">//新容量比数组最大长度还大</span></span><br><span class="line">       <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">       <span class="comment">//计算容量</span></span><br><span class="line">           newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">       elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//计算容量</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) </span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">       <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">           Integer.MAX_VALUE :</span><br><span class="line">           MAX_ARRAY_SIZE;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>我们如何用数组实现自己的一个stack呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line"><span class="comment">//栈元素组</span></span><br><span class="line"><span class="keyword">private</span> Object[] members;</span><br><span class="line">    <span class="comment">//指针</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">//自定义初始栈长度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">(<span class="keyword">int</span> initCapacity)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(initCapacity&lt;=<span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.members=<span class="keyword">new</span> Object[initCapacity];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//默认栈长度为10</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.members=<span class="keyword">new</span> Object[<span class="number">10</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//元素入栈</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">ensureCapacity(size+<span class="number">1</span>);</span><br><span class="line">members[size++]=o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//元素出栈</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(size&lt;=<span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> members[--size];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查看栈顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">peek</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(size&lt;=<span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> members[size-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//确认容量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line"><span class="comment">//size+1比数组长度要长，扩容</span></span><br><span class="line"><span class="keyword">if</span>(minCapacity-members.length&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> oldCapacity = members.length;</span><br><span class="line">        Object oldMembers=members;</span><br><span class="line">        <span class="comment">//扩容到二倍</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = <span class="number">2</span> * oldCapacity ;</span><br><span class="line">        <span class="comment">//扩容后还不够或者超过int最大值，就直接赋值size+1</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        members=<span class="keyword">new</span> Object[newCapacity];</span><br><span class="line">        <span class="comment">//拷贝数组</span></span><br><span class="line">        System.arraycopy(oldMembers, <span class="number">0</span>, members, <span class="number">0</span>, size);</span><br><span class="line">        oldMembers=<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码就是一个简易的Stack的实现方式。</p><p>代码见： <a href="https://github.com/JavaZWT/sakuratears" target="_blank" rel="noopener">https://github.com/JavaZWT/sakuratears</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Stack类在编程过程中用到的不是很多，但是计算机栈内存机制遵循先进后出原则，学习Stack类，可以帮助我们加深对程序及数据结构的理解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;栈（Stack）是限定只能在一段进行插入和删除操作的线性表。&lt;/p&gt;
&lt;p&gt;进行插入和删除操作的一端称为“栈顶”（top），另一端称为“栈底
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java正则表达式使用</title>
    <link href="https://www.sakuratears.top/blog/Java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BD%BF%E7%94%A820180721/"/>
    <id>https://www.sakuratears.top/blog/Java正则表达式使用20180721/</id>
    <published>2018-07-21T08:52:00.000Z</published>
    <updated>2018-07-21T12:00:16.335Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>1.什么是正则表达式？</p><p>正则表达式是一种可以用于模式匹配和替换的强有力的工具。</p><p>2.为什么要使用正则表达式？有什么优点缺点？</p><p>正则表达式在参数校验、参数匹配方面可以发挥重大作用。</p><p>优点：更少的代码，更高的效率。</p><p>缺点：需要一定时间的学习及记忆，不然理解晦涩。</p><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="符号及其含义"><a href="#符号及其含义" class="headerlink" title="符号及其含义"></a>符号及其含义</h2><p>下表是正则表达式的所有符号及含义。</p><table><tr><td colspan="2" style="color:red;"><center><strong>常用的符号</strong></center></td></tr><tr><td style="color:red;"><strong>.</strong></td><td>表示任意字符</td></tr><tr><td style="color:red;"><strong>\s</strong></td><td>空格字符(空格键, tab, 换行, 换页, 回车)</td></tr><tr><td style="color:red;"><strong>\S</strong></td><td>非空格字符([^\s])</td></tr><tr><td style="color:red;"><strong>\d</strong></td> <td>一个数字，(相当于[0-9] )</td></tr><tr><td style="color:red;"><strong>\D</strong></td><td>一个非数字的字符，(相当于[^0-9] )</td></tr><tr><td style="color:red;"><strong>\w</strong></td><td>一个单词字符(word character) (相当于 [a-zA-Z_0-9] )</td></tr><tr><td style="color:red;"><strong>\W</strong></td><td>一个非单词的字符，[^\w]</td></tr><tr><td style="color:red;"><strong>^</strong></td><td>一行的开始</td></tr><tr><td style="color:red;"><strong>$</strong></td><td>一行的结尾</td></tr><tr><td style="color:red;"><strong>\b</strong></td><td>一个单词的边界</td> </tr><tr><td style="color:red;"><strong>\B</strong></td><td>一个非单词的边界</td></tr><tr><td style="color:red;"><strong>\G</strong></td><td>前一个匹配的结束</td> </tr><tr><td style="color:red;"><strong>[]</strong></td><td>匹配方括号内的一个字符<br>例如:[abc] 表示字符 a，b，c 中的任意一个(与 a|b|c 相同) <br>[a-zA-Z]表示从a到z或A到Z当中的任意一个字符</td></tr><tr><td colspan="2" style="color:red;"><center><strong>表示次数的符号</strong></center></td></tr><tr><td style="color:red;"><strong>*</strong></td><td>重复零次或更多次<br>例如:a* 匹配零个或者多个 a</td></tr><tr><td style="color:red;"><strong>+</strong></td><td>重复一次或更多次<br>例如:a+ 匹配一个或者多个 a</td></tr><tr><td style="color:red;"><strong>?</strong></td><td>重复零次或一次<br>例如:a? 匹配零个或一个 a</td></tr><tr><td style="color:red;"><strong>{n}</strong></td><td>重复n次<br>例如:a{4}匹配4个a</td> </tr><tr><td style="color:red;"><strong>{n,}</strong></td><td>重复 n 次或更多次<br>例如:a{4,} 匹配至少 4 个 a</td></tr><tr><td style="color:red;"><strong>{n,m}</strong></td><td>重复n到m次<br>例如:a{4,10} 匹配 4~10 个 a</td></tr></table><h2 id="正则表达式实例"><a href="#正则表达式实例" class="headerlink" title="正则表达式实例"></a>正则表达式实例</h2><p>java 正则表达式通过 java.util.regex 包下的 Pattern 类与 Matcher 类实现:</p><p>正则表达式使用总共分三步:</p><ol><li>构造一个模式.<br> Pattern p=Pattern.compile(“[a-z]*”); </li><li>建造一个匹配器<br> Matcher m = p.matcher(str); </li><li>进行判断，得到结果<br> boolean b = m.matches();</li></ol><p>Matcher 类提供三个匹配操作方法,三个方法均返回 boolean 类型,当匹配到 时返回 true,没匹配到则返回 false</p><ol><li><p>m.matches()</p><p> matches()对整个字符串进行匹配,只有整个字符串都匹配了才返回 true</p></li><li><p>m.lookingAt() </p><p> lookingAt()对前面的字符串进行匹配,只有匹配到的字符串在最前面才返 回 true</p></li><li><p>m.find()</p><p> find()对字符串进行匹配,匹配到的字符串可以在任何位置</p></li></ol><p>Matcher 类的其他方法:</p><ol><li><p>int groupcount() </p><p> 返回此匹配器模式中的捕获组数。</p></li><li><p>String replaceAll(String replacement)</p><p> 用给定的 replacement 全部替代匹配的 部分</p></li><li><p>String repalceFirst(String replacement) </p><p> 用给定的 replacement 替代第一次匹 配的部分</p></li><li><p>appendReplacement(StringBuffer sb,String replacement) </p><p> 根 据 模 式 用 replacement 替换相应内容,并将匹配的结果添加到 sb 当前位置之后 </p></li><li><p>StringBuffer appendTail(StringBuffer sb) </p><p> 将输入序列中匹配之后的末尾字串 添加到 sb 当前位置之后.</p></li><li><p>group(n)</p><p> 0 代表永远都是匹配整个表达式的字符串的那部分 n&lt;&gt;0 时代表 第 n 组匹配的部分</p></li></ol><h2 id="正则表达式的用法"><a href="#正则表达式的用法" class="headerlink" title="正则表达式的用法"></a>正则表达式的用法</h2><ol><li><p>字符匹配</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Pattern p = Pattern.compile(expression); <span class="comment">// 正则表达式 </span></span><br><span class="line">Matcher m = p.matcher(str); <span class="comment">// 操作的字符串</span></span><br><span class="line"><span class="keyword">boolean</span> b = m.matches(); <span class="comment">//返回是否匹配的结果 </span></span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure></li><li><p>分割字符串</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Pattern pattern = Pattern.compile(expression); <span class="comment">//正则表达式</span></span><br><span class="line">String[] strs = pattern.split(str); <span class="comment">//操作字符串 得到返回的字符串数组</span></span><br></pre></td></tr></table></figure></li><li><p>替换字符串</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pattern p = Pattern.compile(expression); <span class="comment">// 正则表达式 </span></span><br><span class="line">   Matcher m = p.matcher(text); <span class="comment">// 操作的字符串</span></span><br><span class="line">String s = m.replaceAll(str); <span class="comment">//替换后的字符串</span></span><br></pre></td></tr></table></figure></li><li><p>查找替换指定字符串</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Pattern p = Pattern.compile(expression); <span class="comment">// 正则表达式 </span></span><br><span class="line">   Matcher m = p.matcher(text); <span class="comment">// 操作的字符串 </span></span><br><span class="line">   StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (m.find()) &#123;</span><br><span class="line">m.appendReplacement(sb, str);</span><br><span class="line">i++; <span class="comment">//字符串出现次数</span></span><br><span class="line">&#125;</span><br><span class="line">m.appendTail(sb);<span class="comment">//从截取点将后面的字符串接上 </span></span><br><span class="line">   String s = sb.toString();</span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><p>查找输出字符串</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Pattern p = Pattern.compile(expression); <span class="comment">// 正则表达式 </span></span><br><span class="line">   Matcher m = p.matcher(text); <span class="comment">// 操作的字符串</span></span><br><span class="line"><span class="keyword">while</span> (m.find()) &#123;</span><br><span class="line"><span class="comment">//m.start() 返回匹配到的子字符串在字符串中的索引位置. </span></span><br><span class="line">   <span class="comment">//m.end()返回匹配到的子字符串的最后一个字符在字符串中的索引位置.</span></span><br><span class="line">   <span class="comment">//m.group()返回匹配到的子字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="常用的正则表达式"><a href="#常用的正则表达式" class="headerlink" title="常用的正则表达式"></a>常用的正则表达式</h2><ol><li><p>手机号码校验</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPhone</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">Pattern p = Pattern.compile(<span class="string">"^[1][3,5,7,8]+\\d&#123;9&#125;"</span>); <span class="comment">//正则表达式</span></span><br><span class="line">Matcher m = p.matcher(str); <span class="comment">//操作的字符串</span></span><br><span class="line"><span class="keyword">return</span> m.matches();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>邮箱地址校验</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isEmail</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">Pattern p = Pattern.compile(<span class="string">"^[a-zA-Z0-9_.-]+@[a-zA-Z0-9-]+(\\.[a-zA-Z0-9-]+)*\\.[a-zA-Z0-9]&#123;2,6&#125;$"</span>); <span class="comment">//正则表达式</span></span><br><span class="line">Matcher m = p.matcher(str); <span class="comment">//操作的字符串</span></span><br><span class="line"><span class="keyword">return</span> m.matches();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>IP地址校验</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isIPv4</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">Pattern p = Pattern.compile(<span class="string">"\\d&#123;1,3&#125;+\\.\\d&#123;1,3&#125;+\\.\\d&#123;1,3&#125;+\\.\\d&#123;1,3&#125;"</span>); <span class="comment">//正则表达式</span></span><br><span class="line">Matcher m = p.matcher(str); <span class="comment">//操作的字符串</span></span><br><span class="line"><span class="keyword">return</span> m.matches();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>是不是汉字</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isChinese</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">Pattern p = Pattern.compile(<span class="string">"^[\\u4e00-\\u9fa5]+$"</span>); <span class="comment">//正则表达式</span></span><br><span class="line">Matcher m = p.matcher(str); <span class="comment">//操作的字符串</span></span><br><span class="line"><span class="keyword">return</span> m.matches();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><p>QQ号校验</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isQQ</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">Pattern p = Pattern.compile(<span class="string">"[1-9][0-9]&#123;4,13&#125;"</span>); <span class="comment">//正则表达式</span></span><br><span class="line">Matcher m = p.matcher(str); <span class="comment">//操作的字符串</span></span><br><span class="line"><span class="keyword">return</span> m.matches();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>身份证号校验</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isIDNumber</span><span class="params">(String IDNumber)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (IDNumber == <span class="keyword">null</span> || <span class="string">""</span>.equals(IDNumber)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义判别用户身份证号的正则表达式（15位或者18位，最后一位可以为字母）</span></span><br><span class="line">    String regularExpression = <span class="string">"(^[1-9]\\d&#123;5&#125;(18|19|20)\\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\\d&#123;3&#125;[0-9Xx]$)|"</span> +</span><br><span class="line">            <span class="string">"(^[1-9]\\d&#123;5&#125;\\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\\d&#123;3&#125;$)"</span>; </span><br><span class="line">    <span class="keyword">boolean</span> matches = IDNumber.matches(regularExpression);</span><br><span class="line">    <span class="comment">//详细校验略</span></span><br><span class="line">    <span class="keyword">return</span> matches;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="7"><li><p>邮编校验</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMail</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">Pattern p = Pattern.compile(<span class="string">"[1-9]\\d&#123;5&#125;(?!\\d)"</span>); <span class="comment">//正则表达式</span></span><br><span class="line">Matcher m = p.matcher(str); <span class="comment">//操作的字符串</span></span><br><span class="line"><span class="keyword">return</span> m.matches();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="8"><li><p>其他</p><p> 其他常用校验不在一一说明。</p><p> 可以通过  <a href="https://github.com/JavaZWT/sakuratears" target="_blank" rel="noopener">https://github.com/JavaZWT/sakuratears</a>  获取。</p></li></ol><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>如果我们能够熟练掌握正则表达式，一定会对我们的开发提供很大的帮助。</p><p>正则表达式整体上相对于代码来说是比较晦涩的，用好它需要一定的功力及学习能力。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;1.什么是正则表达式？&lt;/p&gt;
&lt;p&gt;正则表达式是一种可以用于模式匹配和替换的强有力的工具。&lt;/p&gt;
&lt;p&gt;2.为什么要使用正则表达式？有什
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>搭建自己的Hexo博客（2）</title>
    <link href="https://www.sakuratears.top/blog/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2%EF%BC%882%EF%BC%8920180717/"/>
    <id>https://www.sakuratears.top/blog/搭建自己的Hexo博客（2）20180717/</id>
    <published>2018-07-17T13:21:00.000Z</published>
    <updated>2018-07-17T14:22:33.751Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>关于之前的部分请参考我的《搭建自己的Hexo博客（1）》这篇文章。</p><h1 id="创建Github账户"><a href="#创建Github账户" class="headerlink" title="创建Github账户"></a>创建Github账户</h1><p>我们把博客发布到Github上。</p><p>首先申请Github账号：<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a></p><p>新建一个Repository</p><p><img src="/images/pasted-22.png" alt="upload successful"></p><p>红框内为项目名称，应写成 yourname.github.io 这种形式。</p><p>如我注册的用户名是JavaZWT，则项目名应写为 JavaZWT.github.io</p><p>新建好后，我们开始发布我们的博客。</p><h1 id="博客发布"><a href="#博客发布" class="headerlink" title="博客发布"></a>博客发布</h1><p>进入到原来的blog文件夹。</p><p>我们要记住以下指令：</p><p>博客本地调试启动：hexo s</p><p>博客部署文件生成：hexo g</p><p>博客发布：hexo d</p><p>博客部署文件夹清空： hexo clean</p><p>hexo g 后，要发布的博客文件会生成在public文件夹下。</p><p>hexo d 会把这个文件夹下的文件deploy到Github上。</p><p>_config.yml配置文件里，指明自己的Github地址上新建的yourname.github.io的项目。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span> </span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="string">git@github.com:JavaZWT/JavaZWT.github.io.git</span></span><br></pre></td></tr></table></figure><p>正常的发布流程：</p><ol><li>新写了一篇博文</li><li>通过hexo s本地调试通过后</li><li>hexo clean 清空public文件夹及db文件</li><li>hexo g 重新生成部署文件</li><li>hexo d 发布到Github</li></ol><p>当我们发布成功后，通过 <a href="https://yourname.github.io/" target="_blank" rel="noopener">https://yourname.github.io/</a> 便可以在外网访问自己的blog啦。</p><h1 id="添加域名"><a href="#添加域名" class="headerlink" title="添加域名"></a>添加域名</h1><p>成功访问之后，我们觉得这个网址不好，想换个自己喜欢的域名怎么办？</p><p>这里我使用了阿里云申请了域名。</p><p>首先登陆阿里云，没有账号请注册申请。</p><p>找到域名与网站（万网）菜单。</p><p><img src="/images/pasted-23.png" alt="upload successful"></p><p>找到自己喜欢的域名进行购买。</p><p>得到域名后，我们需要配置域名解析。把域名指向我们的博客。</p><p>在域名解析列表里我们新增两条记录，如下图红框部分。</p><p>其中记录值可以写 <a href="https://yourname.github.io/" target="_blank" rel="noopener">https://yourname.github.io/</a></p><p>相当于把这个域名指向了<a href="https://yourname.github.io/这个域名。" target="_blank" rel="noopener">https://yourname.github.io/这个域名。</a></p><p>或者我们可以查到 <a href="https://yourname.github.io/" target="_blank" rel="noopener">https://yourname.github.io/</a>  这个域名的IP，直接将新的域名指向这个IP即可。</p><p><img src="/images/pasted-24.png" alt="upload successful"></p><p>配置好后等一段时间，我们访问新的域名，就可以跳转到我们的博客啦。</p><h1 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h1><h2 id="添加音乐播放功能"><a href="#添加音乐播放功能" class="headerlink" title="添加音乐播放功能"></a>添加音乐播放功能</h2><p>找到 /themes/next/layout/_custom/sidebar.swig 文件</p><p>登陆网易云音乐，对于一首歌，生成外链播放器。</p><p><img src="/images/pasted-25.png" alt="upload successful"></p><p><img src="/images/pasted-26.png" alt="upload successful"></p><p>将上述代码复制到sidebar.swig文件里。</p><p>生成如下图所示效果。</p><p><img src="/images/pasted-27.png" alt="upload successful"></p><h2 id="添加博客编写功能"><a href="#添加博客编写功能" class="headerlink" title="添加博客编写功能"></a>添加博客编写功能</h2><p>写博客时是不是很不方便？</p><p>我们安装hexo-admin插件吧。这个插件可以是写博客更快捷方便。</p><p>npm install hexo-admin –save</p><p>安装好后，启动调试博客 hexo s</p><p>输入 <a href="http://localhost:4000/admin/" target="_blank" rel="noopener">http://localhost:4000/admin/</a></p><p>是不是看到进入了博客管理菜单？</p><p>通过这个插件可以方便的管理和书写博客。</p><p><img src="/images/pasted-28.png" alt="upload successful"></p><h2 id="压缩博客"><a href="#压缩博客" class="headerlink" title="压缩博客"></a>压缩博客</h2><p>博客里有一些图片或者css，js过大怎么办，这样会导致博客加载缓慢。</p><p>我们在发布博客时可以先对其进行压缩。</p><p>在blog目录下新建gulpfile.js</p><p>有如下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> minifycss = <span class="built_in">require</span>(<span class="string">'gulp-minify-css'</span>);</span><br><span class="line"><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);</span><br><span class="line"><span class="keyword">var</span> htmlmin = <span class="built_in">require</span>(<span class="string">'gulp-htmlmin'</span>);</span><br><span class="line"><span class="keyword">var</span> htmlclean = <span class="built_in">require</span>(<span class="string">'gulp-htmlclean'</span>);</span><br><span class="line"><span class="keyword">var</span> imagemin = <span class="built_in">require</span>(<span class="string">'gulp-imagemin'</span>);</span><br><span class="line"><span class="comment">// 压缩 public 目录 css</span></span><br><span class="line">gulp.task(<span class="string">'minify-css'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.css'</span>)</span><br><span class="line">        .pipe(minifycss())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 压缩 public 目录 html</span></span><br><span class="line">gulp.task(<span class="string">'minify-html'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.html'</span>)</span><br><span class="line">        .pipe(htmlclean())</span><br><span class="line">        .pipe(htmlmin(&#123;</span><br><span class="line">            removeComments: <span class="literal">true</span>,</span><br><span class="line">            minifyJS: <span class="literal">true</span>,</span><br><span class="line">            minifyCSS: <span class="literal">true</span>,</span><br><span class="line">            minifyURLs: <span class="literal">true</span>,</span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./public'</span>))</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 压缩 public/js 目录 js</span></span><br><span class="line">gulp.task(<span class="string">'minify-js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.js'</span>)</span><br><span class="line">        .pipe(uglify())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 压缩 public/images 目录 images</span></span><br><span class="line">gulp.task(<span class="string">'images'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src([<span class="string">'./public/**/*.png'</span>, <span class="string">'./public/**/*.jpg'</span>, <span class="string">'./public/**/*.gif'</span>, <span class="string">'./public/**/*.svg'</span>])</span><br><span class="line">        .pipe(imagemin(&#123;</span><br><span class="line">            progressive: <span class="literal">false</span></span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 执行 gulp 命令时执行的任务</span></span><br><span class="line">gulp.task(<span class="string">'default'</span>, [</span><br><span class="line">    <span class="string">'minify-html'</span>, <span class="string">'minify-css'</span>, <span class="string">'minify-js'</span>, <span class="string">'images'</span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>同时在package.json里添加这几个包。</p><pre><code>&quot;gulp-minify-css&quot;: &quot;^1.2.4&quot;,&quot;gulp-uglify&quot;: &quot;^3.0.0&quot;,&quot;gulp-htmlmin&quot;: &quot;^4.0.0&quot;,&quot;gulp-htmlclean&quot;: &quot;^2.7.22&quot;,&quot;gulp&quot;: &quot;^3.9.1&quot;,&quot;gulp-imagemin&quot;: &quot;^4.1.0&quot;,</code></pre><p>添加完后执行 npm install。</p><p>或者直接一个个的 npm install 包名 –save 也是可以的。</p><p>弄好后，在hexo g 指令后进行 压缩操作，执行 gulp 命令，可对public文件夹下的资源进行压缩。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>一个博客的基本搭建到这里基本就结束了，如果想提高性能及速度，可以自己申请个服务器，或者使用CDN进行加速，基本都涉及到一定的费用。</p><p>博客还有一些比较小的美化的地方就不一一说明，大家可以自己尝试，自己动手，把自己的博客搭建的更漂亮。</p><p>毕竟，搭建博客这件事我们应本着学习，兴趣，快乐的本质去出发，自己摸索自己研究一些比较好玩的东西，这样才是做这件事的意义。</p><p>附上我的博客地址：</p><p><a href="https://www.sakuratears.top/">https://www.sakuratears.top/</a></p><p>大家可以参考下，有什么问题可以随时联系我，一定会为大家解答。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;关于之前的部分请参考我的《搭建自己的Hexo博客（1）》这篇文章。&lt;/p&gt;
&lt;h1 id=&quot;创建Github账户&quot;&gt;&lt;a href=&quot;#创建
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="blog" scheme="https://www.sakuratears.top/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>搭建自己的Hexo博客（1）</title>
    <link href="https://www.sakuratears.top/blog/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Hexo%E5%8D%9A%E5%AE%A220180715/"/>
    <id>https://www.sakuratears.top/blog/搭建自己的Hexo博客20180715/</id>
    <published>2018-07-15T06:29:00.000Z</published>
    <updated>2018-07-16T10:50:55.693Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我的Hexo博客很早就建好了，但一直没时间把搭建博客的步骤和经验好好总结。今天，我把在搭建博客中注意到的点及经验总结下来。一方面与大家分享，另一方面也加深自己的记忆，总结经验。</p><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><h2 id="安装Node-js及npm"><a href="#安装Node-js及npm" class="headerlink" title="安装Node.js及npm"></a>安装Node.js及npm</h2><p>要搭建Hexo博客，首先需要安装Node.js环境，去Node.js官网下载Node并安装。</p><p>NodeJs官网：<a href="https://nodejs.org/" target="_blank" rel="noopener">https://nodejs.org/</a></p><p>在命令行界面输入node -v 查询版本号。</p><p>输入npm -v 可查询npm版本号。</p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>使用npm指令安装hexo</p><p>npm install hexo-cli -g</p><p>安装成功后输入hexo -v可查询hexo版本信息</p><h2 id="博客初始化"><a href="#博客初始化" class="headerlink" title="博客初始化"></a>博客初始化</h2><p>安装好hexo后，我们找到一个自己文件夹，通过指令进入该文件夹。</p><p>使用指令：</p><p>①hexo init blog</p><p>②cd blog</p><p>③npm install</p><p>④hexo s</p><p>会看到命令行输出如下信息</p><p><img src="/images/pasted-21.png" alt="upload successful"></p><p>打开浏览器，输入地址便可以看到blog搭建成功了。</p><h2 id="美化博客"><a href="#美化博客" class="headerlink" title="美化博客"></a>美化博客</h2><p>虽然blog搭建好了，但是总感觉不是很好看。</p><p>推荐一款hexo主题Next，其有很多种blog主题供我们选择。</p><h3 id="安装Next主题"><a href="#安装Next主题" class="headerlink" title="安装Next主题"></a>安装Next主题</h3><p>首先cd到刚刚建好的blog目录下，执行命令：</p><p>git clone <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a> themes/next</p><p>如果没有安装git，那么安装下吧。</p><p>请去git官网下载git：    <a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a></p><p>如果命令执行成功，在blog下的themes包下，我们可以看到next文件夹，那就是刚刚下好的next主题啦。themes包下那个landscape包，就是hexo自带的默认主题。</p><p>如果不成功，那么我们可以直接下载next主题，<a href="https://github.com/iissnan/hexo-theme-next/releases，下载source" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next/releases，下载source</a> code，然后把文件解压，重命名为next放到themes包下就可以了啦。</p><p>完成后，在blog包下，有个_config.yml文件，打开它，里面配置为theme: next即可加载next主题。</p><h3 id="Hexo的-config-yml文件"><a href="#Hexo的-config-yml文件" class="headerlink" title="Hexo的_config.yml文件"></a>Hexo的_config.yml文件</h3><p>上文提到的这个配置文件是Hexo的核心配置文件，我们来说下这个文件吧</p><p>请先对yml语法有一定了解，本文不做说明。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Hexo Configuration</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/configuration.html</span></span><br><span class="line"><span class="comment">## Source: https://github.com/hexojs/hexo/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">SakuraTears的博客</span>             <span class="string">//博客的标题</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">越努力越幸运</span><span class="string">//博客简介</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">越努力越幸运</span><span class="string">//博客描述</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">'Java,努力,随笔,学习,SakuraTears,博客,生活'</span>  <span class="string">//博客关键字</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">SakuraTears</span><span class="string">//博客作者</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-Hans</span><span class="string">//博客语言</span></span><br><span class="line"><span class="attr">timezone:</span><span class="string">//时区</span></span><br><span class="line"><span class="attr">avatar:</span> <span class="string">/uploads/avatar.jpg</span><span class="string">//头像</span></span><br><span class="line"><span class="comment">#google_analytics: your-analytics-id//谷歌统计，开启的话请输入自己的id</span></span><br><span class="line"><span class="comment">#baidu_analytics: your-analytics-id//百度统计，开启的话请输入自己的id</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></span><br><span class="line"><span class="attr">url:</span> <span class="attr">https://www.sakuratears.top</span>       <span class="string">//自己的网站地址</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span><span class="string">//根目录</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">blog/:title:year:month:day/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Directory</span></span><br><span class="line"><span class="attr">source_dir:</span> <span class="string">source</span><span class="string">//源码位置，请默认</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public</span><span class="string">//生成的文件位置，请默认</span></span><br><span class="line"><span class="attr">tag_dir:</span> <span class="string">tags</span><span class="string">//标签文件位置，请默认</span></span><br><span class="line"><span class="attr">archive_dir:</span> <span class="string">archives</span><span class="string">//归档文件位置，请默认</span></span><br><span class="line"><span class="attr">category_dir:</span> <span class="string">categories</span><span class="string">//分类文件位置，请默认</span></span><br><span class="line"><span class="attr">code_dir:</span> <span class="string">downloads/code</span></span><br><span class="line"><span class="attr">i18n_dir:</span> <span class="string">:lang</span></span><br><span class="line"><span class="attr">skip_render:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Writing</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:title.md</span> <span class="comment"># File name of new posts  //新文章默认名字</span></span><br><span class="line"><span class="attr">default_layout:</span> <span class="string">post</span><span class="string">//默认样式</span></span><br><span class="line"><span class="attr">titlecase:</span> <span class="literal">false</span> <span class="comment"># Transform title into titlecase</span></span><br><span class="line"><span class="attr">external_link:</span> <span class="literal">true</span> <span class="comment"># Open external links in new tab</span></span><br><span class="line"><span class="attr">filename_case:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">render_drafts:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">relative_link:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">future:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">highlight:</span><span class="string">//高亮</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span><span class="string">//启用</span></span><br><span class="line"><span class="attr">  line_number:</span> <span class="literal">true</span><span class="string">//linenumber启用</span></span><br><span class="line"><span class="attr">  auto_detect:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  tab_replace:</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># Home page setting</span></span><br><span class="line"><span class="comment"># path: Root path for your blogs index page. (default = '')</span></span><br><span class="line"><span class="comment"># per_page: Posts displayed per page. (0 = disable pagination)</span></span><br><span class="line"><span class="comment"># order_by: Posts order. (Order by date descending by default)</span></span><br><span class="line"><span class="attr">index_generator:</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">''</span></span><br><span class="line"><span class="attr">  per_page:</span> <span class="number">3</span>           <span class="string">//每页三篇文章</span></span><br><span class="line"><span class="attr">  order_by:</span> <span class="bullet">-date</span><span class="string">//按日期排序</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># Category &amp; Tag</span></span><br><span class="line"><span class="attr">default_category:</span> <span class="string">uncategorized</span><span class="string">//按默认策略分类</span></span><br><span class="line"><span class="attr">category_map:</span></span><br><span class="line"><span class="attr">tag_map:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Date / Time format</span></span><br><span class="line"><span class="comment">## Hexo uses Moment.js to parse and display date</span></span><br><span class="line"><span class="comment">## You can customize the date format as defined in</span></span><br><span class="line"><span class="comment">## http://momentjs.com/docs/#/displaying/format/</span></span><br><span class="line"><span class="attr">date_format:</span> <span class="string">YYYY-MM-DD</span><span class="string">//日期时间格式</span></span><br><span class="line"><span class="attr">time_format:</span> <span class="attr">HH:mm:ss</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pagination</span></span><br><span class="line"><span class="comment">## Set per_page to 0 to disable pagination</span></span><br><span class="line"><span class="attr">per_page:</span> <span class="number">10</span><span class="string">//归档每页10篇文章</span></span><br><span class="line"><span class="attr">pagination_dir:</span> <span class="string">page</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="attr">plugins:</span> <span class="string">hexo-generate-feed</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span><span class="string">//hexo主题</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># hexo-admin authentification</span></span><br><span class="line"><span class="attr">admin:</span></span><br><span class="line"><span class="attr">  username:</span> <span class="string">sakuratears</span></span><br><span class="line"><span class="attr">  password_hash:</span> <span class="string">$2a$10$HhGu7w5fYH6e7wmb2tXta.FvJvGWlzosdUgImJxGhxU0K3YAkXIkm</span></span><br><span class="line"><span class="attr">  secret:</span> <span class="string">what's</span> <span class="string">your</span> <span class="string">name?</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Live2D//live2D插件，后面介绍</span></span><br><span class="line"><span class="comment">## https://github.com/xiazeyu/live2d-widget.js</span></span><br><span class="line"><span class="comment">## https://l2dwidget.js.org/docs/class/src/index.js~L2Dwidget.html#instance-method-init</span></span><br><span class="line"><span class="attr">live2d:</span></span><br><span class="line"><span class="attr">  model:</span></span><br><span class="line"><span class="attr">    scale:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">    hHeadPos:</span> <span class="number">0.5</span></span><br><span class="line"><span class="attr">    vHeadPos:</span> <span class="number">0.618</span></span><br><span class="line"><span class="attr">  display:</span></span><br><span class="line"><span class="attr">    superSample:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">    width:</span> <span class="number">150</span></span><br><span class="line"><span class="attr">    height:</span> <span class="number">300</span></span><br><span class="line"><span class="attr">    position:</span> <span class="string">right</span></span><br><span class="line"><span class="attr">    hOffset:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">    vOffset:</span> <span class="bullet">-20</span></span><br><span class="line"><span class="attr">  mobile:</span></span><br><span class="line"><span class="attr">    show:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    scale:</span> <span class="number">0.1</span></span><br><span class="line"><span class="attr">    motion:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  react:</span></span><br><span class="line"><span class="attr">    opacityDefault:</span> <span class="number">0.7</span></span><br><span class="line"><span class="attr">    opacityOnHover:</span> <span class="number">0.2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##local_search//搜索插件</span></span><br><span class="line"><span class="attr">search:</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">search.xml</span></span><br><span class="line"><span class="attr">  field:</span> <span class="string">post</span></span><br><span class="line"><span class="attr">  format:</span> <span class="string">html</span></span><br><span class="line"><span class="attr">  limit:</span> <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Deployment//部署</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span> </span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="string">git@github.com:JavaZWT/JavaZWT.github.io.git</span></span><br></pre></td></tr></table></figure><h3 id="Next主题的-config-yml文件"><a href="#Next主题的-config-yml文件" class="headerlink" title="Next主题的_config.yml文件"></a>Next主题的_config.yml文件</h3><p>在next包下，也有一个_config.yml文件，这个文件是配置next主题的，也简单介绍下。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span>     <span class="string">//next主题菜单</span></span><br><span class="line"><span class="attr">  home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line"><span class="attr">  about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">user</span></span><br><span class="line"><span class="attr">  tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">  categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line"><span class="attr">  archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line"><span class="attr">  commonweal:</span> <span class="string">/404/</span> <span class="string">||</span> <span class="string">heartbeat</span></span><br><span class="line"><span class="attr">  support:</span> <span class="string">/support/</span> <span class="string">||</span> <span class="string">support</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">scheme:</span> <span class="string">Pisces</span>  <span class="string">//主题类型</span></span><br></pre></td></tr></table></figure><p>我选的Pisces主题。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">social:</span>   <span class="string">//社交信息</span></span><br><span class="line"><span class="attr">  GitHub:</span> <span class="attr">https://github.com/JavaZWT</span> <span class="string">||</span> <span class="string">github</span></span><br><span class="line"><span class="attr">  Email:</span> <span class="attr">mailto:971258230@qq.com</span> <span class="string">||</span> <span class="string">envelope</span></span><br><span class="line"><span class="attr">  QQ:</span> <span class="attr">http://wpa.qq.com/msgrd?v=3&amp;uin=971258230&amp;site=qq&amp;menu=yes</span> <span class="string">||</span> <span class="string">qq</span></span><br><span class="line"><span class="attr">  CSDN:</span> <span class="attr">https://blog.csdn.net/JavaZWT</span> <span class="string">||</span> <span class="string">copyright</span></span><br></pre></td></tr></table></figure><p>上面都是一些基本配置，下面我们对blog进行更多的美化。</p><h3 id="添加动态旋转头像"><a href="#添加动态旋转头像" class="headerlink" title="添加动态旋转头像"></a>添加动态旋转头像</h3><p>打开/themes/next/source/css/_common/components/sidebar/sidebar-author.styl文件</p><p>将代码替换为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.site-author-image</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">padding</span>: $site-author-image-padding;</span><br><span class="line">  <span class="attribute">max-width</span>: $site-author-image-width;</span><br><span class="line">  <span class="attribute">height</span>: $site-author-image-height;</span><br><span class="line">  <span class="attribute">border</span>: $site-author-image-border-width solid $site-author-image-border-color;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">60%</span>;</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">2.5s</span> all;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.site-author-image</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(360deg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.site-author-name</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: $site-author-name-margin;</span><br><span class="line">  <span class="attribute">text-align</span>: $site-author-name-align;</span><br><span class="line">  <span class="attribute">color</span>: $site-author-name-color;</span><br><span class="line">  <span class="attribute">font-weight</span>: $site-author-name-weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.site-description</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: $site-description-margin-top;</span><br><span class="line">  <span class="attribute">text-align</span>: $site-description-align;</span><br><span class="line">  <span class="attribute">font-size</span>: $site-description-font-size;</span><br><span class="line">  <span class="attribute">color</span>: $site-description-color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后重新发布，可以看到头像可以旋转啦。</p><h3 id="添加本地搜索插件"><a href="#添加本地搜索插件" class="headerlink" title="添加本地搜索插件"></a>添加本地搜索插件</h3><p>安装hexo-generator-searchdb：</p><p>npm install hexo-generator-searchdb –save</p><p>同时在hexo的_config.yml里配置如下参数：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##local_search</span></span><br><span class="line"><span class="attr">search:</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">search.xml</span></span><br><span class="line"><span class="attr">  field:</span> <span class="string">post</span></span><br><span class="line"><span class="attr">  format:</span> <span class="string">html</span></span><br><span class="line"><span class="attr">  limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure><p>Next的_config.yml配置如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># if auto, trigger search by changing input</span></span><br><span class="line">  <span class="comment"># if manual, trigger search by pressing enter key or search button</span></span><br><span class="line"><span class="attr">  trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># show top n results per article, show all results by setting to -1</span></span><br><span class="line"><span class="attr">  top_n_per_article:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>重新发布，可以看到新增了搜索功能。</p><h3 id="更换背景图片"><a href="#更换背景图片" class="headerlink" title="更换背景图片"></a>更换背景图片</h3><p>找到 /themes/next/source/css/_custom/custom.styl文件</p><p>加入如下代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>:<span class="built_in">url</span>(<span class="string">"/images/background.jpg"</span>);</span><br><span class="line">    background-attachment: fixed; // 不随屏幕滚动而滚动</span><br><span class="line">    background-repeat: no-repeat; // 如果背景图不够屏幕大小则重复铺，改为no-repeat则表示不重复铺</span><br><span class="line">    background-size: 100%; // 等比例铺满屏幕</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main-inner</span> &#123; </span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0.8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新发布，可以看到背景图片变化了。</p><h3 id="添加live2D功能"><a href="#添加live2D功能" class="headerlink" title="添加live2D功能"></a>添加live2D功能</h3><p>安装live2D插件hexo-helper-live2d</p><p>npm install hexo-helper-live2d –save</p><p>Hexo的 _config.yml文件里配置如下参数</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">live2d:</span></span><br><span class="line"><span class="attr">  model:</span></span><br><span class="line"><span class="attr">    scale:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">    hHeadPos:</span> <span class="number">0.5</span></span><br><span class="line"><span class="attr">    vHeadPos:</span> <span class="number">0.618</span></span><br><span class="line"><span class="attr">  display:</span></span><br><span class="line"><span class="attr">    superSample:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">    width:</span> <span class="number">150</span></span><br><span class="line"><span class="attr">    height:</span> <span class="number">300</span></span><br><span class="line"><span class="attr">    position:</span> <span class="string">right</span></span><br><span class="line"><span class="attr">    hOffset:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">    vOffset:</span> <span class="bullet">-20</span></span><br><span class="line"><span class="attr">  mobile:</span></span><br><span class="line"><span class="attr">    show:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    scale:</span> <span class="number">0.1</span></span><br><span class="line"><span class="attr">    motion:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  react:</span></span><br><span class="line"><span class="attr">    opacityDefault:</span> <span class="number">0.7</span></span><br><span class="line"><span class="attr">    opacityOnHover:</span> <span class="number">0.2</span></span><br></pre></td></tr></table></figure><p>重新发布，便看到萌萌的二次元人物出现啦。</p><h3 id="添加评论插件"><a href="#添加评论插件" class="headerlink" title="添加评论插件"></a>添加评论插件</h3><p>这里用的Valine评论插件，Valine插件需要leancloud支持，请先注册leancloud，注册成功拿到id和key。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">valine:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  appid:</span> <span class="string">//你的id</span></span><br><span class="line"><span class="attr">  appkey:</span> <span class="string">//你的key</span></span><br><span class="line"><span class="attr">  notify:</span> <span class="literal">false</span> <span class="comment"># mail notifier , https://github.com/xCss/Valine/wiki</span></span><br><span class="line"><span class="attr">  verify:</span> <span class="literal">false</span> <span class="comment"># Verification code</span></span><br><span class="line"><span class="attr">  placeholder:</span> <span class="string">(*^_^*)看了这么多，可能你有话想说</span> <span class="comment"># comment box placeholder</span></span><br><span class="line"><span class="attr">  avatar:</span> <span class="string">mm</span> <span class="comment"># gravatar style</span></span><br><span class="line"><span class="attr">  guest_info:</span> <span class="string">nick,mail,link</span> <span class="comment"># custom comment header</span></span><br><span class="line"><span class="attr">  pageSize:</span> <span class="number">10</span> <span class="comment"># pagination size</span></span><br></pre></td></tr></table></figure><p>配置成功后，重新发布便能看到文章可以评论啦。</p><h3 id="开启访客统计"><a href="#开启访客统计" class="headerlink" title="开启访客统计"></a>开启访客统计</h3><p>当我们注册好leancloud后。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">leancloud_visitors:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  app_id:</span> <span class="string">//你的id</span></span><br><span class="line"><span class="attr">  app_key:</span> <span class="string">//你的key</span></span><br></pre></td></tr></table></figure><p>找到代码，填入自己的id和key。</p><p>重新发布，在页面上可以看到博客的访客数量。</p><h3 id="开启字数统计"><a href="#开启字数统计" class="headerlink" title="开启字数统计"></a>开启字数统计</h3><p>安装字数统计插件：hexo-wordcount</p><p>npm install hexo-wordcount –save</p><p>Next配置文件如下参数开启：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_wordcount:</span></span><br><span class="line"><span class="attr">  item_text:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  wordcount:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  min2read:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  totalcount:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  separated_meta:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>重新发布便拥有了字数统计功能。</p><h1 id="续"><a href="#续" class="headerlink" title="续"></a>续</h1><p>文章还没写完，后面会继续更新。</p><p>欢迎大家关注我的博客</p><p><a href="https://www.sakuratears.top/">https://www.sakuratears.top/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我的Hexo博客很早就建好了，但一直没时间把搭建博客的步骤和经验好好总结。今天，我把在搭建博客中注意到的点及经验总结下来。一方面与大家分享，
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="blog" scheme="https://www.sakuratears.top/tags/blog/"/>
    
  </entry>
  
</feed>
