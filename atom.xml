<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SakuraTears的博客</title>
  
  <subtitle>越努力越幸运</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.sakuratears.top/"/>
  <updated>2018-12-20T13:33:58.193Z</updated>
  <id>https://www.sakuratears.top/</id>
  
  <author>
    <name>SakuraTears</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySql 使用Explain分析SQL语句及索引</title>
    <link href="https://www.sakuratears.top/blog/MySql-%E4%BD%BF%E7%94%A8Explain%E5%88%86%E6%9E%90SQL%E8%AF%AD%E5%8F%A5%E5%8F%8A%E7%B4%A2%E5%BC%9520181219/"/>
    <id>https://www.sakuratears.top/blog/MySql-使用Explain分析SQL语句及索引20181219/</id>
    <published>2018-12-19T14:43:00.000Z</published>
    <updated>2018-12-20T13:33:58.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们经常会用到数据库，并可能写一些查询语句，大多数情况下，可能都是一些比较简单的增删改查语句。但某些时候，也可能遇到一些较复杂的语句。</p><p>在系统数据量不太大的情况下，可能我们SQL语句的好坏对系统性能并不会造成太大影响，但是随着系统数据量增大，数据库压力增大，除一些其它策略（使用缓存数据库、分库分表等等），良好的SQL语句也是提高数据库性能的一个重要指标。</p><p>SQL语句我们基本是按照，能精确查询就精确查询，能简化就简化，能使用索引就使用索引（必要条件下）的原则去编写。</p><p>我们今天通过Explain这个关键字来分析及优化我们的SQL语句。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>那就先说下Explain吧。</p><p>打开数据库，随便找一张数据表。如下：</p><p><img src="/images/pasted-236.png" alt="upload successful"></p><p>可以看到，当我们在我们写的SQL语句前加上Explain后，会得到如下的结果表。</p><p>PS：如果SQL语句关联其它表，会有多行结果，后续。</p><p>我们先来简单说下结果各个字段的含义。</p><ol><li><p><strong>id</strong></p><p> 暂且叫主键或者顺序吧，如果不止一次查询搜索（比如关联其它表），会按照顺序列出来。序号越大越先被执行。</p></li><li><p><strong>select_type</strong></p><p> 查询类型，有下面几种：</p><pre><code>SIMPLE：简单SELECT(不使用UNION或子查询等)PRIMARY：最外面的SELECTUNION：UNION中的第二个或后面的SELECT语句DEPENDENT UNION：UNION中的第二个或后面的SELECT语句，取决于外面的查询UNION RESULT：UNION的结果。SUBQUERY：子查询中的第一个SELECTDEPENDENT SUBQUERY：子查询中的第一个SELECT，取决于外面的查询DERIVED：导出表的SELECT(FROM子句的子查询)</code></pre></li><li><p><strong>table</strong></p><p> 这行数据和哪张表有关联。</p></li><li><p><strong>partitions</strong></p><p> 匹配的哪个分区。</p></li><li><p><strong>type</strong></p><p> 这列最重要，显示了连接使用了哪种类别，有无使用索引，是使用Explain命令分析性能瓶颈的关键项之一。</p><p> 结果值从好到坏依次是：</p><pre><code>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt;     index_subquery &gt; range &gt; index &gt; ALL</code></pre><p> 一般来说，得保证查询至少达到range级别，最好能达到ref，否则就可能会出现性能问题。</p></li><li><p><strong>possible_keys</strong></p><p> MySQL可能使用哪个索引在该表中找到行。</p></li><li><p><strong>key</strong></p><p> MySQL实际决定使用的键（索引）。如果没有选择索引，值是NULL。</p></li><li><p><strong>key_len</strong></p><p> MySQL决定使用的索引长度。如果key是NULL，则key_len为NULL。在不损失精确性的情况下，长度越短越好。</p></li><li><p><strong>ref</strong></p><p> 使用哪个列或常数与key一起从表中选择行。</p></li><li><p><strong>rows</strong></p><p>MySQL认为它执行查询时必须检查的行数。正常情况下这个值越小越好。</p></li><li><p><strong>Extra</strong></p><p>MySQL解决查询的详细信息，也是关键参考项之一。</p><pre><code>Distinct：一旦MYSQL找到了与行相联合匹配的行，就不再搜索了。Not exists：MYSQL 优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行，就不再搜索了。Range checked for each Record：没有找到理想的索引，因此对于从前面表中来的每一个行组合，MYSQL检查使用哪个索引，并用它来从表中返回行。Using filesort：MYSQL需要进行额外的步骤来发现如何对返回的行排序。它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来排序全部行。出现这种情况应当优化SQL语句。Using index：列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候。Using temporary：说明MySQL需要新建一个临时表来存储结果，当生成的临时表较大时，应当优化SQL语句。Using where：使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。如果不想返回表中的全部行，并且连接类型ALL或index，就会出现这种情况。Using union：使用了合并，有可能合并索引、表等。一般使用or连接条件时可能会出现。</code></pre></li></ol><p>我们创建一张学生表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`student`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'自增主键'</span>,</span><br><span class="line">  <span class="string">`stu_no`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'学生编号'</span>,</span><br><span class="line">  <span class="string">`stu_name`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'学生姓名'</span>,</span><br><span class="line">  <span class="string">`stu_sex`</span> <span class="built_in">char</span>(<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`stu_birthday`</span> <span class="built_in">date</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'学生生日'</span>,</span><br><span class="line">  <span class="string">`stu_class`</span> <span class="built_in">char</span>(<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'学生所在班级'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">50077</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-237.png" alt="upload successful"></p><p>向表中加入100w数据。（过程略）</p><p><img src="/images/pasted-238.png" alt="upload successful"></p><h2 id="关于索引"><a href="#关于索引" class="headerlink" title="关于索引"></a>关于索引</h2><p><strong>我们统计5班学生的学生数量。</strong></p><p><img src="/images/pasted-239.png" alt="upload successful"></p><p>可以看到耗时2s之久。</p><p>使用Explain分析可以看到mysql需要检查994511行才能得到结果，已经相当于全表扫描了。Type是ALL，为最差的一种。</p><p><img src="/images/pasted-240.png" alt="upload successful"></p><p>我们在stu_class班级这一列上加上索引。</p><p><img src="/images/pasted-241.png" alt="upload successful"></p><p>继续查询及分析，可以看到耗时0.07s。</p><p><img src="/images/pasted-242.png" alt="upload successful"></p><p>Explain分析可知type为ref满足我们要求，mysql执行这个查询认为只要扫描191502条数据即可，使用了index_1索引。</p><p><img src="/images/pasted-243.png" alt="upload successful"></p><p>是不是感觉到索引很厉害？</p><p>我们再来看一下。</p><p><strong>这回我们查询5年级所有学生的学生名</strong>。如下：</p><p>先不使用索引，可以看到，耗时2s左右。</p><p><img src="/images/pasted-244.png" alt="upload successful"></p><p><img src="/images/pasted-245.png" alt="upload successful"></p><p>我们给年级加上索引，继续测试。如下：</p><p><img src="/images/pasted-246.png" alt="upload successful"></p><p><img src="/images/pasted-247.png" alt="upload successful"></p><p>可以看到耗时竟达到5s左右。</p><p>为什么会这样呢？</p><p>一般我们认为，这种属于很特殊的情况，一般在硬盘上，数据是连续存储的，但是引入索引后，数据连续性变差，随机波动性要大，在数据量大的情况下更是。</p><p>这种情况下，我们读取大量数据（99497条已接近1/10数据总量），由于随机性变大，故读取时间会变大。因此索引在查询一些小数据量数据的情况下效果明显，或者索引带来的优化已经完全超过了数据读取时间。</p><p>关于上面，我们可以看下有索引和无索引SQL执行情况。</p><p>有索引情况下:</p><p><img src="/images/pasted-248.png" alt="upload successful"></p><p>无索引情况下:</p><p><img src="/images/pasted-249.png" alt="upload successful"></p><p>可以看到它们明显的差距就在返回数据这儿了，有索引情况下读取数据浪费了太多时间。</p><p>关于索引带来的优化已经完全超过了数据读取时间这个，我们可以看下这个例子。</p><p>我们在添加一条姓名索引。</p><p><img src="/images/pasted-250.png" alt="upload successful"></p><p><strong>我们查询5班所有姓张的童鞋。</strong></p><p>有索引情况下:</p><p><img src="/images/pasted-251.png" alt="upload successful"></p><p><img src="/images/pasted-252.png" alt="upload successful"></p><p>无索引情况下:</p><p><img src="/images/pasted-253.png" alt="upload successful"></p><p>明显的有索引的完爆无索引查询时间啦，这里就不在具体分析了。</p><p>我们可以看下这儿的like，可以直接看下面的图。</p><p><img src="/images/pasted-254.png" alt="upload successful"></p><p><img src="/images/pasted-255.png" alt="upload successful"></p><p><img src="/images/pasted-256.png" alt="upload successful"></p><p><img src="/images/pasted-257.png" alt="upload successful"></p><p>明显得到的结论就是<strong>当有like查询时，%或者_在前面的是无法使用当前字段索引的（如果有），会进行全表扫描</strong>，这一点需要注意。</p><h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><p>我们接下来分析一些SQL的优化。</p><p>1.<strong>我想查询生日在1998年至2010年之间的所有学生数量。（生日已建立索引index_3）</strong></p><p>可以这样，如下图。</p><p><img src="/images/pasted-258.png" alt="upload successful"></p><p><img src="/images/pasted-259.png" alt="upload successful"></p><p>Explain分析仅为index级别，虽然用到了索引index_3。</p><p>如何优化下呢？</p><p>我们可以这样处理：</p><p><img src="/images/pasted-260.png" alt="upload successful"></p><p><img src="/images/pasted-261.png" alt="upload successful"></p><p>通过Explain分析type也达到了range级别。</p><p><strong>PS： 通过上面例子，我们知道我们应该尽量减少对字段的计算操作，以便使其可以正常利用索引，也就是尽量使条件数据与字段数据去匹配，而不是对字段数据进行操作后去匹配条件数据。</strong></p><p>2.<strong>我想查询生日在98年后且是5班的且姓张的童鞋。</strong></p><p>有生日索引index_3，姓名索引index_2，班级索引index_1。</p><p><img src="/images/pasted-262.png" alt="upload successful"></p><p><img src="/images/pasted-263.png" alt="upload successful"></p><p>运行上述SQL后我们看到type级别为range，还可以，但是却只用到了index_2索引，时间还可以0.006s。</p><p>还有好一点的方法吗？</p><p>我们试着删除上面三个索引，创建一个联合索引。如下：</p><p><img src="/images/pasted-264.png" alt="upload successful"></p><p>进行测试。</p><p><img src="/images/pasted-265.png" alt="upload successful"></p><p><img src="/images/pasted-266.png" alt="upload successful"></p><p>可以看到时间有提高（反复测试是比单索引要好的），type级别还是range。</p><p>PS：联合索引只有在一些特定的情况下能发挥很好的作用，一般单索引可以满足大多需求，所以联合索引的创建是需要慎重的。</p><p>联合索引有一些特点需要注意，以免被坑。<br>对于上面的联合索引，index_1(stu_name, stu_birthday, stu_class)，遵循最左原则。</p><p>最左原则可以看下面7个例子。</p><p><strong>例子1:</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> * <span class="keyword">from</span> student s <span class="keyword">where</span> s.stu_birthday &gt;= <span class="string">'1998-01-01'</span>;</span><br></pre></td></tr></table></figure></p><p>Explain分析结果如下：</p><p><img src="/images/pasted-267.png" alt="upload successful"></p><p><strong>例子2:</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> * <span class="keyword">from</span> student s <span class="keyword">where</span> s.stu_name <span class="keyword">like</span> <span class="string">'张%'</span>;</span><br></pre></td></tr></table></figure></p><p>Explain分析结果如下：</p><p><img src="/images/pasted-268.png" alt="upload successful"></p><p><strong>例子3:</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> * <span class="keyword">from</span> student s <span class="keyword">where</span> s.stu_class = <span class="string">'5'</span>;</span><br></pre></td></tr></table></figure></p><p>Explain分析结果如下：</p><p><img src="/images/pasted-269.png" alt="upload successful"></p><p><strong>例子4:</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> * <span class="keyword">from</span> student s <span class="keyword">where</span> s.stu_class = <span class="string">'5'</span> <span class="keyword">and</span> s.stu_birthday &gt;= <span class="string">'1998-01-01'</span>;</span><br></pre></td></tr></table></figure></p><p>Explain分析结果如下：</p><p><img src="/images/pasted-270.png" alt="upload successful"></p><p><strong>例子5:</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> * <span class="keyword">from</span> student s <span class="keyword">where</span> s.stu_class = <span class="string">'5'</span> <span class="keyword">and</span> s.stu_name <span class="keyword">like</span> <span class="string">'张%'</span>;</span><br></pre></td></tr></table></figure></p><p>Explain分析结果如下：</p><p><img src="/images/pasted-271.png" alt="upload successful"></p><p><strong>例子6:</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> * <span class="keyword">from</span> student s <span class="keyword">where</span> s.stu_birthday &gt;= <span class="string">'1998-01-01'</span> <span class="keyword">and</span> s.stu_name <span class="keyword">like</span> <span class="string">'张%'</span>;</span><br></pre></td></tr></table></figure></p><p>Explain分析结果如下：</p><p><img src="/images/pasted-272.png" alt="upload successful"></p><p><strong>例子7:</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> * <span class="keyword">from</span> student s <span class="keyword">where</span> s.stu_birthday &gt;= <span class="string">'1998-01-01'</span>  <span class="keyword">and</span> s.stu_name <span class="keyword">like</span> <span class="string">'张%'</span> <span class="keyword">and</span> s.stu_class = <span class="string">'5'</span>;</span><br></pre></td></tr></table></figure></p><p>Explain分析结果如下：</p><p><img src="/images/pasted-273.png" alt="upload successful"></p><p>可以看到，可以使用索引的查询有 （stu_name）（stu_name, stu_birthday）（stu_name, stu_birthday, stu_class）（stu_name, stu_class），也就是必须有stu_name这个条件。这就是联合索引的最左原则。</p><p>3.<strong>我们统计姓名相同的学生的学生名及数量。</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> s.stu_name,<span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">from</span> student s <span class="keyword">GROUP</span> <span class="keyword">BY</span> s.stu_name <span class="keyword">HAVING</span> <span class="keyword">count</span>(<span class="number">1</span>)&gt;<span class="number">1</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> s.stu_name;</span><br></pre></td></tr></table></figure></p><p>这儿就不在贴图了，当stu_name有索引时，查询效率会有明显提升。</p><p>在有索引Explain分析后，我们可以看到，Mysql认为这个查询需要检索全部数据（rows 99万）。</p><p><img src="/images/pasted-274.png" alt="upload successful"></p><p>这是Mysql认为要检索的行数，实际由于stu_name有索引，是没有检索这么多的。</p><p>因为查询语句中出现了group by，对于某张表，正常情况的的认知肯定是检索完全表后才能进行分组归类。所以，在一些经常被group by 或者 order by 的字段上，数据量较大的情况下，且该字段比较多样性（比如性别这种字段顶多有男、女、未知三种，加不加索引都可以），向表中常用的创建时间、修改时间等字段，还是有必要添加索引的。</p><p>4.<strong>查询所有学生生日，性别，班级相同的学生数量。</strong></p><p>我们假设建立了index_1(stu_birthday)索引，index_2(stu_sex)索引，index_3(stu_class)索引。</p><p>你可能会想到如下SQL。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">from</span> student a,(<span class="keyword">select</span> stu_birthday,stu_class,stu_sex <span class="keyword">from</span> student) b <span class="keyword">where</span> a.stu_birthday = b.stu_birthday <span class="keyword">and</span> a.stu_class=b.stu_class <span class="keyword">and</span> a.stu_sex=b.stu_sex;</span><br></pre></td></tr></table></figure></p><p>嗯，这个SQL是不正确的，而且耗时无法忍受。</p><p>其实不用Explain，单独看它就可以知道它会扫描全表，无论有无索引。而且我们统计学生数量，如果有2个以上情况相同呢？显然上面SQL的3个等于条件会出现问题。</p><p>其实我们可以根据分组数量来处理这个问题，如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">from</span> student s ,(<span class="keyword">select</span> a.stu_birthday,a.stu_sex,a.stu_class <span class="keyword">from</span> student a <span class="keyword">GROUP</span> <span class="keyword">BY</span> a.stu_birthday,a.stu_sex,a.stu_class <span class="keyword">HAVING</span> <span class="keyword">count</span>(<span class="number">1</span>)&gt;<span class="number">1</span>) b <span class="keyword">where</span> s.stu_birthday=b.stu_birthday <span class="keyword">and</span> s.stu_sex=b.stu_sex <span class="keyword">and</span> s.stu_class=b.stu_class;</span><br></pre></td></tr></table></figure></p><p>通过学生生日，性别，班级相同，他们的数量要大于1，从而进行数量统计。</p><p><img src="/images/pasted-275.png" alt="upload successful"></p><p>耗时在8s左右。我们Explain分析下：</p><p><img src="/images/pasted-276.png" alt="upload successful"></p><p>先从id为2的看起，生成了一个临时表a，但一个索引也没用到，向上看它用了学生生日，性别，班级这三个临时表的值做了auto_key（可以理解为临时索引），然后对s表全表扫描得到结果。</p><p>那我们的三个索引岂不是创建的是毫无意义的……</p><p>我们可以将它的auto_key变成一个联合索引，index_4(stu_birthday, stu_sex, stu_class)。</p><p>这时候查询时间减少到5s左右。</p><p><img src="/images/pasted-277.png" alt="upload successful"></p><p><img src="/images/pasted-278.png" alt="upload successful"></p><p>可以看到使用到了index_4，且Extra字段原来使用Using temporary现在变为了Using index。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>好了，基本上就这些内容，其实也有想写一个多表联查复杂的SQL语句的优化，但是无奈例子比较难找（自己不想再建新表，再插入数据，再想例子），在这儿就不在举例了。</p><p>其实实际中SQL语句的编写，复杂的还是比较少的（毕竟有程序结合，一个不行可以拆开嘛）。</p><p>这一节主要的内容其实是讲Explain这个关键字的，实际中写完复杂SQL语句可以用它分析下SQL执行情况。</p><p>上面也看到了有些索引不是建了就会减少查询时间的，索引的选择还是要认真对待，处理好能提升不少查询效率，另外索引创建也应找到问题的关键点。比如该字段经常被group by，order by ，该字段业务中经常使用等等。</p><p>使用Explain可以帮我们分析到索引的利用情况。</p><p>另外，Mysql除<strong>BTree索引</strong>外，还有一种<strong>Hash索引</strong>。</p><p>BTree索引具有范围查找和前缀查找的能力，一个N节点的BTree，检索一条记录时间复杂度为O(LogN)，相当于二分查找。</p><p>Hash索引只能做等值查找，但查找时间复杂度为O(1)。</p><p>如果值的差异性大，并且以等值查找（=、 &lt;、&gt;、in）为主，Hash索引是更好的选择。<br>如果值的差异性相对较差，并且以范围查找为主，BTree是更好的选择。</p><p>一般使用BTree索引的场合较多。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>结束之前，我们可以看看索引的一些失效场景。</p><ol><li><p>索引列查询出现 is not null 情况，会进行全表扫描不走索引。</p><p> <img src="/images/pasted-279.png" alt="upload successful"></p></li><li><p>列类型是字符串，数据需要引号引起来，否则会进行全表扫描不走索引。</p><p> <img src="/images/pasted-280.png" alt="upload successful"></p></li><li><p>模糊查询like的各种情况，不再详述。</p></li><li><p>联合索引的各种情况，不再详述。</p></li><li><p>or的情况，当用or连接条件时，应保证条件都有索引才能使用索引，否则索引无效。</p><p> 可以看到由于stu_name没有索引，故进行了全表扫描。</p><p> <img src="/images/pasted-281.png" alt="upload successful"></p><p> stu_sex和stu_birthday均有索引，使用了索引。</p><p> <img src="/images/pasted-282.png" alt="upload successful"></p></li><li><p>如果MySQL觉得全表扫描要比使用索引要快，它也不会使用索引。</p><p> 如下：由于stu_sex=0 或者 stu_class =1 数据很多，且都要返回，故没有使用它们的索引。</p><p> <img src="/images/pasted-283.png" alt="upload successful"></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我们经常会用到数据库，并可能写一些查询语句，大多数情况下，可能都是一些比较简单的增删改查语句。但某些时候，也可能遇到一些较复杂的语句。&lt;/p
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="MySQL" scheme="https://www.sakuratears.top/tags/MySQL/"/>
    
      <category term="索引" scheme="https://www.sakuratears.top/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="Explain" scheme="https://www.sakuratears.top/tags/Explain/"/>
    
      <category term="SQL" scheme="https://www.sakuratears.top/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>我的2018年度总结</title>
    <link href="https://www.sakuratears.top/blog/%E6%88%91%E7%9A%842018%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%9320181216/"/>
    <id>https://www.sakuratears.top/blog/我的2018年度总结20181216/</id>
    <published>2018-12-16T14:21:00.000Z</published>
    <updated>2018-12-16T15:52:44.836Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/show4.jpg" alt="upload successful"><br><a id="more"></a></p><h1 id="我的2018年度总结"><a href="#我的2018年度总结" class="headerlink" title="我的2018年度总结"></a>我的2018年度总结</h1><p>本来计划月底写的，可是啊，看到有时力不从心的自己，还是决定提前写了吧。</p><p>写这个文章，算是对自己今年一整年的总结吧。</p><p>怎么说呢？</p><p>先整体上总结一下吧，感觉自己比17年状态要好，懂得了时间的宝贵吧，自制力上也有些许提高。</p><p>语无伦次了呢……</p><p>哎，谁让我是个偏内向的男孩啊。啊啊啊啊啊啊啊，老男人，哈哈。</p><p>不知道3、5年后，在看到这篇文章，会想到些什么呢？</p><p>如果文章还在的话……</p><p>不扯那么多矫情的话了……</p><p>我的2018年度总结开篇吧。</p><p>先说下自己的一些目标及愿望吧，我比较喜欢列清单的方式。</p><p><img src="/images/pasted-235.png" alt="upload successful"></p><p>主要也是由于制定的比较晚吧，可能目标/愿望较少，不过也基本上能代表2018年的一些自己主要的计划/想法了。</p><p>总的来说一些目标也太模糊，一些目标也很随意，毕竟第一年制定这么个清单。</p><p>比如坚持锻炼，可能那时定个坚持锻炼7天，坚持15天……一点点来，自己就不会太迷茫，开始就感觉没戏一样。</p><p>而且总感觉对自己下不去狠心，惩罚写的很潦草，奖励写的不现实。</p><p>PS：所以这儿就不贴上面给大家看啦，哈哈。</p><p>PS：而且还有一些比较个人隐私的目标和愿望没写到上面。</p><p>PS：如果你看到这篇文章，也可以自己制定个计划List，不一定要一年，一个月，半年也是可以的。有的时候越长远，反而越不容易实现。</p><p>人都是有惰性的嘛。</p><p>总会越来越好的。</p><p>2018年的自己，怎么说呢？</p><blockquote><p>也自信也迷茫，<br>也努力也彷徨，<br>也欢喜也哀伤，<br>也年轻也沧桑。</p></blockquote><p>感觉自己也是蛮幸运的吧。</p><p>也受到过不少负面的影响。</p><p>有时甚至无聊到想探寻人类的本质……</p><p>有人说，出生那一刻，人命就定了，曾经年少轻狂，以为自己可以拯救世界，却发现世界根本不在乎你……</p><p>哈哈，越长大越“认命”吗？</p><p>罗曼·罗兰有句话说的好啊。</p><blockquote><p>世界上只有一种真正的英雄主义，那就是在认清生活的真相后依然热爱生活。</p></blockquote><p>对于人生，我觉得，或许会认命，但绝不会认输。</p><p>好吧，我自己这都是写了啥啊……</p><p>哎，跑题了……</p><p>就这样吧，就这样吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/show4.jpg&quot; alt=&quot;upload successful&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="https://www.sakuratears.top/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="思维" scheme="https://www.sakuratears.top/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper Java客户端Curator</title>
    <link href="https://www.sakuratears.top/blog/Zookeeper-Java%E5%AE%A2%E6%88%B7%E7%AB%AFCurator20181215/"/>
    <id>https://www.sakuratears.top/blog/Zookeeper-Java客户端Curator20181215/</id>
    <published>2018-12-15T03:35:00.000Z</published>
    <updated>2018-12-15T07:21:31.060Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们今天来讲讲Zookeeper Java客户端的一些使用吧。</p><p>之前我们说到Zookeeper的安装及简单使用，要介绍它的一些应用场景，要明白它的应用场景，要先理解它客户端的一些操作方法。</p><p>Zookeeper的Java客户端，最常使用的便是Apache Curator了，它是Netflix公司开源的一个Zookeeper客户端，与Zookeeper提供的原生客户端ZooKeeper相比，Curator的抽象层次更高，简化了Zookeeper客户端的开发量，而且Curator的功能更加强大。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>要使用Curator客户端，需要下面的两个依赖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.12.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.12.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>curator-recipes包一般能满足我们的需要，要是封装更简便的底层功能的话，curator-framework包必不可少。</p><h2 id="创建并启动客户端"><a href="#创建并启动客户端" class="headerlink" title="创建并启动客户端"></a>创建并启动客户端</h2><p>使用程序创建一个客户端client并启动（连接到Zookeeper）。</p><p>Builder模式创建一个客户端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder()</span><br><span class="line">                .connectString(zkConfig.getConnectString())</span><br><span class="line">                .namespace(zkConfig.getNameSpace())</span><br><span class="line">                .retryPolicy(<span class="keyword">new</span> ExponentialBackoffRetry(zkConfig.getRetryInterval(), Integer.MAX_VALUE))</span><br><span class="line">                .connectionTimeoutMs(zkConfig.getConnectTimeoutMs())</span><br><span class="line">                .sessionTimeoutMs(zkConfig.getSessionTimeoutMs());</span><br><span class="line">        client = builder.build();</span><br></pre></td></tr></table></figure><p>客户端启动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.start();</span><br></pre></td></tr></table></figure><p>简单说下连接时的参数:</p><ol><li><strong>connectString</strong>：服务器列表，逗号隔开（host1:port1,host2:port2……）</li><li><strong>namespace</strong>：命名空间，可以用来进行业务区分。</li><li><strong>retryPolicy</strong>：重试策略,有以下4种重试策略，也可以自己实现重试策略（实现RetryPolicy接口）。<pre><code>RetryOneTime：重试一次。RetryNTimes：重试N次（需要传入重试间隔参数sleepMsBetweenRetries，及尝试次数n），它继承了抽象类SleepingRetry（每休眠一段时间重试一次）。RetryForever：一直重试（需要传入重试间隔retryIntervalMs参数）。BoundedExponentialBackoffRetry：重试次数固定，但每次重试的时间间隔会不断变大（如果一直连不上），需要传入初始等待重试时间baseSleepTimeMs，重试次数maxRetries，及最大等待重试时间maxSleepTimeMs 参数，这个类继承ExponentialBackoffRetry（它又继承SleepingRetry）抽象类。</code></pre></li><li><strong>sessionTimeoutMs</strong>：会话超时时间，单位毫秒，默认60000ms。</li><li><strong>connectionTimeoutMs</strong>：连接创建超时时间，单位毫秒，默认60000ms。</li></ol><h2 id="创建数据节点。"><a href="#创建数据节点。" class="headerlink" title="创建数据节点。"></a>创建数据节点。</h2><p>Zookeeper节点有4种，上篇文章已介绍。</p><p><strong>创建持久化节点</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT).forPath(path, data);</span><br></pre></td></tr></table></figure><p>使用create方法，creatingParentsIfNeeded这个方法保证如果有父节点也会一起创建，这在原生客户端是无法实现的。<br>CreateMode 有4种，跟Zookeeper的节点类型对应。<br>forPath方法可以认为最终操作，path表示节点路径，data表示节点数据。<br>data是byte数组，其它类型的数据应转换为byte数组。</p><p>注：如果不设置withMode方法，默认创建持久化节点，不设置data，节点默认内容为空。</p><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.create().forPath(path);</span><br></pre></td></tr></table></figure><p><strong>创建顺序节点</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT_SEQUENTIAL).forPath(path, data);</span><br></pre></td></tr></table></figure><p><strong>创建临时节点</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(path, data);</span><br></pre></td></tr></table></figure><p><strong>创建临时顺序节点</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath(path, data);</span><br></pre></td></tr></table></figure><h2 id="设置节点数据"><a href="#设置节点数据" class="headerlink" title="设置节点数据"></a>设置节点数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.setData().forPath(path, bytes);</span><br></pre></td></tr></table></figure><p>直接调用setData方法即可，返回一个Stat（节点信息类）。</p><h2 id="获取节点数据"><a href="#获取节点数据" class="headerlink" title="获取节点数据"></a>获取节点数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.getData().forPath(path);</span><br></pre></td></tr></table></figure><p>使用getData方法，返回byte数组。</p><h2 id="获取子节点"><a href="#获取子节点" class="headerlink" title="获取子节点"></a>获取子节点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.getChildren().forPath(path);</span><br></pre></td></tr></table></figure><p>使用getChildren方法，返回一个子节点List <code>&lt;String&gt;</code> 列表，数据为各个子节点名称。</p><h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.delete().guaranteed().forPath(path);</span><br></pre></td></tr></table></figure><p>使用delete方法，guaranteed方法可以保证一定删除。如果某个节点删除失败，会抛出异常，但是如果使用了guaranteed，它会在后台继续进行删除直到删除成功。</p><h2 id="删除节点（包括子节点）"><a href="#删除节点（包括子节点）" class="headerlink" title="删除节点（包括子节点）"></a>删除节点（包括子节点）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.delete().guaranteed().deletingChildrenIfNeeded().forPath(path);</span><br></pre></td></tr></table></figure><p>deletingChildrenIfNeeded方法可以保证如果有子节点的话一并删除，原生client是无法实现此功能的（需要我们写方法处理）。</p><h2 id="判断节点是否存在"><a href="#判断节点是否存在" class="headerlink" title="判断节点是否存在"></a>判断节点是否存在</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkNodeExist</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> exits = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Stat stat = client.checkExists().forPath(path);</span><br><span class="line"><span class="keyword">if</span> (stat != <span class="keyword">null</span>) &#123;</span><br><span class="line">exits = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> exits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用checkExists方法，最终返回一个Stat，如果Stat为空就说明不存在。</p><p>PS：由此我们可以创建一个 createOrUpdate方法，无节点时创建，有节点时更新内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createOrUpdateNode</span><span class="params">(String path, <span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(checkNodeExist(path))&#123;</span><br><span class="line">setData(path,data);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">createNode(path, data);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h2><p>上面的操作方法，都可以使用异步进行处理的，主要使用了inBackground方法。</p><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.create().inBackground().forPath(path, data);</span><br></pre></td></tr></table></figure><p>该方法全参函数如下，且重载了多个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">inBackground</span><span class="params">(BackgroundCallback callback, Object context, Executor executor)</span></span>;</span><br></pre></td></tr></table></figure><pre><code>BackgroundCallback callback：异步回调函数，处理完成后会回调此函数进行某些逻辑。Object context：上下文对象。Executor executor：异步处理的线程，不指定的话将使用内部默认线程处理。</code></pre><p>我们可以看下BackgroundCallback 方法 会有两个参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BackgroundCallback</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processResult</span><span class="params">(CuratorFramework var1, CuratorEvent var2)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个参数CuratorEvent里面包含了此次处理结果的所有信息，包括节点信息等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CuratorEvent</span> </span>&#123;</span><br><span class="line">    <span class="function">CuratorEventType <span class="title">getType</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getResultCode</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getPath</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">getContext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Stat <span class="title">getStat</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">byte</span>[] getData();</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">List&lt;String&gt; <span class="title">getChildren</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">List&lt;ACL&gt; <span class="title">getACLList</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">WatchedEvent <span class="title">getWatchedEvent</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CuratorEventType表示事件类型，表示此次操作的事件类型。可以看到它与CuratorFramework里的方法是一一对应的。</p><p><img src="/images/pasted-226.png" alt="upload successful"></p><p>getResultCode返回处理结果码。可以在这个枚举里查看各个状态码。</p><p><img src="/images/pasted-227.png" alt="upload successful"></p><h2 id="添加watcher"><a href="#添加watcher" class="headerlink" title="添加watcher"></a>添加watcher</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">client.getData().usingWatcher(watcher).forPath(path);</span><br><span class="line">client.getChildren().usingWatcher(watcher).forPath(path);</span><br></pre></td></tr></table></figure><p>使用usingWatcher结合getData或者getChildren方法可以为指定节点或者子节点添加watcher。</p><p>Watcher可以为CuratorWatcher或者Zookeeper自带的Watcher。它们有一个event参数。</p><p><img src="/images/pasted-228.png" alt="upload successful"></p><p>可以拿到Zookeeper的状态 KeeperState和 事件类型 EventType，从而进行某些必要的操作。</p><p>KeeperState枚举和EventType枚举如下图。</p><p><img src="/images/pasted-229.png" alt="upload successful"></p><p><img src="/images/pasted-230.png" alt="upload successful"></p><h2 id="事务支持"><a href="#事务支持" class="headerlink" title="事务支持"></a>事务支持</h2><p>Zookeeper一些操作是支持事务的。</p><p>主要用到的方法有inTransaction、and、commit等方法。举例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 开启事务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CuratorTransaction <span class="title">startTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> client.inTransaction();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事务中添加create操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CuratorTransactionFinal <span class="title">addCreateToTransaction</span><span class="params">(CuratorTransaction transaction, String path)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> transaction.create().forPath(path, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>]).and();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事务中添加delete操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CuratorTransactionFinal <span class="title">addDeleteToTransaction</span><span class="params">(CuratorTransaction transaction, String path)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> transaction.delete().forPath(path).and();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事务中添加seData操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CuratorTransactionFinal <span class="title">addSetDataToTransaction</span><span class="params">(CuratorTransaction transaction, String path, <span class="keyword">byte</span>[] data)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> transaction.setData().forPath(path, data).and();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提交事务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;CuratorTransactionResult&gt; <span class="title">commitTransaction</span><span class="params">(CuratorTransactionFinal transaction)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> transaction.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="检查连接情况"><a href="#检查连接情况" class="headerlink" title="检查连接情况"></a>检查连接情况</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.getZookeeperClient().isConnected();</span><br></pre></td></tr></table></figure><h2 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.close();</span><br></pre></td></tr></table></figure><h1 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h1><p>对Curator客户端有简单理解后，我们把它进行简单功能的封装。</p><p>PS：Curator的强大之处在于其增强功能部分，我们会在后面结合Zookeeper应用讨论。</p><p>创建项目framework-zookeeper，搭建如下结构：</p><p><img src="/images/pasted-231.png" alt="upload successful"></p><p>接口ZKClient，里面有一些Zookeeper客户端的协议，大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ZKClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;<span class="comment">//启动</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">()</span></span>;<span class="comment">//连接情况</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;<span class="comment">//关闭</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createNode</span><span class="params">(String path, <span class="keyword">byte</span>[] data)</span></span>;<span class="comment">//创建永久节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createOrUpdateNode</span><span class="params">(String path, <span class="keyword">byte</span>[] data)</span></span>; <span class="comment">//创建或者更新节点   </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createEphemeralNode</span><span class="params">(String path, <span class="keyword">byte</span>[] data)</span></span>;</span><br><span class="line"><span class="function">String <span class="title">createSequenceNode</span><span class="params">(String path)</span> </span>;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CuratorZKClient是Curator对接口ZKClient的实现，BaseZKClient是原生客户端对接口ZKClient的实现。</p><p>我们来写下CuratorZKClient的一些关键代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorZKClient</span> <span class="keyword">implements</span> <span class="title">ZKClient</span> </span>&#123;</span><br><span class="line"><span class="comment">//zk客户端</span></span><br><span class="line"><span class="keyword">private</span> CuratorFramework client;</span><br><span class="line">  <span class="comment">//关闭状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> closed = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//zk配置</span></span><br><span class="line"><span class="keyword">private</span> ZKConfig zkConfig;</span><br><span class="line"><span class="comment">//连接状态监听</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;ConnectionListener&gt; connectionListeners = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</span><br><span class="line"><span class="comment">//节点变化监听及相关Watcher</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, ConcurrentMap&lt;NodeListener, CuratorWatcher&gt;&gt; nodeListeners = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供一个连接监听接口，以便我们可以监听Zookeeper的连接状态并且执行某些操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConnectionListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(ZKConstants.ConnectState state)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>及节点变化接口，监测节点变化进行某些操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NodeListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nodeChanged</span><span class="params">(String path, List&lt;String&gt; nodes)</span></span>;<span class="comment">//节点改变</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nodeDelete</span><span class="params">(String path)</span></span>;<span class="comment">//节点删除</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dataChanged</span><span class="params">(String path, <span class="keyword">byte</span>[] data)</span></span>;<span class="comment">//节点数据改变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ZKConfig是Zookeeper客户端连接的配置，属性值可以配置在properties等配置文件里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String connectString;</span><br><span class="line">    <span class="keyword">private</span> String nameSpace;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> retryInterval = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> connectTimeoutMs = <span class="number">60000</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> sessionTimeoutMs = <span class="number">60000</span>;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CuratorZKClient 里实现接口的start方法是，部分代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  .......</span><br><span class="line">        CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder()</span><br><span class="line">                .connectString(zkConfig.getConnectString())</span><br><span class="line">                .namespace(zkConfig.getNameSpace())</span><br><span class="line">                <span class="comment">//重试指定的次数, 且每一次重试之间停顿的时间逐渐增加</span></span><br><span class="line">                .retryPolicy(<span class="keyword">new</span> ExponentialBackoffRetry(zkConfig.getRetryInterval(), Integer.MAX_VALUE))</span><br><span class="line">                .connectionTimeoutMs(zkConfig.getConnectTimeoutMs())</span><br><span class="line">                .sessionTimeoutMs(zkConfig.getSessionTimeoutMs());</span><br><span class="line">        client = builder.build();</span><br><span class="line">        <span class="comment">//添加Zookeeper状态监听</span></span><br><span class="line">        client.getConnectionStateListenable().addListener(<span class="keyword">new</span> ConnectionStateListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(CuratorFramework client, ConnectionState zkConnectionState)</span> </span>&#123;</span><br><span class="line">                ZKConstants.ConnectState state = toConnectionListenerState(zkConnectionState);</span><br><span class="line">                <span class="keyword">if</span> (state != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(ConnectionListener connectionListener : connectionListeners) &#123;</span><br><span class="line">                        connectionListener.stateChanged(state);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">private</span> ZKConstants.<span class="function">ConnectState <span class="title">toConnectionListenerState</span><span class="params">(ConnectionState zkConnectionState)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">switch</span> (zkConnectionState) &#123;</span><br><span class="line">                    <span class="keyword">case</span> LOST:</span><br><span class="line">                        <span class="keyword">return</span> ZKConstants.ConnectState.DISCONNECTED;</span><br><span class="line">                    <span class="keyword">case</span> SUSPENDED:</span><br><span class="line">                        <span class="keyword">return</span> ZKConstants.ConnectState.DISCONNECTED;</span><br><span class="line">                    <span class="keyword">case</span> CONNECTED:</span><br><span class="line">                        <span class="keyword">return</span> ZKConstants.ConnectState.CONNECTED;</span><br><span class="line">                    <span class="keyword">case</span> RECONNECTED:</span><br><span class="line">                        <span class="keyword">return</span> ZKConstants.ConnectState.RECONNECTED;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p>这样我们暴露了Zookeeper的连接状态监听接口，以后想监听它的连接状态进行某些操作，直接实现接口，并通过addConnectionListener添加进来即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addConnectionListener</span><span class="params">(ConnectionListener listener)</span> </span>&#123;</span><br><span class="line">        connectionListeners.add(listener);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeConnectionListener</span><span class="params">(ConnectionListener listener)</span> </span>&#123;</span><br><span class="line">        connectionListeners.remove(listener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其它的方法，比如createNode、deleteNode等，我们拿到client后，按照上面讲述的各个操作便可以写出代码，这里不再赘述。以下是createNode的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createNode</span><span class="params">(String path, <span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">     client.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT).forPath(path, data);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (KeeperException.NodeExistsException e) &#123;</span><br><span class="line">            log.warn(String.format(<span class="string">"create node is exist:%s"</span>, path));</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再说一下需要实现的NodeListener方法，节点发生变化，主要通过watcher通知。<br>实现一个watcher。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorWatcherImpl</span> <span class="keyword">implements</span> <span class="title">CuratorWatcher</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> NodeListener listener;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CuratorWatcherImpl</span><span class="params">(NodeListener listener)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.listener = listener;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unWatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.listener = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                log.debug(event.getPath() + <span class="string">" with event "</span> + event.getType());</span><br><span class="line">                <span class="keyword">switch</span> (event.getType()) &#123;</span><br><span class="line">                <span class="comment">//节点数据变化，调用listener指定方法</span></span><br><span class="line">                    <span class="keyword">case</span> NodeDataChanged:</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">byte</span>[] data = client.getData().usingWatcher(<span class="keyword">this</span>).forPath(event.getPath());</span><br><span class="line">                            log.debug(event.getPath() + <span class="string">" data after change: "</span> + <span class="keyword">new</span> String(data));</span><br><span class="line">                            listener.dataChanged(event.getPath(), data);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            log.warn(e.getMessage(), e);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//节点删除</span></span><br><span class="line">                    <span class="keyword">case</span> NodeDeleted:</span><br><span class="line">                    <span class="comment">//节点创建</span></span><br><span class="line">                    <span class="keyword">case</span> NodeCreated:</span><br><span class="line">                        log.error(event.getPath());</span><br><span class="line">                    <span class="comment">//自己点改变</span></span><br><span class="line">                    <span class="keyword">case</span> NodeChildrenChanged:</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (event.getType().equals(Watcher.Event.EventType.NodeDeleted)) &#123;</span><br><span class="line">                                listener.nodeDelete(event.getPath());</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                List&lt;String&gt; nodes = getNodes(event.getPath());</span><br><span class="line">                                <span class="keyword">if</span> (nodes != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    client.getChildren().usingWatcher(<span class="keyword">this</span>).forPath(event.getPath());</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">//监控子节点数据变化</span></span><br><span class="line">                                <span class="comment">//for(String node : nodes) &#123;</span></span><br><span class="line">                                <span class="comment">//    client.getData().usingWatcher(this).forPath( ZKPathMgr.joinPath(event.getPath(),node));</span></span><br><span class="line">                                <span class="comment">//&#125;</span></span><br><span class="line">                                log.debug(event.getPath() + <span class="string">" nodes after change: "</span> + nodes);</span><br><span class="line">                                listener.nodeChanged(event.getPath(), nodes);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (KeeperException.NoNodeException e) &#123;</span><br><span class="line">                            log.warn(e.getMessage());</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            log.warn(e.getMessage(), e);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> None:</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后实现NodeListener的添加移除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNodeListener</span><span class="params">(String path, NodeListener listener)</span> </span>&#123;</span><br><span class="line">       ConcurrentMap&lt;NodeListener, CuratorWatcher&gt; listeners = nodeListeners.get(path);</span><br><span class="line">       <span class="keyword">if</span> (listeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">           nodeListeners.putIfAbsent(path, <span class="keyword">new</span> ConcurrentHashMap&lt;NodeListener, CuratorWatcher&gt;());</span><br><span class="line">           listeners = nodeListeners.get(path);</span><br><span class="line">       &#125;</span><br><span class="line">       CuratorWatcher watcher = listeners.get(listener);</span><br><span class="line">       <span class="keyword">if</span> (watcher == <span class="keyword">null</span>) &#123;</span><br><span class="line">           listeners.putIfAbsent(listener, <span class="keyword">new</span> CuratorWatcherImpl(listener));</span><br><span class="line">           watcher = listeners.get(listener);</span><br><span class="line">       &#125;</span><br><span class="line">       addChildrenCuratorWatcher(path, watcher);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeNodeListener</span><span class="params">(String path, NodeListener listener)</span> </span>&#123;</span><br><span class="line">       ConcurrentMap&lt;NodeListener, CuratorWatcher&gt; listeners = nodeListeners.get(path);</span><br><span class="line">       <span class="keyword">if</span> (listeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">           CuratorWatcher watcher = listeners.remove(listener);</span><br><span class="line">           <span class="keyword">if</span> (watcher != <span class="keyword">null</span>) &#123;</span><br><span class="line">               ((CuratorWatcherImpl) watcher).unWatch();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//添加目录watcher</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addChildrenCuratorWatcher</span><span class="params">(<span class="keyword">final</span> String path, CuratorWatcher watcher)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           client.getData().usingWatcher(watcher).forPath(path);</span><br><span class="line">           client.getChildren().usingWatcher(watcher).forPath(path);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (KeeperException.NoNodeException e) &#123;</span><br><span class="line">           log.warn(String.format(<span class="string">"add watcher node not exist:%s"</span>, path));</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可以看到主要是是维护一个ConcurrentHashMap，listener为key，watcher为value，节点有变化，通知到listener。</p><p>好。到这里基本上一个Zookeeper工具客户端就OK了，BaseZKClient的实现与CuratorZKClient类似，有兴趣的可以自己看看。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>我们测试下我们的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">ZKConfig config = <span class="keyword">new</span> ZKConfig();</span><br><span class="line">config.setConnectString(<span class="string">"127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183"</span>);</span><br><span class="line">config.setConnectTimeoutMs(<span class="number">60000</span>);</span><br><span class="line">config.setNameSpace(<span class="string">"zwt"</span>);</span><br><span class="line">config.setRetryInterval(<span class="number">1000</span>);</span><br><span class="line">config.setSessionTimeoutMs(<span class="number">60000</span>);</span><br><span class="line">ZKClient client = <span class="keyword">new</span> CuratorZKClient(config);</span><br><span class="line">client.addConnectionListener(<span class="keyword">new</span> ConnectionListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(ZKConstants.ConnectState state)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"ZKState state "</span>+ state.name());</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">client.start();</span><br><span class="line">client.createNode(<span class="string">"/mytest"</span>,<span class="string">"Hello World"</span>);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(client.getData(<span class="string">"/mytest"</span>),<span class="string">"UTF-8"</span>));</span><br><span class="line">client.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行可以看到输出：</p><p><img src="/images/pasted-232.png" alt="upload successful"></p><p>我们使用命令行也可以看到我们新增的test节点及其属性。</p><p><img src="/images/pasted-233.png" alt="upload successful"></p><p>PS：可以看到nameSpace 业务命名空间相当于新增一个根节点以区分不同业务，避免节点冲突等作用。</p><p>我们在client启动后添加watcher。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">client.start();</span><br><span class="line">client.addNodeListener(<span class="string">"/mytest"</span>, <span class="keyword">new</span> NodeListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nodeChanged</span><span class="params">(String path, List&lt;String&gt; nodes)</span> </span>&#123;</span><br><span class="line">System.out.println(path+<span class="string">" node changed"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nodeDelete</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">System.out.println(path+<span class="string">" node delete"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dataChanged</span><span class="params">(String path, <span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line">System.out.println(path+<span class="string">" data changed "</span>+ data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(client.getData(<span class="string">"/mytest"</span>),<span class="string">"UTF-8"</span>));</span><br><span class="line">client.setData(<span class="string">"/mytest"</span>,<span class="string">"World"</span>);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(client.getData(<span class="string">"/mytest"</span>),<span class="string">"UTF-8"</span>));</span><br><span class="line">client.createNode(<span class="string">"/mytest/test"</span>);</span><br><span class="line">client.deleteNodeWithChildren(<span class="string">"/mytest"</span>);</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>继续测试，结果如下。</p><p><img src="/images/pasted-234.png" alt="upload successful"></p><p>到这里，我们基本把客户端操作的基本说完了。关于其它一些Zookeeper客户端，这里就不在过多介绍了，有兴趣的可以继续实现ZKClient接口去完成。</p><p>PS：BaseZKClient类是我写的一个原生Zookeeper客户端的集成工具，但有些小问题未处理。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过使用Zookeeper客户端的一些例子，更对Zookeeper有了更深入的了解。</p><p>下面的文章我们将结合Curator的一些高级功能及Zookeeper的一些应用来了解Zookeeper的强大之处。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我们今天来讲讲Zookeeper Java客户端的一些使用吧。&lt;/p&gt;
&lt;p&gt;之前我们说到Zookeeper的安装及简单使用，要介绍它的一些
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="Zookeeper" scheme="https://www.sakuratears.top/tags/Zookeeper/"/>
    
      <category term="Curator" scheme="https://www.sakuratears.top/tags/Curator/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper初探</title>
    <link href="https://www.sakuratears.top/blog/Zookeeper%E5%88%9D%E6%8E%A220181208/"/>
    <id>https://www.sakuratears.top/blog/Zookeeper初探20181208/</id>
    <published>2018-12-08T14:08:00.000Z</published>
    <updated>2018-12-08T16:16:08.307Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前不久研究了下Zookeeper，感觉挺不错的，这几天把成果总结下，方便记忆。</p><p>今天先简单介绍下它的安装使用和一些特性吧。</p><blockquote><p>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</p></blockquote><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Zookeeper的安装与配置"><a href="#Zookeeper的安装与配置" class="headerlink" title="Zookeeper的安装与配置"></a>Zookeeper的安装与配置</h2><p>首先需要下载安装包。</p><p><a href="http://zookeeper.apache.org/" target="_blank" rel="noopener">Zookeeper官网地址</a></p><p><a href="http://mirrors.hust.edu.cn/apache/zookeeper/zookeeper-3.4.13/" target="_blank" rel="noopener">点击这里</a>  我们可以通过镜像的方式将压缩包下载下来。</p><p><img src="/images/pasted-210.png" alt="upload successful"></p><p>解压到合适目录，进入到zookeeper目录下的conf目录，需要新建zoo.cfg文件，可以看到里面有一个zoo_sample.cfg文件，可以作为我们的配置参考。</p><p><img src="/images/pasted-211.png" alt="upload successful"></p><p>我们来看下它里面的一些常用参数：</p><pre><code>tickTime=2000指Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime 时间就会发送一个心跳。单位毫秒initLimit=10此配置表示，允许 follower（相对于 leader 而言）连接并同步到 leader 的初始化连接时间，它以 tickTime 的倍数来表示。当超过设置倍数的 tickTime 时间，则连接失败。syncLimit=5此配置表示，leader 与 follower 之间发送消息，请求和应答时间长度。如果 follower 在设置的时间内不能与leader 进行通信，那么此 follower 将被丢弃。dataDir=D:/zookeeper1/zookeeper/data数据存储快照的地址dataLogDir=D:/zookeeper1/zookeeper/log数据库事务日志地址，如果不设置此项，默认dataDir的地址clientPort=2181供客户端连接的端口，对外提供的端口server.10=127.0.0.1:2888:3888集群模式下需要的配置（单机不需要） server.A = B:C:DA：表示这是第几号服务器B：服务器的 IP 地址C：集群内机器通讯使用（Leader监听此端口）D：一旦集群中的 Leader 服务器挂了，需要一个端口重新进行选举，选出一个新的 Leader</code></pre><h2 id="Zookeeper的启动和使用"><a href="#Zookeeper的启动和使用" class="headerlink" title="Zookeeper的启动和使用"></a>Zookeeper的启动和使用</h2><p>看完上面配置后，我们先配置单机zookeeper对其简单使用。</p><p>进入到zookeeper bin目录下，我们可以看到一些脚本，分为cmd脚本和sh脚本。</p><p><img src="/images/pasted-212.png" alt="upload successful"></p><pre><code>zkCleanup　　清理Zookeeper历史数据脚本，包括日志文件和快照数据文件zkCli　　　　Zookeeper的客户端脚本zkEnv　　　　设置Zookeeper的环境变量脚本zkServer　　 Zookeeper服务器的启动、停止、和重启脚本</code></pre><h3 id="启动Zookeeper"><a href="#启动Zookeeper" class="headerlink" title="启动Zookeeper"></a>启动Zookeeper</h3><p>Windows操作：</p><pre><code>进入到bin目录下，执行如下命令：zkServer可以启动zookeeper服务。（需要注意windows下dataDir路径支持/和\\，但使用\会出现问题。）</code></pre><p>下图是我公司电脑（Windows）上的zookeeper启动图。</p><p><img src="/images/pasted-213.png" alt="upload successful"></p><p>Linux/Mac/Unix操作：</p><pre><code>进入到bin目录下，执行如下命令：./zkServer.sh start可以启动zookeeper服务。</code></pre><h3 id="停止Zookeeper"><a href="#停止Zookeeper" class="headerlink" title="停止Zookeeper"></a>停止Zookeeper</h3><p>Windows操作：</p><pre><code>直接可以Ctrl+C结束命令。</code></pre><p>Linux/Mac/Unix操作：</p><pre><code>./zkServer.sh stopPS:杀进程也可以结束，不推荐</code></pre><h3 id="连接Zookeeper"><a href="#连接Zookeeper" class="headerlink" title="连接Zookeeper"></a>连接Zookeeper</h3><p>Windows操作：</p><pre><code>进入到bin目录下，执行如下命令：zkCli -server localhost:2181可以连接到zookeeper服务。</code></pre><p>下图是Windows电脑上连接到zookeeper服务的图。  </p><p><img src="/images/pasted-214.png" alt="upload successful"></p><p>Linux/Mac/Unix操作：</p><pre><code>进入到bin目录下，执行如下命令：./zkCli.sh -server localhost:2181可以连接到zookeeper服务。</code></pre><h3 id="Zookeeper常用命令"><a href="#Zookeeper常用命令" class="headerlink" title="Zookeeper常用命令"></a>Zookeeper常用命令</h3><p>在zookeeper客户端，使用help可以查看可以使用的命令。</p><p><img src="/images/pasted-215.png" alt="upload successful"></p><p>我们说几个比较常用的命令。</p><p><strong>创建节点：</strong></p><pre><code>create [-s] [-e] path data acl使用此命令可以创建一个zookeeper节点。其中，-s或-e分别指定节点特性，顺序或临时节点，若不指定，则表示持久节点；acl用来进行权限控制。create -s /zk-test test表示创建顺序节点zk-test。</code></pre><p><img src="/images/pasted-216.png" alt="upload successful"></p><p>可以看到创建的zk-test节点后面添加了一串数字以示区别顺序。</p><pre><code>create -e /zk-temp test表示创建临时节点。临时节点在客户端断开连接后会自动删除。</code></pre><p><img src="/images/pasted-217.png" alt="upload successful"></p><p><img src="/images/pasted-218.png" alt="upload successful"></p><p>可以看到创建临时节点重新登陆后节点已被删除。</p><pre><code>create /zk-permanent  test创建永久节点zk-permanent。</code></pre><p><strong>读取节点：</strong></p><pre><code>ls path [watch] 可以列出节点下面的所有子节点。get path [watch] 可以获取根节点数据内容和属性信息。ls2 path [watch] 列出节点信息。</code></pre><p>如下图：</p><p><img src="/images/pasted-219.png" alt="upload successful"></p><p><strong>更新节点：</strong></p><pre><code>set path data [version]</code></pre><p>我们将zk-permanent节点下的数据test变为test1。</p><p><img src="/images/pasted-220.png" alt="upload successful"></p><p>可以看到dataVersion也发生了变化，用来表示已经进行了更新。</p><p><strong>删除节点：</strong></p><pre><code>delete path [version]</code></pre><p>我们删除刚才创建的zk-permanent节点。</p><p><img src="/images/pasted-221.png" alt="upload successful"></p><p>可以看到节点已经被删除。</p><p><strong>PS：若删除节点存在子节点，那么无法删除该节点，必须先删除子节点，再删除父节点。</strong></p><h2 id="Zookeeper部署模式"><a href="#Zookeeper部署模式" class="headerlink" title="Zookeeper部署模式"></a>Zookeeper部署模式</h2><p>Zookeeper的部署模式一般分为3种，单机模式、伪集群模式、集群模式。</p><p><strong>单机模式</strong></p><p>单个Zookeeper服务，如上面所述。</p><p><strong>伪集群模式</strong></p><p>所谓伪集群, 是指在单台机器中启动多个zookeeper进程, 并组成一个集群。</p><p>以3个zookeeper服务进程为例。</p><p>需要有3个zookeeper项目。</p><p><img src="/images/pasted-222.png" alt="upload successful"></p><p>三个项目配置特殊的地方：</p><p>zookeeper1配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dataDir=D:/zookeeper1/zookeeper/data</span><br><span class="line">dataLogDir=D:/zookeeper1/zookeeper/log</span><br><span class="line">clientPort=2181</span><br><span class="line">server.1=127.0.0.1:2881:3881</span><br><span class="line">server.2=127.0.0.1:2882:3882   </span><br><span class="line">server.3=127.0.0.1:2883:3883</span><br><span class="line">#同时在dataDir路径文件夹里需要新建myid文件，里面写入服务器的编号 1</span><br></pre></td></tr></table></figure></p><p>zookeeper2配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dataDir=D:/zookeeper2/zookeeper/data</span><br><span class="line">dataLogDir=D:/zookeeper2/zookeeper/log</span><br><span class="line">clientPort=2182</span><br><span class="line">server.1=127.0.0.1:2881:3881</span><br><span class="line">server.2=127.0.0.1:2882:3882   </span><br><span class="line">server.3=127.0.0.1:2883:3883</span><br><span class="line">#同时在dataDir路径文件夹里需要新建myid文件，里面写入服务器的编号 2</span><br></pre></td></tr></table></figure></p><p>zookeeper3配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dataDir=D:/zookeeper3/zookeeper/data</span><br><span class="line">dataLogDir=D:/zookeeper3/zookeeper/log</span><br><span class="line">clientPort=2183</span><br><span class="line">server.1=127.0.0.1:2881:3881</span><br><span class="line">server.2=127.0.0.1:2882:3882   </span><br><span class="line">server.3=127.0.0.1:2883:3883</span><br><span class="line">#同时在dataDir路径文件夹里需要新建myid文件，里面写入服务器的编号 3</span><br></pre></td></tr></table></figure></p><p>在同一台机器上，3者的端口号不能相同，不然出现端口冲突。</p><p><strong>集群模式</strong></p><p>集群模式下配置和伪集群相似。</p><p>服务器1配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tickTime=2000</span><br><span class="line">initLimit=10</span><br><span class="line">syncLimit=5</span><br><span class="line">dataDir=D:/zookeeper1/zookeeper/data</span><br><span class="line">dataLogDir=D:/zookeeper1/zookeeper/log</span><br><span class="line">clientPort=2181</span><br><span class="line">server.1=10.1.100.1:2888:3888</span><br><span class="line">server.2=10.1.100.2:2888:3888</span><br><span class="line">server.3=10.1.100.3:2888:3888</span><br></pre></td></tr></table></figure></p><p>由于不在一个服务器上，故服务器2，服务器3也如上面的配置即可，它们3个唯一不同的地方是dataDir文件夹里面的myid文件，代表着服务器各自的编号。</p><h2 id="Zookeeper特性"><a href="#Zookeeper特性" class="headerlink" title="Zookeeper特性"></a>Zookeeper特性</h2><p>由上面内容，我们汇总说下Zookeeper的一些性质。</p><p><strong>类文件系统（数据节点）</strong></p><p>Zookeeper有类似于Unix文件系统的节点。它可以自由创建、修改和删除子目录，这些目录项被称为znode，znode可以存储数据。</p><p>Zookeeper有4种类型的znode：</p><pre><code>1. PERSISTENT   持久化目录节点，客户端与zookeeper断开连接后，该节点依旧存在 2. PERSISTENT_SEQUENTIAL   持久化顺序编号目录节点，客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号 3. EPHEMERAL   临时目录节点，客户端与zookeeper断开连接后，该节点被删除 4. EPHEMERAL_SEQUENTIAL   临时顺序编号目录节点，客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号</code></pre><p><strong>通知机制</strong></p><p>客户端注册监听它关心的目录节点，当目录节点发生变化（数据改变、被删除、子目录节点增加删除）时，zookeeper会通知客户端。这是非常重要的一条性质。</p><p><strong>高可用性</strong></p><p>zookeeper的高可用性通过zookeeper集群实现。</p><p>Zookeeper一般有三种集群角色：</p><pre><code>Leader（领导者）Follower（跟随者）Observer（观察者）</code></pre><p>一个 ZooKeeper 集群同一时刻只会有一个 Leader，其他都是 Follower 或 Observer。</p><p>ZooKeeper 默认只有 Leader 和 Follower 两种角色，没有 Observer 角色。为了使用 Observer 模式，在任何想变成Observer的节点的配置文件中加入 <strong>peerType=observer</strong> 并在所有 server 的配置文件中，配置成 observer 模式的 server 的那行配置追加 <strong>:observer</strong>即可。</p><p>ZooKeeper 集群的所有机器通过一个 Leader 选举过程来选定一台机器作为Leader，Leader服务器为客户端提供读和写服务。Follower 和 Observer 都能提供读服务，不能提供写服务。两者唯一的区别在于，Observer机器不参与 Leader 选举过程，也不参与写操作的过半写成功策略，因此 Observer 可以在不影响写性能的情况下提升集群的读性能。</p><p>我们简单来看下：</p><p>我在自己的Mac机器上创建了4个zookeeper服务并启动（伪集群），其中一个是Observer，另三个其中一个是Leader，其它两个Follower。（3台机器中谁是Leader是选举出来的，一般情况下先启动的会成为Leader）。</p><p>配置如下(关键配置)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># zookeeper1的配置，myid文件里值为1</span><br><span class="line">clientPort=2181</span><br><span class="line">server.1=127.0.0.1:2881:3881</span><br><span class="line">server.2=127.0.0.1:2882:3882</span><br><span class="line">server.3=127.0.0.1:2883:3883</span><br><span class="line">server.4=127.0.0.1:2884:3884:observer</span><br><span class="line"></span><br><span class="line"># zookeeper2的配置，myid文件里值为2</span><br><span class="line">clientPort=2182</span><br><span class="line">server.1=127.0.0.1:2881:3881</span><br><span class="line">server.2=127.0.0.1:2882:3882</span><br><span class="line">server.3=127.0.0.1:2883:3883</span><br><span class="line">server.4=127.0.0.1:2884:3884:observer</span><br><span class="line"></span><br><span class="line"># zookeeper3的配置，myid文件里值为3</span><br><span class="line">clientPort=2183</span><br><span class="line">server.1=127.0.0.1:2881:3881</span><br><span class="line">server.2=127.0.0.1:2882:3882</span><br><span class="line">server.3=127.0.0.1:2883:3883</span><br><span class="line">server.4=127.0.0.1:2884:3884:observer</span><br><span class="line"></span><br><span class="line"># zookeeper4的配置，myid文件里值为4</span><br><span class="line">clientPort=2184</span><br><span class="line">peerType=observer</span><br><span class="line">server.1=127.0.0.1:2881:3881</span><br><span class="line">server.2=127.0.0.1:2882:3882</span><br><span class="line">server.3=127.0.0.1:2883:3883</span><br><span class="line">server.4=127.0.0.1:2884:3884:observer</span><br></pre></td></tr></table></figure></p><p>启动后查看它们的角色：</p><p><img src="/images/pasted-223.png" alt="upload successful"></p><p>可以看到zookeeper2是leader，我们停掉zookeeper2.</p><p><img src="/images/pasted-224.png" alt="upload successful"></p><p>可以看到leader变成了zookeeper3.</p><p>我们继续把zookeeper3停掉。</p><p><img src="/images/pasted-225.png" alt="upload successful"></p><p>可以发现zookeeper集群已经不能正常运行了。</p><p>zookeeper在执行增删改操作时，只要有半数以上服务器通过，就可以成功执行（不包括observer服务器）</p><p>半数以上投票通过：可以这样理解，客户端的增删改操作无论访问到了哪台zookeeper服务器，最终都会被转发给leader服务器，再由leader服务器分给zookeeper集群中所有follower服务器去投票（投票指的是在内存中做增删改操作），半数投票通过就被认为操作可执行（commit），否则不可执行。</p><p>由于在增删改操作中需要<strong>半数以上</strong>服务器通过，来分析以下情况。</p><pre><code>2台服务器，至少2台正常运行才行，正常运行1台服务器都不允许挂掉。3台服务器，至少2台正常运行才行，正常运行可以允许1台服务器挂掉。4台服务器，至少3台正常运行才行，正常运行可以允许1台服务器挂掉。......</code></pre><p>故上面例子当挂掉两台服务器时，zookeeper服务已经不能正常运行了。</p><p>由上面可以知道，2n-1台服务器和2n台服务器都最多允许n-1台服务器挂掉（n&gt;=2）。</p><p>一般为了节省资源，环境基本配置奇数2n-1台服务器（不包括observer）。</p><h2 id="Zookeeper应用场景"><a href="#Zookeeper应用场景" class="headerlink" title="Zookeeper应用场景"></a>Zookeeper应用场景</h2><p>Zookeeper的应用场景还是很多的，如：</p><pre><code>1.命名服务2.分布式协调服务/通知 3.数据发布与订阅（配置中心） 4.Master选举 5.分布式锁</code></pre><p>等。</p><p>我会在后面结合例子研究zookeeper的一些应用场景。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>通过对Zookeeper的一些学习，明白了Zookeeper的一些特点用途，了解了一些简单操作，还是蛮不错的一次学习过程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前不久研究了下Zookeeper，感觉挺不错的，这几天把成果总结下，方便记忆。&lt;/p&gt;
&lt;p&gt;今天先简单介绍下它的安装使用和一些特性吧。&lt;/
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Zookeeper" scheme="https://www.sakuratears.top/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot集成RocketMQ</title>
    <link href="https://www.sakuratears.top/blog/SpringBoot%E9%9B%86%E6%88%90RocketMQ20181203/"/>
    <id>https://www.sakuratears.top/blog/SpringBoot集成RocketMQ20181203/</id>
    <published>2018-12-03T14:13:00.000Z</published>
    <updated>2018-12-04T14:26:11.381Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在开始之前，大家可以先了解RocketMQ的一些特性。</p><p><a href="https://www.sakuratears.top/blog/RocketMQ%E7%AE%80%E4%BB%8B20181103/">RocketMQ简介</a> </p><p>今天我们接上之前说的，对RocketMQ进行简单使用。主要的也是讲如何在SpringBoot项目中使用RocketMQ。</p><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><h2 id="RocketMQ安装"><a href="#RocketMQ安装" class="headerlink" title="RocketMQ安装"></a>RocketMQ安装</h2><p>我们先在<a href="http://rocketmq.apache.org/" target="_blank" rel="noopener">RocketMQ官网</a>上下载最新的MQ版本并进行安装。</p><p>可以通过镜像进行下载。</p><p>将压缩包解压并放在一个指定文件夹下。（这里要注意的是文件夹路径中尽量不要有空格，像Program Files这种，有可能导致mq无法正常启动）</p><h2 id="RocketMQ启动"><a href="#RocketMQ启动" class="headerlink" title="RocketMQ启动"></a>RocketMQ启动</h2><p>通过命令行进入到bin目录下，使用 mqnamesrv -n localhost:9876 （windows）可以启动mq的namesrv。如下图：</p><p><img src="/images/pasted-187.png" alt="upload successful"></p><p>使用 mqbroker -n localhost:9876 （windows）可以启动mqbroker。如下图：</p><p><img src="/images/pasted-188.png" alt="upload successful"></p><p>注意：上图表示RocketMQ的namesrv和broker启动成功，RocketMQ若正常使用应保证namesrv和broker均启动成功。</p><h2 id="与Java集成使用"><a href="#与Java集成使用" class="headerlink" title="与Java集成使用"></a>与Java集成使用</h2><p>主要依赖于rocketmq-client的jar包，在与SpringBoot进行集成时，应当引入该jar包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.rocketmq&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;version.rocketmq&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>我们简单使用下该jar包创建消费者和生产者进行消费，来了解下它们的一些参数。</p><p><strong>生产者：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//producerGroup 生产者组名称</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"producer1"</span>);</span><br><span class="line">        <span class="comment">//设置NamesrvAddr</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">"127.0.0.1:9876"</span>);</span><br><span class="line">        <span class="comment">//设置自动创建Topic</span></span><br><span class="line">        producer.setCreateTopicKey(<span class="string">"AUTO_CREATE_TOPIC_KEY"</span>);</span><br><span class="line">        <span class="comment">//调用start()方法启动一个producer实例</span></span><br><span class="line">        producer.start();</span><br><span class="line">        System.out.println(<span class="string">"Producer started"</span>);</span><br><span class="line">        Message message=<span class="keyword">new</span> Message();</span><br><span class="line">        message.setTopic(<span class="string">"Test"</span>);</span><br><span class="line">        message.setTags(<span class="string">"123"</span>);</span><br><span class="line">        message.setBody(<span class="keyword">new</span> String(<span class="string">"Hello"</span>).getBytes());</span><br><span class="line">        SendResult result=producer.send(message);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消费者：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//需要consumerGroup</span></span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"consumer1"</span>);</span><br><span class="line">        <span class="comment">//设置NameServer</span></span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">"127.0.0.1:9876"</span>);</span><br><span class="line">        <span class="comment">//消费策略</span></span><br><span class="line">        <span class="comment">//CONSUME_FROM_LAST_OFFSET 默认策略，从该队列最尾开始消费，即跳过历史消息</span></span><br><span class="line">        <span class="comment">//CONSUME_FROM_FIRST_OFFSET 从队列最开始开始消费，即历史消息（还储存在broker的）全部消费一遍</span></span><br><span class="line">        <span class="comment">//CONSUME_FROM_TIMESTAMP 从某个时间点开始消费，和setConsumeTimestamp()配合使用，默认是半个小时以前</span></span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Topic和Tag，*代表全部的Tag</span></span><br><span class="line">        consumer.subscribe(<span class="string">"Test"</span>, <span class="string">"*"</span>);</span><br><span class="line">        <span class="comment">//设置一个Listener，主要进行消息的逻辑处理</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                            ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">                msgs.forEach((a)-&gt;&#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(a.getBody()));</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="comment">//返回消费状态</span></span><br><span class="line">                <span class="comment">//CONSUME_SUCCESS 消费成功</span></span><br><span class="line">                <span class="comment">//RECONSUME_LATER 消费失败，需要稍后重新消费</span></span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//启动</span></span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.println(<span class="string">"Consumer started"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行这两个类进行测试。</p><p>生产者结果：</p><p><img src="/images/pasted-189.png" alt="upload successful"></p><p>消费者结果：</p><p><img src="/images/pasted-190.png" alt="upload successful"></p><p><strong>备注：</strong>如果启动中出现异常<br>com.alibaba.rocketmq.client.exception.MQClientException: No route info of this topic, TestTopic<br>可能是没有开启AUTO_CREATE_TOPIC，我们可以在启动broker的时候加上该参数，mqbroker -n localhost:9876&amp;autoCreateTopicEnable=true 可以保证使用时自动创建Topic。</p><p>生产等环境一般需要什么Topic就配置什么，不会开启这个参数让程序自动创建。</p><h1 id="简要说明"><a href="#简要说明" class="headerlink" title="简要说明"></a>简要说明</h1><p>我们对上面例子里的一些参数等做些说明，以便于我们可以更好的封装功能。</p><p>可与之前<a href="https://www.sakuratears.top/blog/RocketMQ%E7%AE%80%E4%BB%8B20181103/">RocketMQ的简介</a>结合理解。</p><ol><li><p>DefaultMQProducer部分参数</p><pre><code>producerGroup：生产者组名称。namesrvAddr：生产者NameSrvAddr的服务地址。createTopicKey：可以创建指定的Topic。AUTO_CREATE_TOPIC_KEY为自动创建Topic。其它参数略。</code></pre><p> 发送Message时，需要设置Message的Topic和Tag，并能收到发送状态结果。</p></li><li><p>DefaultMQPushConsumer部分参数</p><pre><code>consumerGroup：消费者组名称。namesrvAddr：消费者NameSrvAddr的服务地址。ConsumeFromWhere：消费策略。---&gt; CONSUME_FROM_LAST_OFFSET 默认策略，从该队列最尾开始消费，即跳过历史消息---&gt; CONSUME_FROM_FIRST_OFFSET 从队列最开始开始消费，即历史消息（还储存在broker的）全部消费一遍---&gt; CONSUME_FROM_TIMESTAMP 从某个时间点开始消费，和setConsumeTimestamp()配合使用，默认是半个小时以前subscribe方法：使消费者订阅指定的Topic和Tag。registerMessageListener方法：注册消费者监听，用于消费消息，这里面也是我们业务逻辑的主要内容。有顺序消费和并行消费两种模式。分别需要实现MessageListenerOrderly接口和MessageListenerConcurrently接口。我们的例子是并行消费处理的。</code></pre></li></ol><h1 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h1><p>每次处理时都要这样写会有很多的与业务无关的代码，也不美观。</p><p>我们对其进行必要封装，之前集成了SpringBoot的一个自己封装的starter插件，今天我们把RocketMQ也与SpringBoot集成下。</p><p><font size="6" color="red"> A </font> 首先新建SpringBoot项目，引入RocketMQ 的jar依赖，不在详述。</p><p>然后在项目下创建必要的package。</p><p><img src="/images/pasted-191.png" alt="upload successful"></p><pre><code>producer：用来存放我们构建producer的类的包。consumer：用来存放我们构建consumer的类的包。listener:用来存放我们构建listener的类的包factory:用来构建生产者和消费者群组的包。config：存放SpringBoot配置类的包。autoware:存放启动配置生效的类的包。annotation：用来存放注解的包。</code></pre><p>先说下简单思路吧。</p><p>首先这个生产者和消费者是可以有多个的，然后我们怎么管理它们？<br>生产者可以发送顺序消息和并发消息，消费者可以处理顺序消息和并发消息，同时我们可能有两种业务要使用同一个Listener，如何解耦呢？</p><p>关于管理：我们可以管理生产者和消费者的一个集合来解决。</p><p>关于解耦：可以提供一个接口，业务类实现这个接口拿到Message，进行处理。那如何知道这个业务类需要哪个listener呢？自然需要customerId或者listenerId。</p><p>好了开始工作。</p><p><font size="6" color="red"> B </font> 先从配置入手。</p><p>下面是生产者和消费者的配置Bean。</p><p>由于可以配置多个生产者或者消费者，故使用List处理它们。部分代码如下：</p><p><img src="/images/pasted-192.png" alt="upload successful"></p><p><img src="/images/pasted-193.png" alt="upload successful"></p><p><img src="/images/pasted-194.png" alt="upload successful"></p><p><font size="6" color="red"> C </font> 然后从消费者和生产者的提供入手。也是比较简单的，主要是根据参数生成一个生产者或者消费者，然后暴露一些方法，如start，stop等方法。</p><p>提供生产者的类，部分代码如下。</p><p><img src="/images/pasted-195.png" alt="upload successful"></p><p><strong>备注：</strong>生产环境一般不设置AUTO_CREATE_TOPIC_KEY，需要什么Topic要手动创建加入管理。</p><p><img src="/images/pasted-196.png" alt="upload successful"></p><p>创建消费者的类，部分代码如下。</p><p><img src="/images/pasted-197.png" alt="upload successful"></p><p>我们认为两个consumerId相等则获取的是一个Consumer，因此需要重写equals方法。</p><p><img src="/images/pasted-198.png" alt="upload successful"></p><p><font size="6" color="red"> D </font>创建消费者监听，为处理消息提供一个接口。</p><p><img src="/images/pasted-199.png" alt="upload successful"></p><p>使用抽象类部分实现这个接口。</p><p><img src="/images/pasted-200.png" alt="upload successful"></p><p>这一步的目的是由于不同的业务逻辑可能用到一个监听，这样可以两个业务逻辑写到两个不同的类中，只需实现IProcessor。</p><p>写两个并行处理监听和顺序处理监听，对其进行实现。</p><p><strong>并行监听：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentlyRocketMQMessageListener</span> <span class="keyword">extends</span> <span class="title">AbstractRocketMQMessageListener</span> <span class="keyword">implements</span> <span class="title">MessageListenerConcurrently</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">transient</span> Logger logger = LoggerFactory.getLogger(ConcurrentlyRocketMQMessageListener.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">        logger.debug(<span class="string">"ConcurrentlyRocketMQMessageListener receive message begin,length:&#123;&#125;"</span> , msgs.size());</span><br><span class="line">        <span class="keyword">for</span>(MessageExt msg:msgs ) &#123;</span><br><span class="line">            <span class="keyword">for</span> (IProcessor processor : processorList) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 处理消息</span></span><br><span class="line">                    process(processor, msg);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    logger.error(<span class="string">"ConcurrentlyRocketMQMessageListener error"</span>,ex);</span><br><span class="line">                    <span class="keyword">return</span> ConsumeConcurrentlyStatus.RECONSUME_LATER;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>顺序监听：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderlyRocketMQMessageListener</span> <span class="keyword">extends</span> <span class="title">AbstractRocketMQMessageListener</span> <span class="keyword">implements</span> <span class="title">MessageListenerOrderly</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">transient</span> Logger logger = LoggerFactory.getLogger(OrderlyRocketMQMessageListener.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConsumeOrderlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context)</span> </span>&#123;</span><br><span class="line">        logger.debug(<span class="string">"OrderlyRocketMQMessageListener receive message begin,length:&#123;&#125;"</span> , msgs.size());</span><br><span class="line">        <span class="keyword">for</span>(MessageExt msg:msgs ) &#123;</span><br><span class="line">            <span class="keyword">for</span> (IProcessor processor : processorList) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    process(processor, msg);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    logger.error(<span class="string">"OrderlyRocketMQMessageListener error"</span>,ex);</span><br><span class="line">                    <span class="keyword">return</span> ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后需要对实现IProcesser接口的类添加如下注解，用来查看调用的哪个Listener。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RocketMQProcessor &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该程序归哪个消费者监听处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">consumerId</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font size="6" color="red"> E </font>好，我们开始构建factory。</p><p>使用ConcurrentHashMap存储生产者和消费者集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于存放生产者的map组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, RocketMQMessageProducer&gt; producers=<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="comment">//用于存放消费者的map组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, RocketMQMessageConsumer&gt; consumers=<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p>创建生产者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个生产者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> configuration</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RocketMQMessageProducer <span class="title">createProducer</span><span class="params">(MqProducerConfiguration configuration)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果map里存在这个实例，直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(producers.get(configuration.getProducerId())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> producers.get(configuration.getProducerId());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个生产者</span></span><br><span class="line">    RocketMQMessageProducer producer=<span class="keyword">new</span> RocketMQMessageProducer(configuration.getGroupName(), configuration.getNamesrvAddr());</span><br><span class="line">    <span class="keyword">if</span>(configuration.getSendMsgTimeout()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        producer.setSendMsgTimeout(configuration.getSendMsgTimeout());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(configuration.getMaxMessageSize()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        producer.setMaxMessageSize(configuration.getMaxMessageSize());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//启动生产者并放入map进行管理</span></span><br><span class="line">        producer.start();</span><br><span class="line">        producers.put(configuration.getProducerId(), producer);</span><br><span class="line">        logger.info(<span class="string">"MqProducer start success "</span>+configuration.toString());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">        logger.error(<span class="string">"MqProducer start error "</span>+configuration.toString(),e);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> producer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个消费者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mqConsumerConfiguration</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RocketMQMessageConsumer <span class="title">createConsumer</span><span class="params">(MqConsumerConfiguration mqConsumerConfiguration, List&lt;IProcessor&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果map里存在，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (consumers.get(mqConsumerConfiguration.getConsumerId()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> consumers.get(mqConsumerConfiguration.getConsumerId());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        RocketMQMessageConsumer consumer = <span class="keyword">new</span> RocketMQMessageConsumer(mqConsumerConfiguration.getConsumerId(), mqConsumerConfiguration.getGroupName(), mqConsumerConfiguration.getNamesrvAddr());</span><br><span class="line">        consumer.subscribe(mqConsumerConfiguration.getTopicAndTagMap());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置消费者其它参数</span></span><br><span class="line">        <span class="keyword">if</span>(!CollectionUtils.isEmpty(mqConsumerConfiguration.getOptions()))&#123;</span><br><span class="line">            String consumeFromWhere = mqConsumerConfiguration.getOptions().get(<span class="string">"consumeFromWhere"</span>);</span><br><span class="line">            String consumeThreadMin = mqConsumerConfiguration.getOptions().get(<span class="string">"consumeThreadMin"</span>);</span><br><span class="line">            String consumeThreadMax = mqConsumerConfiguration.getOptions().get(<span class="string">"consumeThreadMax"</span>);</span><br><span class="line">            String pullThresholdForQueue = mqConsumerConfiguration.getOptions().get(<span class="string">"pullThresholdForQueue"</span>);</span><br><span class="line">            String consumeMessageBatchMaxSize = mqConsumerConfiguration.getOptions().get(<span class="string">"consumeMessageBatchMaxSize"</span>);</span><br><span class="line">            String pullBatchSize = mqConsumerConfiguration.getOptions().get(<span class="string">"pullBatchSize"</span>);</span><br><span class="line">            String pullInterval = mqConsumerConfiguration.getOptions().get(<span class="string">"pullInterval"</span>);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotBlank(consumeFromWhere)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.equals(consumeFromWhere, <span class="string">"CONSUME_FROM_LAST_OFFSET"</span>)) &#123;</span><br><span class="line">                    consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.equals(consumeFromWhere, <span class="string">"CONSUME_FROM_FIRST_OFFSET"</span>)) &#123;</span><br><span class="line">                    consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotBlank(consumeThreadMin)) &#123;</span><br><span class="line">                consumer.setConsumeThreadMin(Integer.parseInt(consumeThreadMin));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotBlank(consumeThreadMax)) &#123;</span><br><span class="line">                consumer.setConsumeThreadMax(Integer.parseInt(consumeThreadMax));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotBlank(pullThresholdForQueue)) &#123;</span><br><span class="line">                consumer.setPullThresholdForQueue(Integer.parseInt(pullThresholdForQueue));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotBlank(consumeMessageBatchMaxSize)) &#123;</span><br><span class="line">                consumer.setConsumeMessageBatchMaxSize(Integer.parseInt(consumeMessageBatchMaxSize));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotBlank(pullBatchSize)) &#123;</span><br><span class="line">                consumer.setPullBatchSize(Integer.parseInt(pullBatchSize));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotBlank(pullInterval)) &#123;</span><br><span class="line">                consumer.setPullInterval(Integer.parseInt(pullInterval));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置消费者监听</span></span><br><span class="line">        <span class="keyword">if</span>(mqConsumerConfiguration.isOrderly())&#123;</span><br><span class="line">            OrderlyRocketMQMessageListener orderlyRocketMQMessageListener=<span class="keyword">new</span> OrderlyRocketMQMessageListener();</span><br><span class="line">            orderlyRocketMQMessageListener.setProcessorList(list);</span><br><span class="line">            consumer.registerMessageListener(orderlyRocketMQMessageListener);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ConcurrentlyRocketMQMessageListener concurrentlyRocketMQMessageListener=<span class="keyword">new</span> ConcurrentlyRocketMQMessageListener();</span><br><span class="line">            concurrentlyRocketMQMessageListener.setProcessorList(list);</span><br><span class="line">            consumer.registerMessageListener(concurrentlyRocketMQMessageListener);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        consumer.start();</span><br><span class="line">        consumers.put(mqConsumerConfiguration.getConsumerId(), consumer);</span><br><span class="line">        logger.info(<span class="string">"MqConsumer start success "</span>+mqConsumerConfiguration.toString());</span><br><span class="line">        logger.info(<span class="string">"MqConsumer processors size "</span>+list.size());</span><br><span class="line">        <span class="keyword">return</span> consumer;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(<span class="string">"MqConsumer start error"</span>, e);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它们的其它方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获取一个生产者</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> producerId</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> RocketMQMessageProducer <span class="title">getProducer</span><span class="params">(String producerId)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(producers.get(producerId)!=<span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> producers.get(producerId);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 停止某个生产者</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> producerId</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopProducer</span><span class="params">(String producerId)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(producers.get(producerId)!=<span class="keyword">null</span>)&#123;</span><br><span class="line">         producers.get(producerId).shutdown();</span><br><span class="line">         producers.remove(producerId);</span><br><span class="line">         logger.info(<span class="string">"MqProducer "</span>+producerId+<span class="string">" is shutdown!"</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获取一个消费者</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> customerId</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> RocketMQMessageConsumer <span class="title">getConsumer</span><span class="params">(String customerId)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(consumers.get(customerId)!=<span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> consumers.get(customerId);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 停止某个消费者</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> customerId</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopConsumer</span><span class="params">(String customerId)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(consumers.get(customerId)!=<span class="keyword">null</span>)&#123;</span><br><span class="line">         consumers.get(customerId).shutdown();</span><br><span class="line">         consumers.remove(customerId);</span><br><span class="line">         logger.info(<span class="string">"MqConsumer "</span>+customerId+<span class="string">" is shutdown!"</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><font size="6" color="red"> F </font>然后到了我们关键的自动配置部分了。</p><p>让这个类实现ApplicationContextAware可以拿到applicationContext。</p><p><img src="/images/pasted-201.png" alt="upload successful"></p><p>同时生成一个FactoryBean。</p><p>主要方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.rocketmq.config"</span>, name = <span class="string">"enabled"</span>, havingValue = <span class="string">"true"</span>)</span><br><span class="line"><span class="function">RocketMQFactory <span class="title">rocketMQFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line">    RocketMQFactory rocketMQFactory=<span class="keyword">new</span> RocketMQFactory();</span><br><span class="line">    <span class="comment">//处理生产者</span></span><br><span class="line">    <span class="keyword">if</span>(mqConfigurations.getMqProducerConfigurations()!=<span class="keyword">null</span>&amp;&amp;mqConfigurations.getMqProducerConfigurations().size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        mqConfigurations.getMqProducerConfigurations().forEach(producerConfiguration -&gt;&#123;</span><br><span class="line">            rocketMQFactory.createProducer(producerConfiguration);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mqConfigurations.getMqConsumerConfigurations()!=<span class="keyword">null</span>&amp;&amp;mqConfigurations.getMqConsumerConfigurations().size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//处理消费者</span></span><br><span class="line">        mqConfigurations.getMqConsumerConfigurations().forEach(consumerConfiguration-&gt;&#123;</span><br><span class="line">            <span class="comment">//处理Processor</span></span><br><span class="line">            <span class="keyword">final</span> Map&lt;String, Object&gt; annotationMap = applicationContext.getBeansWithAnnotation(RocketMQProcessor.class);</span><br><span class="line">            List&lt;IProcessor&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">if</span>(annotationMap!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                annotationMap.forEach((key,value)-&gt;&#123;</span><br><span class="line">                    RocketMQProcessor annotation = value.getClass().getAnnotation(RocketMQProcessor.class);</span><br><span class="line">                    <span class="keyword">if</span>(consumerConfiguration.getConsumerId().equals(annotation.consumerId()))&#123;</span><br><span class="line">                        <span class="keyword">try</span>&#123;</span><br><span class="line">                            list.add((IProcessor) value);</span><br><span class="line">                        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            rocketMQFactory.createConsumer(consumerConfiguration,list);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rocketMQFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说就是拿到配置生产生产者组，生成消费者组。</p><p>在生成消费者的时候需要注册监听，一个监听可以有很多业务类，通过注解拿到业务类，放到处理器列表里，再把该监听注册到指定的customerId上。</p><p><font size="6" color="red"> G </font> 配置spring.factories。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.zwt.rocketmqspringboot.autoware.RocketMqAutoConfig</span><br></pre></td></tr></table></figure><p><font size="6" color="red"> H </font> 然后我们添加application.properties进行测试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">## 是否启用RocketMQ</span><br><span class="line">spring.rocketmq.config.enabled=true</span><br><span class="line"></span><br><span class="line">## Producer1配置</span><br><span class="line">spring.rocketmq.config.mq-producer-configurations[0].group-name=rocketmq-producer</span><br><span class="line">spring.rocketmq.config.mq-producer-configurations[0].namesrv-addr=localhost:9876</span><br><span class="line">spring.rocketmq.config.mq-producer-configurations[0].producer-id=001</span><br><span class="line"></span><br><span class="line">## Consumer1配置</span><br><span class="line">spring.rocketmq.config.mq-consumer-configurations[0].namesrv-addr=localhost:9876</span><br><span class="line">spring.rocketmq.config.mq-consumer-configurations[0].group-name=rocketmq-consumer</span><br><span class="line">spring.rocketmq.config.mq-consumer-configurations[0].consumer-id=001</span><br><span class="line">spring.rocketmq.config.mq-consumer-configurations[0].topic-and-tag-map.123=123</span><br><span class="line">spring.rocketmq.config.mq-consumer-configurations[0].orderly=false</span><br><span class="line"></span><br><span class="line">server.port=8001</span><br><span class="line"></span><br><span class="line">## Producer2配置</span><br><span class="line">spring.rocketmq.config.mq-producer-configurations[1].group-name=rocketmq-producer1</span><br><span class="line">spring.rocketmq.config.mq-producer-configurations[1].namesrv-addr=localhost:9876</span><br><span class="line">spring.rocketmq.config.mq-producer-configurations[1].producer-id=002</span><br><span class="line"></span><br><span class="line">## Consumer2配置</span><br><span class="line">spring.rocketmq.config.mq-consumer-configurations[1].namesrv-addr=localhost:9876</span><br><span class="line">spring.rocketmq.config.mq-consumer-configurations[1].group-name=rocketmq-consumer1</span><br><span class="line">spring.rocketmq.config.mq-consumer-configurations[1].consumer-id=002</span><br><span class="line">spring.rocketmq.config.mq-consumer-configurations[1].topic-and-tag-map.1234=1234</span><br><span class="line">spring.rocketmq.config.mq-consumer-configurations[1].orderly=false</span><br></pre></td></tr></table></figure><p>编写一些测试类进行测试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RocketMQProcessor</span>(consumerId = <span class="string">"001"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConsumer</span> <span class="keyword">implements</span> <span class="title">IProcessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(TestConsumer.class);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(MessageExt msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(msg.getBody())+<span class="string">"TestConsumer"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProducer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RocketMQFactory rocketMQFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doSomething</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Message message=<span class="keyword">new</span> Message();</span><br><span class="line">        message.setTopic(<span class="string">"123"</span>);</span><br><span class="line">        message.setTags(<span class="string">"123"</span>);</span><br><span class="line">        message.setBody(<span class="keyword">new</span> String(<span class="string">"Hello World"</span>).getBytes());</span><br><span class="line">        SendResult result=rocketMQFactory.getProducer(<span class="string">"001"</span>).sendMessage(message);</span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到正常运行。</p><p><img src="/images/pasted-202.png" alt="upload successful"></p><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>我们按照上篇文章那样把它封装成jar包。</p><p>完成后进行测试。</p><p>新建一个test的SpringBoot项目。作为消费者。</p><p>引入我们的包。</p><p><img src="/images/pasted-203.png" alt="upload successful"></p><p>PS：这儿没有命名为xxxx-spring-boot-starter的形式。</p><p>创建一个消费者。</p><p><img src="/images/pasted-204.png" alt="upload successful"></p><p><img src="/images/pasted-205.png" alt="upload successful"></p><p>再新建一个test1的SpringBoot项目。作为生产者。</p><p>引入我们的包并进行配置。</p><p><img src="/images/pasted-206.png" alt="upload successful"></p><p><img src="/images/pasted-207.png" alt="upload successful"></p><p>启动test消费者，同时使用test1生产者发送一条消息。</p><p>可以看到。</p><p>生产者发送成功：</p><p><img src="/images/pasted-208.png" alt="upload successful"></p><p>消费者处理成功：</p><p><img src="/images/pasted-209.png" alt="upload successful"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过对RocketMQ的集成封装使用，更好地学会了如何使用RocketMQ，及对其的更多理解。</p><p>消息中间件在我们软件开发中具有重要作用，应当好好理解。</p><p>如果觉得properties配置太繁琐可以改用yml配置，会更简介好看些。</p><p>如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  rocketmq:</span></span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line"><span class="attr">      enabled:</span> <span class="literal">true</span>                                        <span class="comment"># 是否启用RocketMQ</span></span><br><span class="line"><span class="attr">      mq-producer-configurations:</span>                        <span class="comment"># 生产者配置</span></span><br><span class="line"><span class="attr">      - producerId:</span> <span class="string">TestProducer1</span>                          <span class="comment"># 生产者1的id</span></span><br><span class="line"><span class="attr">        groupName:</span> <span class="string">producer1</span>                               <span class="comment"># 生产者1的组名称</span></span><br><span class="line"><span class="attr">        namesrvAddr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9876</span>                        <span class="comment"># 生产者1的namesrvAddr</span></span><br><span class="line"><span class="attr">      - producerId:</span> <span class="string">TestProducer2</span>                          <span class="comment"># 生产者2的id</span></span><br><span class="line"><span class="attr">        groupName:</span> <span class="string">producer2</span>                               <span class="comment"># 生产者2的组名称</span></span><br><span class="line"><span class="attr">        namesrvAddr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9876</span>                        <span class="comment"># 生产者2的namesrvAddr</span></span><br><span class="line"></span><br><span class="line"><span class="attr">      mq-consumer-configurations:</span>                        <span class="comment"># 消费者配置</span></span><br><span class="line"><span class="attr">      - consumerId:</span> <span class="string">TestConsumer1</span>                          <span class="comment"># 消费者1的id</span></span><br><span class="line"><span class="attr">        groupName:</span> <span class="string">consumer1</span>                               <span class="comment"># 消费者1的组名称</span></span><br><span class="line"><span class="attr">        namesrvAddr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9876</span>                        <span class="comment"># 消费者1的namesrvAddr</span></span><br><span class="line"><span class="attr">        topicAndTagMap:</span> <span class="string">&#123;</span> <span class="attr">TestTopic1:TestTag1</span> <span class="string">&#125;</span>            <span class="comment"># 消费者1监听的topic和tag</span></span><br><span class="line"><span class="attr">        orderly:</span> <span class="literal">false</span>                                      <span class="comment"># 消费者1是否顺序消费消息</span></span><br><span class="line"><span class="attr">      - consumerId:</span> <span class="string">TestConsumer2</span>                           <span class="comment"># 消费者2的id</span></span><br><span class="line"><span class="attr">        groupName:</span> <span class="string">consumer2</span>                                <span class="comment"># 消费者2的组名称</span></span><br><span class="line"><span class="attr">        namesrvAddr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9876</span>                         <span class="comment"># 消费者2的namesrvAddr</span></span><br><span class="line"><span class="attr">        topicAndTagMap:</span> <span class="string">&#123;</span> <span class="attr">TestTopic2:TestTag2</span> <span class="string">&#125;</span>             <span class="comment"># 消费者2监听的topic和tag</span></span><br><span class="line"><span class="attr">        orderly:</span> <span class="literal">true</span>                                        <span class="comment"># 消费者2是否顺序消费消息</span></span><br></pre></td></tr></table></figure><p>代码地址：<a href="https://github.com/JavaZWT/framework-base/tree/master/rocketmq-spring-boot" target="_blank" rel="noopener">rocketmq-spring-boot</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在开始之前，大家可以先了解RocketMQ的一些特性。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sakuratears.to
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="SpringBoot" scheme="https://www.sakuratears.top/tags/SpringBoot/"/>
    
      <category term="RocketMQ" scheme="https://www.sakuratears.top/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>构建一个自定义的spring-boot-starter</title>
    <link href="https://www.sakuratears.top/blog/%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84spring-boot-starter20181129/"/>
    <id>https://www.sakuratears.top/blog/构建一个自定义的spring-boot-starter20181129/</id>
    <published>2018-11-29T14:48:00.000Z</published>
    <updated>2018-12-01T08:43:31.456Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>现在很多项目都使用SpringBoot构建了，不知道大家在使用SpringBoot项目时有没有注意到它的一些jar包的引用。如下图：</p><p><img src="/images/pasted-171.png" alt="upload successful"></p><p>我们引入相关starter后，在application.properties或者application.yml里面进行相关配置，便可以尽情使用相关功能了，十分方便。</p><p>今天我们构建一个自己的spring-boot-starter，来体验下spring-boot的魅力和乐趣。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>我之前有一篇文章是ElasticSearch的介绍并且对它的Java客户端封装了下，那个例子中我们最后的配置文件叫property/es-config.properties 不知道大家还有没有印象。要使用那个jar包，我们需要配置一个es-config.properties文件，显然，我想去掉这个文件，改为application.properties的那种配置，和各种spring-boot-starter一样。</p><p>好了，我们开始吧。</p><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>首先，我们需要创建一个名为 elasticsearch-spring-boot-starter 的SpringBoot项目（除springboot基础外不需要其他dependencies）。</p><p><img src="/images/pasted-172.png" alt="upload successful"></p><p>这儿有一点要注意的，就是项目（后面生成jar包）命名。</p><p><strong>备注</strong>：Spring官方的starter命名一般会采用 spring-boot-starter-xxxx的形式，而官方建议非官方的starter命名可以遵循 xxxx-spring-boot-starter的形式。</p><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><p>然后我们引入我们要编写的starter的一些依赖。（这里对以前封装的ElasticSearch 客户端jar包进行继续优化封装）</p><p><img src="/images/pasted-173.png" alt="upload successful"></p><p><strong>备注</strong>：dependency里的optional表示可选依赖，因为spring-boot父项目有日志的相关jar，我们不必再次引用。</p><p>这样配置的优点大致如下：</p><ol><li>节约空间（不用两个jar包重复引用）</li><li>避免license许可问题（两个jar版本不同可能出现问题）</li><li>避免jar包出现冲突等问题（两个jar版本不同可能出现问题）</li></ol><h1 id="构建（改造）项目"><a href="#构建（改造）项目" class="headerlink" title="构建（改造）项目"></a>构建（改造）项目</h1><p>然后我们把原来的项目改造下。</p><p>我们移除了配置解析的一些方法及类，改用自动配置。</p><p><img src="/images/pasted-174.png" alt="upload successful"></p><p>使用@ConfigurationProperties注解，指定要进行属性配置的Bean。</p><p><img src="/images/pasted-175.png" alt="upload successful"></p><p>使用该注解，需要引入下面的jar包。</p><p><img src="/images/pasted-176.png" alt="upload successful"></p><p>这个jar包的@ConfigurationProperties注解可以帮我们把application.properties的属性值映射到Bean里。</p><p>这个jar的作用是编译时生成 spring-configuration-metadata.json ，此文件主要给IDE使用，可以进行友好的提示。</p><p>我们还需要创建一个自动配置类，名为ElasticSearchStarterAutoConfigure，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(ElasticSearchClientFactory.class)</span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(ElasticSearchConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElasticSearchStarterAutoConfigure</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ElasticSearchConfiguration properties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.elasticserch.zwt"</span>, name = <span class="string">"enabled"</span>, havingValue = <span class="string">"true"</span>)</span><br><span class="line">    <span class="function">ElasticSearchUtil <span class="title">elasticSearchUtil</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        ElasticSearchClientFactory elasticSearchClientFactory=<span class="keyword">new</span> ElasticSearchClientFactory(properties);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ElasticSearchUtil(elasticSearchClientFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Configuration注解，我们可以看到它被标识为 @Component注解，可以认为它最终也会成为spring容器里的一个Bean。</p><p><img src="/images/pasted-177.png" alt="upload successful"></p><p>@ConditionalOnClass 当指定class存在时进行Bean创建。</p><p>@EnableConfigurationProperties 为指定class启用属性配置。</p><p>@ConditionalOnMissingBean 当bean不存在时进行bean创建。</p><p>@ConditionalOnProperty 用属性对bean进行配置创建。它里面可以enabled可以控制是否启用我们的配置。</p><p>然后在resources/META-INF 文件夹下新建spring.factories文件，添加如下内容，用于Spring加载自动配置类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.zwt.elasticsearchspringbootstarter.factory.ElasticSearchStarterAutoConfigure</span><br></pre></td></tr></table></figure><p>配置完成后，在application.properties里，就可以看到我们的自定义属性啦。</p><p><img src="/images/pasted-178.png" alt="upload successful"></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>创建测试类进行测试。</p><p><img src="/images/pasted-179.png" alt="upload successful"></p><p>application.properties配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## es地址</span><br><span class="line">spring.elasticserch.zwt.address=127.0.0.1:9300</span><br><span class="line">## 是否启用es客户端</span><br><span class="line">spring.elasticserch.zwt.enabled=true</span><br></pre></td></tr></table></figure><p>可以看到我们的日志输出。</p><p><img src="/images/pasted-180.png" alt="upload successful"></p><p>当我们把spring.elasticserch.zwt.enabled设置为false时，在运行可以看到bean创建失败了，即未注入属性配置bean。</p><p><img src="/images/pasted-181.png" alt="upload successful"></p><h1 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h1><p>我们把项目用maven打包发布下（clean install），可以看到大约30多M…….</p><p><img src="/images/pasted-182.png" alt="upload successful"></p><p>原因是它里面有原始的springboot项目，还内置了tomcat等，我们如果想把该工具jar包引入到另一个springboot项目里，这显然是不合理的。</p><p>我们还需要对其进行优化。</p><p>我们删除无用的Application class（springboot启动使用，显然我们封装jar包不是为了封装web项目），application.properties（当我们把我们工具jar引入到新的springboot项目里，里面已经有了application.properties）及test类包。</p><p>然后处理下pom文件。</p><p>在pom文件里，spring-boot-starter这个依赖我们是不需要打到包里的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>将其添加属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;optional&gt;true&lt;/optional&gt;</span><br></pre></td></tr></table></figure><p>同时build插件做下调整（原来用的springboot的插件）。</p><p>build插件基本固定的，代码可以不用看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.3&lt;/version&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;encoding&gt;$&#123;project.build.sourceEncoding&#125;&lt;/encoding&gt;</span><br><span class="line">                &lt;source&gt;$&#123;java.version&#125;&lt;/source&gt;</span><br><span class="line">                &lt;target&gt;$&#123;java.version&#125;&lt;/target&gt;</span><br><span class="line">                &lt;showWarnings&gt;true&lt;/showWarnings&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.4&lt;/version&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;attach&gt;true&lt;/attach&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">            &lt;executions&gt;</span><br><span class="line">                &lt;execution&gt;</span><br><span class="line">                    &lt;phase&gt;compile&lt;/phase&gt;</span><br><span class="line">                    &lt;goals&gt;</span><br><span class="line">                        &lt;goal&gt;jar&lt;/goal&gt;</span><br><span class="line">                    &lt;/goals&gt;</span><br><span class="line">                &lt;/execution&gt;</span><br><span class="line">            &lt;/executions&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><p>再次编译，这时候我们就可以看到jar包大小只有10几Kb啦。</p><p><img src="/images/pasted-183.png" alt="upload successful"></p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>我们随便创建一个新的springboot项目。引入我们封装的jar包。</p><p><img src="/images/pasted-184.png" alt="upload successful"></p><p>配置application.properties文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## es地址</span><br><span class="line">spring.elasticserch.zwt.address=127.0.0.1:9300</span><br><span class="line">## 是否启用es客户端</span><br><span class="line">spring.elasticserch.zwt.enabled=true</span><br></pre></td></tr></table></figure><p>新建个测试类，对我们的jar包进行测试。<br>可以看到正常运行。</p><p><img src="/images/pasted-185.png" alt="upload successful"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过一步步改造，我们成功创建了一个spring-boot-starter。</p><p>通过实践，我们也能看到springboot基于注解简化代码的配置。也是蛮不错的一次工具封装体验。</p><p><strong>补充</strong>：上面说的@ConfigurationProperties注解也可以定义自己的配置文件。</p><p>如果我们想使用原来的es-config.properties则需要进行如下配置即可。</p><p><img src="/images/pasted-186.png" alt="upload successful"></p><p>PS：SpringBoot官方已经有了对elasticsearch client的支持，建议使用官方相关支持工具。</p><p>自己实践时，可以简单的写一个HelloWorld去完成一个简单的spring-boot-starter的封装。</p><p>相关代码： <a href="https://github.com/JavaZWT/framework-base/tree/master/elasticsearch-spring-boot-starter" target="_blank" rel="noopener">https://github.com/JavaZWT/framework-base/tree/master/elasticsearch-spring-boot-starter</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;现在很多项目都使用SpringBoot构建了，不知道大家在使用SpringBoot项目时有没有注意到它的一些jar包的引用。如下图：&lt;/p&gt;
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="SpringBoot" scheme="https://www.sakuratears.top/tags/SpringBoot/"/>
    
      <category term="spring-boot-starter" scheme="https://www.sakuratears.top/tags/spring-boot-starter/"/>
    
  </entry>
  
  <entry>
    <title>接口管理平台YAPI</title>
    <link href="https://www.sakuratears.top/blog/%E6%8E%A5%E5%8F%A3%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0YAPI20181125/"/>
    <id>https://www.sakuratears.top/blog/接口管理平台YAPI20181125/</id>
    <published>2018-11-25T14:08:00.000Z</published>
    <updated>2018-11-25T14:51:28.844Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>有没有为维护接口文档而烦恼过？</p><p>作为一个良好的开发人员，为使用者提供准确良好的接口文档也是开发的一部分。</p><p>也便于测试创建测试用例。</p><p>接口管理有很多种方式，很多是提供接口文档供使用者参考，也有一些是通过平台管理。</p><p>今天介绍一款非常好用的工具，YAPI，其主要功能是一款优秀的API接口管理平台。旨在为开发、产品、测试人员提供更优雅的接口管理服务。</p><p>我在使用这个API管理平台时，感觉还蛮不错的，特此介绍下。</p><p><strong>官网地址</strong>：<a href="https://yapi.ymfe.org/" target="_blank" rel="noopener">https://yapi.ymfe.org/</a></p><p>我们搭建内网环境，把这款接口管理平台在内网部署下，并且简单使用下。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>要搭建内网环境，首先要准备以下几个软件。</p><ol><li>nodejs （必须）</li><li>mongodb （必须）</li><li>git （非必须）</li></ol><p>git主要是从GitHub上 clone项目的，如果采用可视化安装或者直接下载压缩包是用不到的。</p><p>没有以上软件的需要下载安装。</p><p>nodejs下载</p><p><img src="/images/pasted-155.png" alt="upload successful"></p><p>mongodb下载</p><p><img src="/images/pasted-156.png" alt="upload successful"></p><p>安装不做过多介绍，自己参考一些资料即可完成。</p><p>对于YAPI服务，我们采用可视化部署，执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g yapi-cli --registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p><strong>注：其他部署方式，详情可以查看官方文档 <a href="https://yapi.ymfe.org/devops/index.html" target="_blank" rel="noopener">https://yapi.ymfe.org/devops/index.html</a></strong></p><p>这儿不做讨论。</p><p>安装成功后启动 yapi server，执行命令： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yapi server</span><br></pre></td></tr></table></figure><p>通过浏览器打开页面 <a href="http://0.0.0.0:9090/" target="_blank" rel="noopener">http://0.0.0.0:9090/</a></p><p>会看到如下界面：</p><p><img src="/images/pasted-157.png" alt="upload successful"></p><p><strong>注意：需要启动mongdb数据库。</strong></p><p><strong>mongodb启动备注(路径未加入PATH)</strong>:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /Users/zhangwentong/Applications/mongodb/mongodb-osx-x86_64-4.0.4/bin</span><br><span class="line">./mongod --dbpath /Users/zhangwentong/Applications/mongodb/data/db</span><br></pre></td></tr></table></figure></p><p>部署引导完成后。我们进入到vendors 文件夹，启动YAPI服务。如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> my-yapi/vendors/</span><br><span class="line">node server/app.js</span><br></pre></td></tr></table></figure><p><img src="/images/pasted-158.png" alt="upload successful"></p><p>说明我们安装完成并启动成功了。浏览器打开图上地址。</p><p><img src="/images/pasted-159.png" alt="upload successful"></p><p>使用管理员账号登陆，<strong>初始密码为 ymfe.org</strong></p><p>其他人可以进行注册后登陆。</p><p>登陆成功后如下图：</p><p><img src="/images/pasted-160.png" alt="upload successful"></p><p>我们可以在个人中心修改密码，这儿就不做过多介绍了。看一看它的主要功能吧。</p><p><strong>首先</strong>我们创建一个分组。</p><p><img src="/images/pasted-161.png" alt="upload successful"></p><p><strong>然后</strong>我们在该分组里创建一个项目。</p><p><img src="/images/pasted-163.png" alt="upload successful"></p><p><img src="/images/pasted-162.png" alt="upload successful"></p><p>上图的成员列表里可以添加成员，把一起开发的开发者拉进来。</p><p>分组动态展示我们分组的一些操作等。</p><p>我们可以看到项目里内容如下：</p><p><img src="/images/pasted-164.png" alt="upload successful"></p><p>接口主要就是用来管理我们的接口的界面，比如后台提供某些接口，全部放在里面，供其它开发人员查看使用。</p><p>动态代表着这个项目里的接口等改动动态，方便人员查看。</p><p>成员管理可以管理这个项目的成员，指定组长，开发者，外部接口使用者（访客）等。</p><p><strong>然后</strong>我们可以添加一些模块接口分类。如下，不同接口放在不同模块下。</p><p><img src="/images/pasted-165.png" alt="upload successful"></p><p><strong>继续</strong>，我们新增加一个接口来看看吧。</p><p><img src="/images/pasted-166.png" alt="upload successful"></p><p>新增OK后对接口进行修改。</p><p><img src="/images/pasted-167.png" alt="upload successful"></p><p>当我们接口参数定义好，或者说后台接口完成后（可以测试时），我们应该把接口状态改为<strong>已完成</strong>。</p><p>一个写好的接口demo如下：</p><p><img src="/images/pasted-168.png" alt="upload successful"></p><p>同时动态里也可以看到我们对于接口的改动。</p><p><img src="/images/pasted-169.png" alt="upload successful"></p><p><strong>同时</strong>YAPI还支持测试接口，mock，wiki等，类似于Postman等工具。</p><p><img src="/images/pasted-170.png" alt="upload successful"></p><p>这儿就不过多介绍了，对于我们开发人员，最主要的应该属对接口文档的维护了，也就是刚才介绍的部分。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>今天说到这里也差不多啦，YAPI还可以控制人员的权限、给指定人员发送邮件、设置是否可以注册等其它功能，有兴趣的可以摸索。</p><p>我们对YAPI的使用就是用其对接口文档进行管理。它是易用的简便的。</p><p>在项目开发过程中，在公司服务器上搭建一套环境，对组成员接口文档维护也是受益的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;有没有为维护接口文档而烦恼过？&lt;/p&gt;
&lt;p&gt;作为一个良好的开发人员，为使用者提供准确良好的接口文档也是开发的一部分。&lt;/p&gt;
&lt;p&gt;也便于
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="YAPI" scheme="https://www.sakuratears.top/tags/YAPI/"/>
    
  </entry>
  
  <entry>
    <title>Java 8 新的日期API</title>
    <link href="https://www.sakuratears.top/blog/Java-8-%E6%96%B0%E7%9A%84%E6%97%A5%E6%9C%9FAPI20181122/"/>
    <id>https://www.sakuratears.top/blog/Java-8-新的日期API20181122/</id>
    <published>2018-11-22T14:05:00.000Z</published>
    <updated>2018-11-22T14:23:50.912Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java 8 中引入了新的一套日期API，相对于之前的Date或者Calendar类，这套API更好的解决了日期和时间的问题。</p><p>我们来简单看下。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h5 id="LocalDateTime-LocalDate-LocalTime"><a href="#LocalDateTime-LocalDate-LocalTime" class="headerlink" title="LocalDateTime,LocalDate,LocalTime"></a>LocalDateTime,LocalDate,LocalTime</h5><p>开始使用日期API时，最先碰到的也是这三个类。</p><p>他们的静态工厂of方法可以创建日期实例。如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 第一部分</span></span><br><span class="line"><span class="comment">//创建一个日期</span></span><br><span class="line">LocalDate date=LocalDate.of(<span class="number">2018</span>,<span class="number">11</span>,<span class="number">22</span>);</span><br><span class="line"><span class="comment">//时分秒</span></span><br><span class="line">LocalTime time=LocalTime.of(<span class="number">13</span>,<span class="number">45</span>,<span class="number">20</span>);</span><br><span class="line"><span class="comment">//LocalDateTime对象</span></span><br><span class="line">LocalDateTime dateTime=LocalDateTime.of(<span class="number">2018</span>,Month.NOVEMBER,<span class="number">22</span>,<span class="number">13</span>,<span class="number">45</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>是不是很简单。</p><p>要注意这三个类都是final的，即不可被改变的。</p><p>LocalDate 表示年月日，LocalTime表示时分秒，LocalDateTime表示年月日时分秒。</p><p>他们三个之间的转换也是比较容易的。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2. 第二部分</span></span><br><span class="line"><span class="comment">//使用localDate和localTime构造一个LocalDateTime</span></span><br><span class="line">LocalDateTime dateTime1=LocalDateTime.of(date,time);</span><br><span class="line"><span class="comment">//使用LocalDate构造一个LocalDateTime</span></span><br><span class="line">LocalDateTime dateTime2=date.atStartOfDay();<span class="comment">//这一天的00:00:00</span></span><br><span class="line">LocalDateTime dateTime3=date.atTime(LocalTime.of(<span class="number">12</span>,<span class="number">12</span>,<span class="number">12</span>));<span class="comment">//指定这一天的时间</span></span><br><span class="line"><span class="comment">//使用LocalTime构造LocalDateTime</span></span><br><span class="line">LocalDateTime dateTime4=time.atDate(LocalDate.of(<span class="number">2018</span>,<span class="number">11</span>,<span class="number">22</span>));<span class="comment">//指定日期</span></span><br><span class="line"><span class="comment">//通过LocalDateTime获取LocalDate和LocalTime</span></span><br><span class="line">LocalDate date1=dateTime.toLocalDate();</span><br><span class="line">LocalTime time1=dateTime.toLocalTime();</span><br></pre></td></tr></table></figure><p>对于固定的日期，我们可以获取它的时间信息，也是比较容易的。如具体年月日的数值，等等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3. 第三部分</span></span><br><span class="line"><span class="comment">//获取日期年份</span></span><br><span class="line"><span class="keyword">int</span> year=dateTime.getYear();</span><br><span class="line"><span class="keyword">int</span> year1=dateTime.get(ChronoField.YEAR);</span><br><span class="line"><span class="comment">//获取日期月份</span></span><br><span class="line">Month month=dateTime.getMonth();</span><br><span class="line"><span class="keyword">int</span> month1=month.getValue();</span><br><span class="line"><span class="keyword">int</span> month2=dateTime.get(ChronoField.MONTH_OF_YEAR);</span><br><span class="line"><span class="comment">//获取当月第几天</span></span><br><span class="line"><span class="keyword">int</span> day=dateTime.getDayOfMonth();</span><br><span class="line"><span class="keyword">int</span> day1=dateTime.get(ChronoField.DAY_OF_MONTH);</span><br><span class="line"><span class="comment">//获取星期几</span></span><br><span class="line">DayOfWeek dow=dateTime.getDayOfWeek();</span><br><span class="line"><span class="comment">//获取该月有几天</span></span><br><span class="line"><span class="keyword">int</span> len=date.lengthOfMonth();</span><br><span class="line"><span class="comment">//获取小时数</span></span><br><span class="line"><span class="keyword">int</span> hour=dateTime.getHour();</span><br><span class="line"><span class="comment">//获取分钟</span></span><br><span class="line"><span class="keyword">int</span> minute=dateTime.getMinute();</span><br><span class="line"><span class="comment">//获取秒数</span></span><br><span class="line"><span class="keyword">int</span> second=dateTime.getSecond();</span><br></pre></td></tr></table></figure><p>他们还有一些常用的方法，如时间和字符串时间之间的转化、判断闰年、获取当前时间信息、时间的比较、时间的加减天数（年数等）等方法。</p><p>相比于我们单独封装处理Date，或者Calendar类，更简便和安全了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4. 第四部分</span></span><br><span class="line"><span class="comment">//是不是闰年</span></span><br><span class="line"><span class="keyword">boolean</span> leap=date.isLeapYear();</span><br><span class="line"><span class="comment">//获取当前时间信息</span></span><br><span class="line">LocalDateTime localDateTimeNow=LocalDateTime.now();</span><br><span class="line">LocalDate localDateNow=LocalDate.now();</span><br><span class="line">LocalTime localTimeNow=LocalTime.now();</span><br><span class="line"><span class="comment">//字符串转时间</span></span><br><span class="line">LocalDate localDate1=LocalDate.parse(<span class="string">"2014-03-18"</span>);</span><br><span class="line">LocalTime localTime1=LocalTime.parse(<span class="string">"13:45:20"</span>);</span><br><span class="line">LocalDateTime localDateTime1=LocalDateTime.parse(<span class="string">"2018/11/22 11:22:33"</span>, DateTimeFormatter.ofPattern(<span class="string">"yyyy/MM/dd HH:mm:ss"</span>));</span><br><span class="line"><span class="comment">//时间转换为字符串</span></span><br><span class="line">String localDateStr=localDate1.toString();</span><br><span class="line">String localTimeStr=localTime1.format(DateTimeFormatter.ofPattern(<span class="string">"HH:mm:ss"</span>));</span><br><span class="line">String localDateTimeStr=localDateTime1.format(DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>));</span><br><span class="line"><span class="comment">//当前时间减10天</span></span><br><span class="line">LocalDateTime localDateTime2=localDateTime1.minusDays(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//当前时间加1年</span></span><br><span class="line">LocalDateTime localDateTime3=localDateTime1.plusYears(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//当前时间加1个月</span></span><br><span class="line">LocalDateTime localDateTime4=localDateTime1.minus(-<span class="number">1</span>, ChronoUnit.MONTHS);</span><br><span class="line"><span class="comment">//当前时间加1个月</span></span><br><span class="line">LocalDateTime localDateTime5=localDateTime1.plus(<span class="number">1</span>, ChronoUnit.MONTHS);</span><br><span class="line"><span class="comment">//更改日期时间，返回新的对象，原对象不会变化</span></span><br><span class="line">LocalDate localDate=date1.with(ChronoField.MONTH_OF_YEAR,<span class="number">9</span>);</span><br><span class="line"><span class="comment">//日期时间比较</span></span><br><span class="line"><span class="keyword">boolean</span> flag=localDateTime2.isAfter(localDateTime3);</span><br><span class="line"><span class="keyword">boolean</span> flag1=localDateTime2.isBefore(localDateTime3);</span><br><span class="line"><span class="keyword">boolean</span> flag2=localDateTime2.isEqual(localDateTime3);</span><br></pre></td></tr></table></figure><p>这里面对于时间的加减（plus，minus方法），赋值（with方法）都会生成新的LocalDateTime对象，不会对原来的对象做修改。</p><h5 id="Period、Duration-类"><a href="#Period、Duration-类" class="headerlink" title="Period、Duration 类"></a>Period、Duration 类</h5><p>这两个类都可以表示日期时间的差值，Period的话表示年月日，如两个时间差1年或者-1个月，Duration 的话用来表示天时分秒，比如它可以表示两个时间差相差34.5s这样的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5. 第五部分</span></span><br><span class="line"><span class="comment">//计算两个时间差</span></span><br><span class="line">Duration d1=Duration.between(localDateTime2,localDateTime3);</span><br><span class="line"><span class="keyword">long</span> days1=d1.toDays();</span><br><span class="line">Duration d2=Duration.between(localDateTime4,localDateTime5);</span><br><span class="line"><span class="keyword">long</span> hours=d2.toHours();</span><br><span class="line"><span class="comment">//计算相差时间，结果10天</span></span><br><span class="line">Period period=Period.between(LocalDate.of(<span class="number">2014</span>,<span class="number">3</span>,<span class="number">8</span>),LocalDate.of(<span class="number">2014</span>,<span class="number">3</span>,<span class="number">18</span>));</span><br><span class="line"><span class="keyword">int</span> days2=period.getDays();</span><br></pre></td></tr></table></figure><h5 id="Instant和-ZoneId"><a href="#Instant和-ZoneId" class="headerlink" title="Instant和 ZoneId"></a>Instant和 ZoneId</h5><p>从计算机的角度来看，建模时间最自然的格式是表示一个持续时间段上某个点的单一大整型数。这也是新的 java.time.Instant 类对时间建模的方式，基本上它是以Unix元年时间（传统的设定为UTC时区1970年1月1日午夜时分）开始所经历的秒数进行计算。<br>而每个ZoneId由该地区的ID标识。地区ID都为“{区域}/{城市}”的格式，这些地区集合的设定都由英特网编号分配机构（IANA）的时区数据库提供。</p><p>看下它们的用法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//6. 第六部分</span></span><br><span class="line"><span class="comment">//机器时间</span></span><br><span class="line"><span class="comment">//以下均表示3s时间</span></span><br><span class="line">Instant.ofEpochSecond(<span class="number">3</span>);</span><br><span class="line">Instant.ofEpochSecond(<span class="number">3</span>,<span class="number">0</span>);</span><br><span class="line">Instant.ofEpochSecond(<span class="number">2</span>,<span class="number">1000000</span>);</span><br><span class="line">Instant.ofEpochSecond(<span class="number">4</span>,-<span class="number">1000000</span>);</span><br><span class="line"><span class="comment">//当前时间的时间戳</span></span><br><span class="line">Instant.now();</span><br><span class="line"><span class="comment">//localDateTime转换为instant</span></span><br><span class="line">Instant instantFormDateTime=localDateTime1.toInstant(ZoneOffset.UTC);</span><br><span class="line"><span class="comment">//获取本地区的zoneId</span></span><br><span class="line">ZoneId romeZone= TimeZone.getDefault().toZoneId();</span><br><span class="line"><span class="comment">//instant转localDateTime</span></span><br><span class="line">Instant instant1=Instant.now();</span><br><span class="line">LocalDateTime timeFromInstant=LocalDateTime.ofInstant(instant1,romeZone);</span><br><span class="line"><span class="comment">//将时区设置为欧洲罗马城市。</span></span><br><span class="line">ZoneId romeZone1 = ZoneId.of(<span class="string">"Europe/Rome"</span>);</span><br></pre></td></tr></table></figure><p>一般传统的Date和LocalDate之间的转换会用到它们（Instant，ZoneId）。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>在一些项目中，应用Date还是很多的。我们想使用新的日期API，又不太想改动源代码。<br>可以写一些转换的工具类，或者使用Java8的一些日期API对Date进行处理。</p><p>如Date转化为LocalDateTime，LocalDateTime转换为Date等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java8 LocalDateTime对象转Date对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> localDateTime</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">localDateTime2Date</span><span class="params">(LocalDateTime localDateTime)</span></span>&#123;</span><br><span class="line">    <span class="comment">//获取zoneId</span></span><br><span class="line">    ZoneId zone = ZoneId.systemDefault();</span><br><span class="line">    <span class="comment">//将localDateTime转换为Instant对象</span></span><br><span class="line">    Instant instant = localDateTime.atZone(zone).toInstant();</span><br><span class="line">    <span class="keyword">return</span> Date.from(instant);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Date对象 转 Java8 LocalDateTime对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> date</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">date2LocalDateTime</span><span class="params">(Date date)</span></span>&#123;</span><br><span class="line">    <span class="comment">//根据date拿到Instant</span></span><br><span class="line">    Instant instant = date.toInstant();</span><br><span class="line">    ZoneId zone = ZoneId.systemDefault();</span><br><span class="line">    <span class="comment">//转换为LocalDateTime</span></span><br><span class="line">    <span class="keyword">return</span> LocalDateTime.ofInstant(instant, zone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将字符串日期格式化为LocalDateTime，或者将LocalDateTime转换为字符串时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 将日期格式化为指定的格式</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> date</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">localDateTime2String</span><span class="params">(Date date)</span></span>&#123;</span><br><span class="line">     LocalDateTime localDateTime=date2LocalDateTime(date);</span><br><span class="line">     <span class="keyword">return</span> DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).format(localDateTime);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 将string时间格式转化为LocalDateTime</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> string</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">string2LocalDateTime</span><span class="params">(String string)</span></span>&#123;</span><br><span class="line">     DateTimeFormatter df=DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">     <span class="keyword">return</span> LocalDateTime.parse(string,df);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>有了这些比较基础的方法，我们某些日期便可以使用Java8处理。比如项目使用Date，在判断闰年，或者时间的加减等，可以封装Java8工具类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取两个日期的时间间隔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> date1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> date2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">diffDays</span><span class="params">(Date date1,Date date2)</span></span>&#123;</span><br><span class="line">    LocalDateTime localDateTime1=date2LocalDateTime(date1);</span><br><span class="line">    LocalDateTime localDateTime2=date2LocalDateTime(date2);</span><br><span class="line">    <span class="keyword">return</span> Duration.between(localDateTime1,localDateTime2).toDays();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当期日期增加多少天后的日期，负数为减少多少天</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> date</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> days</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">addDays</span><span class="params">(Date date,<span class="keyword">int</span> days)</span></span>&#123;</span><br><span class="line">    LocalDateTime localDateTime1=date2LocalDateTime(date);</span><br><span class="line">    LocalDateTime localDateTime2=localDateTime1.minusDays(days);</span><br><span class="line">    <span class="keyword">return</span> localDateTime2Date(localDateTime2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否是闰年</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> date</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLeapYear</span><span class="params">(Date date)</span></span>&#123;</span><br><span class="line">    LocalDateTime localDateTime=date2LocalDateTime(date);</span><br><span class="line">    <span class="keyword">return</span> localDateTime.toLocalDate().isLeapYear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样对于Date的处理，均使用LocalDateTime处理，虽然整个项目把Date改造成LocalDateTime较困难，但是工具类相当于黑匣子，这样慢慢使用LocalDateTime去处理Date，也是蛮不错的一次体验。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Java8 新的日期API比较优秀的地方是更直观了，使用更简洁。而且不用担心变量污染问题，想想一般的Date，对日期进行操作，如果不小心没有创建新对象，会把传入的Date改变掉，是很不安全的。</p><p>而且它也没有时间从1900年起那种莫名其妙的限制，而且获取到的月份值是1-12，不是0-11，也是符合自然的。</p><p>其实Java 8 的日期API不单单完成了对于Java日期的优化，其更多的方法更像是一种工具API，如判断是不是闰年，求两日期之差等等常用方法，都被封装在了Java8的新的日期API里面了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Java 8 中引入了新的一套日期API，相对于之前的Date或者Calendar类，这套API更好的解决了日期和时间的问题。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>代码的优雅</title>
    <link href="https://www.sakuratears.top/blog/%E4%BB%A3%E7%A0%81%E7%9A%84%E4%BC%98%E9%9B%8520181117/"/>
    <id>https://www.sakuratears.top/blog/代码的优雅20181117/</id>
    <published>2018-11-17T11:30:00.000Z</published>
    <updated>2018-11-17T12:24:37.875Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>很早之前就想写这么一篇文章，苦于准备不足和时间有限吧，进度一拖再拖。</p><p>来到新公司差不多3个多月了，让我感到或者说受益比较大的可以说就是公司的代码风格吧。</p><p>估计也是由于有架构师的缘故，大家的代码质量感觉都比较高。</p><p>扯远了……</p><p>今天结合实际聊一下关于如何让代码变得规范、优雅吧。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="遵守规范"><a href="#遵守规范" class="headerlink" title="遵守规范"></a>遵守规范</h2><p>这一点或许可以说很笼统，目前大家除了遵守公司制定的一些规范，针对于Java我还比较建议的是阅读下阿里的《阿里巴巴Java开发手册》，H5前端的可以看看Github 上的这个规范<a href="http://alloyteam.github.io/CodeGuide/" target="_blank" rel="noopener">http://alloyteam.github.io/CodeGuide/</a> ，也是蛮不错的。</p><h2 id="必要的封装"><a href="#必要的封装" class="headerlink" title="必要的封装"></a>必要的封装</h2><p>当有一些重复，或者有共性的代码时，我们可以对它们进行包装。小到一些特殊的判断，大到常用的设计模式。</p><p>如下面的代码，实现相同的功能，明显第二种要好些。</p><p><img src="/images/pasted-142.png" alt="upload successful"></p><p><img src="/images/pasted-143.png" alt="upload successful"></p><p>这些必要的封装不仅可以减少一些额外的工作量，还能提高代码可阅读性。</p><p>一些工具包，如apache.commons 已经封装了一些通用校验，我们是可以直接拿来使用的。</p><h2 id="学会占位符的使用"><a href="#学会占位符的使用" class="headerlink" title="学会占位符的使用"></a>学会占位符的使用</h2><p>这一点打印日志比较常见到。如下：</p><p><img src="/images/pasted-144.png" alt="upload successful"></p><p>可以看到两者的输出是一样的，但是第一种是方便我们进行程序源码阅读的。</p><p>除了String.format里的%s占位符，log4j里的{}占位符也可以实现这种作用。</p><h2 id="枚举和常量的使用"><a href="#枚举和常量的使用" class="headerlink" title="枚举和常量的使用"></a>枚举和常量的使用</h2><p>正确使用一些枚举和常量可以提高代码的阅读性。</p><p>比如我们创建一个水果枚举。</p><p><img src="/images/pasted-145.png" alt="upload successful"></p><p><img src="/images/pasted-146.png" alt="upload successful"></p><p>进行某些方法，这些方法更容易被阅读和维护。</p><h2 id="异常的正确使用"><a href="#异常的正确使用" class="headerlink" title="异常的正确使用"></a>异常的正确使用</h2><p>或许你对异常不感冒，觉得有异常还要try catch是一件很费劲的事情，也影响代码美观，怎么会使代码优雅呢？</p><p>我们可以举个例子看一下异常的一种好玩的用法。</p><p>比如有一个业务逻辑，需要通过分布式接口获取其它数据，比如分三步：</p><p><img src="/images/pasted-147.png" alt="upload successful"></p><p><img src="/images/pasted-148.png" alt="upload successful"></p><p><img src="/images/pasted-149.png" alt="upload successful"></p><p>这种情况下每个Res我们需要判断成功，才能获取数据。</p><p><img src="/images/pasted-150.png" alt="upload successful"></p><p>即retCode为0000时。其它为失败。</p><p>这时候我们可以创建异常类。用于对retCode和retInfo进行接收。</p><p><img src="/images/pasted-151.png" alt="upload successful"></p><p>如果上面步骤中获取失败，直接上抛。</p><p><img src="/images/pasted-152.png" alt="upload successful"></p><p>最后可以使用try catch统一处理返回。</p><p><img src="/images/pasted-153.png" alt="upload successful"></p><p>还有一些异常的用法，在这里就不一一说明了。</p><h2 id="必要时尝试使用多线程"><a href="#必要时尝试使用多线程" class="headerlink" title="必要时尝试使用多线程"></a>必要时尝试使用多线程</h2><p>可以在必要时使用多线程来提高程序运行效率。</p><p>对于上面的例子，查询可用余额，查询提现次数，查询银行卡信息相互之间是不影响的（他们的结果只取决于userId或者customerId的值）。我们可以使用Future获取结果，减少程序运行时间。</p><p><img src="/images/pasted-154.png" alt="upload successful"></p><p>使用多线程分别去请求获取结果，最后在进行处理。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>规范的代码不仅自己赏心悦目，别人看后也有所启发，养成编写良好代码的习惯，对自己、对别人都是有所帮助的。</p><p>其实最重要的还是多学、多练、多思考吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;很早之前就想写这么一篇文章，苦于准备不足和时间有限吧，进度一拖再拖。&lt;/p&gt;
&lt;p&gt;来到新公司差不多3个多月了，让我感到或者说受益比较大的可
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>和朋友的一次关于数组问题讨论</title>
    <link href="https://www.sakuratears.top/blog/%E5%92%8C%E6%9C%8B%E5%8F%8B%E7%9A%84%E4%B8%80%E6%AC%A1%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98%E8%AE%A8%E8%AE%BA20181107/"/>
    <id>https://www.sakuratears.top/blog/和朋友的一次数组问题讨论20181107/</id>
    <published>2018-11-07T14:18:00.000Z</published>
    <updated>2018-11-07T14:56:53.109Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前两天下班和一朋友一起，被问到如下问题：<strong>如何移除一个数组中某些符合条件（或不符合条件）的元素形成新的数组，要求数组长度也应该变化</strong>（这是我后面加的）。</p><p>这两天研究下了这个问题，感觉比较有意思，也从中学到了一些其它该注意的东西。</p><p>特此来分享一下。</p><p>如有问题欢迎批评指正。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>对于上面的问题，最简单也最应该想到的一个应该是借助List这个工具类。</p><p>是的，我写下大致如下代码：</p><h2 id="（1）使用List帮助类实现-借助remove方法"><a href="#（1）使用List帮助类实现-借助remove方法" class="headerlink" title="（1）使用List帮助类实现,借助remove方法"></a>（1）使用List帮助类实现,借助remove方法</h2><p>优点：代码简洁，便于理解，不易出错</p><p>缺点：数组和List转换耗时，效率不算太高，使用List remove方法时应注意线程安全问题，如果是基本数据类型，需要转换为包装类，拆箱装箱也是影响效率的一个因素。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 过滤形成新的数组（转换为List，通过List里面remove(安全的)移除元素）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceArray</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> predicate</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] getArray1(T[] sourceArray,Predicate&lt;T&gt; predicate,Class&lt;T&gt; type)&#123;</span><br><span class="line">    <span class="comment">//asList生成的是一个List的内部类，无法调用add remove delete方法会抛出异常</span></span><br><span class="line">    List&lt;T&gt; sourceList= <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(sourceArray));</span><br><span class="line">    <span class="comment">//使用Java8 函数式接口，移除不符合条件的元素</span></span><br><span class="line">    sourceList.removeIf(predicate);</span><br><span class="line">    <span class="keyword">return</span> sourceList.toArray((T[]) Array.newInstance(type,<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注： Predicate<t> predicate 相当于一个判断条件（lambda表达式，Java8语法），具体的问题也可以写明，就是那种for list 在加上 if 条件判断的，这儿我就不啰嗦了。Java 8里面对于集合类，新增了 removeIf方法，我们可以看下它，其实就是我们上面说的那个。</t></p><p><img src="/images/pasted-140.png" alt="upload successful"></p><p>关于这种写法，有需要注意的几点：</p><ol><li><p>for-each，for, iterator 这三种对于List的循环，for，iterator是可以遍历并进行remove操作的，但是for-each是不可以的。有兴趣的可以研究研究，这不是我们的重点。</p></li><li><p>看到我上面使用的泛型T，其实使用Object[]也是可以的，要注意一个问题，泛型T是不能包含int,long等基本数据类型的，使用的话只能转化为它们的包装类。</p></li><li><p>Object[]是没有限制的，但是Object[]转换为Integer[]或者int[]或者其他不能直接转换，如下写法是错误的，会出现问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object [] objects=<span class="keyword">new</span> Object[<span class="number">10</span>];</span><br><span class="line">Integer [] a=(Integer[])objects;</span><br></pre></td></tr></table></figure></li></ol><p>正确的转换方法应该循环里面的元素，并对它们强转添加进数组；或者使用下面的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object [] objects=<span class="keyword">new</span> Object[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//Integer [] a=(Integer[])objects;</span></span><br><span class="line">Integer [] a=(Integer[])Array.newInstance(Integer.class,objects.length);</span><br></pre></td></tr></table></figure></p><ol start="4"><li>当我们把数组转换成List的时候，为了不想循环遍历添加，可能会想到使用Arrays.asList(T t) 这个方法，这个方法生成的List是一个Arrays里面的一个内部类ArrayList。</li></ol><p><img src="/images/pasted-141.png" alt="upload successful"></p><p>看下这个内部类你会发现它没有对remove、add等方法的实现，也就是继承自AbstractList。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是执行它们时会抛出异常，如果想使用remove方法，应该把它转为具体实现，如ArrayList。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;T&gt; sourceList= <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(sourceArray));</span><br></pre></td></tr></table></figure><p>为什么它要使用内部类处理这个方法呢？也是比较有趣的，我这儿还没做深入研究，有时间研究下。</p><h2 id="2-使用两次循环实现。"><a href="#2-使用两次循环实现。" class="headerlink" title="(2)使用两次循环实现。"></a>(2)使用两次循环实现。</h2><p>原理是第一次数组循环查找符合条件（或不符合条件）的个数count，后面在创建一个指定长度（原数组总长度-count）的数组，然后在遍历循环一遍原数组，将符合条件（或不符合条件）的元素添加进新的数组。</p><p>优点：简单直接，易于理解，基本数据类型数组的处理应该比List方法有优势。</p><p>缺点：两次循环应该比较耗时，对于长Array应该显现的明显。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 过滤形成新的数组（两次循环查找符合条件的，移动过去）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceArray</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> predicate</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] getArray2(T[] sourceArray,Predicate&lt;T&gt; predicate,Class&lt;T&gt; type)&#123;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (T t:sourceArray)&#123;</span><br><span class="line">        <span class="keyword">if</span>(predicate.test(t))&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//都不符合条件</span></span><br><span class="line">    <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(sourceArray,sourceArray.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//都符合条件</span></span><br><span class="line">    <span class="keyword">if</span>(count==sourceArray.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> (T[]) Array.newInstance(type,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T [] targetArray=(T[]) Array.newInstance(type,sourceArray.length-count);</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (T t:sourceArray)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!predicate.test(t))&#123;</span><br><span class="line">           targetArray[index]=t;</span><br><span class="line">           index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> targetArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：还有一种情况，如果过滤的数据（符合条件或者不符合条件的）出现次数较低，我们是不是可以考虑一次拿出一整段进行处理。当然，如果频率较高，比如在一堆自然数中取偶数，明显奇数偶数出现频率相近，都为50%，那么我们可能用上面这种方法效率也很好。</p><h2 id="3-预先设置等长数组，而后截取得到目标数组"><a href="#3-预先设置等长数组，而后截取得到目标数组" class="headerlink" title="(3)预先设置等长数组，而后截取得到目标数组"></a>(3)预先设置等长数组，而后截取得到目标数组</h2><p>对比上一种方法，这是一种空间换时间的做法。</p><p>开始时创建一个和原数组相同大小的数组，遍历后把元素放进去，最后将数组截短。<br>这种方法仅仅循环一次。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对比第二种方法，这属于空间换时间的做法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceArray</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> predicate</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] getArray3(T[] sourceArray,Predicate&lt;T&gt; predicate,Class&lt;T&gt; type)&#123;</span><br><span class="line">    <span class="comment">//直接创建一个空的一样长的数组</span></span><br><span class="line">    T[] tempArray=(T[]) Array.newInstance(type,sourceArray.length);</span><br><span class="line">    <span class="comment">//不符合条件的数量</span></span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (T t:sourceArray)&#123;</span><br><span class="line">        <span class="comment">//拿到不符合过滤条件的，一个个赋值给新数组</span></span><br><span class="line">        <span class="keyword">if</span>(!predicate.test(t))&#123;</span><br><span class="line">            tempArray[count]=t;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后这个数组长度&lt;=原数组长度</span></span><br><span class="line">    <span class="comment">//特殊处理下</span></span><br><span class="line">    <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> (T[]) Array.newInstance(type,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(tempArray,count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-借助List的toArray方法"><a href="#4-借助List的toArray方法" class="headerlink" title="(4)借助List的toArray方法"></a>(4)借助List的toArray方法</h2><p>借助List实现循环一次把符合条件的放到里面，再把List强转成数组。也是不错的实现方法。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 借助list拿到符合条件的，在强转成数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceArray</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> predicate</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] getArray4(T[] sourceArray,Predicate&lt;T&gt; predicate,Class&lt;T&gt; type)&#123;</span><br><span class="line">    <span class="comment">//记录符合条件的元素下标</span></span><br><span class="line">    List&lt;T&gt; targetList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (T t:sourceArray)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!predicate.test(t))&#123;</span><br><span class="line">            targetList.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> targetList.toArray((T[]) Array.newInstance(type,<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论上面哪种方法，其底层都使用了System.arraycopy方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 数组复制核心方法</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> src 原数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> srcPos 原数组要复制的起始位置下标</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> dest 目标数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> destPos 目标数组的起始位置下标</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> length 要复制的长度</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos,Object dest, <span class="keyword">int</span> destPos,<span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="5-Java8串行处理方式"><a href="#5-Java8串行处理方式" class="headerlink" title="(5)Java8串行处理方式"></a>(5)Java8串行处理方式</h2><p>Java8中使用Stream操作集合工具类来对其进行处理。分为串行和并行两种方式。先来看看串行。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java8 串行流语法(收集符合条件的)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceArray</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> predicate</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] getArray5(T[] sourceArray,Predicate&lt;T&gt; predicate,Class&lt;T&gt; type)&#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(sourceArray).sequential().</span><br><span class="line">            filter(predicate).</span><br><span class="line">            collect(Collectors.toList()).</span><br><span class="line">            toArray((T[]) Array.newInstance(type,<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其底层也是元素的循环遍历。</p><h2 id="（6）Java8并行处理方式"><a href="#（6）Java8并行处理方式" class="headerlink" title="（6）Java8并行处理方式"></a>（6）Java8并行处理方式</h2><p>我们应该知道，无论方法怎样，至少应该遍历数组一次以判断该元素是否符合条件。当数据量较大时，这儿会成为方法运行时间的瓶颈，由于List家族中ArrayList是有序的，我们可以使用多线程对它进行分割，每段进行遍历筛选结果，最后再把结果合起来。</p><p>并行流就是利用分支/合并框架实现的，使用了多线程。当数组数据量较大时效率是明显的。</p><p>Java8的相关API已经封装好，我们可以直接使用。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java8 并行流语法(收集符合条件的)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceArray</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> predicate</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] getArray6(T[] sourceArray,Predicate&lt;T&gt; predicate,Class&lt;T&gt; type)&#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(sourceArray).parallel().</span><br><span class="line">            filter(predicate).</span><br><span class="line">            collect(Collectors.toList()).</span><br><span class="line">            toArray((T[]) Array.newInstance(type,<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-自己动手，丰衣足食"><a href="#7-自己动手，丰衣足食" class="headerlink" title="(7)自己动手，丰衣足食"></a>(7)自己动手，丰衣足食</h2><p>我们其实是可以借助多线程自己实现一个相似工具类的。</p><p>可以使用分支/合并框架自己实现一个多线程的处理。</p><p>关于这一块，我有一篇文章 <a href="https://www.sakuratears.top/blog/%E4%B8%80%E9%81%93Java%E8%AF%95%E9%A2%98%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%8320181013/">一道Java试题引发的思考</a><br>中有具体例子及测试。</p><p>大家可以看下，数据量大的情况下并行效率还是比较明显的。</p><p>我这儿对这个例子就不在验证了。</p><p><strong>注意</strong>：使用并行流（或者说多线程）要注意的点。</p><p>首先是数据量，数据量的主要意义就在于单线程处理的耗时（处理数据的时间）已经超过了多线程耗时（数据处理时间+拆分数据时间+合并结果时间），这一点是比较难把控的。其次一点是要确定这些数据可以使用多线程处理，不会产生意外的情况，比如我们这个问题，我想删除两个数相差1的所有元素，剩下的元素生成一个新的数组，多线程显然不易解决这种问题，或者解决起来较复杂。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>测试的话今天就省了，（3）、（4）、（5）都是不错的写法，（6）话具体问题具体分析，（7）的话有想法的可以试试，（1），（2）不推荐。</p><p>因为数据量大小，数据类型都对方法有些影响。</p><p>比如较短的原数组，基本数据类型，（3）方法效率很快的，对比（4）、（5）是没有数据拆箱操作的。换成长数组，引用数据类型，（6）可能效率就高了。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>开始写这篇文章的时候脑子不好使，根本没想到Java8的Stream，失误。我甚至一开始想的都是些可能不安全（（1）方法），或者比较繁琐（（2）方法）的方法，过了一天晾了晾脑子就好使多了。</p><p>在处理时，因为数组底层操作都是基于System.arraycopy嘛，我想到是不是循环一次记录符合条件（不符合条件）的元素下标（可用List记录），然后建立一个目标数组，使用System.arraycopy一段一段的将数据copy进去。</p><p>无奈才疏学浅，想了半天使用System.arraycopy时的两个起始位置，copy长度始终弄错了，仔细想了下，估计这种方法效率也不怎么高。</p><p>哈哈，于是就没写。</p><p>大家有什么好的、耳目一新的方法也可以说出来交流交流。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前两天下班和一朋友一起，被问到如下问题：&lt;strong&gt;如何移除一个数组中某些符合条件（或不符合条件）的元素形成新的数组，要求数组长度也应该
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ简介</title>
    <link href="https://www.sakuratears.top/blog/RocketMQ%E7%AE%80%E4%BB%8B20181103/"/>
    <id>https://www.sakuratears.top/blog/RocketMQ简介20181103/</id>
    <published>2018-11-03T14:16:00.000Z</published>
    <updated>2018-11-07T15:05:02.894Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>为什么要学习RocketMQ？</p></blockquote><p>RocketMQ是一个队列模型的的消息中间件，具有高性能、高可靠、高实时、分布式等特点。</p><p>其主要特点如下：</p><ol><li>生产者、消费者、队列都可以分布式。</li><li>能够保证严格的消息顺序。</li><li>提供丰富的消息拉取模式。</li><li>高效的订阅者水平扩展能力。</li><li>实时的消息订阅机制。</li><li>亿级消息堆积能力。</li><li>较少的依赖。</li></ol><p>RocketMQ的基本原理就是生产者（Producer）向一些队列轮流发送消息，队列集合称为Topic，消费者（Consumer）如果做广播消费，则一个消费者实例消费这个Topic对应的所有队列，如果做集群消费，则多个消费者实例平均消费这个topic对应的队列集合。</p><p>消息中间件收发消息的典型模型如下图：</p><p><img src="/images/pasted-137.png" alt="upload successful"></p><p>好吧，我承认前言太官方了。我们来看下正文关于RocketMQ的一些特点吧。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="RocketMQ术语。"><a href="#RocketMQ术语。" class="headerlink" title="RocketMQ术语。"></a>RocketMQ术语。</h2><p>先介绍RocketMQ的几个术语。</p><ol><li><p>Producer</p><p> 消息生产者，生产者的作用就是将消息发送到Broker（MQ），生产者本身既可以产生消息。也可以对外提供接口，由外部应用来调用接口，再由生产者将收到的消息发送到 Broker（MQ）。</p></li><li><p>Producer Group</p><p> 生产者组，一般来说多个发送同一类消息的生产者称之为一个生产者组。</p></li><li><p>Consumer</p><p> 消息消费者，消费 Broker（MQ） 上的消息的应用程序就是消费者，消息的处理取决于业务。</p></li><li><p>Consumer Group</p><p> 消费者组，和生产者类似，消费同一类消息的多个 consumer 实例组成一个消费者组。</p></li><li><p>Topic</p><p> Topic 是一种消息的逻辑分类，比如说你有支付订单类的消息，也有奖品抽取类的消息，那么就需要进行分类，一个是支付订单 Topic 存放支付订单相关的消息，一个是奖品抽取 Topic 存储抽取奖品结果相关的消息。</p></li><li><p>Message</p><p> Message 是消息的载体。一个 Message 必须指定 topic。Message 还有一个可选的 tag 设置，以便消费者可以基于 tag 进行过滤消息。也可以添加额外的键值对等。</p></li><li><p>Tag</p><p> 标签可以被认为是对 Topic 进一步细化。一般在相同业务模块中通过引入标签来标记不同用途的消息。</p></li><li><p>Broker</p><p> Broker 是 RocketMQ系统的主要角色。Broker 接收来自生产者的消息，储存以及为消费者拉取消息的请求做好准备。</p></li><li><p>Name Server</p><p> Name Server 为 producer 和 consumer 提供路由信息。</p></li></ol><p>对于上面的几个概念的理解，可以从一封邮件的发送入手，认为发信人是Producer，收信人为Consumer，Message，Topic和Tag分别指信的内容，信的分类规则等，Broker就相当于邮局了。</p><h2 id="RocketMQ集群架构"><a href="#RocketMQ集群架构" class="headerlink" title="RocketMQ集群架构"></a>RocketMQ集群架构</h2><p>再来看一下RocketMQ常用的物理部署结构。（生产环境常用的RocketMQ集群架构）</p><p><img src="/images/pasted-138.png" alt="upload successful"></p><p><img src="/images/pasted-139.png" alt="upload successful"></p><p>RocketMQ的集群特点如下：</p><ol><li><p>Name Server是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。</p></li><li><p>Broker部署相对复杂，Broker分为Master与Slave，一个Master可以对应多个Slave，但是一个Slave只能对应一个Master，Master与Slave的对应关系通过指定相同的BrokerName，不同的BrokerId来定义，BrokerId为0表示Master，非0表示Slave。Master也可以部署多个。每个Broker与Name Server集群中的所有节点建立长连接，定时注册Topic信息到所有Name Server。</p></li><li><p>Producer与Name Server集群中的其中一个节点（随机选择）建立长连接，定期从Name Server取Topic路由信息，并向提供Topic服务的Master建立长连接，且定时向Master发送心跳。Producer完全无状态，可集群部署。要注意Producer并不能和 Broker Slave建立连接。</p></li><li><p>Consumer与Name Server集群中的其中一个节点（随机选择）建立长连接，定期从Name Server取Topic路由信息，并向提供Topic服务的Master、Slave建立长连接，且定时向Master、Slave发送心跳。Consumer既可以从Master订阅消息，也可以从Slave订阅消息，订阅规则由Broker配置决定。</p></li><li><p>Broker Master和 Broker Slave之间会进行数据同步，即Data Sync。</p></li></ol><p><strong>数据复制主要有两种</strong>：</p><p>①<strong>同步复制 SYNC_MASTER</strong></p><pre><code>master 和 slave 都写成功后返回成功状态。好处是如果master出故障，slave上有全部备份，容易恢复。缺点是增大延迟，降低吞吐量。</code></pre><p>②<strong>异步复制 ASYNC_MASTER</strong></p><pre><code>只要 master 写成功就返回成功状态。好处是低延迟、高吞吐，缺点是如果 master 出故障，数据没有写入 slave，就会有丢失。</code></pre><p>master或者 slave在返回处理成功消息时，需要将数据持久化（写入磁盘）。称之为MQ的刷盘。</p><p><strong>刷盘策略也有两种</strong>：</p><p>①<strong>同步刷盘 SYNC_FLUSH</strong></p><pre><code>返回成功状态时，消息已经被写入磁盘。消息写入内存后，立即通知刷盘线程，刷盘完成后，返回消息写成功的状态。</code></pre><p>②<strong>异步刷盘 ASYNC_FLUSH</strong></p><pre><code>返回成功状态时，消息只是被写入内存，写操作返回快，吞吐量达，当内存里的消息积累到一定程度时，统一出发写磁盘动作，快速写入。</code></pre><h2 id="RocketMQ部署模式"><a href="#RocketMQ部署模式" class="headerlink" title="RocketMQ部署模式"></a>RocketMQ部署模式</h2><p>根据上面的描述，我们也大致可以知道RocketMQ通常有3种部署模式。</p><ol><li><p><strong>单master部署</strong></p><p> 简单来说就是环境上就一台RocketMQ，一般自己开发研究学习会用这种模式。这种部署明显的缺点就是MQ宕机后系统就会挂掉。所以不用于测试或生产环境。</p></li><li><p><strong>多master部署</strong></p><p> 就是环境上有多台RocketMQ，都充当master的角色。这种方式部署，如果有一台MQ挂掉或者重启，并不会对整个应用系统造成影响。但是该节点MQ宕机期间，未消费的MQ消息是无法被消费的，只有等该节点故障排除后才能恢复正常。如果无法恢复，则会造成RocketMQ消息的永久丢失。</p><p> 这种方式，如果是使用的异步刷盘，则故障发生并恢复正常后可能丢失部分消息（写入内存没来得及写入磁盘的消息）；如果同步刷盘，则不会出现此情况，但同步刷盘会对MQ的响应速度造成一些影响。</p></li><li><p><strong>多master 多slave部署</strong></p><p> 根据刷盘策略和数据复制策略。我们知道这种部署方式基本有四种组合策略。同步复制同步刷盘明显是效率最差但最安全的，异步复制异步刷盘明显是效率最好但最不安全的。</p><p> 一般情况下，我们比较常用的是<strong>异步刷盘+同步复制</strong>的模式。这样即使master 宕机，同步复制的slave也能保证把消息写入磁盘。同时使用异步刷盘策略，因为写入磁盘本身是应用系统中耗时的一个操作，先写入内存，随后写入磁盘，可以保证MQ的响应速度。</p></li></ol><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>这一篇文章简单介绍了RocketMQ的一些性质和特点，了解这些特点，才能更好的掌握RocketMQ，后面我们会搭建一个RocketMQ服务进行下学习，并对我们的调用代码做些优化，封装为自己的一个小小工具类。</p><p>回答下最开始的问题，因为我们公司用到了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;为什么要学习RocketMQ？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;RocketMQ是一个队列模型的的消息中
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring Transaction 注解不生效bug引发的思考</title>
    <link href="https://www.sakuratears.top/blog/%E4%B8%80%E4%B8%AASpring-Transaction-%E6%B3%A8%E8%A7%A3%E4%B8%8D%E7%94%9F%E6%95%88bug%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%8320181103/"/>
    <id>https://www.sakuratears.top/blog/一个Spring-Transaction-注解不生效bug引发的思考20181103/</id>
    <published>2018-11-03T02:32:00.000Z</published>
    <updated>2018-11-03T03:37:39.946Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>某日，在项目测试代码过程中，发现一个问题，<strong>对于一个方法A（无事务），调用B方法（有事务），当A，B方法在同一个类中的时候，在B方法上的事务注解是不生效的！</strong></p><p>同事说将B方法写到新的Service类中就可以解决，遂试之，确实得以解决。但不解其原理，问同事、查资料均感觉不如意。故分析了下Spring 事务的部分源码。有所见解，特此记录。</p><p>下图就是我描述的这种情况，B事务不生效的问题。</p><p>1.测试类</p><p><img src="/images/pasted-93.png" alt="upload successful"></p><p>2.实现类</p><p><img src="/images/pasted-94.png" alt="upload successful"></p><p>我们经过测试可以发现，当insert方法有事务、但被该实现类内部方法doInsert调用后，即使insert方法出现异常，该方法的数据库操作也不会回滚。</p><p>3.数据没有回滚，已经入库</p><p><img src="/images/pasted-95.png" alt="upload successful"></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>要理解研究这种情况，我们先来简单说下Spring 的注解方式的事务实现机制。</p><blockquote><p>事务的一些基础我在一篇文章中有介绍 <a href="https://www.sakuratears.top/blog/Spring-Transactional%E6%B3%A8%E8%A7%A320181013/">https://www.sakuratears.top/blog/Spring-Transactional%E6%B3%A8%E8%A7%A320181013/</a>  不懂得可以先大致看看。</p></blockquote><h2 id="Spring注解方式的事务实现机制"><a href="#Spring注解方式的事务实现机制" class="headerlink" title="Spring注解方式的事务实现机制"></a>Spring注解方式的事务实现机制</h2><p>在应用系统调用声明@Transactional 的目标方法时，Spring Framework 默认使用 AOP 代理，在代码运行时生成一个代理对象，根据@Transactional 的属性配置信息，这个代理对象决定该声明@Transactional 的目标方法是否由拦截器 TransactionInterceptor 来使用拦截，在 TransactionInterceptor 拦截时，会在在目标方法开始执行之前创建并加入事务，并执行目标方法的逻辑, 最后根据执行情况是否出现异常，利用抽象事务管理器AbstractPlatformTransactionManager 操作数据源 DataSource 提交或回滚事务, 如图。</p><p><img src="/images/pasted-96.png" alt="upload successful"></p><p>Spring AOP 代理有 CglibAopProxy 和 JdkDynamicAopProxy 两种，上图以 CglibAopProxy 为例，对于 CglibAopProxy，需要调用其内部类的 DynamicAdvisedInterceptor 的 intercept 方法。对于 JdkDynamicAopProxy，需要调用其 invoke 方法。当然我们也可以使用AspectJ的方式实现AOP代理，这儿不做过多介绍。</p><p>事务管理的框架是由抽象事务管理器 AbstractPlatformTransactionManager 来提供的，而具体的底层事务处理实现，由 PlatformTransactionManager 的具体实现类来实现，如事务管理器 DataSourceTransactionManager。不同的事务管理器管理不同的数据资源 DataSource，比如 DataSourceTransactionManager 管理 JDBC 的 Connection。</p><p>PlatformTransactionManager，AbstractPlatformTransactionManager 及具体实现类关系图如下。</p><p><img src="/images/pasted-97.png" alt="upload successful"></p><h2 id="一次正常事务调试"><a href="#一次正常事务调试" class="headerlink" title="一次正常事务调试"></a>一次正常事务调试</h2><p>出现问题，debug是比较好的解决方法。我们大致跟下SpringTransaction的使用过程。先从正确流程入手吧。<br>如下：直接将事务注解加在doInsert方法上，明显，这种情况下出现异常事务会回滚。我们debug下事务大致的回滚过程。</p><p><img src="/images/pasted-98.png" alt="upload successful"></p><p>DefaultAopProxyFactory里的createAopProxy方法可以拿到看到该方法具体使用的哪种代理。</p><p><img src="/images/pasted-99.png" alt="upload successful"></p><p>可以看到我们这个类使用了Cglib代理。<br>使用了Cglib代理，上面讲到 对于 CglibAopProxy，需要调用其内部类的 DynamicAdvisedInterceptor 的 intercept 方法。我们继续断点跟踪下。</p><p><img src="/images/pasted-100.png" alt="upload successful"></p><p>一步步进行，如事务图所示，进入了TransactionInterceptor的invoke方法，并执行invokeWithinTransaction方法。</p><p><img src="/images/pasted-101.png" alt="upload successful"></p><p>继续跟踪。来到了<strong>TransactionAspectSupport</strong>，这是spring事务处理的关键类，谨记。</p><p><img src="/images/pasted-102.png" alt="upload successful"></p><p><img src="/images/pasted-103.png" alt="upload successful"></p><p>会进行事务的创建，createTransactionIfNecessary  getTransaction方法会开启一个事务。</p><p><img src="/images/pasted-104.png" alt="upload successful"></p><p>根据上面debug看到的事务管理器是DataSourceTransactionManager， 执行getTransaction会调用它的doBeigin方法。</p><p><img src="/images/pasted-105.png" alt="upload successful"></p><p><img src="/images/pasted-106.png" alt="upload successful"></p><p>可以看到把自动提交设置成了false，并且暂时保存了原来的自动提交属性状态。</p><p><img src="/images/pasted-107.png" alt="upload successful"></p><p>而后可以看到他将当前事务信息绑定在了ThreadLocal里了。</p><p><img src="/images/pasted-108.png" alt="upload successful"></p><p>执行我们添加事务注解的方法，抛出了异常被捕获。</p><p><img src="/images/pasted-109.png" alt="upload successful"></p><p>执行completeTransactionAfterThrowing方法，我们的异常正好是这个异常（或者其父类）。</p><p><img src="/images/pasted-110.png" alt="upload successful"></p><p>然后执行回滚操作，最终到达下图所示方法（DataSourceTransactionManager的doRollback）</p><p><img src="/images/pasted-111.png" alt="upload successful"></p><p>回滚具体代码不在介绍，我们可以看到在回滚时它把原来数据库的自动提交属性改了过来。</p><p><img src="/images/pasted-112.png" alt="upload successful"></p><p>最后他会把本次事务状态清除，相当于保存上一次的事务状态。</p><p><img src="/images/pasted-113.png" alt="upload successful"></p><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><ol><li><p><strong>在spring启动时获取事务注解时我们可以看到下图</strong>。</p><p> <img src="/images/pasted-114.png" alt="upload successful"></p><p> <strong>这个说明Spring AOP 事务注解只能作用于public 方法。</strong></p></li><li><p><strong>关于事务回滚rollbackFor条件的问题，我们可以看到下图</strong>。</p><p> <img src="/images/pasted-115.png" alt="upload successful"></p><p> 当我们事务注解配置具体的回滚条件，如rollbackFor = Exception.class，只要是Exception.class或者其子类，都可以实现事务回滚。它会通过RuleBasedTransactionAttribute.class这个类去校验抛出的异常是否符合条件。进而判断是否需要回滚。</p><p> 但是当我们不声明rollbackFor 条件时，这儿应该注意一点。它会使用默认的条件，而不是不处理异常。主要由DefaultTransactionAttribute.class 里的rollbackOn方法实现。我们看下这个方法，可以发现，他只会处理RuntimeException和Error。也就是说，如果我们一个方法有事务，但抛出了非RuntimeException（如检查时异常等），且事务没有声明rollbackFor回滚条件，那么，它是不会触发事务回滚的。这一点要注意。</p><p> <img src="/images/pasted-116.png" alt="upload successful"></p><p> 上图调用RuleBasedTransactionAttribute.class的方法，回滚规则为空，使用父类rollbackOn方法。</p><p> <img src="/images/pasted-117.png" alt="upload successful"></p><p> <img src="/images/pasted-118.png" alt="upload successful"></p><p> 通过调试可以轻松看到这一情况，这儿不在做过多赘述。</p></li></ol><h2 id="异常事务调试"><a href="#异常事务调试" class="headerlink" title="异常事务调试"></a>异常事务调试</h2><p>我们来看下事务不成功的情况。就是题目开始的问题。</p><p>Spring刚启动时，会扫描需要进行代理的类，生成代理对象，在AdvisedSupport.class类中，把类中的方法缓存起来。</p><p><img src="/images/pasted-119.png" alt="upload successful"></p><p>首先查询该方法是不是需要拦截（是不是有事务注解）</p><p><img src="/images/pasted-120.png" alt="upload successful"></p><p><img src="/images/pasted-121.png" alt="upload successful"></p><p>在TransactionAttributeSourcePointcut.class 类里的matches方法，查询事务注解情况。</p><p><img src="/images/pasted-122.png" alt="upload successful"></p><p>查到了就缓存起来了。</p><p>当doInset方法进入时，同样的逻辑。也会缓存起来，但是cached是值为null。</p><p><img src="/images/pasted-123.png" alt="upload successful"></p><p><img src="/images/pasted-124.png" alt="upload successful"></p><p>该类的其他方法也会被缓存，没有事务注解的都放为null。</p><p>开始执行doInsert方法时，进入CglibAopProxy的intercept方法。</p><p><img src="/images/pasted-125.png" alt="upload successful"></p><p>可以看到尝试拿缓存，但缓存的值为空。</p><p><img src="/images/pasted-126.png" alt="upload successful"></p><p>尝试获取一下，显然也是没有值的。所以这时候认为不需要进行事务。事务链为空。</p><p><img src="/images/pasted-127.png" alt="upload successful"></p><p>就直接执行了方法doInsert。并不会开启事务。（不为空的话会创建一个CglibMethodInvocation并开启事务执行方法，如上面开始的情况）。</p><p><strong>当生成一个动态代理对象后，对这个对象引用中方法的调用就是对代理的调用，而这个代理能够代理所有跟特定方法调用相关的拦截器。不过，一旦调用最终抵达了目标对象 （此处为TransactionalTestImpl类的引用），任何对自身的调用例如insert将对this引用进行调用而非代理。这一点意义重大， 它意味着自我调用将不会导致和方法调用关联的通知得到执行的机会。</strong></p><p>如果需要insert的事务生效，一种典型的方法就将方法insert放到新的类中，这便很好理解了。因为新的类会生成新的动态代理对象，调用源从而获得通知。</p><p><strong>如果我非要在本类中实现通知呢？</strong></p><p>那我们就需要直接获取代理对象调用insert方法了。如下图。</p><p><img src="/images/pasted-128.png" alt="upload successful"></p><p>要实现这个功能，需要开启Spring AspectJ支持，我使用的Springboot，启动类上加入如下注解，并引入如下依赖。</p><p><img src="/images/pasted-129.png" alt="upload successful"></p><p><img src="/images/pasted-130.png" alt="upload successful"></p><p>这个pom文件你进去可以看到就是引用了AspectJ 的相关jar包。</p><p><img src="/images/pasted-131.png" alt="upload successful"></p><p>这个时候我们在测试一下，就会发现事务生效了。</p><p>在CglibAopProxy中可以看到如下代码，可以明白开启后它把代理对象绑定到ThreadLocal上等待insert方法执行的通知。</p><p><img src="/images/pasted-132.png" alt="upload successful"></p><p><img src="/images/pasted-133.png" alt="upload successful"></p><p><img src="/images/pasted-134.png" alt="upload successful"></p><p>当然，如果这两个方法上都存在事务，它也会进行判断处理，也就是事务的传播属性，他们主要通过<strong>AbstractPlatformTransactionManager</strong>这个类（这个类也很重要）的getTransaction方法和handleExistingTransaction方法来进行事务传播属性的处理。这儿不做过多讲解，自己看看逻辑处理即可。</p><p>getTransaction部分代码：</p><p><img src="/images/pasted-135.png" alt="upload successful"></p><p>handleExistingTransaction部分代码：</p><p><img src="/images/pasted-136.png" alt="upload successful"></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>总的来说，通过一个问题，我们大致看了下Spring Transactional注解的实现过程。并分析了产生这种问题的原因，通过有效的手段来进行验证。还是蛮不错的一次体验。</p><p>下面总结下：</p><p>A：<strong>在Spring中，一个类中无事务注解的方法A调用有事务注解的方法B，默认情况下B出现异常事务是不会进行回滚的</strong>。</p><p>解决方法：</p><ol><li><p><strong>将B写到一个新的方法中</strong>。（原理上是生成不同类的动态代理对象，实际中比较常用的一种手段，但需要管理一个新的类）</p></li><li><p><strong>如果业务（情形等）允许，可以将事务移动到A上，或者B的事务不动，给A也加一个事务</strong>。（根据具体情况讨论，有时候效果很好，有时候不适宜，使用此种方法可能影响程序效率或者产生莫名其妙的bug，慎用）</p></li><li><p><strong>启用增强型事务，引入AspectJ</strong>。（不太常用的一种手段，但如果项目中本来已经引入了AspectJ并且开启了增强型事务管理，何乐而不为呢？）</p></li></ol><p>B：<strong>研究过程中发现的其他应该注意的坑</strong>。</p><ol><li><p><strong>事务注解应当作用在public方法上，需要注意</strong>。</p></li><li><p><strong>如果不设置事务回滚条件（rollbackFor参数为空），它能捕获RuntimeException及其子类 和 Error及其子类 出现的异常情况并回滚，其他异常是无法捕获并回滚的。如IOException（检查型异常）等</strong>。</p></li><li><p><strong>事务的传播属性的几个应该了解，不能乱用，虽然我们可能就用到过或者就用到了Propagation.REQUIRED ，但不代表其它不会用到</strong>。</p></li></ol><p>C：<strong>本次研究学习我们应该理解掌握的</strong>。</p><ol><li><p>Spring事务的处理过程。（Spring AOP的体现，应用反射和动态代理）</p></li><li><p>事务的一些性质。（事务的传播属性、事务的四大特性等）</p></li><li><p>其它一些需要学习的地方。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;某日，在项目测试代码过程中，发现一个问题，&lt;strong&gt;对于一个方法A（无事务），调用B方法（有事务），当A，B方法在同一个类中的时候，在
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="Spring" scheme="https://www.sakuratears.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>如何以并发方式在同一个流上执行多种操作</title>
    <link href="https://www.sakuratears.top/blog/%E5%A6%82%E4%BD%95%E4%BB%A5%E5%B9%B6%E5%8F%91%E6%96%B9%E5%BC%8F%E5%9C%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E6%B5%81%E4%B8%8A%E6%89%A7%E8%A1%8C%E5%A4%9A%E7%A7%8D%E6%93%8D%E4%BD%9C20181027/"/>
    <id>https://www.sakuratears.top/blog/如何以并发方式在同一个流上执行多种操作20181027/</id>
    <published>2018-10-27T09:41:00.000Z</published>
    <updated>2018-10-27T10:04:32.184Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java 8中，流有一个非常大的局限性，使用时，对它操作一次仅能得到一个处理结果。当流进行终端操作后，如果你在试图遍历它，就会出现异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalStateException: stream has already been operated upon or closed</span><br></pre></td></tr></table></figure><p>虽然流就是如此设计的，但是我们有时候就希望可以通过流获取多个结果。或者说，你希望一次性向流中传入多个Lambda表达式。 为了达到这一目标，我们应该需要一个fork类型的方法，对每个复制的流应用不同的函数。理想情况下，这些操作也应该支持并行去拿到运算结果。</p><p>这一特性在Java 8中是没有的，不过我们可以利用一个通用API，即Spliterator，尤其是它的延迟绑定能力，结合BlockingQueues和Futures来实现这一特性。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="复制流"><a href="#复制流" class="headerlink" title="复制流"></a>复制流</h2><p>要达到此效果，我们首先应该创建一个StreamForker，它会对原始的流进行封装，在此基础上在执行各种操作。我们来看下代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamForker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Stream&lt;T&gt; stream;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, Function&lt;Stream&lt;T&gt;,?&gt;&gt; forks=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StreamForker</span><span class="params">(Stream&lt;T&gt; stream)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.stream = stream;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> StreamForker&lt;T&gt; <span class="title">fork</span><span class="params">(Object key,Function&lt;Stream&lt;T&gt;,?&gt; f)</span></span>&#123;</span><br><span class="line"><span class="comment">//使用一个键对流上的函数进行索引</span></span><br><span class="line">forks.put(key,f);</span><br><span class="line"><span class="comment">//返回this从而保证多次顺畅的调用fork方法</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Results <span class="title">getResults</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//TODO</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>fork</strong>方法接受两个参数。</p><p><strong>Function:</strong>对流进行处理，转变成这些操作结果的类型。</p><p><strong>key:</strong> 通过它拿到结果，这些结果被放到内部的一个Map中。</p><p>fork方法需要返回自身，这样可以复制多个操作构成流水线。</p><p>如图：</p><p><img src="/images/pasted-91.png" alt="upload successful"></p><p>上图不难理解。</p><p>而由fork方法添加的操作如何执行呢，就是通过getResults方法的调用触发，该方法返回一个Results接口的实现。接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Results</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">R <span class="title">get</span><span class="params">(Object key)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现Results接口"><a href="#实现Results接口" class="headerlink" title="实现Results接口"></a>实现Results接口</h2><p>我们使用ForkingStreamConsumer实现Results接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Results <span class="title">getResults</span><span class="params">()</span></span>&#123;</span><br><span class="line">ForkingStreamConsumer&lt;T&gt; consumer=build();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">stream.sequential().forEach(consumer);</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">consumer.finish();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> consumer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ForkingStreamConsumer同时实现了Results和Consumer接口。其主要任务就是来处理流元素，将他们分发到多个BlockingQuenes中处理，BlockingQuenes的数量和通过fork方法提交的操作数是一致的。这里的getResults的实现，流应该是顺序处理的，否则，forEach后元素的顺序就会变化。finish方法用来表明队列中没有更多要处理的元素了。build方法主要用于创建ForkingStreamConsumer。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ForkingStreamConsumer&lt;T&gt; <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//创建由队列组成的列表，每一个队列对应一个操作</span></span><br><span class="line">List&lt;BlockingQueue&lt;T&gt;&gt; queues=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//建立用于标识操作的键与包含操作结果的Future之间的映射关系</span></span><br><span class="line">Map&lt;Object,Future&lt;?&gt;&gt; actions=   </span><br><span class="line">forks.entrySet().stream().reduce(</span><br><span class="line"><span class="keyword">new</span> HashMap&lt;Object,Future&lt;?&gt;&gt;(),</span><br><span class="line">(map,e)-&gt;&#123;</span><br><span class="line">map.put(e.getKey(),getOperationResult(queues,e.getValue()));</span><br><span class="line"><span class="keyword">return</span> map;</span><br><span class="line">&#125;,</span><br><span class="line">(m1,m2)-&gt;&#123;</span><br><span class="line">m1.putAll(m2);</span><br><span class="line"><span class="keyword">return</span> m1;</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ForkingStreamConsumer&lt;&gt;(queues,actions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们先创建了BlockingQuenes列表。接着创建了一个Map，Map的键就是用来标识不同操作的键，值包含着Future里。最终BlockingQuenes和Map会被传递给ForkingStreamConsumer的构造函数。每个Future通过关键方法getOperationResult创建。</p><p>来看看getOperationResult的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Future&lt;?&gt; getOperationResult(List&lt;BlockingQueue&lt;T&gt;&gt; queues,Function&lt;Stream&lt;T&gt;,?&gt; f)&#123;</span><br><span class="line"><span class="comment">//创建一个队列，并将其添加到队列的列表中</span></span><br><span class="line">BlockingQueue&lt;T&gt; queue=<span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;();</span><br><span class="line">queues.add(queue);</span><br><span class="line"><span class="comment">//创建一个Spliterator，遍历队列中的元素</span></span><br><span class="line">Spliterator&lt;T&gt; spliterator=<span class="keyword">new</span> BlockingQueueSpliterator&lt;&gt;(queue);</span><br><span class="line"><span class="comment">//创建一个流，将Spliterator作为数据源</span></span><br><span class="line">Stream&lt;T&gt; source= StreamSupport.stream(spliterator,<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//创建一个Future对象，以异步方式计算在流上执行特定函数的结果</span></span><br><span class="line"><span class="keyword">return</span> CompletableFuture.supplyAsync(()-&gt;f.apply(source));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法创建一个新的BlockingQuene，并将其添加到队列列表。队列会被传递给一个新的BlockingQueueSpliterator对象，后者是一个延迟绑定的Spliterator。然后我们创建一个顺序流对Spliterator进行遍历，最终创建一个Future收集结果。</p><h2 id="开发ForkingStreamConsumer"><a href="#开发ForkingStreamConsumer" class="headerlink" title="开发ForkingStreamConsumer"></a>开发ForkingStreamConsumer</h2><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkingStreamConsumer</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt;,<span class="title">Results</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object END_OF_STREAM=<span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;BlockingQueue&lt;T&gt;&gt; queues;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, Future&lt;?&gt;&gt; actions;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ForkingStreamConsumer</span><span class="params">(List&lt;BlockingQueue&lt;T&gt;&gt; queues, Map&lt;Object, Future&lt;?&gt;&gt; actions)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.queues = queues;</span><br><span class="line"><span class="keyword">this</span>.actions = actions;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">R <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ((Future&lt;R&gt;)actions.get(key)).get();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line"><span class="comment">//将流中遍历的元素添加到所有的队列中</span></span><br><span class="line">queues.forEach(q-&gt;q.add(t));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//将最后一个元素添加到队列中，表明该流已经结束</span></span><br><span class="line">accept((T)END_OF_STREAM);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类同时实现了Consumer接口和Results接口。</p><p>Consumer接口要求实现accept方法，每当ForkingStreamConsumer接受流中的一个元素，它就会将元素添加到所有BlockingQuenes中当所有元素都添加到所有队列后，finish方法将最后一个元素添加到所有队列。处理时碰上这个元素表明后面没有元素要处理了。</p><p>Results接口需要实现get方法。一旦处理结束，get方法会获取Map中由键索引的Future，解析到结果后返回。</p><p>每有一个操作，就会对应一个BlockingQueueSpliterator。我们来看下BlockingQueueSpliterator的实现。</p><h2 id="开发BlockingQueueSpliterator"><a href="#开发BlockingQueueSpliterator" class="headerlink" title="开发BlockingQueueSpliterator"></a>开发BlockingQueueSpliterator</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueSpliterator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Spliterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;T&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BlockingQueueSpliterator</span><span class="params">(BlockingQueue&lt;T&gt; q)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.q = q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">T t;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">t=q.take();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t!=ForkingStreamConsumer.END_OF_STREAM)&#123;</span><br><span class="line">action.accept(t);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Spliterator&lt;T&gt; <span class="title">trySplit</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">estimateSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到该Spliterator未定义任何切割流的策略，仅仅利用了流的延迟绑定能力。也没有实现trySplit方法。由于我们的操作数是不确定的，故estimateSize不能提供任何有意义的数字，返回0.也没有体现Spliterator的特性，故characteristics返回0.</p><p>仅仅实现了tryAdvance方法，它从BlockingQueue中取得原始流元素，进一步传给Consumer对象。当返回true时表明还有元素要处理，直到发现最后一个元素时终止。</p><p>以上基本上是在一个流上执行多种操作的代码。</p><p>我们下面来检测一下正确性。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>编写测试类。如下数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//生成1到1000的数组</span></span><br><span class="line">List&lt;Integer&gt; list1=IntStream.rangeClosed(<span class="number">1</span>,<span class="number">1000</span>).filter(n-&gt;n%<span class="number">2</span>==<span class="number">0</span>).boxed().collect(Collectors.toList());</span><br><span class="line">List&lt;Integer&gt; list2=IntStream.rangeClosed(<span class="number">1</span>,<span class="number">1000</span>).filter(n-&gt;n%<span class="number">5</span>==<span class="number">0</span>).boxed().collect(Collectors.toList());</span><br><span class="line"><span class="comment">//同时对list1数据求和，统计list1数据数量，统计list1和list2相同元素，统计list1和list2相同元素的最大值和最小值</span></span><br><span class="line">Results results=<span class="keyword">new</span> StreamForker&lt;Integer&gt;(list1.stream())</span><br><span class="line">.fork(<span class="string">"sum"</span>,s-&gt;s.mapToInt(Integer::intValue).sum())</span><br><span class="line">.fork(<span class="string">"count"</span>,s-&gt;s.count())</span><br><span class="line">.fork(<span class="string">"list3"</span>,s-&gt;s.flatMap(i-&gt;list2.stream().filter(j-&gt;i.equals(j))).collect(Collectors.toList()))</span><br><span class="line">.fork(<span class="string">"max"</span>,s-&gt;s.flatMap(i-&gt;list2.stream().filter(j-&gt;i.equals(j))).max(Comparator.naturalOrder()))</span><br><span class="line">.fork(<span class="string">"min"</span>,s-&gt;s.flatMap(i-&gt;list2.stream().filter(j-&gt;i.equals(j))).min(Comparator.naturalOrder()))</span><br><span class="line">.getResults();</span><br><span class="line">System.out.println(<span class="string">"sum="</span>+results.get(<span class="string">"sum"</span>));</span><br><span class="line">System.out.println(<span class="string">"count="</span>+results.get(<span class="string">"count"</span>));</span><br><span class="line">System.out.println(<span class="string">"max="</span>+((Optional) results.get(<span class="string">"max"</span>)).get());</span><br><span class="line">System.out.println(<span class="string">"min="</span>+((Optional)results.get(<span class="string">"min"</span>)).get());</span><br><span class="line">    ((List&lt;Integer&gt;)results.get(<span class="string">"list3"</span>)).stream().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="/images/pasted-92.png" alt="upload successful"></p><p>可以看到，使用了一个流，通过我们实现的方法进行了多次终端操作返回正确结果。</p><h1 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h1><p>这是我们用一个流实现多种终端操作的方式，当然这并不意味着会比普通的写法效率高，如果对于上述问题，我们可以分个构建若干个流进行一一实现。</p><p>这种一个流进行多个终端操作的情况使用，一定是生成流比较耗费资源性能时才会用到，比如操作一个较大文件时生成的字符流，我们想统计字数，检查某些单词出现的次数，统计行数等等操作，重复生成流显然是耗费资源的。这种情况可以考虑使用这种一个流进行多个终端操作的实现。</p><p>当然，具体到具体问题优化，建议认真分析两者的资源消耗。这是比较稳妥的做法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Java 8中，流有一个非常大的局限性，使用时，对它操作一次仅能得到一个处理结果。当流进行终端操作后，如果你在试图遍历它，就会出现异常。&lt;/
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>封装一个属于自己的Redis API</title>
    <link href="https://www.sakuratears.top/blog/%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84Redis-API20181027/"/>
    <id>https://www.sakuratears.top/blog/封装一个属于自己的Redis-API20181027/</id>
    <published>2018-10-27T09:15:00.000Z</published>
    <updated>2018-10-27T09:37:30.435Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Redis作为一款强大的key-value型数据库，其应用是十分广泛的。在Java语言中，常用来与Redis数据库建立连接用到的是Jedis Pool连接池。</p><p>今天我们来简单了解下它们然后实现一个可移植的操作Redis的API。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="知识准备"><a href="#知识准备" class="headerlink" title="知识准备"></a>知识准备</h2><p>我们知道Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。并提供了一系列的命令操作这些数据类型。</p><p>Jedis相当于对这些操作进行了代码封装，及提供了一些其它常用操作。</p><p>我们先来了解下Jedis的连接池配置参数。</p><p>commons-pool2 有一个配置类GenericObjectPoolConfig里面的通用参数设置如下：</p><table><thead><tr><th>参数</th><th>说明</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td>maxTotal</td><td>说明一个pool最多可以有多少个Jedis实例</td><td>8</td><td>-1表示不限制</td></tr><tr><td>maxIdle</td><td>一个pool最多可以有多少个空闲的Jedis实例</td><td>8</td><td></td></tr><tr><td>minIdle</td><td>一个pool最少有多少个空闲的Jedis实例</td><td>0</td></tr></tbody></table><p>可以看到它继承BaseObjectPoolConfig。我们可以看到BaseObjectPoolConfig的参数如下。</p><p><img src="/images/pasted-88.png" alt="upload successful"></p><p>部分参数意义如下：</p><table><thead><tr><th>参数</th><th>说明</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td>lifo</td><td>pool中的idle列表是双端队列，设定是否last in first out</td><td>true</td><td></td></tr><tr><td>maxWaitMillis</td><td>当active数量为max时,等待的时长</td><td>-1L(代表一直等)</td><td>配合blockWhenExhausted使用</td></tr><tr><td>blockWhenExhausted</td><td>当active数量为max时，是否阻塞等待一段时间</td><td>true</td><td></td></tr><tr><td>testOnCreate</td><td>创建实例时有效性检测</td><td>false</td><td></td></tr><tr><td>testOnReturn</td><td>归还实例时有效性检测</td><td>false</td><td></td></tr><tr><td>testOnBorrow</td><td>借出实例时有效性检测</td><td>false</td></tr></tbody></table><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>首先Redis连接池属性我们应当放置在配置文件里，解析并获得，连接池最好设计成单例的，每次不用在初始化过多连接资源。同时Redis有单机模式和集群模式区分，这两种模式我们也应该区分开来。单机模式下，可以选择多个database，集群模式下只能选择database0.集群模式下，如果redis地址过多，我们如何分开呢？</p><p>我们可以考虑如下样式：<br>address =127.0.0.1:6379;127.0.0.1:6380</p><p>每个redis地址用分号分隔，解析配置时把每个解析到并建立连接。</p><p>当然，最后完成JedisPool的创建后，我们应该编写工具类对一些常用操作方法进行封装，便于我们使用。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>我们根据上述思路，构造了如下图所示的小项目。</p><p><img src="/images/pasted-89.png" alt="upload successful"></p><p>其中：</p><p><strong>RedisException</strong>是用来统一处理程序过程中的异常的类。</p><p><strong>JedisFactory</strong>可以认为是一个JedisPool工厂，用来提供单机模式的连接池或者集群模式的连接池。</p><p><strong>RedisConfiguration</strong>是与配置文件对应的配置类，用于存放配置的数据。</p><p><strong>RedisConstants</strong>用来放置一些项目中用到的常量。</p><p><strong>RedisUtil</strong>工具类接口，提供了多种操作Redis的方法。</p><p><strong>RedisSingleUtil</strong>工具接口的单机模式实现。</p><p><strong>RedisClusterUtil</strong>工具接口的集群模式实现。</p><p><strong>redis-config.properties</strong> Redis的配置文件存放</p><p>JedisFactory和RedisUtill为主要类。我们看下他们的具体实现。</p><p>JedisFactory的主要代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> JedisPool jedisPool;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> JedisCluster jedisCluster;</span><br><span class="line">   <span class="keyword">private</span> RedisConfiguration redisConfig;</span><br><span class="line">   <span class="keyword">private</span> Pattern addRessPattern = Pattern.compile(<span class="string">"^.+[:]\\d&#123;1,5&#125;\\s*(;.+[:]\\d&#123;1,5&#125;\\s*)*[;]?\\s*$"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">JedisFactory</span><span class="params">(<span class="keyword">final</span> RedisConfiguration redisConfiguration)</span></span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.redisConfig=redisConfiguration;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> JedisPool <span class="title">getJedisPool</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(jedisPool==<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (JedisFactory.class)&#123;</span><br><span class="line">               <span class="keyword">if</span>(jedisPool==<span class="keyword">null</span>)&#123;</span><br><span class="line">                   init();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> jedisPool;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> JedisCluster <span class="title">getJedisCluster</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(jedisCluster==<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (JedisFactory.class)&#123;</span><br><span class="line">               <span class="keyword">if</span>(jedisCluster==<span class="keyword">null</span>)&#123;</span><br><span class="line">                   init();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> jedisCluster;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">       logger.info(<span class="string">"JedisFactory init start..."</span>);</span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(StringUtils.isNotBlank(redisConfig.getLocalPropertiesPath()))&#123;</span><br><span class="line">               fillData();</span><br><span class="line">           &#125;</span><br><span class="line">           logger.info(<span class="string">"redis config is: &#123;&#125;."</span>, redisConfig.toString());</span><br><span class="line">           Set&lt;HostAndPort&gt; hostAndPortSet = <span class="keyword">this</span>.parseHostAndPort(redisConfig.getAddress());</span><br><span class="line"></span><br><span class="line">           GenericObjectPoolConfig genericObjectPoolConfig = <span class="keyword">new</span> GenericObjectPoolConfig();</span><br><span class="line">           genericObjectPoolConfig.setMaxWaitMillis(redisConfig.getMaxWaitMillis());</span><br><span class="line">           genericObjectPoolConfig.setMaxTotal(redisConfig.getMaxTotal());</span><br><span class="line">           genericObjectPoolConfig.setMinIdle(redisConfig.getMinIdle());</span><br><span class="line">           genericObjectPoolConfig.setMaxIdle(redisConfig.getMaxIdle());</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span>(redisConfig.getMode()== RedisConstants.REDIS_MODE_SINGLE)&#123;</span><br><span class="line">               HostAndPort hostAndPort=(HostAndPort)hostAndPortSet.toArray()[<span class="number">0</span>];</span><br><span class="line">               jedisPool=<span class="keyword">new</span> JedisPool(genericObjectPoolConfig, hostAndPort.getHost(), hostAndPort.getPort(), redisConfig.getTimeout(), <span class="keyword">null</span>,redisConfig.getDatabase());</span><br><span class="line">               logger.info(<span class="string">"jedisPool init is finished"</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">if</span>(redisConfig.getDatabase()!=<span class="number">0</span>)&#123;</span><br><span class="line">                   logger.warn(<span class="string">"当前配置的database为："</span>+redisConfig.getDatabase()+<span class="string">",集群模式下不能选择database，只能使用database0"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               jedisCluster = <span class="keyword">new</span> JedisCluster(hostAndPortSet, redisConfig.getTimeout(), redisConfig.getMaxRedirections(), genericObjectPoolConfig);</span><br><span class="line">               logger.info(<span class="string">"jedisCluster init is finished"</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RedisException(ex);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fillData</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">       Properties localProperties = PropertiesUtils.loadLocalProperties(redisConfig.getLocalPropertiesPath());</span><br><span class="line"></span><br><span class="line">       String address=localProperties.getProperty(<span class="string">"address"</span>, <span class="string">""</span>);</span><br><span class="line">       <span class="keyword">if</span> (StringUtils.isBlank(address)) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RedisException(<span class="string">"error:redis config address is blank!"</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 设置初始值</span></span><br><span class="line">       <span class="keyword">long</span> maxWaitMillis=Long.parseLong(localProperties.getProperty(<span class="string">"maxWaitMillis"</span>, String.valueOf(GenericObjectPoolConfig.DEFAULT_MAX_WAIT_MILLIS)));</span><br><span class="line">       <span class="keyword">int</span> maxTotal=Integer.parseInt(localProperties.getProperty(<span class="string">"maxTotal"</span>, String.valueOf(GenericObjectPoolConfig.DEFAULT_MAX_TOTAL)));</span><br><span class="line">       <span class="keyword">int</span> minIdle=Integer.parseInt(localProperties.getProperty(<span class="string">"minIdle"</span>, String.valueOf(GenericObjectPoolConfig.DEFAULT_MIN_IDLE)));</span><br><span class="line">       <span class="keyword">int</span> maxIdle=Integer.parseInt(localProperties.getProperty(<span class="string">"maxIdle"</span>, String.valueOf(GenericObjectPoolConfig.DEFAULT_MAX_IDLE)));</span><br><span class="line">       <span class="keyword">int</span> timeout=Integer.parseInt((localProperties.getProperty(<span class="string">"timeout"</span>, <span class="string">"2000"</span>)));</span><br><span class="line">       <span class="keyword">int</span> maxRedirections=Integer.parseInt((localProperties.getProperty(<span class="string">"maxRedirections"</span>, <span class="string">"6"</span>)));</span><br><span class="line">       <span class="keyword">int</span> database=Integer.parseInt((localProperties.getProperty(<span class="string">"database"</span>, <span class="string">"0"</span>)));</span><br><span class="line">       <span class="comment">//1单机模式，2集群模式</span></span><br><span class="line">       <span class="keyword">int</span> mode=Integer.parseInt((localProperties.getProperty(<span class="string">"mode"</span>, String.valueOf(RedisConstants.REDIS_MODE_SINGLE))));</span><br><span class="line"></span><br><span class="line">       redisConfig.setAddress(address);</span><br><span class="line">       redisConfig.setMaxWaitMillis(maxWaitMillis);</span><br><span class="line">       redisConfig.setMaxTotal(maxTotal);</span><br><span class="line">       redisConfig.setMinIdle(minIdle);</span><br><span class="line">       redisConfig.setMaxIdle(maxIdle);</span><br><span class="line">       redisConfig.setTimeout(timeout);</span><br><span class="line">       redisConfig.setMaxRedirections(maxRedirections);</span><br><span class="line">       redisConfig.setDatabase(database);</span><br><span class="line">       redisConfig.setMode(mode);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//部分代码略</span></span><br></pre></td></tr></table></figure></p><p>对于RedisUtil接口，应有两个实现，单机和集群的，这里为了简化代码，只简单列举了一个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RedisUtil</span> </span>&#123;</span><br><span class="line"><span class="function">String <span class="title">setString</span><span class="params">(String key, String value)</span></span>;</span><br><span class="line">    <span class="comment">//部分代码略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单机模式的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisSingleUtil</span> <span class="keyword">implements</span> <span class="title">RedisUtil</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">setString</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">this</span>.getResource();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> jedis.set(key, value);</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.closeResource(jedis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//部分代码略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>集群模式的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisClusterUtil</span> <span class="keyword">implements</span> <span class="title">RedisUtil</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">setString</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        JedisCluster cluster=getResource();</span><br><span class="line">        <span class="keyword">return</span> getResource().set(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//部分代码略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他方法及实现不在赘述，有兴趣的可以在</p><p><a href="https://github.com/javazwt/framework-base" target="_blank" rel="noopener">https://github.com/javazwt/framework-base</a> 上查看相关代码。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTest</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> RedisSingleUtil redisSingleUtil=<span class="keyword">new</span> RedisSingleUtil();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    redisSingleUtil.setString(<span class="string">"str"</span>,<span class="string">"123"</span>);</span><br><span class="line">        redisSingleUtil.getString(<span class="string">"str"</span>);  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以检测我们的正确性。</p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>经过封装后，我们可以把该工具类使用在任何项目上，提高开发效率，降低项目耦合性，同时对Redis有了更深入的认知。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Redis作为一款强大的key-value型数据库，其应用是十分广泛的。在Java语言中，常用来与Redis数据库建立连接用到的是Jedis
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>封装构建基于ES的Java API包</title>
    <link href="https://www.sakuratears.top/blog/%E5%B0%81%E8%A3%85%E6%9E%84%E5%BB%BA%E5%9F%BA%E4%BA%8EES%E7%9A%84Java-API%E5%8C%8520181027/"/>
    <id>https://www.sakuratears.top/blog/封装构建基于ES的Java-API包20181027/</id>
    <published>2018-10-27T08:39:00.000Z</published>
    <updated>2018-10-27T09:13:04.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前些日子，elastic公司成功上市了。旗下有一款优秀的开源搜索引擎ElasticSearch。</p><p><strong>ElasticSearch</strong>是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。</p><p>好了，扯远了，回归正题。今天我们使用Java对它的一些API进行封装，以使其API更具备灵活性。</p><p>完成对其简单的使用是比较简单的，我们今天把我们的一些调用代码封装，以便可以在各个项目中自由使用。这才是我们的根本目的。</p><p>今天，我们来构建一个工具包类。</p><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>安装ElasticSearch，主要就是为了测试我们的代码，对于有现成环境的，如开发环境，测试环境上的ElasticSearch，这一步可以忽略。</p><ol><li><p>首先请安装ElasticSearch，这里就不介绍了，我这里是安装的ElasticSearch最新版，6.4.0版本。<a href="https://www.elastic.co/downloads/elasticsearch" target="_blank" rel="noopener">https://www.elastic.co/downloads/elasticsearch</a> 。安装成功后可以将其添加到环境变量中，然后启动。启动成功浏览器访问<a href="http://localhost:9200/" target="_blank" rel="noopener">http://localhost:9200/</a> 会看到json信息。</p></li><li><p>安装Kibana，Kibana是ElasticSearch的可视化工具，可以方便的查看ElasticSearch及其运行状态。<a href="https://www.elastic.co/products/kibana" target="_blank" rel="noopener">https://www.elastic.co/products/kibana</a> 。我安装的也是最新版本，6.4.0. 安装成功后加入环境变量，然后启动，访问<a href="http://localhost:5601/" target="_blank" rel="noopener">http://localhost:5601/</a> 可以看到Kibana界面。</p></li><li><p>JDK版本为1.8</p></li></ol><p>以上都为准备工作。</p><h1 id="架构构建"><a href="#架构构建" class="headerlink" title="架构构建"></a>架构构建</h1><p>org.elasticsearch.client.transport jar包已经有相关关于ES API的操作。</p><p>我们把它封装为专用jar包，建议使用Maven构建。如下：</p><h2 id="Maven项目"><a href="#Maven项目" class="headerlink" title="Maven项目"></a>Maven项目</h2><p>首先，我们先建一个名叫 framework-es的Maven项目。如下。</p><p>建好各个package。</p><p><strong>exception</strong>里面定义我们的异常。</p><p><strong>factory</strong>里面用来生成esclient。</p><p><strong>util</strong>里面放一些工具类。</p><p><strong>vo</strong>里面可以放查询对象等。</p><p><strong>property</strong>为配置文件。</p><p><strong>test</strong>里面存放测试类。</p><p>各个package的名字可以自己定义，描述清目的即可。如下图。</p><p><img src="/images/pasted-85.png" alt="upload successful"></p><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p>添加依赖，我的pom.xml依赖如下。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>transport<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.31<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>我的思路是构建一个单例的ESClient，用于与ES建立连接，以后增删改查等逻辑均使用此Client，保证资源的高效利用。这个也应当支持ES集群，有多个ES服务端也应当支持。而且地址应为可配置的。</p><p>话不多说，上代码，主要代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElasticSearchClientFactory</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(ElasticSearchClientFactory.class);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> TransportClient esClient;</span><br><span class="line"><span class="comment">//ES配置</span></span><br><span class="line"><span class="keyword">private</span> ElasticSearchConfiguration esConfig;</span><br><span class="line"><span class="comment">//校验多个ES地址的正则</span></span><br><span class="line"><span class="keyword">private</span> Pattern addRessPattern = Pattern.compile(<span class="string">"^.+[:]\\d&#123;1,5&#125;\\s*(;.+[:]\\d&#123;1,5&#125;\\s*)*[;]?\\s*$"</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ElasticSearchClientFactory</span><span class="params">(<span class="keyword">final</span> ElasticSearchConfiguration elasticSearchConfiguration)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.esConfig=elasticSearchConfiguration;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 获取一个单例的ESClient</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Client <span class="title">getEsClient</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(esClient==<span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (ElasticSearchClientFactory.class)&#123;</span><br><span class="line"><span class="keyword">if</span>(esClient==<span class="keyword">null</span>)&#123;</span><br><span class="line">logger.info(<span class="string">"ElasticSearchClientFactory init start..."</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(StringUtils.isNotBlank(esConfig.getLocalPropertiesPath()))&#123;</span><br><span class="line"><span class="comment">//获取ES配置信息</span></span><br><span class="line">fillData();</span><br><span class="line">&#125;</span><br><span class="line">logger.info(<span class="string">"ESConfig is:&#123;&#125;"</span>,esConfig.toString());</span><br><span class="line"><span class="comment">//多个ES地址解析</span></span><br><span class="line">List&lt;HostAndPort&gt; hostAndPortList = <span class="keyword">this</span>.parseHostAndPortList(esConfig.getAddress());</span><br><span class="line">TransportAddress [] transportAddress=<span class="keyword">new</span> TransportAddress[hostAndPortList.size()];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hostAndPortList.size(); i++) &#123;</span><br><span class="line">transportAddress[i] = <span class="keyword">new</span> TransportAddress(InetAddress.getByName(hostAndPortList.get(i).getIp()),hostAndPortList.get(i).getPort());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//节点名</span></span><br><span class="line">String nodeName=esConfig.getNodeName()+ UUID.randomUUID();</span><br><span class="line">String clusterName=esConfig.getClusterName();</span><br><span class="line">Settings.Builder settingsBuilder = Settings.builder();</span><br><span class="line">settingsBuilder.put(<span class="string">"node.name"</span>, nodeName);</span><br><span class="line"><span class="keyword">if</span>(StringUtils.isNotBlank(clusterName))&#123;</span><br><span class="line">settingsBuilder.put(<span class="string">"cluster.name"</span>, clusterName);</span><br><span class="line">&#125;</span><br><span class="line">settingsBuilder.put(<span class="string">"client.transport.sniff"</span>, <span class="keyword">true</span>);</span><br><span class="line">Settings settings = settingsBuilder.build();</span><br><span class="line">TransportClient client = <span class="keyword">new</span> PreBuiltTransportClient(settings);</span><br><span class="line"><span class="comment">//创建ESClient</span></span><br><span class="line">esClient = client.addTransportAddresses(transportAddress);</span><br><span class="line">logger.info(<span class="string">"EalsticSearchClientFactory init is finished"</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">logger.error(<span class="string">"EalsticSearchClientFactory create failed"</span>,e);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ElasticSearchException(<span class="string">"EalsticSearchClientFactory create faile"</span>,e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> esClient;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//其他代码略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码用于生成一个单例的ESClient类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElasticSearchConstants</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String DEFAULT_PROPERTIES_PATH=<span class="string">"property/es-config.properties"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时默认配置文件为property/es-config.properties<br>可手动进行配置，且支持多个地址，地址写法为 127.0.0.1:9200;127.0.0.2:9300</p><p>这样，中间应使用;分割。</p><p>我们对外提供一个工具类，供使用者进行对数据的操作。如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElasticSearchUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(ElasticSearchUtil.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SerializerFeature[] featuresWithNullValue=&#123;SerializerFeature.WriteMapNullValue, SerializerFeature.WriteNullBooleanAsFalse,</span><br><span class="line">            SerializerFeature.WriteNullListAsEmpty, SerializerFeature.WriteNullNumberAsZero, SerializerFeature.WriteNullStringAsEmpty&#125;;</span><br><span class="line">    <span class="keyword">private</span> ElasticSearchClientFactory elasticSearchClientFactory;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setElasticSearchClientFactory</span><span class="params">(ElasticSearchClientFactory elasticSearchClientFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elasticSearchClientFactory = elasticSearchClientFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ElasticSearchUtil</span><span class="params">(ElasticSearchClientFactory elasticSearchClientFactory)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elasticSearchClientFactory=elasticSearchClientFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ElasticSearchUtil</span><span class="params">(String localPropertiesPath)</span></span>&#123;</span><br><span class="line">        ElasticSearchConfiguration esConfig=<span class="keyword">new</span> ElasticSearchConfiguration();</span><br><span class="line">        esConfig.setLocalPropertiesPath(localPropertiesPath);</span><br><span class="line">        <span class="keyword">this</span>.elasticSearchClientFactory=<span class="keyword">new</span> ElasticSearchClientFactory(esConfig);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ElasticSearchUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ElasticSearchConfiguration esConfig = <span class="keyword">new</span> ElasticSearchConfiguration();</span><br><span class="line">        esConfig.setLocalPropertiesPath(ElasticSearchConstants.DEFAULT_PROPERTIES_PATH);</span><br><span class="line">        <span class="keyword">this</span>.elasticSearchClientFactory = <span class="keyword">new</span> ElasticSearchClientFactory(esConfig);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ElasticSearchUtil</span><span class="params">(ElasticSearchConfiguration esConfig)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elasticSearchClientFactory = <span class="keyword">new</span> ElasticSearchClientFactory(esConfig);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Client <span class="title">getEsClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> elasticSearchClientFactory.getEsClient();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isOnlyCreate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jsonString</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span>  <span class="keyword">boolean</span> <span class="title">createDocument</span><span class="params">(String index,String type,String id,<span class="keyword">boolean</span> isOnlyCreate,String jsonString)</span></span>&#123;</span><br><span class="line">        IndexResponse indexResponse;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isBlank(id))&#123;</span><br><span class="line">            indexResponse=elasticSearchClientFactory.getEsClient().prepareIndex(index,type).setCreate(isOnlyCreate).setSource(jsonString, XContentType.JSON).get();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            indexResponse=elasticSearchClientFactory.getEsClient().prepareIndex(index,type,id).setCreate(isOnlyCreate).setSource(jsonString,XContentType.JSON).get();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(logger.isDebugEnabled())&#123;</span><br><span class="line">            String _index=indexResponse.getIndex();</span><br><span class="line">            String _type=indexResponse.getType();</span><br><span class="line">            String _id=indexResponse.getId();</span><br><span class="line">            <span class="keyword">long</span> _version = indexResponse.getVersion();</span><br><span class="line">            <span class="keyword">boolean</span> created = RestStatus.CREATED.equals(indexResponse.status());</span><br><span class="line">            logger.debug(String.format(<span class="string">"createDocument index:%s,type:%s,id:%s,version:%s,created:%s"</span>, _index, _type, _id, _version, created));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> RestStatus.CREATED.equals(indexResponse.status());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他代码略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建好客户端后，我们可以用它执行增删改查，我们在封装一个ESUtil类，用于执行该系列操作，暴露一些特定增删改查接口。如上代码。</p><p>注：其他代码略。</p><p>这样，完成代码后，工程项目如下图所示。</p><p><img src="/images/pasted-86.png" alt="upload successful"></p><p><strong>ElasticSearchException</strong> 为自定义异常类。</p><p><strong>ElasticSearchClientFactory</strong>为主要方法，用来构建一个单例的ESClient</p><p><strong>ElasticSearchConfiguration</strong>为ES配置类</p><p><strong>ElasticSearchConstants</strong>为常量类，里面存放配置文件的路径</p><p><strong>HostAndPort</strong>为地址和端口的一个辅助Bean</p><p><strong>ElasticSearchUtil</strong>为主要方法，用于对外提供服务（CRUD）</p><p><strong>DocumentVo</strong>为辅助Bean</p><p><strong>es-config.properties</strong>为配置文件</p><p>当我们把项目打包成jar包时，配置文件可以不用打包，这样引入其他项目后，在其他项目里配置配置文件即可。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>若ES的安装路径D:\Program Files\elasticsearch-6.4.0\bin成功配置到环境变量后，在命令行输入elasticsearch便可启动服务。</p><p>若Kibana的安装路径D:\Program Files\kibana-6.4.0-windows-x86_64成功配置到环境变量后，在命令行输入kibana便可启动服务。</p><p>访问<a href="http://127.0.0.1:5601/" target="_blank" rel="noopener">http://127.0.0.1:5601/</a> 看到可视化界面。</p><p>编写测试类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ESTest</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ElasticSearchUtil esUtil=<span class="keyword">new</span> ElasticSearchUtil();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String index=<span class="string">"user_index"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String type=<span class="string">"user_type"</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">JSONObject js=<span class="keyword">new</span> JSONObject();</span><br><span class="line">js.put(<span class="string">"1"</span>,<span class="string">"2"</span>);</span><br><span class="line">esUtil.insertDocument(index,type,<span class="string">"123"</span>,js);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看Kibana界面可以看到我们的数据被添加进来了。</p><p><img src="/images/pasted-87.png" alt="upload successful"></p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>关于ElasticSearch及Kibana的具体使用我们以后再讲。</p><p>我们平时开发中，也可以创建类似的工具包，提高代码使用率，实现软件的高内聚低耦合，同时也是提高自己。</p><p>部分未展示代码请见我的GitHub地址: <a href="https://github.com/javazwt/" target="_blank" rel="noopener">https://github.com/javazwt/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前些日子，elastic公司成功上市了。旗下有一款优秀的开源搜索引擎ElasticSearch。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Elasti
      
    
    </summary>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java8 Spliterator接口</title>
    <link href="https://www.sakuratears.top/blog/Java8-Spliterator%E6%8E%A5%E5%8F%A320181027/"/>
    <id>https://www.sakuratears.top/blog/Java8-Spliterator接口20181027/</id>
    <published>2018-10-27T08:17:00.000Z</published>
    <updated>2018-10-27T08:37:13.932Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Spliterator 是Java8中加入的一个新接口，是“可分迭代器”（splitable iterator）的意思。它也是用来遍历数据源中的元素的，但它是为并行执行而设计的。</p><p>其接口主要代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Public <span class="class"><span class="keyword">interface</span> <span class="title">Spliterator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"><span class="function">Boolean <span class="title">tryAdvance</span><span class="params">(Consumer &lt;? <span class="keyword">super</span> T&gt;)</span> action</span>;</span><br><span class="line"><span class="function">Spliterator&lt;T&gt; <span class="title">trySplit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Long <span class="title">estimateSize</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Int <span class="title">characteristics</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>T </strong>是Spliterator要遍历的元素类型。</p><p><strong>tryAdvance</strong> 方法的行为类似于普通的Iterator，因为它会按顺序一个一个使用Spliterator中的元素，并且如果还有其他元素要遍历就返回true。</p><p><strong>trySplit</strong> 是专为Spliterator接口而设计的，因为它可以把一些元素划出去分给第二个Spliterator，让他们两个并行处理。</p><p><strong>estimateSize</strong>方法估计还剩多少元素需要遍历，因为即使不那么精确，快速算出来的值也有助于让拆分均匀点。</p><blockquote><p>注：将Stream流拆分成多个部分的算法是个递归过程，第一步第一个Spliterator调用trySplit，生成两个Spliterator，第二步这两个Spliterator调用trySplit，生成4个Spliterator，直到调用Spliterator的trySplit 方法后返回null，表示这部分Spliterator不能在分割。</p></blockquote><p>这个拆分过程也受Spliterator本身特性的影响，而特性是通过<strong>characteristics</strong>方法声明的。</p><p>我们来简单看一下它的特性的常用值。</p><table><thead><tr><th>特性</th><th>含义</th></tr></thead><tbody><tr><td>ORDERED</td><td>按元素的既定顺序遍历和划分</td></tr><tr><td>DISTINCT</td><td>对于任一遍历过的元素x，y,x.equals(y)返回false</td></tr><tr><td>SORTED</td><td>遍历元素按照一个预定义顺序排序</td></tr><tr><td>SIZED</td><td>Spliterator由一个已知大小的数据源建立，estimateSize会返回准确值</td></tr><tr><td>NONNULL</td><td>保证遍历元素不会为空</td></tr><tr><td>IMMUTABLE</td><td>Spliterator的数据源不能被修改，（不能 添加、删除、修改任何元素）</td></tr><tr><td>CONCURRENT</td><td>Spliterator的数据源可以被其他线程同时修改而无需同步</td></tr><tr><td>SUBSIZED</td><td>该Spliterator和从它拆分出来的Spliterator都是SIZED的</td></tr></tbody></table><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>为什么我们需要了解这个类，有的时候甚至要实现这个类呢？</p><p>我们来看一个例子。</p><p>对于下面一个String，我想统计下单词数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String WORD=<span class="string">"Hello World Happy EveryDay Good good study day day up let us study Spliterator"</span>;</span><br></pre></td></tr></table></figure><p>我们需要创建一个counter来累计流中字符，以及在counter中把它们结合起来的逻辑，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCounter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> counter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> lastSpace;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WordCounter</span><span class="params">(<span class="keyword">int</span> counter, <span class="keyword">boolean</span> lastSpace)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.counter = counter;</span><br><span class="line">        <span class="keyword">this</span>.lastSpace = lastSpace;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历一个个的Character</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WordCounter <span class="title">accumulate</span><span class="params">(Character c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Character.isWhitespace(c))&#123;</span><br><span class="line">            <span class="keyword">return</span> lastSpace ? <span class="keyword">this</span> : <span class="keyword">new</span> WordCounter(counter,<span class="keyword">true</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//上一个字符是空格，而当前遍历的字符不是空格时，将单词计数器加一</span></span><br><span class="line">            <span class="keyword">return</span> lastSpace ? <span class="keyword">new</span> WordCounter(counter+<span class="number">1</span>,<span class="keyword">false</span>):<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//合并两个WordCounter，将其计数器加起来</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WordCounter <span class="title">combine</span><span class="params">(WordCounter wordCounter)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WordCounter(counter+wordCounter.counter,wordCounter.lastSpace);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCounter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候，我们在书写一个规约Character流统计单词个数就很简单了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countWords</span><span class="params">(Stream&lt;Character&gt; stream)</span></span>&#123;</span><br><span class="line">WordCounter wordCounter=stream.reduce(<span class="keyword">new</span> WordCounter(<span class="number">0</span>,<span class="keyword">true</span>),WordCounter::accumulate,WordCounter::combine);</span><br><span class="line"><span class="keyword">return</span> wordCounter.getCounter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Character&gt; stream= IntStream.range(<span class="number">0</span>,WORD.length()).mapToObj(WORD::charAt);</span><br><span class="line">System.out.println(countWords(stream));</span><br></pre></td></tr></table></figure><p>输出14。结果是正确的。</p><p>现在我们让他在并行流上进行工作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Character&gt; stream= IntStream.range(<span class="number">0</span>,WORD.length()).mapToObj(WORD::charAt).parallel();</span><br></pre></td></tr></table></figure><p>结果输出26。显然这是不正确的。一脸懵逼。</p><p>为什么会出现这种情况呢？</p><p>因为在并行流进行Spliterator分割时，把一个单词拆分成两部分了，导致结果变大。这显然不是我们想看到的。</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>我们要处理这种情况，就要指定分割原则，不要让程序把整个单词切开。</p><p>因此我们需要编写自己的Spliterator才能让上述问题在并行流下工作。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCounterSpliterator</span> <span class="keyword">implements</span> <span class="title">Spliterator</span>&lt;<span class="title">Character</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String string;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> currentChar=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WordCounterSpliterator</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.string = string;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Character&gt; action)</span> </span>&#123;</span><br><span class="line"><span class="comment">//处理当前字符</span></span><br><span class="line">action.accept(string.charAt(currentChar++));</span><br><span class="line"><span class="comment">//如果还有字符要处理，返回true</span></span><br><span class="line"><span class="keyword">return</span> currentChar&lt;string.length();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Spliterator&lt;Character&gt; <span class="title">trySplit</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> currentSize=string.length()-currentChar;</span><br><span class="line"><span class="comment">//返回null表示要处理的String已经足够小</span></span><br><span class="line"><span class="keyword">if</span>(currentSize&lt;<span class="number">10</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将试探拆分位置设定到要解析的文字中间</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> splitPos=currentSize/<span class="number">2</span>+currentChar;splitPos&lt;string.length();splitPos++)&#123;</span><br><span class="line"><span class="comment">//如果是空格就开始拆分，不是空格将拆分位置前进直到下一个空格</span></span><br><span class="line"><span class="keyword">if</span>(Character.isWhitespace(string.charAt(splitPos)))&#123;</span><br><span class="line"><span class="comment">//创建一个新的WordCounterSpliterator来解析String从开始到拆分位置的部分</span></span><br><span class="line">Spliterator&lt;Character&gt; spliterator=</span><br><span class="line"><span class="keyword">new</span> WordCounterSpliterator(string.substring(currentChar,splitPos));</span><br><span class="line"><span class="comment">//将这个WordCounterSpliterator的起始位置设为拆分位置</span></span><br><span class="line">currentChar=splitPos;</span><br><span class="line"><span class="keyword">return</span> spliterator;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">estimateSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> string.length()-currentChar;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ORDERED+SIZED+SUBSIZED+NONNULL+IMMUTABLE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>tryAdvance</strong>方法把String中当前位置的Character传给了Consumer，并让位置加一。作为参数传递的内部类Consumer，在遍历流时将要处理的Character传递给要执行的函数。如果新的指针位置小于String总长度，说明没有遍历完，返回true继续遍历。</p><p><strong>trySplit</strong>方法，首先我们设置了一个拆分下限——10个Character，实际应用中我们应尽量提高这个长度避免生成太多的任务。如果长度小于这个数，就返回空无需继续拆分。否则就把试探拆分位置放到要解析的String块中间，但不能直接使用此位置，应该看看是不是空格，如果是就拆分，如果不是，就向前找，找到空格进行拆分，避免把一个单词拆成两份。</p><p><strong>estimatedSize</strong>方法返回的是这个Spliterator解析的String的总长度和当前遍历位置的差值。</p><p><strong>characteristic</strong>方法告诉这个框架是ORDERED（String的每个Character的默认顺序），SIZED（estimatedSize方法返回值是精确的），SUBSIZED（trySplit分出来的Spliterator大小也是固定的），NONNULL（String里面的Character不可能为null），IMMUTABLE（String本身就不可变化）。</p><p>下面我们测试一下我们的WordCounterSpliterator 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Spliterator&lt;Character&gt; spliterator=<span class="keyword">new</span> WordCounterSpliterator(WORD);</span><br><span class="line">Stream&lt;Character&gt; stream= StreamSupport.stream(spliterator,<span class="keyword">true</span>);</span><br><span class="line">System.out.println(countWords(stream));</span><br></pre></td></tr></table></figure><p>可以看到输出结果为14.</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>可以看到，并行流不是所有情况都适用的，有些情况要定制自己的Spliterator才能使并行流正常工作。这个例子或许运行效率并行比不上串行，但是在大数据下，比如分析一个文本文件中的单词数量，就能明显看到并行带来的速度优势了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Spliterator 是Java8中加入的一个新接口，是“可分迭代器”（splitable iterator）的意思。它也是用来遍历数据源
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>和前同事闲聊小记</title>
    <link href="https://www.sakuratears.top/blog/%E5%92%8C%E5%89%8D%E5%90%8C%E4%BA%8B%E9%97%B2%E8%81%8A%E5%B0%8F%E8%AE%B020181027/"/>
    <id>https://www.sakuratears.top/blog/和前同事闲聊小记20181027/</id>
    <published>2018-10-27T08:02:09.000Z</published>
    <updated>2018-10-27T08:15:50.350Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是一篇技术问题讨论文章~~~</p><p>最近和前同事（朋友）聊天，帮他分析了这么一个需求，蛮有意思的，特来分享下其代码。</p><p>和他聊了很久，算是大致上听懂了他的需求，总结下他的需求：</p><p><strong>假设有若干方法（任务）(A,B,C,D,E…….)，对于每个方法（任务），同一时间只能有一个用户（线程）访问，现一些用户需要执行若干任务（如用户1执行（ABC），用户2执行（BEF），用户3执行（ACEF）….），对每个用户，用户的任务不要求执行顺序，如何尽可能的提高程序运行的效率。</strong></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>其实这之中比较重要的一点是每个方法同一时间只允许一个用户访问，我们如果给每个方法加上synchronized关键字呢？我从这方面入手没有想到太好的方法。我用了一种方法，就是从队列入手，对每个方法，可以设置一个等待队列，如果有任务正在执行该方法，则将其他的访问该方法的线程挂起，当然，对于每个用户，应该开多个线程去异步执行各个方法。</p><p>于是我想到了定长线程池，允许一个线程执行，其他线程进入后会放到等待队列中。对于方法，每有一个方法（任务），就创建一个定长线程池。应当在初始化时就将数据设置好。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>以下是我的一些实现代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoTask</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,ExecutorService&gt; poolMap=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//获取指定class的public方法</span></span><br><span class="line">        Method[] methods=ThingsMethod.class.getDeclaredMethods();</span><br><span class="line">        <span class="comment">//有多少个方法就创建多少个线程池,一个方法指定一个定长线程池</span></span><br><span class="line">        <span class="keyword">for</span>(Method method:methods)&#123;</span><br><span class="line">            ExecutorService pool= Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">            poolMap.put(method.getName(),pool);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//list里面假设是要执行的任务，变化的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTask</span><span class="params">(List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(String taskStr:list)&#123;</span><br><span class="line">            <span class="keyword">final</span> String id=<span class="string">"Thread"</span>+Thread.currentThread().getId();</span><br><span class="line">            <span class="keyword">switch</span> (taskStr)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"A"</span>:</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        executeMethod(<span class="string">"doSomethingA"</span>,id);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">"B"</span>:</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        executeMethod(<span class="string">"doSomethingB"</span>,id);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"C"</span>:</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        executeMethod(<span class="string">"doSomethingC"</span>,id);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"D"</span>:</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        executeMethod(<span class="string">"doSomethingD"</span>,id);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeMethod</span><span class="params">(String methodName,String id)</span></span>&#123;</span><br><span class="line">        poolMap.get(methodName).execute(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Method method=ThingsMethod.class.getMethod(methodName,String.class);</span><br><span class="line">                method.invoke(ThingsMethod.class.newInstance(),id);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThingsMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doSomethingA</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span>+id+<span class="string">"做A事情开始-----&gt;"</span>);</span><br><span class="line">        <span class="comment">//假设做A事情花费1s</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span>+id+<span class="string">"做A事情结束-----&gt;"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doSomethingB</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span>+id+<span class="string">"做B事情开始-----&gt;"</span>);</span><br><span class="line">        <span class="comment">//假设做B事情花费3s</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span>+id+<span class="string">"做B事情结束-----&gt;"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doSomethingC</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span>+id+<span class="string">"做C事情开始-----&gt;"</span>);</span><br><span class="line">        <span class="comment">//假设做C事情花费2s</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span>+id+<span class="string">"做C事情结束-----&gt;"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doSomethingD</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span>+id+<span class="string">"做D事情开始-----&gt;"</span>);</span><br><span class="line">        <span class="comment">//假设做D事情花费5s</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span>+id+<span class="string">"做D事情结束-----&gt;"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写测试类对其进行测试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//随机假设我们的任务是这样的</span></span><br><span class="line">        List&lt;String&gt; s=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        String [] strings=<span class="keyword">new</span> String[]&#123;<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>,<span class="string">"D"</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> l=(<span class="keyword">int</span>)Math.ceil(Math.random()*strings.length);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)&#123;</span><br><span class="line">            s.add(strings[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取结果</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.print(<span class="string">"Thread"</span>+Thread.currentThread().getId()+<span class="string">"随机生成的任务--》"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            System.out.print(s.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        DoTask doTask=<span class="keyword">new</span> DoTask();</span><br><span class="line">        doTask.doTask(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyTest test = <span class="keyword">new</span> MyTest();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(test);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(test);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(test);</span><br><span class="line">        Thread t4 = <span class="keyword">new</span> Thread(test);</span><br><span class="line">        Thread t5 = <span class="keyword">new</span> Thread(test);</span><br><span class="line">        Thread t6 = <span class="keyword">new</span> Thread(test);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line">        t5.start();</span><br><span class="line">        t6.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Thread11随机生成的任务--》A</span><br><span class="line"></span><br><span class="line">Thread13随机生成的任务--》A</span><br><span class="line"></span><br><span class="line">Thread15随机生成的任务--》AB</span><br><span class="line"></span><br><span class="line">Thread14随机生成的任务--》ABCD</span><br><span class="line"></span><br><span class="line">Thread12随机生成的任务--》ABCD</span><br><span class="line"></span><br><span class="line">Thread16随机生成的任务--》A</span><br><span class="line">线程Thread16做A事情开始-----&gt;</span><br><span class="line">线程Thread14做C事情开始-----&gt;</span><br><span class="line">线程Thread12做B事情开始-----&gt;</span><br><span class="line">线程Thread12做D事情开始-----&gt;</span><br><span class="line">线程Thread16做A事情结束-----&gt;</span><br><span class="line">线程Thread13做A事情开始-----&gt;</span><br><span class="line">线程Thread14做C事情结束-----&gt;</span><br><span class="line">线程Thread12做C事情开始-----&gt;</span><br><span class="line">线程Thread13做A事情结束-----&gt;</span><br><span class="line">线程Thread12做A事情开始-----&gt;</span><br><span class="line">线程Thread12做B事情结束-----&gt;</span><br><span class="line">线程Thread14做B事情开始-----&gt;</span><br><span class="line">线程Thread12做A事情结束-----&gt;</span><br><span class="line">线程Thread14做A事情开始-----&gt;</span><br><span class="line">线程Thread12做C事情结束-----&gt;</span><br><span class="line">线程Thread14做A事情结束-----&gt;</span><br><span class="line">线程Thread11做A事情开始-----&gt;</span><br><span class="line">线程Thread12做D事情结束-----&gt;</span><br><span class="line">线程Thread14做D事情开始-----&gt;</span><br><span class="line">线程Thread11做A事情结束-----&gt;</span><br><span class="line">线程Thread15做A事情开始-----&gt;</span><br><span class="line">线程Thread14做B事情结束-----&gt;</span><br><span class="line">线程Thread15做B事情开始-----&gt;</span><br><span class="line">线程Thread15做A事情结束-----&gt;</span><br><span class="line">线程Thread15做B事情结束-----&gt;</span><br><span class="line">线程Thread14做D事情结束-----&gt;</span><br></pre></td></tr></table></figure><p>可以看到运行结果是正确的。</p><h1 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h1><p>我还想到一种就是对各个方法（任务）添加synchronized关键字，这些方法对用户共享，这样每当有用户请求时，开线程池执行各个方法。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoTask</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThingsMethod method=<span class="keyword">new</span> ThingsMethod();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTask</span><span class="params">(List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(String taskStr:list)&#123;</span><br><span class="line">ExecutorService executor= Executors.newCachedThreadPool();            </span><br><span class="line">                executor.execute(()-&gt;&#123;                </span><br><span class="line"><span class="keyword">final</span> String id=<span class="string">"Thread"</span>+Thread.currentThread().getId();</span><br><span class="line">doSomething(taskStr,id,method);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(String taskStr,String id,ThingsMethod method)</span></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (taskStr)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"A"</span>:</span><br><span class="line">method.doSomethingA(id);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"B"</span>:</span><br><span class="line">method.doSomethingA(id);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"C"</span>:</span><br><span class="line">method.doSomethingA(id);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"D"</span>:</span><br><span class="line">method.doSomethingA(id);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThingsMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">doSomethingA</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span>+id+<span class="string">"做A事情开始-----&gt;"</span>);</span><br><span class="line">        <span class="comment">//假设做A事情花费1s</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span>+id+<span class="string">"做A事情结束-----&gt;"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">doSomethingB</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span>+id+<span class="string">"做B事情开始-----&gt;"</span>);</span><br><span class="line">        <span class="comment">//假设做B事情花费3s</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span>+id+<span class="string">"做B事情结束-----&gt;"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">doSomethingC</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span>+id+<span class="string">"做C事情开始-----&gt;"</span>);</span><br><span class="line">        <span class="comment">//假设做C事情花费2s</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span>+id+<span class="string">"做C事情结束-----&gt;"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">doSomethingD</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span>+id+<span class="string">"做D事情开始-----&gt;"</span>);</span><br><span class="line">        <span class="comment">//假设做D事情花费5s</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span>+id+<span class="string">"做D事情结束-----&gt;"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于在主线程上开启了多线程，所以这种方法观看日志比较不方便。这种方法的正确性也还没来得及验证。</p><p>如果大家有什么好的其他想法也可以讨论交流。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这是一篇技术问题讨论文章~~~&lt;/p&gt;
&lt;p&gt;最近和前同事（朋友）聊天，帮他分析了这么一个需求，蛮有意思的，特来分享下其代码。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java8 Stream API简介</title>
    <link href="https://www.sakuratears.top/blog/Java8-Stream-API%E7%AE%80%E4%BB%8B20181027/"/>
    <id>https://www.sakuratears.top/blog/Java8-Stream-API简介20181027/</id>
    <published>2018-10-27T07:28:00.000Z</published>
    <updated>2018-10-27T07:58:39.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天来简单讲下Java8新增的Stream API。</p><p>Stream是Java8新增的对于集合框架操作的一个类，我们也称之为流操作。使用Stream，可以简化很多重复代码，使用并行流时有时还能提高程序运行效率。我们来看下。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>要把一个集合，List、Set或其他集合类转换为一个流，需要调用stream方法（转换为串行流）或者parallelStream方法（转换为并行流）。</p><p>Stream的常用方法如下表格介绍：</p><table><thead><tr><th>常用方法</th><th>说明</th><th>参数</th><th>举例</th></tr></thead><tbody><tr><td>filter(Predicate&lt;? super T&gt; predicate)</td><td>过滤，返回一个匹配给定布尔表达式的数据流</td><td>一个返回值为boolean的lambda表达式</td><td>例1</td></tr><tr><td>map(Function&lt;? super T, ? extends R&gt; mapper)</td><td>匹配，对流的每个元素都应用给定的函数以获得新流</td><td>任一符合条件的lambda表达式</td><td>例2</td></tr><tr><td>mapToInt(ToIntFunction&lt;? super T&gt; mapper)</td><td>将流数据转换为IntStream流</td><td>流元素转为int的lambda表达式</td><td>例3</td></tr><tr><td>mapToLong(ToLongFunction&lt;? super T&gt; mapper)</td><td>将流数据转换为LongStream流</td><td>流元素转为long的lambda表达式</td><td>略</td></tr><tr><td>mapToDouble(ToDoubleFunction&lt;? super T&gt; mapper)</td><td>将流数据转换为DoubleStream流</td><td>流元素转为Double的lambda表达式</td><td>略</td></tr><tr><td>flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt; mapper)</td><td>返回一个对流的每个元素都应用给定的函数的新流。这个入参lambda包含有过滤流，此方法类似于平常的双重循环</td><td>一个包含过滤流的lambda表达式</td><td>例4</td></tr><tr><td>flatMapToInt(Function&lt;? super T, ? extends IntStream&gt; mapper)</td><td>参考mapToInt</td><td>参考mapToInt</td><td>略</td></tr><tr><td>flatMapToLong(Function&lt;? super T, ? extends LongStream&gt; mapper)</td><td>参考mapToLong</td><td>参考mapToLong</td><td>略</td></tr><tr><td>flatMapToDouble(Function&lt;? super T, ? extends DoubleStream&gt; mapper)</td><td>参考mapToDouble</td><td>参考mapToDouble</td><td>略</td></tr><tr><td>distinct()</td><td>去除流中的重复元素</td><td>无参数</td><td>例5</td></tr><tr><td>sorted()</td><td>对流中元素进行排序，使用自然顺序。</td><td>无参数</td><td>例6</td></tr><tr><td>sorted(Comparator&lt;? super T&gt; comparator)</td><td>对流中的元素进行排序，按照指定的规则</td><td>流中元素的比较规则</td><td>例7</td></tr><tr><td>peek(Consumer&lt;? super T&gt; action)</td><td>截断流后进行某些操作</td><td>指定的操作，无返回值lambda</td><td>例8</td></tr><tr><td>limit(long maxSize)</td><td>获取流中的前n个元素的流</td><td>限定值</td><td>例9</td></tr><tr><td>skip(long n)</td><td>获取从n开始后面元素的流，不包括n，如果n超出流长度，返回一个空流</td><td>起始长度</td><td>例10</td></tr><tr><td>forEach(Consumer&lt;? super T&gt; action)</td><td>循环流中的每个元素，执行指定的lambda表达式</td><td>无返回值的lambda表达式</td><td>例11</td></tr><tr><td>forEachOrdered(Consumer&lt;? super T&gt; action)</td><td>按照默认顺序循环流中的元素，执行指定的lambda表达式</td><td>无返回值的lambda表达式</td><td>略</td></tr><tr><td>toArray()</td><td>返回流中元素组成的数组</td><td>无参数</td><td>例12</td></tr><tr><td>toArray(IntFunction&lt;A[]&gt; generator)</td><td>将流中元素转换为指定类型的数组，数组类型必须是流元素的本身或者超类</td><td>略</td><td>略</td></tr><tr><td>reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</td><td>归约，将流中的元素按照指定表达式归并。</td><td>起始值（默认值），指定归约公式</td><td>例13</td></tr><tr><td>reduce(BinaryOperator&lt;T&gt; accumulator)</td><td>同上，不同的是这个没有设置起始值，故结果可能为空，返回的是Optional对象</td><td>指定的归约公式</td><td>略</td></tr><tr><td>reduce(U identity,BiFunction&lt;U,? super T,U&gt; accumulator,BinaryOperator&lt;U&gt; combiner)</td><td>归约全参方法，可以指定初始值，归约方法，归约方式</td><td>略</td><td>例14</td></tr><tr><td>collect(Collector&lt;? super T, A, R&gt; collector)</td><td>收集器，比较常用的是toList，将流元素变为集合</td><td>略</td><td>略</td></tr><tr><td>collect(Supplier&lt;R&gt; supplier,BiConsumer&lt;R, ? super T&gt; accumulator,BiConsumer&lt;R, R&gt; combiner)</td><td>收集器，可以指定收集规则，收集方法等</td><td>略</td><td>略</td></tr><tr><td>min(Comparator&lt;? super T&gt; comparator)</td><td>根据指定规则获取流中最小值</td><td>排序规则lambda表达式</td><td>例15</td></tr><tr><td>max(Comparator&lt;? super T&gt; comparator)</td><td>根据指定规则获取流中最大值</td><td>排序规则lambda表达式</td><td>例15</td></tr><tr><td>count()</td><td>统计流中元素数量</td><td>无参数</td><td>例16</td></tr><tr><td>anyMatch(Predicate&lt;? super T&gt; predicate)</td><td>查找流中是否有元素符合条件，一旦查到，就返回true</td><td>条件的lambda表达式</td><td>例17</td></tr><tr><td>allMatch(Predicate&lt;? super T&gt; predicate)</td><td>查找流中的元素是否全部匹配指定表达式，全部符合才返回true</td><td>条件的lambda表达式</td><td>例18</td></tr><tr><td>noneMatch(Predicate&lt;? super T&gt; predicate)</td><td>查找流中的元素是否全部不匹配指定表达式，全部不匹配才返回true</td><td>条件的lambda表达式</td><td>略</td></tr><tr><td>findFirst()</td><td>查找流的第一个元素，如果流为空，返回空（Optional的空）</td><td>无参数</td><td>略</td></tr><tr><td>findAny()</td><td>随便从流中拿一个元素，如果流为空，返回空（Optional的空）</td><td>无参数</td><td>略</td></tr><tr><td>empty()</td><td>静态方法，返回一个空流</td><td>略</td><td>例19</td></tr><tr><td>of(T t)</td><td>静态方法，生成一个元素的流</td><td>略</td><td>例19</td></tr><tr><td>of(T… values)</td><td>静态方法，生成若干元素的流</td><td>略</td><td>例19</td></tr><tr><td>iterate(final T seed, final UnaryOperator&lt;T&gt; f)</td><td>静态方法，生成一个有规律的流</td><td>起始值，指定的lambda表达式</td><td>例19</td></tr><tr><td>generate(Supplier&lt;T&gt; s)</td><td>静态方法，生成指定规则的数据流，流数据的生成完全取决于lambda表达式</td><td>生成流数据的lambda表达式</td><td>例19</td></tr><tr><td>concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</td><td>静态方法，将两个数据流合并，两个流的类型须一致</td><td>两个数据流</td><td>例19</td></tr></tbody></table><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>举例：假设有一个1-100的List集合list1,50-150的List集合list2.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例1：需要一个1-100的偶数List集合。</span></span><br><span class="line">list1.stream().filter(n-&gt;n%<span class="number">2</span>==<span class="number">0</span>).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//例2：获取list1各元素加上100，再取基数的List集合。</span></span><br><span class="line">list1.stream().map(n-&gt;n+<span class="number">100</span>).map(n-&gt;n%<span class="number">2</span>!=<span class="number">0</span>).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//例3：将list1的流转换为IntStream。</span></span><br><span class="line">list1.stream().mapToInt(n-&gt;n.intValue());</span><br><span class="line"><span class="comment">//例4：list1和list2的交集集合。</span></span><br><span class="line">list1.stream().flatMap(i-&gt;list2.stream().map(j-&gt;i==j)).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//例5：list1和list2的并集集合。</span></span><br><span class="line">list1.addAll(list2);</span><br><span class="line">list1.stream().distinct();</span><br><span class="line"><span class="comment">//例6：对list1进行排序。</span></span><br><span class="line">list1.stream().sorted().collect(Collectors.toList());</span><br><span class="line"><span class="comment">//例7：对list1进行倒序排序。</span></span><br><span class="line">list1.stream().sorted(Comparator.reverseOrder()).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//例8：截断查看流的每一步得到的流元素。</span></span><br><span class="line">list1.stream().map(n-&gt;n+<span class="number">100</span>).peek(System.out::println).map(n-&gt;n%<span class="number">2</span>!=<span class="number">0</span>).peek(System.out::println).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//例9：取list1的前10个元素。</span></span><br><span class="line">list1.stream().limit(<span class="number">10</span>).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//例10：取list1的后10个元素。</span></span><br><span class="line">list1.stream().skip(list1.size()-<span class="number">10</span>).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//例11：输出list1的各个元素。</span></span><br><span class="line">list1.stream().forEach(System.out::println);</span><br><span class="line"><span class="comment">//例12：将list1元素转为数组。</span></span><br><span class="line">list1.stream().toArray();</span><br><span class="line"><span class="comment">//例13：对list1元素求和，对list2元素求差。</span></span><br><span class="line">list1.stream().reduce(<span class="number">0</span>,(a,b)-&gt;a+b);</span><br><span class="line">list2.stream().reduce(<span class="number">0</span>,(a,b)-&gt;a-b);</span><br><span class="line"><span class="comment">//例14：对list1按照最大值到最小值求和。</span></span><br><span class="line">list1.stream().reduce(<span class="number">0</span>,(a,b)-&gt;a+b, BinaryOperator.maxBy(Comparator.naturalOrder()));</span><br><span class="line"><span class="comment">//例15：取list1的最大最小值</span></span><br><span class="line">list1.stream().max(Comparator.naturalOrder());</span><br><span class="line">list1.stream().min(Comparator.naturalOrder());</span><br><span class="line"><span class="comment">//例16：求list1的元素个数</span></span><br><span class="line">list1.stream().count();</span><br><span class="line"><span class="comment">//例17：查询list1中有没有17的倍数（除了17）。</span></span><br><span class="line">list1.stream().anyMatch(n-&gt;n!=<span class="number">17</span>&amp;&amp;n%<span class="number">17</span>==<span class="number">0</span>);</span><br><span class="line"><span class="comment">//例18：查询list1中所有元素是不是都是2的倍数。</span></span><br><span class="line">list1.stream().allMatch(n-&gt;n%<span class="number">2</span>==<span class="number">0</span>);</span><br><span class="line"><span class="comment">//例19：</span></span><br><span class="line">Stream.empty();<span class="comment">//空流</span></span><br><span class="line">Stream.of(<span class="number">1</span>);<span class="comment">//生成一个元素的流</span></span><br><span class="line">Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);<span class="comment">//生成若干元素的流</span></span><br><span class="line">Stream.iterate(<span class="number">1</span>,n-&gt;<span class="number">2</span>*n);<span class="comment">//生成指定规则的数据流</span></span><br><span class="line">Stream.generate(()-&gt;Math.random());<span class="comment">//生成指定规则的数据流</span></span><br><span class="line">Stream.concat(list1.stream(),list2.stream());<span class="comment">//将两个数据流合并</span></span><br></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>Java8 Stream API的一些常用方法基本如上，Stream API为操作集合类提供了更方便快捷的方式，值得我们掌握。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天来简单讲下Java8新增的Stream API。&lt;/p&gt;
&lt;p&gt;Stream是Java8新增的对于集合框架操作的一个类，我们也称之为流操
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>你该相信什么</title>
    <link href="https://www.sakuratears.top/blog/%E4%BD%A0%E8%AF%A5%E7%9B%B8%E4%BF%A1%E4%BB%80%E4%B9%8820181027/"/>
    <id>https://www.sakuratears.top/blog/你该相信什么20181027/</id>
    <published>2018-10-27T07:25:00.000Z</published>
    <updated>2018-11-11T14:13:23.131Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/show3.jpg" alt="upload successful"><br><a id="more"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>写这篇文章，或是怀念过去的自己，或是憧憬自己未来。可是啊，无论如何，要活好当下。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>工作总的来说差不多四年了，或许已从职场菜鸟变化为职场老手了。</p><p>可是，岁月的变迁确无法掩饰我这颗浮躁的心，哎，想想自己，确实很浮躁啊。</p><p>曾经，想静心，于是开始练字，练了很长一段时间，可是后面确不知不觉的放弃了，至今剩下的字帖和钢笔仍静静地躺在我的桌子上。</p><p>后来，心血来潮搭建了属于自己的博客，然后创建了微信公众号，平时写些文章来总结自己和工作，我希望自己可以坚持下去，也相信自己可以坚持下去。</p><p>世上大多数人是平凡的，可是，要有一颗不甘平凡的心。</p><p>最怕一生碌碌无为，还安慰平凡难能可贵。</p><p>任何事都不应成为懒惰的借口。</p><p>不诉困苦于环境，不寄期望于运气，不服挫折于命运。</p><p>还记得那个年少的自己吗？或许他变了，可是他还在，他一直陪着你。</p><p>相信自己。做自己的英雄。</p><p>努力吧，骚年！</p><p>加油！</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>好了，喝饱鸡汤了。</p><p>努力去“搬砖”吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/show3.jpg&quot; alt=&quot;upload successful&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="https://www.sakuratears.top/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="思维" scheme="https://www.sakuratears.top/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Java8 接口</title>
    <link href="https://www.sakuratears.top/blog/Java8-%E6%8E%A5%E5%8F%A320181014/"/>
    <id>https://www.sakuratears.top/blog/Java8-接口20181014/</id>
    <published>2018-10-14T03:35:00.000Z</published>
    <updated>2018-10-14T03:56:00.987Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java 8已经推出相当长一段时间了，其中，接口部分有一些变化。我们来研究下它。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>我们知道，对于一个接口，如果我们声明好后，如果再想对其增加新的方法是困难的，因为我们要改变所有其实现类，也就是每个实现类都要对其新方法进行实现。如下图：</p><p><img src="/images/pasted-82.png" alt="upload successful"></p><p>这显然是不现实的，如果我们直接把方法写在实现类里，接口中没有此方法，就破坏了我们的多态性。</p><p>对于某些已经发布的应用，无论哪种做法都是比较繁重且不被推荐的。</p><h1 id="接口默认实现"><a href="#接口默认实现" class="headerlink" title="接口默认实现"></a>接口默认实现</h1><p>还好，Java大神们已经意识到了这个问题，于是在Java8中，引入了对接口的<strong>默认方法</strong>实现。</p><p>什么是默认方法实现呢？</p><p>简单来说，就是允许接口定义默认方法，在接口中需要有方法体的具体实现，实现类默认继承该方法（如果不重写默认方法的话）。同时为区分默认方法，默认方法在接口中采用default关键字标明。如下图：</p><p><img src="/images/pasted-83.png" alt="upload successful"></p><p>这样，如果我们新增一个接口方法（对于已经发布的接口），可以使用默认实现，就不会出现我们上述的问题。</p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>你一定会说，这和抽象类有什么区别呢？</p><p>当然还是有区别的，Java8以后，接口和抽象类的几点总结如下：</p><p><img src="/images/pasted-84.png" alt="upload successful"></p><h1 id="新的问题"><a href="#新的问题" class="headerlink" title="新的问题"></a>新的问题</h1><p>接口引入了默认方法后，就会有新的问题，好在Java已经替我们解决了，我们来看下。</p><h2 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Interface A"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Interface B"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span>, <span class="title">B</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> C().doSomething();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：输出 Interface B</p><h2 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">A</span>, <span class="title">B</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> C().doSomething();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：输出 Interface B</p><h2 id="情况三"><a href="#情况三" class="headerlink" title="情况三"></a>情况三</h2><p>如果D是这样呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Class D"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：输出Class D</p><p>如果D不对doSomething提供实现（D为抽象的类），则C需要为doSomething提供实现。</p><h2 id="情况四"><a href="#情况四" class="headerlink" title="情况四"></a>情况四</h2><p>如果B接口不在继承A接口。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Interface A"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Interface B"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们C类必须为doSomething提供实现，当然我们可以具体制定使用哪个接口的doSomething方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span>, <span class="title">B</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">B.<span class="keyword">super</span>.doSomething();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="情况五"><a href="#情况五" class="headerlink" title="情况五"></a>情况五</h2><p>如果两个函数不一样但差距很小呢？如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">long</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span>, <span class="title">B</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> C().doSomething();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在IDEA里我们可以看到，类C是无法编译的，这是不被允许的。</p><h2 id="情况六"><a href="#情况六" class="headerlink" title="情况六"></a>情况六</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Interface A"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">B</span>,<span class="title">C</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> D().doSomething();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果Interface A</p><p>因为只有A声明了一个默认方法，这个接口是D的父接口，故输出Interface A。如果B也提供了一个默认方法，签名和A一致，那么编译器会选择B的默认方法，如果B添加一个相同签名的抽象方法，则D需要为其提供实现，如果B,C都有相同签名的默认方法doSomething，则会出现冲突，需要我们为doSomething提供实现或者指定使用B，C中的哪个方法。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>解决问题的三条规则：</p><p>如果一个类使用相同的函数签名从多个地方（比如另一个类或者接口）继承了方法，通过三条规则可进行判断。</p><ol><li><p><strong>类中的方法优先级最高。类或者父类中声明的方法优先级高于任何声明为默认方法的优先级。</strong></p></li><li><p><strong>如果无法依据第一条判断，那么子接口的优先级更高：函数签名相同时，优先选择拥有最具体实现的默认方法的接口，及如果B继承了A，那么B就比A更加具体。</strong></p></li><li><p><strong>最后，如果还是无法判断，继承了多个接口的类必须通过显式覆盖和调用期望的方法，显式地选择使用哪一个默认方法的实现。</strong></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Java 8已经推出相当长一段时间了，其中，接口部分有一些变化。我们来研究下它。&lt;/p&gt;
&lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot;
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
</feed>
