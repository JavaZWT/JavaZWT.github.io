<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SakuraTears的博客</title>
  
  <subtitle>越努力越幸运</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.sakuratears.top/"/>
  <updated>2020-08-09T01:33:43.569Z</updated>
  <id>https://www.sakuratears.top/</id>
  
  <author>
    <name>SakuraTears</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>工作中遇到的问题总结</title>
    <link href="https://www.sakuratears.top/blog/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.html"/>
    <id>https://www.sakuratears.top/blog/工作中遇到的问题总结.html</id>
    <published>2020-08-09T01:27:00.000Z</published>
    <updated>2020-08-09T01:33:43.569Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="工作问题总结"><a href="#工作问题总结" class="headerlink" title="工作问题总结"></a>工作问题总结</h1><p>总结了工作中遇到的一些问题及bug。</p><h2 id="Mysql-group-by-不区分大小写的问题"><a href="#Mysql-group-by-不区分大小写的问题" class="headerlink" title="Mysql group by 不区分大小写的问题"></a>Mysql group by 不区分大小写的问题</h2><p>在Mysql中，如果不特意指定字段，字段数据在group by时是不区分大小写的。</p><p>如下图：</p><p>对于user表，我们有4个用户，通过user_name group by之后我们只得到了两条数据。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-648.jpg" alt="upload successful"></p><p>可以看到，如果不特殊处理的话，Mysql在group by时是不区分大小写的。</p><p>解决方案有两个，都是通过<code>BINARY</code>关键字解决：</p><p><code>BINARY</code> 运算符将紧随其后的<code>string</code> 转换为 二进制字符串。</p><p>主要用来强制进行按字节进行比较的数据。这使得字符串比较是区分大小写的, 不管原始的列定义是否是 <code>BINARY</code> 或者 <code>BLOB</code>。<code>BINARY</code> 也对字符串末尾的空格敏感。</p><ol><li><p>对于查询，我们使用<code>BINARY</code> 关键字。如下图效果：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_name,<span class="keyword">COUNT</span>(<span class="number">1</span>) <span class="keyword">from</span> <span class="string">`user`</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="built_in">BINARY</span> user_name;</span><br></pre></td></tr></table></figure><p> <img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-649.jpg" alt="upload successful"></p><p> 可以看到得到了我们想要的结果。</p></li><li><p>当然也可以给表结构字段添加<code>BINARY</code>来解决，这会改变表的字符集及排序规则。</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`user`</span></span><br><span class="line"><span class="keyword">MODIFY</span> <span class="keyword">COLUMN</span> <span class="string">`user_name`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="built_in">BINARY</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户名'</span>;</span><br></pre></td></tr></table></figure><p> 得到的表结构如下，我们再进行group by查询，可以看到指定字段已经区分了大小写。</p><p> <img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-650.jpg" alt="upload successful"></p><p> 当然对于大小写敏感的字段数据，我们可以在建表的时候直接指定字段的字符集及排序规则。</p></li></ol><h2 id="List去重问题"><a href="#List去重问题" class="headerlink" title="List去重问题"></a>List去重问题</h2><ol><li><p>当然我们可以使用Set进行去重。</p></li><li><p>对于Java 8之后，我们可以使用流进行去重，如下语法：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().distinct().collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>对于对象列表的话，我们应重写对象的<code>hashCode()</code>和<code>equals()</code>方法，再使用流的<code>distinct()</code>方法来进行去重。</p><p><code>distinct()</code>方法不提供按照属性对对象列表进行去重的直接实现。它是基于<code>hashCode()</code>和<code>equals()</code>工作的。</p><p>我们如果想按照属性对对象列表进行去重，除了使用普通循环处理外，还可以构建一个我们自己的<code>Predicate</code>实例，通过流过滤来实现，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createDate;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Phone</span><span class="params">(String phone, LocalDateTime createDate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.phone = phone;</span><br><span class="line">        <span class="keyword">this</span>.createDate = createDate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Phone&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> Phone(<span class="string">"11111"</span>, LocalDateTime.of(<span class="number">2020</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">11</span>,<span class="number">00</span>,<span class="number">00</span>)));</span><br><span class="line">        list.add(<span class="keyword">new</span> Phone(<span class="string">"22222"</span>, LocalDateTime.of(<span class="number">2020</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">00</span>,<span class="number">00</span>)));</span><br><span class="line">        list.add(<span class="keyword">new</span> Phone(<span class="string">"44444"</span>, LocalDateTime.of(<span class="number">2020</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">00</span>,<span class="number">00</span>)));</span><br><span class="line">        list.add(<span class="keyword">new</span> Phone(<span class="string">"11111"</span>, LocalDateTime.of(<span class="number">2020</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">00</span>,<span class="number">00</span>)));</span><br><span class="line">        list.add(<span class="keyword">new</span> Phone(<span class="string">"22222"</span>, LocalDateTime.of(<span class="number">2020</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">11</span>,<span class="number">00</span>,<span class="number">00</span>)));</span><br><span class="line"></span><br><span class="line">        list.stream().filter(distinctByKey(Phone::getCreateDate)).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Predicate&lt;T&gt; <span class="title">distinctByKey</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ?&gt; keyExtractor)</span> </span>&#123;</span><br><span class="line">        Map&lt;Object,Boolean&gt; seen = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> t -&gt; seen.putIfAbsent(keyExtractor.apply(t), Boolean.TRUE) == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其关键方法就是<code>distinctByKey</code>方法，这个方法原理很简单，我们将对象属性放入HashMap中，通过它的<code>putIfAbsent</code>来判断是否放入成功，不成功返回false，<code>filter</code>自动过滤此对象。</p><p>上面的例子中，我们如果在对phone号码进行去重的时候，只想要时间比较新的怎么办呢？</p><p>很简单，我们只需在处理是先对流按照时间进行排序即可，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list.stream().sorted(Comparator.comparing(Phone::getCreateDate).reversed())</span><br><span class="line">                .filter(distinctByKey(Phone::getCreateDate)).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h2 id="Mysql字符集问题"><a href="#Mysql字符集问题" class="headerlink" title="Mysql字符集问题"></a>Mysql字符集问题</h2><p>我在插入Mysql数据库表情等特殊符号时遇到了如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">......Cause: java.sql.SQLException: Incorrect string value: &apos;\xF0\x9D\x91\x80\xF0\x9D...&apos; for column &apos;xxxxx&apos; at row 1......</span><br></pre></td></tr></table></figure><p>如果我们的目标表字符集设置的是<code>CHARSET=utf8mb4</code>但仍是有这种问题，可能是Mysql数据库连接的字符集不正确。</p><p>我们可以通过<code>SHOW VARIABLES LIKE ‘character_set_%’;</code>来查看当前Mysql数据库连接字符集。如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-651.jpg" alt="upload successful"></p><p>其中：</p><ul><li>character_set_client：指客户端字符集属性</li><li>character_set_connection：指连接字符集属性</li><li>character_set_database：指数据库字符集属性</li><li>character_set_filesystem：指文件系统字符集属性</li><li>character_set_results：指返回结果字符集属性</li><li>character_set_server：指服务端字符集属性</li><li>character_set_system：指系统字符集属性</li><li>character_sets_dir：指字符集路径</li></ul><p>影响我们保存和读取的主要为<code>character_set_client</code>、<code>character_set_connection</code>和<code>character_set_results</code>这三个属性。</p><p>比如下面图示，我们保存数据失败了。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-652.jpg" alt="upload successful"></p><p>这时候我们设置一下这三个属性为<code>utf8mb4</code>即可。如下:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SET</span> character_set_client = utf8mb4;</span><br><span class="line"><span class="built_in">SET</span> character_set_results = utf8mb4;</span><br><span class="line"><span class="built_in">SET</span> character_set_connection = utf8mb4;</span><br></pre></td></tr></table></figure><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-653.jpg" alt="upload successful"></p><p>PS:这时候该表的<code>CHARSET</code>需要为<code>utf8mb4</code>。</p><p>这三个设置也可以用一条设置代替。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SET</span> NAMES 'utf8mb4';</span><br></pre></td></tr></table></figure><p>需要注意的是这种设置只在本次连接中有效，当连接中断时，需要重新设置。</p><p>我们在开发时，程序调用，可以通过<code>jdbcUrl</code>进行设置。如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbc.url=jdbc:mysql://xx:xx:xxx:xxx/test?useUnicode=true&amp;amp;characterEncoding=utf8mb4</span><br></pre></td></tr></table></figure><p>出现上面异常一般的解决步骤：</p><ol><li><p>检查数据表字符集是不是<code>utf8mb4</code>，不是的话需要通过如下语句进行修改。</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name [[<span class="keyword">DEFAULT</span>] <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> charset_name] [<span class="keyword">COLLATE</span> collation_name]</span><br></pre></td></tr></table></figure></li><li><p>检查<code>character_set_client</code>、<code>character_set_connection</code>和<code>character_set_results</code>这三个属性的设置，一般情况下我们在程序里配置<code>characterEncoding=utf8mb4</code>即可。</p></li></ol><h2 id="Java-过滤-utf8mb4-字符"><a href="#Java-过滤-utf8mb4-字符" class="headerlink" title="Java 过滤 utf8mb4 字符"></a>Java 过滤 utf8mb4 字符</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 过滤utf8mb4字符</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> text</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">filterOffUtf8Mb4</span><span class="params">(String text)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = text.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(bytes.length);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; bytes.length) &#123;</span><br><span class="line">        <span class="keyword">short</span> b = bytes[i];</span><br><span class="line">        <span class="keyword">if</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            buffer.put(bytes[i++]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 去掉符号位</span></span><br><span class="line">        b += <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (((b &gt;&gt; <span class="number">5</span>) ^ <span class="number">0x6</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            buffer.put(bytes, i, <span class="number">2</span>);</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (((b &gt;&gt; <span class="number">4</span>) ^ <span class="number">0xE</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            buffer.put(bytes, i, <span class="number">3</span>);</span><br><span class="line">            i += <span class="number">3</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (((b &gt;&gt; <span class="number">3</span>) ^ <span class="number">0x1E</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            i += <span class="number">4</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (((b &gt;&gt; <span class="number">2</span>) ^ <span class="number">0x3E</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            i += <span class="number">5</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (((b &gt;&gt; <span class="number">1</span>) ^ <span class="number">0x7E</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            i += <span class="number">6</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            buffer.put(bytes[i++]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    buffer.flip();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(buffer.array(), StandardCharsets.UTF_8);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法可以过滤掉utf8mb4字符（4字节的UTF-8字符）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="工作" scheme="https://www.sakuratears.top/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Java代理模式</title>
    <link href="https://www.sakuratears.top/blog/Java%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.html"/>
    <id>https://www.sakuratears.top/blog/Java代理模式.html</id>
    <published>2020-08-02T09:36:00.000Z</published>
    <updated>2020-08-02T09:48:45.380Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>代理(Proxy)是一种设计模式，提供了间接对目标对象进行访问的方式，即通过代理对象访问目标对象。</p><p>这样做的好处是：可以在目标对象实现的功能上，增加额外的功能补充，即扩展目标对象的功能。</p><p>这就符合了设计模式的开闭原则，即在对既有代码不改动的情况下进行功能的扩展。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>我们一般认为Java中有三种代理模式：静态代理、动态代理和Cglib代理。</p><p>其中Cglib代理需要借助cglib三方jar包实现。</p><p>我们来看下三种代理模式，以及它们的一些特点。</p><p>我们下面以代码来看下代理的例子。</p><p>我们现在有一个<code>Subject</code>接口，同时有两个实现类<code>RunSubject</code>和<code>SingSubject</code>，接口中有一个方法<code>doSomething</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 做一些事</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doSomething</span><span class="params">(String str)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doSomething</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(str + <span class="string">" running..."</span>);</span><br><span class="line">        <span class="keyword">return</span> str + <span class="string">" running..."</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doSomething</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(str+<span class="string">" singing..."</span>);</span><br><span class="line">        <span class="keyword">return</span> str+<span class="string">" singing..."</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们想在<code>doSomething</code>之前和之后记录一些日志，如何实现呢。</p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>静态代理在使用时，需要定义接口或者父类，被代理对象与代理对象一起实现相同的接口或者是继承相同父类。从而实现我们想要的功能。</p><p>根据上面所说，我们可以定义一个StaticProxy类实现此功能，该类需要实现<code>Subject</code>接口，当然，我们也需要被代理对象，以实现我们<code>doSomething</code>的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkStaticProxyImpl</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 被代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Subject subject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JdkStaticProxyImpl</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doSomething</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用之前的逻辑</span></span><br><span class="line">        System.out.println(<span class="string">"在方法调用之前记录日志-----&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        String returnValue = subject.doSomething(str);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用之后的逻辑</span></span><br><span class="line">        System.out.println(<span class="string">"在方法调用之后记录日志-----&gt;"</span>);</span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subject runSubject = <span class="keyword">new</span> RunSubject();</span><br><span class="line">        Subject subject = <span class="keyword">new</span> JdkStaticProxyImpl(runSubject);</span><br><span class="line">        subject.doSomething(<span class="string">"ccc"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在方法调用之前记录日志-----&gt;</span><br><span class="line">ccc running...</span><br><span class="line">在方法调用之后记录日志-----&gt;</span><br></pre></td></tr></table></figure><p>这种代理方法优点是可以在不修改目标对象的功能前提下，对目标功能扩展。</p><p>但缺点也十分明显，上面只是对于<code>Subject</code>的代理，如果我们有其他的接口及其实现类，如果也需要该扩展功能，那么也要为其写代理类。</p><p>会导致我们会有很多代理类，且如果接口增加方法，那么我们也需要修改代理类，即便这个新增的方法可能不需要额外扩展功能。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>上面静态代理的缺点比较明显，如何解决呢？</p><p>我们可以使用动态代理，Java中为我们提供了生成代理对象的API，<code>java.lang.reflect.Proxy</code>。</p><p>实现代理需要调用<code>newProxyInstance</code>方法，它接受三个参数，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>ClassLoader loader：指定当前目标对象使用类加载器，获取加载器的方法是固定的，我们一般使用 <code>getClass().getClassLoader();</code>即可获取目标对象的类加载器。</li><li>Class&lt;?&gt;[] interfaces：目标对象实现的接口的类型，使用泛型方式确认类型，一般使用<code>getClass().getInterfaces();</code>方式取得。</li><li>InvocationHandler h：事件处理，执行目标对象的方法时，会触发事件处理器的方法，会把当前执行目标对象的方法作为参数传入。这个需要我们手动实现要实现的扩展功能。</li></ul><p>对于上面的<code>Subject</code>接口的实现类<code>RunSubject</code>和<code>SingSubject</code>，我们以代码来看下JDK动态代理如何实现功能扩展。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicProxyImpl</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object subject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JdkDynamicProxyImpl</span><span class="params">(Object subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//调用之前的逻辑</span></span><br><span class="line">        System.out.println(<span class="string">"在"</span>+method+<span class="string">"方法调用之前记录日志-----&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用</span></span><br><span class="line">        Object returnValue = method.invoke(subject, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用之后的逻辑</span></span><br><span class="line">        System.out.println(<span class="string">"在"</span>+method+<span class="string">"方法调用之后记录日志-----&gt;"</span>);</span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subject runSubject = <span class="keyword">new</span> RunSubject();</span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> JdkDynamicProxyImpl(runSubject);</span><br><span class="line">        ClassLoader loader = runSubject.getClass().getClassLoader();</span><br><span class="line">        Class[] interfaces = runSubject.getClass().getInterfaces();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Subject subject = (Subject) Proxy.newProxyInstance(loader, interfaces, handler);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"动态代理对象的类型："</span>+subject.getClass().getName());</span><br><span class="line"></span><br><span class="line">        subject.doSomething(<span class="string">"aaa"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行后如下输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">动态代理对象的类型：com.sun.proxy.$Proxy0</span><br><span class="line">在public abstract java.lang.String com.zwt.helputils.utils.proxy.Subject.doSomething(java.lang.String)方法调用之前记录日志-----&gt;</span><br><span class="line">aaa running...</span><br><span class="line">在public abstract java.lang.String com.zwt.helputils.utils.proxy.Subject.doSomething(java.lang.String)方法调用之后记录日志-----&gt;</span><br></pre></td></tr></table></figure><p>上面的<code>JdkDynamicProxyImpl</code>类，我们不仅可以用来代理<code>Subject</code>接口的实现类以实现日志增强功能，如果别的类（比如A）也想实现日志增强，那么只需要A实现一个自己的接口 AInterface 即可。</p><p>可以看到，对于一种增强，我们创建一个代理类即可，这比静态代理要方便简洁很多。</p><p>但这种动态代理有一个缺陷，就是被代理对象（目标对象）一定要实现接口，否则无法实现动态代理。</p><h2 id="Cglib代理"><a href="#Cglib代理" class="headerlink" title="Cglib代理"></a>Cglib代理</h2><p>上面的两种代理方式，也可以认为JDK传统的代理方式，目标对象必须实现接口，否则无法完成代理，但实际中，不一定所有的对象都会实现接口。</p><p>对于没有接口的对象，如果要实现对其的代理，应该如何实现呢？</p><p>我们可以使用继承目标类以目标对象子类的方式实现代理，这种方法就叫做Cglib代理，也叫作子类代理，它是在内存中构建一个子类对象从而实现对目标对象功能的扩展。</p><p>要实现Cglib代理，需要引入三方Cglib包，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/cglib/cglib --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cglib&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxyImpl</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CglibProxyImpl</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">// 回调方法</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//调用之前的逻辑</span></span><br><span class="line">        System.out.println(<span class="string">"在"</span>+method+<span class="string">"方法调用之前记录日志-----&gt;"</span>);</span><br><span class="line">        Object value = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        <span class="comment">//调用之后的逻辑</span></span><br><span class="line">        System.out.println(<span class="string">"在"</span>+method+<span class="string">"方法调用之后记录日志-----&gt;"</span>);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subject runSubject = <span class="keyword">new</span> RunSubject();</span><br><span class="line">        Subject subject1 = (Subject) <span class="keyword">new</span> CglibProxyImpl(runSubject).getInstance();</span><br><span class="line">        subject1.doSomething(<span class="string">"bbb"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在<span class="keyword">public</span> java.lang.String com.zwt.helputils.utils.proxy.RunSubject.doSomething(java.lang.String)方法调用之前记录日志-----&gt;</span><br><span class="line">bbb running...</span><br><span class="line">在<span class="keyword">public</span> java.lang.String com.zwt.helputils.utils.proxy.RunSubject.doSomething(java.lang.String)方法调用之后记录日志-----&gt;</span><br></pre></td></tr></table></figure><p>这种代理方式显然有一个缺点，就是当目标对象类是<code>final</code>的时候，我们是无法继承目标类的，因此也就无法实现Cglib代理。</p><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p>上面我们总结了3种代理方式，及其使用，对于Jdk动态代理和Cglib动态代理代码，我们可以整合成一个<code>Factory</code>，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object subject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxyFactory</span><span class="params">(Object subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"JDK"</span>:</span><br><span class="line">                <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                        subject.getClass().getClassLoader(),</span><br><span class="line">                        subject.getClass().getInterfaces(),</span><br><span class="line">                        <span class="keyword">new</span> JdkDynamicProxyImpl(subject)</span><br><span class="line">                );</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"Cglib"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> CglibProxyImpl(subject).getInstance();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"找不到指定的代理方式！！！！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subject runSubject = <span class="keyword">new</span> RunSubject();</span><br><span class="line">        Subject subject3 = (Subject) <span class="keyword">new</span> DynamicProxyFactory(runSubject).getInstance(<span class="string">"JDK"</span>);</span><br><span class="line">        subject3.doSomething(<span class="string">"1234"</span>);</span><br><span class="line">        Subject subject4 = (Subject) <span class="keyword">new</span> DynamicProxyFactory(runSubject).getInstance(<span class="string">"Cglib"</span>);</span><br><span class="line">        subject4.doSomething(<span class="string">"5678"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以选择自己适合的代理方式，Spring AOP中就有类似的代码，只不过逻辑判断等更复杂些。</p><p>在Spring AOP中，如果加入容器的目标对象有实现接口，那么就用JDK代理；如果目标对象没有实现接口，那么就用Cglib代理。</p><p>有兴趣的同学可以看下AOP的相关代码。在<code>DefaultAopProxyFactory</code>类中，部分代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAopProxyFactory</span> <span class="keyword">implements</span> <span class="title">AopProxyFactory</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line"><span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</span><br><span class="line"><span class="string">"Either an interface or a target is required for proxy creation."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//部分代码略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Cglib警告"><a href="#Cglib警告" class="headerlink" title="Cglib警告"></a>Cglib警告</h2><p>在使用Cglib进行代理的时候，我们可以看到如下警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WARNING: An illegal reflective access operation has occurred</span><br><span class="line">WARNING: Illegal reflective access by net.sf.cglib.core.ReflectUtils$1 (file:/E:/maven-localRepository/local/repo/cglib/cglib/3.3.0/cglib-3.3.0.jar) to method java.lang.ClassLoader.defineClass(java.lang.String,byte[],int,int,java.security.ProtectionDomain)</span><br><span class="line">WARNING: Please consider reporting this to the maintainers of net.sf.cglib.core.ReflectUtils$1</span><br><span class="line">WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations</span><br><span class="line">WARNING: All illegal access operations will be denied in a future release</span><br></pre></td></tr></table></figure><p>我们可以看下<code>ClassLoader.defineClass(String,byte[],int,int,ProtectionDomain)</code>这个类。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-632.jpg" alt="upload successful"></p><p>可以看到它是<code>protected final</code>的，理论上外部包是不能调用它的，那么Cglib是如何实现调用的呢。</p><p>打开Cglib的<code>ReflectUtils</code>类，我们看到下图。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-633.jpg" alt="upload successful"></p><p>可以看到它通过<code>Class.forName</code>拿到<code>java.lang.ClassLoader</code>，然后拿到<code>defineClass</code>方法，改变了其可访问性<code>defineClass.setAccessible(true);</code>。</p><p>这也就是为什么JVM会发出警告的原因，因为正常情况下我们是不被允许访问此方法的（非法反射）。</p><p>还可以看到如果拿不到该方法（被限制后，抛出异常），那么它会尝试去拿<code>sun.misc.Unsafe.defineClass</code>方法。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-634.jpg" alt="upload successful"></p><p>如果我们不想看到这个警告，可以添加 VM 参数来屏蔽它。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--illegal-access=deny</span><br></pre></td></tr></table></figure><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-635.jpg" alt="upload successful"></p><h2 id="JDK动态代理源码分析"><a href="#JDK动态代理源码分析" class="headerlink" title="JDK动态代理源码分析"></a>JDK动态代理源码分析</h2><p>我们现在来分析下JDK动态代理是如何实现的，先看<code>Proxy.newProxyInstance</code>方法。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-636.jpg" alt="upload successful"></p><p>可以看到<code>Constructor&lt;?&gt; cons = getProxyConstructor(caller, loader, interfaces);</code>用来生成了构造器，而后通过<code>newProxyInstance(caller, cons, h);</code>生成对象。</p><p>我们看一下<code>getProxyConstructor</code>这个方法。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-637.jpg" alt="upload successful"></p><p>它分为只有一个接口和实现多个接口的两种处理逻辑，我们看其中一个就行，主要是<code>new ProxyBuilder(ld, clv.key()).build()</code>这个方法，用来生成代理类。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-638.jpg" alt="upload successful"></p><p>在<code>build</code>方法里，我们看到这个调用<code>Class&lt;?&gt; proxyClass = defineProxyClass(module, interfaces);</code>，这就是生成代理类的方法。</p><p>继续跟踪<code>defineProxyClass</code>方法，如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-639.jpg" alt="upload successful"></p><p>在这个方法中，我们可以看到生成代理类字节码的方法调用<code>byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces.toArray(EMPTY_CLASS_ARRAY), accessFlags);</code></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-640.jpg" alt="upload successful"></p><p>跟踪<code>generateProxyClass</code>方法，方法里有一个参数<code>saveGeneratedFiles</code>用来是否保存生成的代理类。</p><p>正常情况下这个值是false，即不保存。</p><p>但是我们想看生成的代理类的话，由于<code>ProxyGenerator.generateProxyClass</code>类及方法本身都是<code>non-public</code>的，所以我们无法直接调用此方法生成代理类。</p><p>因此可以借助<code>saveGeneratedFiles</code>参数。</p><p>观察代码<code>saveGeneratedFiles</code>的定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** debugging flag for saving generated class files */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> saveGeneratedFiles =</span><br><span class="line">    java.security.AccessController.doPrivileged(</span><br><span class="line">        <span class="keyword">new</span> GetBooleanAction(</span><br><span class="line">            <span class="string">"jdk.proxy.ProxyGenerator.saveGeneratedFiles"</span>)).booleanValue();</span><br></pre></td></tr></table></figure><p>所以我们在 VM 变量里配置<code>-Djdk.proxy.ProxyGenerator.saveGeneratedFiles=true</code>就可以将生成的代理类保存到本地。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-641.jpg" alt="upload successful"></p><p>如上图，运行后生成的代理类在<code>com.sun.proxy</code>包下。我们打开这个代理类（IDEA自带反编译）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sun.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zwt.helputils.utils.proxy.Subject;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">doSomething</span><span class="params">(String var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m3 = Class.forName(<span class="string">"com.zwt.helputils.utils.proxy.Subject"</span>).getMethod(<span class="string">"doSomething"</span>, Class.forName(<span class="string">"java.lang.String"</span>));</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到它继承自<code>Proxy</code>并实现了我们定义的<code>Subject</code>接口。也就是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Subject subject = (Subject) Proxy.newProxyInstance(loader, interfaces, handler);</span><br></pre></td></tr></table></figure><p>实际是<code>Subject</code>接口的一个实例，我们调用<code>doSomething</code>方法，实际调用代理类<code>$Proxy0</code>的<code>doSomething</code>方法。</p><p>而在实现<code>Subject</code>接口方法的内部，通过反射调用了<code>InvocationHandler</code>实现类的<code>invoke</code>方法。</p><p>由上面内容可以看出，Java动态代理主要有以下几步：</p><ol><li>通过实现<code>InvocationHandler</code>接口创建自己的调用处理器；</li><li>通过为<code>Proxy</code>类指定<code>ClassLoader</code>对象和一组<code>interface</code>来创建动态代理类；</li><li>通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型；</li><li>通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。</li></ol><h2 id="Cglib代理源码分析"><a href="#Cglib代理源码分析" class="headerlink" title="Cglib代理源码分析"></a>Cglib代理源码分析</h2><p>我们再来看下Cglib的代理是如何实现的。根据如下方法，我们直接跟踪到<code>create</code>方法里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">    enhancer.setSuperclass(target.getClass());</span><br><span class="line">    <span class="comment">// 回调方法</span></span><br><span class="line">    enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 创建代理对象</span></span><br><span class="line">    <span class="keyword">return</span> enhancer.create();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    classOnly = <span class="keyword">false</span>;</span><br><span class="line">    argumentTypes = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> createHelper();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看一下<code>createHelper()</code>方法。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-642.jpg" alt="upload successful"></p><p>其主要方法为<code>Object result = super.create(key);</code>，用来创建代理类。其代码如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-643.jpg" alt="upload successful"></p><p>主要方法<code>Object obj = data.get(this, getUseCache());</code>用来生成代理类，<code>firstInstance((Class) obj);</code>和<code>nextInstance(obj);</code>用来生成代理对象。</p><p>先来看下<code>get</code>方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(AbstractClassGenerator gen, <span class="keyword">boolean</span> useCache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!useCache) &#123;</span><br><span class="line">        <span class="keyword">return</span> gen.generate(ClassLoaderData.<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Object cachedValue = generatedClasses.get(gen);</span><br><span class="line">        <span class="keyword">return</span> gen.unwrapCachedValue(cachedValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到它调用了<code>gen.generate(ClassLoaderData.this)</code>用于生成代理类，继续跟踪调用。</p><p>可以看到<code>generate</code>最终调用了<code>ReflectUtils.defineClass</code>去生成代理类。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-644.jpg" alt="upload successful"></p><p><code>ReflectUtils.defineClass</code>方法中利用反射调用执行<code>ClassLoader.defineClass</code>方法去生成代理类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Class <span class="title">defineClass</span><span class="params">(String className, <span class="keyword">byte</span>[] b, ClassLoader loader, ProtectionDomain protectionDomain)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class c;</span><br><span class="line">    <span class="keyword">if</span> (DEFINE_CLASS != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Object[] args = <span class="keyword">new</span> Object[]&#123;className, b, <span class="keyword">new</span> Integer(<span class="number">0</span>), <span class="keyword">new</span> Integer(b.length), protectionDomain &#125;;</span><br><span class="line">        c = (Class)DEFINE_CLASS.invoke(loader, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DEFINE_CLASS_UNSAFE != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Object[] args = <span class="keyword">new</span> Object[]&#123;className, b, <span class="keyword">new</span> Integer(<span class="number">0</span>), <span class="keyword">new</span> Integer(b.length), loader, protectionDomain &#125;;</span><br><span class="line">        c = (Class)DEFINE_CLASS_UNSAFE.invoke(UNSAFE, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CodeGenerationException(THROWABLE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Force static initializers to run.</span></span><br><span class="line">    Class.forName(className, <span class="keyword">true</span>, loader);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用VM参数来指定Cglib使代理类文件落地。如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dcglib.debugLocation=E:\\WorkSpace\\helputils\\com\\cglib</span><br></pre></td></tr></table></figure><p>这个参数也可以通过代码设置，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, <span class="string">"E:\\WorkSpace\\helputils\\com\\cglib"</span>);</span><br></pre></td></tr></table></figure><p>我们运行下Test，可以看到生成如下类。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-645.jpg" alt="upload successful"></p><p>我们重点关注中间那个类，这个类继承<code>RunSubject</code>，这也印证了我们上面所说，Cglib是依靠继承目标类来实现代理的。</p><p>这个类代码比较多，我就不粘上来了，我们用图片看下它的几个关键部分。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-646.jpg" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-647.jpg" alt="upload successful"></p><p>由上面内容我们可以看到Cglib代理的几个步骤：</p><ol><li>通过实现<code>MethodInterceptor (extends Callback)</code>接口（或者自己实现<code>CallBack</code>接口）创建自己回调类；</li><li>通过<code>Enhancer</code>类指定目标类为超类<code>superClass</code>，并指定我们上面的回调类；</li><li>通过反射机制实现对目标类的继承，创建代理类；</li><li>代理类在调用指定方法时，如果需要回调，会通过反射拿到回调类要执行的内容；如果没有回调类，会直接执行目标类指定方法。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是关于代理模式的全部内容，我们也分析了各种代理模式的一些特点及原理。</p><p>实际中主要常用的就是JDK动态代理和Cglib代理。</p><p>JDK动态代理，是Java自带的代理模式，无需依赖，也没有警告等信息，唯一缺点就是需要目标类实现接口，只能对实现接口的类进行代理。</p><p>Cglib代理，内部使用asm，直接修改字节码进行增强子类，也就是通过继承的方式进行代理，不关心目标类是否继承接口，但是无法处理<code>final</code>的类（无法被继承）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="代理模式" scheme="https://www.sakuratears.top/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal</title>
    <link href="https://www.sakuratears.top/blog/ThreadLocal.html"/>
    <id>https://www.sakuratears.top/blog/ThreadLocal.html</id>
    <published>2020-07-30T14:51:00.000Z</published>
    <updated>2020-07-30T14:58:33.734Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>ThreadLocal</code>是一个本地线程副本变量存储工具类。主要用于将一个线程和该线程存放的副本对象做一个映射（Map），各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不同的变量值完成操作的场景。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>我们根据代码了解下<code>ThreadLocal</code>。</p><p>在了解<code>ThreadLocal</code>之前，我们先带着几个问题：</p><ol><li><code>ThreadLocal</code>的每个线程的私有变量保存在哪里？</li><li>大家说的关于<code>ThreadLocal</code>使用不当会发生内存泄露又是怎么回事？</li><li><code>ThreadLocal</code>弱引用导致内存泄露又是怎么回事？为什么要使用弱引用？</li><li>对于可能出现的内存泄露，<code>ThreadLocal</code>本身有哪些优化？我们编码时应该如何避免内存泄露？</li><li><code>ThreadLocal</code>的应用场景？</li></ol><p>首先我们先来看下<code>ThreadLocal</code>的几个重要方法。</p><h2 id="ThreadLocal的主要方法"><a href="#ThreadLocal的主要方法" class="headerlink" title="ThreadLocal的主要方法"></a>ThreadLocal的主要方法</h2><p><code>ThreadLocal</code>有三个重要方法，如下：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public T get()</td><td>该方法用于获取线程本地变量副本</td></tr><tr><td>public void set(T value)</td><td>该方法用于设置线程本地变量副本</td></tr><tr><td>public void remove()</td><td>该方法用于移除线程本地变量副本</td></tr></tbody></table><p>三个方法的相关源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面<code>get()</code>方法的源码可以看到，本地变量副本是由一个叫<code>ThreadLocalMap</code>的对象维护的，我们看一下<code>getMap(t)</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//.........部分代码略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment">     * by the ThreadLocal class. */</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.........部分代码略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在<code>Thread</code>类里维护着一个<code>ThreadLocalMap</code>，该线程的本地变量副本就会存到这儿。</p><p>再来看下这个变量赋予初始值的过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们通过<code>set</code>方法设置本地变量副本时，如果<code>ThreadLocalMap</code>为<code>null</code>，就会调用<code>createMap</code>将初始值放入。</p><p>而对于<code>get</code>方法，如果<code>ThreadLocalMap</code>为<code>null</code>，就会调用<code>setInitialValue</code>方法，最终调用<code>createMap</code>方法，此时初始值为<code>null</code>。</p><p>我们继续看下<code>ThreadLocalMap</code>的相关源码。</p><h2 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h2><p><code>ThreadLocalMap</code>的主要代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">        table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">        <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">        table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        setThreshold(INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//.....部分代码略</span></span><br></pre></td></tr></table></figure><p>可以看到<code>ThreadLocalMap</code>内部是通过<code>Entry</code>的value来维护变量副本的，其key为<code>ThreadLocal</code>本身。</p><p>而且<code>Entry</code>的key为<strong>弱引用（WeakReference）</strong>。</p><h2 id="关于Java引用"><a href="#关于Java引用" class="headerlink" title="关于Java引用"></a>关于Java引用</h2><p>Java中的引用按照引用强度不同分为四种，从强到弱依次为：强引用、软引用、弱引用和虚引用。</p><p>引用的强度，代表了对内存占用的能力大小，具体体现在GC的时候，会不会被回收，什么时候被回收。</p><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>我们一般很少提及它，但它无处不在。其实我们创建一个对象便是强引用，如<code>StringBuffer buffer = new StringBuffer();</code>。</p><p>HotSpot JVM目前的垃圾回收算法一般默认是可达性算法，即在每一轮GC的时候，选定一些对象作为GC ROOT，然后以它们为根发散遍历，遍历完成之后，如果一个对象不被任何GC ROOT引用，那么它就是不可达对象，则在接下来的GC过程中很可能会被回收。</p><p>如果我们在垃圾回收时还有对buffer的引用，那么它便不会被垃圾回收器回收。</p><h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>软引用是用来描述一些还有用但是并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收返回之后进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。JDK1.2之后提供了<code>SoftReference</code>来实现软引用。</p><p>相对于强引用，软引用在内存充足时可能不会被回收，在内存不够时会被回收。</p><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>弱引用也是用来描述非必须的对象的，但它的强度更弱，被弱引用关联的对象只能生存到下一次GC发生之前，也就是说下一次GC就会被回收。JDK1.2之后，提供了<code>WeakReference</code>来实现弱引用。</p><h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>虚引用也成为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间造成影响，也无法通过虚引用来取得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是在这个对象被GC时收到一个系统通知。JDK1.2之后提供了<code>PhantomReference</code>来实现虚引用。</p><h2 id="ThreadLocal内存模型"><a href="#ThreadLocal内存模型" class="headerlink" title="ThreadLocal内存模型"></a>ThreadLocal内存模型</h2><p>由上面内容，下面<code>ThreadLocal</code>的内存模型也是比较好理解的。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-628.jpg" alt="upload successful"></p><ul><li><p>线程运行时，我们定义的<code>ThreadLocal</code>对象被初始化，存储在<code>Heap</code>，同时线程运行的栈区保存了指向该实例的引用，也就是图中的<code>ThreadLocalRef</code>。</p></li><li><p>当<code>ThreadLocal</code>的<code>set/get</code>被调用时，虚拟机会根据当前线程的引用也就是<code>CurrentThreadRef</code>找到其对应在堆区的实例，然后查看其对用的<code>ThreadLocalMap</code>实例是否被创建，如果没有，则创建并初始化。</p></li><li><p><code>Map</code>实例化之后，也就拿到了该<code>ThreadLocalMap</code>的句柄，然后如果将当前<code>ThreadLocal</code>对象作为<code>key</code>，进行存取操作。</p></li><li><p>图中的虚线，表示<code>key</code>对<code>ThreadLocal</code>实例的引用是个弱引用。</p></li></ul><h2 id="内存泄露分析"><a href="#内存泄露分析" class="headerlink" title="内存泄露分析"></a>内存泄露分析</h2><p>根据上面内容，我们可以知道 <code>ThreadLocal</code>是被<code>ThreadLocalMap</code>以弱引用的方式关联着，因此如果<code>ThreadLocal</code>没有被<code>ThreadLocalMap</code>以外的对象引用，则在下一次GC的时候，<code>ThreadLocal</code>实例就会被回收，那么此时<code>ThreadLocalMap</code>里的一组<code>Entry</code>的K就是<code>null</code>了，因此在没有额外操作的情况下，此处的V便不会被外部访问到，而且只要<code>Thread</code>实例一直存在，<code>Thread</code>实例就强引用着<code>ThreadLocalMap</code>，因此<code>ThreadLocalMap</code>就不会被回收，那么这里K为<code>null</code>的V就一直占用着内存。</p><p>因此发生内存泄露的条件是：</p><ul><li><code>ThreadLocal</code>没有被外部强引用；</li><li><code>ThreadLocal</code>实例被回收；</li><li>但是<code>Thread</code>实例一直存活，一直强引用着<code>ThreadLocalMap</code>，也就是说<code>ThreadLocalMap</code>也不会被GC。</li></ul><p>也就是说，如果<code>ThreadLocal</code>使用不当，是有可能发生内存泄露的。</p><blockquote><p>我们这里说的内存泄露，指的是开发者使用不当造成的，而非<code>ThreadLocal</code>本身的问题。</p></blockquote><p>一个典型的例子就是线程池，如果我们在线程池的task里实例化了<code>ThreadLocal</code>对象，线程使用完后，回归线程池，但是本身并不会结束，但是task任务结束了，对<code>ThreadLocal</code>的强引用结束了，这时候在<code>ThreadLocalMap</code>中的<code>value</code>没有被任何清理机制有效清理。</p><p>我们可以模拟这种内存泄露情况，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个定长线程池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> k = a;</span><br><span class="line">            executorService.submit(()-&gt;&#123;</span><br><span class="line">                System.out.println(<span class="string">"线程ID："</span> + Thread.currentThread().getId());</span><br><span class="line">                ThreadLocal&lt;Integer&gt; t = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">                t.set(k);</span><br><span class="line">                System.out.println(<span class="string">"Value:"</span>+ t.get());</span><br><span class="line">            &#125;);</span><br><span class="line">            a+=<span class="number">1</span>;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//            MemoryMXBean mem =  ManagementFactory.getMemoryMXBean();</span></span><br><span class="line"><span class="comment">//            System.out.println("USED RAM：" + mem.getHeapMemoryUsage().getUsed() / 1024 / 1024 + "MB");</span></span><br><span class="line">        &#125;<span class="keyword">while</span> (a &lt; <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，我们模拟了一个长度为1的定长线程池（为了简化），这个线程池只有一个线程，我们在task里创建了<code>ThreadLocal</code>对象，当task结束后，实际<code>Thread</code>是还存活的。</p><p>我们通过<code>debug</code>模式，执行若干次，可以看到<code>ThreadLocalMap</code>里那些无用的<code>value</code>，如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-629.jpg" alt="upload successful"></p><p>这实际上就发生了内存泄露问题。</p><p>其实，我们调用<code>ThreadLocal</code>里提供的<code>remove</code>方法，变会完全解决这个问题。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-631.jpg" alt="upload successful"></p><p>如上图，我们如果使用完后添加<code>remove</code>方法删除变量副本，可以看到无论运行多少次，也不会出现内存泄露问题。</p><blockquote><p>不要觉得这个内存泄露条件自己不会碰到，实际上无论Http，数据库连接等都有线程池的概念，我们每一段代码如果使用<code>ThreadLocal</code>都可能成为task那段的一部分，使用不好就可能出现内存泄露问题。</p><p>因此在日常编码中一定要养成良好的编码习惯。</p></blockquote><h2 id="ThreadLocal的优化"><a href="#ThreadLocal的优化" class="headerlink" title="ThreadLocal的优化"></a>ThreadLocal的优化</h2><p>如果上面那个内存泄露的例子我们多运行一段时间，跟着<code>debug</code>，会发现<code>ThreadLocalMap</code>并不会一直增长的。</p><p>如下图，可以看到一些无用数据会自动消失。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-630.gif" alt="upload successful"></p><p>这是因为<code>ThreadLocal</code>本身的优化，在<code>ThreadLocalMap</code>的<code>getEntry</code>方法里，我们可以看到如下方法<code>getEntryAfterMiss</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">        Entry e = table[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>是的，这个方法就是找不到<code>Entry</code>的处理方法，该方法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == key)</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">                expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                i = nextIndex(i, len);</span><br><span class="line">            e = tab[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个方法一个关键部分就是<code>k == null</code>时调用<code>expungeStaleEntry</code>方法，用来删除旧的<code>Entry</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">        tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">        tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">        Entry e;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">                (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">                i = nextIndex(i, len)) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.value = <span class="keyword">null</span>;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line">                size--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                    tab[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                    <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                    <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                        h = nextIndex(h, len);</span><br><span class="line">                    tab[h] = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>主要逻辑如下：</p><ol><li><p>清理当前脏<code>entry</code>，即将其<code>value</code>引用置为<code>null</code>，并且将<code>table[staleSlot]</code>也置为<code>null</code>。<code>value</code>置为<code>null</code>后该<code>value</code>域变为不可达，在下一次gc的时候就会被回收掉，同时<code>table[staleSlot]</code>为<code>null</code>后以便于存放新的<code>entry</code>;</p></li><li><p>从当前<code>staleSlot</code>位置向后环形（<code>nextIndex</code>）继续搜索，直到遇到哈希桶（<code>tab[i]</code>）为<code>null</code>的时候退出；</p></li><li><p>若在搜索过程再次遇到脏<code>entry</code>，继续将其清除。</p></li></ol><p>除了该方法外，我们在<code>set</code>方法里可以看到对脏<code>entry</code>的处理，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> len = tab.length;</span><br><span class="line">        <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">                e != <span class="keyword">null</span>;</span><br><span class="line">                e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                e.value = value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                replaceStaleEntry(key, value, i);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">        <span class="keyword">int</span> sz = ++size;</span><br><span class="line">        <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">            rehash();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在该方法中针对脏<code>entry</code>做了这样的处理：</p><ol><li><p>如果当前<code>table[i]！=null</code>的话说明hash冲突就需要向后环形查找，若在查找过程中遇到脏<code>entry</code>就通过<code>replaceStaleEntry</code>进行处理；</p></li><li><p>如果当前<code>table[i]==null</code>的话说明新的<code>entry</code>可以直接插入，但是插入后会调用<code>cleanSomeSlots</code>方法检测并清除脏<code>entry</code></p></li></ol><p>我们先来看下<code>replaceStaleEntry</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Back up to check for prior stale entry in current run.</span></span><br><span class="line">    <span class="comment">// We clean out whole runs at a time to avoid continual</span></span><br><span class="line">    <span class="comment">// incremental rehashing due to garbage collector freeing</span></span><br><span class="line">    <span class="comment">// up refs in bunches (i.e., whenever the collector runs).</span></span><br><span class="line">    <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</span><br><span class="line">            (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">            i = prevIndex(i, len))</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find either the key or trailing null slot of run, whichever</span></span><br><span class="line">    <span class="comment">// occurs first</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">            (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">            i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we find key, then we need to swap it</span></span><br><span class="line">        <span class="comment">// with the stale entry to maintain hash table order.</span></span><br><span class="line">        <span class="comment">// The newly stale slot, or any other stale slot</span></span><br><span class="line">        <span class="comment">// encountered above it, can then be sent to expungeStaleEntry</span></span><br><span class="line">        <span class="comment">// to remove or rehash all of the other entries in run.</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line"></span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Start expunge at preceding stale entry if it exists</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If we didn't find stale entry on backward scan, the</span></span><br><span class="line">            <span class="comment">// first stale entry seen while scanning for key is the</span></span><br><span class="line">            <span class="comment">// first still present in the run.</span></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If key not found, put new entry in stale slot</span></span><br><span class="line">        tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">        tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If there are any other stale entries in run, expunge them</span></span><br><span class="line">        <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分代码通过<code>PreIndex</code>方法实现往前环形搜索脏<code>entry</code>的功能，初始时<code>slotToExpunge</code>和<code>staleSlot</code>相同，若在搜索过程中发现了脏<code>entry</code>，则更新<code>slotToExpunge</code>为当前索引<code>i</code>。另外，说明<code>replaceStaleEntry</code>并不仅仅局限于处理当前已知的脏<code>entry</code>，它认为在出现脏<code>entry</code>的相邻位置也有很大概率出现脏<code>entry</code>，所以为了一次处理到位，就需要向前环形搜索，找到前面的脏<code>entry</code>。</p><p>我们再来看下<code>cleanSomeSlots</code>方法的调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cleanSomeSlots</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        i = nextIndex(i, len);</span><br><span class="line">        Entry e = tab[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            n = len;</span><br><span class="line">            removed = <span class="keyword">true</span>;</span><br><span class="line">            i = expungeStaleEntry(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法用来清除一些脏<code>entry</code>，其扫描次数通过<code>n</code>来控制，可以看到<code>n &gt;&gt;&gt;= 1</code>表示每次<code>n</code>除以2进行减小范围搜索，当遇到脏<code>entry</code>时，<code>n = len</code>，就会扩大搜索范围。如果在整个搜索过程没遇到脏entry的话，搜索结束，采用这种方式的主要是用于时间效率上的平衡。</p><h2 id="为什么使用弱引用？"><a href="#为什么使用弱引用？" class="headerlink" title="为什么使用弱引用？"></a>为什么使用弱引用？</h2><p>根据上面的内容，我们来分析下为什么<code>ThreadLocal</code>要使用弱引用。</p><p>假设<code>ThreadLocal</code>使用的是强引用，在业务代码中执行<code>threadLocalInstance==null</code>操作，以清理掉<code>ThreadLocal</code>实例的目的，但是因为<code>ThreadLocalMap</code>的<code>Entry</code>强引用<code>ThreadLocal</code>，因此在gc的时候进行可达性分析，<code>ThreadLocal</code>依然可达，对<code>ThreadLocal</code>并不会进行垃圾回收，这样就无法真正达到业务逻辑的目的，出现逻辑错误。</p><p>假设<code>Entry</code>弱引用<code>ThreadLocal</code>，尽管会出现内存泄漏的问题，但是在<code>ThreadLocal</code>的生命周期里（<code>set,get,remove</code>）里，都会针对<code>key</code>为<code>null</code>的脏<code>Entry</code>进行处理。</p><p>从以上的分析可以看出，使用弱引用的话在<code>ThreadLocal</code>生命周期里会尽可能的保证不出现内存泄漏的问题，达到安全的状态。而且只要我们规范代码，就可以避免内存泄露问题。</p><h2 id="线程退出"><a href="#线程退出" class="headerlink" title="线程退出"></a>线程退出</h2><p>在<code>Thread</code>源码里，我们可以看到<code>exit</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (group != <span class="keyword">null</span>) &#123;</span><br><span class="line">        group.threadTerminated(<span class="keyword">this</span>);</span><br><span class="line">        group = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Aggressively null out all reference fields: see bug 4006245 */</span></span><br><span class="line">    target = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/* Speed the release of some of these resources */</span></span><br><span class="line">    threadLocals = <span class="keyword">null</span>;</span><br><span class="line">    inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line">    inheritedAccessControlContext = <span class="keyword">null</span>;</span><br><span class="line">    blocker = <span class="keyword">null</span>;</span><br><span class="line">    uncaughtExceptionHandler = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到线程退出后，<code>threadLocals</code>变为<code>null</code>，也就意味着GC可以将<code>ThreadLocalMap</code>进行垃圾回收。</p><h2 id="ThreadLocal应用场景"><a href="#ThreadLocal应用场景" class="headerlink" title="ThreadLocal应用场景"></a>ThreadLocal应用场景</h2><p><code>ThreadLocal</code>在一些开源框架下有着广泛应用。</p><ol><li><p>Spring的事务管理</p><p>在Spring事务管理相关类<code>TransactionAspectSupport</code>代码中，我们可以找到这段代码.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...部分代码略</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;TransactionInfo&gt; transactionInfoHolder =</span><br><span class="line"><span class="keyword">new</span> NamedThreadLocal&lt;TransactionInfo&gt;(<span class="string">"Current aspect-driven transaction"</span>);</span><br><span class="line"><span class="comment">//...部分代码略</span></span><br></pre></td></tr></table></figure><p>其目的就是用来存储当前事务相关信息。</p></li><li><p>Logback中的使用</p><p>在<code>Logback</code>的<code>LogbackMDCAdapter</code>相关代码中，也有<code>ThreadLocal</code>的使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...部分代码略</span></span><br><span class="line"><span class="keyword">final</span> ThreadLocal&lt;Map&lt;String, String&gt;&gt; copyOnThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Map&lt;String, String&gt;&gt;();</span><br><span class="line"><span class="keyword">final</span> ThreadLocal&lt;Integer&gt; lastOperation = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;();</span><br><span class="line"><span class="comment">//...部分代码略</span></span><br></pre></td></tr></table></figure></li><li><p>在<code>tomcat</code>相关代码中，<code>org.apache.catalina.core.ApplicationContext</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...部分代码略</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Thread local data used during request dispatch.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;DispatchData&gt; dispatchData = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"> <span class="comment">//...部分代码略</span></span><br></pre></td></tr></table></figure></li><li><p>如果要配置多数据源，我们可以使用<code>ThreadLocal</code>来进行数据源key的切换管理。</p><p> 可以看下这篇文章<a href="https://www.sakuratears.top/blog/SpringBoot%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE.html">SpringBoot多数据源配置</a></p></li></ol><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>我们对<code>Threadlocal</code>进行了详细介绍，除了了解它的主要原理，解决项目中遇到的一些问题外，更要使用好它，每次使用完<code>Threadlocal</code>，应调用<code>remove</code>方法清除数据。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.jianshu.com/p/dde92ec37bd1" rel="external nofollow noopener noreferrer" target="_blank">一篇文章，从源码深入详解ThreadLocal内存泄漏问题</a></li><li><a href="https://www.jianshu.com/p/1a5d288bdaee" rel="external nofollow noopener noreferrer" target="_blank">ThreadLocal小结-到底会不会引起内存泄露</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="ThreadLocal" scheme="https://www.sakuratears.top/tags/ThreadLocal/"/>
    
  </entry>
  
  <entry>
    <title>Java类加载器</title>
    <link href="https://www.sakuratears.top/blog/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.html"/>
    <id>https://www.sakuratears.top/blog/Java类加载器.html</id>
    <published>2020-07-26T13:43:00.000Z</published>
    <updated>2020-07-26T13:48:19.841Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>类加载器是<code>Java</code>语言的一个创新，也是<code>Java</code>语言流行的重要原因之一。它使得<code>Java</code> 类可以被动态加载到 <code>Java</code> 虚拟机中并执行。</p><p>一般来说，<code>Java</code> 应用的开发人员不需要直接同类加载器进行交互。<code>Java</code> 虚拟机默认的行为就已经足够满足大多数情况的需求了。不过如果遇到了需要与类加载器进行交互的情况，而对类加载器的机制又不是很了解的话，就很容易花大量的时间去调试 <code>ClassNotFoundException</code> 和 <code>NoClassDefFoundError</code> 等异常。</p><p>下面我们来了解类加载器的一些概念，来使我们更好地认识类加载器。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>类加载器（class loader）是用来加载 <code>Java</code> 类到 <code>Java</code> 虚拟机中的。</p><p>一般来说，<code>Java</code> 虚拟机使用 <code>Java</code> 类的方式如下：</p><ol><li><code>Java</code> 源程序（.java 文件）在经过 <code>Java</code> 编译器编译之后就被转换成 <code>Java</code> 字节代码（.class 文件）。</li><li>类加载器负责读取 <code>Java</code> 字节代码，并转换成 <code>java.lang.Class</code> 类的一个实例。每个这样的实例用来表示一个 <code>Java</code> 类。</li><li>通过此实例的 <code>newInstance()</code> 方法就可以创建出该类的一个对象。</li></ol><p>PS: 实际的情况可能更加复杂，比如 <code>Java</code> 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。</p><h2 id="java-lang-ClassLoader"><a href="#java-lang-ClassLoader" class="headerlink" title="java.lang.ClassLoader"></a>java.lang.ClassLoader</h2><p>基本上所有的类加载器都是 <code>java.lang.ClassLoader</code> 类的一个实例。</p><p><code>java.lang.ClassLoader</code> 类的基本职责就是根据一个指定的类的名称，找到或者生成其对应的字节代码，然后从这些字节代码中定义出一个 <code>Java</code> 类，即 <code>java.lang.Class</code> 类的一个实例。</p><p>除此之外， <code>ClassLoader</code> 还负责加载 <code>Java</code> 应用所需的资源，如图像文件和配置文件等。</p><p>下面我们主要看下这个类中与加载类相关的方法。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>getParent()</td><td>返回该类加载器的父类加载器。</td></tr><tr><td>loadClass(String name)</td><td>加载名称为 name 的类，返回的结果是 java.lang.Class 类的实例。</td></tr><tr><td>findClass(String name)</td><td>查找名称为 name 的类，返回的结果是 java.lang.Class 类的实例。</td></tr><tr><td>findLoadedClass(String name)</td><td>查找名称为 name 的已经被加载过的类，返回的结果是 java.lang.Class 类的实例。</td></tr><tr><td>defineClass(String name, byte[] b, int off, int len)</td><td>把字节数组 b 中的内容转换成 Java 类，返回的结果是 java.lang.Class 类的实例。这个方法被声明为 final 的。</td></tr><tr><td>resolveClass(Class&lt;?&gt; c)</td><td>链接指定的 Java 类。</td></tr></tbody></table><h2 id="类加载器的树状组织结构"><a href="#类加载器的树状组织结构" class="headerlink" title="类加载器的树状组织结构"></a>类加载器的树状组织结构</h2><p><code>Java</code> 中的类加载器大致可以分成两类，一类是系统提供的，另外一类则是由 <code>Java</code> 应用开发人员编写的。系统提供的类加载器主要有下面三个：</p><ul><li><p><strong>引导类加载器（BootstrapClassLoader）</strong>：它用来加载 <code>Java</code> 的核心库，是用原生代码（C++）来实现的，并不继承自 <code>java.lang.ClassLoader</code> 。</p></li><li><p><strong>扩展类/平台类加载器（ExtClassLoader/PlatformClassLoader）</strong>：扩展类加载器在<code>JDK1.8</code>之后变为平台类加载器。从<code>JDK1.8</code>之后的版本(<code>JDK9,JDK10</code>)提供有一个”<code>PlatformClassLoader</code>“类加载器，而在<code>JDK1.8</code>以前的版本里面提供的加载器为”<code>ExtClassLoader</code>“，因为在JDK的安装目录里面提供有一个<code>ext</code>目录，开发者可以将<code>*.jar</code>文件拷贝到此目录里面，这样就可以直接执行了，但是这样的处理并不安全。最初的时候也是不提倡使用的。所以在<code>JDK9</code>开始就将这样的操作彻底废除了，同时为了与系统类加载器和应用类加载器之间保持设计的平衡，提供了平台类加载器。</p></li><li><p><strong>系统类/应用类加载器（SystemClassLoader/AppClassLoader）</strong>：它根据 <code>Java</code> 应用的类路径（CLASSPATH）来加载 <code>Java</code> 类。一般来说，<code>Java</code> 应用的类都是由它来完成加载的。可以通过 <code>ClassLoader.getSystemClassLoader()</code> 来获取它。</p></li></ul><p>除了系统提供的类加载器以外，我们可以通过继承 <code>java.lang.ClassLoader</code> 类的方式实现自己的类加载器，以满足一些特殊的需求。</p><p>除了引导类加载器之外，所有的类加载器都有一个父类加载器。通过 <code>java.lang.ClassLoader</code> 类的 <code>getParent()</code> 方法可以得到。</p><p>对于系统提供的类加载器来说，系统类加载器的父类加载器是扩展类加载器，而扩展类加载器的父类加载器是引导类加载器；对于我们编写的类加载器来说，其父类加载器是加载此类加载器 <code>Java</code> 类的类加载器。因为类加载器 <code>Java</code> 类如同其它的 <code>Java</code> 类一样，也是要由类加载器来加载的。一般来说，我们编写的类加载器的父类加载器是系统类加载器。类加载器通过这种方式组织起来，形成树状结构。树的根节点就是引导类加载器，如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-627.jpg" alt="upload successful"></p><p>我们提供Java代码来看下类加载器的结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassLoader loader = Test.class.getClassLoader();</span><br><span class="line">        <span class="keyword">while</span> (loader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(loader.toString());</span><br><span class="line">            loader = loader.getParent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会有如下输出（JDK1.8及以上）:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jdk.internal.loader.ClassLoaders$AppClassLoader@726f3b58</span><br><span class="line">jdk.internal.loader.ClassLoaders$PlatformClassLoader@368239c8</span><br></pre></td></tr></table></figure></p><blockquote><p>需要注意的是这里并没有输出引导类加载器，这是由于有些 <code>JDK</code> 的实现对于父类加载器是引导类加载器的情况， <code>getParent()</code> 方法返回 <code>null</code> 。</p></blockquote><h2 id="类加载器的代理模式（双亲委派机制）"><a href="#类加载器的代理模式（双亲委派机制）" class="headerlink" title="类加载器的代理模式（双亲委派机制）"></a>类加载器的代理模式（双亲委派机制）</h2><p>类加载器在尝试自己去查找某个类的字节代码并定义它时，会先代理（委托）给其父类加载器，由父类加载器先去尝试加载这个类，依次类推。</p><p>代理模式（委托模式）第一这样可以避免重复加载，第二是为了保证 <code>Java</code> 核心库的类型安全。所有 <code>Java</code> 应用都至少需要引用 <code>java.lang.Object</code> 类，也就是说在运行的时候， <code>java.lang.Object</code>这个类需要被加载到 <code>Java</code> 虚拟机中。如果这个加载过程由 <code>Java</code> 应用自己的类加载器来完成的话，很可能就存在多个版本的 <code>java.lang.Object</code> 类，而且这些类之间是不兼容的。通过代理模式，对于 <code>Java</code> 核心库的类的加载工作由引导类加载器来统一完成，保证了 <code>Java</code> 应用所使用的都是同一个版本的 <code>Java</code> 核心库的类，是互相兼容的。</p><p>不同的类加载器为相同名称的类创建了额外的名称空间。相同名称的类可以并存在 <code>Java</code> 虚拟机中，只需要用不同的类加载器来加载它们即可。不同类加载器加载的类之间是不兼容的，这就相当于在 <code>Java</code> 虚拟机内部创建了一个个相互隔离的 <code>Java</code> 类空间。</p><p>在<code>ClassLoader</code>类的<code>loadClass</code>方法，我们可以看到这种委派机制，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">//首先从jvm缓存查找该类</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//父类加载器不为空，委托给父类加载器进行加载</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果父类加载器为null,则委托给BootStrap加载器加载</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 若仍然没有找到则调用findclass查找该类</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其大致流程如下：</p><ol><li><p>从 <code>JVM</code> 缓存查找该类，如果该类之前被加载过，则直接从 <code>JVM</code> 缓存返回该类。</p></li><li><p>如果 <code>JVM</code> 缓存不存在该类，则看当前类加载器是否有父加载器，如果有的话则委托父类加载器进行加载，否则委托 <code>BootStrapClassloader</code> 进行加载，如果还是没有找到，则调用当前 <code>Classloader</code> 的 <code>findclass</code> 方法进行查找。</p></li><li><p>从本地<code>Classloader</code>指定路径进行查找，其中<code>findClass</code>方法在路径找到<code>Class</code>文件会加载二进制字节码到内存，然后后会调用<code>native</code>方法<code>defineClass1</code>解析字节码为<code>JVM</code>内部的<code>kclass</code>对象，然后存放到<code>Java</code>堆的方法区。</p></li><li><p>如果需要链接<code>resolve=true</code>，则当字节码加载到内存后进行链接操作，对文件格式和字节码验证，并为 <code>static</code> 字段分配空间并初始化，符号引用转为直接引用，访问控制，方法覆盖等。</p></li></ol><h2 id="加载类的过程"><a href="#加载类的过程" class="headerlink" title="加载类的过程"></a>加载类的过程</h2><p>在前面介绍类加载器的代理模式的时候，提到过类加载器会首先代理给其它类加载器来尝试加载某个类。</p><p>这就意味着真正完成类的加载工作的类加载器和启动这个加载过程的类加载器，有可能不是同一个。</p><p>真正完成类的加载工作是通过调用 <code>defineClass</code> 来实现的；而启动类的加载过程是通过调用 <code>loadClass</code> 来实现的。前者称为一个类的定义加载器（defining loader），后者称为初始加载器（initiating loader）。</p><p>在 <code>Java</code> 虚拟机判断两个类是否相同的时候，使用的是类的定义加载器。</p><p>也就是说，哪个类加载器启动类的加载过程并不重要，重要的是最终定义这个类的加载器。两种类加载器的关联之处在于：一个类的定义加载器是它引用的其它类的初始加载器。</p><p>如类 <code>com.example.Outer</code> 引用了类 <code>com.example.Inner</code> ，则由类 <code>com.example.Outer</code> 的定义加载器负责启动类 <code>com.example.Inner</code> 的加载过程。</p><p>方法 <code>loadClass()</code> 抛出的是 <code>java.lang.ClassNotFoundException</code> 异常；方法 <code>defineClass()</code> 抛出的是 <code>java.lang.NoClassDefFoundError</code> 异常。</p><p>类加载器在成功加载某个类之后，会把得到的 <code>java.lang.Class</code> 类的实例缓存起来。下次再请求加载该类的时候，类加载器会直接使用缓存的类的实例，而不会尝试再次加载。</p><p>也就是说，对于一个类加载器实例来说，相同全名的类只加载一次，即 <code>loadClass</code> 方法不会被重复调用。</p><h2 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h2><p>线程上下文类加载器（context class loader）是从 JDK 1.2 开始引入的。</p><p>类 <code>java.lang.Thread</code> 中的方法 <code>getContextClassLoader()</code> 和 <code>setContextClassLoader(ClassLoader cl)</code> 用来获取和设置线程的上下文类加载器。如果没有通过 <code>setContextClassLoader(ClassLoader cl)</code> 方法进行设置的话，线程将继承其父线程的上下文类加载器。</p><p><code>Java</code>应用运行的初始线程的上下文类加载器是系统类加载器。在线程中运行的代码可以通过此类加载器来加载类和资源。</p><p>线程上下文类加载器所解决的问题：</p><p><code>Java</code> 提供了很多服务提供者接口（Service Provider Interface，SPI），允许第三方为这些接口提供实现。常见的 SPI 有 <code>JDBC、JCE、JNDI、JAXP 和 JBI</code> 等。这些 SPI 的接口由 <code>Java</code> 核心库来提供，这些 SPI 的实现代码很可能是作为 <code>Java</code> 应用所依赖的 <code>jar</code> 包被包含进来，可以通过类路径（CLASSPATH）来找到。而问题在于，SPI 的接口是 <code>Java</code> 核心库的一部分，是由引导类加载器来加载的；SPI 实现的 <code>Java</code> 类一般是由系统类加载器来加载的。引导类加载器是无法找到 SPI 的实现类的，因为它只加载 <code>Java</code> 的核心库。它也不能代理给系统类加载器，因为它是系统类加载器的祖先类加载器。也就是说，类加载器的代理模式无法解决这个问题。</p><p>线程上下文类加载器正好解决了这个问题。如果不做任何的设置，<code>Java</code> 应用的线程的上下文类加载器默认就是系统上下文类加载器。在 SPI 接口的代码中使用线程上下文类加载器，就可以成功的加载到 SPI 实现的类。线程上下文类加载器在很多 SPI 的实现中都会用到。</p><h2 id="Class-forName"><a href="#Class-forName" class="headerlink" title="Class.forName"></a>Class.forName</h2><p><code>Class.forName</code> 是一个静态方法，同样可以用来加载类。</p><p>该方法有两种形式：<code>Class.forName(String name, boolean initialize, ClassLoader loader)</code> 和 <code>Class.forName(String className)</code> 。</p><p>第一种形式的参数 <code>name</code> 表示的是类的全名； <code>initialize</code> 表示是否初始化类；<code>loader</code> 表示加载时使用的类加载器。</p><p>第二种形式则相当于设置了参数 <code>initialize</code> 的值为 <code>true</code>，<code>loader</code> 的值为当前类的类加载器。<code>Class.forName</code> 的一个很常见的用法是在加载数据库驱动的时候。</p><p>如 <code>Class.forName(“org.apache.derby.jdbc.EmbeddedDriver”).newInstance()</code> 用来加载 <code>Apache Derby</code> 数据库的驱动。</p><h2 id="开发自己的类加载器"><a href="#开发自己的类加载器" class="headerlink" title="开发自己的类加载器"></a>开发自己的类加载器</h2><p>虽然在绝大多数情况下，系统默认提供的类加载器实现已经可以满足需求。但是在某些情况下，我们还是需要为应用开发出自己的类加载器。比如我们的应用通过网络来传输 <code>Java</code> 类的字节代码，为了保证安全性，这些字节代码经过了加密处理。这个时候我们就需要自己的类加载器来从某个网络地址上读取加密后的字节代码，接着进行解密和验证，最后定义出要在 <code>Java</code> 虚拟机中运行的类来。下面将通过两个具体的实例来说明类加载器的开发。</p><h3 id="文件系统类加载器"><a href="#文件系统类加载器" class="headerlink" title="文件系统类加载器"></a>文件系统类加载器</h3><p>我们先编写一个类加载器用来加载存储在文件系统上的 <code>Java</code> 字节代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSystemClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String rootDir;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileSystemClassLoader</span><span class="params">(String rootDir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rootDir = rootDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] classData = getClassData(name);</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassData(String className) &#123;</span><br><span class="line">        String path = classNameToPath(className);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream ins = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> bufferSize = <span class="number">4096</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[bufferSize];</span><br><span class="line">            <span class="keyword">int</span> bytesNumRead = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((bytesNumRead = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, bytesNumRead);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">classNameToPath</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rootDir + File.separatorChar</span><br><span class="line">                + className.replace(<span class="string">'.'</span>, File.separatorChar) + <span class="string">".class"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>如上所示，类 <code>FileSystemClassLoader</code> 继承自类 <code>java.lang.ClassLoader</code> 。在 <code>java.lang.ClassLoader</code> 类的常用方法中，一般来说，自己开发的类加载器只需要覆写 <code>findClass(String name)</code> 方法即可。 </p><p>如上面源码所示，<code>loadClass()</code> 封装了前面提到的代理模式的实现。该方法会首先调用 <code>findLoadedClass()</code> 方法来检查该类是否已经被加载过；如果没有加载过的话，会调用父类加载器的 <code>loadClass()</code> 方法来尝试加载该类；如果父类加载器无法加载该类的话，就调用 <code>findClass()</code> 方法来查找该类。</p><p>因此，为了保证类加载器都正确实现代理模式，在开发自己的类加载器时，最好不要覆写 <code>loadClass()</code> 方法，而是覆写 <code>findClass()</code> 方法。</p><p>类 <code>FileSystemClassLoader</code> 的 <code>findClass()</code> 方法首先根据类的全名在硬盘上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 <code>defineClass()</code> 方法来把这些字节代码转换成 <code>java.lang.Class</code> 类的实例。</p><h3 id="网络类加载器"><a href="#网络类加载器" class="headerlink" title="网络类加载器"></a>网络类加载器</h3><p>下面将通过一个网络类加载器来说明如何通过类加载器来实现组件的动态更新。</p><p>即基本的场景是：<code>Java</code> 字节代码（.class）文件存放在服务器上，客户端通过网络的方式获取字节代码并执行。当有版本更新的时候，只需要替换掉服务器上保存的文件即可。通过类加载器可以比较简单的实现这种需求。</p><p>类 <code>NetworkClassLoader</code> 负责通过网络下载 <code>Java</code> 类字节代码并定义出 <code>Java</code> 类。它的实现与 <code>FileSystemClassLoader</code> 类似。</p><p>在通过 <code>NetworkClassLoader</code> 加载了某个版本的类之后，一般有两种做法来使用它。</p><p>第一种做法是使用 <code>Java</code> 反射 API。另外一种做法是使用接口。需要注意的是，并不能直接在客户端代码中引用从服务器上下载的类，因为客户端代码的类加载器找不到这些类。使用 <code>Java</code> 反射 API 可以直接调用 Java 类的方法。而使用接口的做法则是把接口的类放在客户端中，从服务器上加载实现此接口的不同版本的类。在客户端通过相同的接口来使用这些实现类。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String rootUrl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NetworkClassLoader</span><span class="params">(String rootUrl)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.rootUrl = rootUrl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"><span class="keyword">byte</span>[] classData = getClassData(name);</span><br><span class="line"><span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] getClassData(String className) &#123;</span><br><span class="line">String path = classNameToPath(className);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">URL url = <span class="keyword">new</span> URL(path);</span><br><span class="line">InputStream ins = url.openStream();</span><br><span class="line">ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line"><span class="keyword">int</span> bufferSize = <span class="number">4096</span>;</span><br><span class="line"><span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[bufferSize];</span><br><span class="line"><span class="keyword">int</span> bytesNumRead = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((bytesNumRead = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">baos.write(buffer, <span class="number">0</span>, bytesNumRead);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">classNameToPath</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> rootUrl + <span class="string">"/"</span></span><br><span class="line">+ className.replace(<span class="string">'.'</span>, <span class="string">'/'</span>) + <span class="string">".class"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Versioned</span> </span>&#123;</span><br><span class="line"><span class="function">String <span class="title">getVersion</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICalculator</span> <span class="keyword">extends</span> <span class="title">Versioned</span> </span>&#123;</span><br><span class="line"><span class="function">String <span class="title">calculate</span><span class="params">(String expression)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String url = <span class="string">"http://localhost:8080/ClassloaderTest/classes"</span>;</span><br><span class="line">NetworkClassLoader ncl = <span class="keyword">new</span> NetworkClassLoader(url);</span><br><span class="line">String basicClassName = <span class="string">"com.example.CalculatorBasic"</span>;</span><br><span class="line">String advancedClassName = <span class="string">"com.example.CalculatorAdvanced"</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class&lt;?&gt; clazz = ncl.loadClass(basicClassName);</span><br><span class="line">ICalculator calculator = (ICalculator) clazz.newInstance();</span><br><span class="line">System.out.println(calculator.getVersion());</span><br><span class="line">clazz = ncl.loadClass(advancedClassName);</span><br><span class="line">calculator = (ICalculator) clazz.newInstance();</span><br><span class="line">System.out.println(calculator.getVersion());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时需要在服务器提供<code>CalculatorBasic</code>和<code>CalculatorAdvanced</code>的实现，它们继承<code>ICalculator</code>接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorAdvanced</span> <span class="keyword">implements</span> <span class="title">ICalculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">calculate</span><span class="params">(String expression)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Result is "</span> + expression;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"2.0"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorBasic</span> <span class="keyword">implements</span> <span class="title">ICalculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">calculate</span><span class="params">(String expression)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> expression;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"1.0"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>类加载器是 <code>Java</code> 语言的一个创新。它使得动态安装和更新软件组件成为可能。</p><p>本文详细介绍了类加载器的相关话题，包括基本概念、代理模式、线程上下文类加载器等。我们在遇到 <code>ClassNotFoundException</code> 和 <code>NoClassDefFoundError</code> 等异常的时候，应该检查抛出异常的类的类加载器和当前线程的上下文类加载器，从中可以发现问题的所在。</p><p>在开发自己的类加载器的时候，需要注意与已有的类加载器组织结构的协调。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="类加载器" scheme="https://www.sakuratears.top/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java加密算法</title>
    <link href="https://www.sakuratears.top/blog/Java%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.html"/>
    <id>https://www.sakuratears.top/blog/Java加密算法.html</id>
    <published>2020-07-21T15:41:00.000Z</published>
    <updated>2020-07-21T15:42:44.781Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近总结了一些加密算法的相关Java代码，特此整理如下，以备不时之需。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="MD5信息摘要算法"><a href="#MD5信息摘要算法" class="headerlink" title="MD5信息摘要算法"></a>MD5信息摘要算法</h2><p>此算法为不可逆加密算法，是一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值，用于确保信息传输完整一致。</p><p>后来该算法被证实存在弱点，无法防止碰撞破解，因此不适用于安全性认证，对于需要高度安全性的数据，可以采用其他加密算法。</p><p>Java相关代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MD5Utils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_ALGORITHM = <span class="string">"MD5"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认的密码字符串组合，用来将字节转换成 16 进制表示的字符,apache校验下载的文件的正确性用的就是默认的这个组合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">char</span>[] hexDigits = &#123; <span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>,</span><br><span class="line">            <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MessageDigest messagedigest = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            messagedigest = MessageDigest.getInstance(KEY_ALGORITHM);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException ex) &#123;</span><br><span class="line">            log.error(ex.getMessage(),ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成字符串的md5校验值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMD5String</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getMD5String(s.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMD5String</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        messagedigest.update(bytes);</span><br><span class="line">        <span class="keyword">return</span> bufferToHex(messagedigest.digest());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">bufferToHex</span><span class="params">(<span class="keyword">byte</span> bytes[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bufferToHex(bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">bufferToHex</span><span class="params">(<span class="keyword">byte</span> bytes[], <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        StringBuffer stringbuffer = <span class="keyword">new</span> StringBuffer(<span class="number">2</span> * n);</span><br><span class="line">        <span class="keyword">int</span> k = m + n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = m; l &lt; k; l++) &#123;</span><br><span class="line">            appendHexPair(bytes[l], stringbuffer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringbuffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">appendHexPair</span><span class="params">(<span class="keyword">byte</span> bt, StringBuffer stringbuffer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 取字节中高 4 位的数字转换, &gt;&gt;&gt; 为逻辑右移，将符号位一起右移,此处未发现两种符号有何不同</span></span><br><span class="line">        <span class="keyword">char</span> c0 = hexDigits[(bt &amp; <span class="number">0xf0</span>) &gt;&gt; <span class="number">4</span>];</span><br><span class="line">        <span class="comment">// 取字节中低 4 位的数字转换</span></span><br><span class="line">        <span class="keyword">char</span> c1 = hexDigits[bt &amp; <span class="number">0xf</span>];</span><br><span class="line">        stringbuffer.append(c0);</span><br><span class="line">        stringbuffer.append(c1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成字符串指定部分的md5校验值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMD5String</span><span class="params">(String s,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(s))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s = s.toUpperCase();</span><br><span class="line">        <span class="keyword">if</span>(end &gt; start &amp;&amp; end &gt; <span class="number">0</span> &amp;&amp; s.length() &gt;= end)&#123;</span><br><span class="line">            s = s.substring(start, end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getMD5String(s.getBytes()).toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(getMD5String(<span class="string">"123456"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SHA安全散列算法"><a href="#SHA安全散列算法" class="headerlink" title="SHA安全散列算法"></a>SHA安全散列算法</h2><p>我们这儿提到的SHA安全散列算法一般指的它的密码散列函数家族，其有5个算法，分别是SHA-1、SHA-224、SHA-256、SHA-384和SHA-512。</p><p>其加密强度依次上升，SHA加密算法也是一种不可逆加密算法。</p><p>由于目前SHA-1存在暴力破解（碰撞破解）的可能性，因此推荐使用SHA-2（SHA-224、SHA-256、SHA-384、SHA-512）进行数据加密。这4个算法函数都将讯息对应到更长的讯息摘要。</p><p>Java相关代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SHAUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_SHA_1 = <span class="string">"SHA1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_SHA_224 = <span class="string">"SHA-224"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_SHA_256 = <span class="string">"SHA-256"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_SHA_384 = <span class="string">"SHA-384"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_SHA_512 = <span class="string">"SHA-512"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认的密码字符串组合，用来将字节转换成 16 进制表示的字符,apache校验下载的文件的正确性用的就是默认的这个组合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">char</span>[] hexDigits = &#123; <span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>,</span><br><span class="line">            <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MessageDigest messagedigestSHA1 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MessageDigest messagedigestSHA224 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MessageDigest messagedigestSHA256 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MessageDigest messagedigestSHA384 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MessageDigest messagedigestSHA512 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            messagedigestSHA1 = MessageDigest.getInstance(KEY_SHA_1);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException ex) &#123;</span><br><span class="line">            log.error(ex.getMessage(),ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            messagedigestSHA224 = MessageDigest.getInstance(KEY_SHA_224);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException ex) &#123;</span><br><span class="line">            log.error(ex.getMessage(),ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            messagedigestSHA256 = MessageDigest.getInstance(KEY_SHA_256);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException ex) &#123;</span><br><span class="line">            log.error(ex.getMessage(),ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            messagedigestSHA384 = MessageDigest.getInstance(KEY_SHA_384);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException ex) &#123;</span><br><span class="line">            log.error(ex.getMessage(),ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            messagedigestSHA512 = MessageDigest.getInstance(KEY_SHA_512);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException ex) &#123;</span><br><span class="line">            log.error(ex.getMessage(),ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">bufferToHex</span><span class="params">(<span class="keyword">byte</span> bytes[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bufferToHex(bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">bufferToHex</span><span class="params">(<span class="keyword">byte</span> bytes[], <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        StringBuffer stringbuffer = <span class="keyword">new</span> StringBuffer(<span class="number">2</span> * n);</span><br><span class="line">        <span class="keyword">int</span> k = m + n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = m; l &lt; k; l++) &#123;</span><br><span class="line">            appendHexPair(bytes[l], stringbuffer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringbuffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">appendHexPair</span><span class="params">(<span class="keyword">byte</span> bt, StringBuffer stringbuffer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 取字节中高 4 位的数字转换, &gt;&gt;&gt; 为逻辑右移，将符号位一起右移,此处未发现两种符号有何不同</span></span><br><span class="line">        <span class="keyword">char</span> c0 = hexDigits[(bt &amp; <span class="number">0xf0</span>) &gt;&gt; <span class="number">4</span>];</span><br><span class="line">        <span class="comment">// 取字节中低 4 位的数字转换</span></span><br><span class="line">        <span class="keyword">char</span> c1 = hexDigits[bt &amp; <span class="number">0xf</span>];</span><br><span class="line">        stringbuffer.append(c0);</span><br><span class="line">        stringbuffer.append(c1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成字符串的sha1校验值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSHA1String</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSHA1String(s.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSHA1String</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        messagedigestSHA1.update(bytes);</span><br><span class="line">        <span class="keyword">return</span> bufferToHex(messagedigestSHA1.digest());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成字符串的sha224校验值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSHA224String</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSHA224String(s.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSHA224String</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        messagedigestSHA224.update(bytes);</span><br><span class="line">        <span class="keyword">return</span> bufferToHex(messagedigestSHA224.digest());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成字符串的sha256校验值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSHA256String</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSHA256String(s.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSHA256String</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        messagedigestSHA256.update(bytes);</span><br><span class="line">        <span class="keyword">return</span> bufferToHex(messagedigestSHA256.digest());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成字符串的sha384校验值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSHA384String</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSHA384String(s.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSHA384String</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        messagedigestSHA384.update(bytes);</span><br><span class="line">        <span class="keyword">return</span> bufferToHex(messagedigestSHA384.digest());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成字符串的sha512校验值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSHA512String</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSHA512String(s.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSHA512String</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        messagedigestSHA512.update(bytes);</span><br><span class="line">        <span class="keyword">return</span> bufferToHex(messagedigestSHA512.digest());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SHA1:"</span>+getSHA1String(<span class="string">"123456"</span>));</span><br><span class="line">        System.out.println(<span class="string">"SHA224:"</span>+getSHA224String(<span class="string">"123456"</span>));</span><br><span class="line">        System.out.println(<span class="string">"SHA256:"</span>+getSHA256String(<span class="string">"123456"</span>));</span><br><span class="line">        System.out.println(<span class="string">"SHA384:"</span>+getSHA384String(<span class="string">"123456"</span>));</span><br><span class="line">        System.out.println(<span class="string">"SHA512:"</span>+getSHA512String(<span class="string">"123456"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Hmac哈希消息认证码"><a href="#Hmac哈希消息认证码" class="headerlink" title="Hmac哈希消息认证码"></a>Hmac哈希消息认证码</h2><p>Hmac是一种基于Hash函数和密钥进行消息认证的方法，在IPSec和其他网络协议（如SSL）中有广泛应用，现在已经成为Internet安全标准。</p><p>它也是一种不可逆加密算法。</p><p>Hmac运算利用hash算法，以一个消息M和一个密钥K作为输入，生成一个定长的消息摘要作为输出。</p><p>由于存在加密密钥K，因此认证时，加密方和认证方都是需要知道密钥K的。因此需要保证密钥K不被泄露。</p><p>同时密钥K的长度也影响加密算法强度，推荐密钥K随机生成且长度大于n（hash输出值）。</p><p>Hmac根据hash运算的不同，有6种算法，分别是Hmac-SHA1、Hmac-SHA224、Hmac-SHA256、Hmac-SHA284、Hmac-SHA512和Hmac-MD5。</p><p>Java相关代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HmacUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_HMAC_SHA1 = <span class="string">"HmacSHA1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_HMAC_SHA224 = <span class="string">"HmacSHA224"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_HMAC_SHA256 = <span class="string">"HmacSHA256"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_HMAC_SHA384 = <span class="string">"HmacSHA384"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_HMAC_SHA512 = <span class="string">"HmacSHA512"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_HMAC_MD5 = <span class="string">"HmacMD5"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到指定算法的一个密钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> algorithm</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">initMacKey</span><span class="params">(String algorithm)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//得到一个 指定算法密钥的密钥生成器</span></span><br><span class="line">        KeyGenerator keyGenerator = KeyGenerator.getInstance(algorithm);</span><br><span class="line">        <span class="comment">//生成一个密钥</span></span><br><span class="line">        SecretKey secretKey = keyGenerator.generateKey();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = secretKey.getEncoded();</span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HmacSHA 加密算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptText</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">hmacSHAEncrypt</span><span class="params">(String encryptText, String encryptKey,String algorithm)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] data = encryptKey.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        SecretKey secretKey = <span class="keyword">new</span> SecretKeySpec(data, algorithm);</span><br><span class="line">        Mac mac = Mac.getInstance(algorithm);</span><br><span class="line">        mac.init(secretKey);</span><br><span class="line">        <span class="keyword">byte</span>[] text = encryptText.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes =  mac.doFinal(text);</span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HmacSHA1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptText</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">hmacSHA1Encrypt</span><span class="params">(String encryptText, String encryptKey)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hmacSHAEncrypt(encryptText,encryptKey,KEY_HMAC_SHA1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HmacSHA224</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptText</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">hmacSHA224Encrypt</span><span class="params">(String encryptText, String encryptKey)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hmacSHAEncrypt(encryptText,encryptKey,KEY_HMAC_SHA224);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HmacSHA256</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptText</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">hmacSHA256Encrypt</span><span class="params">(String encryptText, String encryptKey)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hmacSHAEncrypt(encryptText,encryptKey,KEY_HMAC_SHA256);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HmacSHA384</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptText</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">hmacSHA384Encrypt</span><span class="params">(String encryptText, String encryptKey)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hmacSHAEncrypt(encryptText,encryptKey,KEY_HMAC_SHA384);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HmacSHA512</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptText</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">hmacSHA512Encrypt</span><span class="params">(String encryptText, String encryptKey)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hmacSHAEncrypt(encryptText,encryptKey,KEY_HMAC_SHA512);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HmacMD5</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptText</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">hmacMD5Encrypt</span><span class="params">(String encryptText, String encryptKey)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hmacSHAEncrypt(encryptText,encryptKey,KEY_HMAC_MD5);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String sha1Key = initMacKey(KEY_HMAC_SHA1);</span><br><span class="line">        System.out.println(<span class="string">"HmacSHA1_Key:"</span>+sha1Key);</span><br><span class="line">        System.out.println(<span class="string">"HmacSHA1_Result:"</span>+hmacSHA1Encrypt(<span class="string">"123456"</span>,sha1Key));</span><br><span class="line"></span><br><span class="line">        String sha224Key = initMacKey(KEY_HMAC_SHA224);</span><br><span class="line">        System.out.println(<span class="string">"HmacSHA224_Key:"</span>+sha224Key);</span><br><span class="line">        System.out.println(<span class="string">"HmacSHA224_Result:"</span>+hmacSHA224Encrypt(<span class="string">"123456"</span>,sha224Key));</span><br><span class="line"></span><br><span class="line">        String sha256Key = initMacKey(KEY_HMAC_SHA256);</span><br><span class="line">        System.out.println(<span class="string">"HmacSHA256_Key:"</span>+sha256Key);</span><br><span class="line">        System.out.println(<span class="string">"HmacSHA256_Result:"</span>+hmacSHA256Encrypt(<span class="string">"123456"</span>,sha256Key));</span><br><span class="line"></span><br><span class="line">        String sha384Key = initMacKey(KEY_HMAC_SHA384);</span><br><span class="line">        System.out.println(<span class="string">"HmacSHA384_Key:"</span>+sha384Key);</span><br><span class="line">        System.out.println(<span class="string">"HmacSHA384_Result:"</span>+hmacSHA384Encrypt(<span class="string">"123456"</span>,sha384Key));</span><br><span class="line"></span><br><span class="line">        String sha512Key = initMacKey(KEY_HMAC_SHA512);</span><br><span class="line">        System.out.println(<span class="string">"HmacSHA512_Key:"</span>+sha512Key);</span><br><span class="line">        System.out.println(<span class="string">"HmacSHA512_Result:"</span>+hmacSHA512Encrypt(<span class="string">"123456"</span>,sha512Key));</span><br><span class="line"></span><br><span class="line">        String md5Key = initMacKey(KEY_HMAC_MD5);</span><br><span class="line">        System.out.println(<span class="string">"HmacMD5_Key:"</span>+md5Key);</span><br><span class="line">        System.out.println(<span class="string">"HmacMD5_Result:"</span>+hmacMD5Encrypt(<span class="string">"123456"</span>,md5Key));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DES加密算法"><a href="#DES加密算法" class="headerlink" title="DES加密算法"></a>DES加密算法</h2><p>DES全称为Data Encryption Standard，直译即数据加密标准，是一种使用密钥加密的块算法。</p><p>它是一种对称可逆加密算法。</p><p>DES的加密密钥也是需要加密方和解密方都知道，因此存在泄漏的可能性。需要保护好密钥。</p><p>同时DES被证明是可以破解的，明文+密钥=密文，这个公式只要知道任何两个，就可以推导出第三个。</p><p>在已经知道明文和对应密文的情况下，通过穷举和暴力破解是可以破解DES的。</p><p>Java相关代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DESUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_ALGORITHM = <span class="string">"DESede"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认的加密算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CIPHER_ALGORITHM = <span class="string">"DESede/CBC/PKCS5Padding"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> iv</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encrypt</span><span class="params">(String data, String key,String iv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] keyBytes = key.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        <span class="keyword">byte</span>[] ivBytes = iv.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        <span class="keyword">if</span>(keyBytes.length &lt; <span class="number">24</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Key字节长度需大于等于24"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ivBytes.length != <span class="number">8</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"IV偏移量需要为8字节"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bt = encrypt(data.getBytes(StandardCharsets.UTF_8), keyBytes,ivBytes);</span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(bt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> iv</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decrypt</span><span class="params">(String data, String key,String iv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] keyBytes = key.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        <span class="keyword">byte</span>[] ivBytes = iv.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        <span class="keyword">if</span>(keyBytes.length &lt; <span class="number">24</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Key字节长度需大于等于24"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ivBytes.length != <span class="number">8</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"IV偏移量需要为8字节"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] buf = Base64.decodeBase64(data);</span><br><span class="line">        <span class="keyword">byte</span>[] bt = decrypt(buf, keyBytes,ivBytes);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(bt, StandardCharsets.UTF_8);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DES加密数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> iv</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encrypt(<span class="keyword">byte</span>[] data, <span class="keyword">byte</span>[] key,<span class="keyword">byte</span>[] iv) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 生成一个可信任的随机数源</span></span><br><span class="line">        SecureRandom sr = <span class="keyword">new</span> SecureRandom();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从原始密钥数据创建DESKeySpec对象</span></span><br><span class="line">        DESedeKeySpec dks = <span class="keyword">new</span> DESedeKeySpec(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个密钥工厂，然后用它把DESKeySpec转换成SecretKey对象</span></span><br><span class="line">        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(KEY_ALGORITHM);</span><br><span class="line">        SecretKey secretKey = keyFactory.generateSecret(dks);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Cipher对象实际完成加密操作</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);</span><br><span class="line"></span><br><span class="line">        IvParameterSpec ips = <span class="keyword">new</span> IvParameterSpec(iv);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用密钥初始化Cipher对象</span></span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, secretKey,ips, sr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DES解密数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> iv</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decrypt(<span class="keyword">byte</span>[] data, <span class="keyword">byte</span>[] key,<span class="keyword">byte</span>[] iv) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 生成一个可信任的随机数源</span></span><br><span class="line">        SecureRandom sr = <span class="keyword">new</span> SecureRandom();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从原始密钥数据创建DESKeySpec对象</span></span><br><span class="line">        DESedeKeySpec dks = <span class="keyword">new</span> DESedeKeySpec(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个密钥工厂，然后用它把DESKeySpec转换成SecretKey对象</span></span><br><span class="line">        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(KEY_ALGORITHM);</span><br><span class="line">        SecretKey secretKey = keyFactory.generateSecret(dks);</span><br><span class="line"></span><br><span class="line">        IvParameterSpec ips = <span class="keyword">new</span> IvParameterSpec(iv);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Cipher对象实际完成解密操作</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用密钥初始化Cipher对象</span></span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, secretKey,ips, sr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String text = <span class="string">"12345611111111111111111111111"</span>;</span><br><span class="line">        String key = <span class="string">"111111111111111111111张"</span>;</span><br><span class="line">        String iv = <span class="string">"张三81"</span>;</span><br><span class="line">        String result = encrypt(text,key,iv);</span><br><span class="line">        System.out.println(<span class="string">"DES加密："</span>+ result);</span><br><span class="line">        System.out.println(<span class="string">"DES解密："</span>+decrypt(result,key,iv));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AES加密算法"><a href="#AES加密算法" class="headerlink" title="AES加密算法"></a>AES加密算法</h2><p>AES（Advanced Encryption Standard），高级加密标准，这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。</p><p>它是一种对称可逆加密算法。</p><p>AES的加密密钥也是需要加密方和解密方都知道，因此也需要保护好密钥。</p><p>在使用AES加密时，我们一般使用CBC加密模式，这种加密模式安全性好，适合传输长报文，缺点是需要初始化向量IV。</p><p>对称加密的加密模式一般有4种，优缺点如下：</p><p>对称/分组密码一般分为流加密(如OFB、CFB等)和块加密(如ECB、CBC等)。对于流加密，需要将分组密码转化为流模式工作。对于块加密(或称分组加密)，如果要加密超过块大小的数据，就需要涉及填充和链加密模式。</p><ul><li><p>ECB(Electronic Code Book电子密码本)模式</p><p>ECB模式是最早采用和最简单的模式，它将加密的数据分成若干组，每组的大小跟加密密钥长度相同，然后每组都用相同的密钥进行加密。</p><p>优点:</p><ol><li>简单；　</li><li>有利于并行计算；</li><li>误差不会被传送；</li></ol><p>缺点:　</p><ol><li>不能隐藏明文的模式；　</li><li>可能对明文进行主动攻击；　</li></ol><p>因此，此模式适于加密小消息。</p></li><li><p>CBC(Cipher Block Chaining，加密块链)模式</p><p>优点：</p><ol><li>不容易主动攻击；</li><li>安全性好于ECB；</li><li>适合传输长度长的报文,是SSL、IPSec的标准。　</li></ol><p>缺点：　</p><ol><li>不利于并行计算；　</li><li>误差传递；　</li><li>需要初始化向量IV</li></ol></li><li><p>CFB(Cipher FeedBack Mode，加密反馈)模式</p><p>优点：</p><ol><li>隐藏了明文模式;　</li><li>分组密码转化为流模式;　</li><li>可以及时加密传送小于分组的数据;　</li></ol><p>缺点:　</p><ol><li>不利于并行计算;　</li><li>误差传送：一个明文单元损坏影响多个单元;　</li><li>唯一的IV;</li></ol></li><li><p>OFB(Output FeedBack，输出反馈)模式</p><p>优点:</p><ol><li>隐藏了明文模式;　</li><li>分组密码转化为流模式;　</li><li>可以及时加密传送小于分组的数据;　</li></ol><p>缺点:　</p><ol><li>不利于并行计算;　</li><li>对明文的主动攻击是可能的;　</li><li>误差传送：一个明文单元损坏影响多个单元</li></ol></li></ul><p>Java相关代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AESUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_ALGORITHM = <span class="string">"AES"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认的加密算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CIPHER_ALGORITHM = <span class="string">"AES/CBC/PKCS5Padding"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 随机数算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RANDOM_ALGORITHM = <span class="string">"SHA1PRNG"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * IV向量长度必须为16</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IV_PARAM_LENGTH = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AES支持的密钥长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SECRET_KEY_LENGTH_128 = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SECRET_KEY_LENGTH_192 = <span class="number">192</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SECRET_KEY_LENGTH_256 = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 密钥种子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String secretKeySeed = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * IV向量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String ivParameterSeed = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AESUtils</span><span class="params">(String secretKeySeed, String ivParameterSeed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.secretKeySeed = secretKeySeed;</span><br><span class="line">        <span class="keyword">if</span> (ivParameterSeed.length() != IV_PARAM_LENGTH) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"iv向量长度必须为16"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.ivParameterSeed=ivParameterSeed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">encrypt</span><span class="params">(String content)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// AES加密</span></span><br><span class="line">        <span class="keyword">byte</span>[] encryptStr = encrypt(content, secretKeySeed,ivParameterSeed);</span><br><span class="line">        <span class="comment">// BASE64位加密</span></span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(encryptStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptStr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decrypt</span><span class="params">(String encryptStr)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// BASE64位解密</span></span><br><span class="line">        <span class="keyword">byte</span>[] decodeBase64 = Base64.decodeBase64(encryptStr);</span><br><span class="line">        <span class="comment">// AES解密</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(decrypt(decodeBase64, secretKeySeed,ivParameterSeed),StandardCharsets.UTF_8);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成加密秘钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> secretKeySeed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> SecretKeySpec <span class="title">getSecretKeySpec</span><span class="params">(<span class="keyword">final</span> String secretKeySeed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//生成指定算法密钥生成器的 KeyGenerator 对象</span></span><br><span class="line">            KeyGenerator keyGenerator = KeyGenerator.getInstance(KEY_ALGORITHM);</span><br><span class="line">            <span class="comment">// 防止linux下 随机生成key</span></span><br><span class="line">            SecureRandom secureRandom = SecureRandom.getInstance(RANDOM_ALGORITHM);</span><br><span class="line">            secureRandom.setSeed(secretKeySeed.getBytes());</span><br><span class="line">            <span class="comment">//AES 要求密钥长度为 128/192/256</span></span><br><span class="line">            keyGenerator.init(SECRET_KEY_LENGTH_128, secureRandom);</span><br><span class="line">            <span class="comment">//生成一个密钥</span></span><br><span class="line">            SecretKey secretKey = keyGenerator.generateKey();</span><br><span class="line">            <span class="comment">// 转换为AES专用密钥</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SecretKeySpec(secretKey.getEncoded(), KEY_ALGORITHM);</span><br><span class="line"><span class="comment">//            //注意：ios不支持使用 KeyGenerator、SecureRandom、SecretKey 生成</span></span><br><span class="line"><span class="comment">//            return new SecretKeySpec(secretKeySeed.getBytes(), KEY_ALGORITHM);</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            log.error(ex.getMessage(), ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成向量秘钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ivParameterSeed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IvParameterSpec <span class="title">getIvParameterSpec</span><span class="params">(<span class="keyword">final</span> String ivParameterSeed)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用CBC模式，需要一个向量iv，可增加加密算法的强度</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IvParameterSpec(ivParameterSeed.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> secretKeySeed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ivParameterSeed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encrypt(String content, String secretKeySeed,String ivParameterSeed) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建密码器</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);</span><br><span class="line">        <span class="comment">// 初始化为加密模式的密码器</span></span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, getSecretKeySpec(secretKeySeed),getIvParameterSpec(ivParameterSeed));</span><br><span class="line">        <span class="comment">// 加密</span></span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(content.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> secretKeySeed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ivParameterSeed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decrypt(<span class="keyword">byte</span>[] content, String secretKeySeed,String ivParameterSeed) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建密码器</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);</span><br><span class="line">        <span class="comment">// 初始化为加密模式的密码器</span></span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, getSecretKeySpec(secretKeySeed),getIvParameterSpec(ivParameterSeed));</span><br><span class="line">        <span class="comment">// 解密</span></span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String secretKeySeed = <span class="string">"test123456"</span>;</span><br><span class="line">        String ivParameterSeed = <span class="string">"ivPar-test-hello"</span>;</span><br><span class="line">        String message = <span class="string">"test1234567890"</span>;</span><br><span class="line">        AESUtils aesUtils = <span class="keyword">new</span> AESUtils(secretKeySeed,ivParameterSeed);</span><br><span class="line">        String a= aesUtils.encrypt(message);</span><br><span class="line">        System.out.println(<span class="string">"加密后的字符："</span> + a);</span><br><span class="line">        System.out.println(<span class="string">"解密后的字符："</span> + aesUtils.decrypt(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RSA加密算法"><a href="#RSA加密算法" class="headerlink" title="RSA加密算法"></a>RSA加密算法</h2><p>它是一种非对称可逆加密算法，其密钥由公钥和私钥组成，公钥外部暴露，用于数据加密，私钥保密，用于解密数据。</p><p>RSA公开密钥密码体制是一种使用不同的加密密钥与解密密钥，“由已知加密密钥推导出解密密钥在计算上是不可行的”密码体制。</p><p>RSA公开密钥密码体制的原理是：根据数论，寻求两个大素数比较简单，而将它们的乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。</p><p>RSA的安全性依赖于大数分解，但是否等同于大数分解一直未能得到理论上的证明，也并没有从理论上证明破译。RSA的难度与大数分解难度等价。</p><p>RSA算法的保密强度随其密钥的长度增加而增强。但是，密钥越长，其加解密所耗用的时间也越长。因此，要根据所保护信息的敏感程度与攻击者破解所要花费的代价值不值得以及系统所要求的反应时间来综合考虑。一般情况下，公钥长度最好选择1024位及以上。</p><p>由于进行的都是大数计算，使得RSA最快的情况也比DES慢上好几倍，无论是软件还是硬件实现。速度一直是RSA的缺陷。一般来说只用于少量数据加密。RSA的速度比对应同样安全级别的对称密码算法要慢1000倍左右。</p><p>由于RSA加密数据长度不超过 <code>密钥长度/8 - 11</code>，解密长度不超过 <code>密钥长度/8</code>，因此对于较长数据，一般有两种方法进行处理：一是在使用RSA加密前，先使用一些对称加密算法将数据加密，使得加密后长度在RSA允许范围内，在使用RSA加密；二是使用RSA分段加密。</p><p>下面代码提供了RSA分段加密的算法，一般情况下，由于RSA加解密速度慢，耗资源，我们在双方通信中，先使用RSA进行通信，成功后协定双方对称加密密钥（如AES密钥），而后在使用对称加密算法（如AES）进行数据传输。</p><p>Java相关代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RSAUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数字签名，密钥算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RSA_KEY_ALGORITHM = <span class="string">"RSA"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数字签名签名/验证算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SIGNATURE_ALGORITHM = <span class="string">"MD5withRSA"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * RSA密钥长度，RSA算法的默认密钥长度是1024密钥长度必须是64的倍数，在512到65536位之间</span></span><br><span class="line"><span class="comment">     * PS:值改变后 最大加密字节数、最大解密字节数会随之变化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEY_SIZE = <span class="number">2048</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * bits转换为byte单位</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BASE_SIZE = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大加密字节数，超出最大字节数需要分组加密</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ENCRYPT_BLOCK = KEY_SIZE / BASE_SIZE - <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大解密字节数，超出最大字节数需要分组解密</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_DECRYPT_BLOCK = KEY_SIZE / BASE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成密钥对</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, String&gt; <span class="title">initKey</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        KeyPairGenerator keygen = KeyPairGenerator.getInstance(RSA_KEY_ALGORITHM);</span><br><span class="line">        <span class="comment">//初始化密钥生成器</span></span><br><span class="line">        keygen.initialize(KEY_SIZE);</span><br><span class="line">        KeyPair keys = keygen.genKeyPair();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] pubKey = keys.getPublic().getEncoded();</span><br><span class="line">        String publicKeyString = Base64.encodeBase64String(pubKey);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] priKey = keys.getPrivate().getEncoded();</span><br><span class="line">        String privateKeyString = Base64.encodeBase64String(priKey);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; keyPairMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        keyPairMap.put(<span class="string">"publicKeyString"</span>, publicKeyString);</span><br><span class="line">        keyPairMap.put(<span class="string">"privateKeyString"</span>, privateKeyString);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> keyPairMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 密钥转成byte[]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decodeBase64(String key) &#123;</span><br><span class="line">        <span class="keyword">return</span> Base64.decodeBase64(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 获取公钥</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> publicKey 公钥字符串</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PublicKey <span class="title">getPublicKey</span><span class="params">(String publicKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">         KeyFactory keyFactory = KeyFactory.getInstance(RSA_KEY_ALGORITHM);</span><br><span class="line">         <span class="keyword">byte</span>[] decodedKey = Base64.decodeBase64(publicKey.getBytes());</span><br><span class="line">         X509EncodedKeySpec keySpec = <span class="keyword">new</span> X509EncodedKeySpec(decodedKey);</span><br><span class="line">         <span class="keyword">return</span> keyFactory.generatePublic(keySpec);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 获取私钥</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> privateKey 私钥字符串</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PrivateKey <span class="title">getPrivateKey</span><span class="params">(String privateKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">         KeyFactory keyFactory = KeyFactory.getInstance(RSA_KEY_ALGORITHM);</span><br><span class="line">         <span class="keyword">byte</span>[] decodedKey = Base64.decodeBase64(privateKey.getBytes());</span><br><span class="line">         PKCS8EncodedKeySpec keySpec = <span class="keyword">new</span> PKCS8EncodedKeySpec(decodedKey);</span><br><span class="line">         <span class="keyword">return</span> keyFactory.generatePrivate(keySpec);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公钥加密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data      加密前的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey 公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 加密后的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encryptByPubKey</span><span class="params">(String data, String publicKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] pubKey = RSAUtils.decodeBase64(publicKey);</span><br><span class="line">        <span class="keyword">byte</span>[] enSign = encryptByPubKey(data.getBytes(), pubKey);</span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(enSign);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公钥加密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data   待加密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pubKey 公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encryptByPubKey(<span class="keyword">byte</span>[] data, <span class="keyword">byte</span>[] pubKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        X509EncodedKeySpec x509KeySpec = <span class="keyword">new</span> X509EncodedKeySpec(pubKey);</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(RSA_KEY_ALGORITHM);</span><br><span class="line">        PublicKey publicKey1 = keyFactory.generatePublic(x509KeySpec);</span><br><span class="line">        Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, publicKey1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标识</span></span><br><span class="line">        <span class="keyword">int</span> offSet = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] resultBytes = &#123;&#125;;</span><br><span class="line">        <span class="keyword">byte</span>[] cache = &#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> inputLength = data.length;</span><br><span class="line">        <span class="keyword">while</span> (inputLength - offSet &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inputLength - offSet &gt; MAX_ENCRYPT_BLOCK) &#123;</span><br><span class="line">                cache = cipher.doFinal(data, offSet, MAX_ENCRYPT_BLOCK);</span><br><span class="line">                offSet += MAX_ENCRYPT_BLOCK;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cache = cipher.doFinal(data, offSet, inputLength - offSet);</span><br><span class="line">                offSet = inputLength;</span><br><span class="line">            &#125;</span><br><span class="line">            resultBytes = Arrays.copyOf(resultBytes, resultBytes.length + cache.length);</span><br><span class="line">            System.arraycopy(cache, <span class="number">0</span>, resultBytes, resultBytes.length - cache.length, cache.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私钥解密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data   待解密的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> priKey 私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decryptByPriKey(<span class="keyword">byte</span>[] data, <span class="keyword">byte</span>[] priKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        PKCS8EncodedKeySpec pkcs8KeySpec = <span class="keyword">new</span> PKCS8EncodedKeySpec(priKey);</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(RSA_KEY_ALGORITHM);</span><br><span class="line">        PrivateKey privateKey1 = keyFactory.generatePrivate(pkcs8KeySpec);</span><br><span class="line">        Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, privateKey1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> inputLen = data.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> offSet = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] cache;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 对数据分段解密</span></span><br><span class="line">        <span class="keyword">byte</span>[] decryptedData = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>(ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream())&#123;</span><br><span class="line">            <span class="keyword">while</span> (inputLen - offSet &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (inputLen - offSet &gt; MAX_DECRYPT_BLOCK) &#123;</span><br><span class="line">                    cache = cipher.doFinal(data, offSet, MAX_DECRYPT_BLOCK);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cache = cipher.doFinal(data, offSet, inputLen - offSet);</span><br><span class="line">                &#125;</span><br><span class="line">                out.write(cache, <span class="number">0</span>, cache.length);</span><br><span class="line">                i++;</span><br><span class="line">                offSet = i * MAX_DECRYPT_BLOCK;</span><br><span class="line">            &#125;</span><br><span class="line">            decryptedData = out.toByteArray();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            log.error(e.getMessage(),e);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> decryptedData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私钥解密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data       解密前的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey 私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 解密后的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decryptByPriKey</span><span class="params">(String data, String privateKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] priKey = RSAUtils.decodeBase64(privateKey);</span><br><span class="line">        <span class="keyword">byte</span>[] design = decryptByPriKey(Base64.decodeBase64(data), priKey);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(design);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 签名</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> signVo 待签名数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey 私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 签名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">sign</span><span class="params">(SignVo signVo, String privateKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">         PrivateKey privateKeys = getPrivateKey(privateKey);</span><br><span class="line">         String data = toSignStrMap(signVo);</span><br><span class="line">         <span class="keyword">byte</span>[] keyBytes = privateKeys.getEncoded();</span><br><span class="line">         PKCS8EncodedKeySpec keySpec = <span class="keyword">new</span> PKCS8EncodedKeySpec(keyBytes);</span><br><span class="line">         KeyFactory keyFactory = KeyFactory.getInstance(RSA_KEY_ALGORITHM);</span><br><span class="line">         PrivateKey key = keyFactory.generatePrivate(keySpec);</span><br><span class="line">         Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM);</span><br><span class="line">         signature.initSign(key);</span><br><span class="line">         signature.update(data.getBytes());</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> String(Base64.encodeBase64(signature.sign()));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 验签</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> signVo 签名实体</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> publicKey 公钥</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> sign 签名</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@return</span> 是否验签通过</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(SignVo signVo, String publicKey, String sign)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">         PublicKey publicKeys = getPublicKey(publicKey);</span><br><span class="line">         String srcData = toSignStrMap(signVo);</span><br><span class="line">         <span class="keyword">byte</span>[] keyBytes = publicKeys.getEncoded();</span><br><span class="line">         <span class="comment">// 初始化公钥</span></span><br><span class="line">         X509EncodedKeySpec keySpec = <span class="keyword">new</span> X509EncodedKeySpec(keyBytes);</span><br><span class="line">         <span class="comment">// 实例化密钥工厂</span></span><br><span class="line">         KeyFactory keyFactory = KeyFactory.getInstance(RSA_KEY_ALGORITHM);</span><br><span class="line">         <span class="comment">// 产生公钥</span></span><br><span class="line">         PublicKey key = keyFactory.generatePublic(keySpec);</span><br><span class="line">         <span class="comment">// 实例化Signature</span></span><br><span class="line">         Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM);</span><br><span class="line">         <span class="comment">// 初始化Signature</span></span><br><span class="line">         signature.initVerify(key);</span><br><span class="line">         signature.update(srcData.getBytes());</span><br><span class="line">         <span class="keyword">return</span> signature.verify(Base64.decodeBase64(sign.getBytes()));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 签名串拼接  格式：标志A&amp;标志B&amp;标志C.....   中间用 &amp; 连接</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> signVo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toSignStrMap</span><span class="params">(SignVo signVo)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(signVo.getSignA()).append(<span class="string">"&amp;"</span>).append(signVo.getSignB()).append(<span class="string">"&amp;"</span>).append(signVo.getSignC());</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Map&lt;String, String&gt; keyMap = initKey();</span><br><span class="line">            String publicKeyString = keyMap.get(<span class="string">"publicKeyString"</span>);</span><br><span class="line">            String privateKeyString = keyMap.get(<span class="string">"privateKeyString"</span>);</span><br><span class="line">            System.out.println(<span class="string">"公钥:"</span> + publicKeyString);</span><br><span class="line">            System.out.println(<span class="string">"私钥:"</span> + privateKeyString);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 待加密数据</span></span><br><span class="line">            String data = <span class="string">"&#123;\"code\":\"0000\",\"data\":&#123;\"list\":[&#123;\"address\":\"互联网创业中心\",\"amount\":120000.0,\"applicationDate\":1594174666000,\"createDate\":1594174666000,\"ecCode\":\"MC0001\",\"ecName\":\"ARJ\",\"ecOrderNumber\":\"20202070817261111\",\"orderNumber\":\"AR202007081017453500\",\"payOrderNumber\":\"\",\"phone\":\"1860000000\",\"productList\":[&#123;\"name\":\"小米18\",\"number\":2,\"pictureUrl\":\"https://dss0.bdstatic.com/-0U0bnSm1A5BphGlnYG/tam-ogel/93d9d2b0e5373b93ca5032d13866fd14_254_144.jpg\",\"price\":60000.0&#125;],\"repayDay\":\"08\",\"stageAmount\":40000.0,\"stageNumber\":3,\"status\":\"01\",\"total\":2,\"updateDate\":1594261066000,\"userId\":\"56f72c55c0cc11ea8c81fa163efd3ee0\"&#125;,&#123;\"address\":\"互联网创业中心\",\"amount\":60000.0,\"applicationDate\":1594173896000,\"createDate\":1594173896000,\"ecCode\":\"MC0001\",\"ecName\":\"ARJ\",\"ecOrderNumber\":\"20202070817260000\",\"orderNumber\":\"AR202007081004565300\",\"payOrderNumber\":\"\",\"phone\":\"137777777\",\"productList\":[&#123;\"name\":\"华为P40\",\"number\":2,\"pictureUrl\":\"https://consumer-img.huawei.com/content/dam/huawei-cbg-site/common/mkt/pdp/phones/p40-pro-plus-specs/cn/dimage.jpg\",\"price\":30000.0&#125;],\"repayDay\":\"08\",\"stageAmount\":20000.0,\"stageNumber\":3,\"status\":\"01\",\"total\":2,\"updateDate\":1594260296000,\"userId\":\"56f72c55c0cc11ea8c81fa163efd3ee0\"&#125;]&#125;,\"msg\":\"成功\",\"showMsg\":\"success\"&#125;"</span>;</span><br><span class="line">            <span class="comment">// 公钥加密</span></span><br><span class="line">            String encrypt = RSAUtils.encryptByPubKey(data, publicKeyString);</span><br><span class="line">            <span class="comment">// 私钥解密</span></span><br><span class="line">            String decrypt = RSAUtils.decryptByPriKey(encrypt, privateKeyString);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"加密前:"</span> + data);</span><br><span class="line">            System.out.println(<span class="string">"加密后:"</span> + encrypt);</span><br><span class="line">            System.out.println(<span class="string">"解密后:"</span> + decrypt);</span><br><span class="line"></span><br><span class="line">            SignVo signVo = <span class="keyword">new</span> SignVo();</span><br><span class="line">            signVo.setSignA(<span class="string">"testA"</span>);</span><br><span class="line">            signVo.setSignB(<span class="string">"testB"</span>);</span><br><span class="line">            signVo.setSignC(<span class="string">"testC"</span>);</span><br><span class="line">            String sign = RSAUtils.sign(signVo,privateKeyString);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"签名:"</span>+sign);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> result = RSAUtils.verify(signVo,publicKeyString,sign);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"验签结果:"</span>+result);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SignVo</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标志A</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String signA;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标志B</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String signB;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标志C</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String signC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DH加密算法"><a href="#DH加密算法" class="headerlink" title="DH加密算法"></a>DH加密算法</h2><p>上面我们说到非对称加密算法加密速度慢，耗资源，可以使用非对称加密算法进行通信，协商密钥后，在使用对称加密算法进行数据传输，这就是DH加密算法的核心。</p><p>其实也可以说DH加密算法是一种建立密钥的方法，而不是加密方法。</p><p>我们以甲乙双方发送数据为模型进行分析：</p><ol><li><p>甲方（消息发送方，下同）构建密钥对（公钥+私钥），甲方公布公钥给乙方（消息接收方，下同）;</p></li><li><p>乙方以甲方发送过来的公钥作为参数构造密钥对（公钥+私钥），将构造出来的公钥公布给甲方;</p></li><li><p>甲方用“甲方的私钥 + 乙方的公钥”构造本地密钥;</p></li><li><p>乙方用“乙方的私钥 + 甲方的公钥”构造本地的密钥;</p></li><li><p>这个时候，甲乙两方本地新构造出来的密钥应该一样，甲乙双方可以通过本地密钥进行数据的加密和解密;</p></li><li><p>然后就可以使用AES/DES这类对称加密算法进行数据的安全传送了。</p></li></ol><p>Java相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DHUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ALGORITHM = <span class="string">"DH"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认密钥字节数</span></span><br><span class="line"><span class="comment">     * 需要为64的倍数，且在512到1024之间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEY_SIZE = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DH加密下需要一种对称加密算法对数据加密，这里我们使用DES，也可以使用其他对称加密算法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SECRET_ALGORITHM = <span class="string">"DES"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公钥私钥Key值，便于从Map获取</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PUBLIC_KEY = <span class="string">"DHPublicKey"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PRIVATE_KEY = <span class="string">"DHPrivateKey"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化甲方密钥</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title">initKey</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(ALGORITHM);</span><br><span class="line">        keyPairGenerator.initialize(KEY_SIZE);</span><br><span class="line"></span><br><span class="line">        KeyPair keyPair = keyPairGenerator.generateKeyPair();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 甲方公钥</span></span><br><span class="line">        DHPublicKey publicKey = (DHPublicKey) keyPair.getPublic();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 甲方私钥</span></span><br><span class="line">        DHPrivateKey privateKey = (DHPrivateKey) keyPair.getPrivate();</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; keyMap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        keyMap.put(PUBLIC_KEY, publicKey);</span><br><span class="line">        keyMap.put(PRIVATE_KEY, privateKey);</span><br><span class="line">        <span class="keyword">return</span> keyMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化乙方密钥</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 甲方公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title">initKey</span><span class="params">(String key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 解析甲方公钥</span></span><br><span class="line">        <span class="keyword">byte</span>[] keyBytes = Base64.decodeBase64(key);</span><br><span class="line">        X509EncodedKeySpec x509KeySpec = <span class="keyword">new</span> X509EncodedKeySpec(keyBytes);</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(ALGORITHM);</span><br><span class="line">        PublicKey pubKey = keyFactory.generatePublic(x509KeySpec);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由甲方公钥构建乙方密钥</span></span><br><span class="line">        DHParameterSpec dhParamSpec = ((DHPublicKey) pubKey).getParams();</span><br><span class="line"></span><br><span class="line">        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(keyFactory.getAlgorithm());</span><br><span class="line">        keyPairGenerator.initialize(dhParamSpec);</span><br><span class="line"></span><br><span class="line">        KeyPair keyPair = keyPairGenerator.generateKeyPair();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 乙方公钥</span></span><br><span class="line">        DHPublicKey publicKey = (DHPublicKey) keyPair.getPublic();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 乙方私钥</span></span><br><span class="line">        DHPrivateKey privateKey = (DHPrivateKey) keyPair.getPrivate();</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; keyMap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        keyMap.put(PUBLIC_KEY, publicKey);</span><br><span class="line">        keyMap.put(PRIVATE_KEY, privateKey);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> keyMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data       待加密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey  甲方公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey 乙方私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encrypt(<span class="keyword">byte</span>[] data, String publicKey,String privateKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成本地密钥</span></span><br><span class="line">        SecretKey secretKey = getSecretKey(publicKey, privateKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数据加密</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(secretKey.getAlgorithm());</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, secretKey);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data  待加密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey 甲方公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey 乙方私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encrypt</span><span class="params">(String data, String publicKey,String privateKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = data.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        <span class="keyword">byte</span>[] result = encrypt(bytes,publicKey,privateKey);</span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data       待解密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey  乙方公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey 乙方私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decrypt(<span class="keyword">byte</span>[] data, String publicKey, String privateKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成本地密钥</span></span><br><span class="line">        SecretKey secretKey = getSecretKey(publicKey, privateKey);</span><br><span class="line">        <span class="comment">// 数据解密</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(secretKey.getAlgorithm());</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, secretKey);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 待解密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey 乙方公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey 甲方私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decrypt</span><span class="params">(String data, String publicKey, String privateKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = Base64.decodeBase64(data);</span><br><span class="line">        <span class="keyword">byte</span>[] result = decrypt(bytes,publicKey,privateKey);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(result,StandardCharsets.UTF_8);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建密钥</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey  公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey 私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> SecretKey <span class="title">getSecretKey</span><span class="params">(String publicKey, String privateKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化公钥</span></span><br><span class="line">        <span class="keyword">byte</span>[] pubKeyBytes = Base64.decodeBase64(publicKey);</span><br><span class="line"></span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(ALGORITHM);</span><br><span class="line">        X509EncodedKeySpec x509KeySpec = <span class="keyword">new</span> X509EncodedKeySpec(pubKeyBytes);</span><br><span class="line">        PublicKey pubKey = keyFactory.generatePublic(x509KeySpec);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化私钥</span></span><br><span class="line">        <span class="keyword">byte</span>[] priKeyBytes = Base64.decodeBase64(privateKey);</span><br><span class="line"></span><br><span class="line">        PKCS8EncodedKeySpec pkcs8KeySpec = <span class="keyword">new</span> PKCS8EncodedKeySpec(priKeyBytes);</span><br><span class="line">        Key priKey = keyFactory.generatePrivate(pkcs8KeySpec);</span><br><span class="line"></span><br><span class="line">        KeyAgreement keyAgree = KeyAgreement.getInstance(keyFactory.getAlgorithm());</span><br><span class="line">        keyAgree.init(priKey);</span><br><span class="line">        keyAgree.doPhase(pubKey, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成本地密钥</span></span><br><span class="line">        SecretKey secretKey = keyAgree.generateSecret(SECRET_ALGORITHM);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> secretKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取得私钥</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyMap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPrivateKey</span><span class="params">(Map&lt;String, Object&gt; keyMap)</span></span>&#123;</span><br><span class="line">        Key key = (Key) keyMap.get(PRIVATE_KEY);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(key.getEncoded());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取得公钥</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyMap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPublicKey</span><span class="params">(Map&lt;String, Object&gt; keyMap)</span></span>&#123;</span><br><span class="line">        Key key = (Key) keyMap.get(PUBLIC_KEY);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(key.getEncoded());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 生成甲方密钥对</span></span><br><span class="line">        Map&lt;String, Object&gt; aKeyMap = DHUtils.initKey();</span><br><span class="line">        String aPublicKey = DHUtils.getPublicKey(aKeyMap);</span><br><span class="line">        String aPrivateKey = DHUtils.getPrivateKey(aKeyMap);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"甲方公钥:"</span> + aPublicKey);</span><br><span class="line">        System.out.println(<span class="string">"甲方私钥:"</span> + aPrivateKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由甲方公钥产生本地密钥对</span></span><br><span class="line">        Map&lt;String, Object&gt; bKeyMap = DHUtils.initKey(aPublicKey);</span><br><span class="line">        String bPublicKey = DHUtils.getPublicKey(bKeyMap);</span><br><span class="line">        String bPrivateKey = DHUtils.getPrivateKey(bKeyMap);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"乙方公钥:"</span> + bPublicKey);</span><br><span class="line">        System.out.println(<span class="string">"乙方私钥:"</span> + bPrivateKey);</span><br><span class="line"></span><br><span class="line">        String aInput = <span class="string">"abc "</span>;</span><br><span class="line">        System.out.println(<span class="string">"原数据: "</span> + aInput);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由甲方公钥，乙方私钥构建密文</span></span><br><span class="line">        String aCode = DHUtils.encrypt(aInput, aPublicKey,bPrivateKey);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"加密："</span>+aCode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由乙方公钥，甲方私钥解密</span></span><br><span class="line">        String aDecode = DHUtils.decrypt(aCode, bPublicKey, aPrivateKey);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"解密: "</span> + aDecode);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String bInput = <span class="string">"def "</span>;</span><br><span class="line">        System.out.println(<span class="string">"原数据: "</span> + bInput);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由乙方公钥，甲方私钥构建密文</span></span><br><span class="line">        String bCode = DHUtils.encrypt(bInput, bPublicKey,aPrivateKey);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"加密："</span>+bCode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由甲方公钥，乙方私钥解密</span></span><br><span class="line">        String bDecode = DHUtils.decrypt(bCode, aPublicKey, bPrivateKey);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"解密: "</span> + bDecode);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ECC椭圆加密算法"><a href="#ECC椭圆加密算法" class="headerlink" title="ECC椭圆加密算法"></a>ECC椭圆加密算法</h2><p>椭圆加密算法（ECC）是一种公钥加密体制，其数学基础是利用椭圆曲线上的有理点构成Abel加法群上椭圆离散对数的计算困难性。</p><p>因此其也是一种非对称可逆加密算法。</p><p>相比RSA加密算法，ECC加密算法的安全性更高，有研究表明160位的椭圆密钥与1024位的RSA密钥安全性相同。</p><p>同时在私钥的加密解密速度上，ECC算法比RSA速度更快。</p><p>Java目前不支持ECC算法的加解密，只支持公私钥的生成，这儿我们引入<code>org.bouncycastle.bcprov-jdk15on</code>包，来实现Java下的ECC加密算法。</p><p>pom文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.bouncycastle/bcprov-jdk15on --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.bouncycastle&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;bcprov-jdk15on&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.66&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>Java相关代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ECCUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ALGORITHM = <span class="string">"EC"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PROVIDER = <span class="string">"BC"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TRANSFORM = <span class="string">"ECIES"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Map key值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PUBLIC_KEY = <span class="string">"publicKey"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PRIVATE_KEY = <span class="string">"privateKey"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Java目前不支持ECC加解密，只支持公私钥的生成</span></span><br><span class="line"><span class="comment">     * 这儿我们使用BouncyCastleProvider来支持ECC加密算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        Security.addProvider(<span class="keyword">new</span> BouncyCastleProvider());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成秘钥对</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> KeyPair <span class="title">getKeyPair</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(ALGORITHM, PROVIDER);</span><br><span class="line"></span><br><span class="line">        keyPairGenerator.initialize(SIZE, <span class="keyword">new</span> SecureRandom());</span><br><span class="line">        KeyPair keyPair = keyPairGenerator.generateKeyPair();</span><br><span class="line">        <span class="keyword">return</span> keyPair;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyPair</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPublicKey</span><span class="params">(KeyPair keyPair)</span></span>&#123;</span><br><span class="line">        ECPublicKey publicKey = (ECPublicKey) keyPair.getPublic();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = publicKey.getEncoded();</span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyPair</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPrivateKey</span><span class="params">(KeyPair keyPair)</span></span>&#123;</span><br><span class="line">        ECPrivateKey privateKey = (ECPrivateKey) keyPair.getPrivate();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = privateKey.getEncoded();</span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(bytes);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将Base64编码后的公钥转换成PublicKey对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pubStr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ECPublicKey <span class="title">string2PublicKey</span><span class="params">(String pubStr)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] keyBytes = Base64.decodeBase64(pubStr);</span><br><span class="line"></span><br><span class="line">        X509EncodedKeySpec keySpec = <span class="keyword">new</span> X509EncodedKeySpec(keyBytes);</span><br><span class="line"></span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(ALGORITHM,PROVIDER);</span><br><span class="line"></span><br><span class="line">        ECPublicKey publicKey = (ECPublicKey) keyFactory.generatePublic(keySpec);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> publicKey;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将Base64编码后的私钥转换成PrivateKey对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> priStr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ECPrivateKey <span class="title">string2PrivateKey</span><span class="params">(String priStr)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] keyBytes = Base64.decodeBase64(priStr);</span><br><span class="line"></span><br><span class="line">        PKCS8EncodedKeySpec keySpec = <span class="keyword">new</span> PKCS8EncodedKeySpec(keyBytes);</span><br><span class="line"></span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(ALGORITHM, PROVIDER);</span><br><span class="line"></span><br><span class="line">        ECPrivateKey privateKey = (ECPrivateKey) keyFactory.generatePrivate(keySpec);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> privateKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用公钥加密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encryptByPublicKey(<span class="keyword">byte</span>[] content,PublicKey publicKey) <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">        Cipher cipher = Cipher.getInstance(TRANSFORM,PROVIDER);</span><br><span class="line"></span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE,publicKey);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = cipher.doFinal(content);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私钥解密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decryptByPrivateKey(<span class="keyword">byte</span>[] content, PrivateKey privateKey) <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">        Cipher cipher = Cipher.getInstance(TRANSFORM,PROVIDER);</span><br><span class="line"></span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE,privateKey);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = cipher.doFinal(content);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encrypt</span><span class="params">(String content,String publicKey)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ECPublicKey pubKey = string2PublicKey(publicKey);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = content.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        <span class="keyword">byte</span>[] result = encryptByPublicKey(bytes,pubKey);</span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cipherText</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decrypt</span><span class="params">(String cipherText,String privateKey)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ECPrivateKey priKey = string2PrivateKey(privateKey);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = Base64.decodeBase64(cipherText);</span><br><span class="line">        <span class="keyword">byte</span>[] result = decryptByPrivateKey(bytes,priKey);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(result,StandardCharsets.UTF_8);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成一组密钥对</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String,String&gt; <span class="title">initKeyPairStr</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        KeyPair keyPair = ECCUtils.getKeyPair();</span><br><span class="line">        String publicKeyStr =ECCUtils.getPublicKey(keyPair);</span><br><span class="line">        String privateKeyStr = ECCUtils.getPrivateKey(keyPair);</span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(PUBLIC_KEY,publicKeyStr);</span><br><span class="line">        map.put(PRIVATE_KEY,privateKeyStr);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String text = <span class="string">"131sdfsfd张庆伟金额取"</span>;</span><br><span class="line">        Map&lt;String,String&gt; keyPair = initKeyPairStr();</span><br><span class="line">        String publicKey = keyPair.get(PUBLIC_KEY);</span><br><span class="line">        String privateKey = keyPair.get(PRIVATE_KEY);</span><br><span class="line">        System.out.println(<span class="string">"公钥："</span>+publicKey);</span><br><span class="line">        System.out.println(<span class="string">"私钥："</span>+privateKey);</span><br><span class="line">        String encrypt = encrypt(text,publicKey);</span><br><span class="line">        System.out.println(<span class="string">"加密数据："</span>+encrypt);</span><br><span class="line">        String decrypt = decrypt(encrypt,privateKey);</span><br><span class="line">        System.out.println(<span class="string">"解密数据："</span>+decrypt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是比较常用的一些加密算法，当然有一些其他的加密算法，如DSA等这儿未作涉及，有兴趣的也可以查看相关资料等。</p><p>了解一些加密算法，以便在设计系统时可以正确选择合适的数据加密算法，来保证系统更加稳定、可靠的运行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="加密算法" scheme="https://www.sakuratears.top/tags/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Mysql数据库设计命名规范</title>
    <link href="https://www.sakuratears.top/blog/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83.html"/>
    <id>https://www.sakuratears.top/blog/Mysql数据库设计命名规范.html</id>
    <published>2020-07-12T08:15:00.000Z</published>
    <updated>2020-07-12T08:18:18.814Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数据库涉及字符规范"><a href="#数据库涉及字符规范" class="headerlink" title="数据库涉及字符规范"></a>数据库涉及字符规范</h1><p>采用 <code>26</code> 个英文字母（区分大小写）和 <code>0-9</code> 这十个自然数，加上下划线<code>‘_’</code>组成，共<code>37</code>个字符。不能出现其他字符(注释除外)。</p><p><strong>注意事项：</strong></p><ol><li><p>以上命名都不得超过 <code>30</code> 个字符的系统限制。变量名的长度限制为<code>29</code>（不包括标识字符<code>@</code>）。</p></li><li><p>数据对象、变量的命名都采用英文字符，禁止使用中文命名。绝对不要在对象名的字符之间留空格。</p></li><li><p>小心保留词，要保证你的字段名没有和保留词、数据库系统或者常用访问方法冲突, 当表名或字段名乃至数据库名和保留字冲突时，在sql语句里可以用撇号（<code>`</code>）括起来。</p></li><li><p>保持字段名和类型的一致性，在命名字段并为其指定数据类型的时候一定要保证一致性。假如数据类型在一个表里是整数，那在另一个表里也要保证是整型。</p></li></ol><h1 id="数据库命名规范"><a href="#数据库命名规范" class="headerlink" title="数据库命名规范"></a>数据库命名规范</h1><p>数据库名使用小写英文以及下划线组成（公司简称+项目名）。比如:</p><p><code>baidu_oa<br>ailibaba_cloud</code></p><p>备份数据库名使用正式库名加上备份时间组成，如:</p><p><code>dbname_20150206</code></p><p>数据库创建时，显式指定字符集。</p><h1 id="数据库表命名规范"><a href="#数据库表命名规范" class="headerlink" title="数据库表命名规范"></a>数据库表命名规范</h1><p>数据表名使用小写英文以及下划线组成（项目名+表信息），并且创建数据库时，显式指定默认字符集。</p><p>比如:</p><p><code>oa_user<br>oa_workflow_steps</code></p><p>备份数据表名使用正式表名加上备份时间组成，如:</p><p><code>oa_user_20150206<br>oa_workflow_step_20150206</code></p><h1 id="字段命名规范"><a href="#字段命名规范" class="headerlink" title="字段命名规范"></a>字段命名规范</h1><p>字段名称使用单词组合完成，首字母小写，单词之间用<code>“_”</code>分隔，最好是带表名前缀，自增id最好创建与业务无关.</p><p>如<code>oa_user</code>表的字段:</p><p><code>user_id<br>user_name</code></p><p>表与表之间的相关联字段要用统一名称。</p><h1 id="索引命名规范"><a href="#索引命名规范" class="headerlink" title="索引命名规范"></a>索引命名规范</h1><p>索引名称为<code>idx_列名<em>表名缩写</em></code>，唯一索引名称为<code>uniq列名_表名缩写</code>,其中表名和关联字段名如果过长，可以取表名、关联字段名的前 5 个字母，如果表名、关联字段为多个单词组合，可以取前一个单词，外加后续其它单词的首字母作为字段名。</p><p>如:</p><p>普通索引:<code>idx_user_name_oa</code></p><p>唯一索引：<code>uqidx_user_name_oa</code></p><p><strong>注意事项：</strong></p><ul><li>单个索引长度不超过<code>64KB</code></li><li>单个表索引不超过<code>8</code>个</li></ul><h1 id="字段类型规范"><a href="#字段类型规范" class="headerlink" title="字段类型规范"></a>字段类型规范</h1><p>规则：用尽量少的存储空间来存数一个字段的数据。</p><ol><li><p><code>char(n)</code>和<code>varchar(n)</code>中括号中<code>n</code>代表字符的个数，并不代表字节个数，所以当使用了中文的时候(UTF8)意味着可以插入<code>m</code>个中文，但是实际会占用<code>m*3</code>个字节。</p></li><li><p>同时<code>char</code>和<code>varchar</code>最大的区别就在于<code>char</code>不管实际<code>value</code>都会占用<code>n</code>个字符的空间，而<code>varchar</code>只会占用实际字符应该占用的空间+1，并且实际空间+1&lt;=n。</p></li><li><p>超过<code>char</code>和<code>varchar</code>的<code>n</code>设置后，字符串会被截断。</p></li><li><p><code>char</code>的上限为<code>255</code>字节，<code>varchar</code>的上限<code>65535</code>字节，<code>text</code>的上限为<code>65535</code>。</p></li><li><p><code>char</code>在存储的时候会截断尾部的空格，<code>varchar</code>和<code>text</code>不会。</p></li><li><p><code>varchar</code>会使用<code>1-3</code>个字节来存储长度，<code>text</code>不会。</p></li></ol><table><thead><tr><th>Value</th><th>CHAR(4)</th><th>Storage Required</th><th>VARCHAR(4)</th><th>Storage Required</th></tr></thead><tbody><tr><td>‘’</td><td>‘    ‘</td><td>4 bytes</td><td>‘’</td><td>1 byte</td></tr><tr><td>‘ab’</td><td>‘ab  ‘</td><td>4 bytes</td><td>‘ab’</td><td>3 bytes</td></tr><tr><td>‘abcd’</td><td>‘abcd’</td><td>4 bytes</td><td>‘abcd’</td><td>5 bytes</td></tr><tr><td>‘abcdefgh’</td><td>‘abcd’</td><td>4 bytes</td><td>‘abcd’</td><td>5 bytes</td></tr></tbody></table><p>总体来说：</p><ul><li><code>char</code>，存定长，速度快，存在空间浪费的可能，会处理尾部空格，上限<code>255</code>。</li><li><code>varchar</code>，存变长，速度慢，不存在空间浪费，不处理尾部空格，上限<code>65535</code>，但是有存储长度实际<code>65532</code>最大可用。</li><li><code>text</code>，存变长大数据，速度慢，不存在空间浪费，不处理尾部空格，上限<code>65535</code>，会用额外空间存放数据长度，顾可以全部使用<code>65535</code>。</li></ul><p>接下来，我们说下这个场景的问题：</p><p>当<code>varchar(n)</code>后面的n非常大的时候我们是使用<code>varchar</code>好，还是<code>text</code>好呢？</p><p>这是个明显的量变引发质变的问题。我们从2个方面考虑，第一是空间，第二是性能。</p><p>首先从空间方面：</p><p>从官方文档中我们可以得知当<code>varchar</code>大于某些数值的时候，其会自动转换为<code>text</code>，大概规则如下：</p><ul><li>大于<code>varchar(255)</code>变为 <code>tinytext</code></li><li>大于<code>varchar(500)</code>变为 <code>text</code></li><li>大于<code>varchar(20000)</code>变为 <code>mediumtext</code></li></ul><p>所以对于过大的内容使用<code>varchar</code>和<code>text</code>没有太多区别。</p><p>比如能用<code>int</code>的就不用<code>char</code>或者<code>varchar</code>，能用<code>varchar(20)</code>的就不用<code>varchar(255)</code>。</p><p>时间戳字段尽量用<code>int</code>型。</p><p>尽量避免大字段<code>blob</code>，<code>text</code>，<code>longtext</code>，如强制需要大字段，不要集中存放在一个表中，分多表存放。查询语句<code>where</code>条件不要落在大字段上。</p><p>相关文档: </p><ul><li><a href="https://dev.mysql.com/doc/refman/5.6/en/column-count-limit.html" rel="external nofollow noopener noreferrer" target="_blank">行的大小限制</a></li><li><a href="https://dev.mysql.com/doc/refman/5.6/en/storage-requirements.html" rel="external nofollow noopener noreferrer" target="_blank">表数据类型的选型手册</a></li><li><a href="https://dev.mysql.com/doc/refman/5.6/en/string-type-syntax.html" rel="external nofollow noopener noreferrer" target="_blank">大对象数据类型的概述</a></li></ul><h1 id="操作规范"><a href="#操作规范" class="headerlink" title="操作规范"></a>操作规范</h1><ul><li><p>创建表时需添加表级别和列级别注释，显示指定存储引擎、默认字符集、自增开始值，<code>id</code>列无特殊要求，建议使用<code>int</code>值。</p></li><li><p>如无备注，则表中的第一个<code>id</code>字段一定是主键且为自动增长；</p></li><li><p>如无备注，则数值类型的字段请使用<code>UNSIGNED</code>属性；</p></li><li><p>如无备注，所有字段都设置<code>NOT NULL</code>，并设置默认值；</p></li><li><p>如无备注，所有的布尔值字段，如<code>is_hot</code>、<code>is_deleted</code>，都必须设置一个默认值，并设为<code>0</code>；</p></li><li><p>所有的数字类型字段，都必须设置一个默认值，并设为<code>0</code>；</p></li><li><p>针对<code>varchar</code>类型字段的程序处理，请验证用户输入，不要超出其预设的长度；</p></li><li><p>建表时将数据字典中的字段中文名和属性备注写入数据表的备注中(“PK、自动增长”不用写)；</p></li><li><p>如无说明，建表时一律采用<code>innodb</code>引擎；</p></li><li><p>尽量采用批量<code>SQL</code>语句,减少与数据库交互次数；</p></li><li><p>提交线上建表改表需求,必须详细注明涉及到的所有<code>SQL</code>语句(包括<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>)，便于DBA进行审核和优化。</p></li></ul><h1 id="数据库用户创建规范"><a href="#数据库用户创建规范" class="headerlink" title="数据库用户创建规范"></a>数据库用户创建规范</h1><p>采用<code>26</code>个英文字母（区分大小写）和<code>0-9</code>这十个自然数，加上下划线<code>‘_’</code>组成，共<code>37</code>个字符。不能出现其他字符（注释除外）。</p><p><strong>注意事项:</strong></p><ul><li>以上命名都不得超过<code>16</code>个字符的系统限制。</li><li><p>数据库用户一律采用小写，由以下几个部分组成，使用<code>人员<em>项目名</em>连接途径_用户权限</code>组成；</p><p>例如:管理平台账号，<code>d_mg_web_dml</code>，<code>d_mg_pc_web_dml</code></p></li></ul><h1 id="其他设计技巧"><a href="#其他设计技巧" class="headerlink" title="其他设计技巧"></a>其他设计技巧</h1><ol><li><p>避免使用存储过程、触发器、视图、自定义函数等，这些高级特性有性能问题，以及未知BUG较多。业务逻辑放到数据库会造成数据库的<code>DDL</code>、<code>SCALE OUT</code>、 <code>SHARDING</code>等变得更加困难。</p></li><li><p>分区表对分区键有严格要求；分区表在表变大后,执行<code>DDL</code>、<code>SHARDING</code>、单表恢复等都变得更加困难。因此禁止使用分区表,并建议业务端手动<code>SHARDING</code>。</p></li><li><p>使用常用英语（或者其他任何语言）而不要使用拼音首字母缩写。</p></li><li><p>将大字段、访问频率低的字段拆分到单独的表中存储，分离冷热数据, 有利于有效利用缓存，防止读入无用的冷数据，较少磁盘IO，同时保证热数据常驻内存提高缓存。</p></li><li><p>禁止有<code>super</code>权限的应用程序账号存在, 安全第一。<code>super</code>权限会导致<code>read only</code>失效，导致较多诡异问题而且很难追踪。</p></li><li><p>不要在MySQL数据库中存放业务逻辑, 数据库是有状态的服务，变更复杂而且速度慢，如果把业务逻辑放到数据库中，将会限制业务的快速发展。建议把业务逻辑提前，放到前端或中间逻辑层，而把数据库作为存储层，实现逻辑与存储的分离。</p></li><li><p>不建议使用<code>enum</code>,<code>set</code>,<code>blob</code>,<code>text</code>字段，如非用<code>blob</code>或<code>text</code>字段，请将<code>blob</code>或<code>text</code>内容存放到文件系统中，数据库中只存放文件系统的<code>url</code>地址，或将该类字段单独存放到一张小表中（首推第一种方法）。</p></li></ol><p>附：建表示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`manager_test`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">20</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`staff_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'操作人员id'</span>,</span><br><span class="line">  <span class="string">`staff_name`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'人员名称'</span>,</span><br><span class="line">  <span class="string">`url`</span> <span class="built_in">varchar</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'操作路径'</span>,</span><br><span class="line">  <span class="string">`method`</span> <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'操作方式'</span>,</span><br><span class="line">  <span class="string">`params`</span> <span class="built_in">varchar</span>(<span class="number">10</span>)<span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'操作参数'</span>,</span><br><span class="line">  <span class="string">`ip`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'ip'</span>,</span><br><span class="line">  <span class="string">`time`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'操作时间'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_staff_id_ct`</span> (<span class="string">`staff_id `</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">1</span><span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</span><br></pre></td></tr></table></figure><h1 id="数据库用户命名规范"><a href="#数据库用户命名规范" class="headerlink" title="数据库用户命名规范"></a>数据库用户命名规范</h1><p>用户命名规则，分为四段，每段规则如下</p><p>示例：<code>d_zq_pc_dml</code></p><ul><li><p>第一段：环境名(<code>d:develop，t:test,p:product</code>)</p></li><li><p>第二段：项目名首字母</p></li><li><p>第三段：连接源(pc:桌面终端，web:程序)</p></li><li><p>第四段：权限(<code>sel:select，dml:select，insert，update，delete</code>)</p></li></ul><p><strong>注意事项：</strong></p><p>禁止程序具有<code>file</code>、<code>super</code>权限。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="MYSQL" scheme="https://www.sakuratears.top/tags/MYSQL/"/>
    
  </entry>
  
  <entry>
    <title>Redis开发规范</title>
    <link href="https://www.sakuratears.top/blog/Redis%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83.html"/>
    <id>https://www.sakuratears.top/blog/Redis开发规范.html</id>
    <published>2020-07-12T08:13:00.000Z</published>
    <updated>2020-07-12T08:14:22.389Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="键值设计"><a href="#键值设计" class="headerlink" title="键值设计"></a>键值设计</h1><h2 id="key名设计"><a href="#key名设计" class="headerlink" title="key名设计"></a>key名设计</h2><ol><li><p>【建议】: 可读性和可管理性</p><p> 以业务名(或数据库名)为前缀(防止key冲突)，用冒号分隔，比如业务名:表名:id</p><p> <code>ugc:video:1</code></p></li><li><p>【建议】：简洁性</p><p> 保证语义的前提下，控制key的长度，当key较多时，内存占用也不容忽视，例如：</p><p> <code>user:{uid}:friends:messages:{mid}</code></p><p> 简化为</p><p> <code>u:{uid}:fr:m:{mid}</code></p></li><li><p>【强制】：不要包含特殊字符</p><p> 反例：包含空格、换行、单双引号以及其他转义字符</p></li></ol><h2 id="value设计"><a href="#value设计" class="headerlink" title="value设计"></a>value设计</h2><ol><li><p>【强制】：拒绝<code>bigkey</code>(防止网卡流量、慢查询)</p><p> <code>String</code>类型控制在10KB以内，<code>hash</code>、<code>list</code>、<code>set</code>、<code>zset</code>元素个数不要超过5000。</p><p> 反例：一个包含200万个元素的<code>list</code>。</p><p> 非字符串的<code>bigkey</code>，不要使用<code>del</code>删除，使用<code>hscan</code>、<code>sscan</code>、<code>zscan</code>方式渐进式删除，同时要注意防止<code>bigkey</code>过期时间自动删除问题(例如一个200万的<code>zset</code>设置1小时过期，会触发del操作，造成阻塞，而且该操作不会不出现在慢查询中(latency可查))，查找方法和删除方法</p></li><li><p>【推荐】：选择适合的数据类型。</p><p> 例如：实体类型(要合理控制和使用数据结构内存编码优化配置,例如<code>ziplist</code>，但也要注意节省内存和性能之间的平衡)</p><p> 反例：</p><p> <code>set user:1:name tom</code></p><p> set user:1:age 19</p><p> set user:1:favor football</p><p> 正例:</p><p> <code>hmset user:1 name tom age 19 favor football</code></p></li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li><p>【推荐】：控制key的生命周期，redis不是垃圾桶。</p><p> 建议使用<code>expire</code>设置过期时间(条件允许可以打散过期时间，防止集中过期)，不过期的数据重点关注<code>idle time</code>。</p></li></ol><h1 id="命令使用"><a href="#命令使用" class="headerlink" title="命令使用"></a>命令使用</h1><ol><li><p>【推荐】 O(N)命令关注N的数量</p><p> 例如<code>hgetall</code>、<code>lrange</code>、<code>smembers</code>、<code>zrange</code>、<code>sinter</code>等并非不能使用，但是需要明确N的值。有遍历的需求可以使用<code>hscan</code>、<code>sscan</code>、<code>zscan</code>代替。</p></li><li><p>【推荐】：禁用命令</p><p> 禁止线上使用<code>keys</code>、<code>flushall</code>、<code>flushdb</code>等，通过redis的<code>rename</code>机制禁掉命令，或者使用<code>scan</code>的方式渐进式处理。</p></li><li><p>【推荐】合理使用<code>select</code></p><p> redis的多数据库较弱，使用数字进行区分，很多客户端支持较差，同时多业务用多数据库实际还是单线程处理，会有干扰。</p></li><li><p>【推荐】使用批量操作提高效率</p><p> 原生命令：例如<code>mget</code>、<code>mset</code>。</p><p> 非原生命令：可以使用<code>pipeline</code>提高效率。</p><p> 但要注意控制一次批量操作的元素个数(例如500以内，实际也和元素字节数有关)。</p><p> 注意两者不同：</p><ul><li>原生是原子操作，<code>pipeline</code>是非原子操作。</li><li><code>pipeline</code>可以打包不同的命令，原生做不到</li><li><code>pipeline</code>需要客户端和服务端同时支持。</li></ul></li><li><p>【建议】Redis事务功能较弱，不建议过多使用</p><p> Redis的事务功能较弱(不支持回滚)，而且集群版本(自研和官方)要求一次事务操作的key必须在一个slot上(可以使用hashtag功能解决)</p></li><li><p>【建议】Redis集群版本在使用Lua上有特殊要求：</p><ul><li>所有key都应该由 KEYS 数组来传递，<code>redis.call/pcall</code> 里面调用的redis命令，key的位置，必须是KEYS array, 否则直接返回error，<code>“-ERR bad lua script for redis cluster, all the keys that the script uses should be passed using the KEYS arrayrn”</code></li><li>所有key，必须在1个slot上，否则直接返回error, <code>“-ERR eval/evalsha command keys must in same slotrn”</code></li></ul></li><li><p>【建议】必要情况下使用<code>monitor</code>命令时，要注意不要长时间使用。</p></li></ol><h1 id="客户端使用"><a href="#客户端使用" class="headerlink" title="客户端使用"></a>客户端使用</h1><ol><li><p>【推荐】 避免多个应用使用一个Redis实例</p><p> 正例：不相干的业务拆分，公共数据做服务化。</p></li><li><p>【推荐】 使用带有连接池的数据库，可以有效控制连接，同时提高效率，标准使用方式：</p></li><li><p>【建议】 高并发下建议客户端添加熔断功能(例如netflix hystrix)</p></li><li><p>【推荐】 设置合理的密码，如有必要可以使用SSL加密访问（阿里云Redis支持）</p></li><li><p>【建议】根据自身业务类型，选好<code>maxmemory-policy</code>(最大内存淘汰策略)，设置好过期时间。</p><p> 默认策略是volatile-lru，即超过最大内存后，在过期键中使用lru算法进行key的剔除，保证不过期数据不被删除，但是可能会出现OOM问题。</p><p> 其他策略如下：</p><ul><li>allkeys-lru：根据LRU算法删除键，不管数据有没有设置超时属性，直到腾出足够空间为止。</li><li>allkeys-random：随机删除所有键，直到腾出足够空间为止。</li><li>volatile-random：随机删除过期键，直到腾出足够空间为止。</li><li>volatile-ttl：根据键值对象的ttl属性，删除最近将要过期数据。如果没有，回退到noeviction策略。</li><li>noeviction：不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息<code>“(error) OOM command not allowed when used memory”</code>，此时Redis只响应读操作。</li></ul></li></ol><h1 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h1><ol><li><p>【推荐】：数据同步</p><p> redis间数据同步可以使用：redis-port</p></li><li><p>【推荐】：big key搜索</p><p> <a href="https://developer.aliyun.com/article/117042" rel="external nofollow noopener noreferrer" target="_blank">redis大key搜索工具</a></p></li><li><p>【推荐】：热点key寻找(内部实现使用monitor，所以建议短时间使用)</p><p> <a href="https://github.com/facebookarchive/redis-faina" rel="external nofollow noopener noreferrer" target="_blank">facebook的redis-faina</a></p><p> PS:阿里云Redis已经在内核层面解决热点key问题。</p></li></ol><h1 id="附录：删除bigkey"><a href="#附录：删除bigkey" class="headerlink" title="附录：删除bigkey"></a>附录：删除bigkey</h1><ul><li><p>下面操作可以使用<code>pipeline</code>加速。</p></li><li><p>redis 4.0已经支持key的异步删除。</p></li></ul><ol><li>Hash删除: hscan + hdel</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delBigHash</span><span class="params">(String host,<span class="keyword">int</span> port,String password,String bigHashKey)</span></span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(host,port);</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isNotEmpty(password))&#123;</span><br><span class="line">        jedis.auth(password);</span><br><span class="line">    &#125;</span><br><span class="line">    ScanParams scanParams = <span class="keyword">new</span> ScanParams().count(<span class="number">100</span>);</span><br><span class="line">    String cursor = <span class="string">"0"</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        ScanResult&lt;Map.Entry&lt;String,String&gt;&gt; scanResult = jedis.hscan(bigHashKey,cursor,scanParams);</span><br><span class="line">        List&lt;Map.Entry&lt;String,String&gt;&gt; entryList = scanResult.getResult();</span><br><span class="line">        <span class="keyword">if</span>(CollectionUtils.isNotEmpty(entryList))&#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : entryList) &#123;</span><br><span class="line">                jedis.hdel(bigHashKey,entry.getKey());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = scanResult.getStringCursor();</span><br><span class="line">    &#125;<span class="keyword">while</span> (!<span class="string">"0"</span>.equals(cursor));</span><br><span class="line">    <span class="comment">//删除bigHashKey</span></span><br><span class="line">    jedis.del(bigHashKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>List删除: ltrim</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delBigList</span><span class="params">(String host,<span class="keyword">int</span> port,String password,String bigListKey)</span></span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(host,port);</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isNotEmpty(password))&#123;</span><br><span class="line">        jedis.auth(password);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> llen = jedis.llen(bigListKey);</span><br><span class="line">    <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">while</span> (counter&lt;llen)&#123;</span><br><span class="line">        <span class="comment">//每次从左边截掉100个</span></span><br><span class="line">        jedis.ltrim(bigListKey,left,llen);</span><br><span class="line">        counter += left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除bigListKey</span></span><br><span class="line">    jedis.del(bigListKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>Set删除: sscan + srem</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delBigSet</span><span class="params">(String host,<span class="keyword">int</span> port,String password,String bigSetKey)</span></span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(host,port);</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isNotEmpty(password))&#123;</span><br><span class="line">        jedis.auth(password);</span><br><span class="line">    &#125;</span><br><span class="line">    ScanParams scanParams = <span class="keyword">new</span> ScanParams().count(<span class="number">100</span>);</span><br><span class="line">    String cursor = <span class="string">"0"</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        ScanResult&lt;String&gt; scanResult = jedis.sscan(bigSetKey,cursor,scanParams);</span><br><span class="line">        List&lt;String&gt; memberList = scanResult.getResult();</span><br><span class="line">        <span class="keyword">if</span>(CollectionUtils.isNotEmpty(memberList))&#123;</span><br><span class="line">            <span class="keyword">for</span> (String s : memberList) &#123;</span><br><span class="line">                jedis.srem(bigSetKey,s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = scanResult.getStringCursor();</span><br><span class="line">    &#125;<span class="keyword">while</span> (!<span class="string">"0"</span>.equals(cursor));</span><br><span class="line">    <span class="comment">//删除bigSetKey</span></span><br><span class="line">    jedis.del(bigSetKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>SortedSet删除: zscan + zrem</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delBigZset</span><span class="params">(String host,<span class="keyword">int</span> port,String password,String bigZsetKey)</span></span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(host,port);</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isNotEmpty(password))&#123;</span><br><span class="line">        jedis.auth(password);</span><br><span class="line">    &#125;</span><br><span class="line">    ScanParams scanParams = <span class="keyword">new</span> ScanParams().count(<span class="number">100</span>);</span><br><span class="line">    String cursor = <span class="string">"0"</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        ScanResult&lt;Tuple&gt; scanResult = jedis.zscan(bigZsetKey,cursor,scanParams);</span><br><span class="line">        List&lt;Tuple&gt; tupleList = scanResult.getResult();</span><br><span class="line">        <span class="keyword">if</span>(CollectionUtils.isNotEmpty(tupleList))&#123;</span><br><span class="line">            <span class="keyword">for</span> (Tuple tuple : tupleList) &#123;</span><br><span class="line">                jedis.zrem(bigZsetKey,tuple.getElement());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = scanResult.getStringCursor();</span><br><span class="line">    &#125;<span class="keyword">while</span> (!<span class="string">"0"</span>.equals(cursor));</span><br><span class="line">    <span class="comment">//删除bigZsetKey</span></span><br><span class="line">    jedis.del(bigZsetKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Redis" scheme="https://www.sakuratears.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Gson转换遇到的问题</title>
    <link href="https://www.sakuratears.top/blog/Gson%E8%BD%AC%E6%8D%A2%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98.html"/>
    <id>https://www.sakuratears.top/blog/Gson转换遇到的问题.html</id>
    <published>2020-06-20T08:25:00.000Z</published>
    <updated>2020-06-20T08:32:08.567Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天在项目中遇到了一个Gson转换数字后会变为Double类型引起的Bug，特此记录一下。</p><p>背景是这样的，我们对于前端请求，有一个公共处理Controller，并根据请求里的接口名称将其分发给其他处理类（Controller）。</p><p>因为每个处理类的请求类Req和返回Res是不同的，但是它们的响应code和原因是可以提取的，因此拿到前端数据后，我们后台会处理并返回数据。</p><p>Req如下，我们会根据前端在Header和传过来的data数据组成如下Req分发给指定apiName的Controller。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonReq</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line">    <span class="keyword">private</span> String apiName;</span><br><span class="line">    <span class="keyword">private</span> String device;</span><br><span class="line">    <span class="keyword">private</span> String platform;</span><br><span class="line">    <span class="keyword">private</span> String version;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个业务实体类TestReq，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReq</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一切都是很正常的，直到我们升级了FastJson的版本后，便出现了异常。</p><h1 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h1><p>尝试定位问题，发现是枚举值转换抛出的异常，我们有一个枚举值，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Type &#123;</span><br><span class="line">    A(<span class="string">"1"</span>, <span class="string">"A"</span>),</span><br><span class="line">    B(<span class="string">"2"</span>, <span class="string">"B"</span>);</span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">    Type(String code, String desc) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCode</span><span class="params">(String code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDesc</span><span class="params">(String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Type <span class="title">getEnum</span><span class="params">(String code)</span> </span>&#123;</span><br><span class="line">        Optional&lt;Type&gt; optional = Arrays.stream(Type.values()).filter(e -&gt; e.code.equals(code)).findFirst();</span><br><span class="line">        <span class="keyword">return</span> optional.orElse(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前端传过来的为1，我们转换传A，这样。</p><p>跟踪了一下，发现原来过来的是”1”，但是现在变成了”1.0”。因此转换异常了。</p><p>继续检查，发现前端传的数据为int类型的1（其实我们接口定义的String），如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"apiName"</span>:<span class="string">"test"</span>,<span class="attr">"version"</span>:<span class="string">"v1"</span>,<span class="attr">"data"</span>:&#123;<span class="attr">"amount"</span>:<span class="string">"3672.0"</span>,<span class="attr">"type"</span>:<span class="number">1</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>然后我们系统会将该数据转化为<code>CommonReq&lt;TestReq></code>对象。</p><p>转化的时候我们发现<code>TestReq</code>里得到的type已经是1.0了。</p><p>继续检查发现在前端数据请求过来后，使用的是Gson进行转化的，由于不知道泛型T的具体类型，因此转换逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CommonReq commonReq = GsonUtil.json2Bean(str,CommonReq.class);</span><br></pre></td></tr></table></figure><p>我自己编写了测试类，经过测试，发现Gson确实会把1转换为1.0，但针对的是该类型不明的情况，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"&#123;\"apiName\":\"test\",\"version\":\"v1\",\"data\":&#123;\"amount\":\"3672.0\",\"type\":1&#125;&#125;"</span>;</span><br><span class="line">        CommonReq commonReq = GsonUtil.json2Bean(str,CommonReq.class);</span><br><span class="line">        LinkedTreeMap linkedTreeMap = (LinkedTreeMap) commonReq.getData();</span><br><span class="line">        System.out.println(linkedTreeMap.get(<span class="string">"type"</span>));;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-623.jpg" alt="upload successful"></p><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>但我观察之前请求的日志，前端传的也是int类型的1，但转换后就是”1”，而不是”1.0”，这又是什么原因呢。</p><p>由于我们升级过一次FastJson版本，但Gson的问题和FastJson又有什么关系呢？</p><p>因此继续排查，我发现了一个特别的地方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(commonReq.getData() <span class="keyword">instanceof</span> LinkedHashMap||commonReq.getData() <span class="keyword">instanceof</span> LinkedTreeMap) &#123;</span><br><span class="line">                String jsonStr = FastJsonConvert.convertObjectToJSON(commonReq.getData());</span><br><span class="line">                commonReq.setData(apiService.convertRequest(jsonStr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其重点在于<code>FastJsonConvert.convertObjectToJSON(reqVo.getData())</code>这段代码上。</p><p>我们看上面的列子，使用Gson转换后<code>CommonReq</code> 里的data对象为<code>LinkedTreeMap</code>，不能直接强转为<code>TestReq</code>对象，因此借助了FastJson将其转换为jsonStr，然后再转回来。</p><p>这样就会不同吗？</p><p>在升级之前，我们使用的FastJson是1.2.10，升级后为1.2.70。</p><p>我们使用1.2.10的FastJson，对Gson得到的<code>LinkedTreeMap</code>进行转换输出，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.10&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"&#123;\"apiName\":\"test\",\"version\":\"v1\",\"data\":&#123;\"amount\":\"3672.0\",\"type\":1&#125;&#125;"</span>;</span><br><span class="line">        CommonReq commonReq = GsonUtil.json2Bean(str,CommonReq.class);</span><br><span class="line">        String jsonStr = FastJsonUtil.bean2Json(commonReq.getData());</span><br><span class="line">        System.out.println(jsonStr);;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-624.jpg" alt="upload successful"></p><p>可以看到type为1.</p><p>我们继续使用1.2.70版本的FastJson进行试验时，可以看到它输出了1.0.</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-625.jpg" alt="upload successful"></p><p>我们实际对FastJson进行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TestVO testVO = <span class="keyword">new</span> TestVO();</span><br><span class="line">testVO.setF(<span class="number">1.0</span>);</span><br><span class="line">String jsonStr = FastJsonUtil.bean2Json(testVO);</span><br><span class="line">System.out.println(jsonStr);</span><br></pre></td></tr></table></figure><p>在1.2.10版本下，FastJson输出了<code>{“f”:1}</code>，在1.2.70版本下，输出了<code>{“f”:1.0}</code>。</p><p>在低版本下，未指定对象类型情况下，FastJson对于小数数字末尾包含0的，都会舍去。</p><p>到这里其实问题也比较清楚了，由于Gson对于未指定类型的数字，会将其转换成Double类型，而FastJson低版本中，对于未指定的浮点数字，如果末尾为0，就会去掉，进而显示整数，而在高版本里解决了这个问题。</p><p>我们系统升级了FastJson，因而出现了问题。</p><p>但归根结底这个问题是由Gson引起的，因为Gson对于未指定类型的数字，会将其转换成Double类型，至目前原作者也没有修复这个问题。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过这个问题排查总结，我们能从中学到一点有用的东西。</p><ol><li>在一个项目中尽量使用一种Json转换工具，如Jackson、Fastjson、Gson，将它们在项目中混用既不方便维护，也加大了问题的排查难度，而且不同的Json转换工具转换出来的Json串可能相互处理起来并不友好。</li><li><p>这个问题，我们最终将Gson替换为Fastjson，从而解决了问题。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-626.jpg" alt="upload successful"></p><p>可以看到只使用FastJson，我们得到的数据不会被转换为Double。</p></li><li><p>在与客户端商定报文格式时，客户端应尽量传送的报文格式与服务端定义的类型一致。</p></li><li><p>关于如果使用Gson，如何避免出现未指定类型的整数转换为double的问题，可以参考这篇文章。</p><p><a href="https://stackoverflow.com/questions/36508323/how-can-i-prevent-gson-from-converting-integers-to-doubles" rel="external nofollow noopener noreferrer" target="_blank">how-can-i-prevent-gson-from-converting-integers-to-doubles</a></p></li></ol><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>其实客户端应该上送String类型的1而不是int类型的，但考虑但客户端需要发版，且旧版本客户端后端仍需要兼容，进而改为让服务端进行兼容改造，客户端迭代进行变更处理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="FastJson" scheme="https://www.sakuratears.top/tags/FastJson/"/>
    
      <category term="Gson" scheme="https://www.sakuratears.top/tags/Gson/"/>
    
  </entry>
  
  <entry>
    <title>【转】Java 12 特性及更新</title>
    <link href="https://www.sakuratears.top/blog/%E3%80%90%E8%BD%AC%E3%80%91Java-12-%E7%89%B9%E6%80%A7%E5%8F%8A%E6%9B%B4%E6%96%B0.html"/>
    <id>https://www.sakuratears.top/blog/【转】Java-12-特性及更新.html</id>
    <published>2020-04-29T06:46:00.000Z</published>
    <updated>2020-04-29T06:48:01.856Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://howtodoinjava.com/java12/new-features-enhancements/" rel="external nofollow noopener noreferrer" target="_blank">原文链接</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java 12(发布于2019年3月19日)是JDK的最新版本。让我们看看它为开发人员和架构师带来的新特性和改进。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Stream-API-新的方法-Collectors-teeing"><a href="#Stream-API-新的方法-Collectors-teeing" class="headerlink" title="Stream API 新的方法 Collectors.teeing()"></a>Stream API 新的方法 Collectors.teeing()</h2><p>此收集器将其输入转发给其他两个收集器，然后将它们的结果与一个函数合并。它是一个静态方法<code>Collectors::teeing</code>.</p><p><code>teeing(Collector, Collector, BiFunction)</code> 接受两个收集器和一个函数来合并它们的结果。传递给结果收集器的每个元素都由两个下游收集器处理，然后使用指定的merge函数将它们的结果合并到最终结果中。</p><p>例如，在给定的雇员列表中，如果我们想要找出拥有最高工资和最低工资的雇员，我们可以使用此收集器在单个语句中完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SalaryRange salaryRange = Stream</span><br><span class="line">            .of(<span class="number">56700</span>, <span class="number">67600</span>, <span class="number">45200</span>, <span class="number">120000</span>, <span class="number">77600</span>, <span class="number">85000</span>)</span><br><span class="line">            .collect(teeing(</span><br><span class="line">                    minBy(Integer::compareTo), </span><br><span class="line">                    maxBy(Integer::compareTo), </span><br><span class="line">                    SalaryRange::fromOptional));</span><br></pre></td></tr></table></figure><p>关于更多的关于此收集器的内容，可以查看<a href="https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/stream/Collectors.html#teeing(java.util.stream.Collector,java.util.stream.Collector,java.util.function.BiFunction" rel="external nofollow noopener noreferrer" target="_blank">Collectors.teeing()</a>)这篇文章。</p><h2 id="String-API-变化"><a href="#String-API-变化" class="headerlink" title="String API 变化"></a>String API 变化</h2><h3 id="String-indent"><a href="#String-indent" class="headerlink" title="String.indent()"></a>String.indent()</h3><p>这个缩进方法有助于更改字符串的缩进。我们可以传递一个正值，也可以传递一个负值，这取决于我们是想要添加更多的空白还是删除现有的空白。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String result = <span class="string">"foo\nbar\nbar2"</span>.indent(<span class="number">4</span>);</span><br><span class="line"> </span><br><span class="line">System.out.println(result);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//    foo</span></span><br><span class="line"><span class="comment">//    bar</span></span><br><span class="line"><span class="comment">//    bar2</span></span><br></pre></td></tr></table></figure><p>需要注意，indent()方法会自动添加新行字符(如果没有的话)。这是意料之中的，也是新方法的一个特点。</p><blockquote><p>每个空白字符都被视为单个字符。特别是制表符<code>“\t” (U+0009)</code>被认为是单个字符;它没有展开。</p></blockquote><h3 id="String-transform"><a href="#String-transform" class="headerlink" title="String.transform()"></a>String.transform()</h3><p><code>transform()</code>方法获取一个字符串，并在函数的帮助下将其转换为一个新字符串。</p><p>在给定的示例中，我们有一个名称列表。我们使用<code>transform()</code>方法执行两个操作(删除空白和将所有名称设置为大小写)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = List.of(</span><br><span class="line">                        <span class="string">"   Alex"</span>,</span><br><span class="line">                        <span class="string">"brian"</span>);</span><br><span class="line"> </span><br><span class="line">List&lt;String&gt; transformedNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (String name : names) </span><br><span class="line">&#123;</span><br><span class="line">    String transformedName = name.transform(String::strip)</span><br><span class="line">                                .transform(StringUtils::toCamelCase);</span><br><span class="line"> </span><br><span class="line">    transformedNames.add(transformedName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="String-constants"><a href="#String-constants" class="headerlink" title="String constants"></a>String constants</h3><p>从Java 12开始，String类实现了两个额外的接口<code> java.lang.constant.Constable</code>和<code>java.lang.constant.ConstantDesc</code>。</p><p><code>String</code>类还引入了另外两个低级方法<code>describeConstable()</code>和<code>resolveConstantDesc(MethodHandles.Lookup)</code>。</p><p>它们是低级api，用于库和提供字节码解析和生成功能的工具，例如Byte Buddy。</p><p>注意，<code>Constable</code>类型的值是常量，可以在<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.4" rel="external nofollow noopener noreferrer" target="_blank">JVMS 4.4</a>中描述的Java类文件的常量池中表示，它的实例可以在名义上将自己描述为<code>ConstantDesc</code>。</p><p><code>resolveConstantDesc()</code>类似于<code>describeConstable()</code>，不同之处在于这个方法返回的是<code>ConstantDesc</code>的一个实例。</p><h2 id="Files-mismatch-Path-Path"><a href="#Files-mismatch-Path-Path" class="headerlink" title="Files.mismatch(Path, Path)"></a>Files.mismatch(Path, Path)</h2><p>有时，我们希望确定两个文件是否具有相同的内容。这个API有助于比较文件的内容。</p><p><code>mismatch()</code>方法比较两个文件路径并返回一个long值。long值表示两个文件内容中<strong>第一个不匹配的字节</strong>的位置。如果文件内容相同，返回值将是“-1”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Path helloworld1 = tempDir.resolve(<span class="string">"helloworld1.txt"</span>);</span><br><span class="line"> </span><br><span class="line">Path helloworld2 = tempDir.resolve(<span class="string">"helloworld2.txt"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">long</span> diff = Files.mismatch(helloworld1, helloworld2);   <span class="comment">//returns long value</span></span><br></pre></td></tr></table></figure><h2 id="数字格式"><a href="#数字格式" class="headerlink" title="数字格式"></a>数字格式</h2><p>由用户界面或命令行工具呈现的大数字总是很难解析。使用数字的缩写形式要普遍得多。紧凑的数字表示更易于阅读，并且在不丢失原始含义的情况下，在屏幕上需要更少的空间。</p><p>例: <code>3.6 M</code> 比 <code>3,600,000</code> 容易读得多。</p><p>Java 12引入了一个<code>NumberFormat.getCompactNumberInstance(Locale, NumberFormat.Style)</code>的方便方法用于创建紧凑数字表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NumberFormat formatter = NumberFormat.getCompactNumberInstance(Locale.US,</span><br><span class="line">                                                        NumberFormat.Style.SHORT);</span><br><span class="line"> </span><br><span class="line">String formattedString = formatter.format(<span class="number">25000L</span>);      <span class="comment">//25K</span></span><br></pre></td></tr></table></figure><h2 id="Unicode-11-相关支持"><a href="#Unicode-11-相关支持" class="headerlink" title="Unicode 11 相关支持"></a>Unicode 11 相关支持</h2><p>在一个emoji表情符号在社交媒体渠道上扮演着重要角色的时代，支持最新的Unicode规范比以往任何时候都更重要。Java 12保持了同步并支持Unicode 11。</p><p>Unicode 11增加了684个字符，总共有137374个字符，还有7个新脚本，总共有146个脚本。</p><h2 id="switch-表达式扩展"><a href="#switch-表达式扩展" class="headerlink" title="switch 表达式扩展"></a>switch 表达式扩展</h2><p>这个更改扩展了switch语句，因此它既可以用作语句，也可以用作表达式。</p><p>我们可以简单地使用箭头语法，而不必为每个case块定义一个break语句。箭头语法在语义上看起来像一个lambda，它将大小写标签从表达式中分离出来。</p><p>使用新的switch表达式，我们可以直接将switch语句分配给一个变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isWeekend = <span class="keyword">switch</span> (day) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -&gt; <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> SATURDAY, SUNDAY -&gt; <span class="keyword">true</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">default</span> -&gt; <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Illegal day entry :: "</span> + day);</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">System.out.println(isWeekend);<span class="comment">//根据输入日期返回true或false</span></span><br></pre></td></tr></table></figure><blockquote><p>要使用此特性，请记住，我们必须在应用程序启动期间使用<code>-enable-preview</code>标志显式地指示JVM。</p></blockquote><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>以上就是关于Java 12 的全部内容。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java 12" scheme="https://www.sakuratears.top/tags/Java-12/"/>
    
  </entry>
  
  <entry>
    <title>【转】Java 11 特性及更新</title>
    <link href="https://www.sakuratears.top/blog/%E3%80%90%E8%BD%AC%E3%80%91Java-11-%E7%89%B9%E6%80%A7%E5%8F%8A%E6%9B%B4%E6%96%B0.html"/>
    <id>https://www.sakuratears.top/blog/【转】Java-11-特性及更新.html</id>
    <published>2020-04-23T06:46:00.000Z</published>
    <updated>2020-04-23T06:48:45.136Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://howtodoinjava.com/java11/features-enhancements/" rel="external nofollow noopener noreferrer" target="_blank">原文链接</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java 11(于2018年9月发布)包含许多重要和有用的更新。让我们看看它为开发人员和架构师带来的新特性和改进。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="HTTP-Client-API"><a href="#HTTP-Client-API" class="headerlink" title="HTTP Client API"></a>HTTP Client API</h2><p>Java长期使用HttpURLConnection类进行HTTP通信。但是随着时间的推移，需求变得越来越复杂，对应用程序的要求也越来越高。在Java 11之前，开发人员不得不求助于功能丰富的库，如<em>Apache HttpComponents</em>或<em>OkHttp</em>等。</p><p>我们看到Java 9发布版将<code>HttpClient</code>实现作为一个实验性特性包括在内。它随着时间的推移而发展，现在是Java 11的最后一个特性。现在，Java应用程序可以进行HTTP通信，而不需要任何外部依赖。</p><h3 id="如何使用HttpClient"><a href="#如何使用HttpClient" class="headerlink" title="如何使用HttpClient"></a>如何使用HttpClient</h3><p>它与<code>java.net.http</code>模块的经典HTTP通信是类似的：</p><ul><li>创建一个HttpClient实例，并根据需要配置它。</li><li>创建HttpRequest实例并填充信息。</li><li>将请求传递给客户机，执行请求并检索HttpResponse的实例。</li><li>处理HttpResponse中包含的信息。</li></ul><p>HTTP API可以处理同步和异步通信。让我们来看一个简单的例子。</p><h3 id="同步请求例子"><a href="#同步请求例子" class="headerlink" title="同步请求例子"></a>同步请求例子</h3><p>注意，Http客户端API如何使用builder模式来创建复杂对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> java.net.http.HttpClient;</span><br><span class="line"><span class="keyword">import</span> java.net.http.HttpRequest;</span><br><span class="line"><span class="keyword">import</span> java.net.http.HttpResponse;</span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"> </span><br><span class="line">HttpClient httpClient = HttpClient.newBuilder()</span><br><span class="line">                        .connectTimeout(Duration.ofSeconds(<span class="number">10</span>))</span><br><span class="line">                        .build();                                  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    String urlEndpoint = <span class="string">"https://postman-echo.com/get"</span>;</span><br><span class="line">    URI uri = URI.create(urlEndpoint + <span class="string">"?foo1=bar1&amp;foo2=bar2"</span>);</span><br><span class="line">    HttpRequest request = HttpRequest.newBuilder()</span><br><span class="line">                                    .uri(uri)</span><br><span class="line">                                    .build();                              </span><br><span class="line">    HttpResponse&lt;String&gt; response = httpClient.send(request,</span><br><span class="line">                                        HttpResponse.BodyHandlers.ofString()); </span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">System.out.println(<span class="string">"Status code: "</span> + response.statusCode());                            </span><br><span class="line">System.out.println(<span class="string">"Headers: "</span> + response.headers().allValues(<span class="string">"content-type"</span>));               </span><br><span class="line">System.out.println(<span class="string">"Body: "</span> + response.body());</span><br></pre></td></tr></table></figure><h3 id="异步请求例子"><a href="#异步请求例子" class="headerlink" title="异步请求例子"></a>异步请求例子</h3><p>如果我们不想等待响应，可以使用异步通信。我们提供回调处理程序，它在响应可用时执行。</p><p>注意使用<code>sendAsync()</code>方法发送异步请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> java.net.http.HttpClient;</span><br><span class="line"><span class="keyword">import</span> java.net.http.HttpRequest;</span><br><span class="line"><span class="keyword">import</span> java.net.http.HttpResponse;</span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.Collectors.toList;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">final</span> List&lt;URI&gt; uris = Stream.of(</span><br><span class="line">                        <span class="string">"https://www.google.com/"</span>,</span><br><span class="line">                        <span class="string">"https://www.github.com/"</span>,</span><br><span class="line">                        <span class="string">"https://www.yahoo.com/"</span></span><br><span class="line">                        ).map(URI::create).collect(toList());      </span><br><span class="line"> </span><br><span class="line">HttpClient httpClient = HttpClient.newBuilder()</span><br><span class="line">                        .connectTimeout(Duration.ofSeconds(<span class="number">10</span>))</span><br><span class="line">                        .followRedirects(HttpClient.Redirect.ALWAYS)</span><br><span class="line">                        .build();</span><br><span class="line"> </span><br><span class="line">CompletableFuture[] futures = uris.stream()</span><br><span class="line">                            .map(uri -&gt; verifyUri(httpClient, uri))</span><br><span class="line">                            .toArray(CompletableFuture[]::<span class="keyword">new</span>);     </span><br><span class="line"> </span><br><span class="line">CompletableFuture.allOf(futures).join();           </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> CompletableFuture&lt;Void&gt; <span class="title">verifyUri</span><span class="params">(HttpClient httpClient, </span></span></span><br><span class="line"><span class="function"><span class="params">                                          URI uri)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HttpRequest request = HttpRequest.newBuilder()</span><br><span class="line">                                    .timeout(Duration.ofSeconds(<span class="number">5</span>))</span><br><span class="line">                                    .uri(uri)</span><br><span class="line">                                    .build();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> httpClient.sendAsync(request,HttpResponse.BodyHandlers.ofString())</span><br><span class="line">                        .thenApply(HttpResponse::statusCode)</span><br><span class="line">                        .thenApply(statusCode -&gt; statusCode == <span class="number">200</span>)</span><br><span class="line">                        .exceptionally(ex -&gt; <span class="keyword">false</span>)</span><br><span class="line">                        .thenAccept(valid -&gt; </span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">                                System.out.println(<span class="string">"[SUCCESS] Verified "</span> + uri);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                System.out.println(<span class="string">"[FAILURE] Could not "</span> + <span class="string">"verify "</span> + uri);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);                                    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不用编译运行一个单文件项目"><a href="#不用编译运行一个单文件项目" class="headerlink" title="不用编译运行一个单文件项目"></a>不用编译运行一个单文件项目</h2><p>通常，对于我们想要执行的每个程序，我们都需要首先编译它为class文件。对于用于测试的小程序来说，这似乎是一个不必要的冗长过程。</p><p>Java 11做出了改变，现在我们可以执行包含在单个文件中的Java源代码，而不需要首先编译它。</p><p><strong>HelloWorld.java</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>要执行上面的类，直接用<code>java</code>命令运行它。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ java HelloWorld.java</span><br><span class="line"> </span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，程序不能使用除<code>java.base</code>模块之外的任何外部依赖项，并且程序只能是单文件程序。</p></blockquote><h2 id="String-API变更"><a href="#String-API变更" class="headerlink" title="String API变更"></a>String API变更</h2><h3 id="String-repeat-Integer"><a href="#String-repeat-Integer" class="headerlink" title="String.repeat(Integer)"></a>String.repeat(Integer)</h3><p>这个方法简单地重复一个字符串n次。它返回一个字符串，其值是重复N次的给定字符串的串联。</p><p>如果该字符串为空或count为零，则返回空字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String str = <span class="string">"1"</span>.repeat(<span class="number">5</span>);</span><br><span class="line"> </span><br><span class="line">        System.out.println(str);    <span class="comment">//11111</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="String-isBlank"><a href="#String-isBlank" class="headerlink" title="String.isBlank()"></a>String.isBlank()</h3><p>此方法判断字符串是否为空或者为空字符串。在此之前，我们一直在使用Apache开源包的<code>StringUtils.java</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="string">"1"</span>.isBlank();  <span class="comment">//false</span></span><br><span class="line"> </span><br><span class="line">        <span class="string">""</span>.isBlank();   <span class="comment">//true</span></span><br><span class="line"> </span><br><span class="line">        <span class="string">"    "</span>.isBlank();   <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="String-strip"><a href="#String-strip" class="headerlink" title="String.strip()"></a>String.strip()</h3><p>此方法负责删除开头和结尾空白。我们可以更具体地使用<code>String.stripLeading() </code>删除开头空白，或者使用<code>String.stripTrailing()</code>删除结尾空白。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="string">"   hi  "</span>.strip();  <span class="comment">//"hi"</span></span><br><span class="line"> </span><br><span class="line">       <span class="string">"   hi  "</span>.stripLeading();    <span class="comment">//"hi   "</span></span><br><span class="line"> </span><br><span class="line">       <span class="string">"   hi  "</span>.stripTrailing();   <span class="comment">//"   hi"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="String-lines"><a href="#String-lines" class="headerlink" title="String.lines()"></a>String.lines()</h3><p>这个方法有助于将多行文本处理为一个流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String testString = <span class="string">"hello\nworld\nis\nexecuted"</span>;</span><br><span class="line"> </span><br><span class="line">        List&lt;String&gt; lines = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">        testString.lines().forEach(line -&gt; lines.add(line));</span><br><span class="line"> </span><br><span class="line">        assertEquals(List.of(<span class="string">"hello"</span>, <span class="string">"world"</span>, <span class="string">"is"</span>, <span class="string">"executed"</span>), lines);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Collection-toArray-IntFunction"><a href="#Collection-toArray-IntFunction" class="headerlink" title="Collection.toArray(IntFunction)"></a>Collection.toArray(IntFunction)</h2><p>在Java 11之前，将集合转换为数组并不方便。Java 11使转换更加方便。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        names.add(<span class="string">"alex"</span>);</span><br><span class="line">        names.add(<span class="string">"brian"</span>);</span><br><span class="line">        names.add(<span class="string">"charles"</span>);</span><br><span class="line"> </span><br><span class="line">        String[] namesArr1 = names.toArray(<span class="keyword">new</span> String[names.size()]);       <span class="comment">//Before Java 11</span></span><br><span class="line"> </span><br><span class="line">        String[] namesArr2 = names.toArray(String[]::<span class="keyword">new</span>);                  <span class="comment">//Since Java 11</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Files-readString-和-Files-writeString"><a href="#Files-readString-和-Files-writeString" class="headerlink" title="Files.readString() 和 Files.writeString()"></a>Files.readString() 和 Files.writeString()</h2><p>使用这些重载的方法，Java 11旨在减少大量的样板代码，使文件的读写更加容易。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//Read file as string</span></span><br><span class="line">        URI txtFileUri = getClass().getClassLoader().getResource(<span class="string">"helloworld.txt"</span>).toURI();</span><br><span class="line"> </span><br><span class="line">        String content = Files.readString(Path.of(txtFileUri),Charset.defaultCharset());</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//Write string to file</span></span><br><span class="line">        Path tmpFilePath = Path.of(File.createTempFile(<span class="string">"tempFile"</span>, <span class="string">".tmp"</span>).toURI());</span><br><span class="line"> </span><br><span class="line">        Path returnedFilePath = Files.writeString(tmpFilePath,<span class="string">"Hello World!"</span>, </span><br><span class="line">                                    Charset.defaultCharset(), StandardOpenOption.WRITE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Optional-isEmpty"><a href="#Optional-isEmpty" class="headerlink" title="Optional.isEmpty()"></a>Optional.isEmpty()</h2><p>Optional是一个容器对象，它可以包含也可以不包含一个非空值。如果没有值，则认为该对象是空的。</p><p>如果存在值，则先前存在的方法<code>isPresent()</code>返回true，否则返回false。有时，它迫使我们写出不方便阅读的判断语句。</p><p><code>isEmpty()</code>方法与<code>isPresent()</code>方法相反，如果有值，则返回false，否则返回true。</p><p>所以在任何情况下我们都不需要写出相反的条件。在适当的时候使用这两种方法中的任何一种。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String currentTime = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">        assertTrue(!Optional.ofNullable(currentTime).isPresent());  <span class="comment">//It's negative condition</span></span><br><span class="line">        assertTrue(Optional.ofNullable(currentTime).isEmpty());     <span class="comment">//Write it like this</span></span><br><span class="line"> </span><br><span class="line">        currentTime = <span class="string">"12:00 PM"</span>;</span><br><span class="line"> </span><br><span class="line">        assertFalse(!Optional.ofNullable(currentTime).isPresent()); <span class="comment">//It's negative condition</span></span><br><span class="line">        assertFalse(Optional.ofNullable(currentTime).isEmpty());    <span class="comment">//Write it like this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>以上就是关于Java 11 更新的内容。</p><p>相关链接: <a href="https://docs.oracle.com/en/java/javase/11/" rel="external nofollow noopener noreferrer" target="_blank">Java 11 release doc</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java 11" scheme="https://www.sakuratears.top/tags/Java-11/"/>
    
  </entry>
  
  <entry>
    <title>【转】Java 10 特性及更新</title>
    <link href="https://www.sakuratears.top/blog/Java-10-%E7%89%B9%E6%80%A7%E5%8F%8A%E6%9B%B4%E6%96%B0.html"/>
    <id>https://www.sakuratears.top/blog/Java-10-特性及更新.html</id>
    <published>2020-04-21T08:37:00.000Z</published>
    <updated>2020-04-21T09:00:49.108Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://howtodoinjava.com/java10/java10-features/" rel="external nofollow noopener noreferrer" target="_blank">原文链接</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在Java 9发布之后，Java 10很快就出现了。与之前的版本不同，Java 10没有那么多令人兴奋的特性，但是它仍然有一些重要的更新，这些更新将改变我们编写代码的方式，以及其他未来的Java版本。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="局部变量类型推断（Local-Variable-Type-Inference）"><a href="#局部变量类型推断（Local-Variable-Type-Inference）" class="headerlink" title="局部变量类型推断（Local Variable Type Inference）"></a>局部变量类型推断（Local Variable Type Inference）</h2><p>Java现在有了<code>var</code>样式声明。它允许我们在不指定类型的情况下声明局部变量。变量的类型将从实际创建的对象的类型中推断出来。</p><p>这个特性对Java 10开发人员来说可以说是唯一的特性，因为其它Java 10的特性更新离我们编码较远。</p><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var str = <span class="string">"Hello world"</span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//or</span></span><br><span class="line">  </span><br><span class="line">String str = <span class="string">"Hello world"</span>;</span><br></pre></td></tr></table></figure><p>在上面的例子中，两个语句是等价的。在第一个语句中，str的类型由赋值类型决定，赋值类型为字符串类型。</p><p>想了解更多有关内容，可以阅读这篇文章<a href="https://www.sakuratears.top/blog/Java-10-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD.html#more">Java 10 局部变量类型推断</a>。</p><h2 id="基于时间的发布版本（Time-Based-Release-Versioning）"><a href="#基于时间的发布版本（Time-Based-Release-Versioning）" class="headerlink" title="基于时间的发布版本（Time-Based Release Versioning）"></a>基于时间的发布版本（Time-Based Release Versioning）</h2><p>从Java 10开始，Oracle已经采用了基于时间的版本字符串模式。版本号的新格式为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$FEATURE.$INTERIM.$UPDATE.$PATCH</span><br></pre></td></tr></table></figure><p>与旧版本不同的是，基于时间的新版本不会延迟发布，新功能将每六个月发布一次，对新版本中可以发布哪些功能没有限制。</p><p>还有长期发行版本(LTS)。主要面向企业客户。LTS版本的产品将由Oracle公司提供卓越和持续的支持。此外，这些版本的更新将至少在三年内可用。</p><p>关于该部分的更多内容，可以查看这篇文章<a href="https://www.sakuratears.top/blog/Java-10-%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E7%9A%84%E5%8F%91%E5%B8%83%E7%89%88%E6%9C%AC.html#more">Java 10 基于时间的发布版本</a>.</p><h2 id="垃圾收集器接口（Garbage-Collector-Interface）"><a href="#垃圾收集器接口（Garbage-Collector-Interface）" class="headerlink" title="垃圾收集器接口（Garbage-Collector Interface）"></a>垃圾收集器接口（Garbage-Collector Interface）</h2><p>在早期的JDK结构中，组成垃圾收集器(GC)实现的组件分散在代码库的各个部分。它在Java 10中进行了变化。现在，它是JVM源代码中的一个干净的接口，允许快速、轻松地集成替代收集器。它将改进不同垃圾收集器的源代码隔离。</p><p>这是一次非常重要的重构，以使得垃圾收集器可以适应过去现在及未来的需要。</p><h2 id="G1的并行Full-GC（Parallel-Full-GC-for-G1）"><a href="#G1的并行Full-GC（Parallel-Full-GC-for-G1）" class="headerlink" title="G1的并行Full GC（Parallel Full GC for G1）"></a>G1的并行Full GC（Parallel Full GC for G1）</h2><p>Java 9引入了 G1(garbage first) 垃圾收集器。G1垃圾收集器的设计是为了避免Full GC，但当并发收集不能足够快地回收内存时。有了这个更改，就会发生 Full GC。</p><p>G1 Full GC 实现使用的是单线程 标记-清除-压缩（mark-sweep-compact） 算法。这个更改将并行化 标记-清除-压缩（mark-sweep-compact） 算法，并使用相同数量的线程。当收集的并发线程不能足够快地恢复内存时，将会触发G1 Full GC。</p><p>线程的数量可以通过<code>-XX:ParallelGCThreads</code> 选项进行控制。</p><h2 id="可选内存设备上的堆分配（Heap-Allocation-on-Alternative-Memory-Devices）"><a href="#可选内存设备上的堆分配（Heap-Allocation-on-Alternative-Memory-Devices）" class="headerlink" title="可选内存设备上的堆分配（Heap Allocation on Alternative Memory Devices）"></a>可选内存设备上的堆分配（Heap Allocation on Alternative Memory Devices）</h2><p>此更改的目的是使<code>HotSpot VM</code>能够在用户指定的其他内存设备(如NV-DIMM)上分配Java对象堆。</p><p>要在这样的内存中分配堆，我们可以添加一个新选项:<code>-XX:AllocateHeapAt=\<path></path></code>。此选项将采用到文件系统的路径，并使用内存映射来实现在内存设备上分配对象堆的期望结果。现有的堆相关参数(如<code>-Xmx</code>、<code>-Xms</code>等)和垃圾收集相关参数将继续工作。</p><h2 id="JDK-分支整合（Consolidate-the-JDK-Forest-into-a-Single-Repository）"><a href="#JDK-分支整合（Consolidate-the-JDK-Forest-into-a-Single-Repository）" class="headerlink" title="JDK 分支整合（Consolidate the JDK Forest into a Single Repository）"></a>JDK 分支整合（Consolidate the JDK Forest into a Single Repository）</h2><p>为了简化和简化开发，JDK 分支的许多存储库被合并到一个单独的存储库中。</p><p>在JDK 9中有八个<code>repos</code>: <code>root</code>、<code>corba</code>、<code>hotspot</code>、<code>jaxp</code>、<code>jaxws</code>、<code>JDK</code>、<code>langtools</code>和<code>nashorn</code>。在合并后，Java模块的代码在一个顶级<code>src</code>目录下。</p><p>例如，之前JDK分支有一些基于模块的目录，比如：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ROOT/jdk/src/java.base</span><br><span class="line">...</span><br><span class="line">$ROOT/langtools/src/java.compiler</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>整合后，它们现在变为这样：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ROOT/src/java.base</span><br><span class="line">$ROOT/src/java.compiler</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="应用数据共享（Application-Class-Data-Sharing）"><a href="#应用数据共享（Application-Class-Data-Sharing）" class="headerlink" title="应用数据共享（Application Class-Data Sharing）"></a>应用数据共享（Application Class-Data Sharing）</h2><p>该特性的目标是改进启动占用空间，扩展现有的类数据共享(“CDS”)特性，允许将应用程序类放在共享归档中。</p><p>在JDK 5中引入的类数据共享允许将一组类预先处理为共享的存档文件，然后在运行时对这些文件进行内存映射，以减少启动时间。当多个jvm共享相同的归档文件时，它还可以减少动态内存占用。</p><p>目前CDS只允许引导类加载器加载存档的类。应用程序CDS允许内置的系统类装入器、内置的平台类装入器和自定义类装入器装入归档的类。</p><p>指定<code>-XX:+UseAppCDS</code>命令行选项，以便为系统类装入器、平台类装入器和其他用户定义的类装入器启用类数据共享。</p><h2 id="Unicode语言标记扩展（Additional-Unicode-Language-Tag-Extensions）"><a href="#Unicode语言标记扩展（Additional-Unicode-Language-Tag-Extensions）" class="headerlink" title="Unicode语言标记扩展（Additional Unicode Language-Tag Extensions）"></a>Unicode语言标记扩展（Additional Unicode Language-Tag Extensions）</h2><p>它的目标是增强<code>java.util.Locale</code>和相关api来实现<a href="https://www.rfc-editor.org/rfc/bcp/bcp47.txt" rel="external nofollow noopener noreferrer" target="_blank">BCP 47</a>语言标记的额外Unicode扩展。</p><p>对BCP 47语言标记的支持最初是在Java SE 7中添加的，对Unicode区域设置扩展的支持仅限于日历和数字。这个JEP将在相关的JDK类中实现最新<a href="https://www.unicode.org/reports/tr35/tr35.html#Locale_Extension_Key_and_Type_Data" rel="external nofollow noopener noreferrer" target="_blank">LDML规范</a>中指定的更多扩展。</p><p>这个JEP将增加对以下附加扩展的支持:</p><ul><li>cu (currency type)</li><li>fw (first day of week)</li><li>rg (region override)</li><li>tz (time zone)</li></ul><p>修改的相关API有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">java.text.DateFormat::get*Instance</span><br><span class="line">java.text.DateFormatSymbols::getInstance</span><br><span class="line">java.text.DecimalFormatSymbols::getInstance</span><br><span class="line">java.text.NumberFormat::get*Instance</span><br><span class="line">java.time.format.DateTimeFormatter::localizedBy</span><br><span class="line">java.time.format.DateTimeFormatterBuilder::getLocalizedDateTimePattern</span><br><span class="line">java.time.format.DecimalStyle::of</span><br><span class="line">java.time.temporal.WeekFields::of</span><br><span class="line">java.util.Calendar::&#123;getFirstDayOfWeek,getMinimalDaysInWeek&#125;</span><br><span class="line">java.util.Currency::getInstance</span><br><span class="line">java.util.Locale::getDisplayName</span><br><span class="line">java.util.spi.LocaleNameProvider</span><br></pre></td></tr></table></figure><h2 id="根证书（Root-Certificates）"><a href="#根证书（Root-Certificates）" class="headerlink" title="根证书（Root Certificates）"></a>根证书（Root Certificates）</h2><p>作为JDK的一部分，cacerts密钥存储库旨在包含一组根证书，这些根证书可用于在各种安全协议中使用的证书链中建立信任。但是，JDK源代码中的cacerts密钥库目前是空的。</p><p>cacerts密钥存储库将使用一组由Oracle的Java SE根CA程序签名颁发的根证书。许多供应商已经签署了所需的协议，并为每个供应商提供了将包含的根证书列表。那些没有签署协议的国家将不在此列。那些需要较长时间处理的将包含在下一个版本中。</p><p>这也意味着Oracle和Open JDK的二进制文件在功能上是相同的。关键的安全组件，比如TLS，将在OpenJDK构建中默认使用。</p><h2 id="基于Java的JIT编译器（Experimental-Java-Based-JIT-Compiler）"><a href="#基于Java的JIT编译器（Experimental-Java-Based-JIT-Compiler）" class="headerlink" title="基于Java的JIT编译器（Experimental Java-Based JIT Compiler）"></a>基于Java的JIT编译器（Experimental Java-Based JIT Compiler）</h2><p>该特性使基于Java的JIT编译器 <em>Graal</em> 能够作为Linux/x64平台上的实验性JIT编译器使用。Graal将使用JDK 9中引入的JVM编译器接口(JVMCI)。Graal已经在JDK中了，所以启用它作为实验性的JIT主要是测试和调试工作。</p><p>要启用Graal作为JIT编译器，请在Java命令行上使用以下选项:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler</span><br></pre></td></tr></table></figure><p>Graal是Java中对JIT编译器的完全重写。以前的JIT编译器是用c++编写的。</p><h2 id="线程本地”握手”（Thread-Local-Handshakes）"><a href="#线程本地”握手”（Thread-Local-Handshakes）" class="headerlink" title="线程本地”握手”（Thread-Local Handshakes）"></a>线程本地”握手”（Thread-Local Handshakes）</h2><p>这个JEP通过在不执行全局VM安全点的情况下在应用程序线程上执行回调，为改进VM性能奠定了基础。这意味着JVM可以停止单个线程，而不是全部。</p><p>线程本地握手将首先在x64和SPARC上实现。其他平台将退回到正常的安全点。新选项<code>-XX:ThreadLocalHandshakes</code>(默认值为true)允许用户在支持的平台上选择正常的安全点。</p><h2 id="移除头文件生成工具（Remove-the-Native-Header-Generation-Tool）"><a href="#移除头文件生成工具（Remove-the-Native-Header-Generation-Tool）" class="headerlink" title="移除头文件生成工具（Remove the Native-Header Generation Tool）"></a>移除头文件生成工具（Remove the Native-Header Generation Tool）</h2><p>它将从JDK中删除<code>javah</code>工具，这是一个在编译JNI代码时生成头文件的独立工具，因为这可以通过<code>javac</code>完成。</p><p>这是另一个Java 10特性，侧重于管理。</p><h2 id="新增的API和参数（New-Added-APIs-and-Options）"><a href="#新增的API和参数（New-Added-APIs-and-Options）" class="headerlink" title="新增的API和参数（New Added APIs and Options）"></a>新增的API和参数（New Added APIs and Options）</h2><p>Java 10里新增了73个API，我们来看下：</p><table><thead><tr><th>API</th><th>DESCRIPTION</th></tr></thead><tbody><tr><td>Optional.orElseThrow()</td><td>一个新的方法orElseThrow被添加到这个可选的类中。它是现有get方法的同义词，现在是首选的替代方法</td></tr><tr><td>List.copyOf, Set.copyOf, and Map.copyOf</td><td>这些方法从现有实例创建新的集合实例</td></tr><tr><td>Collectors.toUnmodifiableList, Collectors.toUnmodifiableSet, Collectors.toUnmodifiableMap</td><td>这些方法允许将流的元素收集到不可修改的集合中</td></tr><tr><td>–jdk.disableLastUsageTracking</td><td>禁用对正在运行的VM的JRE最后一次使用情况跟踪</td></tr><tr><td>–add-stylesheet</td><td>支持在生成的文档中使用多个样式表</td></tr><tr><td>–main-stylesheet</td><td>以帮助区分主样式表和其他样式表</td></tr><tr><td>@summary Tag</td><td>添加以显式指定用作API描述摘要的文本。默认情况下，API描述的摘要是从第一句话推断出来的</td></tr></tbody></table><h2 id="删除的API和参数（Removed-APIs-and-Options）"><a href="#删除的API和参数（Removed-APIs-and-Options）" class="headerlink" title="删除的API和参数（Removed APIs and Options）"></a>删除的API和参数（Removed APIs and Options）</h2><table><thead><tr><th>API</th><th>DESCRIPTION</th></tr></thead><tbody><tr><td>LookAndFeels</td><td></td></tr><tr><td>Runtime.getLocalizedInputStream, Runtime.getLocalizedOutputStream</td><td>过时的国际化机制的一部分，没有实际用途</td></tr><tr><td>RMI Server-Side Multiplex Protocol Support</td><td>JDK 9被禁用，现在已被删除</td></tr><tr><td>Common DOM APIs</td><td><code>com.sun.java.browser.plugin2.DOM</code>和<code>sun.plugin.dom.DOMObject</code>现已被删除，应用可以使用<code>netscape.javascript.JSObject</code>去操作DOM</td></tr><tr><td>FlatProfiler</td><td>JDK 9已弃用，目前已删除</td></tr><tr><td>-Xoss, -Xsqnopause, -Xoptimize, -Xboundthreads,-Xusealtsigs</td><td>这几项参数均被移除</td></tr><tr><td>policytool</td><td>policytool安全工具已从JDK中删除。</td></tr><tr><td>弃用<code>com.sun.security.auth.**</code></td><td>下面的class已被删除：com.sun.security.auth.PolicyFile, com.sun.security.auth.SolarisNumericGroupPrincipal,com.sun.security.auth.SolarisNumericUserPrincipal,com.sun.security.auth.SolarisPrincipal,com.sun.security.auth.X500Principal,com.sun.security.auth.module.SolarisLoginModule,com.sun.security.auth.module.SolarisSystem</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java 10" scheme="https://www.sakuratears.top/tags/Java-10/"/>
    
  </entry>
  
  <entry>
    <title>Java 10 局部变量类型推断</title>
    <link href="https://www.sakuratears.top/blog/Java-10-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD.html"/>
    <id>https://www.sakuratears.top/blog/Java-10-局部变量类型推断.html</id>
    <published>2020-04-21T08:31:00.000Z</published>
    <updated>2020-04-21T08:34:38.200Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java一直在逐步减少语法上的冗长。首先是Diamond操作符，现在是var(局部变量类型- <a href="https://openjdk.java.net/jeps/286" rel="external nofollow noopener noreferrer" target="_blank">JEP 286</a>)来在Java中声明变量。</p><p>当我们使用var来声明变量时，不是声明一个变量类型，而是假设它的类型来自它被设置的值。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var str = <span class="string">"Hello world"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"> </span><br><span class="line">String str = <span class="string">"Hello world"</span>;</span><br></pre></td></tr></table></figure><p>在上面的例子中，在第一个语句中，我们将一个字符串设置为变量str，因此它被隐式地假定为字符串类型。第一个语句本质上等价于上面例子中的第二个语句。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="需要同时声明和初始化var"><a href="#需要同时声明和初始化var" class="headerlink" title="需要同时声明和初始化var"></a>需要同时声明和初始化var</h2><p>使用var时，必须在相同的位置初始化变量。</p><p>不能将声明和初始化放在不同的位置。</p><p>如果我们没有在适当的地方初始化变量，那么将会得到编译错误 - <code>Cannot use ‘var’ on variable without initializer</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var i;  <span class="comment">//错误声明定义 - - Cannot use 'var' on variable without initializer</span></span><br><span class="line">         </span><br><span class="line">var j = <span class="number">10</span>; <span class="comment">//正确声明定义</span></span><br><span class="line"> </span><br><span class="line">System.out.println(i);</span><br></pre></td></tr></table></figure><h2 id="var不是关键字"><a href="#var不是关键字" class="headerlink" title="var不是关键字"></a>var不是关键字</h2><p>看起来像，但实际上var不是Java的关键字，所以我们可以命名叫var的变量，这是允许的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var var = <span class="number">10</span>;   <span class="comment">//正确</span></span><br><span class="line">         </span><br><span class="line"><span class="keyword">int</span> var = <span class="number">10</span>;   <span class="comment">//正确</span></span><br></pre></td></tr></table></figure><h2 id="var用法"><a href="#var用法" class="headerlink" title="var用法"></a>var用法</h2><p>var的使用是有限制的，它可以应用在局部变量与初始化参数、for循环等，它不适用于方法参数、构造函数参数、方法返回类型、字段、捕获参数或任何其他类型的变量声明。</p><p>允许使用范围：</p><ul><li>初始化的局部变量</li><li>增强for循环</li><li>普通for循环</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var blogName = <span class="string">"howtodoinjava.com"</span>;</span><br><span class="line">         </span><br><span class="line"><span class="keyword">for</span> ( var object : dataList)&#123;</span><br><span class="line">    System.out.println( object );</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> ( var i = <span class="number">0</span> ; i &lt; dataList.size(); i++ )&#123;</span><br><span class="line">    System.out.println( dataList.get(i) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不允许使用的范围：</p><ul><li>方法参数</li><li>构造函数参数</li><li>方法返回类型</li><li>类字段</li><li>异常捕获参数或者其他类型的变量声明</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//var firstName;    //不允许定义在类里</span></span><br><span class="line">         </span><br><span class="line">    <span class="comment">//public Application(var param)&#123;    //不允许作为构造函数参数</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*try&#123;</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">    &#125; catch(var ex)&#123;    //不允许作为异常捕获参数</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*public var demoMethod()&#123;  //不允许作为方法返回参数</span></span><br><span class="line"><span class="comment">        return null;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*public Integer demoMethod2( var input )&#123;  //不允许作为方法入参</span></span><br><span class="line"><span class="comment">        return null;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="var不是向后兼容的"><a href="#var不是向后兼容的" class="headerlink" title="var不是向后兼容的"></a>var不是向后兼容的</h2><p>由于这是一种新的语言特性，所以使用var编写的代码不会在较低的JDK版本(少于10)中编译。</p><p>所以，只有我们确定要使用它时，才建议使用。</p><h2 id="var不影响性能"><a href="#var不影响性能" class="headerlink" title="var不影响性能"></a>var不影响性能</h2><p>要知道，在Java中，类型不是在运行时推断的，而是在编译时推断的。这意味着生成的字节码与显式类型声明相同 - 它确实包含了关于类型的信息。这意味着在运行时没有进行额外的处理。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>以上就是关于var的全部内容。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java 10" scheme="https://www.sakuratears.top/tags/Java-10/"/>
    
  </entry>
  
  <entry>
    <title>Java 10 基于时间的发布版本</title>
    <link href="https://www.sakuratears.top/blog/Java-10-%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E7%9A%84%E5%8F%91%E5%B8%83%E7%89%88%E6%9C%AC.html"/>
    <id>https://www.sakuratears.top/blog/Java-10-基于时间的发布版本.html</id>
    <published>2020-04-21T08:29:00.000Z</published>
    <updated>2020-04-21T08:30:05.669Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从Java 10开始，Oracle已经适应了基于时间的版本字符串方案[JEP 322]。新的基于时间的模型已经取代了过去基于特性的多年发布模型。与旧版本不同的是，基于时间的新版本不会延迟发布，新功能将每六个月发布一次，对新版本中可以发布哪些功能没有限制。</p><p>更新版本将在每个季度(1月、4月、7月、10月)发布。更新版本将严格限制在新特性的安全问题、回归和bug的修复上。根据计划安排，我们可以说每个特性发布在下一次特性发布之前会收到两次更新。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Java版本格式化"><a href="#Java版本格式化" class="headerlink" title="Java版本格式化"></a>Java版本格式化</h2><p>如果我们在终端运行<code>java -version</code>命令，那么将会得到如下的版本信息输出：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\<span class="title">Lokesh</span>&gt;<span class="title">java</span> -<span class="title">version</span></span></span><br><span class="line"><span class="function"><span class="title">java</span> <span class="title">version</span> "10.0.1" 2018-04-17</span></span><br><span class="line"><span class="function"><span class="title">Java</span>(<span class="title">TM</span>) <span class="title">SE</span> <span class="title">Runtime</span> <span class="title">Environment</span> 18.3 (<span class="title">build</span> 10.0.1+10)</span></span><br><span class="line"><span class="function"><span class="title">Java</span> <span class="title">HotSpot</span>(<span class="title">TM</span>) 64-<span class="title">Bit</span> <span class="title">Server</span> <span class="title">VM</span> 18.3 (<span class="title">build</span> 10.0.1+10, <span class="title">mixed</span> <span class="title">mode</span>)</span></span><br></pre></td></tr></table></figure><p>新的版本号格式是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$FEATURE.$INTERIM.$UPDATE.$PATCH</span><br></pre></td></tr></table></figure><table><thead><tr><th>COUNTER NAME</th><th>DESCRIPTION</th></tr></thead><tbody><tr><td>$FEATURE</td><td>每6个月将增加，如下：JDK 10, JDK 11. (旧称 $MAJOR.)</td></tr><tr><td>$INTERIM</td><td>这个通常是0，在6个月期限内。对于包含兼容的bug修复和增强，但没有不兼容的更改、没有删除特性和对标准api没有更改的非特性发布，它将增加。(旧称：$MINOR)</td></tr><tr><td>$UPDATE</td><td>在处理兼容的更新版本，以修复新特性中的安全问题、倒退和bug时，它将会增加.(旧称：$SECURITY)</td></tr><tr><td>$PATCH</td><td>只有在需要生成紧急版本来修复关键问题时，才会增加它。</td></tr></tbody></table><blockquote><p>将一个版本号中的数字序列与另一个版本号中的数字序列进行逐点比较;例如，10.0.4小于10.1.2。如果一个序列短于另一个序列，则认为短序列缺少的元素小于长序列相应的元素;例如，10.0.2小于10.0.2.1。</p></blockquote><h2 id="Java-Version-API"><a href="#Java-Version-API" class="headerlink" title="Java Version API"></a>Java Version API</h2><p><code>Runtime.version()</code> 使我们可以通过代码去获取版本信息。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Version version = Runtime.version();</span><br><span class="line">version.feature();</span><br><span class="line">version.interim();</span><br><span class="line">version.update();</span><br><span class="line">version.patch();</span><br><span class="line"> </span><br><span class="line">Output:</span><br><span class="line"> </span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>版本的转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Version version = Runtime.Version.parse(<span class="string">"10.0.1"</span>);</span><br><span class="line"> </span><br><span class="line">version.feature();</span><br><span class="line">version.interim();</span><br><span class="line">version.update();</span><br><span class="line">version.patch();</span><br></pre></td></tr></table></figure><h2 id="长期版本支持-LTS"><a href="#长期版本支持-LTS" class="headerlink" title="长期版本支持 (LTS)"></a>长期版本支持 (LTS)</h2><p>主要面向企业客户。Oracle将为LTS版本的产品将提供卓越和持续的支持。此外，这些版本的更新将至少在三年内可用。</p><p>“LTS”在<code>java -version</code>的输出中会突出显示。例如: <code>11.0.2 + 13-LTS</code></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>以上就是关于Java 10 版本的全部内容。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java 10" scheme="https://www.sakuratears.top/tags/Java-10/"/>
    
  </entry>
  
  <entry>
    <title>[转] Java 9特性及增强</title>
    <link href="https://www.sakuratears.top/blog/%5B%E8%BD%AC%5DJava-9%E7%89%B9%E6%80%A7%E5%8F%8A%E5%A2%9E%E5%BC%BA.html"/>
    <id>https://www.sakuratears.top/blog/[转]Java-9特性及增强.html</id>
    <published>2020-04-13T02:54:00.000Z</published>
    <updated>2020-04-13T03:01:32.963Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://howtodoinjava.com/java9/java9-new-features-enhancements/" rel="external nofollow noopener noreferrer" target="_blank">原文链接</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java 9带来了很多新的增强，这些增强将在很大程度上影响我们的编程风格和习惯。最大的变化是Java的模块化。这是Java 8中的Lambdas之后的另一个重大变化。</p><p>本文中，我们将介绍JDK 9的新特性及增强。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="模块化（Java-platform-module-system）"><a href="#模块化（Java-platform-module-system）" class="headerlink" title="模块化（Java platform module system）"></a>模块化（Java platform module system）</h2><p>JPMS (Java平台模块系统)是新版Java 9的核心亮点。它也被称为<a href="https://openjdk.java.net/projects/jigsaw/" rel="external nofollow noopener noreferrer" target="_blank">“Jigshaw计划”</a>。模块是新的结构，就像我们已经有了包一样。使用新的模块化编程开发的应用程序可以看作是具有定义良好的边界和这些模块之间的依赖关系的交互模块的集合。</p><p>JPMS包括对编写模块化应用程序的支持，以及对JDK源代码的模块化。JDK 9附带了大约92个模块(在GA版本中可以进行更改)。Java 9模块系统有一个“Java”。它被称为基模块。它是一个独立的模块，不依赖于任何其他模块。默认情况下，所有其他模块都依赖于“java.base”。</p><p>java模块化编程要点：</p><ol><li>模块通常只是一个jar文件，在根目录下有一个module-info.class文件。</li><li>要使用模块，请将jar文件包含到modulepath中，而不是classpath中。添加到classpath中的模块jar文件是普通的jar文件，而module-info.class文件将被忽略。</li></ol><p>典型的module-info.java类是这样的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> helloworld &#123;</span><br><span class="line">    <span class="keyword">exports</span> com.howtodoinjava.demo;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">module</span> test &#123;</span><br><span class="line">    <span class="keyword">requires</span> helloworld;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于模块化的更多介绍可以查看 <a href="https://www.sakuratears.top/blog/Java-9%E6%A8%A1%E5%9D%97%E5%8C%96.html#more">Java 9模块化</a></p><h2 id="接口私有方法（Interface-Private-Methods）"><a href="#接口私有方法（Interface-Private-Methods）" class="headerlink" title="接口私有方法（Interface Private Methods）"></a>接口私有方法（Interface Private Methods）</h2><p>Java 8允许在接口中编写默认方法，这是一个广受好评的特性。因此，在这之后，接口中缺少的只有私有方法了。从Java 9开始，我们可以在接口中声明私有方法。</p><p>这些私有方法将提高接口内部的代码可重用性。例如，如果两个默认方法需要共享代码，一个私有接口方法将允许它们这样做，但是不会将这个私有方法暴露给它的实现类。</p><p>在接口中使用私有方法有四个规则:</p><ol><li>私有接口方法不能是抽象的。</li><li>私有方法只能在接口内部使用。</li><li>私有静态方法可以在其他静态和非静态接口方法中使用。</li><li>私有非静态方法不能在私有静态方法中使用。</li></ol><p>一个使用私有方法接口的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomCalculator</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">addEvenNumbers</span><span class="params">(<span class="keyword">int</span>... nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> add(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">addOddNumbers</span><span class="params">(<span class="keyword">int</span>... nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> add(n -&gt; n % <span class="number">2</span> != <span class="number">0</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(IntPredicate predicate, <span class="keyword">int</span>... nums)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> IntStream.of(nums)</span><br><span class="line">                .filter(predicate)</span><br><span class="line">                .sum();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于接口私有方法的更多内容可以查看 <a href="https://www.sakuratears.top/blog/Java-9%E6%8E%A5%E5%8F%A3%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95.html#more">Java 9接口私有方法</a></p><h2 id="HTTP-2-Client"><a href="#HTTP-2-Client" class="headerlink" title="HTTP/2 Client"></a>HTTP/2 Client</h2><p>HTTP/1.1客户端在1997年发布。从那以后发生了很大的变化。因此，Java 9引入了一个新的API，它使用起来更干净、更清晰，并且还增加了对HTTP/2的支持。</p><p>新的API使用了3个主要的类:<code>HttpClient</code>, <code>HttpRequest</code>和<code>HttpResponse</code>。</p><p>要发出请求，只需获取客户端、构建请求并发送请求，如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HttpClient httpClient = HttpClient.newHttpClient(); </span><br><span class="line">HttpRequest httpRequest = HttpRequest.newBuilder().uri(<span class="keyword">new</span> URI(<span class="string">"//howtodoinjava.com/"</span>)).GET().build(); </span><br><span class="line">HttpResponse&lt;String&gt; httpResponse = httpClient.send(httpRequest, HttpResponse.BodyHandler.asString()); </span><br><span class="line">System.out.println( httpResponse.body() );</span><br></pre></td></tr></table></figure><p>上面的代码看起来更清晰可读了。</p><p>新的API还支持使用<code>httpClient.sendAsync()</code>方法的异步HTTP请求。它返回<code>CompletableFuture</code>对象，该对象可用于确定请求是否已完成。它还提供了在请求完成后对<code>HttpResponse</code>的访问。最好的一点是，如果你想，你甚至可以在请求完成之前取消它。</p><p>我们来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(httpResponse.isDone()) &#123;</span><br><span class="line">    System.out.println(httpResponse.get().statusCode());</span><br><span class="line">    System.out.println(httpResponse.get().body());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    httpResponse.cancel(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JShell-工具（JShell-–-REPL-Tool）"><a href="#JShell-工具（JShell-–-REPL-Tool）" class="headerlink" title="JShell 工具（JShell – REPL Tool）"></a>JShell 工具（JShell – REPL Tool）</h2><p>JShell是JDK 9发行版附带的新的命令行交互工具[JEP 222]，用于评估用Java编写的声明、语句和表达式。JShell允许我们执行Java代码片段并立即获得结果，而不必创建解决方案或项目。</p><p>Jshell很像linux操作系统中的命令窗口。不同之处在于JShell是特定于Java的。除了执行简单的代码片段外，它还有许多其他功能。如：</p><ol><li>在单独的窗口中启动内建代码编辑器</li><li>在单独的窗口中启动您选择的代码编辑器</li><li>当保存操作在这些外部编辑器中发生时执行代码</li><li>从文件系统加载预先编写的类</li></ol><p>关于JShell的更多内容，请查看 <a href="https://www.sakuratears.top/blog/Java-9-JShell.html#more">Java 9 JShell</a>。</p><h2 id="平台和JVM日志（Platform-and-JVM-Logging）"><a href="#平台和JVM日志（Platform-and-JVM-Logging）" class="headerlink" title="平台和JVM日志（Platform and JVM Logging）"></a>平台和JVM日志（Platform and JVM Logging）</h2><p>JDK 9通过一个新的loging API改进了平台类(JDK类)和JVM组件的日志记录。它允许我们指定自己选择的日志记录框架(例如Log4J2)作为来自JDK类的日志记录消息的日志记录后端。</p><p>关于这个API，我们需要知道以下几点:</p><ol><li>API应该由JDK中的类使用，而不是由应用程序类使用。</li><li>对于我们的应用程序代码，我们将像以前一样继续使用其他日志api。</li><li>该API不允许我们以编程方式配置日志记录器。</li></ol><p>API包含以下内容:</p><ol><li>一个服务接口，<code>java.lang.System.LoggerFinder</code>，它是一个抽象的静态类</li><li>一个接口<code>java.lang.System.Logger</code>，它提供了日志API</li><li>一个重载方法<code>getLogger()</code>位于<code>java.lang.System</code>类，它返回一个logger实例。</li></ol><p>JDK 9还添加了一个新的命令行选项<code>-Xlog</code>，它为我们提供了一个访问所有JVM类中记录的所有消息的单点访问点。</p><p>下面是使用<code>-Xlog</code>选项的语法:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xlog [:][:[][:[][:]]]</span><br></pre></td></tr></table></figure><p>所有选项都是可选的。如果缺少<code>-Xlog</code>中的前一部分，则必须为该部分使用冒号。</p><p>例如，<code>-Xlog::stderr</code>表示所有部件都是默认的，其中输出设置为stderr。</p><p>关于JVM Logging的更多内容，我们后面讨论。</p><h2 id="进程API更新（Process-API-Updates）"><a href="#进程API更新（Process-API-Updates）" class="headerlink" title="进程API更新（Process API Updates）"></a>进程API更新（Process API Updates）</h2><p>在Java 5之前，生成新进程的惟一方法是使用Runtime.getRuntime().exec()方法。然后在Java 5中引入了ProcessBuilder API，它支持一种更干净的生成新进程的方式。现在Java 9增加了一种获取当前进程和任何衍生进程信息的新方法。</p><p>要获取任何进程的信息，现在应该使用<code>java.lang.ProcessHandle.Info</code>接口。这个接口在获取进程较多信息时很有用。如以下进程信息：</p><ol><li>用于启动进程的命令</li><li>命令的参数</li><li>启动过程的时间瞬间</li><li>它和创建它的用户所花费的总时间</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ProcessHandle processHandle = ProcessHandle.current();</span><br><span class="line">ProcessHandle.Info processInfo = processHandle.info();</span><br><span class="line"> </span><br><span class="line">System.out.println( processHandle.getPid() );</span><br><span class="line">System.out.println( processInfo.arguments().isPresent() );</span><br><span class="line">System.out.println( pprocessInfo.command().isPresent() );</span><br><span class="line">System.out.println( processInfo.command().get().contains(<span class="string">"java"</span>) );</span><br><span class="line">System.out.println( processInfo.startInstant().isPresent() );</span><br></pre></td></tr></table></figure><p>要获取新派生进程的信息，请使用<code>process.toHandle()</code>方法获取<code>ProcessHandle</code>实例。剩下的事情如上所述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String javaPrompt = ProcessUtils.getJavaCmd().getAbsolutePath();</span><br><span class="line">ProcessBuilder processBuilder = <span class="keyword">new</span> ProcessBuilder(javaPrompt, <span class="string">"-version"</span>);</span><br><span class="line">Process process = processBuilder.inheritIO().start();</span><br><span class="line">ProcessHandle processHandle = process.toHandle();</span><br></pre></td></tr></table></figure><p>还可以使用<code>ProcessHandle.allProcesses()</code>获取系统中所有可用进程的<code>ProcessHandle</code>流。</p><p>要获得所有子进程的列表(一级的和n级深度的)，可以使用<code>children()</code> 和 <code>descendants()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;ProcessHandle&gt; children    = ProcessHandle.current().children();</span><br><span class="line">Stream&lt;ProcessHandle&gt; descendants = ProcessHandle.current().descendants();</span><br></pre></td></tr></table></figure><h2 id="集合API更新（Collection-API-Updates）"><a href="#集合API更新（Collection-API-Updates）" class="headerlink" title="集合API更新（Collection API Updates）"></a>集合API更新（Collection API Updates）</h2><p>从Java 9开始，我们可以使用新的工厂方法创建不可变集合，如不可变list、不可变set和不可变map。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableCollections</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;String&gt; namesList = List.of(<span class="string">"Lokesh"</span>, <span class="string">"Amit"</span>, <span class="string">"John"</span>);</span><br><span class="line"> </span><br><span class="line">        Set&lt;String&gt; namesSet = Set.of(<span class="string">"Lokesh"</span>, <span class="string">"Amit"</span>, <span class="string">"John"</span>);</span><br><span class="line"> </span><br><span class="line">        Map&lt;String, String&gt; namesMap = Map.ofEntries(</span><br><span class="line">                                    Map.entry(<span class="string">"1"</span>, <span class="string">"Lokesh"</span>),</span><br><span class="line">                                    Map.entry(<span class="string">"2"</span>, <span class="string">"Amit"</span>),</span><br><span class="line">                                    Map.entry(<span class="string">"3"</span>, <span class="string">"Brian"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于更多的集合API更新内容请查看 <a href="https://www.sakuratears.top/blog/Java-9%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E5%8F%98%E6%9B%B4.html#more">Java 9集合相关更新</a></p><h2 id="Stream-API相关更新（Stream-API-Improvements）"><a href="#Stream-API相关更新（Stream-API-Improvements）" class="headerlink" title="Stream API相关更新（Stream API Improvements）"></a>Stream API相关更新（Stream API Improvements）</h2><p>Java 9引入了两种与流交互的新方法，即<code>takeWhile</code>/<code>dropWhile</code>方法。此外，它还添加了两个重载方法，即<code>ofNullable</code>和<code>iterate</code>方法。</p><p>新的方法<code>takeWhile</code>和<code>dropWhile</code>允许我们根据谓词获取流的一部分。</p><ol><li>在一个有序的流上，<code>takeWhile</code>返回从流中取出的与给定谓词匹配的元素的“最长前缀”，从流的开头开始。<code>dropWhile</code>返回未被<code>takeWhile</code>匹配的剩余项。</li><li>在一个无序流上，<code>takeWhile</code>从流的开头开始返回匹配给定谓词(但不是全部)的流元素的子集。<code>dropWhile</code>在删除匹配给定谓词的元素子集后返回剩余的流元素。</li></ol><p>类似地，在Java 8之前，流中不能有<code>null</code>值。它会导致<code>NullPointerException</code>。自Java 9以来，<code>Stream.ofnullable()</code>方法允许我们创建一个单元素流，它包装一个值(如果不是<code>null</code>)，或者是一个空流。从技术上讲，<code>Stream.ofnullable()</code>与在流API上下文中使用<code>null</code>条件检查非常相似。</p><p>关于Stream API更新更多内容，可以查看 <a href="https://www.sakuratears.top/blog/Java-9-Stream-API%E5%8F%98%E6%9B%B4.html#more">Java 9 Stream API更新</a></p><h2 id="多版本JAR引用增强（Multi-Release-JAR-Files）"><a href="#多版本JAR引用增强（Multi-Release-JAR-Files）" class="headerlink" title="多版本JAR引用增强（Multi-Release JAR Files）"></a>多版本JAR引用增强（Multi-Release JAR Files）</h2><p>这个增强与我们如何在jar文件中打包应用程序类有关。在此之前，我们必须将所有类打包到一个jar文件中，并放入另一个希望使用它的应用程序的类路径中。</p><p>使用多版本特性，现在jar可以包含一个类的不同版本——兼容于不同的JDK版本。类的不同版本的信息，以及在哪个JDK版本中哪个类应该被类加载，都存储在<code>MANIFEST.MF</code>文件中。在本例中，<code>MANIFEST.MF</code>文件主要部分包含了条目<code>Multi-Release: true</code>。</p><p>而且，<code>META-INF</code>包含一个版本子目录，它的整数命名的子目录(从9开始(对于Java 9))存储特定于版本的类和资源文件。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">JAR content root</span><br><span class="line">  A.class</span><br><span class="line">  B.class</span><br><span class="line">  C.class</span><br><span class="line">  D.class</span><br><span class="line">  META-INF</span><br><span class="line">     MANIFEST.MF</span><br><span class="line">     versions</span><br><span class="line">        <span class="number">9</span></span><br><span class="line">           A.class</span><br><span class="line">           B.class</span><br></pre></td></tr></table></figure><p>让我们假设在JDK 10中，A.class被更新以利用一些Java 10特性，然后这个Jar文件可以这样更新:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">JAR content root</span><br><span class="line">  A.class</span><br><span class="line">  B.class</span><br><span class="line">  C.class</span><br><span class="line">  D.class</span><br><span class="line">  META-INF</span><br><span class="line">     MANIFEST.MF</span><br><span class="line">     versions</span><br><span class="line">        <span class="number">9</span></span><br><span class="line">           A.class</span><br><span class="line">           B.class</span><br><span class="line">        <span class="number">10</span></span><br><span class="line">           A.class</span><br></pre></td></tr></table></figure><p>这看起来是一个很有用的增强，它解决了在大型应用程序中经常出现的依赖问题，在这些应用程序中，具有不同版本的jar彼此不兼容。这个特性对解决这些场景有很大的帮助。</p><h2 id="Deprecated标签（-Deprecated-Tag-Changes）"><a href="#Deprecated标签（-Deprecated-Tag-Changes）" class="headerlink" title="@Deprecated标签（@Deprecated Tag Changes）"></a>@Deprecated标签（@Deprecated Tag Changes）</h2><p>从Java 9开始，<code>@Deprecated</code>注释将有两个属性，即<code>forRemoval</code>和<code>since</code>。</p><ol><li><code>forRemoval</code>：指示所注释的元素在将来的版本中是否要被删除。</li><li><code>since</code>：它返回注释元素被弃用的版本。</li></ol><p>强烈建议在文档中使用<code>@deprecated</code> javadoc标记解释弃用该API的原因。文档还应该建议并链接到推荐的替换API(如果适用的话)。替换API通常有一些与原API不同的地方，因此也应该作出说明。</p><h2 id="堆栈相关（Stack-Walking）"><a href="#堆栈相关（Stack-Walking）" class="headerlink" title="堆栈相关（Stack Walking）"></a>堆栈相关（Stack Walking）</h2><p>堆栈是后进先出(LIFO)数据结构。在JVM级别，堆栈存储帧。每次调用一个方法时，都会创建一个新帧并将其推到堆栈的顶部。当方法调用完成时，帧将被销毁(从堆栈中弹出)。堆栈上的每个帧都包含自己的局部变量数组，以及自己的操作数堆栈、返回值和对当前方法类的运行时常量池的引用。</p><p>在给定的线程中，在任何点上都只有一个帧是活动的。活动帧称为当前帧，其方法称为当前方法。(<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.2" rel="external nofollow noopener noreferrer" target="_blank">了解更多</a>)</p><p>在Java 8之前，<code>StackTraceElement</code>表示一个堆栈帧。要获得完整的堆栈，必须使用<code>Thread.getStackTrace()</code>和<code>Throwable.getStackTrace()</code>。它返回一个<code>StackTraceElement</code>数组，我们可以迭代该数组以获得所需的信息。</p><p>在Java 9中，引入了一个新的类<code>StackWalker</code>。该类使用当前线程的连续堆栈帧流提供了简单而有效的堆栈遍历。<code>StackWalker</code>类非常高效，因为它对堆栈帧的计算是延迟的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印当前线程的所有堆栈帧的详细信息</span></span><br><span class="line">StackWalker.getInstance () .forEach (system . out:: println);</span><br></pre></td></tr></table></figure><p>我们还可以用这个流做很多其他的事情，我们将在其他的文章中讨论。</p><h2 id="Java-Docs-相关更新（Java-Docs-Updates）"><a href="#Java-Docs-相关更新（Java-Docs-Updates）" class="headerlink" title="Java Docs 相关更新（Java Docs Updates）"></a>Java Docs 相关更新（Java Docs Updates）</h2><p>Java 9增强了<code>javadoc</code>工具来生成HTML5标记。它当前在HTML 4.01中生成页面。</p><p>为了生成HTML5 Javadoc，需要在命令行参数中加入参数<code>-html5</code>。要在命令行生成文档，可以运行以下命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javadoc [options] [packagenames] [sourcefile] [@files]</span><br></pre></td></tr></table></figure></p><p>使用HTML5带来了更简单的HTML5结构的好处。它还实现了<a href="https://www.w3.org/WAI/standards-guidelines/aria/" rel="external nofollow noopener noreferrer" target="_blank">WAI-ARIA standard </a>可访问性标准。这样做的目的是让有生理或视觉缺陷的人更容易使用屏幕阅读器之类的工具访问<code>javadocs</code>页面。</p><p><a href="https://openjdk.java.net/jeps/225" rel="external nofollow noopener noreferrer" target="_blank">JEP 225</a>允许在<code>javadoc</code>中搜索程序元素和带标记的单词和短语。</p><p>以下将被索引和搜索:</p><ul><li>模块的声明名称(Declared names of modules)</li><li>包(Packages)</li><li>类型和成员(Types and members)</li><li>方法参数类型的简单名称(The simple name of method parameter types)</li></ul><p>这是在客户端实现的，带有一个新的<code>search.js</code> Javascript文件，以及在生成<code>javadoc</code>时生成的索引。在生成的HTML5 API页面上有一个搜索框可用。</p><p>请注意，搜索选项将默认添加，但可以关闭参数:<code>-noindex</code>。</p><h2 id="其它特性及增强（Miscellaneous-Other-Features）"><a href="#其它特性及增强（Miscellaneous-Other-Features）" class="headerlink" title="其它特性及增强（Miscellaneous Other Features）"></a>其它特性及增强（Miscellaneous Other Features）</h2><p>在Java 9中还有其他特性，我把它们列在下面以供快速参考。我们将在以后的文章中讨论所有这些特性。</p><ul><li>Reactive Streams API</li><li>GC改进（GC (Garbage Collector) Improvements）</li><li>Filter Incoming Serialization Data</li><li>弃用Applet（Deprecate the Applet API）</li><li>Indify String Concatenation</li><li>Enhanced Method Handles</li><li>Compact Strings</li><li>Nashorn解析器（Parser API for Nashorn）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java 9" scheme="https://www.sakuratears.top/tags/Java-9/"/>
    
  </entry>
  
  <entry>
    <title>Java 9 JShell</title>
    <link href="https://www.sakuratears.top/blog/Java-9-JShell.html"/>
    <id>https://www.sakuratears.top/blog/Java-9-JShell.html</id>
    <published>2020-04-13T02:15:00.000Z</published>
    <updated>2020-04-13T02:32:26.143Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>JShell是JDK 9发行版[JEP 222]附带的新命令行交互式REPL (Read-Evaluate-Print-Loop)控制台，用于计算用Java编写的声明、语句和表达式。JShell允许我们执行Java代码片段并立即获得结果，而不必创建解决方案或项目。</p><p>在本文中，我们将通过示例学习在JShell中可以完成的各种任务。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="运行JShell"><a href="#运行JShell" class="headerlink" title="运行JShell"></a>运行JShell</h2><p>首先要做的是将JDK 9安装到您的计算机中。从这个链接下载<a href="https://jdk.java.net/9/" rel="external nofollow noopener noreferrer" target="_blank">JDK 9</a>并安装它。</p><p>进入安装位置，查看/jdk-9/bin文件夹。我们将在这里找到jshell.exe文件。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-615.png" alt="upload successful"></p><p>现在启动一个新的命令窗口并检查java版本。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; java -version</span><br></pre></td></tr></table></figure><p>它应该指向JDK 9版本。如果不是，则使用相应的值更新环境属性<code>JAVA_HOME</code>和<code>PATH</code>。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME=C:\Program Files\Java\jdk-<span class="number">9</span></span><br><span class="line"><span class="built_in">PATH</span>=C:\Program Files\Java\jdk-<span class="number">9</span>\bin    //<span class="built_in">Path</span> till bin folder</span><br></pre></td></tr></table></figure><p>现在再次启动新的命令提示窗口并输入命令jshell。它将把游标更改为jshell。如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-616.png" alt="upload successful"></p><p>接下来我们来看下如何在JShell REPL中运行了Java相关代码。</p><h2 id="在REPL里编写和运行一段Java代码"><a href="#在REPL里编写和运行一段Java代码" class="headerlink" title="在REPL里编写和运行一段Java代码"></a>在REPL里编写和运行一段Java代码</h2><p>Jshell允许创建小的代码片段并对它们进行测试，而不需要创建和构建复杂的项目。这就是它的用法。</p><p>在JShell上运行代码片段非常容易，我们来看一下。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>我们可以像在实际编程中那样定义变量。唯一不同的是，我们不必一开始就编写一个类或方法。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; int i = <span class="number">10</span>;</span><br><span class="line">i ==&gt; <span class="number">10</span></span><br></pre></td></tr></table></figure><p>要输出变量的值，只需输入变量名并回车。它将输出变量的值。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; i</span><br><span class="line">i ==&gt; <span class="number">10</span></span><br></pre></td></tr></table></figure><p>要将变量重新赋值给新值，只需按常规方式执行即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; i=<span class="number">20</span>;</span><br><span class="line">i ==&gt; <span class="number">20</span></span><br></pre></td></tr></table></figure><p>要列出所有定义的变量，使用 <code>/vars</code> 命令。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; /vars</span><br><span class="line">|    int i = <span class="number">20</span></span><br><span class="line">|    int j = <span class="number">30</span></span><br></pre></td></tr></table></figure><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-617.png" alt="upload successful"></p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>和变量一样，方法也很简单。</p><p>要在JShell中创建方法，需要定义retrun类型、方法名称、参数和方法体定义方法。不需要访问修饰符。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; int sum (int a, int b) &#123;</span><br><span class="line">   ...&gt; return a+b;</span><br><span class="line">   ...&gt; &#125;</span><br><span class="line">|  created method sum(int,int)</span><br></pre></td></tr></table></figure><p>列出所有定义的方法，使用<code>/methods</code> 命令。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; /methods</span><br><span class="line">|    int sum(int,int)</span><br></pre></td></tr></table></figure><p>要使用方法，像普通编程那样调用即可。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; sum(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">$<span class="number">6</span> ==&gt; <span class="number">4</span></span><br></pre></td></tr></table></figure><p>如果我们想查看方法源码，使用<code>/list</code>命令即可，它将展示指定方法的源码。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; /list sum</span><br><span class="line"> </span><br><span class="line"><span class="number">1</span> : int sum (int a, int b) &#123;</span><br><span class="line">   return a+b;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如果想更改方法代码，需要用相同的方法名重写新修改的代码。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; int sum (int a, int b) &#123;</span><br><span class="line">   ...&gt; int c = a+b;</span><br><span class="line">   ...&gt; return c;</span><br><span class="line">   ...&gt; &#125;</span><br><span class="line">|  modified method sum(int,int)</span><br><span class="line"> </span><br><span class="line">jshell&gt; /list sum</span><br><span class="line"> </span><br><span class="line">   <span class="number">3</span> : int sum (int a, int b) &#123;</span><br><span class="line">       int c = a+b;</span><br><span class="line">       return c;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-618.png" alt="upload successful"></p><blockquote><p>请牢记方法重载规则。如果更改了方法参数数量或它们的数据类型，那么它将是一个新方法，并且将有两个方法在JShell中注册。</p></blockquote><h2 id="在JShell编辑器上编写代码"><a href="#在JShell编辑器上编写代码" class="headerlink" title="在JShell编辑器上编写代码"></a>在JShell编辑器上编写代码</h2><p>当只有几行代码时，JShell内联编辑器已经足够好了。但是当代码量开始变大时，我们可能需要一个文件编辑器来修改代码。</p><p>这里我们可以使用JShell编辑器。要启动编辑器，使用 <code>/edit</code>命令 + 要编辑的方法名。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-619.png" alt="upload successful"></p><p>在这里，根据需要更改方法代码并单击Accept按钮。修改后的代码将在Jshell中更新，我们将在提示中收到确认消息。我们可以随时更改代码，保存它，然后退出窗口。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-620.png" alt="upload successful"></p><h2 id="在外部编辑器中编辑代码"><a href="#在外部编辑器中编辑代码" class="headerlink" title="在外部编辑器中编辑代码"></a>在外部编辑器中编辑代码</h2><p>自带的编辑器可以满足大多数需要，但如果你喜欢在任何特定的编辑器上编码，你也可以使用它。</p><p>JShell允许轻松地配置任何外部编辑器来编辑代码片段。只需要获得我们想要使用的编辑器的完整路径，并在JShell中运行<code>/set editor</code>命令来配置编辑器。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/<span class="built_in">set</span> editor "C:\\Program Files\\Sublime Text <span class="number">3</span>\\sublime_text.exe"</span><br></pre></td></tr></table></figure><p>再次执行<code>/edit</code>命令。它将在sublime编辑器中打开代码。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-621.png" alt="upload successful"></p><p>自由编辑代码，并保存。</p><h2 id="将外部Java文件加载到REPL"><a href="#将外部Java文件加载到REPL" class="headerlink" title="将外部Java文件加载到REPL"></a>将外部Java文件加载到REPL</h2><p>很多时候，我们可能已经在任何java文件中编写了一些代码，希望将其执行到JShell中。</p><p>要在JShell中加载文件，使用<code>/open</code>命令。</p><p>假设我在<code>c://temp</code>文件夹中有一个<code>Demo.java</code>文件。它的内容是:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> i2 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> i3 = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">int</span> i4 = <span class="number">40</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在让我们把它加载到JShell。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/open c:\\temp\\demo.java</span><br></pre></td></tr></table></figure><p>可以看到代码被加载到了JShell。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-622.png" alt="upload successful"></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>以上就是在使用Java 9中JShell我们需要了解的内容。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java 9" scheme="https://www.sakuratears.top/tags/Java-9/"/>
    
  </entry>
  
  <entry>
    <title>Java 9 Stream API变更</title>
    <link href="https://www.sakuratears.top/blog/Java-9-Stream-API%E5%8F%98%E6%9B%B4.html"/>
    <id>https://www.sakuratears.top/blog/Java-9-Stream-API变更.html</id>
    <published>2020-04-13T02:12:00.000Z</published>
    <updated>2020-04-13T02:13:11.734Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java 9 Stream API新增了 <code>takeWhile</code> / <code>dropWhile</code>, <code>ofNullable</code> ,<code>iterate</code> 等方法。</p><p>我们通过例子来了解下它们。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="使用takeWhile-和dropWhile-方法对流进行限制"><a href="#使用takeWhile-和dropWhile-方法对流进行限制" class="headerlink" title="使用takeWhile()和dropWhile()方法对流进行限制"></a>使用takeWhile()和dropWhile()方法对流进行限制</h2><p>新的方法<code>takeWhile</code>和<code>dropWhile</code>允许我们根据谓词获取流的一部分。</p><p>这里的流可以是有序的，也可以是无序的，所以:</p><ol><li>在一个有序的流上，<code>takeWhile</code>返回从流中取出的与给定谓词匹配的元素的“最长前缀”，从流的开头开始。</li><li>在一个无序流上，<code>takeWhile</code>从流的开头开始返回匹配给定谓词(但不是全部)的流元素的子集。</li></ol><p><code>dropWhile</code>方法与<code>takeWhile</code>方法相反。</p><ol><li>在一个有序的流中，<code>dropWhile</code>返回与给定谓词匹配的“最长前缀”之后的剩余项。</li><li>在一个无序的流上，<code>dropWhile</code>在删除匹配给定谓词的元素子集后返回剩余的流元素。</li></ol><h2 id="takeWhile和dropWhile的例子"><a href="#takeWhile和dropWhile的例子" class="headerlink" title="takeWhile和dropWhile的例子"></a>takeWhile和dropWhile的例子</h2><p>在本例中，我们有一个从’a’到’i’的字符List。我想要在迭代中获取出现在’d’之前的所有字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; alphabets = List.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>, <span class="string">"g"</span>, <span class="string">"h"</span>, <span class="string">"i"</span>);</span><br><span class="line"> </span><br><span class="line">List&lt;String&gt; subset1 = alphabets</span><br><span class="line">        .stream()</span><br><span class="line">        .takeWhile(s -&gt; !s.equals(<span class="string">"d"</span>))</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line"> </span><br><span class="line">System.out.println(subset1);</span><br><span class="line"> </span><br><span class="line">Output:</span><br><span class="line"> </span><br><span class="line">[a, b, c]</span><br></pre></td></tr></table></figure><p>如前所述，<code>dropWhile</code>的作用与<code>takeWhile</code>方法相反，因此在上面的例子中，如果使用<code>dropWhile</code>方法，它将返回<code>takeWhile</code>谓词所留下的所有字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; alphabets = List.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>, <span class="string">"g"</span>, <span class="string">"h"</span>, <span class="string">"i"</span>);</span><br><span class="line"> </span><br><span class="line">List&lt;String&gt; subset2 = alphabets</span><br><span class="line">        .stream()</span><br><span class="line">        .dropWhile(s -&gt; !s.equals(<span class="string">"d"</span>))</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line"> </span><br><span class="line">System.out.println(subset2);</span><br><span class="line"> </span><br><span class="line">Output:</span><br><span class="line"> </span><br><span class="line">[d, e, f, g, h, i]</span><br></pre></td></tr></table></figure><h2 id="重载流的iterate方法"><a href="#重载流的iterate方法" class="headerlink" title="重载流的iterate方法"></a>重载流的iterate方法</h2><p><code>iterate()</code>方法，用于创建以单个元素(the seed)开始的流，并通过连续应用一元运算符生成后续元素，结果是一个无限的流。</p><p>要终止流，需要使用限制或其他一些短路函数，如<code>findFirst</code>或<code>findAny</code>。</p><p>Java 8中的<code>iterate</code>方法有这样的签名:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Stream <span class="title">iterate</span><span class="params">(<span class="keyword">final</span> T seed, <span class="keyword">final</span> UnaryOperator f)</span></span></span><br></pre></td></tr></table></figure><p>在Java 9中，新的重载版本的iterate将一个谓词作为第二个参数:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Stream <span class="title">iterate</span><span class="params">(T seed, Predicate hasNext, UnaryOperator next)</span></span></span><br></pre></td></tr></table></figure><p>让我们看看Java 8和Java 9之间<code>iterate</code>方法使用的不同之处。</p><p><em>iterate method in Java 8</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Stream.iterate(<span class="number">1</span>, i -&gt; i+<span class="number">1</span>)</span><br><span class="line">                            .limit(<span class="number">10</span>)</span><br><span class="line">                            .collect(Collectors.toList());</span><br><span class="line">         </span><br><span class="line">System.out.println(numbers);</span><br><span class="line"> </span><br><span class="line">Output:</span><br><span class="line"> </span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><p><em>iterate method in Java 9</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Stream.iterate(<span class="number">1</span>, i -&gt; i &lt;= <span class="number">10</span> ,i -&gt; i+<span class="number">1</span>)</span><br><span class="line">                                .collect(Collectors.toList());</span><br><span class="line"> </span><br><span class="line">System.out.println(numbers);</span><br><span class="line"> </span><br><span class="line">Output:</span><br><span class="line"> </span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><p>在上面的例子中，第一个流是使用带有限制的<code>iterate</code>的Java 8方式。第二个使用谓词作为第二个参数。</p><h2 id="新方法ofNullable"><a href="#新方法ofNullable" class="headerlink" title="新方法ofNullable()"></a>新方法ofNullable()</h2><p>在Java 8之前，流中不能有<code>null</code>值。它会导致<code>NullPointerException</code>。</p><p>在Java 9中，<code>ofNullable</code>方法允许我们创建一个单元素流，该流包装一个值(如果不是null)，或者是一个空流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.ofNullable(<span class="string">"123"</span>);</span><br><span class="line">System.out.println(stream.count());</span><br><span class="line"> </span><br><span class="line">stream = Stream.ofNullable(<span class="keyword">null</span>);</span><br><span class="line">System.out.println(stream.count());</span><br><span class="line"> </span><br><span class="line">Output:</span><br><span class="line"> </span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>这里，<code>count</code>方法返回流中非空元素的数量。</p><p>从技术上讲，<code>Stream.ofnullable()</code>与在流API上下文中使用<code>null</code>条件检查非常相似。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java 9" scheme="https://www.sakuratears.top/tags/Java-9/"/>
    
  </entry>
  
  <entry>
    <title>Java 9集合相关变更</title>
    <link href="https://www.sakuratears.top/blog/Java-9%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E5%8F%98%E6%9B%B4.html"/>
    <id>https://www.sakuratears.top/blog/Java-9集合相关变更.html</id>
    <published>2020-04-13T02:10:00.000Z</published>
    <updated>2020-04-13T02:11:30.393Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java 9 对于不可变集合可以使用工厂模式进行创建，我们来看一下，如何来创建不可变List、不可变Map、不可变Set。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="创建不可变List（Immutable-List）"><a href="#创建不可变List（Immutable-List）" class="headerlink" title="创建不可变List（Immutable List）"></a>创建不可变List（Immutable List）</h2><p>使用<code>List.of()</code>静态工厂方法创建不可变列表。它有以下不同的重载版本:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;E&gt; <span class="function">List&lt;E&gt;  <span class="title">of</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt;  <span class="title">of</span><span class="params">(E e1)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt;  <span class="title">of</span><span class="params">(E e1, E e2)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt;  <span class="title">of</span><span class="params">(E e1, E e2, E e3)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt;  <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt;  <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt;  <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5, E e6)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt;  <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5, E e6, E e7)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt;  <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt;  <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt;  <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10)</span></span></span><br><span class="line"><span class="function"><span class="comment">//varargs</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; List&lt;E&gt;  <span class="title">of</span><span class="params">(E... elements)</span></span></span><br></pre></td></tr></table></figure><p>这些方法创建的<code>List</code>实例具有以下特征:</p><ol><li>这些<code>List</code>是不可变的。在这些<code>List</code>中不能添加、删除或替换元素。调用任何<code>mutator</code>方法(即<code>add</code>、<code>addAll</code>、<code>clear</code>、<code>remove</code>、<code>removeAll</code>、<code>replaceAll</code>)总是会引发<code>UnsupportedOperationException</code>。</li><li>它们不允许空元素。尝试添加空元素会导致<code>NullPointerException</code>。</li><li>如果所有元素都是可序列化的，则它们是可序列化的。</li><li>列表中元素的顺序与提供的参数或提供的数组中的元素的顺序相同。</li></ol><p>让我们来看几个使用不可变列表的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.howtodoinjava;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableCollections</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;String&gt; names = List.of(<span class="string">"Lokesh"</span>, <span class="string">"Amit"</span>, <span class="string">"John"</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//Preserve the elements order</span></span><br><span class="line">        System.out.println(names);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//names.add("Brian"); //UnsupportedOperationException occured</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//java.lang.NullPointerException</span></span><br><span class="line">        <span class="comment">//List&lt;String&gt; names2 = List.of("Lokesh", "Amit", "John", null); </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Output:</span><br><span class="line"> </span><br><span class="line">[Lokesh, Amit, John]</span><br></pre></td></tr></table></figure><h2 id="创建不可变Set（Immutable-Set）"><a href="#创建不可变Set（Immutable-Set）" class="headerlink" title="创建不可变Set（Immutable Set）"></a>创建不可变Set（Immutable Set）</h2><p><code>Set</code>的行为与<code>List</code>非常相似，只有很少的区别。如：</p><ol><li>设置不允许重复的元素。传递的任何重复元素都会导致<code>IllegalArgumentException</code>。</li><li>集合元素的迭代顺序是未指定的，可能会发生变化。</li></ol><p>所有的<code>Set</code>工厂方法都具有与<code>List</code>相同的签名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;E&gt; <span class="function">Set&lt;E&gt;   <span class="title">of</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt;   <span class="title">of</span><span class="params">(E e1)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt;   <span class="title">of</span><span class="params">(E e1, E e2)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt;   <span class="title">of</span><span class="params">(E e1, E e2, E e3)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt;   <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt;   <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt;   <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5, E e6)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt;   <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5, E e6, E e7)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt;   <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt;   <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt;   <span class="title">of</span><span class="params">(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10)</span></span></span><br><span class="line"><span class="function"><span class="comment">//varargs</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt;   <span class="title">of</span><span class="params">(E... elements)</span></span></span><br></pre></td></tr></table></figure><p>我们来看几个不可变<code>Set</code>的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableCollections</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; names = Set.of(<span class="string">"Lokesh"</span>, <span class="string">"Amit"</span>, <span class="string">"John"</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//Elements order not fixed</span></span><br><span class="line">        System.out.println(names);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//names.add("Brian"); //UnsupportedOperationException occured</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//java.lang.NullPointerException</span></span><br><span class="line">        <span class="comment">//Set&lt;String&gt; names2 = Set.of("Lokesh", "Amit", "John", null); </span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//java.lang.IllegalArgumentException</span></span><br><span class="line">        <span class="comment">//Set&lt;String&gt; names3 = Set.of("Lokesh", "Amit", "John", "Amit"); </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建不可变Map（Immutable-Map）"><a href="#创建不可变Map（Immutable-Map）" class="headerlink" title="创建不可变Map（Immutable Map）"></a>创建不可变Map（Immutable Map）</h2><p><code>Map</code>工厂方法与<code>List</code>或<code>Set</code>重载工厂方法相同。唯一的区别是方法的签名采用交替的键和值作为参数。如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">Map&lt;K,V&gt;   <span class="title">of</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;K,V&gt; Map&lt;K,V&gt;   <span class="title">of</span><span class="params">(K k1, V v1)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;K,V&gt; Map&lt;K,V&gt;   <span class="title">of</span><span class="params">(K k1, V v1, K k2, V v2)</span></span></span><br><span class="line"><span class="function">...</span></span><br><span class="line"><span class="function">...</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;K,V&gt; Map&lt;K,V&gt;   <span class="title">ofEntries</span><span class="params">(Map.Entry&lt;? extends K,? extends V&gt;... entries)</span></span></span><br></pre></td></tr></table></figure><p>Java 9 还提供了一个特殊的方法来创建<code>Map</code>实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; Map.Entry&lt;K,V&gt; entry​(K k, V v)</span><br></pre></td></tr></table></figure><p>我们来看几个Java 9 创建不可变<code>Map</code>的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableCollections</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; names = Map.ofEntries(</span><br><span class="line">                Map.entry(<span class="string">"1"</span>, <span class="string">"Lokesh"</span>),</span><br><span class="line">                Map.entry(<span class="string">"2"</span>, <span class="string">"Amit"</span>),</span><br><span class="line">                Map.entry(<span class="string">"3"</span>, <span class="string">"Brian"</span>));</span><br><span class="line">         </span><br><span class="line">        System.out.println(names);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//UnsupportedOperationException</span></span><br><span class="line">        <span class="comment">//names.put("2", "Ravi");</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Output:</span><br><span class="line"> </span><br><span class="line">&#123;<span class="number">1</span>=Lokesh, <span class="number">2</span>=Amit, <span class="number">3</span>=Brian&#125;</span><br></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>可以看到在Java 9中创建不可变集合的新工厂方法非常易读且易于使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java 9" scheme="https://www.sakuratears.top/tags/Java-9/"/>
    
  </entry>
  
  <entry>
    <title>Java 9接口私有方法</title>
    <link href="https://www.sakuratears.top/blog/Java-9%E6%8E%A5%E5%8F%A3%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95.html"/>
    <id>https://www.sakuratears.top/blog/Java-9接口私有方法.html</id>
    <published>2020-04-13T02:08:00.000Z</published>
    <updated>2020-04-13T02:10:08.591Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从Java 9开始，我们可以在接口中包含私有方法。使用私有方法，现在在接口中也可以进行封装。</p><p>在本文中，我们将详细了解接口私有方法。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Java-7之前的接口"><a href="#Java-7之前的接口" class="headerlink" title="Java 7之前的接口"></a>Java 7之前的接口</h2><p>在Java 7和所有早期版本中，接口非常简单。它们只能包含公共抽象方法（public abstract method）。这些接口方法必须由选择实现接口的类来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClass</span> <span class="keyword">implements</span> <span class="title">CustomInterface</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        CustomInterface instance = <span class="keyword">new</span> CustomClass();</span><br><span class="line">        instance.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Output:</span><br><span class="line"> </span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure><h2 id="Java-8的接口"><a href="#Java-8的接口" class="headerlink" title="Java 8的接口"></a>Java 8的接口</h2><p>从Java 8开始，除了公共抽象方法之外，接口还可以拥有公共静态方法（public static method）和默认方法（public default method）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomInterface</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"default method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"static method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClass</span> <span class="keyword">implements</span> <span class="title">CustomInterface</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"abstract method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        CustomInterface instance = <span class="keyword">new</span> CustomClass();</span><br><span class="line">        instance.method1();</span><br><span class="line">        instance.method2();</span><br><span class="line">        CustomInterface.method3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Output:</span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> method</span><br><span class="line"><span class="keyword">default</span> method</span><br><span class="line"><span class="keyword">static</span> method</span><br></pre></td></tr></table></figure><blockquote><p>在以上接口方法声明中，访问修饰符“public”是可选的。添加它们只是为了提高可读性。</p></blockquote><h2 id="Java-9的接口"><a href="#Java-9的接口" class="headerlink" title="Java 9的接口"></a>Java 9的接口</h2><p>从Java 9开始，我们将能够在接口中添加私有方法（private methods）和私有静态方法（private static method）。</p><p>这些私有方法将提高接口内部的代码可重用性。</p><p>例如，如果两个默认方法需要共享代码，那么提供一个私有接口方法即可，但是不会将这个私有方法暴露给它的实现类。</p><p>在接口中使用私有方法有四个规则:</p><ol><li>私有接口方法不能是抽象的。</li><li>私有方法只能在接口内部使用。</li><li>私有静态方法可以在其他静态和非静态接口方法中使用。</li><li>私有非静态方法不能在私有静态方法中使用。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomInterface</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method4();  <span class="comment">//private method inside default method</span></span><br><span class="line">        method5();  <span class="comment">//static method inside other non-static method</span></span><br><span class="line">        System.out.println(<span class="string">"default method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method5(); <span class="comment">//static method inside other static method</span></span><br><span class="line">        System.out.println(<span class="string">"static method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"private method"</span>);</span><br><span class="line">    &#125; </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"private static method"</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClass</span> <span class="keyword">implements</span> <span class="title">CustomInterface</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"abstract method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        CustomInterface instance = <span class="keyword">new</span> CustomClass();</span><br><span class="line">        instance.method1();</span><br><span class="line">        instance.method2();</span><br><span class="line">        CustomInterface.method3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Output:</span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> method</span><br><span class="line"><span class="keyword">private</span> method</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> method</span><br><span class="line"><span class="keyword">default</span> method</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> method</span><br><span class="line"><span class="keyword">static</span> method</span><br></pre></td></tr></table></figure><h2 id="Java-9私有方法例子"><a href="#Java-9私有方法例子" class="headerlink" title="Java 9私有方法例子"></a>Java 9私有方法例子</h2><p>让我们看一个示例来理解私有接口方法的用法。</p><p>我们创建一个具有两个函数的计算器类。第一个函数将接受一些整数并在其中添加所有偶数。第二个函数将接受一些整数并在其中添加所有奇数。</p><p><em>CustomCalculator.java – Interface</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.IntPredicate;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomCalculator</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">addEvenNumbers</span><span class="params">(<span class="keyword">int</span>... nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> add(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">addOddNumbers</span><span class="params">(<span class="keyword">int</span>... nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> add(n -&gt; n % <span class="number">2</span> != <span class="number">0</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(IntPredicate predicate, <span class="keyword">int</span>... nums)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> IntStream.of(nums)</span><br><span class="line">                .filter(predicate)</span><br><span class="line">                .sum();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>Main.java – Class</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">implements</span> <span class="title">CustomCalculator</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CustomCalculator demo = <span class="keyword">new</span> Main();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">int</span> sumOfEvens = demo.addEvenNumbers(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>);</span><br><span class="line">        System.out.println(sumOfEvens);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">int</span> sumOfOdds = demo.addOddNumbers(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>);</span><br><span class="line">        System.out.println(sumOfOdds);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Output:</span><br><span class="line"> </span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>简而言之，Java 9私有接口方法可以是静态的，也可以是实例的。在这两种情况下，私有方法都不会被子接口或实现继承。它们主要用于提高接口中的代码可重用性，从而提高封装性。</p><p>让我们回顾一下Java 9中允许的所有方法类型。</p><table><thead><tr><th>METHOD TYPE</th><th style="text-align:center">SINCE WHEN</th></tr></thead><tbody><tr><td>public abstract</td><td style="text-align:center">Java 7</td></tr><tr><td>public default</td><td style="text-align:center">Java 8</td></tr><tr><td>public static</td><td style="text-align:center">Java 8</td></tr><tr><td>private</td><td style="text-align:center">Java 9</td></tr><tr><td>private static</td><td style="text-align:center">Java 9</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java 9" scheme="https://www.sakuratears.top/tags/Java-9/"/>
    
  </entry>
  
  <entry>
    <title>Java 9模块化</title>
    <link href="https://www.sakuratears.top/blog/Java-9%E6%A8%A1%E5%9D%97%E5%8C%96.html"/>
    <id>https://www.sakuratears.top/blog/Java-9模块化.html</id>
    <published>2020-04-13T01:58:00.000Z</published>
    <updated>2020-04-13T02:06:34.271Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>JPMS（Java Platform Module System） Java平台模块系统是Java 9的主要增强。它也被称为Jigsaw项目。在本文中，我们将简单学习模块，以及在将来开始编写模块化代码时，编程风格将如何变化。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="什么是模块？"><a href="#什么是模块？" class="headerlink" title="什么是模块？"></a>什么是模块？</h2><p>在任何编程语言中，模块(类似于包)都是包含代码的构件，其中包含描述模块及其与其他模块的关系的元数据。理想情况下，这些构件从编译时一直到运行时都是可识别的。任何应用程序通常都是多个模块的组合，这些模块一起工作以执行业务目标。</p><p>在应用程序架构方面，模块应该表示特定的业务功能。对于该功能，它应该是自给自足的，并且应该只公开使用模块功能的接口。为了完成它的任务，它可能依赖于其他模块，它应该显式地声明这些模块。</p><p>因此，简而言之，一个模块应该遵循三个核心原则：</p><ul><li><p>强大的封装（Strong Encapsulation）</p><p>  封装意味着隐藏实现细节，这些细节对于正确使用模块并不重要。其目的是封装的代码可以自由改变而不影响模块的用户。</p></li><li><p>稳定的抽象（Stable Abstraction）</p><p>  抽象有助于使用接口(即公共api)公开模块功能。任何时候，如果想要更改模块代码中的业务逻辑或实现，更改对模块用户都是透明的。</p></li><li><p>显式的依赖关系（Explicit dependencies）</p><p>  模块也可以依赖于其他模块。这些外部依赖必须是模块定义本身的一部分。模块之间的这些依赖关系通常用图表示。一旦您看到应用程序级别的图，您将更好地理解应用程序的体系结构。</p></li></ul><h2 id="Java-9模块化介绍"><a href="#Java-9模块化介绍" class="headerlink" title="Java 9模块化介绍"></a>Java 9模块化介绍</h2><p>在Java 9之前，我们有“包（packages）”来根据业务功能对相关类进行分组。除了包之外，还有“访问修饰符”来控制哪些是可见的，哪些是隐藏在其他类或包中的。到目前为止，它运行得很好。Java对封装和抽象提供了强大的支持。</p><p>但是，显式依赖关系是事情开始崩溃的地方。在java中，依赖项是用“import”语句声明的;但是它们是严格的“编译时”构造。一旦代码被编译，就没有明确的机制来声明它的运行时依赖关系。事实上，java运行时依赖项解析是一个非常有问题的领域，因此专门创建了一些工具来解决这个问题，例如gradle或maven。此外，很少有框架捆绑它们的完整运行时依赖项，例如Spring boot项目。</p><p>有了新的Java 9模块，我们将能够更好地编写结构良好的应用程序。这种增强分为两个方面:</p><ol><li>模块化JDK本身。</li><li>提供一个模块系统供其他应用程序使用。</li></ol><blockquote><p>Java 9模块系统有一个“java.base”模块。它被称为基模块。它是一个独立的模块，不依赖于任何其他模块。默认情况下，所有其他模块都依赖于“java.base”。</p></blockquote><p>在Java 9中，模块帮助我们封装包并管理依赖项。所以通常情况下,</p><ul><li>类是字段和方法的容器</li><li>包是类和接口的容器</li><li>模块是包的容器</li></ul><p>如果我们不知道要查找的具体内容，那么我们不会感觉到普通代码和模块化代码之间的任何主要区别。如：</p><ul><li>模块通常只是一个jar文件，在根目录下有一个<code>module-info.class</code>文件。</li><li>要使用模块，请将jar文件包含到<code>modulepath</code>中，而不是<code>classpath</code>中。添加到<code>classpath</code>中的模块jar文件是普通的jar文件，而<code>module-info.class</code>文件将被忽略。</li></ul><h2 id="如何编写模块化代码"><a href="#如何编写模块化代码" class="headerlink" title="如何编写模块化代码"></a>如何编写模块化代码</h2><p>在阅读了所有上述概念之后，让我们看看模块化代码是如何在现实中编写的。我使用Netbeans IDE是因为它对Java 9有很好的早期支持(到今天为止)。</p><h3 id="创建Java模块项目"><a href="#创建Java模块项目" class="headerlink" title="创建Java模块项目"></a>创建Java模块项目</h3><p>创建一个Java模块项目，命名为<code>JavaAppOne</code>。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-610.jpg" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-611.jpg" alt="upload successful"></p><h3 id="创建Java模块"><a href="#创建Java模块" class="headerlink" title="创建Java模块"></a>创建Java模块</h3><p>我们向这个项目中添加两个模块，如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-612.jpg" alt="upload successful"></p><p>我向项目中添加了<code>helloworld</code>和<code>test</code> 模块，它们的结构如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-613.jpg" alt="upload successful"></p><p>相关代码如下：</p><p><code>/helloworld/module-info.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> helloworld &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HelloWorldApp.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.howtodoinjava.demo;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello from HelloWorldApp"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>/test/module-info.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> test &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TestApp.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//some code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到目前为止，模块是独立的。现在假设，我们想在TestApp类中使用<code>HelloWorldApp.sayHello()</code>方法。如果我们尝试在不导入模块的情况下使用该类，我们将得到编译时错误“package com.howtodoinjava.demo is not visible”。</p><h3 id="导入模块信息"><a href="#导入模块信息" class="headerlink" title="导入模块信息"></a>导入模块信息</h3><p>为了能够导入<code>HelloWorldApp</code>，我们必须首先从<code>helloworld</code>模块导出“com.howtodoinjava.demo”包，然后在<code>test</code>模块中包含<code>helloworld</code>模块。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> helloworld &#123;</span><br><span class="line">    <span class="keyword">exports</span> com.howtodoinjava.demo;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">module</span> test &#123;</span><br><span class="line">    <span class="keyword">requires</span> helloworld;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，<code>require</code>关键字表示依赖项，<code>exports</code>关键字标识可以导出到其他模块的包。只有当一个包被显式导出时，才能从其他模块访问它。模块内未导出的包在默认情况下无法从其他模块访问。</p><p>现在我们可以在<code>TestApp</code>类中使用<code>HelloWorldApp</code>类了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.howtodoinjava.demo.HelloWorldApp;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloWorldApp.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Output:</span><br><span class="line"> </span><br><span class="line">Hello from HelloWorldApp</span><br></pre></td></tr></table></figure><p>模块关系图如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-614.jpg" alt="upload successful"></p><blockquote><p>从Java 9开始，<code>public</code>意味着只对该模块内的所有其他包公开。只有在导出包含公共类型的包时，其他模块才能使用它。</p></blockquote><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>模块化应用程序有许多优点，当我们遇到具有非模块化代码库的应用程序时，我们会更加欣赏这些优点。模块化并不是什么灵丹妙药，但它是一种体系结构原则，如果应用得当，可以在很大程度上避免项目依赖混乱问题。</p><p>有了JPMS, Java向成为模块化语言迈出了一大步。这个决定是对是错，只有时间能证明。第三方库和框架如何适应和使用模块系统将会很有趣。以及它将如何影响开发工作，由我们来见证。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java 9" scheme="https://www.sakuratears.top/tags/Java-9/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV的使用（二） - 人脸的识别与训练</title>
    <link href="https://www.sakuratears.top/blog/OpenCV%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89-%E4%BA%BA%E8%84%B8%E7%9A%84%E8%AF%86%E5%88%AB%E4%B8%8E%E8%AE%AD%E7%BB%83.html"/>
    <id>https://www.sakuratears.top/blog/OpenCV的使用（二）-人脸的识别与训练.html</id>
    <published>2020-01-05T09:38:00.000Z</published>
    <updated>2020-01-05T09:42:54.924Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上篇文章我们讲到了OpenCV的安装和简单使用，<a href="https://www.sakuratears.top/blog/OpenCV%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89.html#more">OpenCV简介及使用（一）</a>。</p><p>这篇文章我们来看下如何使用OpenCV进行图像的识别与训练。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>由于OpenCV自带人脸识别及检测功能，我们来看下如何使用OpenCV来分辨人脸。</p><p>如果要进行人脸识别及训练，需要用到人脸灰度图，且有一定的数量，图片宽高需要保持一致。</p><p>上篇文章已经说到如何寻找并裁剪人脸，然后我们将它置灰即可，需要调用<code>org.bytedeco.opencv.global.opencv_imgproc.cvtColor</code>方法，如代码所示<code>cvtColor(image,image,COLOR_BGR2GRAY)</code>。</p><p>其中第一个image是原Mat图，第二个image是生成的Mat图，两个设置成一样则生成的灰度图会覆盖原图，<code>COLOR_BGR2GRAY</code>表示生成的图片颜色。</p><p>则生成灰度图代码大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Mat <span class="title">detectFace</span><span class="params">(String sourceImage, String targetImage,<span class="keyword">int</span> width,<span class="keyword">int</span> height)</span></span>&#123;</span><br><span class="line">    CascadeClassifier faceDetector = <span class="keyword">new</span> CascadeClassifier(CASCADE_FACE_FILENAME);</span><br><span class="line">    <span class="keyword">if</span>(faceDetector.empty())&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"处理文件时发生异常！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Mat image = imread(sourceImage);</span><br><span class="line">    RectVector rectVector = <span class="keyword">new</span> RectVector();</span><br><span class="line">    <span class="comment">// 进行人脸检测</span></span><br><span class="line">    faceDetector.detectMultiScale(image, rectVector);</span><br><span class="line"></span><br><span class="line">    Rect[] rects = rectVector.get();</span><br><span class="line">    <span class="keyword">if</span>(rects.length &lt;=<span class="number">0</span> )&#123;</span><br><span class="line">        log.error(<span class="string">"原图片上未检测到人脸：&#123;&#125;"</span>,sourceImage);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"原图片上未检测到人脸！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(rects.length &gt;<span class="number">1</span>)&#123;</span><br><span class="line">        log.error(<span class="string">"原图片上检测到多个人脸：&#123;&#125;"</span>,sourceImage);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"原图片上检测到多个人脸！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Rect rect = rects[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//人脸裁剪</span></span><br><span class="line">    image = <span class="keyword">new</span> Mat(image,rect);</span><br><span class="line">    <span class="comment">//将图片置灰</span></span><br><span class="line">    cvtColor(image,image,COLOR_BGR2GRAY);</span><br><span class="line">    <span class="comment">//调整图片大小(如果传入宽高为0，就取rect图片宽高)</span></span><br><span class="line">    <span class="keyword">if</span>(width==<span class="number">0</span>||height==<span class="number">0</span>)&#123;</span><br><span class="line">        width = rect.width();</span><br><span class="line">        height = rect.height();</span><br><span class="line">    &#125;</span><br><span class="line">    resize(image,image,<span class="keyword">new</span> Size(width,height));</span><br><span class="line">    <span class="comment">//图片落地（灰色图也可以不落地）</span></span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isNotBlank(targetImage))&#123;</span><br><span class="line">        imwrite(targetImage, image);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返会Mat图</span></span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法里主要使用了OpenCV中<code>org.bytedeco.opencv.global.opencv_imgcodecs</code>和<code>org.bytedeco.opencv.global.opencv_imgproc</code>两个包中的方法。</p><p>然后我们开始进行人脸识别训练。</p><p>人脸识别器（FaceRecognizer）这个类目前包含三种人脸识别方法：基于PCA变换的人脸识别(EigenFaceRecognizer)、基于Fisher变换的人脸识别(FisherFaceRecognizer)、基于局部二值模式的人脸识别(LBPHFaceRecognizer)。</p><p>这儿我们以基于PCA变换的人脸识别(EigenFaceRecognizer)来进行举例。</p><p>我们想识别两张不同的人脸，需要首先准备若干样本，这儿我准备了胡歌和刘亦菲的照片各10张来作为训练样本（想要更好的训练效果，训练图片至少要在数百张左右），如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-606.jpg" alt="upload successful"></p><p>其中胡歌的图片以0-开头，刘亦菲的图片以1-开头，对测试图片进行测试时，识别器的label（识别标签）返回0认为属于胡歌的照片，1认为属于刘亦菲的图片，-1认为不属于他们的照片。</p><p>训练时需要使用灰度图，我们使用上面的方法处理下生成宽高相等的灰度图。</p><p>其相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">faceRecognize</span><span class="params">(String baseImagePath,String testImage)</span></span>&#123;</span><br><span class="line">    <span class="comment">//存放样本的地址</span></span><br><span class="line">    File dirFile = <span class="keyword">new</span> File(baseImagePath);</span><br><span class="line">    <span class="keyword">if</span>(!dirFile.isDirectory())&#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"请指定样本文件目录！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//过滤指定图片文件</span></span><br><span class="line">    FilenameFilter imgFilter = (dir,name)-&gt;&#123;</span><br><span class="line">        name = name.toLowerCase();</span><br><span class="line">        <span class="keyword">return</span> name.endsWith(<span class="string">".jpg"</span>) || name.endsWith(<span class="string">".pgm"</span>) || name.endsWith(<span class="string">".png"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    File[] files = dirFile.listFiles(imgFilter);</span><br><span class="line">    <span class="keyword">if</span>(files == <span class="keyword">null</span> || files.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"目录下没有符合要求的图片文件！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//生成的训练样本（灰色图）临时文件存放在train目录下</span></span><br><span class="line">    String trainFileBasePath = baseImagePath + <span class="string">"/train"</span>;</span><br><span class="line">    File trainFileBase = <span class="keyword">new</span> File(trainFileBasePath);</span><br><span class="line">    <span class="keyword">if</span>(!trainFileBase.exists())&#123;</span><br><span class="line">        trainFileBase.mkdir();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始训练逻辑</span></span><br><span class="line">    <span class="comment">//样本灰色图Mat</span></span><br><span class="line">    MatVector matVector = <span class="keyword">new</span> MatVector(files.length);</span><br><span class="line">    <span class="comment">//样本标签</span></span><br><span class="line">    Mat labels = <span class="keyword">new</span> Mat(files.length, <span class="number">1</span>, CV_32SC1);</span><br><span class="line">    IntBuffer intBuffer = labels.createBuffer();</span><br><span class="line">    <span class="keyword">int</span> baseWidth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> baseHeight = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; files.length; i++) &#123;</span><br><span class="line">        <span class="comment">//灰色图地址</span></span><br><span class="line">        String tempImage = trainFileBasePath+<span class="string">"/"</span>+files[i].getName();</span><br><span class="line">        Mat mat = detectFace(files[i].getPath(),tempImage,baseWidth,baseHeight);</span><br><span class="line">        baseWidth = mat.rows();</span><br><span class="line">        baseHeight= mat.cols();</span><br><span class="line">        matVector.put(i,mat);</span><br><span class="line">        <span class="keyword">int</span> label = Integer.parseInt(files[i].getName().split(<span class="string">"-"</span>)[<span class="number">0</span>]);</span><br><span class="line">        intBuffer.put(i,label);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//人脸识别训练（训练要求训练图片和测试图片必须为灰度图，且大小一致）</span></span><br><span class="line">    <span class="comment">// num_components 主成分分析中保留的成分数(即特征面) 0为全部保留</span></span><br><span class="line">    <span class="comment">// threshold 置信度阈值，待识别图片如果大于这个阈值的话label就会返回-1</span></span><br><span class="line">    <span class="comment">// 可以不设置，会返回最低的置信度图片对于的label</span></span><br><span class="line">    FaceRecognizer faceRecognizer = EigenFaceRecognizer.create();</span><br><span class="line">    faceRecognizer.train(matVector,labels);</span><br><span class="line">    <span class="comment">//保存训练xml</span></span><br><span class="line">    faceRecognizer.save(baseImagePath+<span class="string">"/face.xml"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理待识别的图片</span></span><br><span class="line">    String testTempImage = baseImagePath + <span class="string">"/test"</span>;</span><br><span class="line">    File file = <span class="keyword">new</span> File(testTempImage);</span><br><span class="line">    <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">        file.mkdir();</span><br><span class="line">    &#125;</span><br><span class="line">    Mat tempMat = detectFace(testImage,testTempImage+<span class="string">"/temp.jpg"</span>,baseWidth,baseHeight);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//识别后结果标签，如果没有识别到，会返回-1</span></span><br><span class="line">    IntPointer label = <span class="keyword">new</span> IntPointer(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//识别置信度，越低越好，图片完全一样为0.0</span></span><br><span class="line">    DoublePointer confidence = <span class="keyword">new</span> DoublePointer(<span class="number">1</span>);</span><br><span class="line">    faceRecognizer.predict(tempMat, label, confidence);</span><br><span class="line">    <span class="keyword">int</span> predictedLabel = label.get();</span><br><span class="line">    System.out.println(<span class="string">"Predicted label: "</span> + predictedLabel);</span><br><span class="line">    System.out.println(confidence.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其关键部分代码为<code>faceRecognizer.train(matVector,labels)</code>，matVector接受生成的灰度图，labels为图片所属的标签，我们可以通过<code>faceRecognizer.save(baseImagePath+”/face.xml”)</code>保存训练后的xml。</p><p>在训练之前，通过灰度图处理（detectFace方法），如果训练图片选择落地的话，会在文件夹下生成train文件夹，里面就是存放宽高相等的待训练的样本。如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-607.jpg" alt="upload successful"></p><p>我们取一张测试照片test.jpg，来进行测试，如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-608.jpg" alt="upload successful"></p><p>其测试的主要代码就是上面代码的这部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理待识别的图片</span></span><br><span class="line">String testTempImage = baseImagePath + <span class="string">"/test"</span>;</span><br><span class="line">File file = <span class="keyword">new</span> File(testTempImage);</span><br><span class="line"><span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">    file.mkdir();</span><br><span class="line">&#125;</span><br><span class="line">Mat tempMat = detectFace(testImage,testTempImage+<span class="string">"/temp.jpg"</span>,baseWidth,baseHeight);</span><br><span class="line"></span><br><span class="line"><span class="comment">//识别后结果标签，如果没有识别到，会返回-1</span></span><br><span class="line">IntPointer label = <span class="keyword">new</span> IntPointer(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//识别置信度，越低越好，图片完全一样为0.0</span></span><br><span class="line">DoublePointer confidence = <span class="keyword">new</span> DoublePointer(<span class="number">1</span>);</span><br><span class="line">faceRecognizer.predict(tempMat, label, confidence);</span><br><span class="line"><span class="keyword">int</span> predictedLabel = label.get();</span><br><span class="line">System.out.println(<span class="string">"Predicted label: "</span> + predictedLabel);</span><br><span class="line">System.out.println(confidence.get());</span><br></pre></td></tr></table></figure><p>识别时也是需要使用灰度图进行识别，调用<code>faceRecognizer.predict(tempMat, label, confidence)</code>来对测试图片进行测试，同时也会返回置信度。</p><p>我们构建Main运行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//人脸识别训练</span></span><br><span class="line">    faceRecognize(<span class="string">"C:\\Users\\DELL-3020\\Desktop\\face\\base"</span>,<span class="string">"C:\\Users\\DELL-3020\\Desktop\\face\\test.jpg"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后可以看到输出结果：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-609.jpg" alt="upload successful"></p><p>可以看到符合我们的预期。</p><p>这儿只使用了少量训练样本来展示图像训练的方法，其实在进行识别训练时，样本越大精确度越高。</p><p>我们之前用到的<code>haarcascade_frontalface_alt.xml</code>，就是使用大量人脸样本进行训练生成的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>今天我们使用了OpenCV自带的人脸识别器（FaceRecognizer）来进行了人脸的识别与训练，后续我们会在了解下OpenCV在图像应用方面的一些其它功能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="OpenCV" scheme="https://www.sakuratears.top/tags/OpenCV/"/>
    
      <category term="人脸识别" scheme="https://www.sakuratears.top/tags/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
</feed>
