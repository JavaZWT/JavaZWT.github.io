<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SakuraTears的博客</title>
  
  <subtitle>越努力越幸运</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.sakuratears.top/"/>
  <updated>2021-01-10T09:17:44.183Z</updated>
  <id>https://www.sakuratears.top/</id>
  
  <author>
    <name>SakuraTears</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring Cloud Hystrix工作原理</title>
    <link href="https://www.sakuratears.top/blog/Spring-Cloud-Hystrix%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.html"/>
    <id>https://www.sakuratears.top/blog/Spring-Cloud-Hystrix工作原理.html</id>
    <published>2021-01-10T07:14:00.000Z</published>
    <updated>2021-01-10T09:17:44.183Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上一篇<a href="https://www.sakuratears.top/blog/Spring-Cloud-Hystrix%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99%E4%BF%9D%E6%8A%A4%E5%85%A5%E9%97%A8.html">Spring Cloud Hystrix服务容错保护入门</a>文章里，我们简单的了解了下 <strong>Spring Cloud Hystrix</strong>，并对 <strong>Hystrix</strong> 源码中使用到的两种模式进行了简单介绍，以方便我们更好的的了解 <strong>Hystrix</strong> 的原理。</p><p>这篇文章，我们将结合源码等来了解下 <strong>Hystrix</strong> 的工作原理。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>在 <strong>Netflix Hystrix</strong> 官网上<a href="https://github.com/Netflix/Hystrix/wiki/How-it-Works" rel="external nofollow noopener noreferrer" target="_blank">How-it-Works</a>，说明了 当一个请求调用了相关依赖后<strong>Hystrix</strong>是如何工作的。</p><p>我们通过官方的流程图来说明下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-674.png" alt="upload successful"></p><p>我们来根据图示序号来看下<strong>Hystrix</strong>的工作流程。</p><ol><li>创建<code>HystrixCommand</code>或<code>HystrixObservableCommand</code>对象</li></ol><p>首先，构建一个<code>HystrixCommand</code>或<code>HystrixObservableCommand</code>对象，用来表示对依赖服务的操作请求，同时传递所有需要的参数。</p><p>上篇文章我们已经讲到它们采用了“命令模式”来实现对服务调用操作的封装。</p><ul><li>HystrixCommand：用在依赖的服务返回单个操作结果的时候。</li><li>HystrixObservableCommand：用在依赖的服务返回多个操作结果的时候。</li></ul><ol start="2"><li>命令执行</li></ol><p>图中的4种命令执行方式我们也有简单介绍。</p><p><code>HystrixCommand</code>的两种执行方式：</p><ul><li>execute()：同步执行，从依赖的服务返回一个单一的结果对象，或是在发生错误的时候抛出异常。</li><li>queue()：异步执行，直接返回一个<code>Future</code>对象，其中包含了服务执行结束时要返回的单一结果对象。</li></ul><p><code>HystrixObservableCommand</code>的两种执行方式：</p><ul><li>observe()：返回<code>Observable</code>对象，它代表了操作的多个结果，是一个 <strong>Hot Observable</strong>。</li><li>toObservable()：同样返回<code>Observable</code>对象，也代表了操作的多个结果，但它是一个<strong>Cold Observable</strong>。</li></ul><p>这儿的<strong>观察者-订阅者模式</strong>还有<strong>Hot Observable</strong>和<strong>Cold Observable</strong>我们在上篇文章已经介绍，这儿就不过多叙述。</p><p>看表面的话，大家一定认为只有<code>HystrixObservableCommand</code>使用了<strong>RxJava</strong> ，实际上<code>HystrixCommand</code>的两种命令也使用<strong>RxJava</strong>来实现。</p><p>我们来看下两个命令的部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue().get();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> Exceptions.sneakyThrow(decomposeException(e));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;R&gt; <span class="title">queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Future&lt;R&gt; delegate = toObservable().toBlocking().toFuture();</span><br><span class="line">    <span class="keyword">final</span> Future&lt;R&gt; f = <span class="keyword">new</span> Future&lt;R&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (delegate.isCancelled()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (HystrixCommand.<span class="keyword">this</span>.getProperties().executionIsolationThreadInterruptOnFutureCancel().get()) &#123;</span><br><span class="line">                interruptOnFutureCancel.compareAndSet(<span class="keyword">false</span>, mayInterruptIfRunning);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> res = delegate.cancel(interruptOnFutureCancel.get());</span><br><span class="line">            <span class="keyword">if</span> (!isExecutionComplete() &amp;&amp; interruptOnFutureCancel.get()) &#123;</span><br><span class="line">                <span class="keyword">final</span> Thread t = executionThread.get();</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; !t.equals(Thread.currentThread())) &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> delegate.isCancelled();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> delegate.isDone();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> R <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> delegate.get();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> R <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> delegate.get(timeout, unit);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//处理立即抛出的错误</span></span><br><span class="line">    <span class="keyword">if</span> (f.isDone()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            f.get();</span><br><span class="line">            <span class="keyword">return</span> f;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Throwable t = decomposeException(e);</span><br><span class="line">            <span class="keyword">if</span> (t <span class="keyword">instanceof</span> HystrixBadRequestException) &#123;</span><br><span class="line">                <span class="keyword">return</span> f;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t <span class="keyword">instanceof</span> HystrixRuntimeException) &#123;</span><br><span class="line">                HystrixRuntimeException hre = (HystrixRuntimeException) t;</span><br><span class="line">                <span class="keyword">switch</span> (hre.getFailureType()) &#123;</span><br><span class="line">                <span class="keyword">case</span> COMMAND_EXCEPTION:</span><br><span class="line">                <span class="keyword">case</span> TIMEOUT:</span><br><span class="line">                    <span class="keyword">return</span> f;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> hre;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> Exceptions.sneakyThrow(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>execute()</code>是通过<code>queue()</code>返回的异步对象<code>Future&lt;R&gt;</code>的<code>get()</code>方法来实现同步执行的。</li><li><code>queue()</code>则是通过<code>toObservable()</code>来获得一个<strong>Cold Observable</strong>，然后通过<code>toBlocking()</code>转化为<code>BlockingObservable</code>，它可以把数据以阻塞的方式发射出来。<code>toFuture()</code>则把<code>BlockingObservable</code>转换为一个<code>Future</code>，该方法只是创建一个<code>Future</code>返回，并不会阻塞，这使得消费者可以自行决定如何处理异步操作。</li></ul><ol start="3"><li>结果是否被缓存</li></ol><p>若当前命令的请求缓存功能是被启用的，并且该命令缓存命中，那么缓存的结果会立即以<code>Observable</code>对象的形式返回。</p><ol start="4"><li>断路器是否打开</li></ol><p>在命令结果没有缓存命中的时候，<strong>Hystrix</strong>在执行命令前需要检查断路器是否为打开状态：</p><ul><li>如果断路器是打开的，那么<strong>Hystrix</strong>不会执行命令，而是转接到<code>fallback</code>处理逻辑（对应第8步）。</li><li>如果断路器是关闭的，那么<strong>Hystrix</strong>跳到第5步，检查是否有可用资源来执行命令。</li></ul><p>关于断路器的内容我们后面在详述。</p><ol start="5"><li>线程池/请求队列/信号量是否占满</li></ol><p>如果与命令相关的线程池和请求队列，或者信号量（不使用线程池的时候）已经被占满，那么<strong>Hystrix</strong>也不会执行命令，而是转接到<code>fallback</code>处理逻辑（对应第8步）。</p><p>需要注意的是，这里<strong>Hystrix</strong>所判断的线程池并非容器的线程池，而是每个依赖服务的专有线程池。<strong>Hystrix</strong>为了保证不会因为某个依赖服务的问题影响到其他依赖服务而采用了“舱壁模式（Bulkhead Pattern）”来隔离每个依赖的服务。</p><p>关于该方面的内容我们后面介绍。</p><ol start="6"><li><code>HystrixObservableCommand.construct()</code>或<code>HystrixCommand.run()</code></li></ol><p><code>Hystrix</code>会根据我们编写的方法来决定采取什么样的方式去请求依赖服务。</p><ul><li>HystrixCommand.run()：返回一个单一的结果，或者抛出异常。</li><li>HystrixObservableCommand.construct()：返回一个<code>Observable</code>对象来发射多个结果，或者通过<code>onError</code>发送错误通知。</li></ul><p>如果<code>run()</code>或<code>construct()</code>方法的执行时间超过了命令设置的超时阈值，当前处理的线程将会抛出一个<code>TimeoutException</code>（如果该命令不在其自身的线程中执行，则会通过单独的计时线程来抛出）。在这种情况下，<code>Hystrix</code>会转接到<code>fallback</code>处理逻辑（第8步）。同时，如果当前命令没有被取消或者中断，那么它最终会忽略<code>run()</code>或<code>construct()</code>方法的返回。</p><p>如果命令没有抛出异常并返回了结果，那么<code>Hystrix</code>在记录一些日志并采集监控报告之后将该结果返回。在使用<code>run()</code>的情况下，<code>Hystrix</code>会返回一个<code>Observable</code>，它发射单个结果并产生<code>onCompleted()</code>的结束通知；而在使用<code>construct()</code>的情况下，<code>Hystrix</code>会直接返回该方法产生的<code>Observable</code>对象。</p><ol start="7"><li>计算断路器的健康度</li></ol><p><code>Hystrix</code>会将“成功”、“失败”、“拒绝”、“超时”等信息报告给断路器，而断路器会维护一组计数器来统计这些数据。</p><p>断路器会使用这些统计数据来决定是否要将断路器打开，来对某个依赖服务的请求进行“熔断/短路”，直到恢复期结束。若在恢复期结束后，根据统计数据判断如果还是未达到健康指标，就再次“熔断/短路”。</p><ol start="8"><li>fallback处理</li></ol><p>当命令执行失败的时候，<code>Hystrix</code>会进入<code>fallback</code>尝试回退处理，我们通常也称之为“服务降级”。而能够引起服务降级处理的情况有下面几种：</p><ul><li>第4步，当前命令处于“熔断/短路”状态，断路器是打开的时候。</li><li>第5步，当前命令的线程池、请求队列或者信号量被占满的时候。</li><li>第6步，<code>HystrixCommand.run()</code>或者<code>HystrixObservableCommand.construct()</code>抛出异常的时候。</li></ul><p>在服务降级逻辑中，我们需要实现一个通用的响应结果，并且该结果的处理逻辑应当是从缓存或是根据一些静态逻辑来获取，而不是依赖网络请求获取。如果一定要在降级逻辑中包含网络请求，那么该请求也必须被包装在<code>HystrixCommand</code>或者<code>HystrixObservableCommand</code>中，从而形成级联的降级策略，而最终的降级逻辑一定不是一个依赖网络请求的处理，而是一个能够稳定的返回结果的处理逻辑。</p><p><code>HystrixCommand</code>和<code>HystrixObservableCommand</code>服务降级逻辑实现不同：</p><ul><li>当使用<code>HystrixCommand</code>时，通过实现<code>HystrixCommand.getFallback()</code>来实现服务降级逻辑。</li><li>当使用<code>HystrixObservableCommand</code>时，通过<code>HystrixObservableCommand.resumeWithFallback()</code>实现服务降级逻辑，该方法会返回一个<code>Observable</code>对象来发射一个或者多个降级结果。</li></ul><p>当命令的降级逻辑返回结果之后，<code>Hystrix</code>就会将该结果返回给调用者。当使用<code>HystrixCommand.getFallback()</code>时，它会返回一个<code>Observable</code>对象，该对象会发射<code>getFallback()</code>的处理结果。当使用<code>HystrixObservableCommand.resumeWithFallback()</code>时，它会将<code>Observable</code>对象直接返回。</p><p>如果我们没有为命令实现降级逻辑或者降级逻辑处理中抛出了异常，<code>Hystrix</code>依然会返回一个<code>Observable</code>对象，但是它不会发射任何结果数据，而是通过<code>onError()</code>方法通知命令立即中断请求，并通过<code>onError()</code>方法将引起命令失败的异常发给调用者。实现一个有可能失败的降级逻辑是一种非常糟糕的做法，我们应该在实现降级策略时尽可能避免失败的情况。</p><p>当然，完全不可能出现失败的完美降级策略是不存在的，如果降级执行发现失败的时候，<code>Hystrix</code>会根据不同的执行方法做不同的处理。</p><ul><li>execute()：抛出异常。</li><li>queue()：正常返回<code>Future</code>对象，但是当调用<code>get()</code>来获取结果的时候会抛出异常。</li><li>observe()：正常返回<code>Observable</code>对象，当订阅它的时候，将立即通过调用订阅者的<code>onError()</code>方法来通知终止请求。</li><li>toObservable()：正常返回<code>Observable</code>对象，当订阅它的时候，将通过调用订阅者的<code>onError()</code>方法来通知终止请求。</li></ul><ol start="9"><li>返回成功的响应</li></ol><p>当<code>Hystrix</code>命令执行成功之后，它会将处理结果直接返回或是以<code>Observable</code>的形式返回。而具体哪种方式取决于之前第2步中我们所提到的对命令的4种不同执行方式，下图中总结了这4种调用方式之前的依赖关系。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-675.png" alt="upload successful"></p><ul><li>toObservable()：返回最原始的<code>Observable</code>，必须通过订阅它才会真正触发命令的执行流程。</li><li>observe()：在<code>toObservable()</code>产生原始<code>Observable</code>之后立即订阅它，让命令能够马上开始异步执行，并返回一个<code>Observable</code>对象，当调用它的<code>subscribe</code>时，将重新产生结果和通知给订阅者。</li><li>queue()：将<code>toObservable()</code>产生的原始<code>Observable</code>通过<code>toBlocking()</code>方法转换成<code>BlockingObservable</code>对象，并调用它的<code>toFuture()</code>方法返回异步的<code>Future</code>对象。</li><li>execute()：在<code>queue()</code>产生异步结果<code>Future</code>对象之后，通过调用<code>get()</code>方法阻塞并等待结果的返回。</li></ul><h2 id="断路器原理"><a href="#断路器原理" class="headerlink" title="断路器原理"></a>断路器原理</h2><p>断路器在<code>HystrixCommand</code>和<code>HystrixObservableCommand</code>执行过程中起到了至关重要的作用，我们来看下断路器的原理。</p><p>断路器<code>HystrixCircuitBreaker</code>的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HystrixCircuitBreaker</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">allowRequest</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">markSuccess</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;...&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixCircuitBreakerImpl</span> <span class="keyword">implements</span> <span class="title">HystrixCircuitBreaker</span></span>&#123;...&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NoOpCircuitBreaker</span> <span class="keyword">implements</span> <span class="title">HystrixCircuitBreaker</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到断路器接口定义了三个抽象方法：</p><ul><li>allowRequest()：每个 <strong>Hystrix</strong> 命令的请求都通过它判断是否被执行。</li><li>isOpen()：返回当前断路器是否打开。</li><li>markSuccess()：用来闭合断路器。</li></ul><p>另外还有三个静态类。</p><ul><li><p>Factory：它维护了一个<strong>Hystrix</strong>命令与<code>HystrixCircuitBreaker</code>的关系集合。其中<code>String</code>类型的<code>key</code>通过<code>HystrixCommandKey</code>定义。每一个<strong>Hystrix</strong>命令都需要一个<code>key</code>来标识。一个<strong>Hystrix</strong>命令也会在该集合中找到它对应的<code>HystrixCircuitBreaker</code>实例。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ConcurrentHashMap&lt;String, HystrixCircuitBreaker&gt; circuitBreakersByCommand = <span class="keyword">new</span> ConcurrentHashMap&lt;String, HystrixCircuitBreaker&gt;();</span><br></pre></td></tr></table></figure></li><li><p>NoOpCircuitBreaker：它定义了一个什么都不做的断路器实现，它允许所有请求，并且断路器状态始终闭合。</p></li><li>HystrixCircuitBreakerImpl：它是<code>HystrixCircuitBreaker</code>的实现类，我们来分析一下它。</li></ul><p><strong>HystrixCircuitBreakerImpl</strong></p><p><code>HystrixCircuitBreakerImpl</code>定义了断路器的4个核心对象。</p><ul><li>HystrixCommandProperties properties：断路器对应<code>HystrixCommand</code>实例的属性对象。</li><li>HystrixCommandMetrics metrics：用来让<code>HystrixCommand</code>记录各类度量指标的对象。</li><li>AtomicBoolean circuitOpen：断路器是否打开的标志，默认false。</li><li>AtomicLong circuitOpenedOrLastTestedTime：断路器打开或是上一次测试的时间戳。</li></ul><p><code>HystrixCircuitBreakerImpl</code>对<code>HystrixCircuitBreaker</code>接口的各个方法实现如下。</p><p><strong>isOpen()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (circuitOpen.get()) &#123;</span><br><span class="line">        <span class="comment">// if we're open we immediately return true and don't bother attempting to 'close' ourself as that is left to allowSingleTest and a subsequent successful test to close</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we're closed, so let's see if errors have made us so we should trip the circuit open</span></span><br><span class="line">    HealthCounts health = metrics.getHealthCounts();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check if we are past the statisticalWindowVolumeThreshold</span></span><br><span class="line">    <span class="keyword">if</span> (health.getTotalRequests() &lt; properties.circuitBreakerRequestVolumeThreshold().get()) &#123;</span><br><span class="line">        <span class="comment">// we are not past the minimum volume threshold for the statisticalWindow so we'll return false immediately and not calculate anything</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (health.getErrorPercentage() &lt; properties.circuitBreakerErrorThresholdPercentage().get()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// our failure rate is too high, trip the circuit</span></span><br><span class="line">        <span class="keyword">if</span> (circuitOpen.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            <span class="comment">// if the previousValue was false then we want to set the currentTime</span></span><br><span class="line">            circuitOpenedOrLastTestedTime.set(System.currentTimeMillis());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// How could previousValue be true? If another thread was going through this code at the same time a race-condition could have</span></span><br><span class="line">            <span class="comment">// caused another thread to set it to true already even though we were in the process of doing the same</span></span><br><span class="line">            <span class="comment">// In this case, we know the circuit is open, so let the other thread set the currentTime and report back that the circuit is open</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体逻辑如下：</p><ol><li>如果断路器打开标识为true，就返回true，表示断路器处于打开状态。否则，就从<code>metrics</code>中获取<code>HealthCounts</code>做判断（该对象记录了一个滚动时间窗内的请求信息快照，默认时间窗为10s）。</li><li>如果它的请求总数（QPS）在预设的阈值范围内就返回false，表示断路器处于闭合状态。该参数配置为<code>circuitBreakerRequestVolumeThreshold</code>，默认值为20。</li><li>如果错误百分比在阈值之内就返回false，表示断路器处于闭合状态。该配置参数为<code>circuitBreakerErrorThresholdPercentage</code>，默认值为50。</li><li>如果上面的两个条件都不满足，则将断路器设置为打开状态。同时如果是从关闭状态切换到打开状态的话，就将当前时间记录到<code>circuitOpenedOrLastTestedTime</code>对象中。</li></ol><p><strong>allowRequest()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">allowRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (properties.circuitBreakerForceOpen().get()) &#123;</span><br><span class="line">        <span class="comment">// properties have asked us to force the circuit open so we will allow NO requests</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (properties.circuitBreakerForceClosed().get()) &#123;</span><br><span class="line">        <span class="comment">// we still want to allow isOpen() to perform it's calculations so we simulate normal behavior</span></span><br><span class="line">        isOpen();</span><br><span class="line">        <span class="comment">// properties have asked us to ignore errors so we will ignore the results of isOpen and just allow all traffic through</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !isOpen() || allowSingleTest();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体逻辑如下：</p><ol><li>先检查配置对象<code>properties</code>中的强制打开或关闭属性是否被设置。如果强制打开，就返回false，拒绝请求。如果强制关闭，会允许所有请求，但它也会调用<code>isOpen()</code>来执行断路器计算逻辑，用来模拟断路器行为。</li><li>默认情况下，断路器不会进入到上述分支，而是通过<code>!isOpen() || allowSingleTest()</code>来判断当前断路器是否打开。</li></ol><p>我们再来看下<code>allowSingleTest()</code>的相关代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">allowSingleTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> timeCircuitOpenedOrWasLastTested = circuitOpenedOrLastTestedTime.get();</span><br><span class="line">    <span class="comment">// 1) if the circuit is open</span></span><br><span class="line">    <span class="comment">// 2) and it's been longer than 'sleepWindow' since we opened the circuit</span></span><br><span class="line">    <span class="keyword">if</span> (circuitOpen.get() &amp;&amp; System.currentTimeMillis() &gt; timeCircuitOpenedOrWasLastTested + properties.circuitBreakerSleepWindowInMilliseconds().get()) &#123;</span><br><span class="line">        <span class="comment">// We push the 'circuitOpenedTime' ahead by 'sleepWindow' since we have allowed one request to try.</span></span><br><span class="line">        <span class="comment">// If it succeeds the circuit will be closed, otherwise another singleTest will be allowed at the end of the 'sleepWindow'.</span></span><br><span class="line">        <span class="keyword">if</span> (circuitOpenedOrLastTestedTime.compareAndSet(timeCircuitOpenedOrWasLastTested, System.currentTimeMillis())) &#123;</span><br><span class="line">            <span class="comment">// if this returns true that means we set the time so we'll return true to allow the singleTest</span></span><br><span class="line">            <span class="comment">// if it returned false it means another thread raced us and allowed the singleTest before we did</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体逻辑如下：</p><ol><li>拿到之前记录的时间戳<code>circuitOpenedOrLastTestedTime</code>。</li><li>当断路器打开时，判断时间戳+配置中的<code>circuitBreakerSleepWindowInMilliseconds</code>是否小于当前时间，是的话，就将当前时间更新到<code>circuitOpenedOrLastTestedTime</code>中，并且允许此次请求。</li></ol><p>可以看到<code>circuitBreakerSleepWindowInMilliseconds</code>属性设置了一个断路器打开之后的休眠时间（默认5s），在该休眠时间达到后，将再次允许请求尝试访问，此时断路器处于“半开”状态，若此时请求继续失败，断路器又进入打开状态，并且等待下一个休眠窗口过去之后再次尝试；如果请求成功，则将断路器重新置于关闭状态。所以通过<code>isOpen()</code>和<code>allowSingleTest()</code>方法的配合，实现了断路器打开和关闭状态的切换。</p><p><strong>markSuccess()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">markSuccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (circuitOpen.get()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (circuitOpen.compareAndSet(<span class="keyword">true</span>, <span class="keyword">false</span>)) &#123;</span><br><span class="line">            <span class="comment">//win the thread race to reset metrics</span></span><br><span class="line">            <span class="comment">//Unsubscribe from the current stream to reset the health counts stream.  This only affects the health counts view,</span></span><br><span class="line">            <span class="comment">//and all other metric consumers are unaffected by the reset</span></span><br><span class="line">            metrics.resetStream();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法用来在断路器“半开路”状态时使用。如果<strong>Hystrix</strong>命令调用成功，通过调用它将打开的断路器关闭，并重置度量指标对象。</p><p>下图是<strong>Netflix Hystrix</strong>官方文档中关于断路器的详细执行逻辑图，可以帮助我们理解相关内容。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-676.png" alt="upload successful"></p><h2 id="依赖隔离"><a href="#依赖隔离" class="headerlink" title="依赖隔离"></a>依赖隔离</h2><p><strong>Hystrix</strong>使用”舱壁模式“实现线程池的隔离。它会为每一个依赖服务创立一个独立的线程池，这样就算某个依赖服务出现延迟过高的情况，也只是对该依赖服务的调用产生影响，而不会拖慢其他的依赖服务。</p><p>通过实现对依赖服务的线程池隔离，可以带来如下优势：</p><ul><li>应用自身得到完全保护，不会受不可控的依赖服务影响。即便给依赖服务分配的线程池被填满，也不会影响应用自身的其余部分。</li><li>可以有效降低接入新服务的风险。如果新服务接入后运行不稳定或存在问题，完全不会影响到应用其他请求。</li><li>当依赖的服务从失效恢复正常后，它的线程池会被清理并且能够马上恢复健康的服务，相比之下，容器级别的清理恢复速度要慢得多。</li><li>当依赖的服务出现配置错误的时候，线程池会快速反映出此问题（通过失败次数、延迟、超时、拒绝等指标的增加情况）。同时，我们可以在不影响应用功能的情况下通过实时的动态属性刷新（Spring Cloud Config）来处理它。</li><li>当依赖的服务因实现机制调整等原因造成其性能出现很大变化时，线程池的监控指标信息会反映出这样的变化。同时，我们也可以通过实时动态刷新自身应用对依赖服务的阈值进行调整以适应依赖方的改变。</li><li>每个专业线程池都提供了内置的并发实现，可以利用它为同步的依赖服务构建异步访问。</li></ul><p>虽然线程池隔离的方案带来了如此多的好处，但我们可能会担心为每一个依赖服务都分配一个线程池是否会过多地增加系统的负载和开销。对于这一点，<strong>Netflix</strong>在设计<strong>Hystrix</strong>时，认为线程池上的开销相对于隔离所带来的的好处是无法比拟的。同时，<strong>Netflix</strong>也针对线程池的开销做了相关测试，以用结果打消<strong>Hystrix</strong>实现对性能影响的顾虑。</p><p>下图是<strong>Netflix Hystrix</strong>官方提供的一个<strong>Hystrix</strong>命令的性能监控图，该命令以每秒60个请求的速度（QPS）对一个单服务实例进行访问，该服务实例每秒运行的线程数峰值为350个。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-677.png" alt="upload successful"></p><p>通过上图我们可以看出，使用线程池隔离与不使用线程池隔离的耗时差异如下：</p><table><thead><tr><th>比较情况</th><th>未使用线程池隔离</th><th>使用了线程池隔离</th><th>耗时差距</th></tr></thead><tbody><tr><td>中位数</td><td>2ms</td><td>2ms</td><td>2ms</td></tr><tr><td>90百分位</td><td>5ms</td><td>8ms</td><td>3ms</td></tr><tr><td>99百分位</td><td>28ms</td><td>37ms</td><td>9ms</td></tr></tbody></table><p>在99%的情况想，使用线程池隔离的延迟有9ms，对于大多数需求来说这样的消耗是微乎其微的，更何况可为系统在稳定性和灵活性上带来巨大提示。</p><p>在<strong>Hystrix</strong>中除了可使用线程池之外，还可以使用信号量来控制单个依赖服务的并发度，信号量的开销远比线程池的开销小，但是它不能设置超时和实现异步访问。所以，只有在依赖服务是足够可靠的情况下才使用信号量。在<code>HystrixCommand</code>和<code>HystrixObservableCommand</code>中有两处支持信号量的使用。</p><ul><li>命令执行：如果将隔离策略参数<code>execution.isolation.strategy</code>设置为<code>SEMAPHORE</code>，<strong>Hystrix</strong>会使用信号量代替线程池来控制依赖服务的并发。</li><li>降级逻辑：当<strong>Hystrix</strong>尝试降级逻辑时，它会在调用线程中使用信号量。</li></ul><p>信号量的默认值为10，我们也可以通过动态刷新配置的方式来控制并发线程的数量。对于信号量大小的估算方法与线程池并发度估算类似。仅访问内存数据的请求一般耗时在1ms以内，性能可以达到 5000rps（rps指每秒请求数），这样级别的请求可以将信号量设置为1或者2，我们可以按照此标准并依据实际请求耗时来设置信号量。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本篇我们通过了解<strong>Hystrix</strong>的部分内容，借助官方文档，可以对<strong>Hystrix</strong>的工作原理有个大概了解，下篇文章我们将详细介绍<strong>Hystrix</strong>的使用方法，如创建请求、服务降级、异常处理、请求缓存、请求合并等。</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ol><li>Spring Cloud 微服务实战</li><li><a href="https://github.com/Netflix/Hystrix/wiki/How-it-Works" rel="external nofollow noopener noreferrer" target="_blank">Netflix Hystrix</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="SpringCloud" scheme="https://www.sakuratears.top/tags/SpringCloud/"/>
    
      <category term="Hystrix" scheme="https://www.sakuratears.top/tags/Hystrix/"/>
    
  </entry>
  
  <entry>
    <title>【转】【译】Java 14 特性及更新</title>
    <link href="https://www.sakuratears.top/blog/%E3%80%90%E8%BD%AC%E3%80%91%E3%80%90%E8%AF%91%E3%80%91Java-14-%E7%89%B9%E6%80%A7%E5%8F%8A%E6%9B%B4%E6%96%B0.html"/>
    <id>https://www.sakuratears.top/blog/【转】【译】Java-14-特性及更新.html</id>
    <published>2020-12-20T06:32:00.000Z</published>
    <updated>2021-01-10T10:09:09.711Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>2020年3月17日，Java 14 发布。通过这篇文章我们来看下它新增的一些特性，便于我们更好的了解及掌握。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>PS： 预览特性表示改特性被放到该版本后，可以正常使用，但在以后版本可能会有改动/删除（也可能不再改动/删除）。</p><h2 id="JEP-305-–-instanceof-匹配模式（预览特性）"><a href="#JEP-305-–-instanceof-匹配模式（预览特性）" class="headerlink" title="JEP 305 – instanceof 匹配模式（预览特性）"></a>JEP 305 – instanceof 匹配模式（预览特性）</h2><h3 id="instanceof操作符的改进"><a href="#instanceof操作符的改进" class="headerlink" title="instanceof操作符的改进"></a>instanceof操作符的改进</h3><p>我们以一个例子来看下<code>instanceof</code>操作符的改进。</p><ol><li>旧版本实现</li></ol><p>如果应用程序需要处理某种类型的类，但我们有父类类型的引用，那么我们需要检查该实例的类型并进行适当的类型转换。</p><p>例如，<code>Customer </code>的类型可以是<code>BusinessCustomer</code>或<code>PersonalCustomer</code>。根据客户实例的类型，我们可以根据上下文获取信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Customer customer = <span class="keyword">new</span> PersonalCustomer();   <span class="comment">//通过某些方法拿到数据，略</span></span><br><span class="line">String customerName = <span class="string">""</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//旧版本实现</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(customer <span class="keyword">instanceof</span> PersonalCustomer)</span><br><span class="line">&#123;</span><br><span class="line">    PersonalCustomer pCustomer = (PersonalCustomer) customer;   <span class="comment">//强转</span></span><br><span class="line">    customerName = String.join(<span class="string">" "</span>, pCustomer.getFirstName(), </span><br><span class="line">                            pCustomer.getMiddleName(), </span><br><span class="line">                            pCustomer.getLastName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(customer <span class="keyword">instanceof</span> BusinessCustomer)&#123;</span><br><span class="line">    BusinessCustomer bCustomer = (BusinessCustomer) customer;   <span class="comment">//强转</span></span><br><span class="line">    customerName = bCustomer.getLegalName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>新版本实现</li></ol><p>现在，通过与<code>instanceof</code>进行模式匹配，我们可以用以下方式编写类似的代码。在这里，我们可以减少类型转换的样板代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新版本实现</span></span><br><span class="line"><span class="keyword">if</span>(customer <span class="keyword">instanceof</span> PersonalCustomer pCustomer)</span><br><span class="line">&#123;</span><br><span class="line">    customerName = String.join(<span class="string">" "</span>, pCustomer.getFirstName(), </span><br><span class="line">                            pCustomer.getMiddleName(), </span><br><span class="line">                            pCustomer.getLastName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(customer <span class="keyword">instanceof</span> BusinessCustomer bCustomer)</span><br><span class="line">&#123;</span><br><span class="line">    customerName = bCustomer.getLegalName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相关细节"><a href="#相关细节" class="headerlink" title="相关细节"></a>相关细节</h3><ol><li>类型测试模式</li></ol><p>类型测试模式包含以下内容:</p><ul><li>可以应用于目标的谓词</li><li>只有在谓词成功应用于目标时才从目标提取的一组绑定变量</li></ul><p>类型测试模式由指定类型的谓词和单个绑定变量组成。</p><p>在下面的代码中，短语字符串<code>s</code>是类型测试模式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String s) &#123;</span><br><span class="line">    <span class="comment">// 这儿可以直接使用s变量</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不能使用s变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>它做了什么</li></ol><p>如果<code>obj</code>是<code>String</code>的实例，则<code>instanceof</code>操作符将目标<code>obj</code>“匹配”到类型测试模式，然后将其转换为<code>String</code>并分配给绑定变量<code>s</code>。</p><p>需要注意的是，只有当<code>obj</code>不为空时，模式才会匹配，<code>s</code>才会被赋值。</p><ol start="3"><li>复杂表达式用法</li></ol><p>当<code>if</code>语句变得更加复杂时，绑定变量的作用域也相应增大。</p><p>例如，当我们添加<code>&amp;&amp;</code>运算符和另一条语句时，只有<code>instanceof</code>成功并分配给<code>pCustomer</code>时，添加的语句才会被计算。另外，<code>true</code>块中的<code>pCustomer</code>引用了所包含类中的一个字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以执行</span></span><br><span class="line"><span class="keyword">if</span>(customer <span class="keyword">instanceof</span> PersonalCustomer pCustomer </span><br><span class="line">        &amp;&amp; pCustomer.getId() &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    customerName = String.join(<span class="string">" "</span>, pCustomer.getFirstName(), </span><br><span class="line">                            pCustomer.getMiddleName(), </span><br><span class="line">                            pCustomer.getLastName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与上面的情况相反，当我们添加<code>||</code>操作符和另一条语句时，绑定变量<code>pCustomer</code>不在<code>||</code>操作符右手边的作用域内，也不在<code>true</code>块的作用域内。在这些点上，<code>pCustomer</code>引用了封闭类中的一个字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译错误 :: The pattern variable pCustomer is not in scope in this location</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(customer <span class="keyword">instanceof</span> PersonalCustomer pCustomer </span><br><span class="line">        || pCustomer.getId() &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    customerName = String.join(<span class="string">" "</span>, pCustomer.getFirstName(), </span><br><span class="line">                            pCustomer.getMiddleName(), </span><br><span class="line">                            pCustomer.getLastName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JEP-368-–-文本块（二次预览特性）"><a href="#JEP-368-–-文本块（二次预览特性）" class="headerlink" title="JEP 368 – 文本块（二次预览特性）"></a>JEP 368 – 文本块（二次预览特性）</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在<strong>Java</strong>中，文本块是一个多行字符串字面量。这意味着我们不需要陷入显式的行结束符、字符串连接和分隔符的混乱就可以编写普通字符串文本。</p><blockquote><p><strong>Java</strong> 文本块在 <strong>Java 13 (JEP 355)</strong> 和 <strong>Java 14 (JEP 368)</strong> 中作为预览特性可用。它计划成为<strong>Java 15 (JEP 378)</strong> 中的一个标准特性。</p></blockquote><p>要启用这个预览特性，我们必须使用<code>-enable-preview</code>和<code>-source 14</code>标志。</p><h3 id="文本块语法"><a href="#文本块语法" class="headerlink" title="文本块语法"></a>文本块语法</h3><ul><li>文本块由多行文本组成，并使用三个双引号字符(“ “ “)作为开始和结束分隔符。</li><li>开始的三个双引号字符后面总是跟一个行结束符。</li><li>我们不能将分隔符和文本块放在一行上。开始的分隔符必须在它自己的行上。内容只能从下一行开始。</li><li>如果文本内容包含单引号或双引号，则不需要对它们进行转义。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String dbSchema =   <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">            CREATE TABLE 'TEST'.'EMPLOYEE'</span></span><br><span class="line"><span class="string">            (</span></span><br><span class="line"><span class="string">              'ID' INT NOT NULL DEFAULT 0 ,</span></span><br><span class="line"><span class="string">              'FIRST_NAME' VARCHAR(100) NOT NULL ,</span></span><br><span class="line"><span class="string">              'LAST_NAME' VARCHAR(100) NULL ,</span></span><br><span class="line"><span class="string">              'STAT_CD' TINYINT NOT NULL DEFAULT 0</span></span><br><span class="line"><span class="string">            );</span></span><br><span class="line"><span class="string">                    "</span><span class="string">""</span>;</span><br></pre></td></tr></table></figure><p>看起来十分简单，我们再深入了解一下。</p><h3 id="与String相似之处"><a href="#与String相似之处" class="headerlink" title="与String相似之处"></a>与String相似之处</h3><ul><li>从文本块生成的实例的类型是<code>java.lang.String</code>。具有与传统双引号字符串相同特征的字符串。这包括对象表示和在字符串池中的表现。</li><li>我们可以使用文本块作为<code>String</code>类型的方法参数传递。</li><li>文本块可以在任何可以使用字符串文字的地方使用。例如，我们可以将它用于字符串连接。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String string = <span class="string">"Hello"</span>;</span><br><span class="line">String textBlock = <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">                    World"</span><span class="string">""</span>;</span><br><span class="line"> </span><br><span class="line">String joinedString =  string + textBlock;</span><br><span class="line"> </span><br><span class="line">System.out.println(joinedString);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello</span><br><span class="line">World</span><br></pre></td></tr></table></figure><h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><ol><li>偶然缩进和基本缩进</li></ol><p>文本块保留其内容的缩进。为了执行此操作，JEP将空格分为偶然缩进和基本缩进。</p><p>让我们来看下第一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String dbSchema =   <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">            CREATE TABLE 'TEST'.'EMPLOYEE'</span></span><br><span class="line"><span class="string">            (</span></span><br><span class="line"><span class="string">              'ID' INT NOT NULL DEFAULT 0 ,</span></span><br><span class="line"><span class="string">              'FIRST_NAME' VARCHAR(100) NOT NULL ,</span></span><br><span class="line"><span class="string">              'LAST_NAME' VARCHAR(100) NULL ,</span></span><br><span class="line"><span class="string">              'STAT_CD' TINYINT NOT NULL DEFAULT 0</span></span><br><span class="line"><span class="string">            );</span></span><br><span class="line"><span class="string">                    "</span><span class="string">""</span>;</span><br><span class="line"> </span><br><span class="line">System.out.println(dbSchema);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">|CREATE TABLE <span class="string">'TEST'</span>.<span class="string">'EMPLOYEE'</span></span><br><span class="line">|(</span><br><span class="line">|  <span class="string">'ID'</span> INT NOT NULL DEFAULT <span class="number">0</span> ,</span><br><span class="line">|  <span class="string">'FIRST_NAME'</span> VARCHAR(<span class="number">100</span>) NOT NULL ,</span><br><span class="line">|  <span class="string">'LAST_NAME'</span> VARCHAR(<span class="number">100</span>) NULL ,</span><br><span class="line">|  <span class="string">'STAT_CD'</span> TINYINT NOT NULL DEFAULT <span class="number">0</span></span><br><span class="line">|);</span><br></pre></td></tr></table></figure><p>这里，我们有两种类型的缩进:</p><p>第一个缩进是从行开始到所有行中的单词“CREATE”为止。这可以根据各种因素增加或减少，比如格式化插件或开发人员的选择。这是偶然的缩进。</p><p>第二次缩进是从字符’(‘到’ID’。大部分空间是4到8个空格。这样做是为了保持文本块的缩进意图。这被称为基本缩进。</p><blockquote><p><strong>Java</strong>文本块删除所有偶然的缩进，只保留基本的缩进。</p></blockquote><ol start="2"><li>添加自定义的缩进</li></ol><p>让我们想象一下，在上面的例子中，我们想要给所有行的左边两个制表符缩进。要做到这一点，我们可以将关闭的三重引号精确地向左移动两个制表符。放置的位置与应起压痕的位置完全相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String dbSchema =   <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">            CREATE TABLE 'TEST'.'EMPLOYEE'</span></span><br><span class="line"><span class="string">            (</span></span><br><span class="line"><span class="string">                'ID' INT NOT NULL DEFAULT 0 ,</span></span><br><span class="line"><span class="string">                'FIRST_NAME' VARCHAR(100) NOT NULL ,</span></span><br><span class="line"><span class="string">                'LAST_NAME' VARCHAR(100) NULL ,</span></span><br><span class="line"><span class="string">                'STAT_CD' TINYINT NOT NULL DEFAULT 0</span></span><br><span class="line"><span class="string">            );</span></span><br><span class="line"><span class="string">    "</span><span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(dbSchema);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">|       CREATE TABLE &apos;TEST&apos;.&apos;EMPLOYEE&apos;</span><br><span class="line">|       (</span><br><span class="line">|           &apos;ID&apos; INT NOT NULL DEFAULT 0 ,</span><br><span class="line">|           &apos;FIRST_NAME&apos; VARCHAR(100) NOT NULL ,</span><br><span class="line">|           &apos;LAST_NAME&apos; VARCHAR(100) NULL ,</span><br><span class="line">|           &apos;STAT_CD&apos; TINYINT NOT NULL DEFAULT 0</span><br><span class="line">|       );</span><br></pre></td></tr></table></figure><p>另外，请注意文本块中每行末尾的空格也会被Java编译器除去。</p><ol start="3"><li>TAB的处理</li></ol><p>对于编译器来说，了解制表符在不同编辑器中是如何显示的并不困难。</p><p>编译器将单个空格字符视为单个制表符，即使制表符可能会产生相当于8个空格的空白。</p><h3 id="行终止符"><a href="#行终止符" class="headerlink" title="行终止符"></a>行终止符</h3><p>不同的平台有不同的行结束符。Java不进行平台检测，并将文本块中的所有行终止符规范化为<code>\n</code>。</p><p>如果需要平台行终止符，则可以使用<code>String::replaceAll(“\n”,System.lineSeparator())</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String string = <span class="string">"Hello"</span>;</span><br><span class="line">String textBlock = <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">                    World"</span><span class="string">""</span>;</span><br><span class="line"> </span><br><span class="line">String joinedString =  string + textBlock;</span><br><span class="line"> </span><br><span class="line">joinedString = joinedString.replaceAll(<span class="string">"\n"</span>, System.lineSeparator());</span><br><span class="line"> </span><br><span class="line">System.out.println(joinedString);</span><br></pre></td></tr></table></figure><h3 id="新转义符"><a href="#新转义符" class="headerlink" title="新转义符"></a>新转义符</h3><ol><li>避开换行符</li></ol><p>很多时候，我们只希望将内容写入程序中的多行，但它们实际上是单个字符串内容。在这种情况下，我们可以使用行结束符转义字符，即单反斜杠’\’。它禁止包含隐式换行字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String dbSchema = <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">    CREATE TABLE 'TEST'.'EMPLOYEE'\</span></span><br><span class="line"><span class="string">    (\</span></span><br><span class="line"><span class="string">    'ID' INT NOT NULL DEFAULT 0 ,\</span></span><br><span class="line"><span class="string">    'FIRST_NAME' VARCHAR(100) NOT NULL ,</span></span><br><span class="line"><span class="string">    'LAST_NAME' VARCHAR(100) NULL ,\</span></span><br><span class="line"><span class="string">    'STAT_CD' TINYINT NOT NULL DEFAULT 0 \</span></span><br><span class="line"><span class="string">    );</span></span><br><span class="line"><span class="string">    "</span><span class="string">""</span>;</span><br><span class="line"> </span><br><span class="line">System.out.println(dbSchema);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|CREATE TABLE &apos;TEST&apos;.&apos;EMPLOYEE&apos;(&apos;ID&apos; INT NOT NULL DEFAULT 0 ,&apos;FIRST_NAME&apos; VARCHAR(100) NOT NULL ,</span><br><span class="line">&apos;LAST_NAME&apos; VARCHAR(100) NULL ,&apos;STAT_CD&apos; TINYINT NOT NULL DEFAULT 0 );</span><br></pre></td></tr></table></figure><ol start="2"><li>右侧空格补充</li></ol><p>如果出于某种原因不想去掉缩进，可以使用’\s’ (ASCII字符32，空格)转义序列。在任何一行的末尾使用它可以保证一行在遇到’\s’之前都有空格字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String dbSchema =   <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">    CREATE TABLE 'TEST'.'EMPLOYEE'          \s</span></span><br><span class="line"><span class="string">    (                                       \s</span></span><br><span class="line"><span class="string">      'ID' INT NOT NULL DEFAULT 0 ,         \s</span></span><br><span class="line"><span class="string">       'FIRST_NAME' VARCHAR(100) NOT NULL , \s</span></span><br><span class="line"><span class="string">      'LAST_NAME' VARCHAR(100) NULL ,       \s</span></span><br><span class="line"><span class="string">      'STAT_CD' TINYINT NOT NULL DEFAULT 0  \s</span></span><br><span class="line"><span class="string">    );                                      \s</span></span><br><span class="line"><span class="string">    "</span><span class="string">""</span>;</span><br><span class="line"> </span><br><span class="line">System.out.println(dbSchema.replaceAll(<span class="string">"\s"</span>, <span class="string">"."</span>));</span><br></pre></td></tr></table></figure><p>输出结果：</p><p>注：为便于理解，我们用’.’替换了所有空格。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE.TABLE.&apos;TEST&apos;.&apos;EMPLOYEE&apos;...........</span><br><span class="line">(........................................</span><br><span class="line">..&apos;ID&apos;.INT.NOT.NULL.DEFAULT.0.,..........</span><br><span class="line">...&apos;FIRST_NAME&apos;.VARCHAR(100).NOT.NULL.,..</span><br><span class="line">..&apos;LAST_NAME&apos;.VARCHAR(100).NULL.,........</span><br><span class="line">..&apos;STAT_CD&apos;.TINYINT.NOT.NULL.DEFAULT.0...</span><br><span class="line">);.......................................</span><br></pre></td></tr></table></figure><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li>只有在提高代码的清晰度时才使用文本块，特别是对于多行字符串。</li><li>如果字符串符合使用条件，请始终使用字符串。它们在应用程序性能方面更好。</li><li>为了保持所需的缩进，始终使用相对于内容的最后一行的三引号结束位置。</li><li>避免在复杂表达式(如lambda表达式或流操作)中出现内联文本块，以保持可读性。可考虑重构为局部变量或静态<code>final</code>字段。</li><li>文本块的缩进只使用空格或制表符。混合使用会导致文本对齐出现问题。</li></ol><h2 id="JEP-358-空指针问题定位"><a href="#JEP-358-空指针问题定位" class="headerlink" title="JEP 358 - 空指针问题定位"></a>JEP 358 - 空指针问题定位</h2><p>Java 14 通过精确地描述哪个变量为<code>null</code>，提高了由JVM生成的<code>NullPointerException</code>的可用性。</p><p>首先，我们需要传递<code>-XX:+ShowCodeDetailsInExceptionMessages</code> JVM参数，以便在运行应用程序时启用该特性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelpfulNullPointerException</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Employee e = <span class="keyword">null</span>;</span><br><span class="line">         </span><br><span class="line">        System.out.println(e.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    Long id;</span><br><span class="line">    String name;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出错误日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NullPointerException: </span><br><span class="line">    Cannot invoke &quot;com.howtodoinjava.core.basic.Employee.getName()&quot; because &quot;e&quot; is null</span><br><span class="line">    at com.howtodoinjava.core.basic.HelpfulNullPointerException.main </span><br><span class="line">    (HelpfulNullPointerException.java:9)</span><br></pre></td></tr></table></figure><p>可以看到现在日志清晰的告诉我们哪个方法哪个变量为<code>null</code>而引发的异常。</p><p>没有此特性之前的输出日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NullPointerException</span><br><span class="line">    at com.howtodoinjava.core.basic.HelpfulNullPointerException.main</span><br><span class="line">    (HelpfulNullPointerException.java:9)</span><br></pre></td></tr></table></figure><p>注意点：</p><ol><li>只有由JVM直接创建和抛出的<strong>NPEs</strong>才会包含<code>null</code>的细节消息(当我们在程序中创建异常时，通常会在构造函数中传递这些消息)。运行在JVM上的程序显式地创建和（或）抛出的<strong>NPEs</strong>不受字节码分析的影响。</li><li>请注意，由于一些原因，可能在所有情况下都不需要<code>null</code>细节消息。例如，它会影响性能，因为算法会给堆栈跟踪的生成增加一些开销。</li><li>此外，它还增加了安全风险，因为<code>null</code>细节消息提供了对源代码的洞察，否则就不容易获得这些信息。</li></ol><h2 id="JEP-359-record（预览特性）"><a href="#JEP-359-record（预览特性）" class="headerlink" title="JEP 359 - record（预览特性）"></a>JEP 359 - record（预览特性）</h2><p>Java 中的<code>record</code>类型。它是在 Java 14 中作为预览特性引入的，用于修饰普通的不可变数据类，实现类和应用程序之间的数据传输。</p><h3 id="record-类型"><a href="#record-类型" class="headerlink" title="record 类型"></a>record 类型</h3><p>与<code>enum</code>一样，<code>record</code>也是 Java 中的一种特殊类类型。它的目的是用于创建类仅作为纯数据载体的地方。</p><p><code>class</code>和<code>record</code>之间的重要区别在于，<code>record</code>旨在消除设置和从实例获取数据所需的所有样板代码。<code>record</code>将这个责任转移给Java编译器，Java编译器帮我们生成构造函数、字段<code>getter</code>、<code>hashCode()</code>和<code>equals()</code>以及<code>toString()</code>等方法。</p><p>我们可以在<code>record</code>定义中覆盖上面提供的任何默认方法来实现自定义行为。</p><ol><li>语法</li></ol><p>使用关键字<code>record</code>在Java中创建这样的<code>record</code>类。就像我们在构造函数中所做的一样，我们需要在<code>record</code>中设置属性和它们的类型。</p><p>在给定的示例中，<code>EmployeeRecord</code>用于保存员工信息，如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.howtodoinjava.core.basic;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> record <span class="title">EmployeeRecord</span><span class="params">(Long id, </span></span></span><br><span class="line"><span class="function"><span class="params">        String firstName, </span></span></span><br><span class="line"><span class="function"><span class="params">        String lastName, </span></span></span><br><span class="line"><span class="function"><span class="params">        String email, </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建和使用</li></ol><p>要创建一个<code>record</code>，需要调用它的构造函数并将所有字段信息传递进去。然后，我们可以使用JVM生成的<code>getter</code>方法获取记录信息，并调用任何生成的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.howtodoinjava.core.basic;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecordExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        EmployeeRecord e1 = <span class="keyword">new</span> EmployeeRecord</span><br><span class="line">                (<span class="number">1l</span>, <span class="string">"Lokesh"</span>, <span class="string">"Gupta"</span>, <span class="string">"howtodoinjava@gmail.com"</span>, <span class="number">38</span>);</span><br><span class="line">         </span><br><span class="line">        System.out.println(e1.id());</span><br><span class="line">        System.out.println(e1.email());</span><br><span class="line">         </span><br><span class="line">        System.out.println(e1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">howtodoinjava@gmail.com</span><br><span class="line">EmployeeRecord[id=1, firstName=Lokesh, lastName=Gupta, </span><br><span class="line">            email=howtodoinjava@gmail.com, age=38]</span><br></pre></td></tr></table></figure><ol start="3"><li>底层原理</li></ol><p>当我们创建<code>EmployeeRecord</code>记录时，编译器创建字节代码并在生成的类文件中包括以下内容:</p><ol><li>一个包含所有字段的构造函数。</li><li><code>toString()</code>方法的作用是:打印<code>record</code>中所有字段的状态/值。</li><li><code>equals()</code>和<code>hashCode()</code>方法使用基于 动态反射（invokedynamic）的机制。</li><li><code>getter</code>方法的名字类似于字段名，例如<code>id()</code>， <code>firstName()</code>， <code>lastName()</code>， <code>email()</code>和<code>age()</code>。</li><li>这个类继承自<code>java.lang.Record</code>，它是所有<code>record</code>的基类。这意味着<code>record</code>不能继承其他类。</li><li>这个类被标记为<code>final</code>类型，这意味着我们不能创建它的子类。</li><li>它没有任何<code>setter</code>方法，这意味着<code>record</code>实例被设计为不可变的。</li></ol><p>如果我们在生成的类文件上运行<code>javap</code>工具，我们将看到类文件的相关内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">howtodoinjava</span>.<span class="title">core</span>.<span class="title">basic</span>.<span class="title">EmployeeRecord</span> </span></span><br><span class="line"><span class="class">                                        <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Record</span> </span>&#123;</span><br><span class="line">  <span class="comment">//1                           </span></span><br><span class="line">  <span class="keyword">public</span> com.howtodoinjava.core.basic</span><br><span class="line">    .EmployeeRecord(java.lang.Long, java.lang.String, java.lang.String, java.lang.String, <span class="keyword">int</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//2</span></span><br><span class="line">  <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//3</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(java.lang.Object)</span></span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//4</span></span><br><span class="line">  <span class="keyword">public</span> java.lang.<span class="function">Long <span class="title">id</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">firstName</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">lastName</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">email</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">age</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-record-的场景"><a href="#使用-record-的场景" class="headerlink" title="使用 record 的场景"></a>使用 record 的场景</h3><ol><li>在建模诸如领域模型类(可能通过ORM持久化)或数据传输对象(DTO)之类的东西时，<code>record</code>是理想的候选对象。</li><li>这些<code>record</code>在临时存储数据时很有用。例如，可以在JSON反序列化期间。通常在反序列化期间，我们不期望程序改变从JSON读取的数据。我们只是读取数据并将其传递给数据处理器或验证器。</li><li>另外，<code>record</code>不能替换可变<strong>Java bean</strong>，因为<code>record</code>在设计上是不可变的。</li><li>当一个类打算保存数据一段时间并且希望避免编写大量样板代码时，请使用<code>record</code>。</li><li>我们可以在各种其他情况下使用<code>record</code>，例如保存方法、流连接、复合键的多个返回值，以及在数据结构(如树节点)中使用记录。</li></ol><h3 id="原理深度分析"><a href="#原理深度分析" class="headerlink" title="原理深度分析"></a>原理深度分析</h3><ol><li>动态反射（invokedynamic）</li></ol><p>如果我们看Java编译器生成的字节码来检查<code>toString()</code>(以及<code>equals()</code>和<code>hashCode()</code>)的方法实现，那么它们是使用基于<code>invokedynamic</code>的机制实现的。</p><p><code>invokedynamic</code>是一个字节码指令，它通过动态方法调用来实现动态语言(针对JVM)的相关功能。</p><ol start="2"><li>无法被继承实现子类化</li></ol><p>尽管所有<code>record</code>都继承了<code>java.lang.Record</code>类，我们仍然不能显式创建<code>java.lang.Record</code>的子类，编译器不会通过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Data</span> <span class="keyword">extends</span> <span class="title">Record</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> unit;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Compiler error : The type Data may not subclass Record explicitly</span></span><br></pre></td></tr></table></figure><p>这意味着获得<code>record</code>的唯一方法是显式地声明一个<code>record</code>，并让<code>javac</code>创建类文件。</p><ol start="3"><li>使用注解</li></ol><p>我们可以向记录的组件添加适用于它们的注释。例如，我们可以对<code>id</code>字段应用<code>@Transient</code>注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> record <span class="title">EmployeeRecord</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @Transient Long id, </span></span></span><br><span class="line"><span class="function"><span class="params">        String firstName, </span></span></span><br><span class="line"><span class="function"><span class="params">        String lastName, </span></span></span><br><span class="line"><span class="function"><span class="params">        String email, </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> age)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>序列化</li></ol><p><code>record</code>的Java序列化与常规类的序列化不同。<code>record</code>对象的序列化形式是从该对象的最终实例字段派生的值序列。<code>record</code>对象的流格式与流中的普通对象的流格式相同。</p><p>在反序列化中，如果指定流类描述符的本地类等价于一个<code>record</code>类，则首先读取并重新构建流字段，以作为<code>record</code>的组件值;其次，通过以组件值作为参数(或者如果流中缺少组件值，则为组件类型的默认值)调用<code>record</code>的规范构造函数来创建<code>record</code>对象。</p><p>除非是显式声明，否则<code>record</code>类的<code>serialVersionUID</code>为<code>0L</code>。对于<code>record</code>，也无需匹配<code>serialVersionUID</code>值。</p><p>无法自定义用于序列化<code>record</code>对象的过程;在序列化和反序列化期间，<code>record</code>类定义的任何特定于类的<code>writeObject</code>、<code>readObject</code>、<code>readObjectNoData</code>、<code>readResolve</code>、<code>writeExternal</code>和<code>readExternal</code>方法都会被忽略。但是，<code>writeReplace</code>方法可用于返回要序列化的替代对象。</p><p>在执行任何序列化或反序列化之前，我们必须确保<code>record</code>必须是可序列化或可外部化的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> record <span class="title">EmployeeRecord</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Long id, </span></span></span><br><span class="line"><span class="function"><span class="params">        String firstName, </span></span></span><br><span class="line"><span class="function"><span class="params">        String lastName, </span></span></span><br><span class="line"><span class="function"><span class="params">        String email, </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> age)</span> implements Serializable</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecordExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        EmployeeRecord e1 = <span class="keyword">new</span> EmployeeRecord</span><br><span class="line">                (<span class="number">1l</span>, <span class="string">"Lokesh"</span>, <span class="string">"Gupta"</span>, <span class="string">"howtodoinjava@gmail.com"</span>, <span class="number">38</span>);</span><br><span class="line">         </span><br><span class="line">        writeToFile(e1, <span class="string">"employee1"</span>);</span><br><span class="line">        System.out.println(readFromFile(<span class="string">"employee1"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeToFile</span><span class="params">(EmployeeRecord obj, String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream( <span class="keyword">new</span> FileOutputStream(path)))&#123;</span><br><span class="line">            oos.writeObject(obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">static</span> EmployeeRecord <span class="title">readFromFile</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        EmployeeRecord result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> (ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(path)))&#123;</span><br><span class="line">            result = (EmployeeRecord) ois.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException | IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EmployeeRecord[id=1, firstName=Lokesh, lastName=Gupta, </span><br><span class="line">            email=howtodoinjava@gmail.com, age=38]</span><br></pre></td></tr></table></figure><ol start="5"><li>其他字段和方法</li></ol><p>可以添加新的字段和方法，但不建议添加。</p><p>添加到<code>record</code>的新字段(未添加到组件列表中)必须是静态的。也可以添加一个方法来访问记录字段的内部状态。</p><p>添加的字段和方法不会在编译器隐式生成的字节代码中使用，因此它们不是<code>equals()</code>、<code>hashCode()</code>或<code>toString()</code>等任何方法实现的一部分。我们必须根据需要显式地使用它们。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> record <span class="title">EmployeeRecord</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Long id, </span></span></span><br><span class="line"><span class="function"><span class="params">        String firstName, </span></span></span><br><span class="line"><span class="function"><span class="params">        String lastName, </span></span></span><br><span class="line"><span class="function"><span class="params">        String email, </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> age)</span> implements Serializable </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//additional field</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> minor;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//additional method</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">fullName</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> firstName + <span class="string">" "</span> + lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>Compact Constructor</li></ol><p>我们可以在Compact Constructor中添加用于数据验证的构造函数特定代码。它有助于构建在给定业务上下文中有效的记录。</p><p>Compact Constructor不会导致编译器生成单独的构造函数。相反，在Compact Constructor中指定的代码将作为额外代码出现在规范构造函数的开始处。</p><p>我们不需要指定构造函数参数给字段的赋值，就像在规范构造函数中通常发生的那样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> record <span class="title">EmployeeRecord</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Long id, </span></span></span><br><span class="line"><span class="function"><span class="params">        String firstName, </span></span></span><br><span class="line"><span class="function"><span class="params">        String lastName, </span></span></span><br><span class="line"><span class="function"><span class="params">        String email, </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> age)</span> implements Serializable </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> EmployeeRecord</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(age &lt; <span class="number">18</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"You cannot hire a minor person as employee"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="API变化"><a href="#API变化" class="headerlink" title="API变化"></a>API变化</h3><ol><li>Class class</li></ol><p><code><a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/Class.html" rel="external nofollow noopener noreferrer" target="_blank">Class</a></code>类有两个方法—<code>isRecord()</code>和<code>getRecordComponents()</code>。<code>getRecordComponents()</code>方法返回一个<code>RecordComponent</code>对象数组。</p><p><code><a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/reflect/RecordComponent.html" rel="external nofollow noopener noreferrer" target="_blank">RecordComponent</a></code>是<code>java.lang.reflect</code>包中的一个新类。它包含十一个方法，用于检索注释和泛型类型的详细信息。</p><ol start="2"><li>ElementType 枚举</li></ol><p><code><a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/annotation/ElementType.html" rel="external nofollow noopener noreferrer" target="_blank">ElementType</a></code> 为 <code>record</code>新增了一个常量，<code>RECORD_COMPONENT</code>。</p><ol start="3"><li>javax.lang.model.element</li></ol><p><code><a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.compiler/javax/lang/model/element/ElementKind.html" rel="external nofollow noopener noreferrer" target="_blank">ElementKind</a></code>枚举为<code>record</code>新增了三个新的常量和<code>instanceof</code>特性的模式匹配，即<code>BINDING_VARIABLE</code>、<code>RECORD</code>和<code>RECORD_COMPONENT</code>。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>Java <code>record</code>是一个非常有用的特性，对Java类型系统是一个很好的补充，有助于几乎完全地减少为简单数据载体类编写的样板代码。</p><p>但是我们使用时应当注意，不要试图自定义它的行为，最好使用默认的构造。</p><h2 id="JEP-361-switch-表达式（标准）"><a href="#JEP-361-switch-表达式（标准）" class="headerlink" title="JEP 361 - switch 表达式（标准）"></a>JEP 361 - switch 表达式（标准）</h2><p>Java 14 中<code>switch</code>语句允许程序在运行时根据给定表达式的值有多个可能的执行路径。</p><p>求值表达式称为选择器表达式，它的类型必须是<code>char</code>、<code>byte</code>、<code>short</code>、<code>int</code>、<code>Character</code>、<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>String</code>或<code>enum</code>。</p><blockquote><p>在Java 14中，使用<code>switch</code>表达式，整个<code>switch</code>块“获得一个值”，然后可以在同一语句中将该值赋给一个变量。</p></blockquote><ol><li>例子</li></ol><ul><li>在Java 14中，它是一个标准特性。在Java 13和Java 12中，它作为预览特性。</li><li>它支持多个<code>case</code>标签，并使用<code>yield</code>来代替旧的<code>return</code>关键字返回值。</li><li>它还支持通过标签规则返回值(类似于<code>lambda</code>的箭头操作符)。</li><li>如果使用箭头函数(-&gt;)操作符，可以跳过<code>yield</code>关键字，如<code>isWeekDayV1_1()</code>所示。</li><li>如果使用冒号(:)操作符，则需要使用<code>yield</code>关键字，如<code>isWeekDayV1_2()</code>所示。</li><li>对于多个语句，使用大括号和<code>yield</code>关键字，如<code>isWeekDayV2()</code>所示。</li><li>对于<code>enum</code>，我们可以跳过默认情况。如果有任何丢失的值没有在<code>case</code>中处理，编译器将会报错。在所有其他表达式类型(<code>int</code>, <code>String</code>等)中，我们也必须提供默认情况。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwitchExpressions</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(isWeekDayV1_1(Day.MON));     <span class="comment">//true</span></span><br><span class="line">        System.out.println(isWeekDayV1_2(Day.MON));     <span class="comment">//true</span></span><br><span class="line">        System.out.println(isWeekDayV2(Day.MON));       <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//1 - 直接返回结果</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">enum</span> Day &#123;</span><br><span class="line">        MON, TUE, WED, THUR, FRI, SAT, SUN</span><br><span class="line">    &#125;;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">isWeekDayV1_1</span> <span class="params">(Day day)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Boolean result = <span class="keyword">switch</span>(day) &#123;</span><br><span class="line">            <span class="keyword">case</span> MON, TUE, WED, THUR, FRI -&gt; <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">case</span> SAT, SUN -&gt; <span class="keyword">false</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">isWeekDayV1_2</span> <span class="params">(Day day)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Boolean result = <span class="keyword">switch</span>(day) &#123;</span><br><span class="line">            <span class="keyword">case</span> MON, TUE, WED, THUR, FRI : yield <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">case</span> SAT, SUN : yield <span class="keyword">false</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//2 - 多条语句（部分处理后返回结果）</span></span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">isWeekDayV2</span> <span class="params">(Day day)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Boolean result = <span class="keyword">switch</span>(day) &#123;</span><br><span class="line">            <span class="keyword">case</span> MON, TUE, WED, THUR, FRI -&gt;</span><br><span class="line">            &#123; </span><br><span class="line">                System.out.println(<span class="string">"It is WeekDay"</span>);</span><br><span class="line">                yield <span class="keyword">true</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> SAT, SUN -&gt;</span><br><span class="line">            &#123; </span><br><span class="line">                System.out.println(<span class="string">"It is Weekend"</span>);</span><br><span class="line">                yield <span class="keyword">false</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>yield 和 return</li></ol><p><code>return</code>语句将控制权返回给方法或构造函数的调用者。<code>yield</code>语句通过使封闭的<code>switch</code>表达式产生指定的值来传递控制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SwitchExpression:</span><br><span class="line">    YieldStatement:</span><br><span class="line">        yield Expression;</span><br></pre></td></tr></table></figure><ul><li><code>SwitchExpression</code>试图找到一个正确的<code>YieldStatement</code>，以便将控制转移到最内层的<code>yield</code>目标。</li><li><code>SwitchExpression</code>正常终止，表达式的值成为<code>SwitchExpression</code>的值。</li><li>如果表达式的求值由于某种原因突然结束，那么<code>yield</code>语句也会由于同样的原因突然结束。</li></ul><h2 id="更多新特性"><a href="#更多新特性" class="headerlink" title="更多新特性"></a>更多新特性</h2><h3 id="JEP-343-–-打包工具（孵化）"><a href="#JEP-343-–-打包工具（孵化）" class="headerlink" title="JEP 343 – 打包工具（孵化）"></a>JEP 343 – 打包工具（孵化）</h3><p>在 JDK 8 中，一个名为<code>javapackager</code>的工具作为 JavaFX 工具包的一部分发布。然而，随着 JDK 11 的发布，JavaFX 从 Java 中分离出来后，流行的<code>javapackager</code>就不再可用了。</p><p>这个 JEP 基于<code>javapackager</code>工具创建了一个简单的打包工具，该工具支持本地打包格式，为最终用户提供自然的安装体验。这些格式包括 Windows 上的 msi和exe, macOS 上的 pkg和dmg，以及Linux上的 deb和rpm。</p><p>该工具可以从命令行直接调用，也可以通过工具提供程序API以编程方式调用。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jpackage --name myapp --input lib --main-jar main.jar</span><br></pre></td></tr></table></figure><h3 id="JEP-345-–-NUMA-Aware-Memory-Allocation-for-G1"><a href="#JEP-345-–-NUMA-Aware-Memory-Allocation-for-G1" class="headerlink" title="JEP 345 – NUMA-Aware Memory Allocation for G1"></a>JEP 345 – NUMA-Aware Memory Allocation for G1</h3><p>在Numa(Non-Uniform Memory Access 非均匀内存访问)内存体系结构中，每个处理器接收少量的本地内存，但是其他核心被授予访问它的权限。</p><p>并行垃圾收集器(由<code>-XX:+UseParallelGC</code>启用)，多年来一直支持Numa，并提高了跨多个套接字运行单个 JVM 的配置的性能。</p><p>有了这个 JEP , G1垃圾收集器得到了增强，可以在 Linux OS 下更好地管理内存。</p><h3 id="JEP-349-–-JFR-事件流"><a href="#JEP-349-–-JFR-事件流" class="headerlink" title="JEP 349 – JFR 事件流"></a>JEP 349 – JFR 事件流</h3><p>该JEP为进程内和进程外程序公开了JDK运行情况记录数据，方便我们进行监控。</p><p>以前要使用这些数据，用户必须启动记录、停止记录、将内容转储到磁盘，然后解析记录文件。虽然对于程序分析比较友好，因为通常一次记录至少一分钟的时间，但是它不适用于实时监控。</p><p>该JEP对包 <code>jdk.jfr.consumer</code>，<code>jdk.jfr</code>模块进行了扩展，提供了异步订阅事件的功能。用户可以直接从磁盘存储库读取记录数据或流，而无需转储记录文件。</p><h3 id="JEP-352-–-非易失性映射的字节缓冲区"><a href="#JEP-352-–-非易失性映射的字节缓冲区" class="headerlink" title="JEP 352 – 非易失性映射的字节缓冲区"></a>JEP 352 – 非易失性映射的字节缓冲区</h3><p>这个 JEP 添加了一个新的特定于JDK的文件映射模式，这样<code>FileChannel API</code>就可以用来创建引用 <strong>NVM</strong>(non-volatile memory 非易失性内存)的<code>MappedByteBuffer</code>实例。<strong>NVM</strong>也被称为持久内存，用于永久存储数据。</p><p>当前对<code>MappedByteBufer API</code>的更改意味着它支持允许直接内存更新所需的所有行为，并提供实现持久数据类型(例如块文件系统、日志记录日志、持久对象等)的更高级别<strong>Java</strong>客户端库所需的持久性保证。</p><h3 id="JEP-363-–-删除并发标记清除-CMS-垃圾收集器"><a href="#JEP-363-–-删除并发标记清除-CMS-垃圾收集器" class="headerlink" title="JEP 363 – 删除并发标记清除(CMS)垃圾收集器"></a>JEP 363 – 删除并发标记清除(CMS)垃圾收集器</h3><p>这个 JEP 的目的是删除掉在<strong>Java 9 (JEP 291)</strong>中被标记为<code>deprecated</code>的CMS垃圾收集器。由于 <strong>CMS GC</strong>的代码难以理解维护，且两年内未有相关感兴趣人员进行维护和更新。</p><p>所以现在，<strong>CMS GC</strong>已经从<strong>Java 14</strong>中删除了。需要注意的是，<strong>CMS GC</strong> 在 <strong>Java 13</strong>之前都是可用的。</p><h3 id="JEP-367-–-删除-Pack200-工具和相关-API"><a href="#JEP-367-–-删除-Pack200-工具和相关-API" class="headerlink" title="JEP 367 – 删除 Pack200 工具和相关 API"></a>JEP 367 – 删除 Pack200 工具和相关 API</h3><p>在<code>java.util.jar</code>包中删除<code>pack200</code>和<code>unpack200</code>工具。<code>Pack200 API</code>(<strong>Java SE 5.0</strong>中引入的JAR文件的压缩方案)在<strong>Java SE 11</strong>中他们已经被标记为<code>deprecated</code>，不建议使用，且未来版本明确会删除。</p><h3 id="JEP-370-–-外部内存访问API（孵化）"><a href="#JEP-370-–-外部内存访问API（孵化）" class="headerlink" title="JEP 370 – 外部内存访问API（孵化）"></a>JEP 370 – 外部内存访问API（孵化）</h3><p>有了这个 JEP , <strong>Java</strong> 提供了一个 <strong>API</strong> 来允许 <strong>Java</strong> 程序安全有效地访问 <strong>Java</strong> 堆之外的外部内存。</p><p>目标是相同的 <strong>API</strong> 应该能够操作各种类型的外部内存(例如，本机内存、持久内存、托管堆内存等)。</p><p>无论操作的内存类型如何，<strong>API</strong> 都不应该破坏 <strong>JVM</strong> 的安全性。另外，在源代码中内存回收操作应该是显式的。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ol><li><a href="https://howtodoinjava.com/java14/java14-new-features/" rel="external nofollow noopener noreferrer" target="_blank">Java 14 – New Features and Improvements</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="Java 14" scheme="https://www.sakuratears.top/tags/Java-14/"/>
    
  </entry>
  
  <entry>
    <title>【转】【译】The Twelve-Factor App</title>
    <link href="https://www.sakuratears.top/blog/%E3%80%90%E8%BD%AC%E3%80%91%E3%80%90%E8%AF%91%E3%80%91The-Twelve-Factor-App.html"/>
    <id>https://www.sakuratears.top/blog/【转】【译】The-Twelve-Factor-App.html</id>
    <published>2020-11-29T13:42:00.000Z</published>
    <updated>2021-01-10T10:09:09.712Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>如今，软件通常会作为一种服务来交付，它们被称为网络应用程序，或软件即服务（<strong>SaaS</strong>）。<strong>12-Factor</strong> 为构建如下的 <strong>SaaS</strong> 应用提供了方法论：</p><ul><li>使用标准化流程自动配置，从而使新的开发者花费最少的学习成本加入这个项目。</li><li>和操作系统之间尽可能的划清界限，在各个系统中提供最大的可移植性。</li><li>适合部署在现代的云计算平台，从而在服务器和系统管理方面节省资源。</li><li>将开发环境和生产环境的差异降至最低，并使用持续交付实施敏捷开发。</li><li>可以在工具、架构和开发流程不发生明显变化的前提下实现扩展。</li></ul><p>这套理论适用于任意语言和后端服务（数据库、消息队列、缓存等）开发的应用程序。</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>本文的贡献者参与过数以百计的应用程序的开发和部署，并通过 <a href="https://www.heroku.com/" rel="external nofollow noopener noreferrer" target="_blank">Heroku</a> 平台间接见证了数十万应用程序的开发，运作以及扩展的过程。</p><p>本文综合了我们关于 <strong>SaaS</strong> 应用几乎所有的经验和智慧，是开发此类应用的理想实践标准，并特别关注于应用程序如何保持良性成长，开发者之间如何进行有效的代码协作，以及如何 避免软件污染 。</p><p>我们的初衷是分享在现代软件开发过程中发现的一些系统性问题，并加深对这些问题的认识。我们提供了讨论这些问题时所需的共享词汇，同时使用相关术语给出一套针对这些问题的广义解决方案。本文格式的灵感来自于 <strong>Martin Fowler</strong> 的书籍： <strong>Patterns of Enterprise Application Architecture ， Refactoring</strong> 。</p><h1 id="读者应该是哪些人？"><a href="#读者应该是哪些人？" class="headerlink" title="读者应该是哪些人？"></a>读者应该是哪些人？</h1><p>任何 <strong>SaaS</strong> 应用的开发人员。部署和管理此类应用的运维工程师。</p><h1 id="12-Factors"><a href="#12-Factors" class="headerlink" title="12-Factors"></a>12-Factors</h1><h2 id="I-基准代码"><a href="#I-基准代码" class="headerlink" title="I. 基准代码"></a>I. 基准代码</h2><p><em>一份基准代码（Codebase），多份部署（deploy）</em></p><p><strong>12-Factor</strong>应用(译者注：应该是说一个使用本文概念来设计的应用，下同)通常会使用版本控制系统加以管理，如<strong>Git</strong>, <strong>Mercurial</strong>, <strong>Subversion</strong>。一份用来跟踪代码所有修订版本的数据库被称作 代码库（<strong>code repository</strong>, <strong>code repo</strong>, <strong>repo</strong>）。</p><p>在类似 <strong>SVN</strong> 这样的集中式版本控制系统中，基准代码 就是指控制系统中的这一份代码库；而在 <strong>Git</strong> 那样的分布式版本控制系统中，基准代码 则是指最上游的那份代码库。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-670.png" alt="upload successful"></p><p>基准代码和应用之间总是保持一一对应的关系：</p><ul><li>一旦有多个基准代码，就不能称为一个应用，而是一个分布式系统。分布式系统中的每一个组件都是一个应用，每一个应用可以分别使用 <strong>12-Factor</strong> 进行开发。</li><li>多个应用共享一份基准代码是有悖于 <strong>12-Factor</strong> 原则的。解决方案是将共享的代码拆分为独立的类库，然后使用 依赖管理 策略去加载它们。</li></ul><p>尽管每个应用只对应一份基准代码，但可以同时存在多份部署。每份 部署 相当于运行了一个应用的实例。通常会有一个生产环境，一个或多个预发布环境。此外，每个开发人员都会在自己本地环境运行一个应用实例，这些都相当于一份部署。</p><p>所有部署的基准代码相同，但每份部署可以使用其不同的版本。比如，开发人员可能有一些提交还没有同步至预发布环境；预发布环境也有一些提交没有同步至生产环境。但它们都共享一份基准代码，我们就认为它们只是相同应用的不同部署而已。</p><h2 id="II-依赖"><a href="#II-依赖" class="headerlink" title="II. 依赖"></a>II. 依赖</h2><p><em>显式声明依赖关系（ dependency ）</em></p><p>大多数编程语言都会提供一个打包系统，用来为各个类库提供打包服务，就像 <strong>Perl</strong> 的 <strong>CPAN</strong> 或是 <strong>Ruby</strong> 的 <strong>Rubygems</strong> 。通过打包系统安装的类库可以是系统级的（称之为 “site packages”），或仅供某个应用程序使用，部署在相应的目录中（称之为 “vendoring” 或 “bunding”）。</p><p><strong>12-Factor</strong>规则下的应用程序不会隐式依赖系统级的类库。 它一定通过 依赖清单 ，确切地声明所有依赖项。此外，在运行过程中通过 依赖隔离 工具来确保程序不会调用系统中存在但清单中未声明的依赖项。这一做法会统一应用到生产和开发环境。</p><p>例如， <strong>Ruby</strong> 的 <strong>Bundler</strong> 使用 <code>Gemfile</code> 作为依赖项声明清单，使用 <code>bundle exec</code> 来进行依赖隔离。<strong>Python</strong> 中则可分别使用两种工具 – <strong>Pip</strong> 用作依赖声明， <strong>Virtualenv</strong> 用作依赖隔离。甚至 <strong>C</strong> 语言也有类似工具， <strong>Autoconf</strong> 用作依赖声明，静态链接库用作依赖隔离。无论用什么工具，依赖声明和依赖隔离必须一起使用，否则无法满足 <strong>12-Factor</strong> 规范。</p><p>显式声明依赖的优点之一是为新进开发者简化了环境配置流程。新进开发者可以检出应用程序的基准代码，安装编程语言环境和它对应的依赖管理工具，只需通过一个 构建命令 来安装所有的依赖项，即可开始工作。例如，<strong>Ruby/Bundler</strong> 下使用 <code>bundle install</code>，而 <strong>Clojure/Leiningen</strong> 则是 <code>lein deps</code>。</p><p><strong>12-Factor</strong> 应用同样不会隐式依赖某些系统工具，如 <strong>ImageMagick</strong> 或是<code>curl</code>。即使这些工具存在于几乎所有系统，但终究无法保证所有未来的系统都能支持应用顺利运行，或是能够和应用兼容。如果应用必须使用到某些系统工具，那么这些工具应该被包含在应用之中。</p><h2 id="III-配置"><a href="#III-配置" class="headerlink" title="III. 配置"></a>III. 配置</h2><p><em>在环境中存储配置</em></p><p>通常，应用的 配置 在不同 部署 (预发布、生产环境、开发环境等等)间会有很大差异。这其中包括：</p><ul><li>数据库，<strong>Memcached</strong>，以及其他 后端服务 的配置</li><li>第三方服务的证书，如 <strong>Amazon S3</strong>、<strong>Twitter</strong> 等</li><li>每份部署特有的配置，如域名等</li></ul><p>有些应用在代码中使用常量保存配置，这与 <strong>12-Factor</strong> 所要求的代码和配置严格分离显然大相径庭。配置文件在各部署间存在大幅差异，代码却完全一致。</p><p>判断一个应用是否正确地将配置排除在代码之外，一个简单的方法是看该应用的基准代码是否可以立刻开源，而不用担心会暴露任何敏感的信息。</p><p>需要指出的是，这里定义的“配置”并不包括应用的内部配置，比如 <strong>Rails</strong> 的 <code>config/routes.rb</code>，或是使用 <strong>Spring</strong> 时 代码模块间的依赖注入关系 。这类配置在不同部署间不存在差异，所以应该写入代码。</p><p>另外一个解决方法是使用配置文件，但不把它们纳入版本控制系统，就像 <strong>Rails</strong> 的 <code>config/database.yml</code> 。这相对于在代码中使用常量已经是长足进步，但仍然有缺点：总是会不小心将配置文件签入了代码库；配置文件的可能会分散在不同的目录，并有着不同的格式，这让找出一个地方来统一管理所有配置变的不太现实。更糟的是，这些格式通常是语言或框架特定的。</p><p><strong>12-Factor</strong>推荐将应用的配置存储于 <em>环境变量</em> 中（ <code>env vars, env</code> ）。环境变量可以非常方便地在不同的部署间做修改，却不动一行代码；与配置文件不同，不小心把它们签入代码库的概率微乎其微；与一些传统的解决配置问题的机制（比如 <strong>Java</strong> 的属性配置文件）相比，环境变量与语言和系统无关。</p><p>配置管理的另一个方面是分组。有时应用会将配置按照特定部署进行分组（或叫做“环境”），例如 <strong>Rails</strong> 中的 <code>development</code>,<code>test</code>, 和 <code>production</code> 环境。这种方法无法轻易扩展：更多部署意味着更多新的环境，例如 <code>staging</code> 或 <code>qa</code>。 随着项目的不断深入，开发人员可能还会添加他们自己的环境，比如 <code>joes-staging</code> ，这将导致各种配置组合的激增，从而给管理部署增加了很多不确定因素。</p><p><strong>12-Factor</strong> 应用中，环境变量的粒度要足够小，且相对独立。它们永远也不会组合成一个所谓的“环境”，而是独立存在于每个部署之中。当应用程序不断扩展，需要更多种类的部署时，这种配置管理方式能够做到平滑过渡。</p><h2 id="IV-后端服务"><a href="#IV-后端服务" class="headerlink" title="IV. 后端服务"></a>IV. 后端服务</h2><p><em>把后端服务(backing services)当作附加资源</em></p><p>后端服务是指程序运行所需要的通过网络调用的各种服务，如数据库（<strong>MySQL</strong>，<strong>CouchDB</strong>），消息/队列系统（<strong>RabbitMQ，Beanstalkd</strong>），<strong>SMTP</strong> 邮件发送服务（<strong>Postfix</strong>），以及缓存系统（<strong>Memcached</strong>）。</p><p>类似数据库的后端服务，通常由部署应用程序的系统管理员一起管理。除了本地服务之外，应用程序有可能使用了第三方发布和管理的服务。示例包括 <strong>SMTP</strong>（例如 <strong>Postmark</strong>），数据收集服务（例如 <strong>New Relic</strong> 或 <strong>Loggly</strong>），数据存储服务（如 <strong>Amazon S3</strong>），以及使用 <strong>API</strong> 访问的服务（例如 <strong>Twitter</strong>, <strong>Google Maps</strong>, <strong>Last.fm</strong>）。</p><p><strong>12-Factor</strong> 应用不会区别对待本地或第三方服务。 对应用程序而言，两种都是附加资源，通过一个 <strong>url</strong> 或是其他存储在 配置 中的服务定位/服务证书来获取数据。<strong>12-Factor</strong> 应用的任意 部署 ，都应该可以在不进行任何代码改动的情况下，将本地 <strong>MySQL</strong> 数据库换成第三方服务（例如 <strong>Amazon RDS</strong>）。类似的，本地 <strong>SMTP</strong> 服务应该也可以和第三方 <strong>SMTP</strong> 服务（例如 Postmark ）互换。上述 2 个例子中，仅需修改配置中的资源地址。</p><p>每个不同的后端服务是一份 资源 。例如，一个 <strong>MySQL</strong> 数据库是一个资源，两个 <strong>MySQL</strong> 数据库（用来数据分区）就被当作是 2 个不同的资源。<strong>12-Factor</strong> 应用将这些数据库都视作 附加资源 ，这些资源和它们附属的部署保持松耦合。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-671.png" alt="upload successful"></p><p>部署可以按需加载或卸载资源。例如，如果应用的数据库服务由于硬件问题出现异常，管理员可以从最近的备份中恢复一个数据库，卸载当前的数据库，然后加载新的数据库 – 整个过程都不需要修改代码。</p><h2 id="V-构建，发布，运行"><a href="#V-构建，发布，运行" class="headerlink" title="V. 构建，发布，运行"></a>V. 构建，发布，运行</h2><p><em>严格分离构建和运行</em></p><p>基准代码 转化为一份部署(非开发环境)需要以下三个阶段：</p><ul><li>构建阶段 是指将代码仓库转化为可执行包的过程。构建时会使用指定版本的代码，获取和打包 依赖项，编译成二进制文件和资源文件。</li><li>发布阶段 会将构建的结果和当前部署所需 配置 相结合，并能够立刻在运行环境中投入使用。</li><li>运行阶段 （或者说“运行时”）是指针对选定的发布版本，在执行环境中启动一系列应用程序 进程。</li></ul><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-672.png" alt="upload successful"></p><p><strong>12-factor</strong> 应用严格区分构建，发布，运行这三个步骤。 举例来说，直接修改处于运行状态的代码是非常不可取的做法，因为这些修改很难再同步回构建步骤。</p><p>部署工具通常都提供了发布管理工具，最引人注目的功能是退回至较旧的发布版本。比如， <strong>Capistrano</strong> 将所有发布版本都存储在一个叫 <code>releases</code> 的子目录中，当前的在线版本只需映射至对应的目录即可。该工具的 <code>rollback</code> 命令可以很容易地实现回退版本的功能。</p><p>每一个发布版本必须对应一个唯一的发布 <code>ID</code>，例如可以使用发布时的时间戳（<code>2011-04-06-20:32:17</code>），亦或是一个增长的数字（<code>v100</code>）。发布的版本就像一本只能追加的账本，一旦发布就不可修改，任何的变动都应该产生一个新的发布版本。</p><p>新的代码在部署之前，需要开发人员触发构建操作。但是，运行阶段不一定需要人为触发，而是可以自动进行。如服务器重启，或是进程管理器重启了一个崩溃的进程。因此，运行阶段应该保持尽可能少的模块，这样假设半夜发生系统故障而开发人员又捉襟见肘也不会引起太大问题。构建阶段是可以相对复杂一些的，因为错误信息能够立刻展示在开发人员面前，从而得到妥善处理。</p><h2 id="VI-进程"><a href="#VI-进程" class="headerlink" title="VI. 进程"></a>VI. 进程</h2><p><em>以一个或多个无状态进程运行应用</em></p><p>运行环境中，应用程序通常是以一个和多个 进程 运行的。</p><p>最简单的场景中，代码是一个独立的脚本，运行环境是开发人员自己的笔记本电脑，进程由一条命令行（例如<code>python my_script.py</code>）。另外一个极端情况是，复杂的应用可能会使用很多 进程类型 ，也就是零个或多个进程实例。</p><p><strong>12-Factor</strong> 应用的进程必须无状态且 无共享 。 任何需要持久化的数据都要存储在 后端服务 内，比如数据库。</p><p>内存区域或磁盘空间可以作为进程在做某种事务型操作时的缓存，例如下载一个很大的文件，对其操作并将结果写入数据库的过程。<strong>12-Factor</strong>应用根本不用考虑这些缓存的内容是不是可以保留给之后的请求来使用，这是因为应用启动了多种类型的进程，将来的请求多半会由其他进程来服务。即使在只有一个进程的情形下，先前保存的数据（内存或文件系统中）也会因为重启（如代码部署、配置更改、或运行环境将进程调度至另一个物理区域执行）而丢失。</p><p>源文件打包工具（<strong>Jammit</strong>, <strong>django-compressor</strong>） 使用文件系统来缓存编译过的源文件。<strong>12-Factor</strong> 应用更倾向于在 构建步骤 做此动作——正如 <strong>Rails</strong>资源管道 ，而不是在运行阶段。</p><p>一些互联网系统依赖于 “粘性 <code>session</code>”， 这是指将用户 <code>session</code> 中的数据缓存至某进程的内存中，并将同一用户的后续请求路由到同一个进程。粘性 <code>session</code> 是 <strong>12-Factor</strong> 极力反对的。<strong>Session</strong> 中的数据应该保存在诸如 <strong>Memcached</strong> 或 <strong>Redis</strong> 这样的带有过期时间的缓存中。</p><h2 id="VII-端口绑定"><a href="#VII-端口绑定" class="headerlink" title="VII. 端口绑定"></a>VII. 端口绑定</h2><p><em>通过端口绑定(Port binding)来提供服务</em></p><p>互联网应用有时会运行于服务器的容器之中。例如 <strong>PHP</strong> 经常作为 <strong>Apache HTTPD</strong> 的一个模块来运行，正如 <strong>Java</strong> 运行于 <strong>Tomcat</strong> 。</p><p><strong>12-Factor</strong> 应用完全自我加载 而不依赖于任何网络服务器就可以创建一个面向网络的服务。互联网应用 通过端口绑定来提供服务 ，并监听发送至该端口的请求。</p><p>本地环境中，开发人员通过类似 <em><a href="http://localhost:5000/" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:5000/</a></em> 的地址来访问服务。在线上环境中，请求统一发送至公共域名而后路由至绑定了端口的网络进程。</p><p>通常的实现思路是，将网络服务器类库通过 依赖声明 载入应用。例如，<strong>Python</strong> 的 <strong>Tornado</strong>, <strong>Ruby</strong> 的<strong>Thin</strong> , <strong>Java</strong> 以及其他基于 <strong>JVM</strong> 语言的 <strong>Jetty</strong>。完全由 用户端 ，确切的说应该是应用的代码，发起请求。和运行环境约定好绑定的端口即可处理这些请求。</p><p><strong>HTTP</strong> 并不是唯一一个可以由端口绑定提供的服务。其实几乎所有服务器软件都可以通过进程绑定端口来等待请求。例如，使用 <strong>XMPP</strong> 的 <strong>ejabberd</strong> ， 以及使用 <strong>Redis</strong> 协议 的 <strong>Redis</strong> 。</p><p>还要指出的是，端口绑定这种方式也意味着一个应用可以成为另外一个应用的 后端服务 ，调用方将服务方提供的相应 <strong>URL</strong> 当作资源存入 配置 以备将来调用。</p><h2 id="VIII-并发"><a href="#VIII-并发" class="headerlink" title="VIII. 并发"></a>VIII. 并发</h2><p><em>通过进程模型进行扩展</em></p><p>任何计算机程序，一旦启动，就会生成一个或多个进程。互联网应用采用多种进程运行方式。例如，<strong>PHP</strong> 进程作为 <strong>Apache</strong> 的子进程存在，随请求按需启动。<strong>Java</strong> 进程则采取了相反的方式，在程序启动之初 <strong>JVM</strong> 就提供了一个超级进程储备了大量的系统资源(CPU 和内存)，并通过多线程实现内部的并发管理。上述 2 个例子中，进程是开发人员可以操作的最小单位。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-673.png" alt="upload successful"></p><p>在 <strong>12-factor</strong> 应用中，进程是一等公民。<strong>12-Factor</strong> 应用的进程主要借鉴于 <strong>unix</strong> 守护进程模型 。开发人员可以运用这个模型去设计应用架构，将不同的工作分配给不同的 进程类型 。例如，<strong>HTTP</strong> 请求可以交给 <strong>web</strong> 进程来处理，而常驻的后台工作则交由 <strong>worker</strong> 进程负责。</p><p>这并不包括个别较为特殊的进程，例如通过虚拟机的线程处理并发的内部运算，或是使用诸如 <strong>EventMachine</strong>, <strong>Twisted</strong>, <strong>Node.js</strong> 的异步/事件触发模型。但一台独立的虚拟机的扩展有瓶颈（垂直扩展），所以应用程序必须可以在多台物理机器间跨进程工作。</p><p>上述进程模型会在系统急需扩展时大放异彩。 <strong>12-Factor</strong> 应用的进程所具备的无共享，水平分区的特性 意味着添加并发会变得简单而稳妥。这些进程的类型以及每个类型中进程的数量就被称作 进程构成 。</p><p><strong>12-Factor</strong> 应用的进程 不需要守护进程 或是写入 <strong>PID</strong> 文件。相反的，应该借助操作系统的进程管理器(例如 <strong>systemd</strong> ，分布式的进程管理云平台，或是类似 <strong>Foreman</strong> 的工具)，来管理 输出流 ，响应崩溃的进程，以及处理用户触发的重启和关闭超级进程的请求。</p><h2 id="IX-易处理"><a href="#IX-易处理" class="headerlink" title="IX. 易处理"></a>IX. 易处理</h2><p><em>快速启动和优雅终止可最大化健壮性</em></p><p><strong>12-Factor</strong> 应用的 进程 是 易处理（<strong>disposable</strong>）的，意思是说它们可以瞬间开启或停止。 这有利于快速、弹性的伸缩应用，迅速部署变化的 代码 或 配置 ，稳健的部署应用。</p><p>进程应当追求 最小启动时间 。 理想状态下，进程从敲下命令到真正启动并等待请求的时间应该只需很短的时间。更少的启动时间提供了更敏捷的 发布 以及扩展过程，此外还增加了健壮性，因为进程管理器可以在授权情形下容易的将进程搬到新的物理机器上。</p><p>进程 一旦接收 终止信号（<strong>SIGTERM</strong>） 就会优雅的终止 。就网络进程而言，优雅终止是指停止监听服务的端口，即拒绝所有新的请求，并继续执行当前已接收的请求，然后退出。此类型的进程所隐含的要求是<strong>HTTP</strong>请求大多都很短(不会超过几秒钟)，而在长时间轮询中，客户端在丢失连接后应该马上尝试重连。</p><p>对于 <strong>worker</strong> 进程来说，优雅终止是指将当前任务退回队列。例如，<strong>RabbitMQ</strong> 中，<strong>worker</strong> 可以发送一个<strong>NACK</strong>信号。 <strong>Beanstalkd</strong> 中，任务终止并退回队列会在<strong>worker</strong>断开时自动触发。有锁机制的系统诸如 <strong>Delayed Job</strong> 则需要确定释放了系统资源。此类型的进程所隐含的要求是，任务都应该 可重复执行 ， 这主要由将结果包装进事务或是使重复操作 幂等 来实现。</p><p>进程还应当在面对突然死亡时保持健壮，例如底层硬件故障。虽然这种情况比起优雅终止来说少之又少，但终究有可能发生。一种推荐的方式是使用一个健壮的后端队列，例如 <strong>Beanstalkd</strong> ，它可以在客户端断开或超时后自动退回任务。无论如何，<strong>12-Factor</strong> 应用都应该可以设计能够应对意外的、不优雅的终结。<strong>Crash-only design</strong> 将这种概念转化为 合乎逻辑的理论。</p><h2 id="X-开发环境与线上环境等价"><a href="#X-开发环境与线上环境等价" class="headerlink" title="X. 开发环境与线上环境等价"></a>X. 开发环境与线上环境等价</h2><p><em>尽可能的保持开发，预发布，线上环境相同</em></p><p>从以往经验来看，开发环境（即开发人员的本地 部署）和线上环境（外部用户访问的真实部署）之间存在着很多差异。这些差异表现在以下三个方面：</p><ul><li>时间差异： 开发人员正在编写的代码可能需要几天，几周，甚至几个月才会上线。</li><li>人员差异： 开发人员编写代码，运维人员部署代码。</li><li>工具差异： 开发人员或许使用 <strong>Nginx</strong>，<strong>SQLite</strong>，<strong>OS X</strong>，而线上环境使用 <strong>Apache</strong>，<strong>MySQL</strong> 以及 <strong>Linux</strong>。</li></ul><p><strong>12-Factor</strong> 应用想要做到 持续部署 就必须缩小本地与线上差异。 再回头看上面所描述的三个差异:</p><ul><li>缩小时间差异：开发人员可以几小时，甚至几分钟就部署代码。</li><li>缩小人员差异：开发人员不只要编写代码，更应该密切参与部署过程以及代码在线上的表现。</li><li>缩小工具差异：尽量保证开发环境以及线上环境的一致性。</li></ul><p>将上述总结变为一个表格如下：</p><table><thead><tr><th>项目</th><th>传统应用</th><th>12-Factor 应用</th></tr></thead><tbody><tr><td>每次部署间隔</td><td>数周</td><td>几小时</td></tr><tr><td>开发人员 vs 运维人员</td><td>不同的人</td><td>相同的人</td></tr><tr><td>开发环境 vs 线上环境</td><td>不同</td><td>尽量接近</td></tr></tbody></table><p>后端服务 是保持开发与线上等价的重要部分，例如数据库，队列系统，以及缓存。许多语言都提供了简化获取后端服务的类库，例如不同类型服务的 适配器 。下列表格提供了一些例子。</p><table><thead><tr><th>类型</th><th>语言</th><th>类库</th><th>适配器</th></tr></thead><tbody><tr><td>数据库</td><td>Ruby/Rails</td><td>ActiveRecord</td><td>MySQL, PostgreSQL, SQLite</td></tr><tr><td>队列</td><td>Python/Django</td><td>Celery</td><td>RabbitMQ, Beanstalkd, Redis</td></tr><tr><td>缓存</td><td>Ruby/Rails</td><td>ActiveSupport::Cache</td><td>Memory, filesystem, Memcached</td></tr></tbody></table><p>开发人员有时会觉得在本地环境中使用轻量的后端服务具有很强的吸引力，而那些更重量级的健壮的后端服务应该使用在生产环境。例如，本地使用 <strong>SQLite</strong> 线上使用 <strong>PostgreSQL</strong>；又如本地缓存在进程内存中而线上存入 <strong>Memcached</strong>。</p><p><strong>12-Factor</strong> 应用的开发人员应该反对在不同环境间使用不同的后端服务 ，即使适配器已经可以几乎消除使用上的差异。这是因为，不同的后端服务意味着会突然出现的不兼容，从而导致测试、预发布都正常的代码在线上出现问题。这些错误会给持续部署带来阻力。从应用程序的生命周期来看，消除这种阻力需要花费很大的代价。</p><p>与此同时，轻量的本地服务也不像以前那样引人注目。借助于<strong>Homebrew</strong>，<strong>apt-get</strong>等现代的打包系统，诸如<strong>Memcached</strong>、<strong>PostgreSQL</strong>、<strong>RabbitMQ</strong> 等后端服务的安装与运行也并不复杂。此外，使用类似 <strong>Chef</strong> 和 <strong>Puppet</strong> 的声明式配置工具，结合像 Vagrant 这样轻量的虚拟环境就可以使得开发人员的本地环境与线上环境无限接近。与同步环境和持续部署所带来的益处相比，安装这些系统显然是值得的。</p><p>不同后端服务的适配器仍然是有用的，因为它们可以使移植后端服务变得简单。但应用的所有部署，这其中包括开发、预发布以及线上环境，都应该使用同一个后端服务的相同版本。</p><h2 id="XI-日志"><a href="#XI-日志" class="headerlink" title="XI. 日志"></a>XI. 日志</h2><p><em>把日志当作事件流</em></p><p>日志 使得应用程序运行的动作变得透明。在基于服务器的环境中，日志通常被写在硬盘的一个文件里，但这只是一种输出格式。</p><p>日志应该是 事件流 的汇总，将所有运行中进程和后端服务的输出流按照时间顺序收集起来。尽管在回溯问题时可能需要看很多行，日志最原始的格式确实是一个事件一行。日志没有确定开始和结束，但随着应用在运行会持续的增加。</p><p><strong>12-factor</strong>应用本身从不考虑存储自己的输出流。 不应该试图去写或者管理日志文件。相反，每一个运行的进程都会直接的标准输出（<strong>stdout</strong>）事件流。开发环境中，开发人员可以通过这些数据流，实时在终端看到应用的活动。</p><p>在预发布或线上部署中，每个进程的输出流由运行环境截获，并将其他输出流整理在一起，然后一并发送给一个或多个最终的处理程序，用于查看或是长期存档。这些存档路径对于应用来说不可见也不可配置，而是完全交给程序的运行环境管理。类似 <strong>Logplex</strong> 和 <strong>Fluentd</strong> 的开源工具可以达到这个目的。</p><p>这些事件流可以输出至文件，或者在终端实时观察。最重要的，输出流可以发送到 <strong>Splunk</strong> 这样的日志索引及分析系统，或 <strong>Hadoop/Hive</strong> 这样的通用数据存储系统。这些系统为查看应用的历史活动提供了强大而灵活的功能，包括：</p><ul><li>找出过去一段时间特殊的事件。</li><li>图形化一个大规模的趋势，比如每分钟的请求量。</li><li>根据用户定义的条件实时触发警报，比如每分钟的报错超过某个警戒线。</li></ul><h2 id="XII-管理进程"><a href="#XII-管理进程" class="headerlink" title="XII. 管理进程"></a>XII. 管理进程</h2><p><em>后台管理任务当作一次性进程运行</em></p><p>进程构成（<strong>process formation</strong>）是指用来处理应用的常规业务（比如处理 <strong>web</strong> 请求）的一组进程。与此不同，开发人员经常希望执行一些管理或维护应用的一次性任务，例如：</p><ul><li>运行数据移植（<strong>Django</strong> 中的 <code>manage.py migrate</code>, <strong>Rails</strong> 中的 <code>rake db:migrate</code>）。</li><li>运行一个控制台（也被称为 <strong>REPL shell</strong>），来执行一些代码或是针对线上数据库做一些检查。大多数语言都通过解释器提供了一个 <strong>REPL</strong> 工具（<code>python</code> 或 <code>perl</code>） ，或是其他命令（<strong>Ruby</strong> 使用 <code>irb</code>, <strong>Rails</strong> 使用 <code>rails console</code>）。</li><li>运行一些提交到代码仓库的一次性脚本。</li></ul><p>一次性管理进程应该和正常的 常驻进程 使用同样的环境。这些管理进程和任何其他的进程一样使用相同的 代码 和 配置 ，基于某个 发布版本 运行。后台管理代码应该随其他应用程序代码一起发布，从而避免同步问题。</p><p>所有进程类型应该使用同样的 依赖隔离 技术。例如，如果Ruby的web进程使用了命令 <code>bundle exec thin start</code> ，那么数据库移植应使用 <code>bundle exec rake db:migrate</code> 。同样的，如果一个 <strong>Python</strong> 程序使用了 <strong>Virtualenv</strong>，则需要在运行 <strong>Tornado Web</strong> 服务器和任何 <code>manage.py</code> 管理进程时引入 <code>bin/python</code> 。</p><p><strong>12-factor</strong> 尤其青睐那些提供了 <strong>REPL shell</strong> 的语言，因为那会让运行一次性脚本变得简单。在本地部署中，开发人员直接在命令行使用 <code>shell</code> 命令调用一次性管理进程。在线上部署中，开发人员依旧可以使用<strong>ssh</strong>或是运行环境提供的其他机制来运行这样的进程。</p><h1 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h1><p><a href="https://12factor.net/" rel="external nofollow noopener noreferrer" target="_blank">The Twelve-Factor App</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="12-factors" scheme="https://www.sakuratears.top/tags/12-factors/"/>
    
      <category term="12准则" scheme="https://www.sakuratears.top/tags/12%E5%87%86%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>CAS详解</title>
    <link href="https://www.sakuratears.top/blog/CAS%E8%AF%A6%E8%A7%A3.html"/>
    <id>https://www.sakuratears.top/blog/CAS详解.html</id>
    <published>2020-11-21T09:24:00.000Z</published>
    <updated>2021-01-10T10:08:11.734Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>CAS全称CompareAndSwap，比较并交换，主要是通过处理器的指令来保证操作的原子性，它包含三个操作数：</p><ol><li>变量内存地址，V表示</li><li>旧的预期值，A表示</li><li>准备设置的新值，B表示</li></ol><p>当执行CAS指令时，只有当V等于A时，才会用B去更新V的值，否则就不会执行更新操作。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="CAS原理"><a href="#CAS原理" class="headerlink" title="CAS原理"></a>CAS原理</h2><p>CAS的伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">//备份旧数据</span></span><br><span class="line">    <span class="comment">//基于旧数据构造新数据B</span></span><br><span class="line">&#125;<span class="keyword">while</span> (!CAS(变量内存地址,旧的预期值,准备设置的新值));</span><br></pre></td></tr></table></figure><p>如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-667.jpg" alt="upload successful"></p><ol><li>我们假设线程1和线程2同时访问变量V=33，两线程将变量值33拷贝到各自工作空间内存；</li><li>两线程分别进行 +1 操作，分别得到准备设置的新值34，而后进行值设置，对V进行 CAS 操作；</li><li>线程1操作成功，将值设置为34，完成后并更新自己本地值A=34；</li><li>这时候线程2操作就会返回失败，因为V的值以及被线程1设置为了34；</li><li>失败后，它会进行重试，它需要在获取34到本地，进行 +1 操作，再进行CAS(34,34,35)的操作，而后线程2将值设置成功。</li></ol><p>大家可能会有个疑问，如果在第2步，线程1和线程2同时进行CAS操作，是如何保证原子性的呢？</p><p>在<code>sun.misc.Unsafe</code>类中，我们可以看到<code>CompareAndSwap</code>方法是调用的原生代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object var1, <span class="keyword">long</span> var2, Object var4, Object var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4, <span class="keyword">long</span> var6)</span></span>;</span><br></pre></td></tr></table></figure><p>我们来分析一下它们的相关代码。</p><h2 id="CAS源码解析"><a href="#CAS源码解析" class="headerlink" title="CAS源码解析"></a>CAS源码解析</h2><p>我们以<code>compareAndSwapInt</code>为例，在<a href="http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/87ee5ee27509/src/share/vm/prims/unsafe.cpp" rel="external nofollow noopener noreferrer" target="_blank">openjdk 1.8 unsafe.cpp</a>里可以找到如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  UnsafeWrapper(<span class="string">"Unsafe_CompareAndSwapInt"</span>);</span><br><span class="line">  oop p = JNIHandles::resolve(obj);</span><br><span class="line">  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);</span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure><p>其对应我们的<code>sun.misc.Unsafe</code>类中的<code>compareAndSwapInt</code>方法。</p><p>关键方法为<code>Atomic::cmpxchg(x, addr, e)</code>，它位于<a href="http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/87ee5ee27509/src/share/vm/runtime/atomic.cpp" rel="external nofollow noopener noreferrer" target="_blank">openjdk 1.8 atomic.cpp</a>文件中，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> Atomic::cmpxchg(<span class="keyword">unsigned</span> <span class="keyword">int</span> exchange_value,</span><br><span class="line">                         <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>* dest, <span class="keyword">unsigned</span> <span class="keyword">int</span> compare_value) &#123;</span><br><span class="line">  assert(<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>) == <span class="keyword">sizeof</span>(jint), <span class="string">"more work to do"</span>);</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)Atomic::cmpxchg((jint)exchange_value, (<span class="keyword">volatile</span> jint*)dest,</span><br><span class="line">                                       (jint)compare_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Atomic::cmpxchg((jint)exchange_value, (volatile jint*)dest,(jint)compare_value)</code>方法位于<a href="http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/87ee5ee27509/src/os_cpu/windows_x86/vm/atomic_windows_x86.inline.hpp" rel="external nofollow noopener noreferrer" target="_blank">openjdk 1.8 atomic_windows_x86.inline.hpp</a>文件中，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> jint     Atomic::cmpxchg    (jint     exchange_value, <span class="keyword">volatile</span> jint*     dest, jint     compare_value) &#123;</span><br><span class="line">  <span class="comment">// alternative for InterlockedCompareExchange</span></span><br><span class="line">  <span class="keyword">int</span> mp = os::is_MP();</span><br><span class="line">  __asm &#123;</span><br><span class="line">    mov edx, dest</span><br><span class="line">    mov ecx, exchange_value</span><br><span class="line">    mov eax, compare_value</span><br><span class="line">    LOCK_IF_MP(mp)</span><br><span class="line">    cmpxchg dword ptr [edx], ecx</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mp</code>是<code>os::is_MP()</code>的返回结果，<code>os::is_MP()</code>是一个内联函数，用来判断当前系统是否为多处理器。</p><p>如果当前系统是多处理器，该函数返回1，否则，返回0。</p><p><code>LOCK_IF_MP(mp)</code>会根据<code>mp</code>的值来决定是否为<code>cmpxchg</code>指令添加<code>lock</code>前缀。</p><ul><li>如果通过<code>mp</code>判断当前系统是多处理器（即<code>mp</code>值为1），则为<code>cmpxchg</code>指令添加<code>lock</code>前缀。</li><li>否则，不加<code>lock</code>前缀。</li></ul><p>这是一种优化手段，单处理器的环境没有必要添加<code>lock</code>前缀，只有在多核情况下才会添加<code>lock</code>前缀，因为<code>lock</code>会导致性能下降。</p><p><code>cmpxchg</code>是汇编指令，作用是比较并交换操作数。</p><p><strong>关于lock指令</strong></p><ol><li>确保对内存的读-改-写操作原子执行。在Pentium及Pentium之前的处理器中，带有lock前缀的指令在执行期间会锁住总线，使得其他处理器暂时无法通过总线访问内存。很显然，这会带来昂贵的开销。从Pentium 4，Intel Xeon及P6处理器开始，intel在原有总线锁的基础上做了一个很有意义的优化：如果要访问的内存区域（area of memory）在lock前缀指令执行期间已经在处理器内部的缓存中被锁定（即包含该内存区域的缓存行当前处于独占或以修改状态），并且该内存区域被完全包含在单个缓存行（cache line）中，那么处理器将直接执行该指令。由于在指令执行期间该缓存行会一直被锁定，其它处理器无法读/写该指令要访问的内存区域，因此能保证指令执行的原子性。这个操作过程叫做缓存锁定（cache locking），缓存锁定将大大降低lock前缀指令的执行开销，但是当多处理器之间的竞争程度很高或者指令访问的内存地址未对齐时，仍然会锁住总线。</li><li>禁止该指令与之前和之后的读和写指令重排序。</li><li>把写缓冲区中的所有数据刷新到内存中。</li></ol><p>上面的第1点保证了CAS操作是一个原子操作，第2点和第3点所具有的内存屏障效果，保证了CAS同时具有<code>volatile</code>读和<code>volatile</code>写的内存语义。</p><p>有关<code>lock</code>指令更多内容，我们可以下载<a href="https://www.intel.cn/content/www/cn/zh/architecture-and-technology/64-ia-32-architectures-software-developer-vol-2a-manual.html" rel="external nofollow noopener noreferrer" target="_blank">Intel 官方文档</a> 来查看。</p><h2 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h2><p>虽然CAS很高效的解决了原子操作问题，但CAS仍有3个主要缺点：</p><ol><li>ABA问题：ABA的问题指的是在CAS更新的过程中，当读取到的值是A，然后准备赋值的时候仍然是A，但是实际上有可能A的值被改成了B，然后又被改回了A，这个CAS更新的漏洞就叫做ABA。只是ABA的问题大部分场景下都不影响并发的最终效果。</li></ol><p>Java中有<code>AtomicStampedReference</code>来解决这个问题，它加入了预期标志和更新后标志两个字段，更新时不光检查值，还要检查当前的标志是否等于预期标志，全部相等的话才会更新。</p><p>我们来简单看下它的部分代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicStampedReference</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> T reference;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> stamp;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Pair</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.reference = reference;</span><br><span class="line">            <span class="keyword">this</span>.stamp = stamp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">of</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(reference, stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Pair&lt;V&gt; pair;</span><br><span class="line">    <span class="comment">//....部分代码略</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                V   newReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> expectedStamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> newStamp)</span> </span>&#123;</span><br><span class="line">    Pair&lt;V&gt; current = pair;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        expectedReference == current.reference &amp;&amp;</span><br><span class="line">        expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">        ((newReference == current.reference &amp;&amp;</span><br><span class="line">            newStamp == current.stamp) ||</span><br><span class="line">            casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...部分代码略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>AtomicStampedReference</code>类中除了对象引用<code>reference</code>，还加入了标志字段<code>stamp</code>来解决ABA问题。</p><ol start="2"><li>循环时间长开销大：自旋CAS的方式如果长时间不成功，会给CPU带来很大的开销。</li></ol><p>上面图示中我们提到线程2如果更新不成功，会进行重试，其采用自旋方式进行重试，如果有多个线程操作共享变量时，部分线程可能自旋时间过长，对CPU造成较大开销。</p><ol start="3"><li>只能保证一个共享变量的原子操作：只对一个共享变量操作可以保证原子性，但是多个则不行，多个可以通过<code>AtomicReference</code>来处理或者使用锁<code>synchronized</code>实现。</li></ol><p>我们来看下<code>AtomicReference</code>的部分代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReference</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">1848883965231344442L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicReference.class.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> V value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...部分代码略</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V expect, V update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...部分代码略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到它是通过<code>compareAndSwapObject</code>函数来实现的。</p><p>经过上面分析，我们可以看到CAS操作和乐观锁的性质类似。</p><h2 id="CAS应用"><a href="#CAS应用" class="headerlink" title="CAS应用"></a>CAS应用</h2><p>CAS在<code>java.util.concurrent</code>包下的类中有大量被应用，有兴趣的同学可以看一下。</p><h2 id="CAS的开销"><a href="#CAS的开销" class="headerlink" title="CAS的开销"></a>CAS的开销</h2><p>CAS（比较并交换）是CPU指令级的操作，只有一步原子操作，所以非常快。而且CAS避免了请求操作系统来裁定锁的问题，不用麻烦操作系统，直接在CPU内部就搞定了。但CAS就没有开销了吗？不！有cache miss的情况。这个问题比较复杂，首先需要了解CPU的硬件体系结构：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-668.png" alt="upload successful"></p><p>上图可以看到一个8核CPU计算机系统，每个CPU有cache（CPU内部的高速缓存，寄存器），管芯内还带有一个互联模块，使管芯内的两个核可以互相通信。在图中央的系统互联模块可以让四个管芯相互通信，并且将管芯与主存连接起来。数据以“缓存线”为单位在系统中传输，“缓存线”对应于内存中一个 2 的幂大小的字节块，大小通常为 32 到 256 字节之间。当 CPU 从内存中读取一个变量到它的寄存器中时，必须首先将包含了该变量的缓存线读取到 CPU 高速缓存。同样地，CPU 将寄存器中的一个值存储到内存时，不仅必须将包含了该值的缓存线读到 CPU 高速缓存，还必须确保没有其他 CPU 拥有该缓存线的拷贝。</p><p>比如，如果 CPU0 在对一个变量执行“比较并交换”（CAS）操作，而该变量所在的缓存线在 CPU7 的高速缓存中，就会发生以下经过简化的事件序列：</p><ul><li>CPU0 检查本地高速缓存，没有找到缓存线。</li><li>请求被转发到 CPU0 和 CPU1 的互联模块，检查 CPU1 的本地高速缓存，没有找到缓存线。</li><li>请求被转发到系统互联模块，检查其他三个管芯，得知缓存线被 CPU6和 CPU7 所在的管芯持有。</li><li>请求被转发到 CPU6 和 CPU7 的互联模块，检查这两个 CPU 的高速缓存，在 CPU7 的高速缓存中找到缓存线。</li><li>CPU7 将缓存线发送给所属的互联模块，并且刷新自己高速缓存中的缓存线。</li><li>CPU6 和 CPU7 的互联模块将缓存线发送给系统互联模块。</li><li>系统互联模块将缓存线发送给 CPU0 和 CPU1 的互联模块。</li><li>CPU0 和 CPU1 的互联模块将缓存线发送给 CPU0 的高速缓存。</li><li>CPU0 现在可以对高速缓存中的变量执行 CAS 操作了</li></ul><p>以上是刷新不同CPU缓存的开销。最好情况下的 CAS 操作消耗大概 40 纳秒，超过 60 个时钟周期。这里的“最好情况”是指对某一个变量执行 CAS 操作的 CPU 正好是最后一个操作该变量的CPU，所以对应的缓存线已经在 CPU 的高速缓存中了，类似地，最好情况下的锁操作（一个“round trip 对”包括获取锁和随后的释放锁）消耗超过 60 纳秒，超过 100 个时钟周期。这里的“最好情况”意味着用于表示锁的数据结构已经在获取和释放锁的 CPU 所属的高速缓存中了。锁操作比 CAS 操作更加耗时，是因深入理解并行编程<br>为锁操作的数据结构中需要两个原子操作。缓存未命中消耗大概 140 纳秒，超过 200 个时钟周期。需要在存储新值时查询变量的旧值的 CAS 操作，消耗大概 300 纳秒，超过 500 个时钟周期。想想这个，在执行一次 CAS 操作的时间里，CPU 可以执行 500 条普通指令。这表明了细粒度锁的局限性。</p><p>以下是cache miss cas 和lock的性能对比：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-669.png" alt="upload successful"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇文章我们讲到了CAS的一些特点，大致了解了CAS的一些原理，在实际工作中，针对于一些场景，也可以使用CAS来操作。</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="https://www.cnblogs.com/Mainz/p/3546347.html" rel="external nofollow noopener noreferrer" target="_blank">非阻塞同步算法与CAS(Compare and Swap)无锁算法</a></li><li><a href="http://hg.openjdk.java.net/jdk8" rel="external nofollow noopener noreferrer" target="_blank">openjdk hotspot 1.8源码</a></li><li><a href="https://www.intel.cn/content/www/cn/zh/architecture-and-technology/64-ia-32-architectures-software-developer-vol-2a-manual.html" rel="external nofollow noopener noreferrer" target="_blank">Intel 官方文档</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="CAS" scheme="https://www.sakuratears.top/tags/CAS/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Hystrix服务容错保护入门</title>
    <link href="https://www.sakuratears.top/blog/Spring-Cloud-Hystrix%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99%E4%BF%9D%E6%8A%A4%E5%85%A5%E9%97%A8.html"/>
    <id>https://www.sakuratears.top/blog/Spring-Cloud-Hystrix服务容错保护入门.html</id>
    <published>2020-11-21T09:13:00.000Z</published>
    <updated>2020-11-21T09:25:02.213Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在微服务中，系统由许多服务单元构成，各单元的应用间通过服务注册与订阅的方式互相依赖。由于每个单元都在不同的进程中进行，依赖通过远程调用的方式执行，这样就有可能因为网络原因或者依赖服务自身问题出现调用故障或延迟，这些问题会直接导致调用方的对外服务也出现延迟，若此时调用方的请求不断增加，最后就会因等待出现故障的依赖方响应而形成任务积压，最终导致自身服务瘫痪。</p><p>由于微服务中存在众多服务单元，若一个单元出现故障，就很容易因依赖关系而引发故障的蔓延，最终导致整个系统瘫痪。未解决这样的问题，产生了断路器等一系列服务保护机制，而 Spring Cloud Hystrix 就是其中之一。</p><p>Spring Cloud Hystrix 基于 Netflix 开源框架 Hystrix 实现，具备 服务降级、服务熔断、线程和信号隔离、请求缓存、请求合并以及服务监控等强大功能。</p><p>接下来，我们从一个示例来了解它的使用及原理。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>由于内容较多，这篇文章我们先来了解下 Hystrix 的一个简单例子，然后再来了解两种模式：命令模式 和 观察者-订阅者模式。</p><h2 id="Hystrix示例"><a href="#Hystrix示例" class="headerlink" title="Hystrix示例"></a>Hystrix示例</h2><p>在Eureka和Ribbon的例子里，我们创建了 eureka-server、sakura-service、sakura-consumer服务，简单实现了微服务的调用。</p><p>PS：详见此文章<a href="https://www.sakuratears.top/blog/Eureka%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.html">Eureka简介及简单使用</a></p><p>我们启动3个 eureka-server（高可用服务注册中心）端口号为8001、8002、8003，启动2个sakura-service 模拟服务提供方，端口号为9001、9002，启动1个sakura-service 模拟服务提供方，端口号7001。</p><p>正常情况下，我们访问 <a href="http://host:port/consumer" rel="external nofollow noopener noreferrer" target="_blank">http://host:port/consumer</a> 会提示HelloWorld信息，如下图。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-662.jpg" alt="upload successful"></p><p>现在我们模拟服务提供方部分服务故障，停掉 sakura-service 的一个节点 9002 ，再次访问 <a href="http://host:port/consumer" rel="external nofollow noopener noreferrer" target="_blank">http://host:port/consumer</a> ，有时候正常，有时候会出现如下错误。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-663.jpg" alt="upload successful"></p><p>同时反应缓慢，因为需要等到我们这边服务调用超时，这种错误信息当调用方请求不断增加后，易出现任务积压，从而导致调用方对外服务也变得不可用。</p><p>下面我们引入 Spring Cloud Hystrix。</p><ul><li><p>在 sakura-consumer 工程的 <code>pom.xml</code>的 <code>dependency</code> 节点中引入 <code>spring-cloud-starter-netflix-hystrix</code>依赖。</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在 sakura-consumer 工程的主类<code>SakuraConsumerApplication</code>中使用<code>@EnableCircuitBreaker</code>开启断路器功能。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="meta">@RibbonClient</span>(name = <span class="string">"sakura"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SakuraConsumerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SakuraConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>改造服务消费方式，我们新增<code>SakuraService</code>类，注入<code>RestTemplate</code>。然后在<code>SakuraController</code>中注入<code>SakuraService</code>，并对其方法<code>hello</code>进行调用，同时，在<code>hello</code>方法上增加<code>@HystrixCommand</code>注解来指定回调方法。如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SakuraService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"helloFallback"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForEntity(<span class="string">"http://SAKURA-SERVICE/hello"</span>,String.class).getBody();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloFallback</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SakuraController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SakuraService sakuraService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/consumer"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sakuraService.hello();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这时候我们启动 sakura-consumer，同时停掉 sakura-service 的一个节点 9002 ，再次访问 <a href="http://host:port/consumer" rel="external nofollow noopener noreferrer" target="_blank">http://host:port/consumer</a> ，我们多次访问，可以看到有时候正常，有时候提示如下：</p><p>正常显示：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-664.jpg" alt="upload successful"></p><p>访问到服务异常的实例后提示：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-665.jpg" alt="upload successful"></p><p>上面的信息说明了当consumer访问到异常的实例后，不再返回之前的错误内容，而输出内容为error，也就是我们指定的 Hystrix 服务回调，即<code>helloFallback</code>里的内容。</p><p>这种是属于服务异常的情况，我们也可以模拟服务请求阻塞（长时间无响应）的情况，我们来看一下：</p><p>我们对sakura-service进行部分修改，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SakuraController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务注册</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"eurekaRegistration"</span>)</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Registration registration;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/hello"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> time = <span class="keyword">new</span> Random().nextInt(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">"sleepTime:"</span>+time);</span><br><span class="line">        Thread.sleep(time);</span><br><span class="line">        System.out.println(<span class="string">"Host:"</span>+registration.getHost()</span><br><span class="line">                +<span class="string">";ServiceID:"</span>+registration.getServiceId()</span><br><span class="line">                +<span class="string">";port:"</span>+registration.getPort()</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使其收到请求后随机0~3000ms在进行处理，而后重新启动 sakura-service （9001、9002）。</p><p>我们通过全局配置，在<code>application.properties</code>文件里设置 Hystrix 超时时间为 2000ms。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=2000</span><br></pre></td></tr></table></figure><p>然后我们调用 <a href="http://host:port/consumer" rel="external nofollow noopener noreferrer" target="_blank">http://host:port/consumer</a> ，可以看到当响应时间在 2000ms 内时，输出 Hello World，否则输出 error。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-666.jpg" alt="upload successful"></p><p>上面就是服务消费者因调用的服务超时从而触发熔断请求，并调用回调逻辑返回结果。</p><p>在了解 Hystrix 原理及详情之前，我们需要先对一下部分内容有所熟悉。</p><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>命令模式，它可以将来自客户端的请求封装成一个对象，从而让我们可以使用不同的请求对客户端进行参数化。它可以被用于实现“行为请求者”与“行为实现者”的解耦，以便使两者可以适应变化。</p><p>我们通过代码来看下命令模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//命令接收者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//真正的业务逻辑</span></span><br><span class="line">        System.out.println(<span class="string">"12345678"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//命令接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体命令实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Receiver receiver;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteCommand</span><span class="params">(Receiver receiver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver.action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端调用者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Invoker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(Command command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Receiver receiver = <span class="keyword">new</span> Receiver();</span><br><span class="line">        Command command = <span class="keyword">new</span> ConcreteCommand(receiver);</span><br><span class="line">        Invoker invoker = <span class="keyword">new</span> Invoker();</span><br><span class="line">        invoker.setCommand(command);</span><br><span class="line">        invoker.action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码对象示意如下：</p><ul><li>Receiver：接收者，它知道如何处理具体的业务逻辑。</li><li>Command：抽象命令，它定义了一个命令对象应具备的一系列命令操作，如<code>execute</code>，<code>undo</code>，<code>redo</code>等。当命令操作被调用的时候就会触发接收者去做具体命令对应的业务逻辑。</li><li>ConcreteCommand：具体的命令实现，在这里它绑定了命令操作与接收者之间的关系，<code>execute</code>命令的实现委托给了<code>Receiver</code>的<code>action</code>函数。</li><li>Invoker：调用者，它持有一个命令对象，并且可以在需要的时候通过命令对象完成具体的业务逻辑。</li></ul><p>从上面的例子我们可以看到，调用者<code>Invoker</code>与操作者<code>Receiver</code>通过<code>Command</code>命令接口实现了解耦。</p><p>对于调用者来说，我们可以为其注入多个命令操作，比如新建文件、复制文件、删除文件等操作，调用者只需在需要的时候调用即可，而不需要知道这些操作命令实际是如何实现的。</p><p>上面的示例中，我们可以发现，<code>Invoker</code>与<code>Receiver</code>的关系非常类似于“请求-响应”模式，所以它比较适用于实现记录日志、撤销操作、队列请求等。</p><p>下面这些情况下应考虑使用命令模式。</p><ul><li>使用命令模式作为“回调（Callback）”在面向对象系统中的替代。“Callback”讲的便是先将一个函数登记上，然后在以后在调用此函数。</li><li>需要在不同的时间指定请求、将请求排队。一个命令对象和原先的请求发出者可以有不同的生命期。换言之，原先的请求发出者可能已经不在了，而命令对象本身仍然是活动的。这时命令的接收者可以是在本地，也可以在网络的另一个地址。命令对象可以在序列化之后传送到另一台机器上去。</li><li>系统需要支持命令的撤销。命令对象可以把状态存储起来，等到客户端需要撤销命令所产生的效果时，可以调用<code>undo()</code>方法，把命令所产生的效果撤销掉。命令对象还可以提高<code>redo()</code>方法，以供客户端在需要时再重新实施命令效果。</li><li>如果要将系统中所有的数据更新到日志里，以便在系统崩溃是，可以根据日志读回所有的数据更新命令，重新调用<code>execute()</code>方法一条一条执行这些命令，从而恢复系统在崩溃前所做的数据更新。</li></ul><p>在 Hystrix 中，共有两种命令对象，如下：</p><ul><li>HystrixCommand ： 用在依赖的服务返回单个操作结果的时候。</li><li>HystrixObservableCommand ： 用在依赖的服务返回多个操作结果的时候。</li></ul><p>上面两个命令对象分别有两种命令执行方式，如下：</p><p>HystrixCommand：</p><ul><li>execute()：同步执行，从依赖的服务返回一个单一的结果对象，或是在发生错误的时候抛出异常。</li><li>queue()：异步执行，直接返回一个 <code>Future</code> 对象，其中包含了服务执行结束时要返回的单一结果对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R value = command.execute();</span><br><span class="line">Future&lt;R&gt; fValue = command.queue();</span><br></pre></td></tr></table></figure><p>HystrixObservableCommand:</p><ul><li>observe()：返回<code>Observable</code>对象，它代表了操作的多个结果，它是一个<strong>Hot Observable</strong>。</li><li>toObservable()：同样会返回<code>Observable</code>对象，也代表了操作的多个结果，但它返回的是一个<strong>Cold Observable</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;R&gt; ohValue = command.observe();</span><br><span class="line">Observable&lt;R&gt; ocValue = command.toObservable();</span><br></pre></td></tr></table></figure><p>在Hystrix底层大量使用了<strong>RxJava</strong>，我们在介绍Hystrix原理时，先对<strong>RxJava</strong>的 观察者-订阅者 模式来做一个简单了解。</p><h2 id="RxJava-观察者-订阅者模式"><a href="#RxJava-观察者-订阅者模式" class="headerlink" title="RxJava 观察者-订阅者模式"></a>RxJava 观察者-订阅者模式</h2><p>上面我们所提到的<code>Observable</code>对象就是<strong>RxJava</strong>的核心内容之一，可以把它理解为“事件源”或是“被观察者”，与其对应的<code>Subscriber</code>对象，可以理解为“订阅者”或是“观察者”。这两个对象是<strong>RxJava</strong>响应式编程的重要组成部分。</p><ul><li><code>Observable</code>用来向订阅者<code>Subscriber</code>对象发布事件，<code>Subscriber</code>对象则在接收到事件后对其进行处理，而在这里所指的的事件通常就是对依赖服务的调用。</li><li>一个<code>Observable</code>可以发出多个事件，直到结束或者发生异常。</li><li><code>Observable</code>对象每发出一个事件，就会调用对应观察者<code>Subscriber</code>对象的<code>onNext()</code>方法。</li><li>每一个<code>Observable</code>的执行，最后一定会通过调用<code>Subscriber.onCompleted()</code>或者<code>Subscriber.onError()</code>来结束该事件的操作流。</li></ul><p>我们通过一个例子来看一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建事件源observable</span></span><br><span class="line">        Observable&lt;String&gt; observable = Observable.unsafeCreate(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</span><br><span class="line">                subscriber.onNext(<span class="string">"Hello World"</span>);</span><br><span class="line">                subscriber.onNext(<span class="string">"I am sakuratears"</span>);</span><br><span class="line">                subscriber.onCompleted();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Subscriber&lt;String&gt; subscriber = <span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"completed"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Subscriber:"</span>+s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//订阅</span></span><br><span class="line">        observable.subscribe(subscriber);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该示例中，我们创建了一个简单的事件源<code>observable</code>，一个对事件传递内容输出的订阅者<code>subscriber</code>，通过<code>observable.subscribe(subscriber)</code>来触发事件的发布。</p><p>对于事件源<code>observable</code>，有两个不同的概念： <strong>Hot Observable</strong> 和 <strong>Cold Observable</strong>。其中<strong>Hot Observable</strong>，它不论“事件源”是否有“订阅者”，都会在创建后对事件进行发布，所以对于<strong>Hot Observable</strong>的每一个“订阅者”都有可能是从“事件源”的中途开始的，并可能只是看到了整个操作过程的局部过程。而<strong>Cold Observable</strong>在没有“订阅者”的时候并不会发布事件，而是进行等待，直到有“订阅者”之后才进行发布事件，所以对于<strong>Cold Observable</strong>的订阅者，它可以保证从一开始看到整个操作的全部过程。</p><p>以上就是在熟悉 Hystrix 源码时，我们应该有所了解的部分内容。</p><p>我们将在下篇文章详细分析 Hystrix 的一些内容。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇文章我们通过一个 Hystrix 的示例，对 Hystrix 有了简单的认识，同时简单介绍了两种模式，在 Hystrix 中，便使用了这两种模式，我们将在下篇文章详细分析，并进一步了解 Hystrix 的一些特点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="SpringCloud" scheme="https://www.sakuratears.top/tags/SpringCloud/"/>
    
      <category term="Hystrix" scheme="https://www.sakuratears.top/tags/Hystrix/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud Ribbon 配置详解</title>
    <link href="https://www.sakuratears.top/blog/SpringCloud-Ribbon-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3.html"/>
    <id>https://www.sakuratears.top/blog/SpringCloud-Ribbon-配置详解.html</id>
    <published>2020-11-01T10:02:00.000Z</published>
    <updated>2021-01-10T10:09:09.708Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在前面的文章中我们分析了SpringCloud Ribbon的源码，了解了Ribbon的特点及一些重要接口。这篇文章我们来看下Ribbon在使用时的各种配置。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Ribbon的自动化配置"><a href="#Ribbon的自动化配置" class="headerlink" title="Ribbon的自动化配置"></a>Ribbon的自动化配置</h2><p>由于Ribbon中定义的每个接口都有多种不同的策略实现，同时这些接口之间又有一定的依赖关系，某些开发者开始时很难上手，不知道如何选择具体实现策略等。</p><p>Spring Cloud Ribbon的自动化配置恰恰能够解决这种问题，当我们引入Spring Cloud Ribbon依赖之后，就能自动化构建下面这些接口的实现。</p><ul><li><code>IClientConfig</code>：Ribbon的客户端配置，默认采用<code>com.netflix.client.config.DefaultClientConfigImpl</code>实现。</li><li><code>IRule</code>：Ribbon的负载均衡策略，默认采用<code>com.netflix.loadbalancer.ZoneAvoidanceRule</code>实现，该策略能够在多区域环境下选出最佳区域的实例进行访问。</li><li><code>IPing</code>：Ribbon的实例检查策略，默认采用<code>com.netflix.loadbalancer.NoOpPing</code>实现，该策略不会检查实例是否可用，直接返回<code>true</code>，默认所有实例都是可用的。</li><li><code>ServerList&lt;Server&gt;</code>：服务实例清单维护机制，默认采用<code>com.netflix.loadbalancer.ConfigurationBasedServerList</code>实现。</li><li><code>ServerListFilter&lt;Server&gt;</code>：服务实例清单过滤机制，默认采用<code>org.springframework.cloud.netflix.ribbon.ZonePreferenceServerListFilter</code>实现，该策略能够优先过滤出与请求调用方处于同区域的服务实例。</li><li><code>ILoadBalancer</code>：负载均衡器，默认采用<code>com.netflix.loadbalancer.ZoneAwareLoadBalancer</code>实现，它具备了区域感知的能力。</li></ul><p>通过自动化配置的实现，我们可以轻松地实现客户端负载均衡。如果我们想实现一些个性化需求，也可以替换掉这些默认实现。</p><h2 id="代码配置"><a href="#代码配置" class="headerlink" title="代码配置"></a>代码配置</h2><p>如果我们想实现个性化配置，可以通过实现自定义的配置来完成，如下：</p><p>我们制定配置为<code>CustomLoadBalancer</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@RibbonClient</span>(name = <span class="string">"sakura"</span>,configuration = CustomLoadBalancer.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SakuraConsumerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SakuraConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实现如下：</p><p>使用了<code>NIWSDiscoveryPing</code>、<code>RandomRule</code>和我们前面文章自写的<code>ParallelPingStrategy</code>策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomLoadBalancer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">ILoadBalancer <span class="title">loadBalancer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BaseLoadBalancer(<span class="keyword">new</span> NIWSDiscoveryPing(),<span class="keyword">new</span> RandomRule(),<span class="keyword">new</span> ParallelPingStrategy());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，如果我们不需这么多改动，只想改变负载均衡策略。则如下配置即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerRule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IRule <span class="title">rule</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RandomRule();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他也与之类似。</p><p>这种配置方式唯一一个缺点是对于集群部署，如果我们想让每个节点的策略不同，需要变更相关代码，当然一般情况下每个节点的策略应是一致的。</p><h2 id="配置文件配置"><a href="#配置文件配置" class="headerlink" title="配置文件配置"></a>配置文件配置</h2><p>相比代码配置，使用配置文件配置相关参数更加灵活。</p><p>我们在<code>org.springframework.cloud.netflix.ribbon.PropertiesFactory</code>这个类里可以看到如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Map&lt;Class, String&gt; classToProperty = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PropertiesFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">classToProperty.put(ILoadBalancer.class, <span class="string">"NFLoadBalancerClassName"</span>);</span><br><span class="line">classToProperty.put(IPing.class, <span class="string">"NFLoadBalancerPingClassName"</span>);</span><br><span class="line">classToProperty.put(IRule.class, <span class="string">"NFLoadBalancerRuleClassName"</span>);</span><br><span class="line">classToProperty.put(ServerList.class, <span class="string">"NIWSServerListClassName"</span>);</span><br><span class="line">classToProperty.put(ServerListFilter.class, <span class="string">"NIWSServerListFilterClassName"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSet</span><span class="params">(Class clazz, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> StringUtils.hasText(getClassName(clazz, name));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getClassName</span><span class="params">(Class clazz, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.classToProperty.containsKey(clazz)) &#123;</span><br><span class="line">String classNameProperty = <span class="keyword">this</span>.classToProperty.get(clazz);</span><br><span class="line">String className = environment</span><br><span class="line">.getProperty(name + <span class="string">"."</span> + NAMESPACE + <span class="string">"."</span> + classNameProperty);</span><br><span class="line"><span class="keyword">return</span> className;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> &lt;C&gt; <span class="function">C <span class="title">get</span><span class="params">(Class&lt;C&gt; clazz, IClientConfig config, String name)</span> </span>&#123;</span><br><span class="line">String className = getClassName(clazz, name);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(className)) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class&lt;?&gt; toInstantiate = Class.forName(className);</span><br><span class="line"><span class="keyword">return</span> (C) SpringClientFactory.instantiateWithConfig(toInstantiate,</span><br><span class="line">config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unknown class to load "</span> + className</span><br><span class="line">+ <span class="string">" for class "</span> + clazz + <span class="string">" named "</span> + name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类可以动态地为<code>RibbonClient</code>创建接口实现。使用时，我们只需要&lt;clientName&gt;.ribbon.&lt;key&gt;=&lt;value&gt;的形式进行配置即可。</p><p>比如上面我们的代码配置，则可以用配置文件进行如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sakura.ribbon.NFLoadBalancerPingClassName = com.netflix.niws.loadbalancer.NIWSDiscoveryPing</span><br><span class="line">sakura.ribbon.NFLoadBalancerRuleClassName = com.netflix.loadbalancer.RandomRule</span><br><span class="line">sakura.ribbon.NFLoadBalancerClassName = com.zwt.sakuraconsumer.loadbalancer.CustomLoadBalancer</span><br></pre></td></tr></table></figure><h3 id="关于参数配置"><a href="#关于参数配置" class="headerlink" title="关于参数配置"></a>关于参数配置</h3><p>对于Ribbon的参数配置通常有两种方式：全局配置及指定客户端配置。</p><ul><li><p>全局配置：全局配置很简单，类如如下形式即可，ribbon.&lt;key&gt;=&lt;value&gt;格式配置即可。</p><p>  比如，我们全局配置Ribbon创建连接的超时时间。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ribbon.ConnectTimeout=300</span><br></pre></td></tr></table></figure><p>  全局配置可以作为默认值使用，当指定客户端配置了相应的key的值时，将覆盖全局配置的内容。</p></li><li><p>指定客户端配置：采用&lt;client&gt;.ribbon.&lt;key&gt;=&lt;value&gt;的格式进行配置。其中的&lt;client&gt;代表客户端名称，我们可以通过在<code>@RibbonClient</code>进行指定。</p><p>  比如，我们可以为客户端指定具体的实例清单，如下：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sakura.ribbon.listOfServers=localhost:8001,localhost:8002</span><br></pre></td></tr></table></figure></li></ul><p>在<code>com.netflix.client.config.CommonClientConfigKey</code>类中，我们可以找到Ribbon更为详细的配置参数内容。</p><p>我把参数详细信息整理如下，大家可以参考下：</p><table><thead><tr><th>配置项</th><th>类型</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>AppName</td><td>String</td><td></td><td>应用名称</td></tr><tr><td>Version</td><td>String</td><td></td><td>应用版本号</td></tr><tr><td>Port</td><td>Integer</td><td>7001</td><td>端口号</td></tr><tr><td>SecurePort</td><td>Integer</td><td>443</td><td>安全端口号</td></tr><tr><td>VipAddress</td><td>String</td><td></td><td>虚拟IP地址</td></tr><tr><td>ForceClientPortConfiguration</td><td>Boolean</td><td>false</td><td>是否强制使用客户端口号配置</td></tr><tr><td>DeploymentContextBasedVipAddresses</td><td>String</td><td></td><td></td></tr><tr><td>MaxAutoRetries</td><td>Integer</td><td>0</td><td>当前实例连接最大重试次数</td></tr><tr><td>MaxAutoRetriesNextServer</td><td>Integer</td><td>1</td><td>实例连接最大重试次数，超过会换其他实例重试</td></tr><tr><td>OkToRetryOnAllOperations</td><td>Boolean</td><td>false</td><td>是否对所有请求操作进行重试</td></tr><tr><td>RequestSpecificRetryOn</td><td>Boolean</td><td>false</td><td>是否对特殊请求进行重试</td></tr><tr><td>ReceiveBufferSize</td><td>Integer</td><td></td><td>接收到的数据流长度限制</td></tr><tr><td>EnablePrimeConnections</td><td>Boolean</td><td>false</td><td>启用预连接 （关于预连接请参考下文）</td></tr><tr><td>PrimeConnectionsClassName</td><td>String</td><td>com.netflix.niws.client.http.HttpPrimeConnection</td><td>预连接类名</td></tr><tr><td>MaxRetriesPerServerPrimeConnection</td><td>Integer</td><td>9</td><td>每个server的预连接最大重试次数</td></tr><tr><td>MaxTotalTimeToPrimeConnections</td><td>Integer</td><td>30000</td><td>预连接超时时间</td></tr><tr><td>MinPrimeConnectionsRatio</td><td>Float</td><td>1.0f</td><td>预连接最小时间间隔</td></tr><tr><td>PrimeConnectionsURI</td><td>String</td><td>/</td><td>预连接URI</td></tr><tr><td>PoolMaxThreads</td><td>Integer</td><td>200</td><td>连接池内最大可用线程数</td></tr><tr><td>PoolMinThreads</td><td>Integer</td><td>1</td><td>连接池内最小可用线程数</td></tr><tr><td>PoolKeepAliveTime</td><td>Integer</td><td>15 * 60L</td><td>连接在池内存活时间，默认15min</td></tr><tr><td>PoolKeepAliveTimeUnits</td><td>String</td><td>SECONDS</td><td>连接在池内存活时间单位</td></tr><tr><td>EnableConnectionPool</td><td>Boolean</td><td>true</td><td>是否启用连接池</td></tr><tr><td>MaxHttpConnectionsPerHost</td><td>Integer</td><td>50</td><td>已过时，详见MaxConnectionsPerHost</td></tr><tr><td>MaxTotalHttpConnections</td><td>Integer</td><td>200</td><td>已过时，详见MaxTotalConnections</td></tr><tr><td>MaxConnectionsPerHost</td><td>Integer</td><td>50</td><td>每个主机的最大连接数</td></tr><tr><td>MaxTotalConnections</td><td>Integer</td><td>200</td><td>最大连接总数</td></tr><tr><td>IsSecure</td><td>Boolean</td><td>false</td><td>是否安全连接</td></tr><tr><td>GZipPayload</td><td>Boolean</td><td>true</td><td>是否启用GZip传输</td></tr><tr><td>ConnectTimeout</td><td>Integer</td><td>2000</td><td>请求连接超时时间</td></tr><tr><td>BackoffTimeout</td><td>Integer</td><td></td><td></td></tr><tr><td>ReadTimeout</td><td>Integer</td><td>5000</td><td>请求处理超时时间</td></tr><tr><td>SendBufferSize</td><td>Integer</td><td></td><td>发送的数据最大长度</td></tr><tr><td>StaleCheckingEnabled</td><td>Boolean</td><td></td><td></td></tr><tr><td>Linger</td><td>Integer</td><td></td><td></td></tr><tr><td>ConnectionManagerTimeout</td><td>Integer</td><td>2000</td><td>连接管理器超时时间</td></tr><tr><td>FollowRedirects</td><td>Boolean</td><td>false</td><td>连接是否自动处理重定向</td></tr><tr><td>ConnectionPoolCleanerTaskEnabled</td><td>Boolean</td><td>true</td><td>是否启用连接池自动清理任务</td></tr><tr><td>ConnIdleEvictTimeMilliSeconds</td><td>Integer</td><td>30000</td><td>空闲连接存活时间</td></tr><tr><td>ConnectionCleanerRepeatInterval</td><td>Integer</td><td>30000</td><td>连接清理时间间隔</td></tr><tr><td>EnableGZIPContentEncodingFilter</td><td>Boolean</td><td>false</td><td>是否启用GZIP编码过滤</td></tr><tr><td>ProxyHost</td><td>String</td><td></td><td>服务代理地址</td></tr><tr><td>ProxyPort</td><td>Integer</td><td>Integer.MIN_VALUE + 1</td><td>代理服务端口号，默认值没有实际用途，如果使用需要用户自行设置</td></tr><tr><td>KeyStore</td><td>String</td><td></td><td></td></tr><tr><td>KeyStorePassword</td><td>String</td><td></td><td></td></tr><tr><td>TrustStore</td><td>String</td><td></td><td></td></tr><tr><td>TrustStorePassword</td><td>String</td><td></td><td></td></tr><tr><td>IsClientAuthRequired</td><td>Boolean</td><td>false</td><td>是否需要客户端安全认证（如果请求需要的话）</td></tr><tr><td>CustomSSLSocketFactoryClassName</td><td>String</td><td></td><td>用户自定义的SSL连接类</td></tr><tr><td>IsHostnameValidationRequired</td><td>Boolean</td><td></td><td>是否需要校验</td></tr><tr><td>IgnoreUserTokenInConnectionPoolForSecureClient</td><td>Boolean</td><td></td><td></td></tr><tr><td>ClientClassName</td><td>String</td><td>com.netflix.niws.client.http.RestClient</td><td>请求客户端的实现类</td></tr><tr><td>InitializeNFLoadBalancer</td><td>Boolean</td><td>true</td><td>是否初始化Ribbon负载均衡器</td></tr><tr><td>NFLoadBalancerClassName</td><td>String</td><td>com.netflix.loadbalancer.ZoneAwareLoadBalancer</td><td>使用的负载均衡器类名</td></tr><tr><td>NFLoadBalancerRuleClassName</td><td>String</td><td>com.netflix.loadbalancer.AvailabilityFilteringRule</td><td>负载均衡器的过滤规则</td></tr><tr><td>NFLoadBalancerPingClassName</td><td>String</td><td>com.netflix.loadbalancer.DummyPing</td><td>负载均衡器的ping规则</td></tr><tr><td>NFLoadBalancerPingInterval</td><td>Integer</td><td>30</td><td>ping间隔时间</td></tr><tr><td>NFLoadBalancerMaxTotalPingTime</td><td>Integer</td><td>2</td><td>ping的最大次数</td></tr><tr><td>NFLoadBalancerStatsClassName</td><td>String</td><td>com.netflix.loadbalancer.LoadBalancerStats</td><td>负载均衡状态统计类</td></tr><tr><td>NIWSServerListClassName</td><td>String</td><td>com.netflix.loadbalancer.ConfigurationBasedServerList</td><td>获取服务列表所使用的类</td></tr><tr><td>ServerListUpdaterClassName</td><td>String</td><td>com.netflix.loadbalancer.PollingServerListUpdater</td><td>服务列表更新所使用的类</td></tr><tr><td>NIWSServerListFilterClassName</td><td>String</td><td>com.netflix.loadbalancer.ZoneAffinityServerListFilter</td><td>区域甄别服务列表过滤类名</td></tr><tr><td>ServerListRefreshInterval</td><td>Integer</td><td>30 * 1000 ms</td><td>服务列表刷新间隔，单位毫秒</td></tr><tr><td>EnableMarkingServerDownOnReachingFailureLimit</td><td>Boolean</td><td></td><td></td></tr><tr><td>ServerDownFailureLimit</td><td>Integer</td><td></td><td></td></tr><tr><td>ServerDownStatWindowInMillis</td><td>Integer</td><td></td><td></td></tr><tr><td>EnableZoneAffinity</td><td>Boolean</td><td>false</td><td>是否开启区域甄别</td></tr><tr><td>EnableZoneExclusivity</td><td>Boolean</td><td>false</td><td>是否开启ZoneAffinity</td></tr><tr><td>PrioritizeVipAddressBasedServers</td><td>Boolean</td><td>true</td><td></td></tr><tr><td>VipAddressResolverClassName</td><td>String</td><td>com.netflix.client.SimpleVipAddressResolver</td><td></td></tr><tr><td>TargetRegion</td><td>String</td><td></td><td></td></tr><tr><td>RulePredicateClasses</td><td>String</td><td></td><td></td></tr><tr><td>RequestIdHeaderName</td><td>String</td><td></td><td></td></tr><tr><td>UseIPAddrForServer</td><td>Boolean</td><td>false</td><td>是否使用IP地址请求</td></tr><tr><td>listOfServers</td><td>String</td><td>“”</td><td>为客户端指定具体的实例清单</td></tr></tbody></table><p><strong>预连接</strong></p><p>对于那些拥有客户端负载均衡，并且知道要链接的服务器集群的客户端，我们可以预先与服务端建立连接，进行“预热”，这样做的好处是对于一些有防火墙的服务应用，请求时可以快速与之建立连接，提高应用体验。</p><p>详细信息可以查看 <code>com.netflix.niws.client.http.HttpPrimeConnection</code> 预连接处理类，这儿就不过多介绍了。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>关于上面的参数，很多是关于对Ribbon使用的HttpClient的配置，不太了解的可以先了解下HttpClient的一些参数配置等。</p><p>参数都遵循&lt;client&gt;.ribbon.&lt;key&gt;=&lt;value&gt;的配置。</p><p>比如我们以Ribbon的重试机制来进行举例，Spring Cloud整合了 Spring Retry来增强RestTemplate的重试能力，对于我们只需简单的配置，便可以实现重试功能。</p><p>我们在配置文件中添加如下配置信息，其配置信息含义已经说明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 该参数用来开启重试机制</span><br><span class="line">spring.cloud.loadbalancer.retry.enabled=true</span><br><span class="line"></span><br><span class="line">//断路器超时时间（断路器超时时间需要大于Ribbon超时时间，不然不会触发重试，有关断路器的内容，我们后面在了解）</span><br><span class="line">hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=10000</span><br><span class="line"></span><br><span class="line">//请求连接的超时时间</span><br><span class="line">sakura.ribbon.ConnectTimeout = 250</span><br><span class="line"></span><br><span class="line">//请求处理的超时时间</span><br><span class="line">sakura.ribbon.ReadTimeout= 1000</span><br><span class="line"></span><br><span class="line">//对所有请求操作进行重试</span><br><span class="line">sakura.ribbon.OkToRetryOnAllOperations = true</span><br><span class="line"></span><br><span class="line">//切换实例的重试次数</span><br><span class="line">sakura.ribbon.MaxAutoRetriesNextServer = 2</span><br><span class="line"></span><br><span class="line">//对当前实例的重试次数</span><br><span class="line">sakura.ribbon.MaxAutoRetries = 1</span><br></pre></td></tr></table></figure><p>根据如上配置，当访问到故障请求时，Ribbon会再尝试访问一次当前实例（访问次数取决于<code>MaxAutoRetries</code>），如果不行，就换一个实例进行访问，如果还是不行，再换一次实例访问（更换次数取决于<code>MaxAutoRetriesNextServer</code>），如果依然不行，返回失败。</p><h3 id="与Eureka结合"><a href="#与Eureka结合" class="headerlink" title="与Eureka结合"></a>与Eureka结合</h3><p>当我们在 Spring Cloud 的应用中同时引入 Spring Cloud Ribbon 和 Spring Cloud Eureka 依赖时，会触发 Eureka 中实现的对 Ribbon 的自动化配置。这时<code>ServerList</code>的维护机制实现将被<code>com.netflix.niws.loadbalancer.DiscoveryEnabledNIWSServerList</code>的实例所覆盖，该实现会将服务列表交给 Eureka 的服务治理机制来进行维护；<code>IPing</code>的实现将被<code>com.netflix.niws.loadbalancer.NIWSDiscoveryPing</code>的实例所覆盖，该实例也将实例检查的任务交给了服务治理框架来进行维护。默认情况下，用于获取实例请求的<code>ServerList</code>接口实现将采用 Spring Cloud Eureka 中封装的 <code>org.springframework.cloud.netflix.ribbon.eureka.DomainExtractingServerList</code>,其目的是为了让实例维护策略更加通用。</p><p>由于 Eureka 会为我们维护所有服务实例的清单，因此结合使用的时候，我们无需再配置类似<code>sakura.ribbon.listOfServers</code>的参数来指定服务实例清单。</p><p>此外，由于 Spring Cloud Ribbon 默认实现了区域亲和策略，所以我们可以通过 Eureka 实例的元数据配置来实现区域化的实例配置方案。比如，可以将处于不同机房的实例配置成不同的区域值，以作为跨区域的容错机制实现。而实现方式非常简单，只需在服务实例的元数据中增加 <code>zone</code>参数来指定自己所在的区域，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eureka.instance.metadataMap.zone=beijing</span><br></pre></td></tr></table></figure><p>在 Spring Cloud Ribbon 和 Spring Cloud Eureka 结合的工程中，我们也可以通过参数配置来禁用 Eureka 对 Ribbon 服务实例的维护实现。只需在配置文件加入如下参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ribbon.eureka.enabled=false</span><br></pre></td></tr></table></figure><p>禁用后，我们服务实例的维护需要手动指定<code>listOfServers</code>等参数。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是关于 Spring Cloud Ribbon 的一些配置及介绍，实际应用中，我们大多数与 Eureka 结合使用，很多遵循默认配置，真正的开箱即用，但我们也应对它们的配置及原理有所了解，方便我们更好的使用及解决可能出现的一系列问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="SpringCloud" scheme="https://www.sakuratears.top/tags/SpringCloud/"/>
    
      <category term="Ribbon" scheme="https://www.sakuratears.top/tags/Ribbon/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud Ribbon 负载均衡策略</title>
    <link href="https://www.sakuratears.top/blog/SpringCloud-Ribbon-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5.html"/>
    <id>https://www.sakuratears.top/blog/SpringCloud-Ribbon-负载均衡策略.html</id>
    <published>2020-10-18T13:29:00.000Z</published>
    <updated>2021-01-10T10:09:09.707Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>通过上篇文章对于SpringCloud Ribbon 负载均衡器的解读，我们已经对 Ribbon 实现负载均衡器以及其中包含的服务实例过滤器、服务实例信息存储对象、区域的信息快照等有了深入的认识和理解，接下来我们来看下负载均衡的几个策略实现。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>Ribbon中的负载均衡选择策略通过实现<code>IRule</code>接口来实现。具体关系如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-661.jpg" alt="upload successful"></p><p>下面我们来看下各种负载均衡策略。</p><h2 id="AbstractLoadBalancerRule"><a href="#AbstractLoadBalancerRule" class="headerlink" title="AbstractLoadBalancerRule"></a>AbstractLoadBalancerRule</h2><p>负载均衡策略的抽象类，在该抽象类中定义了负载均衡器<code>ILoadBalancer</code>对象，该对象能够在具体实现选择服务策略时，获取到一些负载均衡中维护的信息来作为分配依据，并以此设计一些算法来实现针对特定场景的高效策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractLoadBalancerRule</span> <span class="keyword">implements</span> <span class="title">IRule</span>, <span class="title">IClientConfigAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ILoadBalancer lb;</span><br><span class="line">        </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLoadBalancer</span><span class="params">(ILoadBalancer lb)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lb = lb;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ILoadBalancer <span class="title">getLoadBalancer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lb;</span><br><span class="line">    &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RandomRule"><a href="#RandomRule" class="headerlink" title="RandomRule"></a>RandomRule</h2><p>该策略实现了从服务实例清单中随机选择一个服务实例的功能。其具体实现如下：</p><p>主要由<code>choose</code>函数完成，委托给函数<code>choose(ILoadBalancer lb, Object key)</code>来实现。</p><ol><li>获取可用实例列表<code>upList</code>和所有实例列表<code>allList</code>；</li><li>获取一个随机数，通过<code>chooseRandomInt(serverCount)</code>函数；</li><li>将该随机数作为<code>upList</code>的索引值来返回具体实例；</li><li>选择逻辑处于一个循环中，正常情况下，每次都应该选出一个具体实例，如果出现死循环获取不到服务实例的情况，则可能出现一些问题。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(ILoadBalancer lb, Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lb == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Server server = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Server&gt; upList = lb.getReachableServers();</span><br><span class="line">        List&lt;Server&gt; allList = lb.getAllServers();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> serverCount = allList.size();</span><br><span class="line">        <span class="keyword">if</span> (serverCount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = chooseRandomInt(serverCount);</span><br><span class="line">        server = upList.get(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (server.isAlive()) &#123;</span><br><span class="line">            <span class="keyword">return</span> (server);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        server = <span class="keyword">null</span>;</span><br><span class="line">        Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> server;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">chooseRandomInt</span><span class="params">(<span class="keyword">int</span> serverCount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ThreadLocalRandom.current().nextInt(serverCount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> choose(getLoadBalancer(), key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RoundRobinRule"><a href="#RoundRobinRule" class="headerlink" title="RoundRobinRule"></a>RoundRobinRule</h2><p>该策略实现了按照线性轮询的方式一次选择每个服务实例的功能。其具体实现逻辑如下：</p><ol><li>获取可用实例列表<code>reachableServers</code>和所有实例列表<code>allServers</code>，并记录它们的数量<code>upCount</code>、<code>serverCount</code>；</li><li>获取下一个可用服务的索引，主要通过<code>incrementAndGetModulo</code>函数实现；</li><li>选择逻辑处于循环中，与<code>RandomRule</code>不同的是，如果一直选不到<code>server</code>超过10次，该循环终止，打印警告日志并返回null。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(ILoadBalancer lb, Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lb == <span class="keyword">null</span>) &#123;</span><br><span class="line">        log.warn(<span class="string">"no load balancer"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Server server = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (server == <span class="keyword">null</span> &amp;&amp; count++ &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        List&lt;Server&gt; reachableServers = lb.getReachableServers();</span><br><span class="line">        List&lt;Server&gt; allServers = lb.getAllServers();</span><br><span class="line">        <span class="keyword">int</span> upCount = reachableServers.size();</span><br><span class="line">        <span class="keyword">int</span> serverCount = allServers.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((upCount == <span class="number">0</span>) || (serverCount == <span class="number">0</span>)) &#123;</span><br><span class="line">            log.warn(<span class="string">"No up servers available from load balancer: "</span> + lb);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> nextServerIndex = incrementAndGetModulo(serverCount);</span><br><span class="line">        server = allServers.get(nextServerIndex);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/* Transient. */</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (server.isAlive() &amp;&amp; (server.isReadyToServe())) &#123;</span><br><span class="line">            <span class="keyword">return</span> (server);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Next.</span></span><br><span class="line">        server = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">        log.warn(<span class="string">"No available alive servers after 10 tries from load balancer: "</span></span><br><span class="line">                + lb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> server;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">incrementAndGetModulo</span><span class="params">(<span class="keyword">int</span> modulo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = nextServerCyclicCounter.get();</span><br><span class="line">        <span class="keyword">int</span> next = (current + <span class="number">1</span>) % modulo;</span><br><span class="line">        <span class="keyword">if</span> (nextServerCyclicCounter.compareAndSet(current, next))</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> choose(getLoadBalancer(), key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RetryRule"><a href="#RetryRule" class="headerlink" title="RetryRule"></a>RetryRule</h2><p>该策略实现了一个具备重试机制的实例选择功能。其具体实现逻辑如下：</p><ol><li>内部定义一个<code>IRule</code>对象，默认使用<code>RoundRobinRule</code>实例；</li><li><code>choose</code>函数中实现了对内部策略进行反复尝试的策略；</li><li>若期间能够选择到具体实例就返回，若选择不到就根据设置的尝试结束时间为阈值<code>maxRetryMillis</code>，当超过阈值后就返回null。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryRule</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalancerRule</span> </span>&#123;</span><br><span class="line">IRule subRule = <span class="keyword">new</span> RoundRobinRule();</span><br><span class="line"><span class="keyword">long</span> maxRetryMillis = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RetryRule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RetryRule</span><span class="params">(IRule subRule)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.subRule = (subRule != <span class="keyword">null</span>) ? subRule : <span class="keyword">new</span> RoundRobinRule();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RetryRule</span><span class="params">(IRule subRule, <span class="keyword">long</span> maxRetryMillis)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.subRule = (subRule != <span class="keyword">null</span>) ? subRule : <span class="keyword">new</span> RoundRobinRule();</span><br><span class="line"><span class="keyword">this</span>.maxRetryMillis = (maxRetryMillis &gt; <span class="number">0</span>) ? maxRetryMillis : <span class="number">500</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRule</span><span class="params">(IRule subRule)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.subRule = (subRule != <span class="keyword">null</span>) ? subRule : <span class="keyword">new</span> RoundRobinRule();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> IRule <span class="title">getRule</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> subRule;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaxRetryMillis</span><span class="params">(<span class="keyword">long</span> maxRetryMillis)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (maxRetryMillis &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.maxRetryMillis = maxRetryMillis;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.maxRetryMillis = <span class="number">500</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getMaxRetryMillis</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> maxRetryMillis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLoadBalancer</span><span class="params">(ILoadBalancer lb)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.setLoadBalancer(lb);</span><br><span class="line">subRule.setLoadBalancer(lb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Loop if necessary. Note that the time CAN be exceeded depending on the</span></span><br><span class="line"><span class="comment"> * subRule, because we're not spawning additional threads and returning</span></span><br><span class="line"><span class="comment"> * early.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(ILoadBalancer lb, Object key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> requestTime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">long</span> deadline = requestTime + maxRetryMillis;</span><br><span class="line"></span><br><span class="line">Server answer = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">answer = subRule.choose(key);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (((answer == <span class="keyword">null</span>) || (!answer.isAlive()))</span><br><span class="line">&amp;&amp; (System.currentTimeMillis() &lt; deadline)) &#123;</span><br><span class="line"></span><br><span class="line">InterruptTask task = <span class="keyword">new</span> InterruptTask(deadline</span><br><span class="line">- System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">answer = subRule.choose(key);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (((answer == <span class="keyword">null</span>) || (!answer.isAlive()))</span><br><span class="line">&amp;&amp; (System.currentTimeMillis() &lt; deadline)) &#123;</span><br><span class="line"><span class="comment">/* pause and retry hoping it's transient */</span></span><br><span class="line">Thread.yield();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task.cancel();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((answer == <span class="keyword">null</span>) || (!answer.isAlive())) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> choose(getLoadBalancer(), key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initWithNiwsConfig</span><span class="params">(IClientConfig clientConfig)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WeightedResponseTimeRule"><a href="#WeightedResponseTimeRule" class="headerlink" title="WeightedResponseTimeRule"></a>WeightedResponseTimeRule</h2><p>该策略是对<code>RoundRobinRule</code>的扩展，增加了根据实例的运行情况来计算权重，并根据权重来挑选实例，以达到更优的分配效果。</p><p>其主要构成如下：</p><h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><p><code>WeightedResponseTimeRule</code>策略在初始化的时候会通过<code>serverWeightTimer.schedule</code>启动一个定时任务，用来为每个服务实例计算权重，该任务默认30s执行一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//....</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_TIMER_INTERVAL = <span class="number">30</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverWeightTaskTimerInterval = DEFAULT_TIMER_INTERVAL;</span><br><span class="line"></span><br><span class="line"><span class="comment">//....</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLoadBalancer</span><span class="params">(ILoadBalancer lb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.setLoadBalancer(lb);</span><br><span class="line">    <span class="keyword">if</span> (lb <span class="keyword">instanceof</span> BaseLoadBalancer) &#123;</span><br><span class="line">        name = ((BaseLoadBalancer) lb).getName();</span><br><span class="line">    &#125;</span><br><span class="line">    initialize(lb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ILoadBalancer lb)</span> </span>&#123;        </span><br><span class="line">    <span class="keyword">if</span> (serverWeightTimer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        serverWeightTimer.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    serverWeightTimer = <span class="keyword">new</span> Timer(<span class="string">"NFLoadBalancer-serverWeightTimer-"</span></span><br><span class="line">            + name, <span class="keyword">true</span>);</span><br><span class="line">    serverWeightTimer.schedule(<span class="keyword">new</span> DynamicServerWeightTask(), <span class="number">0</span>,</span><br><span class="line">            serverWeightTaskTimerInterval);</span><br><span class="line">    <span class="comment">// do a initial run</span></span><br><span class="line">    ServerWeight sw = <span class="keyword">new</span> ServerWeight();</span><br><span class="line">    sw.maintainWeights();</span><br><span class="line"></span><br><span class="line">    Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            logger</span><br><span class="line">                    .info(<span class="string">"Stopping NFLoadBalancer-serverWeightTimer-"</span></span><br><span class="line">                            + name);</span><br><span class="line">            serverWeightTimer.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//....</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DynamicServerWeightTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServerWeight serverWeight = <span class="keyword">new</span> ServerWeight();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverWeight.maintainWeights();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">"Error running DynamicServerWeightTask for &#123;&#125;"</span>, name, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//....</span></span><br></pre></td></tr></table></figure><h3 id="权重计算"><a href="#权重计算" class="headerlink" title="权重计算"></a>权重计算</h3><p>在源码中我们可以找到用于存储权重的对象 <code>List<double> accumulatedWeights = new ArrayList<double>()</double></double></code>，该<code>List</code>中每个权重值所处的位置对应了负载均衡器维护的实例清单中所有实例所在清单中的位置。</p><p>维护实例权重的计算过程通过<code>maintainWeights</code>函数实现，其代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">maintainWeights</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ILoadBalancer lb = getLoadBalancer();</span><br><span class="line">    <span class="keyword">if</span> (lb == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!serverWeightAssignmentInProgress.compareAndSet(<span class="keyword">false</span>,  <span class="keyword">true</span>))  &#123;</span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        logger.info(<span class="string">"Weight adjusting job started"</span>);</span><br><span class="line">        AbstractLoadBalancer nlb = (AbstractLoadBalancer) lb;</span><br><span class="line">        LoadBalancerStats stats = nlb.getLoadBalancerStats();</span><br><span class="line">        <span class="keyword">if</span> (stats == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// no statistics, nothing to do</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> totalResponseTime = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// find maximal 95% response time</span></span><br><span class="line">        <span class="keyword">for</span> (Server server : nlb.getAllServers()) &#123;</span><br><span class="line">            <span class="comment">// this will automatically load the stats if not in cache</span></span><br><span class="line">            ServerStats ss = stats.getSingleServerStat(server);</span><br><span class="line">            totalResponseTime += ss.getResponseTimeAvg();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// weight for each server is (sum of responseTime of all servers - responseTime)</span></span><br><span class="line">        <span class="comment">// so that the longer the response time, the less the weight and the less likely to be chosen</span></span><br><span class="line">        Double weightSoFar = <span class="number">0.0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// create new list and hot swap the reference</span></span><br><span class="line">        List&lt;Double&gt; finalWeights = <span class="keyword">new</span> ArrayList&lt;Double&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Server server : nlb.getAllServers()) &#123;</span><br><span class="line">            ServerStats ss = stats.getSingleServerStat(server);</span><br><span class="line">            <span class="keyword">double</span> weight = totalResponseTime - ss.getResponseTimeAvg();</span><br><span class="line">            weightSoFar += weight;</span><br><span class="line">            finalWeights.add(weightSoFar);   </span><br><span class="line">        &#125;</span><br><span class="line">        setWeights(finalWeights);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(<span class="string">"Error calculating server weights"</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        serverWeightAssignmentInProgress.set(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数实现内容如下：</p><ul><li>根据<code>LoadBalancerStats</code>中记录的每个实例的统计信息，累加所有实例的平均响应时间，得到总平均响应时间<code>totalResponseTime</code>，该值会用于后续计算。</li><li>为负载均衡器中维护的实例清单逐个计算权重（从第一个开始），计算规则为<code>weightSoFar+totalResponseTime-实例平均响应时间</code>，其中<code>weightSoFar</code>初始化为0，并且每计算好一个权重需要累加到<code>weightSoFar</code>上供下次计算使用。</li></ul><p>如下例子：</p><p>假设4个实例A、B、C、D，它们平均响应时间为10、40、80、100，所以总响应时间为10+40+80+100=230，根据上面，可以计算出实例A、B、C、D的权重：</p><ul><li>A：230 - 10 = 220</li><li>B：220 + (230 - 40) = 410</li><li>C：410 + (230 - 80) = 560</li><li>D：560 + (230 - 100) = 690</li></ul><p>需要注意的是，这里的权重值只是表示了各实例权重区间上限，并非实例优先级。实例A、B、C、D的权重区间如下：</p><ul><li>A：[0,220]</li><li>B：(220,410]</li><li>C：(410,560]</li><li>D：(560,690)</li></ul><p>可以看到，每个区间的宽度就是：总平均响应时间-实例的平均响应时间，所有实例的平均响应时间越短、权重区间的宽度越大，宽度越大被选中的概率就越高。</p><p>我们再来看下区间边界的开闭是如何确定的。</p><h3 id="实例选择"><a href="#实例选择" class="headerlink" title="实例选择"></a>实例选择</h3><p>我们来看下该策略的实例选择算法相关代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(ILoadBalancer lb, Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lb == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Server server = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// get hold of the current reference in case it is changed from the other thread</span></span><br><span class="line">        List&lt;Double&gt; currentWeights = accumulatedWeights;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Server&gt; allList = lb.getAllServers();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> serverCount = allList.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (serverCount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> serverIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// last one in the list is the sum of all weights</span></span><br><span class="line">        <span class="keyword">double</span> maxTotalWeight = currentWeights.size() == <span class="number">0</span> ? <span class="number">0</span> : currentWeights.get(currentWeights.size() - <span class="number">1</span>); </span><br><span class="line">        <span class="comment">// No server has been hit yet and total weight is not initialized</span></span><br><span class="line">        <span class="comment">// fallback to use round robin</span></span><br><span class="line">        <span class="keyword">if</span> (maxTotalWeight &lt; <span class="number">0.001</span>d || serverCount != currentWeights.size()) &#123;</span><br><span class="line">            server =  <span class="keyword">super</span>.choose(getLoadBalancer(), key);</span><br><span class="line">            <span class="keyword">if</span>(server == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> server;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// generate a random weight between 0 (inclusive) to maxTotalWeight (exclusive)</span></span><br><span class="line">            <span class="keyword">double</span> randomWeight = random.nextDouble() * maxTotalWeight;</span><br><span class="line">            <span class="comment">// pick the server index based on the randomIndex</span></span><br><span class="line">            <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (Double d : currentWeights) &#123;</span><br><span class="line">                <span class="keyword">if</span> (d &gt;= randomWeight) &#123;</span><br><span class="line">                    serverIndex = n;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    n++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            server = allList.get(serverIndex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/* Transient. */</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (server.isAlive()) &#123;</span><br><span class="line">            <span class="keyword">return</span> (server);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Next.</span></span><br><span class="line">        server = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> server;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其代码逻辑主要如下：</p><ol><li>生成一个 [0,最大权重值) 区间内的随机数。</li><li>遍历权重列表，比较权重值与随机数的大小，如果权重值大于等于随机数，就拿当前权重列表的索引值去服务实例列表中获取具体的实例。因此每个权重区间为 (x,y] 的形式，由于随机数的最小值可以为0，所以第一个实例的下限是闭区间，随机数最大值取不到权重最大值，所以最后一个实例上限是开区间。</li></ol><p>按照上面的例子，如果随机数为230，则该值位于第二区间，所以此时就会选择实例B进行请求。</p><h2 id="ClientConfigEnabledRoundRobinRule"><a href="#ClientConfigEnabledRoundRobinRule" class="headerlink" title="ClientConfigEnabledRoundRobinRule"></a>ClientConfigEnabledRoundRobinRule</h2><p>该策略较为特殊，我们一般不直接使用它。因为它本身没有实现任何特殊的处理逻辑，如代码所示，在它内部定义了一个<code>RoundRobinRule</code>策略，而<code>choose</code>函数的实现也正是使用了<code>RoundRobinRule</code>的线下轮询机制。</p><p>虽然我们不会直接使用该策略，但是通过继承该策略，默认的<code>choose</code>就实现了线性轮询机制，在子类中做一些高级策略时通常可能存在一些无法实施的情况，那么就可以使用父类的实现作为备选。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientConfigEnabledRoundRobinRule</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalancerRule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    RoundRobinRule roundRobinRule = <span class="keyword">new</span> RoundRobinRule();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initWithNiwsConfig</span><span class="params">(IClientConfig clientConfig)</span> </span>&#123;</span><br><span class="line">        roundRobinRule = <span class="keyword">new</span> RoundRobinRule();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLoadBalancer</span><span class="params">(ILoadBalancer lb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.setLoadBalancer(lb);</span><br><span class="line">    roundRobinRule.setLoadBalancer(lb);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (roundRobinRule != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> roundRobinRule.choose(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"This class has not been initialized with the RoundRobinRule class"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BestAvailableRule"><a href="#BestAvailableRule" class="headerlink" title="BestAvailableRule"></a>BestAvailableRule</h2><p>该策略继承自<code>ClientConfigEnabledRoundRobinRule</code>，同时在实现中注入了负载均衡器统计对象<code>LoadBalancerStats</code>，算法通过利用统计对象中保存的实例信息来选择满足要求的实例。</p><p>通过代码我们可以看到，它通过遍历负载均衡器中维护的所有实例，会过滤掉故障实例，并找出并发请求数最小的一个，所以该策略的特性是可以选出最空闲的实例。</p><p>当<code>LoadBalancerStats</code>对象为空时，会使用父类的<code>RoundRobinRule</code>策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BestAvailableRule</span> <span class="keyword">extends</span> <span class="title">ClientConfigEnabledRoundRobinRule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LoadBalancerStats loadBalancerStats;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (loadBalancerStats == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.choose(key);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Server&gt; serverList = getLoadBalancer().getAllServers();</span><br><span class="line">        <span class="keyword">int</span> minimalConcurrentConnections = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">        Server chosen = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Server server: serverList) &#123;</span><br><span class="line">            ServerStats serverStats = loadBalancerStats.getSingleServerStat(server);</span><br><span class="line">            <span class="keyword">if</span> (!serverStats.isCircuitBreakerTripped(currentTime)) &#123;</span><br><span class="line">                <span class="keyword">int</span> concurrentConnections = serverStats.getActiveRequestsCount(currentTime);</span><br><span class="line">                <span class="keyword">if</span> (concurrentConnections &lt; minimalConcurrentConnections) &#123;</span><br><span class="line">                    minimalConcurrentConnections = concurrentConnections;</span><br><span class="line">                    chosen = server;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (chosen == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.choose(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> chosen;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLoadBalancer</span><span class="params">(ILoadBalancer lb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setLoadBalancer(lb);</span><br><span class="line">        <span class="keyword">if</span> (lb <span class="keyword">instanceof</span> AbstractLoadBalancer) &#123;</span><br><span class="line">            loadBalancerStats = ((AbstractLoadBalancer) lb).getLoadBalancerStats();            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PredicateBasedRule"><a href="#PredicateBasedRule" class="headerlink" title="PredicateBasedRule"></a>PredicateBasedRule</h2><p>这是一个抽象策略，它也继承自<code>ClientConfigEnabledRoundRobinRule</code>，其基础逻辑如下：</p><p>先通过子类中实现的<code>Predicate</code>逻辑来过滤一部分服务实例，然后再以线性轮询的方式从过滤后的实例清单中选出一个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PredicateBasedRule</span> <span class="keyword">extends</span> <span class="title">ClientConfigEnabledRoundRobinRule</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AbstractServerPredicate <span class="title">getPredicate</span><span class="params">()</span></span>;</span><br><span class="line">        </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        ILoadBalancer lb = getLoadBalancer();</span><br><span class="line">        Optional&lt;Server&gt; server = getPredicate().chooseRoundRobinAfterFiltering(lb.getAllServers(), key);</span><br><span class="line">        <span class="keyword">if</span> (server.isPresent()) &#123;</span><br><span class="line">            <span class="keyword">return</span> server.get();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它是通过 Google Guava Collection 工具对集合进行过滤的接口<code>Predicate</code>来实现的。我们来看下<code>AbstractServerPredicate</code>的部分关键逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractServerPredicate</span> <span class="keyword">implements</span> <span class="title">Predicate</span>&lt;<span class="title">PredicateKey</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Optional&lt;Server&gt; <span class="title">chooseRoundRobinAfterFiltering</span><span class="params">(List&lt;Server&gt; servers)</span> </span>&#123;</span><br><span class="line">        List&lt;Server&gt; eligible = getEligibleServers(servers);</span><br><span class="line">        <span class="keyword">if</span> (eligible.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Optional.absent();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Optional.of(eligible.get(incrementAndGetModulo(eligible.size())));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Server&gt; <span class="title">getEligibleServers</span><span class="params">(List&lt;Server&gt; servers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getEligibleServers(servers, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Server&gt; <span class="title">getEligibleServers</span><span class="params">(List&lt;Server&gt; servers, Object loadBalancerKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (loadBalancerKey == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ImmutableList.copyOf(Iterables.filter(servers, <span class="keyword">this</span>.getServerOnlyPredicate()));            </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            List&lt;Server&gt; results = Lists.newArrayList();</span><br><span class="line">            <span class="keyword">for</span> (Server server: servers) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.apply(<span class="keyword">new</span> PredicateKey(loadBalancerKey, server))) &#123;</span><br><span class="line">                    results.add(server);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> results;            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个抽象策略只是提供一个实现过滤清单的模板，具体实现需要其子类去完成（实现<code>Predicate</code>接口的<code>apply</code>方法），过滤清单后得到符合条件的实例，轮询选择。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GwtCompatible</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(@Nullable T var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(@Nullable Object var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AvailabilityFilteringRule"><a href="#AvailabilityFilteringRule" class="headerlink" title="AvailabilityFilteringRule"></a>AvailabilityFilteringRule</h2><p>该策略继承自<code>PredicateBasedRule</code>，其过滤条件使用了<code>AvailabilityPredicate</code>。</p><p><code>AvailabilityPredicate</code>的关键代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AvailabilityPredicate</span> <span class="keyword">extends</span>  <span class="title">AbstractServerPredicate</span> </span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(@Nullable PredicateKey input)</span> </span>&#123;</span><br><span class="line">        LoadBalancerStats stats = getLBStats();</span><br><span class="line">        <span class="keyword">if</span> (stats == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> !shouldSkipServer(stats.getSingleServerStat(input.getServer()));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">shouldSkipServer</span><span class="params">(ServerStats stats)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">if</span> ((CIRCUIT_BREAKER_FILTERING.get() &amp;&amp; stats.isCircuitBreakerTripped()) </span><br><span class="line">                || stats.getActiveRequestsCount() &gt;= activeConnectionsLimit.get()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码，我们可以看到该策略的主要过滤逻辑：</p><ul><li>是否故障，即断路器是否生效已断开。</li><li>实例的并发请求数大于阈值，默认<code>Integer.MAX_VALUE</code>，该配置可通过参数<clientname>.<namespace>.ActiveConnectionsLimit 来修改。</namespace></clientname></li></ul><p>这两项只要满足一个就返回false，代表节点可能故障或者负载过高，不适用处理请求，会被过滤掉，都不满足返回true，表示该节点可被选择用于处理请求。</p><p>除了上面的过滤方法，该策略的<code>choose</code>函数也做了一些改进优化，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AvailabilityFilteringRule</span> <span class="keyword">extends</span> <span class="title">PredicateBasedRule</span> </span>&#123; </span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initWithNiwsConfig</span><span class="params">(IClientConfig clientConfig)</span> </span>&#123;</span><br><span class="line">    predicate = CompositePredicate.withPredicate(<span class="keyword">new</span> AvailabilityPredicate(<span class="keyword">this</span>, clientConfig))</span><br><span class="line">                .addFallbackPredicate(AbstractServerPredicate.alwaysTrue())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        Server server = roundRobinRule.choose(key);</span><br><span class="line">        <span class="keyword">while</span> (count++ &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (predicate.apply(<span class="keyword">new</span> PredicateKey(server))) &#123;</span><br><span class="line">                <span class="keyword">return</span> server;</span><br><span class="line">            &#125;</span><br><span class="line">            server = roundRobinRule.choose(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.choose(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>choose</code>函数的实现逻辑并不像父类那样，先遍历所有节点进行过滤，然后在过滤后的集合中选择实例。</p><p>而是先以线性的方式选择一个实例，接着用过滤条件判断该实例是否满足要求，满足直接使用该实例，不满足选择下一个实例，并进行检查，如此循环进行，如果这个过程重复了10次还是没有找到符合要求的实例，就采用父类的实现方案。</p><p>该策略通过线性抽样的方式直接尝试寻找可用且较空闲的实例来使用，优化了父类每次都要遍历所有实例的开销。</p><h2 id="ZoneAvoidanceRule"><a href="#ZoneAvoidanceRule" class="headerlink" title="ZoneAvoidanceRule"></a>ZoneAvoidanceRule</h2><p>该策略也是<code>PredicateBasedRule</code>的实现类。可以看到它使用了<code>CompositePredicate</code>来进行服务清单过滤。这是一个组合过滤条件，在其构造函数中，它以<code>ZoneAvoidancePredicate</code>为主过滤条件，<code>AvailabilityPredicate</code>为次过滤条件来进行过滤。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZoneAvoidanceRule</span> <span class="keyword">extends</span> <span class="title">PredicateBasedRule</span> </span>&#123;</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    <span class="keyword">private</span> CompositePredicate compositePredicate;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZoneAvoidanceRule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        ZoneAvoidancePredicate zonePredicate = <span class="keyword">new</span> ZoneAvoidancePredicate(<span class="keyword">this</span>);</span><br><span class="line">        AvailabilityPredicate availabilityPredicate = <span class="keyword">new</span> AvailabilityPredicate(<span class="keyword">this</span>);</span><br><span class="line">        compositePredicate = createCompositePredicate(zonePredicate, availabilityPredicate);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ZoneAvoidanceRule</code>在实现的时候并没有像<code>AvailabilityFilteringRule</code>那样重写<code>choose</code>函数来优化，所以它和父类一样，先过滤清单，再轮询选择。</p><p>过滤条件就是上面提到的两个组合条件，我们先来看下<code>CompositePredicate</code>的部分源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositePredicate</span> <span class="keyword">extends</span> <span class="title">AbstractServerPredicate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AbstractServerPredicate delegate;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> List&lt;AbstractServerPredicate&gt; fallbacks = Lists.newArrayList();</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minimalFilteredServers = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> minimalFilteredPercentage = <span class="number">0</span>;    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(@Nullable PredicateKey input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> delegate.apply(input);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> CompositePredicate toBuild;</span><br><span class="line">        </span><br><span class="line">        Builder(AbstractServerPredicate primaryPredicate) &#123;</span><br><span class="line">            toBuild = <span class="keyword">new</span> CompositePredicate();    </span><br><span class="line">            toBuild.delegate = primaryPredicate;                    </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Builder(AbstractServerPredicate ...primaryPredicates) &#123;</span><br><span class="line">            toBuild = <span class="keyword">new</span> CompositePredicate();</span><br><span class="line">            Predicate&lt;PredicateKey&gt; chain = Predicates.&lt;PredicateKey&gt;and(primaryPredicates);</span><br><span class="line">            toBuild.delegate =  AbstractServerPredicate.ofKeyPredicate(chain);                </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">addFallbackPredicate</span><span class="params">(AbstractServerPredicate fallback)</span> </span>&#123;</span><br><span class="line">            toBuild.fallbacks.add(fallback);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setFallbackThresholdAsMinimalFilteredNumberOfServers</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">            toBuild.minimalFilteredServers = number;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setFallbackThresholdAsMinimalFilteredPercentage</span><span class="params">(<span class="keyword">float</span> percent)</span> </span>&#123;</span><br><span class="line">            toBuild.minimalFilteredPercentage = percent;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> CompositePredicate <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> toBuild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Builder <span class="title">withPredicates</span><span class="params">(AbstractServerPredicate ...primaryPredicates)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Builder(primaryPredicates);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Builder <span class="title">withPredicate</span><span class="params">(AbstractServerPredicate primaryPredicate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Builder(primaryPredicate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the filtered servers from primary predicate, and if the number of the filtered servers</span></span><br><span class="line"><span class="comment">     * are not enough, trying the fallback predicates  </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Server&gt; <span class="title">getEligibleServers</span><span class="params">(List&lt;Server&gt; servers, Object loadBalancerKey)</span> </span>&#123;</span><br><span class="line">        List&lt;Server&gt; result = <span class="keyword">super</span>.getEligibleServers(servers, loadBalancerKey);</span><br><span class="line">        Iterator&lt;AbstractServerPredicate&gt; i = fallbacks.iterator();</span><br><span class="line">        <span class="keyword">while</span> (!(result.size() &gt;= minimalFilteredServers &amp;&amp; result.size() &gt; (<span class="keyword">int</span>) (servers.size() * minimalFilteredPercentage))</span><br><span class="line">                &amp;&amp; i.hasNext()) &#123;</span><br><span class="line">            AbstractServerPredicate predicate = i.next();</span><br><span class="line">            result = predicate.getEligibleServers(servers, loadBalancerKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面源码，可以看到<code>CompositePredicate</code>是可以支持多个过滤条件的，它们存储在<code>fallbacks</code>的List里。</p><p>我们指定传入的过滤条件参数顺序就是过滤条件的优先级，因为它们放入List后是有序的。</p><p>我们主要来看下<code>getEligibleServers</code>的逻辑：</p><ul><li>使用主过滤条件对所有实例过滤并返回过滤后的实例清单。</li><li>依次使用次过滤条件列表中的过滤条件对上面的过滤结果进行过滤。</li><li>每次过滤后（包括主过滤条件和次过滤条件），都需要判断下面两个条件，只要有一个不符合就不再进行过滤，将当前结果返回供线性轮询算法选择：<ul><li>过滤后的实例总数 &gt;= 最小过滤实例数（minimalFilteredServers，默认为1）.</li><li>过滤后的实例比例 &gt; 最小过滤百分比（minimalFilteredPercentage，默认为0）.</li></ul></li></ul><p>对于传入的两个过滤条件，<code>AvailabilityPredicate</code>我们上面有介绍，我们来看下<code>ZoneAvoidancePredicate</code>。</p><p>其主要逻辑部分如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZoneAvoidancePredicate</span> <span class="keyword">extends</span>  <span class="title">AbstractServerPredicate</span> </span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(@Nullable PredicateKey input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!ENABLED.get()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String serverZone = input.getServer().getZone();</span><br><span class="line">        <span class="keyword">if</span> (serverZone == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// there is no zone information from the server, we do not want to filter</span></span><br><span class="line">            <span class="comment">// out this server</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LoadBalancerStats lbStats = getLBStats();</span><br><span class="line">        <span class="keyword">if</span> (lbStats == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// no stats available, do not filter</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lbStats.getAvailableZones().size() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// only one zone is available, do not filter</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String, ZoneSnapshot&gt; zoneSnapshot = ZoneAvoidanceRule.createSnapshot(lbStats);</span><br><span class="line">        <span class="keyword">if</span> (!zoneSnapshot.keySet().contains(serverZone)) &#123;</span><br><span class="line">            <span class="comment">// The server zone is unknown to the load balancer, do not filter it out </span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        logger.debug(<span class="string">"Zone snapshots: &#123;&#125;"</span>, zoneSnapshot);</span><br><span class="line">        Set&lt;String&gt; availableZones = ZoneAvoidanceRule.getAvailableZones(zoneSnapshot, triggeringLoad.get(), triggeringBlackoutPercentage.get());</span><br><span class="line">        logger.debug(<span class="string">"Available zones: &#123;&#125;"</span>, availableZones);</span><br><span class="line">        <span class="keyword">if</span> (availableZones != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> availableZones.contains(input.getServer().getZone());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码逻辑：</p><ul><li><code>niws.loadbalancer.zoneAvoidanceRule.enabled</code> 配置参数是否开启，如果为false，该过滤条件直接返回true。</li><li>拿到实例的<code>Zone</code>，如果为空，该过滤条件直接返回true。</li><li>拿到实例的<code>LoadBalancerStats</code>，如果为空或者可用<code>Zone</code>数量小于等于1，该过滤条件直接返回true。</li><li>通过<code>ZoneAvoidanceRule.createSnapshot</code>函数拿到<code>Zone</code>映射，如果该映射里不包含该实例的<code>Zone</code>，该过滤条件直接返回true。</li><li>否则通过<code>ZoneAvoidanceRule.getAvailableZones</code>拿到可用<code>Zone</code>列表，如果列表不为空，返回是否包含该实例的<code>Zone</code>结果；如果为空，直接返回false。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是关于Spring Cloud Ribbon 负载均衡策略的全部内容，通过了解Ribbon的负载均衡策略，可以使我们更好的了解到Ribbon的一些特性，对Ribbon有更深入的了解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="SpringCloud" scheme="https://www.sakuratears.top/tags/SpringCloud/"/>
    
      <category term="Ribbon" scheme="https://www.sakuratears.top/tags/Ribbon/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud Ribbon 负载均衡器</title>
    <link href="https://www.sakuratears.top/blog/SpringCloud-Ribbon-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8.html"/>
    <id>https://www.sakuratears.top/blog/SpringCloud-Ribbon-负载均衡器.html</id>
    <published>2020-10-11T05:50:00.000Z</published>
    <updated>2020-10-18T13:28:26.265Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上篇文章我们介绍了Spring Cloud Ribbon中实现客户端负载均衡的一些基本脉络，了解了它的一些特点。</p><p>虽然Spring Cloud 中定义了 <code>LoadBalancerClient</code>作为负载均衡器的通用接口，并且针对Ribbon实现了<code>RibbonLoadBalancerClient</code>，但是它在具体实现客户端负载均衡时，是通过Ribbon的<code>ILoadBalancer</code>接口实现的。</p><p>我们这篇文章来看下<code>ILoadBalancer</code>接口的实现类，来了解它是如何实现客户端负载均衡的。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="AbstractLoadBalancer"><a href="#AbstractLoadBalancer" class="headerlink" title="AbstractLoadBalancer"></a>AbstractLoadBalancer</h2><p><code>AbstractLoadBalancer</code>是<code>ILoadBalancer</code>接口的抽象实现。该类中定义了一个关于服务实例的分组枚举类<code>ServerGroup</code>，包含三种不同的类型。</p><ul><li>ALL：所有服务实例。</li><li>STATUS_UP：正常服务的实例。</li><li>STATUS_NOT_UP：停止服务的实例。</li></ul><p>另外还实现一个<code>chooseServer()</code>函数，该函数通过调用接口的<code>chooseServer(Object key)</code>实现，其中参数<code>key</code>为<code>null</code>，表示在选择具体服务实例时忽略<code>key</code>的条件判断。</p><p>还定义了两个抽象函数：</p><ul><li>getServerList(ServerGroup serverGroup)：根据分组类型来获取不同的服务列表。</li><li>getLoadBalancerStats()：定义获取<code>LoadBalancerStats</code>对象的方法。</li></ul><p>PS：<code>LoadBalancerStats</code>对象用来存储负载均衡器中各个服务实例当前的属性和统计信息。这些信息可以帮助我们观察负载均衡器的运行情况，制定合适的负载均衡策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractLoadBalancer</span> <span class="keyword">implements</span> <span class="title">ILoadBalancer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> ServerGroup&#123;</span><br><span class="line">        ALL,</span><br><span class="line">        STATUS_UP,</span><br><span class="line">        STATUS_NOT_UP        </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Server <span class="title">chooseServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> chooseServer(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;Server&gt; <span class="title">getServerList</span><span class="params">(ServerGroup serverGroup)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> LoadBalancerStats <span class="title">getLoadBalancerStats</span><span class="params">()</span></span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BaseLoadBalancer"><a href="#BaseLoadBalancer" class="headerlink" title="BaseLoadBalancer"></a>BaseLoadBalancer</h2><p><code>BaseLoadBalancer</code>类是Ribbon负载均衡器的基础实现类，该类中定义了很多有关负载均衡器的基础内容。</p><ul><li><p>定义维护了两个存储服务实例Server对象列表。一个用于存储所有服务实例的清单，一个用于存储正常服务的清单。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Monitor</span>(name = PREFIX + <span class="string">"AllServerList"</span>, type = DataSourceType.INFORMATIONAL)</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> List&lt;Server&gt; allServerList = Collections</span><br><span class="line">        .synchronizedList(<span class="keyword">new</span> ArrayList&lt;Server&gt;());</span><br><span class="line"><span class="meta">@Monitor</span>(name = PREFIX + <span class="string">"UpServerList"</span>, type = DataSourceType.INFORMATIONAL)</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> List&lt;Server&gt; upServerList = Collections</span><br><span class="line">        .synchronizedList(<span class="keyword">new</span> ArrayList&lt;Server&gt;());</span><br></pre></td></tr></table></figure></li><li><p>定义了用来存储负载均衡服务器各服务实例属性和统计信息的<code>LoadBalancerStats</code>对象。</p></li><li>定义了检查服务实例是否正常的<code>IPing</code>对象，在<code>BaseLoadBalancer</code>中默认为<code>null</code>，需要在构造时注入它的具体实现。</li><li><p>定义了检查服务实例操作的执行策略对象<code>IPingStrategy</code>，在<code>BaseLoadBalancer</code>中默认使用了该类中定义的静态内部类<code>SerialPingStrategy</code>实现。</p><p>  根据源码，我们可以看到该策略采用线性遍历ping服务实例的方式实现检查。该策略在当<code>IPing</code>的实现速度并不理想，或者<code>Server</code>列表过大时，可能会影响系统性能，这时候需要通过实现<code>IPingStrategy</code>接口并重写<code>pingServers(IPing ping, Server[] servers)</code>函数去扩展ping的执行策略。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialPingStrategy</span> <span class="keyword">implements</span> <span class="title">IPingStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span>[] pingServers(IPing ping, Server[] servers) &#123;</span><br><span class="line">        <span class="keyword">int</span> numCandidates = servers.length;</span><br><span class="line">        <span class="keyword">boolean</span>[] results = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCandidates];</span><br><span class="line"></span><br><span class="line">        logger.debug(<span class="string">"LoadBalancer:  PingTask executing [&#123;&#125;] servers configured"</span>, numCandidates);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCandidates; i++) &#123;</span><br><span class="line">            results[i] = <span class="keyword">false</span>; <span class="comment">/* Default answer is DEAD. */</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (ping != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    results[i] = ping.isAlive(servers[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(<span class="string">"Exception while pinging Server: '&#123;&#125;'"</span>, servers[i], e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  比如我们想改成并行处理，则需要写自己的并行ping策略，如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParallelPingStrategy</span> <span class="keyword">implements</span> <span class="title">IPingStrategy</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory</span><br><span class="line">        .getLogger(ParallelPingStrategy.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span>[] pingServers(IPing ping, Server[] servers) &#123;</span><br><span class="line">        <span class="keyword">int</span> numCandidates = servers.length;</span><br><span class="line">        <span class="keyword">boolean</span>[] results = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCandidates];</span><br><span class="line"></span><br><span class="line">        logger.debug(<span class="string">"LoadBalancer:  PingTask executing [&#123;&#125;] servers configured"</span>, numCandidates);</span><br><span class="line"></span><br><span class="line">        List&lt;Future&lt;Boolean&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        ExecutorService ex = Executors.newFixedThreadPool(numCandidates+<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Server server : servers) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ping !=<span class="keyword">null</span>)&#123;</span><br><span class="line">                futures.add(ex.submit(()-&gt;ping.isAlive(server)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCandidates; i++) &#123;</span><br><span class="line">            results[i] = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(!futures.isEmpty())&#123;</span><br><span class="line">                    results[i] = futures.get(i).get();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                logger.error(<span class="string">"Exception while pinging Server: '&#123;&#125;'"</span>, servers[i], e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  然后添加到配置即可。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomLoadBalancer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">ILoadBalancer <span class="title">loadBalancer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BaseLoadBalancer(<span class="keyword">new</span> NIWSDiscoveryPing(),<span class="keyword">new</span> RandomRule(),<span class="keyword">new</span> ParallelPingStrategy());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@RibbonClient</span>(name = <span class="string">"sakura"</span>,configuration = CustomLoadBalancer.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SakuraConsumerApplication</span> </span>&#123;</span><br><span class="line">    <span class="comment">//.....略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义了负载均衡的处理规则<code>IRule</code>对象，从<code>BaseLoadBalancer</code>中的<code>chooseServer(Object key)</code>源码，我们可以知道，负载均衡器实际将服务实例选择任务委托给了<code>IRule</code>实例中的<code>choose</code>函数来实现，而这里默认初始化了<code>RoundRobinRule</code>作为<code>IRule</code>的实现对象。<code>RoundRobinRule</code>实现的是最基本的线性负载均衡规则。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">chooseServer</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (counter == <span class="keyword">null</span>) &#123;</span><br><span class="line">        counter = createCounter();</span><br><span class="line">    &#125;</span><br><span class="line">    counter.increment();</span><br><span class="line">    <span class="keyword">if</span> (rule == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> rule.choose(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.warn(<span class="string">"LoadBalancer [&#123;&#125;]:  Error choosing server for key &#123;&#125;"</span>, name, key, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动ping任务：在<code>BaseLoadBalancer</code>的默认构造函数中，会直接启动一个用于定时检查Server是否健康的任务。该任务默认的执行间隔时间为10s。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BaseLoadBalancer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = DEFAULT_NAME;</span><br><span class="line">    <span class="keyword">this</span>.ping = <span class="keyword">null</span>;</span><br><span class="line">    setRule(DEFAULT_RULE);</span><br><span class="line">    setupPingTask();</span><br><span class="line">    lbStats = <span class="keyword">new</span> LoadBalancerStats(DEFAULT_NAME);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setupPingTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (canSkipPing()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lbTimer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        lbTimer.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    lbTimer = <span class="keyword">new</span> ShutdownEnabledTimer(<span class="string">"NFLoadBalancer-PingTimer-"</span> + name,</span><br><span class="line">            <span class="keyword">true</span>);</span><br><span class="line">    lbTimer.schedule(<span class="keyword">new</span> PingTask(), <span class="number">0</span>, pingIntervalSeconds * <span class="number">1000</span>);</span><br><span class="line">    forceQuickPing();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现了<code>ILoadBalancer</code>接口定义的负载均衡器应具备以下一系列基本操作。</p><ul><li><p>addServers(List<server> newServers)：向负载均衡器中添加新的服务实例列表。</server></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addServers</span><span class="params">(List&lt;Server&gt; newServers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (newServers != <span class="keyword">null</span> &amp;&amp; newServers.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ArrayList&lt;Server&gt; newList = <span class="keyword">new</span> ArrayList&lt;Server&gt;();</span><br><span class="line">            newList.addAll(allServerList);</span><br><span class="line">            newList.addAll(newServers);</span><br><span class="line">            setServersList(newList);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">"LoadBalancer [&#123;&#125;]: Exception while adding Servers"</span>, name, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>chooseServer(Object key)：挑选一个具体服务实例。代码见上面。</p></li><li><p>markServerDown(Server server)：标记某个服务实例暂停服务。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">markServerDown</span><span class="params">(Server server)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (server == <span class="keyword">null</span> || !server.isAlive()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logger.error(<span class="string">"LoadBalancer [&#123;&#125;]:  markServerDown called on [&#123;&#125;]"</span>, name, server.getId());</span><br><span class="line">    server.setAlive(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// forceQuickPing();</span></span><br><span class="line"></span><br><span class="line">    notifyServerStatusChangeListener(singleton(server));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>getReachableServers()：获取可用的服务实例列表。由于<code>BaseLoadBalancer</code>中单独维护了一个正常服务的实例清单，所以直接返回即可。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Server&gt; <span class="title">getReachableServers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableList(upServerList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>getAllServers()：获取所有的服务实例列表。同样由于<code>BaseLoadBalancer</code>中单独维护了一个所有服务的实例清单，所以直接返回即可。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Server&gt; <span class="title">getAllServers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableList(allServerList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="DynamicServerListLoadBalancer"><a href="#DynamicServerListLoadBalancer" class="headerlink" title="DynamicServerListLoadBalancer"></a>DynamicServerListLoadBalancer</h2><p><code>DynamicServerListLoadBalancer</code>类继承于<code>BaseLoadBalancer</code>类，它是对基础负载均衡器的扩展。在该负载均衡器中，实现了服务实例清单在运行期的动态更新能力；同时它还具备了对服务实例清单的过滤功能。</p><p>我们来看下相比<code>BaseLoadBalancer</code>，该类新增了哪些内容。</p><ul><li><p>ServerList</p><p>  在类成员定义中，我们可以发现新增了一个关于服务列表的操作对象<code>ServerList<t> serverListImpl</t></code>，泛型 T 根据<code>DynamicServerListLoadBalancer<t extends="" server=""></t></code>可知它是一个<code>Server</code>的子类。</p><p>  <code>ServerList</code>接口定义如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServerList</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Server</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getInitialListOfServers</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getUpdatedListOfServers</span><span class="params">()</span></span>;   </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>getInitialListOfServers()：获取初始化的服务实例清单。</li><li><p>getUpdatedListOfServers()：获取更新的服务实例清单。</p><p><code>DynamicServerListLoadBalancer</code>里默认是使用哪个<code>ServerList</code>的实现类呢？</p><p>在<code>EurekaRibbonClientConfiguration</code>类中，我们可以找到如下创建<code>ServerList</code>实例的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="keyword">public</span> ServerList&lt;?&gt; ribbonServerList(IClientConfig config, Provider&lt;EurekaClient&gt; eurekaClientProvider) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(ServerList.class, serviceId)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(ServerList.class, config, serviceId);</span><br><span class="line">&#125;</span><br><span class="line">DiscoveryEnabledNIWSServerList discoveryServerList = <span class="keyword">new</span> DiscoveryEnabledNIWSServerList(</span><br><span class="line">config, eurekaClientProvider);</span><br><span class="line">DomainExtractingServerList serverList = <span class="keyword">new</span> DomainExtractingServerList(</span><br><span class="line">discoveryServerList, config, <span class="keyword">this</span>.approximateZoneFromHostname);</span><br><span class="line"><span class="keyword">return</span> serverList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们看到它构造函数传入了<code>DiscoveryEnabledNIWSServerList</code>，我们来看下代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DomainExtractingServerList</span> <span class="keyword">implements</span> <span class="title">ServerList</span>&lt;<span class="title">DiscoveryEnabledServer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServerList&lt;DiscoveryEnabledServer&gt; list;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RibbonProperties ribbon;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> approximateZoneFromHostname;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DomainExtractingServerList</span><span class="params">(ServerList&lt;DiscoveryEnabledServer&gt; list,</span></span></span><br><span class="line"><span class="function"><span class="params">            IClientConfig clientConfig, <span class="keyword">boolean</span> approximateZoneFromHostname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">        <span class="keyword">this</span>.ribbon = RibbonProperties.from(clientConfig);</span><br><span class="line">        <span class="keyword">this</span>.approximateZoneFromHostname = approximateZoneFromHostname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;DiscoveryEnabledServer&gt; <span class="title">getInitialListOfServers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;DiscoveryEnabledServer&gt; servers = setZones(<span class="keyword">this</span>.list</span><br><span class="line">                .getInitialListOfServers());</span><br><span class="line">        <span class="keyword">return</span> servers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;DiscoveryEnabledServer&gt; <span class="title">getUpdatedListOfServers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;DiscoveryEnabledServer&gt; servers = setZones(<span class="keyword">this</span>.list</span><br><span class="line">                .getUpdatedListOfServers());</span><br><span class="line">        <span class="keyword">return</span> servers;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到调用了<code>DiscoveryEnabledNIWSServerList</code>的<code>getInitialListOfServers()</code>方法和<code>getUpdatedListOfServers()</code>方法。这两个方法通过<code>EurekaClient</code>从服务中心中获取到具体的服务实例列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;DiscoveryEnabledServer&gt; <span class="title">getInitialListOfServers</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obtainServersViaDiscovery();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;DiscoveryEnabledServer&gt; <span class="title">getUpdatedListOfServers</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obtainServersViaDiscovery();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;DiscoveryEnabledServer&gt; <span class="title">obtainServersViaDiscovery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;DiscoveryEnabledServer&gt; serverList = <span class="keyword">new</span> ArrayList&lt;DiscoveryEnabledServer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eurekaClientProvider == <span class="keyword">null</span> || eurekaClientProvider.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        logger.warn(<span class="string">"EurekaClient has not been initialized yet, returning an empty list"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;DiscoveryEnabledServer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EurekaClient eurekaClient = eurekaClientProvider.get();</span><br><span class="line">    <span class="keyword">if</span> (vipAddresses!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (String vipAddress : vipAddresses.split(<span class="string">","</span>)) &#123;</span><br><span class="line">            <span class="comment">// if targetRegion is null, it will be interpreted as the same region of client</span></span><br><span class="line">            List&lt;InstanceInfo&gt; listOfInstanceInfo = eurekaClient.getInstancesByVipAddress(vipAddress, isSecure, targetRegion);</span><br><span class="line">            <span class="keyword">for</span> (InstanceInfo ii : listOfInstanceInfo) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ii.getStatus().equals(InstanceStatus.UP)) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(shouldUseOverridePort)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(logger.isDebugEnabled())&#123;</span><br><span class="line">                            logger.debug(<span class="string">"Overriding port on client name: "</span> + clientName + <span class="string">" to "</span> + overridePort);</span><br><span class="line">                        &#125;</span><br><span class="line">                        InstanceInfo copy = <span class="keyword">new</span> InstanceInfo(ii);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span>(isSecure)&#123;</span><br><span class="line">                            ii = <span class="keyword">new</span> InstanceInfo.Builder(copy).setSecurePort(overridePort).build();</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            ii = <span class="keyword">new</span> InstanceInfo.Builder(copy).setPort(overridePort).build();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    DiscoveryEnabledServer des = createServer(ii, isSecure, shouldUseIpAddr);</span><br><span class="line">                    serverList.add(des);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (serverList.size()&gt;<span class="number">0</span> &amp;&amp; prioritizeVipAddressBasedServers)&#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// if the current vipAddress has servers, we dont use subsequent vipAddress based servers</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> serverList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>ServerListUpdater</p><p>  通过上面内容，我们已经知道Ribbon可以从Eureka Server中获取服务实例清单。那么它又是如何触发向Eureka Server去获取服务清单以及如何在获取到服务实例清单后更新本地的服务实例清单的呢？</p><p>  这就要涉及到<code>ServerListUpdater</code>的内容了，我们来看一下。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> ServerListUpdater.UpdateAction updateAction = <span class="keyword">new</span> ServerListUpdater.UpdateAction() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        updateListOfServers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  我们来看下<code>ServerListUpdater</code>接口内容。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServerListUpdater</span> </span>&#123;</span><br><span class="line">    <span class="comment">//服务更新接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UpdateAction</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">doUpdate</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动服务更新</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(UpdateAction updateAction)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//停止服务更新器</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取最近的更新时间戳</span></span><br><span class="line">    <span class="function">String <span class="title">getLastUpdate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取上一次更新到现在的时间间隔，单位毫秒</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getDurationSinceLastUpdateMs</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取错过的更新周期数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumberMissedCycles</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取核心线程数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCoreThreads</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <code>ServerListUpdater</code>的实现类有两个，如下：</p><ul><li><p>PollingServerListUpdater：动态服务列表更新的默认策略，使用的是定时任务的方式进行服务列表的更新。</p></li><li><p>EurekaNotificationServerListUpdater：利用Eureka事件监听器来驱动服务列表的更新操作。</p></li></ul></li><li><p>ServerListFilter</p><p>  我们回到<code>UpdateAction</code>，看一下<code>doUpdate</code>的具体调用方法，可以看到它调用了<code>updateListOfServers</code>方法。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateListOfServers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;T&gt; servers = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">    <span class="keyword">if</span> (serverListImpl != <span class="keyword">null</span>) &#123;</span><br><span class="line">        servers = serverListImpl.getUpdatedListOfServers();</span><br><span class="line">        LOGGER.debug(<span class="string">"List of Servers for &#123;&#125; obtained from Discovery client: &#123;&#125;"</span>,</span><br><span class="line">                getIdentifier(), servers);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (filter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            servers = filter.getFilteredListOfServers(servers);</span><br><span class="line">            LOGGER.debug(<span class="string">"Filtered List of Servers for &#123;&#125; obtained from Discovery client: &#123;&#125;"</span>,</span><br><span class="line">                    getIdentifier(), servers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    updateAllServerList(servers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  可以看到用到了前面ServerList的<code>getUpdatedListOfServers</code>方法。用于从Eureka Server中获取服务可用实例列表。</p><p>  同时引入了一个新对象 filter，它是通过<code>ServerListFilter</code>进行定义的。</p><p>  <code>ServerListFilter</code>接口只定义了一个方法，<code>getFilteredListOfServers(List<t> servers)</t></code>，用于实现对服务实例列表按照过滤规则进行过滤。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServerListFilter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Server</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getFilteredListOfServers</span><span class="params">(List&lt;T&gt; servers)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  它有四个具体实现及一个抽象实现。</p><ul><li><p>AbstractServerListFilter</p><p>  抽象过滤器，这里定一个一个重要依据对象<code>LoadBalancerStats</code>，用来存储关于负载均衡器的一些属性和统计信息。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractServerListFilter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Server</span>&gt; <span class="keyword">implements</span> <span class="title">ServerListFilter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> LoadBalancerStats stats;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLoadBalancerStats</span><span class="params">(LoadBalancerStats stats)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stats = stats;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> LoadBalancerStats <span class="title">getLoadBalancerStats</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stats;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ZoneAffinityServerListFilter  </p><p>  区域感知过滤器，该过滤器会基于“区域感知”方式实现服务过滤。也就是说它会根据提供服务的实例所处的区域（Zone）与消费者自身所处区域（Zone）进行比较，过滤掉不是同处于一个区域的实例。关键代码：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getFilteredListOfServers</span><span class="params">(List&lt;T&gt; servers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (zone != <span class="keyword">null</span> &amp;&amp; (zoneAffinity || zoneExclusive) &amp;&amp; servers !=<span class="keyword">null</span> &amp;&amp; servers.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        List&lt;T&gt; filteredServers = Lists.newArrayList(Iterables.filter(</span><br><span class="line">                servers, <span class="keyword">this</span>.zoneAffinityPredicate.getServerOnlyPredicate()));</span><br><span class="line">        <span class="keyword">if</span> (shouldEnableZoneAffinity(filteredServers)) &#123;</span><br><span class="line">            <span class="keyword">return</span> filteredServers;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (zoneAffinity) &#123;</span><br><span class="line">            overrideCounter.increment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> servers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>DefaultNIWSServerListFilter</p><p>  该过滤器完全继承自 <code>ZoneAffinityServerListFilter</code>，是默认的NIWS（Netflix Internal Web Service）过滤器。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultNIWSServerListFilter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Server</span>&gt; <span class="keyword">extends</span> <span class="title">ZoneAffinityServerListFilter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ServerListSubsetFilter</p><p>  该过滤器也继承自<code>ZoneAffinityServerListFilter</code>，它非常适合用于拥有大规模服务器集群的系统。因为它可以产生一个“区域感知”结果的子集列表，同时它还能够通过比较服务实例的通信失败数量和并发连接数来判定该服务是否健康来选择性地从服务实例列表中剔除那些相对不够健康的实例。该过滤器实现主要有3步。</p><ol><li>获取“区域感知”的过滤结果，作为候选的服务实例清单。</li><li><p>从当前消费者维护的服务实例子集中剔除那些相对不够健康的实例（同时也将这些实例从候选清单中剔除，防止第三步的时候又被选入），不够健康的标准如下。</p><p> a. 服务实例的并发连接数超过客户端配置的值，默认0，配置参数为<clientname>.<namespace>.ServerListSubsetFilter.eliminationConnectionThresold。</namespace></clientname></p><p> b. 服务实例的失败数超过客户端配置的值，默认0，配置参数为<clientname>.<namespace>.ServerListSubsetFilter.eliminationFailureThresold。</namespace></clientname></p><p> c. 如果按符合上面任一规则的服务实例剔除后，剔除比例小于客户端默认配置的百分比，默认为0.1（10%），配置参数为<clientname>.<namespace>.ServerListSubsetFilter.forceEliminationPercent，那么就先对剩下的实例列表进行健康排序，再从最不健康的实例进行剔除，直到达到配置剔除的百分比。</namespace></clientname></p></li><li><p>在完成剔除后，清单至少已经少了10%（默认值）的服务实例，最后通过随机的方式从候选清单中选出一批实例加入到清单中，以保持服务实例子集与原来的数量一致，默认实例子集数量为20，配置参数<clientname>.<namespace>.ServerListSubsetFilter.size。</namespace></clientname></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getFilteredListOfServers</span><span class="params">(List&lt;T&gt; servers)</span> </span>&#123;</span><br><span class="line">    List&lt;T&gt; zoneAffinityFiltered = <span class="keyword">super</span>.getFilteredListOfServers(servers);</span><br><span class="line">    Set&lt;T&gt; candidates = Sets.newHashSet(zoneAffinityFiltered);</span><br><span class="line">    Set&lt;T&gt; newSubSet = Sets.newHashSet(currentSubset);</span><br><span class="line">    LoadBalancerStats lbStats = getLoadBalancerStats();</span><br><span class="line">    <span class="keyword">for</span> (T server: currentSubset) &#123;</span><br><span class="line">        <span class="comment">// this server is either down or out of service</span></span><br><span class="line">        <span class="keyword">if</span> (!candidates.contains(server)) &#123;</span><br><span class="line">            newSubSet.remove(server);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ServerStats stats = lbStats.getSingleServerStat(server);</span><br><span class="line">            <span class="comment">// remove the servers that do not meet health criteria</span></span><br><span class="line">            <span class="keyword">if</span> (stats.getActiveRequestsCount() &gt; eliminationConnectionCountThreshold.get()</span><br><span class="line">                    || stats.getFailureCount() &gt; eliminationFailureCountThreshold.get()) &#123;</span><br><span class="line">                newSubSet.remove(server);</span><br><span class="line">                <span class="comment">// also remove from the general pool to avoid selecting them again</span></span><br><span class="line">                candidates.remove(server);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> targetedListSize = sizeProp.get();</span><br><span class="line">    <span class="keyword">int</span> numEliminated = currentSubset.size() - newSubSet.size();</span><br><span class="line">    <span class="keyword">int</span> minElimination = (<span class="keyword">int</span>) (targetedListSize * eliminationPercent.get());</span><br><span class="line">    <span class="keyword">int</span> numToForceEliminate = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (targetedListSize &lt; newSubSet.size()) &#123;</span><br><span class="line">        <span class="comment">// size is shrinking</span></span><br><span class="line">        numToForceEliminate = newSubSet.size() - targetedListSize;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (minElimination &gt; numEliminated) &#123;</span><br><span class="line">        numToForceEliminate = minElimination - numEliminated; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (numToForceEliminate &gt; newSubSet.size()) &#123;</span><br><span class="line">        numToForceEliminate = newSubSet.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (numToForceEliminate &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        List&lt;T&gt; sortedSubSet = Lists.newArrayList(newSubSet);           </span><br><span class="line">        Collections.sort(sortedSubSet, <span class="keyword">this</span>);</span><br><span class="line">        List&lt;T&gt; forceEliminated = sortedSubSet.subList(<span class="number">0</span>, numToForceEliminate);</span><br><span class="line">        newSubSet.removeAll(forceEliminated);</span><br><span class="line">        candidates.removeAll(forceEliminated);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// after forced elimination or elimination of unhealthy instances,</span></span><br><span class="line">    <span class="comment">// the size of the set may be less than the targeted size,</span></span><br><span class="line">    <span class="comment">// then we just randomly add servers from the big pool</span></span><br><span class="line">    <span class="keyword">if</span> (newSubSet.size() &lt; targetedListSize) &#123;</span><br><span class="line">        <span class="keyword">int</span> numToChoose = targetedListSize - newSubSet.size();</span><br><span class="line">        candidates.removeAll(newSubSet);</span><br><span class="line">        <span class="keyword">if</span> (numToChoose &gt; candidates.size()) &#123;</span><br><span class="line">            <span class="comment">// Not enough healthy instances to choose, fallback to use the</span></span><br><span class="line">            <span class="comment">// total server pool</span></span><br><span class="line">            candidates = Sets.newHashSet(zoneAffinityFiltered);</span><br><span class="line">            candidates.removeAll(newSubSet);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;T&gt; chosen = randomChoose(Lists.newArrayList(candidates), numToChoose);</span><br><span class="line">        <span class="keyword">for</span> (T server: chosen) &#123;</span><br><span class="line">            newSubSet.add(server);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    currentSubset = newSubSet;       </span><br><span class="line">    <span class="keyword">return</span> Lists.newArrayList(newSubSet);            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>ZonePreferenceServerListFilter</p><p>  Spring Cloud整合是新增的过滤器。若使用Spring Cloud整合Eureka 和 Ribbon时会默认使用该过滤器。它实现通过配置或者Eureka实例元数据的所属区域（Zone）来过滤出同区域的服务实例。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Server&gt; <span class="title">getFilteredListOfServers</span><span class="params">(List&lt;Server&gt; servers)</span> </span>&#123;</span><br><span class="line">    List&lt;Server&gt; output = <span class="keyword">super</span>.getFilteredListOfServers(servers);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.zone != <span class="keyword">null</span> &amp;&amp; output.size() == servers.size()) &#123;</span><br><span class="line">        List&lt;Server&gt; local = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Server server : output) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.zone.equalsIgnoreCase(server.getZone())) &#123;</span><br><span class="line">                local.add(server);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!local.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> local;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="ZoneAwareLoadBalancer"><a href="#ZoneAwareLoadBalancer" class="headerlink" title="ZoneAwareLoadBalancer"></a>ZoneAwareLoadBalancer</h2><p><code>ZoneAwareLoadBalancer</code>负载均衡器是对<code>DynamicServerListLoadBalancer</code>的扩展。在<code>DynamicServerListLoadBalancer</code>中，并没有重写选择具体服务实例的<code>chooseServer</code>函数，所以它依然会采用<code>BaseLoadBalancer</code>中实现的算法。使用<code>RoundRobinRule</code>规则，以线性轮询的方式来选择调用的服务实例，该算法并没有区域（Zone）的概念。这样就会周期性的产生跨区域访问情况，由于跨区域有更高的延迟，这些区域实例主要以防止区域性故障来实现高可用的目的，而不能作为常规的访问性实例，所以在多区域部署的情况下会有一定的问题。</p><p>而<code>ZoneAwareLoadBalancer</code>则可以避免这样的问题，我们来看下它是如何实现的。</p><p>我们可以看到它并没有重写<code>setServersList</code>，而是重写了<code>setServerListForZones</code>，我们先来看下<code>DynamicServerListLoadBalancer</code>的部分代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setServersList</span><span class="params">(List lsrv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.setServersList(lsrv);</span><br><span class="line">    List&lt;T&gt; serverList = (List&lt;T&gt;) lsrv;</span><br><span class="line">    Map&lt;String, List&lt;Server&gt;&gt; serversInZones = <span class="keyword">new</span> HashMap&lt;String, List&lt;Server&gt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Server server : serverList) &#123;</span><br><span class="line">        <span class="comment">// make sure ServerStats is created to avoid creating them on hot</span></span><br><span class="line">        <span class="comment">// path</span></span><br><span class="line">        getLoadBalancerStats().getSingleServerStat(server);</span><br><span class="line">        String zone = server.getZone();</span><br><span class="line">        <span class="keyword">if</span> (zone != <span class="keyword">null</span>) &#123;</span><br><span class="line">            zone = zone.toLowerCase();</span><br><span class="line">            List&lt;Server&gt; servers = serversInZones.get(zone);</span><br><span class="line">            <span class="keyword">if</span> (servers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                servers = <span class="keyword">new</span> ArrayList&lt;Server&gt;();</span><br><span class="line">                serversInZones.put(zone, servers);</span><br><span class="line">            &#125;</span><br><span class="line">            servers.add(server);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    setServerListForZones(serversInZones);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setServerListForZones</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Map&lt;String, List&lt;Server&gt;&gt; zoneServersMap)</span> </span>&#123;</span><br><span class="line">    LOGGER.debug(<span class="string">"Setting server list for zones: &#123;&#125;"</span>, zoneServersMap);</span><br><span class="line">    getLoadBalancerStats().updateZoneServerMapping(zoneServersMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>setServersList</code>在最后调用了<code>setServerListForZones</code>方法，而<code>ZoneAwareLoadBalancer</code>重写了<code>setServerListForZones</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setServerListForZones</span><span class="params">(Map&lt;String, List&lt;Server&gt;&gt; zoneServersMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.setServerListForZones(zoneServersMap);</span><br><span class="line">    <span class="keyword">if</span> (balancers == <span class="keyword">null</span>) &#123;</span><br><span class="line">        balancers = <span class="keyword">new</span> ConcurrentHashMap&lt;String, BaseLoadBalancer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;Server&gt;&gt; entry: zoneServersMap.entrySet()) &#123;</span><br><span class="line">        String zone = entry.getKey().toLowerCase();</span><br><span class="line">        getLoadBalancer(zone).setServersList(entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// check if there is any zone that no longer has a server</span></span><br><span class="line">    <span class="comment">// and set the list to empty so that the zone related metrics does not</span></span><br><span class="line">    <span class="comment">// contain stale data</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, BaseLoadBalancer&gt; existingLBEntry: balancers.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!zoneServersMap.keySet().contains(existingLBEntry.getKey())) &#123;</span><br><span class="line">            existingLBEntry.getValue().setServersList(Collections.emptyList());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到它创建了一个名为<code>balancers</code>的<code>ConcurrentHashMap</code>，用来存储每个Zone区域对应的负载均衡器。</p><p>再来看下它的<code>chooseServer</code>方法，看它如何挑选实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">chooseServer</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!ENABLED.get() || getLoadBalancerStats().getAvailableZones().size() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Zone aware logic disabled or there is only one zone"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.chooseServer(key);</span><br><span class="line">    &#125;</span><br><span class="line">    Server server = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        LoadBalancerStats lbStats = getLoadBalancerStats();</span><br><span class="line">        Map&lt;String, ZoneSnapshot&gt; zoneSnapshot = ZoneAvoidanceRule.createSnapshot(lbStats);</span><br><span class="line">        logger.debug(<span class="string">"Zone snapshots: &#123;&#125;"</span>, zoneSnapshot);</span><br><span class="line">        <span class="keyword">if</span> (triggeringLoad == <span class="keyword">null</span>) &#123;</span><br><span class="line">            triggeringLoad = DynamicPropertyFactory.getInstance().getDoubleProperty(</span><br><span class="line">                    <span class="string">"ZoneAwareNIWSDiscoveryLoadBalancer."</span> + <span class="keyword">this</span>.getName() + <span class="string">".triggeringLoadPerServerThreshold"</span>, <span class="number">0.2</span>d);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (triggeringBlackoutPercentage == <span class="keyword">null</span>) &#123;</span><br><span class="line">            triggeringBlackoutPercentage = DynamicPropertyFactory.getInstance().getDoubleProperty(</span><br><span class="line">                    <span class="string">"ZoneAwareNIWSDiscoveryLoadBalancer."</span> + <span class="keyword">this</span>.getName() + <span class="string">".avoidZoneWithBlackoutPercetage"</span>, <span class="number">0.99999</span>d);</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;String&gt; availableZones = ZoneAvoidanceRule.getAvailableZones(zoneSnapshot, triggeringLoad.get(), triggeringBlackoutPercentage.get());</span><br><span class="line">        logger.debug(<span class="string">"Available zones: &#123;&#125;"</span>, availableZones);</span><br><span class="line">        <span class="keyword">if</span> (availableZones != <span class="keyword">null</span> &amp;&amp;  availableZones.size() &lt; zoneSnapshot.keySet().size()) &#123;</span><br><span class="line">            String zone = ZoneAvoidanceRule.randomChooseZone(zoneSnapshot, availableZones);</span><br><span class="line">            logger.debug(<span class="string">"Zone chosen: &#123;&#125;"</span>, zone);</span><br><span class="line">            <span class="keyword">if</span> (zone != <span class="keyword">null</span>) &#123;</span><br><span class="line">                BaseLoadBalancer zoneLoadBalancer = getLoadBalancer(zone);</span><br><span class="line">                server = zoneLoadBalancer.chooseServer(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(<span class="string">"Error choosing server using zone aware logic for load balancer=&#123;&#125;"</span>, name, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (server != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> server;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.debug(<span class="string">"Zone avoidance logic is not invoked."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.chooseServer(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由源码可知，只有当负载均衡器中维护的实例所属的Zone区域个数大于1的时候才会执行选择策略。可以看到当区域个数大于1时，使用的规则为<code>ZoneAvoidanceRule</code>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过本篇文章，我们大致了解了几种Ribbon客户端负载均衡器的一些特点。后面我们将对负载均衡的一些策略做相关整理及梳理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="SpringCloud" scheme="https://www.sakuratears.top/tags/SpringCloud/"/>
    
      <category term="Ribbon" scheme="https://www.sakuratears.top/tags/Ribbon/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud客户端负载均衡Ribbon</title>
    <link href="https://www.sakuratears.top/blog/SpringCloud%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1Ribbon.html"/>
    <id>https://www.sakuratears.top/blog/SpringCloud客户端负载均衡Ribbon.html</id>
    <published>2020-10-11T04:49:00.000Z</published>
    <updated>2020-10-11T05:00:23.427Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Spring Cloud Ribbon是一个基于HTTP和TCP的客户端负载均衡工具，它基于Netflix Ribbon实现。通过Spring Cloud的封装，可以让我们轻松地将面向服务的REST模版请求自动转换成客户端负载均衡的服务调用。</p><p>这篇文章我们来看下如何使用Ribbon来实现客户端负载均衡，以及Ribbon实现负载均衡的原理。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="客户端负载均衡"><a href="#客户端负载均衡" class="headerlink" title="客户端负载均衡"></a>客户端负载均衡</h2><p>负载均衡在系统架构中非常重要，是系统实现高可用、网络压力缓解、处理能力扩容的重要手段之一。一般情况下，我们所说的负载均衡大都指的服务端的负载均衡，通常分为硬件负载均衡和软件负载均衡。</p><p>硬件负载均衡，主要通过在服务器节点之间安装专门用于负载均衡的设备来实现，如F5。</p><p>软件负载均衡，主要通过在服务器上安装一些具有负载均衡的模块或者软件来实现，如Nginx。</p><p>负载均衡设备或者软件都会维护一个下挂可用的服务端清单，通过心跳检测来剔除故障的服务节点以保证清单中都是可以正常访问的服务节点。客户端发送请求到负载均衡设备，设备按照某种算法（轮询、权重等）从清单里取出一台服务地址，进行转发。</p><p>客户端负载均衡和上面说的服务端负载均衡最大的不同点在于上面提到的服务清单所存储的位置。在客户端负载均衡中，所有客户端都需要维护自己要访问的服务器清单，这些服务端清单来自注册中心。当然，客户端负载均衡也要通过心跳检测服务的健康性，这个步骤需要注册中心配合完成。</p><h2 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h2><p>在之前<a href="https://www.sakuratears.top/blog/Eureka%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.html">Eureka的例子</a>中，我们引入了Ribbon实现负载均衡功能，同时知道了通过给<code>RestTemplate</code>对象配置<code>@LoadBalanced</code>注解便可以开启客户端负载均衡。</p><p>在了解Ribbon之前，我们先聊聊<code>RestTemplate</code>。</p><p>我们可以看到<code>RestTemplate</code>是属于spring web模块的一个类，顾名思义，它是spring用来发送REST请求的封装模板。</p><p>对于GET请求，可以看到主要有两种类型的函数方法。</p><p>第一种，<code>getForEntity</code>函数。返回<code>ResponseEntity</code>对象。它有三个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">ResponseEntity&lt;T&gt; <span class="title">getForEntity</span><span class="params">(String url, Class&lt;T&gt; responseType, Object... uriVariables)</span> <span class="keyword">throws</span> RestClientException </span>&#123;<span class="comment">/**/&#125;</span></span><br><span class="line"><span class="comment">//2.</span></span><br><span class="line"><span class="comment">public &lt;T&gt; ResponseEntity&lt;T&gt; getForEntity(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) throws RestClientException &#123;/**/</span>&#125;</span><br><span class="line"><span class="comment">//3.</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">ResponseEntity&lt;T&gt; <span class="title">getForEntity</span><span class="params">(URI url, Class&lt;T&gt; responseType)</span> <span class="keyword">throws</span> RestClientException </span>&#123;<span class="comment">/**/&#125;</span></span><br></pre></td></tr></table></figure><p>对于第一个方法，其uriVariables里为GET请求的参数，通过url占位符的方式使用，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ResponseEntity&lt;String&gt; responseEntity = restTemplate.getForEntity(<span class="string">"http://SAKURA-SERVICE/hello?name=&#123;1&#125;"</span>,String.class,<span class="string">"aaa"</span>);</span><br><span class="line">String body = responseEntity.getBody();</span><br></pre></td></tr></table></figure><p>其中访问SAKURA-SERVICE服务的hello接口时，”aaa”会替换掉{1}。</p><p>如果返回对象是个User，那么如下实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ResponseEntity&lt;User&gt; responseEntity = restTemplate.getForEntity(<span class="string">"http://SAKURA-SERVICE/hello?name=&#123;1&#125;"</span>,User.class,<span class="string">"aaa"</span>);</span><br><span class="line">User body = responseEntity.getBody();</span><br></pre></td></tr></table></figure><p>第2，3个方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.我们使用name作为占位符，则map里需要put一个key为name的参数</span></span><br><span class="line">Map&lt;String,String&gt; map =<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"name"</span>,<span class="string">"aaa"</span>);</span><br><span class="line">ResponseEntity&lt;String&gt; responseEntity1 = restTemplate.getForEntity(<span class="string">"http://SAKURA-SERVICE/hello?name=&#123;name&#125;"</span>,String.class,map);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.构建uri</span></span><br><span class="line">UriComponents uriComponents = UriComponentsBuilder.fromUriString(<span class="string">"http://SAKURA-SERVICE/hello?name=&#123;name&#125;"</span>).build().expand(<span class="string">"aaa"</span>).encode();</span><br><span class="line">URI uri = uriComponents.toUri();</span><br><span class="line">ResponseEntity&lt;String&gt; responseEntity2 = restTemplate.getForEntity(uri,String.class);</span><br></pre></td></tr></table></figure><p>第二种，<code>getForObject</code>函数。该方法是对<code>getForEntity</code>的进一步封装。</p><p>我们使用时十分简单，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = restTemplate.getForObject(uri,String.class);</span><br><span class="line"></span><br><span class="line">User user = restTemplate.getForObject(uri1,User.class);</span><br></pre></td></tr></table></figure><p>它也有3个重载方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getForObject</span><span class="params">(String url, Class&lt;T&gt; responseType, Object... uriVariables)</span> <span class="keyword">throws</span> RestClientException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getForObject</span><span class="params">(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)</span> <span class="keyword">throws</span> RestClientException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getForObject</span><span class="params">(URI url, Class&lt;T&gt; responseType)</span> <span class="keyword">throws</span> RestClientException </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>对于POST请求，与GET类似，它也有<code>postForEntity</code>和<code>postForObject</code>函数。</p><p>它们的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">postForObject</span><span class="params">(String url, @Nullable Object request, Class&lt;T&gt; responseType,</span></span></span><br><span class="line"><span class="function"><span class="params">Object... uriVariables)</span> <span class="keyword">throws</span> RestClientException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">postForObject</span><span class="params">(String url, @Nullable Object request, Class&lt;T&gt; responseType,</span></span></span><br><span class="line"><span class="function"><span class="params">Map&lt;String, ?&gt; uriVariables)</span> <span class="keyword">throws</span> RestClientException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">postForObject</span><span class="params">(URI url, @Nullable Object request, Class&lt;T&gt; responseType)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> RestClientException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">ResponseEntity&lt;T&gt; <span class="title">postForEntity</span><span class="params">(String url, @Nullable Object request,</span></span></span><br><span class="line"><span class="function"><span class="params">Class&lt;T&gt; responseType, Object... uriVariables)</span> <span class="keyword">throws</span> RestClientException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">ResponseEntity&lt;T&gt; <span class="title">postForEntity</span><span class="params">(String url, @Nullable Object request,</span></span></span><br><span class="line"><span class="function"><span class="params">Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)</span> <span class="keyword">throws</span> RestClientException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">ResponseEntity&lt;T&gt; <span class="title">postForEntity</span><span class="params">(URI url, @Nullable Object request, Class&lt;T&gt; responseType)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> RestClientException </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>它们的使用与GET类似，我们就不在过多介绍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User(<span class="string">"aaaa"</span>,<span class="number">18</span>);</span><br><span class="line">ResponseEntity&lt;String&gt; responseEntity = restTemplate.postForEntity(<span class="string">"http://SAKURA-SERVICE/hello"</span>,user,String.class);</span><br><span class="line">String body = responseEntity.getBody();</span><br></pre></td></tr></table></figure><p>另外POST里还有一种<code>postForLocation</code>函数，用来提交资源并返回新资源URI，它也有三种重载方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User(<span class="string">"aaaa"</span>,<span class="number">18</span>);</span><br><span class="line">URI uri = restTemplate.postForLocation(<span class="string">"http://SAKURA-SERVICE/hello"</span>,user);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> URI <span class="title">postForLocation</span><span class="params">(String url, @Nullable Object request, Object... uriVariables)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> RestClientException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> URI <span class="title">postForLocation</span><span class="params">(String url, @Nullable Object request, Map&lt;String, ?&gt; uriVariables)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> RestClientException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> URI <span class="title">postForLocation</span><span class="params">(URI url, @Nullable Object request)</span> <span class="keyword">throws</span> RestClientException </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><code>RestTemplate</code>里的其他方法，如PUT、DELETE等我们不再介绍，有兴趣的可以看看源码。</p><h2 id="Ribbon源码"><a href="#Ribbon源码" class="headerlink" title="Ribbon源码"></a>Ribbon源码</h2><p>分析完<code>RestTemplate</code>后，我们会想，<code>RestTemplate</code>本是Spring本是的东西，如何通过Ribbon实现负载均衡的呢？</p><p>因为我们之前的例子讲到当<code>RestTemplate</code>作用上<code>@LoadBalanced</code>注解后，便可以实现负载均衡了，因此我们从<code>@LoadBalanced</code>注解开始看起吧。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-656.jpg" alt="upload successful"></p><p>通过<code>@LoadBalanced</code>注释可以看到，该注解用来给<code>RestTemplate</code>做标记，以使用负载均衡的客户端<code>LoadBalancerClient</code>来配置它。</p><p>我们搜索<code>LoadBalancerClient</code>可以发现这是Spring Cloud定义的一个接口。如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-657.jpg" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-658.jpg" alt="upload successful"></p><p>通过该接口，可以大致了解负载均衡客户端应具备的几种能力。</p><ol><li><p><code>choose</code>方法：根据传入的服务名serviceId，从负载均衡器中挑选一个对应服务的实例。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ServiceInstance <span class="title">choose</span><span class="params">(String serviceId)</span></span></span><br></pre></td></tr></table></figure></li><li><p><code>execute</code>方法：使用从负载均衡器中挑选出来的服务实例来执行请求内容。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String serviceId, LoadBalancerRequest&lt;T&gt; request)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String serviceId, ServiceInstance serviceInstance,LoadBalancerRequest&lt;T&gt; request)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>reconstructURI</code>方法：为系统构建一个合适的host:port形式的URI。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">URI <span class="title">reconstructURI</span><span class="params">(ServiceInstance instance, URI original)</span></span>;</span><br></pre></td></tr></table></figure></li></ol><p>我们再来看一下<code>LoadBalancerAutoConfiguration</code>这个类，这个类是实现客户端负载均衡的自动化配置类。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-659.jpg" alt="upload successful"></p><p>根据上图，我们可以知道，Ribbon实现负载均衡自动化配置需要满足下面两个条件：</p><ul><li><code>@ConditionalOnClass(RestTemplate.class)</code>：当前工程环境中需要存在<code>RestTemplate</code>类。</li><li><code>@ConditionalOnBean(LoadBalancerClient.class)</code>：需要存在<code>LoadBalancerClient</code>接口的实现Bean。</li></ul><p>该自动化配置类主要完成以下几个功能：</p><ul><li>创建一个<code>LoadBalancerInterceptor</code>的 Bean，用于实现对客户端发起请求时进行拦截，以实现客户端负载均衡。</li><li>创建一个<code>RetryLoadBalancerInterceptor</code>的Bean，用于实现客户端负载均衡的重试机制。</li><li>创建一个<code>RestTemplateCustomizer</code>的 Bean，用于给<code>RestTemplate</code>增加<code>LoadBalancerInterceptor</code>和<code>RetryLoadBalancerInterceptor</code>拦截器。</li><li>维护一个被<code>@LoadBalanced</code>修饰的<code>RestTemplate</code>对象列表，并在这里进行初始化，通过调用<code>RestTemplateCustomizer</code>实例来给需要客户端负载均衡的<code>RestTemplate</code>增加<code>LoadBalancerInterceptor</code>和<code>RetryLoadBalancerInterceptor</code>拦截器。</li></ul><p><code>LoadBalancerInterceptor</code>相关代码如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-660.jpg" alt="upload successful"></p><p>通过源码以及之前的自动化配置类，我们可以看到在拦截器中注入了<code>LoadBalancerClient</code>的实现。当一个被<code>@LoadBalanced</code>注解修饰的<code>RestTemplate</code>对象向外发起HTTP请求时，会被<code>LoadBalancerInterceptor</code>类的<code>intercept</code>所拦截。由于我们在使用<code>RestTemplate</code>时采用了服务名作为host，所以直接从<code>HttpRequest</code>的URI对象中通过<code>getHost()</code>就可以拿到服务名，然后调用<code>execute</code>函数去根据服务名来选择实例并发起实际的请求。</p><p>我们上面讲到了<code>LoadBalancerClient</code>，它只是一个接口，我们现在来看下它的实现类。我们很容易就可以找到它的实现类<code>RibbonLoadBalancerClient</code>。</p><p>这个类我们主要看下它的<code>execute</code>方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String serviceId, LoadBalancerRequest&lt;T&gt; request, Object hint)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ILoadBalancer loadBalancer = getLoadBalancer(serviceId);</span><br><span class="line">    Server server = getServer(loadBalancer, hint);</span><br><span class="line">    <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No instances available for "</span> + serviceId);</span><br><span class="line">    &#125;</span><br><span class="line">    RibbonServer ribbonServer = <span class="keyword">new</span> RibbonServer(serviceId, server, isSecure(server,</span><br><span class="line">            serviceId), serverIntrospector(serviceId).getMetadata(server));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> execute(serviceId, ribbonServer, request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String serviceId, ServiceInstance serviceInstance, LoadBalancerRequest&lt;T&gt; request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Server server = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(serviceInstance <span class="keyword">instanceof</span> RibbonServer) &#123;</span><br><span class="line">        server = ((RibbonServer)serviceInstance).getServer();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No instances available for "</span> + serviceId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RibbonLoadBalancerContext context = <span class="keyword">this</span>.clientFactory</span><br><span class="line">            .getLoadBalancerContext(serviceId);</span><br><span class="line">    RibbonStatsRecorder statsRecorder = <span class="keyword">new</span> RibbonStatsRecorder(context, server);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        T returnVal = request.apply(serviceInstance);</span><br><span class="line">        statsRecorder.recordStats(returnVal);</span><br><span class="line">        <span class="keyword">return</span> returnVal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// catch IOException and rethrow so RestTemplate behaves correctly</span></span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        statsRecorder.recordStats(ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        statsRecorder.recordStats(ex);</span><br><span class="line">        ReflectionUtils.rethrowRuntimeException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Server <span class="title">getServer</span><span class="params">(ILoadBalancer loadBalancer, Object hint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (loadBalancer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Use 'default' on a null hint, or just pass it on?</span></span><br><span class="line">    <span class="keyword">return</span> loadBalancer.chooseServer(hint != <span class="keyword">null</span> ? hint : <span class="string">"default"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在<code>execute</code>函数的实现中，第一步就是通过<code>getServer</code>根据传入的服务名<code>serviceId</code>去获取具体的服务实例。</p><p>同时可以看到<code>getServer</code>函数的实现，调用的是<code>ILoadBalancer</code>接口中定义的<code>chooseServer</code>函数。</p><p>对于<code>ILoadBalancer</code>接口，该接口定义了一个客户端负载均衡需要的一系列抽象操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ILoadBalancer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addServers</span><span class="params">(List&lt;Server&gt; newServers)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Server <span class="title">chooseServer</span><span class="params">(Object key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">markServerDown</span><span class="params">(Server server)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Server&gt; <span class="title">getReachableServers</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Server&gt; <span class="title">getAllServers</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>addServers：向负载均衡器中维护的实例列表增加服务实例。</li><li>chooseServer：通过某种策略，从负载均衡器中挑选出一个具体的服务实例。</li><li>markServerDown：用来通知和标识负载均衡器中某个具体实例已经停止服务，不然负载均衡器在下一次获取服务实例清单前会认为服务实例正常，实际访问时出现问题。</li><li>getReachableServers：获取当前正常服务的实例列表。</li><li>getAllServers：获取所有已知服务实例列表，包括正常服务和停止服务的实例。</li></ul><p>该接口的实现就是对负载均衡策略的一些扩展，这部分我们下节在详细讨论。</p><p>在<code>RibbonClientConfiguration</code>配置类中，我们可以看到如下代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ILoadBalancer <span class="title">ribbonLoadBalancer</span><span class="params">(IClientConfig config,</span></span></span><br><span class="line"><span class="function"><span class="params">        ServerList&lt;Server&gt; serverList, ServerListFilter&lt;Server&gt; serverListFilter,</span></span></span><br><span class="line"><span class="function"><span class="params">        IRule rule, IPing ping, ServerListUpdater serverListUpdater)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(ILoadBalancer.class, name)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(ILoadBalancer.class, config, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ZoneAwareLoadBalancer&lt;&gt;(config, rule, ping, serverList,</span><br><span class="line">            serverListFilter, serverListUpdater);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到Ribbon默认使用<code>ZoneAwareLoadBalancer</code>来实现负载均衡器。</p><p>我们在回到<code>RibbonLoadBalancerClient</code>的代码逻辑，当通过<code>ZoneAwareLoadBalancer</code>的<code>chooseServer</code>函数获取了负载均衡策略分配到的服务实例Server后，将其内容包装成<code>RibbonServer</code>对象，然后使用该对象回调<code>LoadBalancerInterceptor</code>请求拦截器中<code>LoadBalancerRequest</code>的<code>apply(ServiceInstance instance)</code>函数，向一个具体服务实例发起请求。</p><p>在<code>apply(ServiceInstance instance)</code>函数中传入的<code>ServiceInstance</code>接口对象是对服务实例的抽象定义。其内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceInstance</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">default</span> String <span class="title">getInstanceId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">getServiceId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">getHost</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getPort</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSecure</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">URI <span class="title">getUri</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Map&lt;String, String&gt; <span class="title">getMetadata</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">default</span> String <span class="title">getScheme</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的<code>RibbonServer</code>对象就是该接口对的一个实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonServer</span> <span class="keyword">implements</span> <span class="title">ServiceInstance</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String serviceId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Server server;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> secure;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; metadata;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RibbonServer</span><span class="params">(String serviceId, Server server)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(serviceId, server, <span class="keyword">false</span>, Collections.emptyMap());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RibbonServer</span><span class="params">(String serviceId, Server server, <span class="keyword">boolean</span> secure,</span></span></span><br><span class="line"><span class="function"><span class="params">            Map&lt;String, String&gt; metadata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serviceId = serviceId;</span><br><span class="line">        <span class="keyword">this</span>.server = server;</span><br><span class="line">        <span class="keyword">this</span>.secure = secure;</span><br><span class="line">        <span class="keyword">this</span>.metadata = metadata;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//.....部分代码略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>分析到这里，我们大致理清Spring Cloud Ribbon中实现负载均衡的基本脉络，了解了它的一些源码。后面我们会再来看下Ribbon的负载均衡器及负载均衡策略的一些东西。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="SpringCloud" scheme="https://www.sakuratears.top/tags/SpringCloud/"/>
    
      <category term="Ribbon" scheme="https://www.sakuratears.top/tags/Ribbon/"/>
    
  </entry>
  
  <entry>
    <title>面试问题总结</title>
    <link href="https://www.sakuratears.top/blog/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.html"/>
    <id>https://www.sakuratears.top/blog/面试问题总结.html</id>
    <published>2020-08-30T03:28:00.000Z</published>
    <updated>2021-01-10T10:07:45.417Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Redis高并发和快速的原因"><a href="#Redis高并发和快速的原因" class="headerlink" title="Redis高并发和快速的原因"></a><code>Redis</code>高并发和快速的原因</h1><h2 id="Redis高并发和快速的原因-1"><a href="#Redis高并发和快速的原因-1" class="headerlink" title="Redis高并发和快速的原因"></a><code>Redis</code>高并发和快速的原因</h2><ol><li><code>Redis</code>是基于内存的，内存的读写速度非常快；</li><li><code>Redis</code>是单线程的，省去了很多上下文切换线程的时间；</li><li><code>Redis</code>使用多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用<code>epoll</code>，采用了<code>epoll+</code>自己实现的简单的事件框架。<code>epoll</code>中的读、写、关闭、连接都转化成了事件，然后利用<code>epoll</code>的多路复用特性，绝不在io上浪费一点时间。</li></ol><h2 id="为什么Redis是单线程的"><a href="#为什么Redis是单线程的" class="headerlink" title="为什么Redis是单线程的"></a>为什么<code>Redis</code>是单线程的</h2><ol><li><p>官方答案</p><p> 因为<code>Redis</code>是基于内存的操作，CPU不是<code>Redis</code>的瓶颈，<code>Redis</code>的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p></li><li><p>性能指标</p><p> 关于<code>Redis</code>的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。</p></li><li><p>详细原因</p><ul><li><p>不需要各种锁的性能消耗</p><p>  <code>Redis</code>的数据结构并不全是简单的<code>Key-Value</code>，还有<code>list</code>，<code>hash</code>等复杂的结构，这些结构有可能会进行很细粒度的操作，比如在很长的列表后面添加一个元素，在<code>hash</code>当中添加或者删除一个对象。这些操作可能就需要加非常多的锁，导致的结果是同步开销大大增加。</p><p>  总之，在单线程的情况下，就不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。</p></li><li><p>单线程多进程集群方案</p><p>  单线程的威力实际上非常强大，每核心效率也非常高，多线程自然是可以比单线程有更高的性能上限，但是在今天的计算环境中，即使是单机多线程的上限也往往不能满足需要了，需要进一步摸索的是多服务器集群化的方案，这些方案中多线程的技术照样是用不上的。</p><p>  所以单线程、多进程的集群不失为一个时髦的解决方案。</p></li><li><p>CPU消耗</p><p>  采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU。</p><p>  但是如果CPU成为<code>Redis</code>瓶颈，或者不想让服务器其他CUP核闲置，那怎么办？</p><p>  可以考虑多起几个<code>Redis</code>进程，<code>Redis</code>是<code>key-value</code>数据库，不是关系数据库，数据之间没有约束。只要客户端分清哪些<code>key</code>放在哪个<code>Redis</code>进程上就可以了。</p></li></ul></li></ol><h2 id="Redis单线程的优劣势"><a href="#Redis单线程的优劣势" class="headerlink" title="Redis单线程的优劣势"></a><code>Redis</code>单线程的优劣势</h2><ol><li><p>单进程单线程优势</p><ul><li>代码更清晰，处理逻辑更简单；</li><li>不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</li><li>不存在多进程或者多线程导致的切换而消耗CPU。</li></ul></li><li><p>单进程单线程弊端</p><ul><li>无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善。</li></ul></li><li><p>IO多路复用技术</p><p> <code>Redis</code> 采用网络IO多路复用技术来保证在多连接的时候， 系统的高吞吐量。</p><p> 多路-指的是多个<code>socket</code>连接，复用-指的是复用一个线程。多路复用主要有三种技术：<code>select</code>，<code>poll</code>，<code>epoll</code>。<code>epoll</code>是最新的也是目前最好的多路复用技术。</p><p> 这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且<code>Redis</code>在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了<code>Redis</code>具有很高的吞吐量。</p></li></ol><h2 id="Redis高并发快总结"><a href="#Redis高并发快总结" class="headerlink" title="Redis高并发快总结"></a>Redis高并发快总结</h2><ol><li><code>Redis</code>是纯内存数据库，一般都是简单的存取操作，线程占用的时间很多，时间的花费主要集中在IO上，所以读取速度快。</li><li>再说一下IO，<code>Redis</code>使用的是非阻塞IO，IO多路复用，使用了单线程来轮询描述符，将数据库的开、关、读、写都转换成了事件，减少了线程切换时上下文的切换和竞争。</li><li><code>Redis</code>采用了单线程的模型，保证了每个操作的原子性，也减少了线程的上下文切换和竞争。</li><li>另外，数据结构也帮了不少忙，<code>Redis</code>全程使用<code>hash</code>结构，读取速度快，还有一些特殊的数据结构，对数据存储进行了优化，如压缩表，对短数据进行压缩存储，再如，跳表，使用有序的数据结构加快读取的速度。</li><li>还有一点，<code>Redis</code>采用自己实现的事件分离器，效率比较高，内部采用非阻塞的执行方式，吞吐能力比较大。</li></ol><h1 id="Spring中BeanFactory和ApplicationContext的区别"><a href="#Spring中BeanFactory和ApplicationContext的区别" class="headerlink" title="Spring中BeanFactory和ApplicationContext的区别"></a><code>Spring</code>中<code>BeanFactory</code>和<code>ApplicationContext</code>的区别</h1><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-655.jpg" alt="upload successful"></p><ol><li><p>国际化</p><p> <code>BeanFactory</code>是不支持国际化功能的，因为<code>BeanFactory</code>没有扩展<code>Spring</code>中<code>MessageResource</code>接口。相反，由于<code>ApplicationContext</code>扩展了<code>MessageResource</code>接口，因而具有消息处理的能力(i18N)。</p></li><li><p>强大的事件机制(Event) </p><p> 基本上牵涉到事件(Event)方面的设计，就离不开观察者模式，<code>ApplicationContext</code>的事件机制主要通过<code>ApplicationEvent</code>和<code>ApplicationListener</code>这两个接口来提供的，和<code>java swing</code>中的事件机制一样。即当<code>ApplicationContext</code>中发布一个事件的时，所有扩展了<code>ApplicationListener</code>的<code>Bean</code>都将会接受到这个事件，并进行相应的处理。</p></li><li><p>底层资源的访问 </p><p> <code>ApplicationContext</code>扩展了<code>ResourceLoader</code>(资源加载器)接口，从而可以用来加载多个<code>Resource</code>，而<code>BeanFactory</code>是没有扩展<code>ResourceLoader</code>。</p></li><li><p>对Web应用的支持 </p><p> 与<code>BeanFactory</code>通常以编程的方式被创建不同的是，<code>ApplicationContext</code>能以声明的方式创建，如使用<code>ContextLoader</code>。当然你也可以使用<code>ApplicationContext</code>的实现之一来以编程的方式创建<code>ApplicationContext</code>实例 。</p></li><li><p>延迟加载</p><ul><li><p><code>BeanFactroy</code>采用的是延迟加载形式来注入<code>Bean</code>的，即只有在使用到某个<code>Bean</code>时(调用<code>getBean()</code>)，才对该<code>Bean</code>进行加载实例化，这样，我们就不能发现一些存在的<code>spring</code>的配置问题。而<code>ApplicationContext</code>则相反，它是在容器启动时，一次性创建了所有的<code>Bean</code>。这样，在容器启动时，我们就可以发现<code>Spring</code>中存在的配置错误。</p></li><li><p><code>BeanFactory</code>和<code>ApplicationContext</code>都支持<code>BeanPostProcessor</code>、<code>BeanFactoryPostProcessor</code>的使用，但两者之间的区别是：<code>BeanFactory</code>需要手动注册，而<code>ApplicationContext</code>则是自动注册。</p></li></ul></li></ol><p>可以看到:</p><ul><li><p><code>ApplicationContext</code>继承了<code>BeanFactory</code>，<code>BeanFactory</code>是<code>Spring</code>中比较原始的<code>Factory</code>，它不支持<code>AOP</code>、<code>Web</code>等<code>Spring</code>插件，而<code>ApplicationContext</code>不仅包含了<code>BeanFactory</code>的所有功能，还支持<code>Spring</code>的各种插件，还以一种面向框架的方式工作以及对上下文进行分层和实现继承。</p></li><li><p><code>BeanFactory</code>是<code>Spring</code>框架的基础设施，面向<code>Spring</code>本身；而<code>ApplicationContext</code>面向使用<code>Spring</code>的开发者，相比<code>BeanFactory</code>提供了更多面向实际应用的功能，几乎所有场合都可以直接使用<code>ApplicationContext</code>而不是底层的<code>BeanFactory</code>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Redis" scheme="https://www.sakuratears.top/tags/Redis/"/>
    
      <category term="Spring" scheme="https://www.sakuratears.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Redis淘汰策略</title>
    <link href="https://www.sakuratears.top/blog/Redis%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5.html"/>
    <id>https://www.sakuratears.top/blog/Redis淘汰策略.html</id>
    <published>2020-08-19T14:35:00.000Z</published>
    <updated>2021-01-10T10:08:42.099Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>当Ridis被用作缓存时，我们添加新数据后可以很方便的删除旧数据。这种行为在开发过程中十分常见，这种行为是内存型数据库的默认行为。</p><p>当然，数据库对旧数据进行处理的前提是我们的数据存储达到了设定的值。</p><p>在Redis中，LRU（Less Recently Used）是比较常用的数据淘汰策略，其方式就是当内存达到指定值时，清除一部分当前较少被使用（Less Recently Used）的数据。</p><p>从Redis 4.0版本开始，Redis引入了一个新的内存数据淘汰策略LFU（Least Frequently Used），清除最不经常使用的的内存数据。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Maxmemory配置指令"><a href="#Maxmemory配置指令" class="headerlink" title="Maxmemory配置指令"></a>Maxmemory配置指令</h2><p><code>maxmemory</code> 配置指令是用来配置<code>Redis</code>使用指定数量的内存数据集。</p><p>我们可以使用<code>redis.conf</code>文件设置配置指令，或者在运行时使用<code>CONFIG set</code>命令设置。</p><p>比如，我们想限制<code>Redis</code>使用最大100M的内存，则可以在<code>redis.conf</code>文件中如下配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory 100mb</span><br></pre></td></tr></table></figure><p>将<code>maxmemory</code>设置为0会导致没有内存限制。这是64位系统的默认行为，而32位系统使用隐式内存限制为<code>3GB</code>。</p><p>当达到指定的内存量时，我们可以设定不同的淘汰策略。Redis可以只返回错误的命令，这可能导致更多的内存被使用，或者它可以淘汰一些旧数据，以便添加新的数据。</p><h2 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h2><p>当数据量达到<code>maxmemory</code>限制时，<code>Redis</code>的确切行为是使用<code>maxmemory-policy</code>配置指令配置的。</p><p>有以下策略：</p><ul><li><strong>noeviction</strong>：当达到内存限制且客户端试图执行可能导致使用更多内存的命令时返回错误(大多数是<code>write </code>命令，除了<code>DEL</code>和其他一些异常)。</li><li><strong>allkeys-lru</strong>：通过首先尝试删除最近使用较少的(LRU)键来删除数据，以便为添加的新数据腾出空间。</li><li><strong>volatile-lru</strong>：通过尝试首先删除最近较少使用的(LRU)键，但仅在具有过期时间的键中删除，从而为添加的新数据腾出空间。</li><li><strong>allkeys-random</strong>：随机删除键，以便为添加的新数据腾出空间。</li><li><strong>volatile-random</strong>：随机删除键，以便为添加的新数据腾出空间，但仅删除具有过期时间的键。</li><li><strong>volatile-ttl</strong>：删除具有过期时间的键值，并首先尝试删除具有较短生存时间(TTL)的键值，以便为添加的新数据腾出空间。</li></ul><p>如果没有匹配到先决条件的淘汰键，<code>volatile-lru</code>、<code>volatile-random</code>和<code>volatile-ttl</code>策略的行为类似于<code>noeviction</code>。</p><p>根据应用程序的访问模式选择正确的回收策略是十分重要的，但是我们也可以在运行时重新配置策略，当应用程序运行时，使用 <code>Redis </code><code>INFO</code> 命令输出信息来监控缓存丢失和命中的数量，以便调整我们的设置。</p><p>一般经验法则：</p><ul><li>当我们的请求数据量呈<strong>幂律分布</strong>时，即访问一部分元素比其它元素更频繁时，可以使用<strong>allkeys-lru</strong>策略，这是一个不错的选择。</li><li>如果我们的访问比较均匀，所有的键都可能平等的被访问（期望分布均匀），那么可以使用<strong>allkeys-random</strong>策略。</li><li>如果我们创建对象的时候，设置了对象的过期时间（TTL），那么可以使用<strong>volatile-ttl</strong>策略。</li><li>当我们使用Redis单例缓存持久数据时，<strong>volatile-lru</strong>和<strong>volatile-random</strong>策略就非常有用了。当然，使用两个Redis实例来解决这个问题通常更好。</li></ul><p>需要注意的是，为键设置过期时间会消耗内存，因此使用<strong>allkeys-lru</strong>这样的策略更能有效地利用内存，因为在内存压力下不需要为要淘汰的键设置过期时间。</p><blockquote><p>幂律分布：数学模型，如二八原则：20%的人口拥有80%的财富，20%的上市公司创造80%的价值，80%的收入来自20%的商品等等。</p></blockquote><h2 id="淘汰过程如何进行"><a href="#淘汰过程如何进行" class="headerlink" title="淘汰过程如何进行"></a>淘汰过程如何进行</h2><p>我们需要知道淘汰策略是如下进行的：</p><ol><li>客户端运行一个新命令，导致更多数据被添加；</li><li><code>Redis</code>检查内存使用，如果超过<code>maxmemory</code>限制，便会根据策略淘汰数据；</li><li>执行一个新命令，以此类推。</li></ol><p>所以实际是不断的跨越<code>maxmemory</code>边界限制，检测到，而后通过淘汰某些数据使内存回到限制下。</p><p>如果一个命令导致一段时间内使用了大量内存（如向一个大集合<code>big set</code>里插入一个新的<code>key</code>），那么内存限制可能会短时间内超过很多。</p><h2 id="近似LRU算法"><a href="#近似LRU算法" class="headerlink" title="近似LRU算法"></a>近似LRU算法</h2><p>需要注意的是<code>Redis</code>的<code>LRU</code>算法只是一个近似的实现。这就意味着<code>Redis</code>并不一定能淘汰最佳的需要被淘汰的数据。</p><p><code>Redis</code>通过运行近似<code>LRU</code>算法，对少量数据<code>key</code>进行采样，然后在采样数据中找到最好的（访问时间最旧的<code>key</code>），并将其淘汰。</p><p>从Redis 3.0以后，算法得到了改进，采取了一个好的候选淘汰池。这提高了算法的性能，使其更能够更接近真实LRU算法的行为。</p><p><code>Redis</code>的<code>LRU</code>算法有一个比较重要的点，我们可以改变样本数量来调整算法的精度，参数控制如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory-samples 5</span><br></pre></td></tr></table></figure><p><code>Redis</code>不使用真正<code>LRU</code>算法的根本原因是其需要很多内存。其实对于使用<code>Redis</code>的应用来说，这个近似<code>LRU</code>算法和真正的<code>LRU</code>算法是等价的。</p><p>下面是<code>Redis</code>使用的<code>LRU</code>近似值与真实<code>LRU</code>之间的图形比较。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-654.png" alt="upload successful"></p><p>上述图形生成过程：使用给定数量的<code>key</code>填充<code>Redis</code>，然后从第一个键访问到最后一个键，因此第一个键是使用<code>LRU</code>算法淘汰的最佳候选键。然后增加50%的键，迫使<code>Redis</code>淘汰一半的键。</p><p>可以看到上图的数据点，形成了3个不同的带。</p><ul><li>浅灰色带是被淘汰的对象。</li><li>灰色带是未被淘汰的对象。</li><li>绿带是新添加的对象。</li></ul><p>在理论上的<code>LRU</code>实现中，我们期望在旧的键中，将前一半淘汰。而<code>Redis LRU</code>算法只会概率地使旧键被淘汰。</p><p>正如我们所看到的，与<code>Redis 2.8</code>相比，<code>Redis 3.0</code>在5个样本上做得更好，但是大多数最新访问的对象仍然保留在<code>Redis 2.8</code>中。在<code>Redis 3.0</code>中使用10个样本大小，这个近似非常接近于理论性能的<code>Redis 3.0</code>。</p><p>需要注意的是，<code>LRU</code>只是一个模型，用于预测给定<code>key</code>在未来被访问的可能性。此外，如果我们数据访问模式与幂律分布非常相似，那么大多数访问将位于<code>LRU</code>近似算法能够很好处理的键集中。</p><p>在模拟中，我们发现使用幂律访问模式，真实<code>LRU</code>近似和<code>Redis LRU</code>近似之间的差异极小或不存在。</p><p>但是，我们可以以额外的CPU使用为代价将样本大小增加到10，以接近真实的<code>LRU</code>，并检查这是否会对缓存漏报率产生影响。</p><p>通过使用配置集<code>maxmemory-samples \<count></count></code>命令，在生产环境中使用不同的样本大小值进行试验，这非常简单。</p><h2 id="新的LFU策略模式"><a href="#新的LFU策略模式" class="headerlink" title="新的LFU策略模式"></a>新的LFU策略模式</h2><p>在<code>Redis 4.0</code>中，我们可以使用一种新的淘汰策略模式，<code>LFU</code>（Least Frequently Used）。在某些情况下，这种策略模式可能更好（提供更好的命中/丢失比率），因为使用<code>LFU</code>，<code>Redis</code>会尝试跟踪访问条目的频率，所以使用很少的会被清除，而经常使用的会被留在内存中。</p><p>而我们想下<code>LRU</code>，最近访问过但实际上几乎从未请求过的项将不会淘汰，因此风险是淘汰一个将来有更高机会被请求的键。<code>LFU</code>不存在这个问题，一般来说能更好地适应不同的访问模式。</p><p><code>LFU</code>有以下策略模式可以使用：</p><ul><li>volatile-lfu：在设置过期时间的键里使用近似LFU模式淘汰键。</li><li>allkeys-lfu：使用近似LFU模式淘汰任何键。</li></ul><p><code>LFU</code>和<code>LRU</code>有些类似：它使用概率计算器，一种叫<a href="https://en.wikipedia.org/wiki/Approximate_counting_algorithm" rel="external nofollow noopener noreferrer" target="_blank"><code>Morris counter</code></a>的计数器。根据一些对象的访问频率，结合衰减期来进行估算。</p><p>信息采样类似于<code>LRU</code>，选择一个合适的候选数据以便淘汰掉。</p><p>与<code>LRU</code>不同的是，<code>LFU</code>有某些参数可调，如果一个频繁的条目不再被访问，它的排名应该降低多快？ 还可以调优Morris计数器范围，以便更好地使算法适应特定的用例。</p><p><code>Redis 4.0</code>默认配置如下：</p><ul><li>大约一百万个请求使计数器饱和。</li><li>每隔一分钟衰减一下计数器。</li></ul><p>这些值是比较合理的，并且是经过实验测试的，但是用户可能希望使用这些配置设置来选择最优值。</p><p>关于如何调优这些参数的说明可以在源代码分发版的示例<code>redis.conf</code>文件中找到，但简单地说，它们是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lfu-log-factor 10</span><br><span class="line">lfu-decay-time 1</span><br></pre></td></tr></table></figure><p>lfu-decay-time ：衰减时间，计数器应衰减的分钟数，当采样并发现比该值更早的值时。一个特殊的值0表示:每次扫描时总是衰减计数器，很少有用。</p><p>lfu-log-factor ：计数器对数因子，使计数器达到饱和所需的命中次数，该次数刚好在0-255范围内。系数越高，为了达到最大值，需要的访问次数就越多。系数越低，计数器对于低访问频率的表现越好，由下表可知:</p><table><thead><tr><th>factor</th><th>100 hits</th><th>1000 hits</th><th>100K hits</th><th>1M hits</th><th>10M hits</th></tr></thead><tbody><tr><td>0</td><td>104</td><td>255</td><td>255</td><td>255</td><td>255</td></tr><tr><td>1</td><td>18</td><td>49</td><td>255</td><td>255</td><td>255</td></tr><tr><td>10</td><td>10</td><td>18</td><td>142</td><td>255</td><td>255</td></tr><tr><td>100</td><td>8</td><td>11</td><td>49</td><td>143</td><td>255</td></tr></tbody></table><p>所以基本上这个因子就是在低访问和高访问之间进行权衡。更多的信息可以在示例<code>redis.conf</code>文件中获得。</p><p>由于<code>LFU</code>是一个新特性，如果我们在实际使用中可以与<code>LRU</code>进行比较，得到的信息及疑问可以反馈给<code>Redis</code>官方。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文通过对<code>Redis</code>淘汰策略的介绍，了解了<code>Redis</code>淘汰模式的一些特点和用法，这对我们是比较有帮助的。</p><h1 id="参考-翻译"><a href="#参考-翻译" class="headerlink" title="参考/翻译"></a>参考/翻译</h1><ol><li><a href="https://redis.io/topics/lru-cache" rel="external nofollow noopener noreferrer" target="_blank">Using Redis as an LRU cache</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Redis" scheme="https://www.sakuratears.top/tags/Redis/"/>
    
      <category term="淘汰策略" scheme="https://www.sakuratears.top/tags/%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>Java实体对象映射工具MapStruct</title>
    <link href="https://www.sakuratears.top/blog/Java%E5%AE%9E%E4%BD%93%E5%AF%B9%E8%B1%A1%E6%98%A0%E5%B0%84%E5%B7%A5%E5%85%B7MapStruct.html"/>
    <id>https://www.sakuratears.top/blog/Java实体对象映射工具MapStruct.html</id>
    <published>2020-08-17T12:49:00.000Z</published>
    <updated>2020-08-17T12:50:11.163Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天我们来介绍一款非常优秀的实体对象映射工具，<a href="https://mapstruct.org/" rel="external nofollow noopener noreferrer" target="_blank"><code>MapStruct</code></a>。</p><p>在开发的时候我们会看到业务代码之间有很多的<code>JavaBean</code>之间的相互转化，非常影响美观，但是又不得不存在。</p><p>通常的<code>JavaBean</code>处理方法是通过Spring或者Apache提供的<code>BeanUtils</code>工具，而对于一些不匹配的属性，通过<code>get/set</code>方法解决。</p><p>由于<code>BeanUtils</code>使用反射机制，故其在大量使用时可能会影响到性能，同时对于不匹配的属性，如果较多，<code>get/set</code>起来也非常麻烦和繁琐。</p><p>对于一些特殊类型不一致的字段，如<code>DO</code>里为<code>Date</code>类型，可能<code>DTO</code>里需要变为时间的<code>String</code>类型，我们需要调用指定方法进行处理，再进行<code>get/set</code>。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>而<code>MapStruct</code>可以让我们从这种复杂而繁琐的工作中解放出来。</p><p><code>MapSturct</code> 是一个生成类型安全，高性能且无依赖的<code>JavaBean</code>映射代码的注解处理器（annotation processor）。</p><p>它可以让我们通过注解的方式，生成<code>JavaBean</code>之间的映射代码，相较于反射，更安全更高效。</p><p>让我们来看一下。</p><h2 id="MapStruct引入"><a href="#MapStruct引入" class="headerlink" title="MapStruct引入"></a>MapStruct引入</h2><p>首先我们需要在<code>Maven</code>项目中引入<code>MapSturct</code>的相关Jar包。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">org.mapstruct.version</span>&gt;</span>1.3.1.Final<span class="tag">&lt;/<span class="name">org.mapstruct.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mapstruct/mapstruct --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mapstruct<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapstruct<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;org.mapstruct.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mapstruct<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapstruct-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;org.mapstruct.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>有两个，<code>mapstruct</code>是主要包，<code>mapstruct-processor</code>用来辅助生成<code>JavaBean</code>之间的映射代码。</p><h2 id="MapStruct使用"><a href="#MapStruct使用" class="headerlink" title="MapStruct使用"></a>MapStruct使用</h2><p>我们根据例子来看如何使用<code>MapSturct</code>。</p><p>我们这儿有两个<code>JavaBean</code>，<code>PersonDO</code>和<code>PersonDTO</code>，现在我们将<code>PersonDO</code>转为<code>PersonDTO</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDTO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Gender gender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Gender &#123;</span><br><span class="line">    MAN,MALE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转化时需要编写<code>Mapper</code>，即对象映射器，是一个接口，如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonConverter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    PersonConverter INSTANCE = Mappers.getMapper(PersonConverter.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mapping</span>(source = <span class="string">"name"</span>, target = <span class="string">"userName"</span>)</span><br><span class="line">    <span class="function">PersonDTO <span class="title">do2dto</span><span class="params">(PersonDO person)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用注解<code>@Mapper</code>定义一个<code>Converter</code>接口，在其中定义一个<code>do2dto</code>方法，方法的入参类型是<code>PersonDO</code>，出参类型是<code>PersonDTO</code>，这个方法就用于将<code>PersonDO</code>转成<code>PersonDTO</code>。</p><p>测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PersonDO personDO = <span class="keyword">new</span> PersonDO();</span><br><span class="line">        personDO.setName(<span class="string">"Sakura"</span>);</span><br><span class="line">        personDO.setAge(<span class="number">27</span>);</span><br><span class="line">        personDO.setId(<span class="number">1</span>);</span><br><span class="line">        personDO.setGender(Gender.MAN.name());</span><br><span class="line"></span><br><span class="line">        PersonDTO personDTO = PersonConverter.INSTANCE.do2dto(personDO);</span><br><span class="line">        System.out.println(personDTO);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PersonDTO(userName=Sakura, age=27, gender=MAN)</span><br></pre></td></tr></table></figure><p>由上面的例子可以看到<code>MapSturct</code>成功将<code>PersonDO</code>转成<code>PersonDTO</code>。</p><h2 id="MapStruct字段映射处理"><a href="#MapStruct字段映射处理" class="headerlink" title="MapStruct字段映射处理"></a>MapStruct字段映射处理</h2><p>两个<code>JavaBean</code>对象进行映射，属性名称一致的字段可以相互映射，不一致的如何处理呢？</p><h3 id="两个字段名字不一致"><a href="#两个字段名字不一致" class="headerlink" title="两个字段名字不一致"></a>两个字段名字不一致</h3><p>从上面的例子可以看出，我们只需要使用<code>@Mapping</code>注解。在转换方法上设置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapping</span>(source = <span class="string">"name"</span>, target = <span class="string">"userName"</span>)</span><br></pre></td></tr></table></figure><p>即可。其含义是将<code>name</code>字段的值映射给<code>userName</code>。</p><h3 id="MapStruct可以映射的类型"><a href="#MapStruct可以映射的类型" class="headerlink" title="MapStruct可以映射的类型"></a>MapStruct可以映射的类型</h3><p>在上面例子，我们发现<code>age</code>字段完成映射，其类型一个为<code>int</code>，另一个为包装类。</p><p><code>gender</code>字段完成映射，其类型一个为枚举，一个为<code>String</code>。</p><p>一般情况下，<code>MapSturct</code>会对部分类型做自动映射，而不需要我们额外配置。</p><ul><li>基本类型及其他们对应的包装类型。</li><li>基本类型的包装类型和String类型之间</li><li>String类型和枚举类型之间</li></ul><h3 id="自定义常量和默认值"><a href="#自定义常量和默认值" class="headerlink" title="自定义常量和默认值"></a>自定义常量和默认值</h3><p>如果我们想在转换中，给某个属性一个固定值，可以使用<code>constant</code>。</p><p>比如<code>PersonDTO</code>里新增身高字段。而<code>PersonDO</code>里没有，那么我们可以在转换时赋予默认值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDTO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Gender gender;</span><br><span class="line">    <span class="keyword">private</span> Integer height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapping</span>(target = <span class="string">"height"</span>,constant = <span class="string">"175"</span>)</span><br></pre></td></tr></table></figure><p>而对于某一个属性，如果映射后为空，我们可以给予其默认值，使用<code>defaultValue</code>，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapping</span>(target = <span class="string">"gender"</span>,defaultValue = <span class="string">"MAN"</span>)</span><br></pre></td></tr></table></figure><h3 id="类型不一致的映射"><a href="#类型不一致的映射" class="headerlink" title="类型不一致的映射"></a>类型不一致的映射</h3><p>在实际转化中，有可能字段类型是不一致的，如何进行映射呢？</p><p>我们使用上面的例子，在<code>PersonDO</code>里增加生日属性，为<code>Date</code>类型，<code>PersonDTO</code>里为<code>String</code>类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDTO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Gender gender;</span><br><span class="line">    <span class="keyword">private</span> Integer height;</span><br><span class="line">    <span class="keyword">private</span> String birthday;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候我们可以使用如下方法转化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapping</span>(source = <span class="string">"name"</span>, target = <span class="string">"userName"</span>)</span><br><span class="line"><span class="meta">@Mapping</span>(target = <span class="string">"height"</span>,constant = <span class="string">"175"</span>)</span><br><span class="line"><span class="meta">@Mapping</span>(target = <span class="string">"birthday"</span>,dateFormat = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span><br><span class="line"><span class="function">PersonDTO <span class="title">do2dto</span><span class="params">(PersonDO person)</span></span>;</span><br></pre></td></tr></table></figure><p>运行后可以看到正确输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PersonDTO(userName=Sakura, age=27, gender=MAN, height=175, birthday=2020-08-17 15:20:16)</span><br></pre></td></tr></table></figure><p><code>dateFormat</code>是<code>MapStruct</code>自带的属性，如果我们的属性映射方法比较复杂呢？</p><p>当然，<code>MapStruct</code>支持我们自定义属性转换的方法，我们来看一下。</p><p>我们新增一个兴趣爱好字段，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; hobbies;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDTO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Gender gender;</span><br><span class="line">    <span class="keyword">private</span> Integer height;</span><br><span class="line">    <span class="keyword">private</span> String birthday;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; strHobbies;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> HobbiesEnum &#123;</span><br><span class="line">    FOOTBALL(<span class="number">1</span>,<span class="string">"足球"</span>),</span><br><span class="line">    READ_BOOK(<span class="number">2</span>,<span class="string">"读书"</span>),</span><br><span class="line">    PLAY_GAME(<span class="number">3</span>,<span class="string">"玩游戏"</span>),</span><br><span class="line">    SINGING(<span class="number">4</span>,<span class="string">"唱歌"</span>),</span><br><span class="line">    TRAVEL(<span class="number">5</span>,<span class="string">"旅行"</span>);</span><br><span class="line">    <span class="keyword">private</span> Integer value;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get/set 构造器略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取一个枚举</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HobbiesEnum <span class="title">getEnum</span><span class="params">(Integer value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(HobbiesEnum.values()).filter(e-&gt;e.value.equals(value)).findFirst().orElse(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要完成<code>List<integer> hobbies</integer></code>对<code>List<string> strHobbies</string></code>的转化，我们可以使用如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonConverter</span> </span>&#123;</span><br><span class="line">    PersonConverter INSTANCE = Mappers.getMapper(PersonConverter.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mapping</span>(source = <span class="string">"name"</span>, target = <span class="string">"userName"</span>)</span><br><span class="line">    <span class="meta">@Mapping</span>(target = <span class="string">"height"</span>,constant = <span class="string">"175"</span>)</span><br><span class="line">    <span class="meta">@Mapping</span>(target = <span class="string">"gender"</span>,defaultValue = <span class="string">"MAN"</span>)</span><br><span class="line">    <span class="meta">@Mapping</span>(target = <span class="string">"birthday"</span>,dateFormat = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span><br><span class="line">    <span class="meta">@Mapping</span>(target = <span class="string">"strHobbies"</span>,expression = <span class="string">"java(getHobbiesStr(person.getHobbies()))"</span>)</span><br><span class="line">    <span class="function">PersonDTO <span class="title">do2dto</span><span class="params">(PersonDO person)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 爱好映射</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> integers</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> List&lt;String&gt; <span class="title">getHobbiesStr</span><span class="params">(List&lt;Integer&gt; integers)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Integer integer : integers) &#123;</span><br><span class="line">            HobbiesEnum hobbiesEnum = HobbiesEnum.getEnum(integer);</span><br><span class="line">            <span class="keyword">if</span>(hobbiesEnum!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                list.add(hobbiesEnum.getDesc());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：java1.8接口支持自定义default方法，<code>expression = “java(getHobbiesStr(person.getHobbies()))”</code>这段代码也可以指向自己写的某个方法，需要具体路径包名。</p><p>上面代码还是非常好理解的，这儿就不过多叙述。</p><h3 id="多个属性映射"><a href="#多个属性映射" class="headerlink" title="多个属性映射"></a>多个属性映射</h3><p><code>MapStruct</code>还支持将多个实体数据组装到一个实体中，如下：</p><p>比如上面的例子，我们的身高属性来自另一个<code>Bean</code>，则代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeightDO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> Integer height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则组装数据的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapping</span>(source = <span class="string">"person.name"</span>, target = <span class="string">"userName"</span>)</span><br><span class="line"><span class="meta">@Mapping</span>(source = <span class="string">"height.height"</span>,target = <span class="string">"height"</span>)</span><br><span class="line"><span class="meta">@Mapping</span>(target = <span class="string">"gender"</span>,defaultValue = <span class="string">"MAN"</span>)</span><br><span class="line"><span class="meta">@Mapping</span>(target = <span class="string">"birthday"</span>,dateFormat = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span><br><span class="line"><span class="meta">@Mapping</span>(target = <span class="string">"strHobbies"</span>,expression = <span class="string">"java(getHobbiesStr(person.getHobbies()))"</span>)</span><br><span class="line"><span class="function">PersonDTO <span class="title">do2dto</span><span class="params">(PersonDO person,HeightDO height)</span></span>;</span><br></pre></td></tr></table></figure><p>对于<code>source</code>属性，需要指定来自哪个<code>DO</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PersonDO personDO = <span class="keyword">new</span> PersonDO();</span><br><span class="line">        personDO.setName(<span class="string">"Sakura"</span>);</span><br><span class="line">        personDO.setAge(<span class="number">27</span>);</span><br><span class="line">        personDO.setId(<span class="number">1</span>);</span><br><span class="line">        personDO.setBirthday(<span class="keyword">new</span> Date());</span><br><span class="line">        personDO.setGender(Gender.MAN.name());</span><br><span class="line">        List&lt;Integer&gt; list  =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line">        personDO.setHobbies(list);</span><br><span class="line"></span><br><span class="line">        HeightDO heightDO = <span class="keyword">new</span> HeightDO();</span><br><span class="line">        heightDO.setHeight(<span class="number">178</span>);</span><br><span class="line"></span><br><span class="line">        PersonDTO personDTO = PersonConverter.INSTANCE.do2dto(personDO,heightDO);</span><br><span class="line">        System.out.println(personDTO);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PersonDTO(userName=Sakura, age=27, gender=MAN, height=178, birthday=2020-08-17 15:52:14, strHobbies=[足球, 玩游戏])</span><br></pre></td></tr></table></figure><h3 id="更新现有Bean实例"><a href="#更新现有Bean实例" class="headerlink" title="更新现有Bean实例"></a>更新现有Bean实例</h3><p><code>MapStruct</code>还支持将一个<code>Bean</code>的属性更新到另一个<code>Bean</code>的同名属性里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateDTOfromDO</span><span class="params">(PersonDO person, @MappingTarget PersonDTO personDTO)</span></span>;</span><br></pre></td></tr></table></figure><p>需要注意这个对于同名属性，如果<code>DO</code>上有值，那么<code>DTO</code>上的值将被覆盖，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PersonDTO dto = <span class="keyword">new</span> PersonDTO();</span><br><span class="line">dto.setAge(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">PersonDO aDo = <span class="keyword">new</span> PersonDO();</span><br><span class="line">aDo.setName(<span class="string">"Sakura"</span>);</span><br><span class="line">aDo.setAge(<span class="number">27</span>);</span><br><span class="line">aDo.setId(<span class="number">1</span>);</span><br><span class="line">aDo.setBirthday(<span class="keyword">new</span> Date());</span><br><span class="line">aDo.setGender(Gender.MAN.name());</span><br><span class="line"></span><br><span class="line">PersonConverter.INSTANCE.updateDTOfromDO(aDo,dto);</span><br><span class="line">System.out.println(dto);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PersonDTO(userName=null, age=27, gender=MAN, height=null, birthday=2020/8/17 下午4:29, strHobbies=null)</span><br></pre></td></tr></table></figure><h3 id="继承反转配置"><a href="#继承反转配置" class="headerlink" title="继承反转配置"></a>继承反转配置</h3><p><code>MapStruct</code>在存在<code>DO</code>转换为<code>DTO</code>的前提下，还支持将<code>DTO</code>转换为<code>DO</code>，而且不用我们复杂的配置。</p><p>方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonConverter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    PersonConverter INSTANCE = Mappers.getMapper(PersonConverter.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mapping</span>(source = <span class="string">"name"</span>, target = <span class="string">"userName"</span>)</span><br><span class="line">    <span class="meta">@Mapping</span>(target = <span class="string">"height"</span>,constant = <span class="string">"175"</span>)</span><br><span class="line">    <span class="meta">@Mapping</span>(target = <span class="string">"gender"</span>,defaultValue = <span class="string">"MAN"</span>)</span><br><span class="line">    <span class="meta">@Mapping</span>(target = <span class="string">"birthday"</span>,dateFormat = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span><br><span class="line">    <span class="meta">@Mapping</span>(target = <span class="string">"strHobbies"</span>,expression = <span class="string">"java(getHobbiesStr(person.getHobbies()))"</span>)</span><br><span class="line">    <span class="function">PersonDTO <span class="title">do2dto</span><span class="params">(PersonDO person)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@InheritInverseConfiguration</span>(name = <span class="string">"do2dto"</span>)</span><br><span class="line">    <span class="function">PersonDO <span class="title">dto2do</span><span class="params">(PersonDTO personDTO)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只需要<code>@InheritInverseConfiguration</code>注解即可解决，<code>name</code>属性指向<code>DO</code>转换为<code>DTO</code>的方法。</p><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PersonDTO dto1 = <span class="keyword">new</span> PersonDTO();</span><br><span class="line">dto1.setAge(<span class="number">27</span>);</span><br><span class="line">dto1.setBirthday(<span class="string">"2018-11-11 12:12:12"</span>);</span><br><span class="line">dto1.setGender(Gender.MAN);</span><br><span class="line">dto1.setHeight(<span class="number">175</span>);</span><br><span class="line">dto1.setUserName(<span class="string">"Sakura"</span>);</span><br><span class="line">List&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list1.add(<span class="string">"足球"</span>);</span><br><span class="line">list1.add(<span class="string">"玩游戏"</span>);</span><br><span class="line">dto1.setStrHobbies(list1);</span><br><span class="line">PersonDO personDO1 = PersonConverter.INSTANCE.dto2do(dto1);</span><br><span class="line">System.out.println(personDO1);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PersonDO(id=null, name=Sakura, age=27, gender=MAN, birthday=Sun Nov 11 12:12:12 CST 2018, hobbies=null)</span><br></pre></td></tr></table></figure><p>这儿需要注意的是我们看到<code>Hobbies</code>属性并没有转化，这是正常的，这个需要我们配置<code>@Mapping</code>，写出并指定兴趣爱好转化的逆向方法。</p><h2 id="MapStruct的性能"><a href="#MapStruct的性能" class="headerlink" title="MapStruct的性能"></a>MapStruct的性能</h2><p><code>MapStruct</code>的性能是非常优秀的，我们来测试一下：</p><p>为简化代码，我们是<code>DO</code>和<code>DTO</code>尽可能的简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDTO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MapStruct</code>相关方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestConverter</span> </span>&#123;</span><br><span class="line">    TestConverter INSTANCE = Mappers.getMapper(TestConverter.class);</span><br><span class="line"></span><br><span class="line">    <span class="function">TestDTO <span class="title">do2dto</span><span class="params">(TestDO testDO)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用<code>Spring</code>自带的<code>BeanUtils</code>工具类来与其进行比较：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NUM = <span class="number">100000</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start1 = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;NUM;i++)&#123;</span><br><span class="line">            TestDO testDO = <span class="keyword">new</span> TestDO();</span><br><span class="line">            testDO.setA(i);</span><br><span class="line">            TestDTO testDTO = <span class="keyword">new</span> TestDTO();</span><br><span class="line">            BeanUtils.copyProperties(testDO,testDTO);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"BeanUtils属性拷贝耗时："</span>+(System.currentTimeMillis()-start1)+<span class="string">"ms"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> start2 = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;NUM;i++)&#123;</span><br><span class="line">            TestDO testDO = <span class="keyword">new</span> TestDO();</span><br><span class="line">            testDO.setA(i);</span><br><span class="line">            TestDTO dto = TestConverter.INSTANCE.do2dto(testDO);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"MapStruct处理耗时："</span>+(System.currentTimeMillis()-start2)+<span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们以100000个对象为样本，得到如下输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BeanUtils属性拷贝耗时：1903ms</span><br><span class="line">MapStruct处理耗时：5ms</span><br></pre></td></tr></table></figure><p>可以看到差距是非常大的。</p><p><code>MapStruct</code>为什么有如此优秀的性能呢？</p><p>其实核心点在于：<code>MapStruct</code>在编译期间，就生成了对象映射代码，确保了高性能，同时编译期间也可以发现可能存在的映射问题。</p><p>在上面的<code>TestConverter</code>中，经过代码编译后，<code>MapStruct</code>会生成一个<code>TestConverterImpl</code>的实现类，帮我们进行对象属性转换。</p><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Generated</span>(</span><br><span class="line">    value = <span class="string">"org.mapstruct.ap.MappingProcessor"</span>,</span><br><span class="line">    date = <span class="string">"2020-08-17T17:00:26+0800"</span>,</span><br><span class="line">    comments = <span class="string">"version: 1.3.1.Final, compiler: javac, environment: Java 9 (Oracle Corporation)"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConverterImpl</span> <span class="keyword">implements</span> <span class="title">TestConverter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestDTO <span class="title">do2dto</span><span class="params">(TestDO testDO)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( testDO == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TestDTO testDTO = <span class="keyword">new</span> TestDTO();</span><br><span class="line"></span><br><span class="line">        testDTO.setA( testDO.getA() );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> testDTO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在运行之前就相当于我们手写<code>get/set</code>方法，相比反射，速度更快。</p><p>其编译工作主要由<code>mapstruct-processor</code>包完成。</p><p>PS：<code>PersonConverterImpl</code>的相关实现这儿就不展示了，大家可以看下它是如何处理的，比如对于一些自定义方法等。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文介绍了一款Java对象映射工具，<code>MapStruct</code>。相比传统<code>BeanUtils</code>有着更高的性能。</p><p>映射代码在编译期间生成，相当于替我们手写了<code>get/set</code>，不仅相比反射具有很好的性能，同时还可以在编译期间发现可能存在的映射问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="MapStruct" scheme="https://www.sakuratears.top/tags/MapStruct/"/>
    
  </entry>
  
  <entry>
    <title>CountDownLatch和CylicBarrier以及Semaphare</title>
    <link href="https://www.sakuratears.top/blog/CountDownLatch%E5%92%8CCylicBarrier%E4%BB%A5%E5%8F%8ASemaphare.html"/>
    <id>https://www.sakuratears.top/blog/CountDownLatch和CylicBarrier以及Semaphare.html</id>
    <published>2020-08-17T12:46:00.000Z</published>
    <updated>2020-08-17T12:48:36.902Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>再说这三个工具时，需要先了解一下AQS框架，所谓AQS，指的是<code>AbstractQueuedSynchronizer</code>，它提供了一种实现阻塞锁和一系列依赖FIFO等待队列的同步器的框架，<code>ReentrantLock</code>、<code>Semaphore</code>、<code>CountDownLatch</code>、<code>CyclicBarrier</code>等并发类均是基于AQS来实现的，具体用法是通过继承AQS实现其模板方法，然后将子类作为同步组件的内部类。</p><p>我们这篇文章先了解下这三个AQS框架工具类，后面在整体入手了解AQS框架的一些特点及源码。</p><p>无论是这几个工具类，还是AQS框架，都是JDK1.5之后出现的，位于<code>java.util.concurrent</code>包下，是由著名的<code>Doug Lea</code>操刀实现并完成设计的。</p><p>PS：<code>ReentrantLock</code>我在另一篇文章有介绍，这儿就不过多叙述。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p><code>CountDownLatch</code> 作为一种同步辅助工具，允许一个或多个线程等待，直到在其他线程中执行的一组操作完成。</p><p>我们可以使用给定的<code>count</code>初始化一个<code>CountDownLatch</code>。</p><p><code>CountDownLatch</code>有两个关键方法，<code>countDown</code>和<code>await</code>。</p><p>当我们调用<code>countDown</code>方法时，<code>await</code>方法会被阻塞，直到计数<code>count</code>为0后，所有的等待线程才会都被释放。</p><p>需要注意<code>CountDownLatch</code>是一次性的，计数不会重置。如果我们需要一个可以重置的计数工具版本，我们可以使用<code>CyclicBarrier</code></p><p>我们可以使用这个同步工具做一些事情，实现一些功能。</p><p>比如初始化一个计数为1的<code>CountDownLatch</code>，可以作为一个简单的开/关锁，或者阀门。所有调用<code>await</code>的线程都在阀门处等待，直到它被一个调用<code>countDown</code>的线程打开。<br>初始化为N的<code>CountDownLatch</code>可以让一个线程等待，直到N个线程已经完成某个动作，或者某个动作已经完成N次。</p><p><code>CountDownLatch</code>的一个特点是，它不要求调用<code>countDown</code>的线程在继续执行之前等待计数为零，它只是阻止任何线程通过<code>await</code>，直到所有线程都通过。</p><p>另一种典型的用法是将一个问题分成N个部分，用<code>Runnable</code>（或<code>Callable</code>）描述每个部分，该<code>Runnable</code>执行该部分并在<code>CountDownLatch</code>上向下计数，然后将所有<code>Runnable</code>排队到一个执行器。当所有子任务完成后，协调线程将能够通过<code>await</code>方法。(当需要重复计数时，请使用<code>CyclicBarrier</code>)</p><p>我们以一个例子来看下<code>CountDownLatch</code>的使用。</p><p>例子：我们以田径赛跑为例，运动员在裁判枪响后同时起跑，因此起跑时需要使用<code>CountDownLatch</code>来控制，跑完后，每个运动员结束时间是不同的，我们需要等所有运动员完成后统计他们的时间进行比较。</p><p>相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//我们以田径跑步运动来进行举例，假设有十名运动员，裁判枪响后起跑，全部跑完后统计成绩。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个定长线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService executorService = Executors.newFixedThreadPool(N);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="comment">//开始标志</span></span><br><span class="line">        CountDownLatch startSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//结束标志</span></span><br><span class="line">        CountDownLatch doneSignal = <span class="keyword">new</span> CountDownLatch(N);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            executorService.submit(<span class="keyword">new</span> Runner(startSignal,doneSignal,i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"起跑预备阶段---&gt;"</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        startSignal.countDown();</span><br><span class="line">        System.out.println(<span class="string">"裁判枪响，所有人开跑---&gt;"</span>);</span><br><span class="line">        doneSignal.await();</span><br><span class="line">        System.out.println(<span class="string">"跑步完成，统计每个人的时间"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runner</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Map</span>&lt;<span class="title">Integer</span>,<span class="title">Integer</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch startSignal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch doneSignal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer i;</span><br><span class="line"></span><br><span class="line">    Runner(CountDownLatch startSignal, CountDownLatch doneSignal,Integer i) &#123;</span><br><span class="line">        <span class="keyword">this</span>.startSignal = startSignal;</span><br><span class="line">        <span class="keyword">this</span>.doneSignal = doneSignal;</span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;Integer,Integer&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> time;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            startSignal.await();</span><br><span class="line">            time = doRun();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">            time = -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            doneSignal.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(i,time);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doRun</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> time = random.nextInt(<span class="number">2000</span>)+<span class="number">10000</span>;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(time);</span><br><span class="line">        System.out.println(<span class="string">"第"</span> +i+ <span class="string">"位运动员"</span> + <span class="string">"running......耗时"</span>+ (<span class="keyword">double</span>)(time)/<span class="number">1000</span> + <span class="string">"秒"</span>);</span><br><span class="line">        <span class="keyword">return</span> time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其具体逻辑如下：</p><ol><li>预备起跑阶段（主线程sleep 10s用于模拟准备），一个名为<code>startSignal</code>的<code>CountDownLatch</code>模拟裁判，计数为1。</li><li>使用<code>startSignal.countDown()</code>方法对每个<code>Runner</code>的<code>doRun();</code>进行阻塞（<code>startSignal.await();</code>），模拟裁判发枪。</li><li>发枪后<code>startSignal.await();</code>方法通过，每个<code>Runner</code>执行自己的<code>doRun();</code>方法完成跑步。</li><li>在统计最后成绩时，使用了<code>doneSignal</code>，计数为N，我们只有当全部运动员完成后才能对其进行排名。</li></ol><p>相关输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">起跑预备阶段---&gt;</span><br><span class="line">裁判枪响，所有人开跑---&gt;</span><br><span class="line">第9位运动员running......耗时10.169秒</span><br><span class="line">第8位运动员running......耗时10.279秒</span><br><span class="line">第7位运动员running......耗时10.432秒</span><br><span class="line">第0位运动员running......耗时10.465秒</span><br><span class="line">第1位运动员running......耗时10.633秒</span><br><span class="line">第5位运动员running......耗时10.748秒</span><br><span class="line">第2位运动员running......耗时10.993秒</span><br><span class="line">第3位运动员running......耗时11.333秒</span><br><span class="line">第6位运动员running......耗时11.337秒</span><br><span class="line">第4位运动员running......耗时11.847秒</span><br><span class="line">跑步完成，统计每个人的时间</span><br></pre></td></tr></table></figure><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p><code>CyclicBarrier</code>一种同步辅助工具，它允许一组线程都等待对方到达公共障碍点。<br>在涉及固定大小的线程的程序中，CyclicBarriers非常有用，这些线程必须偶尔相互等待。</p><p>该屏障之所以称为循环屏障（<code>CyclicBarrier</code>），是因为它可以在等待的线程被释放之后被重用。</p><p><code>CyclicBarrier</code>支持一个可选的“<code>Runnable</code>”命令，该命令在每个屏障点运行一次，在队列中的最后一个线程到达之后，但是在所有线程被释放之前运行。可通过构造函数传入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个屏障操作对于在任何一个线程继续之前更新共享状态非常有帮助的。</p><p>我们下面来看个例子，这儿我们使用大文件拆分成小文件进行上传来举例。如下，先上代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个可缓存的线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        List&lt;<span class="keyword">byte</span>[]&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (FileInputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"C:\\Users\\DELL-3020\\Desktop\\hacker's delight.pdf"</span>))&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024000</span>];</span><br><span class="line">            <span class="comment">// 读入多个字节到字节数组中，byteRead为一次读入的字节数</span></span><br><span class="line">            <span class="keyword">while</span> (input.read(buffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">                list.add(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(list.size(),()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">"上传已全部完成"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        List&lt;Future&lt;Boolean&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            Future&lt;Boolean&gt; future =  executorService.submit(<span class="keyword">new</span> UploadHelper(i,list.get(i),cyclicBarrier));</span><br><span class="line">            futures.add(future);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (Future&lt;Boolean&gt; future : futures) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!future.get().equals(Boolean.TRUE))&#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"上传结果"</span>+flag);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UploadHelper</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> N;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] bytes;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier barrier;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UploadHelper</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">byte</span>[] bytes, CyclicBarrier barrier)</span> </span>&#123;</span><br><span class="line">        N = n;</span><br><span class="line">        <span class="keyword">this</span>.bytes = bytes;</span><br><span class="line">        <span class="keyword">this</span>.barrier = barrier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = doUpload(N,bytes);</span><br><span class="line">        barrier.await();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上传逻辑</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doUpload</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">byte</span>[] bytes)</span></span>&#123;</span><br><span class="line">        <span class="comment">//假设的上传逻辑</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">            Random random = <span class="keyword">new</span> Random();</span><br><span class="line">            <span class="keyword">int</span> time = random.nextInt(<span class="number">2000</span>)+<span class="number">10000</span>;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(time);</span><br><span class="line">            System.out.println(<span class="string">"第"</span>+ n + <span class="string">"份数据上传耗时"</span>+ (<span class="keyword">double</span>)(time)/<span class="number">1000</span> + <span class="string">"秒"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>UploadHelper</code>类用来处理上传逻辑，我们将文件按照1M（1024000bit）进行分割，<code>UploadHelper</code>接受三个参数，n表示第多少份，用于上传完成后数据的按顺序拼接。bytes表示每份的数据。barrier屏障用于监测所有上传是否完成，完成后执行新的逻辑（比如通知用户上传完成等）。</p><p>我们运行后，结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">第8份数据上传耗时10.399秒</span><br><span class="line">第3份数据上传耗时10.466秒</span><br><span class="line">第0份数据上传耗时10.609秒</span><br><span class="line">第2份数据上传耗时10.71秒</span><br><span class="line">第6份数据上传耗时10.915秒</span><br><span class="line">第9份数据上传耗时11.093秒</span><br><span class="line">第10份数据上传耗时11.167秒</span><br><span class="line">第5份数据上传耗时11.2秒</span><br><span class="line">第1份数据上传耗时11.521秒</span><br><span class="line">第7份数据上传耗时11.536秒</span><br><span class="line">第4份数据上传耗时11.905秒</span><br><span class="line">上传已全部完成</span><br><span class="line">上传结果true</span><br></pre></td></tr></table></figure><p>可以看到<code>上传已全部完成</code>是在上传全部完成后输出的，这句话在<code>CyclicBarrier</code>构造器的<code>Runnable</code>参数里。</p><p>其实这儿我们也可以模拟一个接受逻辑，通过屏障操作，当我们接收到全部数据后，最后将所有数据合并在一起。</p><p>这儿的代码就交给大家去实现了。</p><p>这儿有一点需要注意，如果屏障操作(barrier)不依赖于被挂起的线程，那么任何线程都可以在它被释放时执行我们想要的动作。为实现这一点，调用<code>await</code>方法会返回<code>barrier</code>处该线程的到达索引。然后我们可以选择哪个线程执行<code>barrier</code>操作。</p><p>比如我们在<code>UploadHelper</code>的<code>call()</code>方法里添上如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = doUpload(N,bytes);</span><br><span class="line">    <span class="keyword">if</span>(barrier.await()==N)&#123;</span><br><span class="line">        System.out.println(<span class="string">"第"</span>+N+<span class="string">"个线程执行barrier操作"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以多次运行，可以发现每次barrier的线程都是不一样的。有可能有一个，也有可能多个。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">第4份数据上传耗时10.04秒</span><br><span class="line">第1份数据上传耗时10.196秒</span><br><span class="line">第2份数据上传耗时10.235秒</span><br><span class="line">第3份数据上传耗时10.282秒</span><br><span class="line">第6份数据上传耗时10.547秒</span><br><span class="line">第9份数据上传耗时10.713秒</span><br><span class="line">第5份数据上传耗时10.784秒</span><br><span class="line">第7份数据上传耗时11.146秒</span><br><span class="line">第10份数据上传耗时11.68秒</span><br><span class="line">第8份数据上传耗时11.787秒</span><br><span class="line">第0份数据上传耗时11.864秒</span><br><span class="line">上传已全部完成</span><br><span class="line">第0个线程执行barrier操作</span><br><span class="line">第6个线程执行barrier操作</span><br><span class="line">上传结果true</span><br></pre></td></tr></table></figure><p>这时候我们可以把<code>barrier.await()==N</code> 变为<code>barrier.await()==5</code>就可以让第5个线程执行barrier操作，而不是其他的线程执行<code>barrier</code>。</p><p><code>CyclicBarrier</code>使用了<code>“all-or-none breakage”</code>模型，指的是所有互相等待的线程，要么一起通过<code>barrier</code>，要么一个都不要通过。</p><p>如果有一个线程因为中断、失败或者超时等原因失败了，则barrier会被<code>broken</code>，所有等待在该<code>barrier</code>上的线程都会抛出<code>BrokenBarrierException</code>（或者<code>InterruptedException</code>）。</p><p>比如我们在<code>UploadHelper</code>类里<code>doUpload</code>方法里添加如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设第5个线程异常了</span></span><br><span class="line"><span class="keyword">if</span>(N==<span class="number">5</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"第"</span>+N+<span class="string">"个线程处理出现异常"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们执行后可以发现上传永远完成不了，其它线程会在<code>barrier</code>处永远等待。</p><p>所以我们在编写代码时在内部方法要处理好可能出现的异常问题。</p><p>另外<code>CyclicBarrier</code>提供了一个<code>await(long timeout, TimeUnit unit)</code>方法，我们可以指定<code>await</code>的最长时间。</p><p>我们指定<code>await</code>时间为15s，同时在<code>doUpload</code>方法里设定第5个线程执行出现异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = doUpload(N,bytes);</span><br><span class="line">    barrier.await(<span class="number">15</span>,TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doUpload</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">byte</span>[] bytes)</span></span>&#123;</span><br><span class="line">    <span class="comment">//假设的上传逻辑</span></span><br><span class="line">    <span class="keyword">if</span>(N==<span class="number">5</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"第"</span>+N+<span class="string">"个线程处理出现异常"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> time = random.nextInt(<span class="number">2000</span>)+<span class="number">10000</span>;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(time);</span><br><span class="line">        System.out.println(<span class="string">"第"</span>+ n + <span class="string">"份数据上传耗时"</span>+ (<span class="keyword">double</span>)(time)/<span class="number">1000</span> + <span class="string">"秒"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行后我们就会看到<code>BrokenBarrierException</code>的出现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">第10份数据上传耗时10.037秒</span><br><span class="line">第2份数据上传耗时10.229秒</span><br><span class="line">第9份数据上传耗时10.287秒</span><br><span class="line">第0份数据上传耗时10.799秒</span><br><span class="line">第3份数据上传耗时11.025秒</span><br><span class="line">第4份数据上传耗时11.111秒</span><br><span class="line">第6份数据上传耗时11.863秒</span><br><span class="line">第8份数据上传耗时11.887秒</span><br><span class="line">第1份数据上传耗时11.904秒</span><br><span class="line">第7份数据上传耗时11.961秒</span><br><span class="line">Exception in thread &quot;main&quot; java.util.concurrent.ExecutionException: java.util.concurrent.BrokenBarrierException</span><br><span class="line">at java.base/java.util.concurrent.FutureTask.report(FutureTask.java:122)</span><br><span class="line">at java.base/java.util.concurrent.FutureTask.get(FutureTask.java:191)</span><br><span class="line">at com.zwt.helputils.utils.aqs.CyclicBarrierDemo.main(CyclicBarrierDemo.java:44)</span><br><span class="line">Caused by: java.util.concurrent.BrokenBarrierException</span><br><span class="line">at java.base/java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:251)</span><br><span class="line">at java.base/java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:436)</span><br><span class="line">at com.zwt.helputils.utils.aqs.UploadHelper.call(CyclicBarrierDemo.java:66)</span><br><span class="line">at com.zwt.helputils.utils.aqs.UploadHelper.call(CyclicBarrierDemo.java:52)</span><br><span class="line">at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)</span><br><span class="line">at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)</span><br><span class="line">at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)</span><br><span class="line">at java.base/java.lang.Thread.run(Thread.java:844)</span><br></pre></td></tr></table></figure><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p><code>Semaphore</code>也被称为计数信号量，从概念上来讲，它维护一组许可。</p><p>主要方法有两个，<code>acquire</code>和<code>release</code>，<code>acquire</code>方法用来阻止获取者获得资源许可，直到许可存在可用的为止。<code>release</code>用于添加一个许可，潜在的意义相当于释放了一个阻塞的获取者。</p><p>需要注意的是<code>Semaphore</code>并不会保存可用资源对象，而是只保留可用资源数量的计数，并进行许可或阻塞操作。</p><p><code>Semaphore</code>通常用于限制能够访问某些(物理或逻辑)资源的线程数量。</p><p>比如我们有一个方法，如果需要对其进行并发限制，可以使用<code>Semaphore</code>来实现，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定数量为5的Semaphore</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span><span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="comment">//假设方法需要执行5s</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        log.info(<span class="string">"这是test方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 并发限制</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">limit</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        semaphore.acquire();</span><br><span class="line">        doSomething();</span><br><span class="line">        semaphore.release();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        SemaphoreDemo semaphoreDemo = <span class="keyword">new</span> SemaphoreDemo();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphoreDemo.limit();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码指定数量为5的<code>Semaphore</code>，<code>limit()</code>方法用来进行并发控制，如上代码的意思是最多允许5个线程调用<code>doSomething()</code>方法。</p><p>输出如下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">15:14:50.471 [Thread-1] INFO com.zwt.helputils.utils.aqs.SemaphoreDemo - 这是test方法</span><br><span class="line">15:14:50.470 [Thread-0] INFO com.zwt.helputils.utils.aqs.SemaphoreDemo - 这是test方法</span><br><span class="line">15:14:50.471 [Thread-7] INFO com.zwt.helputils.utils.aqs.SemaphoreDemo - 这是test方法</span><br><span class="line">15:14:50.471 [Thread-2] INFO com.zwt.helputils.utils.aqs.SemaphoreDemo - 这是test方法</span><br><span class="line">15:14:50.470 [Thread-3] INFO com.zwt.helputils.utils.aqs.SemaphoreDemo - 这是test方法</span><br><span class="line">//...注意这儿停顿5s</span><br><span class="line">15:14:55.476 [Thread-6] INFO com.zwt.helputils.utils.aqs.SemaphoreDemo - 这是test方法</span><br><span class="line">15:14:55.476 [Thread-11] INFO com.zwt.helputils.utils.aqs.SemaphoreDemo - 这是test方法</span><br><span class="line">15:14:55.476 [Thread-5] INFO com.zwt.helputils.utils.aqs.SemaphoreDemo - 这是test方法</span><br><span class="line">15:14:55.476 [Thread-4] INFO com.zwt.helputils.utils.aqs.SemaphoreDemo - 这是test方法</span><br><span class="line">15:14:55.477 [Thread-13] INFO com.zwt.helputils.utils.aqs.SemaphoreDemo - 这是test方法</span><br><span class="line">//...注意这儿停顿5s</span><br><span class="line">15:15:00.477 [Thread-12] INFO com.zwt.helputils.utils.aqs.SemaphoreDemo - 这是test方法</span><br><span class="line">15:15:00.477 [Thread-14] INFO com.zwt.helputils.utils.aqs.SemaphoreDemo - 这是test方法</span><br><span class="line">15:15:00.477 [Thread-10] INFO com.zwt.helputils.utils.aqs.SemaphoreDemo - 这是test方法</span><br><span class="line">15:15:00.478 [Thread-9] INFO com.zwt.helputils.utils.aqs.SemaphoreDemo - 这是test方法</span><br><span class="line">15:15:00.478 [Thread-8] INFO com.zwt.helputils.utils.aqs.SemaphoreDemo - 这是test方法</span><br></pre></td></tr></table></figure><p>当我们初始化数量为1的<code>Semaphore</code>时，此时只有一个可用许可，因此可以当做互斥锁来用。这种通常称为二进制信号量，因为它只有两种状态：1个可用许可，0个可用许可。</p><p>当我们使用这种方式时，相比较<code>java.util.concurrent.locks</code>包的锁实现，它有一些额外的特点：即“锁”可以由所有者以外的线程释放，因为<code>Semaphore</code>没有所有权的概念。</p><p>这在某些情况下是十分有用的，比如死锁恢复。</p><p>除了数量以外，<code>Semaphore</code>构造函数还可以接受一个“公平性”参数。</p><p>当参数设置为<code>false</code>时，<code>Semaphore</code>不能保证线程获得许可的顺序。也就是说，抢占是允许的，调用<code>acquire</code>的线程可以比正在等待的线程提前分配许可 ———— 逻辑上，新线程将自己放在等待线程队列的头部。</p><p>当参数为<code>true</code>时，<code>Semaphore</code>保证调用<code>acquire</code>方法的线程按照顺序获得许可（先进先出FIFO）。需要注意FIFO的顺序适用于这些方法中特定的内部执行点。因此，一个线程可能在另一个线程之前调用<code>acquire</code>，但是在另一个线程之后到达顺序点，从该方法返回时也是如此。另外，<code>tryAcquire</code>方法不支持公平性设置，但是会接受任何可用的许可。</p><p>通常，用于控制资源访问的<code>Semaphore</code>应该初始化为公平，以确保没有线程因为访问资源而耗尽。当将<code>Semaphore</code>用于其他类型的同步控制时，非公平的吞吐量优势常常超过公平性<code>Semaphore</code>。</p><p>另外，<code>Semaphore</code>还提供了<code>acquire(int)</code>和<code>release(int)</code>等方便方法，这些方法通常比循环更有效。</p><p>但是，它们没有优先顺序，例如，如果线程A调用<code>s.acquire(3)</code>，线程B调用<code>s.acquire(2)</code>，并且有两个许可可用，那么不能保证线程B会获得它们，除非它的<code>acquire</code>先来，并且信号量<code>s</code>处于公平模式。</p><h2 id="AbstractQueuedSynchronizer"><a href="#AbstractQueuedSynchronizer" class="headerlink" title="AbstractQueuedSynchronizer"></a>AbstractQueuedSynchronizer</h2><p>我们可以看到无论是<code>CountDownLatch</code>、<code>CyclicBarrier</code>（底层<code>ReentrantLock</code>）、<code>Semaphore</code>还是<code>ReentrantLock</code>，底层均是由<code>AbstractQueuedSynchronizer</code>实现的。</p><p>我们将在后面来分析下AQS框架的一些特点和源码。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文对<code>CountDownLatch</code>、<code>CyclicBarrier</code>和<code>Semaphore</code>进行了一些分析，列举的它们的一些特点和用法。</p><p>对于<code>CountDownLatch</code>，其是在做减法，本身不能重置计数，只能使用一次。</p><p><code>CyclicBarrier</code>是做加法，通过<code>reset()</code>方法可以重置计数，可以多次使用，不过重置需要等到计数结束。</p><p><code>Semaphore</code>主要控制对资源的访问，可以实现控制并发线程的数量，而<code>CountDownLatch</code>和<code>CyclicBarrier</code>是无法实现此功能的，而且<code>Semaphore</code>在控制资源访问时，本身相当于信号量控制标识，不会对资源本身加锁。</p><p>以上就是三种线程同步工具的全部内容。</p><h1 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h1><p>相关代码可在我的<a href="https://github.com/javazwt" rel="external nofollow noopener noreferrer" target="_blank">GitHub</a>上找到。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="CountDownLatch" scheme="https://www.sakuratears.top/tags/CountDownLatch/"/>
    
      <category term="CylicBarrier" scheme="https://www.sakuratears.top/tags/CylicBarrier/"/>
    
      <category term="Semaphare" scheme="https://www.sakuratears.top/tags/Semaphare/"/>
    
  </entry>
  
  <entry>
    <title>工作中遇到的问题总结</title>
    <link href="https://www.sakuratears.top/blog/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.html"/>
    <id>https://www.sakuratears.top/blog/工作中遇到的问题总结.html</id>
    <published>2020-08-09T01:27:00.000Z</published>
    <updated>2021-01-10T10:09:09.712Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="工作问题总结"><a href="#工作问题总结" class="headerlink" title="工作问题总结"></a>工作问题总结</h1><p>总结了工作中遇到的一些问题及bug。</p><h2 id="Mysql-group-by-不区分大小写的问题"><a href="#Mysql-group-by-不区分大小写的问题" class="headerlink" title="Mysql group by 不区分大小写的问题"></a>Mysql group by 不区分大小写的问题</h2><p>在Mysql中，如果不特意指定字段，字段数据在group by时是不区分大小写的。</p><p>如下图：</p><p>对于user表，我们有4个用户，通过user_name group by之后我们只得到了两条数据。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-648.jpg" alt="upload successful"></p><p>可以看到，如果不特殊处理的话，Mysql在group by时是不区分大小写的。</p><p>解决方案有两个，都是通过<code>BINARY</code>关键字解决：</p><p><code>BINARY</code> 运算符将紧随其后的<code>string</code> 转换为 二进制字符串。</p><p>主要用来强制进行按字节进行比较的数据。这使得字符串比较是区分大小写的, 不管原始的列定义是否是 <code>BINARY</code> 或者 <code>BLOB</code>。<code>BINARY</code> 也对字符串末尾的空格敏感。</p><ol><li><p>对于查询，我们使用<code>BINARY</code> 关键字。如下图效果：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_name,<span class="keyword">COUNT</span>(<span class="number">1</span>) <span class="keyword">from</span> <span class="string">`user`</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="built_in">BINARY</span> user_name;</span><br></pre></td></tr></table></figure><p> <img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-649.jpg" alt="upload successful"></p><p> 可以看到得到了我们想要的结果。</p></li><li><p>当然也可以给表结构字段添加<code>BINARY</code>来解决，这会改变表的字符集及排序规则。</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`user`</span></span><br><span class="line"><span class="keyword">MODIFY</span> <span class="keyword">COLUMN</span> <span class="string">`user_name`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="built_in">BINARY</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户名'</span>;</span><br></pre></td></tr></table></figure><p> 得到的表结构如下，我们再进行group by查询，可以看到指定字段已经区分了大小写。</p><p> <img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-650.jpg" alt="upload successful"></p><p> 当然对于大小写敏感的字段数据，我们可以在建表的时候直接指定字段的字符集及排序规则。</p></li></ol><h2 id="List去重问题"><a href="#List去重问题" class="headerlink" title="List去重问题"></a>List去重问题</h2><ol><li><p>当然我们可以使用Set进行去重。</p></li><li><p>对于Java 8之后，我们可以使用流进行去重，如下语法：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().distinct().collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>对于对象列表的话，我们应重写对象的<code>hashCode()</code>和<code>equals()</code>方法，再使用流的<code>distinct()</code>方法来进行去重。</p><p><code>distinct()</code>方法不提供按照属性对对象列表进行去重的直接实现。它是基于<code>hashCode()</code>和<code>equals()</code>工作的。</p><p>我们如果想按照属性对对象列表进行去重，除了使用普通循环处理外，还可以构建一个我们自己的<code>Predicate</code>实例，通过流过滤来实现，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createDate;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Phone</span><span class="params">(String phone, LocalDateTime createDate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.phone = phone;</span><br><span class="line">        <span class="keyword">this</span>.createDate = createDate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Phone&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> Phone(<span class="string">"11111"</span>, LocalDateTime.of(<span class="number">2020</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">11</span>,<span class="number">00</span>,<span class="number">00</span>)));</span><br><span class="line">        list.add(<span class="keyword">new</span> Phone(<span class="string">"22222"</span>, LocalDateTime.of(<span class="number">2020</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">00</span>,<span class="number">00</span>)));</span><br><span class="line">        list.add(<span class="keyword">new</span> Phone(<span class="string">"44444"</span>, LocalDateTime.of(<span class="number">2020</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">00</span>,<span class="number">00</span>)));</span><br><span class="line">        list.add(<span class="keyword">new</span> Phone(<span class="string">"11111"</span>, LocalDateTime.of(<span class="number">2020</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">00</span>,<span class="number">00</span>)));</span><br><span class="line">        list.add(<span class="keyword">new</span> Phone(<span class="string">"22222"</span>, LocalDateTime.of(<span class="number">2020</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">11</span>,<span class="number">00</span>,<span class="number">00</span>)));</span><br><span class="line"></span><br><span class="line">        list.stream().filter(distinctByKey(Phone::getCreateDate)).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Predicate&lt;T&gt; <span class="title">distinctByKey</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ?&gt; keyExtractor)</span> </span>&#123;</span><br><span class="line">        Map&lt;Object,Boolean&gt; seen = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> t -&gt; seen.putIfAbsent(keyExtractor.apply(t), Boolean.TRUE) == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其关键方法就是<code>distinctByKey</code>方法，这个方法原理很简单，我们将对象属性放入HashMap中，通过它的<code>putIfAbsent</code>来判断是否放入成功，不成功返回false，<code>filter</code>自动过滤此对象。</p><p>上面的例子中，我们如果在对phone号码进行去重的时候，只想要时间比较新的怎么办呢？</p><p>很简单，我们只需在处理是先对流按照时间进行排序即可，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list.stream().sorted(Comparator.comparing(Phone::getCreateDate).reversed())</span><br><span class="line">                .filter(distinctByKey(Phone::getCreateDate)).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h2 id="Mysql字符集问题"><a href="#Mysql字符集问题" class="headerlink" title="Mysql字符集问题"></a>Mysql字符集问题</h2><p>我在插入Mysql数据库表情等特殊符号时遇到了如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">......Cause: java.sql.SQLException: Incorrect string value: &apos;\xF0\x9D\x91\x80\xF0\x9D...&apos; for column &apos;xxxxx&apos; at row 1......</span><br></pre></td></tr></table></figure><p>如果我们的目标表字符集设置的是<code>CHARSET=utf8mb4</code>但仍是有这种问题，可能是Mysql数据库连接的字符集不正确。</p><p>我们可以通过<code>SHOW VARIABLES LIKE ‘character_set_%’;</code>来查看当前Mysql数据库连接字符集。如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-651.jpg" alt="upload successful"></p><p>其中：</p><ul><li>character_set_client：指客户端字符集属性</li><li>character_set_connection：指连接字符集属性</li><li>character_set_database：指数据库字符集属性</li><li>character_set_filesystem：指文件系统字符集属性</li><li>character_set_results：指返回结果字符集属性</li><li>character_set_server：指服务端字符集属性</li><li>character_set_system：指系统字符集属性</li><li>character_sets_dir：指字符集路径</li></ul><p>影响我们保存和读取的主要为<code>character_set_client</code>、<code>character_set_connection</code>和<code>character_set_results</code>这三个属性。</p><p>比如下面图示，我们保存数据失败了。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-652.jpg" alt="upload successful"></p><p>这时候我们设置一下这三个属性为<code>utf8mb4</code>即可。如下:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SET</span> character_set_client = utf8mb4;</span><br><span class="line"><span class="built_in">SET</span> character_set_results = utf8mb4;</span><br><span class="line"><span class="built_in">SET</span> character_set_connection = utf8mb4;</span><br></pre></td></tr></table></figure><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-653.jpg" alt="upload successful"></p><p>PS:这时候该表的<code>CHARSET</code>需要为<code>utf8mb4</code>。</p><p>这三个设置也可以用一条设置代替。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SET</span> NAMES 'utf8mb4';</span><br></pre></td></tr></table></figure><p>需要注意的是这种设置只在本次连接中有效，当连接中断时，需要重新设置。</p><p>我们在开发时，程序调用，可以通过<code>jdbcUrl</code>进行设置。如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbc.url=jdbc:mysql://xx:xx:xxx:xxx/test?useUnicode=true&amp;amp;characterEncoding=utf8mb4</span><br></pre></td></tr></table></figure><p>出现上面异常一般的解决步骤：</p><ol><li><p>检查数据表字符集是不是<code>utf8mb4</code>，不是的话需要通过如下语句进行修改。</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name [[<span class="keyword">DEFAULT</span>] <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> charset_name] [<span class="keyword">COLLATE</span> collation_name]</span><br></pre></td></tr></table></figure></li><li><p>检查<code>character_set_client</code>、<code>character_set_connection</code>和<code>character_set_results</code>这三个属性的设置，一般情况下我们在程序里配置<code>characterEncoding=utf8mb4</code>即可。</p></li></ol><h2 id="Java-过滤-utf8mb4-字符"><a href="#Java-过滤-utf8mb4-字符" class="headerlink" title="Java 过滤 utf8mb4 字符"></a>Java 过滤 utf8mb4 字符</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 过滤utf8mb4字符</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> text</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">filterOffUtf8Mb4</span><span class="params">(String text)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = text.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(bytes.length);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; bytes.length) &#123;</span><br><span class="line">        <span class="keyword">short</span> b = bytes[i];</span><br><span class="line">        <span class="keyword">if</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            buffer.put(bytes[i++]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 去掉符号位</span></span><br><span class="line">        b += <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (((b &gt;&gt; <span class="number">5</span>) ^ <span class="number">0x6</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            buffer.put(bytes, i, <span class="number">2</span>);</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (((b &gt;&gt; <span class="number">4</span>) ^ <span class="number">0xE</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            buffer.put(bytes, i, <span class="number">3</span>);</span><br><span class="line">            i += <span class="number">3</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (((b &gt;&gt; <span class="number">3</span>) ^ <span class="number">0x1E</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            i += <span class="number">4</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (((b &gt;&gt; <span class="number">2</span>) ^ <span class="number">0x3E</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            i += <span class="number">5</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (((b &gt;&gt; <span class="number">1</span>) ^ <span class="number">0x7E</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            i += <span class="number">6</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            buffer.put(bytes[i++]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    buffer.flip();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(buffer.array(), StandardCharsets.UTF_8);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法可以过滤掉utf8mb4字符（4字节的UTF-8字符）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="工作" scheme="https://www.sakuratears.top/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Java代理模式</title>
    <link href="https://www.sakuratears.top/blog/Java%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.html"/>
    <id>https://www.sakuratears.top/blog/Java代理模式.html</id>
    <published>2020-08-02T09:36:00.000Z</published>
    <updated>2021-01-10T10:08:11.738Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>代理(Proxy)是一种设计模式，提供了间接对目标对象进行访问的方式，即通过代理对象访问目标对象。</p><p>这样做的好处是：可以在目标对象实现的功能上，增加额外的功能补充，即扩展目标对象的功能。</p><p>这就符合了设计模式的开闭原则，即在对既有代码不改动的情况下进行功能的扩展。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>我们一般认为Java中有三种代理模式：静态代理、动态代理和Cglib代理。</p><p>其中Cglib代理需要借助cglib三方jar包实现。</p><p>我们来看下三种代理模式，以及它们的一些特点。</p><p>我们下面以代码来看下代理的例子。</p><p>我们现在有一个<code>Subject</code>接口，同时有两个实现类<code>RunSubject</code>和<code>SingSubject</code>，接口中有一个方法<code>doSomething</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 做一些事</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doSomething</span><span class="params">(String str)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doSomething</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(str + <span class="string">" running..."</span>);</span><br><span class="line">        <span class="keyword">return</span> str + <span class="string">" running..."</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doSomething</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(str+<span class="string">" singing..."</span>);</span><br><span class="line">        <span class="keyword">return</span> str+<span class="string">" singing..."</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们想在<code>doSomething</code>之前和之后记录一些日志，如何实现呢。</p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>静态代理在使用时，需要定义接口或者父类，被代理对象与代理对象一起实现相同的接口或者是继承相同父类。从而实现我们想要的功能。</p><p>根据上面所说，我们可以定义一个StaticProxy类实现此功能，该类需要实现<code>Subject</code>接口，当然，我们也需要被代理对象，以实现我们<code>doSomething</code>的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkStaticProxyImpl</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 被代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Subject subject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JdkStaticProxyImpl</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doSomething</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用之前的逻辑</span></span><br><span class="line">        System.out.println(<span class="string">"在方法调用之前记录日志-----&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        String returnValue = subject.doSomething(str);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用之后的逻辑</span></span><br><span class="line">        System.out.println(<span class="string">"在方法调用之后记录日志-----&gt;"</span>);</span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subject runSubject = <span class="keyword">new</span> RunSubject();</span><br><span class="line">        Subject subject = <span class="keyword">new</span> JdkStaticProxyImpl(runSubject);</span><br><span class="line">        subject.doSomething(<span class="string">"ccc"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在方法调用之前记录日志-----&gt;</span><br><span class="line">ccc running...</span><br><span class="line">在方法调用之后记录日志-----&gt;</span><br></pre></td></tr></table></figure><p>这种代理方法优点是可以在不修改目标对象的功能前提下，对目标功能扩展。</p><p>但缺点也十分明显，上面只是对于<code>Subject</code>的代理，如果我们有其他的接口及其实现类，如果也需要该扩展功能，那么也要为其写代理类。</p><p>会导致我们会有很多代理类，且如果接口增加方法，那么我们也需要修改代理类，即便这个新增的方法可能不需要额外扩展功能。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>上面静态代理的缺点比较明显，如何解决呢？</p><p>我们可以使用动态代理，Java中为我们提供了生成代理对象的API，<code>java.lang.reflect.Proxy</code>。</p><p>实现代理需要调用<code>newProxyInstance</code>方法，它接受三个参数，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>ClassLoader loader：指定当前目标对象使用类加载器，获取加载器的方法是固定的，我们一般使用 <code>getClass().getClassLoader();</code>即可获取目标对象的类加载器。</li><li>Class&lt;?&gt;[] interfaces：目标对象实现的接口的类型，使用泛型方式确认类型，一般使用<code>getClass().getInterfaces();</code>方式取得。</li><li>InvocationHandler h：事件处理，执行目标对象的方法时，会触发事件处理器的方法，会把当前执行目标对象的方法作为参数传入。这个需要我们手动实现要实现的扩展功能。</li></ul><p>对于上面的<code>Subject</code>接口的实现类<code>RunSubject</code>和<code>SingSubject</code>，我们以代码来看下JDK动态代理如何实现功能扩展。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicProxyImpl</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object subject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JdkDynamicProxyImpl</span><span class="params">(Object subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//调用之前的逻辑</span></span><br><span class="line">        System.out.println(<span class="string">"在"</span>+method+<span class="string">"方法调用之前记录日志-----&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用</span></span><br><span class="line">        Object returnValue = method.invoke(subject, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用之后的逻辑</span></span><br><span class="line">        System.out.println(<span class="string">"在"</span>+method+<span class="string">"方法调用之后记录日志-----&gt;"</span>);</span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subject runSubject = <span class="keyword">new</span> RunSubject();</span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> JdkDynamicProxyImpl(runSubject);</span><br><span class="line">        ClassLoader loader = runSubject.getClass().getClassLoader();</span><br><span class="line">        Class[] interfaces = runSubject.getClass().getInterfaces();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Subject subject = (Subject) Proxy.newProxyInstance(loader, interfaces, handler);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"动态代理对象的类型："</span>+subject.getClass().getName());</span><br><span class="line"></span><br><span class="line">        subject.doSomething(<span class="string">"aaa"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行后如下输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">动态代理对象的类型：com.sun.proxy.$Proxy0</span><br><span class="line">在public abstract java.lang.String com.zwt.helputils.utils.proxy.Subject.doSomething(java.lang.String)方法调用之前记录日志-----&gt;</span><br><span class="line">aaa running...</span><br><span class="line">在public abstract java.lang.String com.zwt.helputils.utils.proxy.Subject.doSomething(java.lang.String)方法调用之后记录日志-----&gt;</span><br></pre></td></tr></table></figure><p>上面的<code>JdkDynamicProxyImpl</code>类，我们不仅可以用来代理<code>Subject</code>接口的实现类以实现日志增强功能，如果别的类（比如A）也想实现日志增强，那么只需要A实现一个自己的接口 AInterface 即可。</p><p>可以看到，对于一种增强，我们创建一个代理类即可，这比静态代理要方便简洁很多。</p><p>但这种动态代理有一个缺陷，就是被代理对象（目标对象）一定要实现接口，否则无法实现动态代理。</p><h2 id="Cglib代理"><a href="#Cglib代理" class="headerlink" title="Cglib代理"></a>Cglib代理</h2><p>上面的两种代理方式，也可以认为JDK传统的代理方式，目标对象必须实现接口，否则无法完成代理，但实际中，不一定所有的对象都会实现接口。</p><p>对于没有接口的对象，如果要实现对其的代理，应该如何实现呢？</p><p>我们可以使用继承目标类以目标对象子类的方式实现代理，这种方法就叫做Cglib代理，也叫作子类代理，它是在内存中构建一个子类对象从而实现对目标对象功能的扩展。</p><p>要实现Cglib代理，需要引入三方Cglib包，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/cglib/cglib --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cglib&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxyImpl</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CglibProxyImpl</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">// 回调方法</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//调用之前的逻辑</span></span><br><span class="line">        System.out.println(<span class="string">"在"</span>+method+<span class="string">"方法调用之前记录日志-----&gt;"</span>);</span><br><span class="line">        Object value = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        <span class="comment">//调用之后的逻辑</span></span><br><span class="line">        System.out.println(<span class="string">"在"</span>+method+<span class="string">"方法调用之后记录日志-----&gt;"</span>);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subject runSubject = <span class="keyword">new</span> RunSubject();</span><br><span class="line">        Subject subject1 = (Subject) <span class="keyword">new</span> CglibProxyImpl(runSubject).getInstance();</span><br><span class="line">        subject1.doSomething(<span class="string">"bbb"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在<span class="keyword">public</span> java.lang.String com.zwt.helputils.utils.proxy.RunSubject.doSomething(java.lang.String)方法调用之前记录日志-----&gt;</span><br><span class="line">bbb running...</span><br><span class="line">在<span class="keyword">public</span> java.lang.String com.zwt.helputils.utils.proxy.RunSubject.doSomething(java.lang.String)方法调用之后记录日志-----&gt;</span><br></pre></td></tr></table></figure><p>这种代理方式显然有一个缺点，就是当目标对象类是<code>final</code>的时候，我们是无法继承目标类的，因此也就无法实现Cglib代理。</p><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p>上面我们总结了3种代理方式，及其使用，对于Jdk动态代理和Cglib动态代理代码，我们可以整合成一个<code>Factory</code>，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object subject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxyFactory</span><span class="params">(Object subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"JDK"</span>:</span><br><span class="line">                <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                        subject.getClass().getClassLoader(),</span><br><span class="line">                        subject.getClass().getInterfaces(),</span><br><span class="line">                        <span class="keyword">new</span> JdkDynamicProxyImpl(subject)</span><br><span class="line">                );</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"Cglib"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> CglibProxyImpl(subject).getInstance();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"找不到指定的代理方式！！！！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subject runSubject = <span class="keyword">new</span> RunSubject();</span><br><span class="line">        Subject subject3 = (Subject) <span class="keyword">new</span> DynamicProxyFactory(runSubject).getInstance(<span class="string">"JDK"</span>);</span><br><span class="line">        subject3.doSomething(<span class="string">"1234"</span>);</span><br><span class="line">        Subject subject4 = (Subject) <span class="keyword">new</span> DynamicProxyFactory(runSubject).getInstance(<span class="string">"Cglib"</span>);</span><br><span class="line">        subject4.doSomething(<span class="string">"5678"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以选择自己适合的代理方式，Spring AOP中就有类似的代码，只不过逻辑判断等更复杂些。</p><p>在Spring AOP中，如果加入容器的目标对象有实现接口，那么就用JDK代理；如果目标对象没有实现接口，那么就用Cglib代理。</p><p>有兴趣的同学可以看下AOP的相关代码。在<code>DefaultAopProxyFactory</code>类中，部分代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAopProxyFactory</span> <span class="keyword">implements</span> <span class="title">AopProxyFactory</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line"><span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</span><br><span class="line"><span class="string">"Either an interface or a target is required for proxy creation."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//部分代码略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Cglib警告"><a href="#Cglib警告" class="headerlink" title="Cglib警告"></a>Cglib警告</h2><p>在使用Cglib进行代理的时候，我们可以看到如下警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WARNING: An illegal reflective access operation has occurred</span><br><span class="line">WARNING: Illegal reflective access by net.sf.cglib.core.ReflectUtils$1 (file:/E:/maven-localRepository/local/repo/cglib/cglib/3.3.0/cglib-3.3.0.jar) to method java.lang.ClassLoader.defineClass(java.lang.String,byte[],int,int,java.security.ProtectionDomain)</span><br><span class="line">WARNING: Please consider reporting this to the maintainers of net.sf.cglib.core.ReflectUtils$1</span><br><span class="line">WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations</span><br><span class="line">WARNING: All illegal access operations will be denied in a future release</span><br></pre></td></tr></table></figure><p>我们可以看下<code>ClassLoader.defineClass(String,byte[],int,int,ProtectionDomain)</code>这个类。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-632.jpg" alt="upload successful"></p><p>可以看到它是<code>protected final</code>的，理论上外部包是不能调用它的，那么Cglib是如何实现调用的呢。</p><p>打开Cglib的<code>ReflectUtils</code>类，我们看到下图。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-633.jpg" alt="upload successful"></p><p>可以看到它通过<code>Class.forName</code>拿到<code>java.lang.ClassLoader</code>，然后拿到<code>defineClass</code>方法，改变了其可访问性<code>defineClass.setAccessible(true);</code>。</p><p>这也就是为什么JVM会发出警告的原因，因为正常情况下我们是不被允许访问此方法的（非法反射）。</p><p>还可以看到如果拿不到该方法（被限制后，抛出异常），那么它会尝试去拿<code>sun.misc.Unsafe.defineClass</code>方法。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-634.jpg" alt="upload successful"></p><p>如果我们不想看到这个警告，可以添加 VM 参数来屏蔽它。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--illegal-access=deny</span><br></pre></td></tr></table></figure><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-635.jpg" alt="upload successful"></p><h2 id="JDK动态代理源码分析"><a href="#JDK动态代理源码分析" class="headerlink" title="JDK动态代理源码分析"></a>JDK动态代理源码分析</h2><p>我们现在来分析下JDK动态代理是如何实现的，先看<code>Proxy.newProxyInstance</code>方法。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-636.jpg" alt="upload successful"></p><p>可以看到<code>Constructor&lt;?&gt; cons = getProxyConstructor(caller, loader, interfaces);</code>用来生成了构造器，而后通过<code>newProxyInstance(caller, cons, h);</code>生成对象。</p><p>我们看一下<code>getProxyConstructor</code>这个方法。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-637.jpg" alt="upload successful"></p><p>它分为只有一个接口和实现多个接口的两种处理逻辑，我们看其中一个就行，主要是<code>new ProxyBuilder(ld, clv.key()).build()</code>这个方法，用来生成代理类。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-638.jpg" alt="upload successful"></p><p>在<code>build</code>方法里，我们看到这个调用<code>Class&lt;?&gt; proxyClass = defineProxyClass(module, interfaces);</code>，这就是生成代理类的方法。</p><p>继续跟踪<code>defineProxyClass</code>方法，如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-639.jpg" alt="upload successful"></p><p>在这个方法中，我们可以看到生成代理类字节码的方法调用<code>byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces.toArray(EMPTY_CLASS_ARRAY), accessFlags);</code></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-640.jpg" alt="upload successful"></p><p>跟踪<code>generateProxyClass</code>方法，方法里有一个参数<code>saveGeneratedFiles</code>用来是否保存生成的代理类。</p><p>正常情况下这个值是false，即不保存。</p><p>但是我们想看生成的代理类的话，由于<code>ProxyGenerator.generateProxyClass</code>类及方法本身都是<code>non-public</code>的，所以我们无法直接调用此方法生成代理类。</p><p>因此可以借助<code>saveGeneratedFiles</code>参数。</p><p>观察代码<code>saveGeneratedFiles</code>的定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** debugging flag for saving generated class files */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> saveGeneratedFiles =</span><br><span class="line">    java.security.AccessController.doPrivileged(</span><br><span class="line">        <span class="keyword">new</span> GetBooleanAction(</span><br><span class="line">            <span class="string">"jdk.proxy.ProxyGenerator.saveGeneratedFiles"</span>)).booleanValue();</span><br></pre></td></tr></table></figure><p>所以我们在 VM 变量里配置<code>-Djdk.proxy.ProxyGenerator.saveGeneratedFiles=true</code>就可以将生成的代理类保存到本地。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-641.jpg" alt="upload successful"></p><p>如上图，运行后生成的代理类在<code>com.sun.proxy</code>包下。我们打开这个代理类（IDEA自带反编译）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sun.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zwt.helputils.utils.proxy.Subject;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">doSomething</span><span class="params">(String var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m3 = Class.forName(<span class="string">"com.zwt.helputils.utils.proxy.Subject"</span>).getMethod(<span class="string">"doSomething"</span>, Class.forName(<span class="string">"java.lang.String"</span>));</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到它继承自<code>Proxy</code>并实现了我们定义的<code>Subject</code>接口。也就是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Subject subject = (Subject) Proxy.newProxyInstance(loader, interfaces, handler);</span><br></pre></td></tr></table></figure><p>实际是<code>Subject</code>接口的一个实例，我们调用<code>doSomething</code>方法，实际调用代理类<code>$Proxy0</code>的<code>doSomething</code>方法。</p><p>而在实现<code>Subject</code>接口方法的内部，通过反射调用了<code>InvocationHandler</code>实现类的<code>invoke</code>方法。</p><p>由上面内容可以看出，Java动态代理主要有以下几步：</p><ol><li>通过实现<code>InvocationHandler</code>接口创建自己的调用处理器；</li><li>通过为<code>Proxy</code>类指定<code>ClassLoader</code>对象和一组<code>interface</code>来创建动态代理类；</li><li>通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型；</li><li>通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。</li></ol><h2 id="Cglib代理源码分析"><a href="#Cglib代理源码分析" class="headerlink" title="Cglib代理源码分析"></a>Cglib代理源码分析</h2><p>我们再来看下Cglib的代理是如何实现的。根据如下方法，我们直接跟踪到<code>create</code>方法里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">    enhancer.setSuperclass(target.getClass());</span><br><span class="line">    <span class="comment">// 回调方法</span></span><br><span class="line">    enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 创建代理对象</span></span><br><span class="line">    <span class="keyword">return</span> enhancer.create();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    classOnly = <span class="keyword">false</span>;</span><br><span class="line">    argumentTypes = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> createHelper();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看一下<code>createHelper()</code>方法。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-642.jpg" alt="upload successful"></p><p>其主要方法为<code>Object result = super.create(key);</code>，用来创建代理类。其代码如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-643.jpg" alt="upload successful"></p><p>主要方法<code>Object obj = data.get(this, getUseCache());</code>用来生成代理类，<code>firstInstance((Class) obj);</code>和<code>nextInstance(obj);</code>用来生成代理对象。</p><p>先来看下<code>get</code>方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(AbstractClassGenerator gen, <span class="keyword">boolean</span> useCache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!useCache) &#123;</span><br><span class="line">        <span class="keyword">return</span> gen.generate(ClassLoaderData.<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Object cachedValue = generatedClasses.get(gen);</span><br><span class="line">        <span class="keyword">return</span> gen.unwrapCachedValue(cachedValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到它调用了<code>gen.generate(ClassLoaderData.this)</code>用于生成代理类，继续跟踪调用。</p><p>可以看到<code>generate</code>最终调用了<code>ReflectUtils.defineClass</code>去生成代理类。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-644.jpg" alt="upload successful"></p><p><code>ReflectUtils.defineClass</code>方法中利用反射调用执行<code>ClassLoader.defineClass</code>方法去生成代理类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Class <span class="title">defineClass</span><span class="params">(String className, <span class="keyword">byte</span>[] b, ClassLoader loader, ProtectionDomain protectionDomain)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class c;</span><br><span class="line">    <span class="keyword">if</span> (DEFINE_CLASS != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Object[] args = <span class="keyword">new</span> Object[]&#123;className, b, <span class="keyword">new</span> Integer(<span class="number">0</span>), <span class="keyword">new</span> Integer(b.length), protectionDomain &#125;;</span><br><span class="line">        c = (Class)DEFINE_CLASS.invoke(loader, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DEFINE_CLASS_UNSAFE != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Object[] args = <span class="keyword">new</span> Object[]&#123;className, b, <span class="keyword">new</span> Integer(<span class="number">0</span>), <span class="keyword">new</span> Integer(b.length), loader, protectionDomain &#125;;</span><br><span class="line">        c = (Class)DEFINE_CLASS_UNSAFE.invoke(UNSAFE, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CodeGenerationException(THROWABLE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Force static initializers to run.</span></span><br><span class="line">    Class.forName(className, <span class="keyword">true</span>, loader);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用VM参数来指定Cglib使代理类文件落地。如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dcglib.debugLocation=E:\\WorkSpace\\helputils\\com\\cglib</span><br></pre></td></tr></table></figure><p>这个参数也可以通过代码设置，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, <span class="string">"E:\\WorkSpace\\helputils\\com\\cglib"</span>);</span><br></pre></td></tr></table></figure><p>我们运行下Test，可以看到生成如下类。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-645.jpg" alt="upload successful"></p><p>我们重点关注中间那个类，这个类继承<code>RunSubject</code>，这也印证了我们上面所说，Cglib是依靠继承目标类来实现代理的。</p><p>这个类代码比较多，我就不粘上来了，我们用图片看下它的几个关键部分。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-646.jpg" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-647.jpg" alt="upload successful"></p><p>由上面内容我们可以看到Cglib代理的几个步骤：</p><ol><li>通过实现<code>MethodInterceptor (extends Callback)</code>接口（或者自己实现<code>CallBack</code>接口）创建自己回调类；</li><li>通过<code>Enhancer</code>类指定目标类为超类<code>superClass</code>，并指定我们上面的回调类；</li><li>通过反射机制实现对目标类的继承，创建代理类；</li><li>代理类在调用指定方法时，如果需要回调，会通过反射拿到回调类要执行的内容；如果没有回调类，会直接执行目标类指定方法。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是关于代理模式的全部内容，我们也分析了各种代理模式的一些特点及原理。</p><p>实际中主要常用的就是JDK动态代理和Cglib代理。</p><p>JDK动态代理，是Java自带的代理模式，无需依赖，也没有警告等信息，唯一缺点就是需要目标类实现接口，只能对实现接口的类进行代理。</p><p>Cglib代理，内部使用asm，直接修改字节码进行增强子类，也就是通过继承的方式进行代理，不关心目标类是否继承接口，但是无法处理<code>final</code>的类（无法被继承）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="代理模式" scheme="https://www.sakuratears.top/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal</title>
    <link href="https://www.sakuratears.top/blog/ThreadLocal.html"/>
    <id>https://www.sakuratears.top/blog/ThreadLocal.html</id>
    <published>2020-07-30T14:51:00.000Z</published>
    <updated>2021-01-10T10:09:09.708Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>ThreadLocal</code>是一个本地线程副本变量存储工具类。主要用于将一个线程和该线程存放的副本对象做一个映射（Map），各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不同的变量值完成操作的场景。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>我们根据代码了解下<code>ThreadLocal</code>。</p><p>在了解<code>ThreadLocal</code>之前，我们先带着几个问题：</p><ol><li><code>ThreadLocal</code>的每个线程的私有变量保存在哪里？</li><li>大家说的关于<code>ThreadLocal</code>使用不当会发生内存泄露又是怎么回事？</li><li><code>ThreadLocal</code>弱引用导致内存泄露又是怎么回事？为什么要使用弱引用？</li><li>对于可能出现的内存泄露，<code>ThreadLocal</code>本身有哪些优化？我们编码时应该如何避免内存泄露？</li><li><code>ThreadLocal</code>的应用场景？</li></ol><p>首先我们先来看下<code>ThreadLocal</code>的几个重要方法。</p><h2 id="ThreadLocal的主要方法"><a href="#ThreadLocal的主要方法" class="headerlink" title="ThreadLocal的主要方法"></a>ThreadLocal的主要方法</h2><p><code>ThreadLocal</code>有三个重要方法，如下：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public T get()</td><td>该方法用于获取线程本地变量副本</td></tr><tr><td>public void set(T value)</td><td>该方法用于设置线程本地变量副本</td></tr><tr><td>public void remove()</td><td>该方法用于移除线程本地变量副本</td></tr></tbody></table><p>三个方法的相关源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面<code>get()</code>方法的源码可以看到，本地变量副本是由一个叫<code>ThreadLocalMap</code>的对象维护的，我们看一下<code>getMap(t)</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//.........部分代码略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment">     * by the ThreadLocal class. */</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.........部分代码略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在<code>Thread</code>类里维护着一个<code>ThreadLocalMap</code>，该线程的本地变量副本就会存到这儿。</p><p>再来看下这个变量赋予初始值的过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们通过<code>set</code>方法设置本地变量副本时，如果<code>ThreadLocalMap</code>为<code>null</code>，就会调用<code>createMap</code>将初始值放入。</p><p>而对于<code>get</code>方法，如果<code>ThreadLocalMap</code>为<code>null</code>，就会调用<code>setInitialValue</code>方法，最终调用<code>createMap</code>方法，此时初始值为<code>null</code>。</p><p>我们继续看下<code>ThreadLocalMap</code>的相关源码。</p><h2 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h2><p><code>ThreadLocalMap</code>的主要代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">        table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">        <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">        table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        setThreshold(INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//.....部分代码略</span></span><br></pre></td></tr></table></figure><p>可以看到<code>ThreadLocalMap</code>内部是通过<code>Entry</code>的value来维护变量副本的，其key为<code>ThreadLocal</code>本身。</p><p>而且<code>Entry</code>的key为<strong>弱引用（WeakReference）</strong>。</p><h2 id="关于Java引用"><a href="#关于Java引用" class="headerlink" title="关于Java引用"></a>关于Java引用</h2><p>Java中的引用按照引用强度不同分为四种，从强到弱依次为：强引用、软引用、弱引用和虚引用。</p><p>引用的强度，代表了对内存占用的能力大小，具体体现在GC的时候，会不会被回收，什么时候被回收。</p><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>我们一般很少提及它，但它无处不在。其实我们创建一个对象便是强引用，如<code>StringBuffer buffer = new StringBuffer();</code>。</p><p>HotSpot JVM目前的垃圾回收算法一般默认是可达性算法，即在每一轮GC的时候，选定一些对象作为GC ROOT，然后以它们为根发散遍历，遍历完成之后，如果一个对象不被任何GC ROOT引用，那么它就是不可达对象，则在接下来的GC过程中很可能会被回收。</p><p>如果我们在垃圾回收时还有对buffer的引用，那么它便不会被垃圾回收器回收。</p><h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>软引用是用来描述一些还有用但是并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收返回之后进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。JDK1.2之后提供了<code>SoftReference</code>来实现软引用。</p><p>相对于强引用，软引用在内存充足时可能不会被回收，在内存不够时会被回收。</p><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>弱引用也是用来描述非必须的对象的，但它的强度更弱，被弱引用关联的对象只能生存到下一次GC发生之前，也就是说下一次GC就会被回收。JDK1.2之后，提供了<code>WeakReference</code>来实现弱引用。</p><h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>虚引用也成为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间造成影响，也无法通过虚引用来取得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是在这个对象被GC时收到一个系统通知。JDK1.2之后提供了<code>PhantomReference</code>来实现虚引用。</p><h2 id="ThreadLocal内存模型"><a href="#ThreadLocal内存模型" class="headerlink" title="ThreadLocal内存模型"></a>ThreadLocal内存模型</h2><p>由上面内容，下面<code>ThreadLocal</code>的内存模型也是比较好理解的。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-628.jpg" alt="upload successful"></p><ul><li><p>线程运行时，我们定义的<code>ThreadLocal</code>对象被初始化，存储在<code>Heap</code>，同时线程运行的栈区保存了指向该实例的引用，也就是图中的<code>ThreadLocalRef</code>。</p></li><li><p>当<code>ThreadLocal</code>的<code>set/get</code>被调用时，虚拟机会根据当前线程的引用也就是<code>CurrentThreadRef</code>找到其对应在堆区的实例，然后查看其对用的<code>ThreadLocalMap</code>实例是否被创建，如果没有，则创建并初始化。</p></li><li><p><code>Map</code>实例化之后，也就拿到了该<code>ThreadLocalMap</code>的句柄，然后如果将当前<code>ThreadLocal</code>对象作为<code>key</code>，进行存取操作。</p></li><li><p>图中的虚线，表示<code>key</code>对<code>ThreadLocal</code>实例的引用是个弱引用。</p></li></ul><h2 id="内存泄露分析"><a href="#内存泄露分析" class="headerlink" title="内存泄露分析"></a>内存泄露分析</h2><p>根据上面内容，我们可以知道 <code>ThreadLocal</code>是被<code>ThreadLocalMap</code>以弱引用的方式关联着，因此如果<code>ThreadLocal</code>没有被<code>ThreadLocalMap</code>以外的对象引用，则在下一次GC的时候，<code>ThreadLocal</code>实例就会被回收，那么此时<code>ThreadLocalMap</code>里的一组<code>Entry</code>的K就是<code>null</code>了，因此在没有额外操作的情况下，此处的V便不会被外部访问到，而且只要<code>Thread</code>实例一直存在，<code>Thread</code>实例就强引用着<code>ThreadLocalMap</code>，因此<code>ThreadLocalMap</code>就不会被回收，那么这里K为<code>null</code>的V就一直占用着内存。</p><p>因此发生内存泄露的条件是：</p><ul><li><code>ThreadLocal</code>没有被外部强引用；</li><li><code>ThreadLocal</code>实例被回收；</li><li>但是<code>Thread</code>实例一直存活，一直强引用着<code>ThreadLocalMap</code>，也就是说<code>ThreadLocalMap</code>也不会被GC。</li></ul><p>也就是说，如果<code>ThreadLocal</code>使用不当，是有可能发生内存泄露的。</p><blockquote><p>我们这里说的内存泄露，指的是开发者使用不当造成的，而非<code>ThreadLocal</code>本身的问题。</p></blockquote><p>一个典型的例子就是线程池，如果我们在线程池的task里实例化了<code>ThreadLocal</code>对象，线程使用完后，回归线程池，但是本身并不会结束，但是task任务结束了，对<code>ThreadLocal</code>的强引用结束了，这时候在<code>ThreadLocalMap</code>中的<code>value</code>没有被任何清理机制有效清理。</p><p>我们可以模拟这种内存泄露情况，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个定长线程池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> k = a;</span><br><span class="line">            executorService.submit(()-&gt;&#123;</span><br><span class="line">                System.out.println(<span class="string">"线程ID："</span> + Thread.currentThread().getId());</span><br><span class="line">                ThreadLocal&lt;Integer&gt; t = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">                t.set(k);</span><br><span class="line">                System.out.println(<span class="string">"Value:"</span>+ t.get());</span><br><span class="line">            &#125;);</span><br><span class="line">            a+=<span class="number">1</span>;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//            MemoryMXBean mem =  ManagementFactory.getMemoryMXBean();</span></span><br><span class="line"><span class="comment">//            System.out.println("USED RAM：" + mem.getHeapMemoryUsage().getUsed() / 1024 / 1024 + "MB");</span></span><br><span class="line">        &#125;<span class="keyword">while</span> (a &lt; <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，我们模拟了一个长度为1的定长线程池（为了简化），这个线程池只有一个线程，我们在task里创建了<code>ThreadLocal</code>对象，当task结束后，实际<code>Thread</code>是还存活的。</p><p>我们通过<code>debug</code>模式，执行若干次，可以看到<code>ThreadLocalMap</code>里那些无用的<code>value</code>，如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-629.jpg" alt="upload successful"></p><p>这实际上就发生了内存泄露问题。</p><p>其实，我们调用<code>ThreadLocal</code>里提供的<code>remove</code>方法，变会完全解决这个问题。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-631.jpg" alt="upload successful"></p><p>如上图，我们如果使用完后添加<code>remove</code>方法删除变量副本，可以看到无论运行多少次，也不会出现内存泄露问题。</p><blockquote><p>不要觉得这个内存泄露条件自己不会碰到，实际上无论Http，数据库连接等都有线程池的概念，我们每一段代码如果使用<code>ThreadLocal</code>都可能成为task那段的一部分，使用不好就可能出现内存泄露问题。</p><p>因此在日常编码中一定要养成良好的编码习惯。</p></blockquote><h2 id="ThreadLocal的优化"><a href="#ThreadLocal的优化" class="headerlink" title="ThreadLocal的优化"></a>ThreadLocal的优化</h2><p>如果上面那个内存泄露的例子我们多运行一段时间，跟着<code>debug</code>，会发现<code>ThreadLocalMap</code>并不会一直增长的。</p><p>如下图，可以看到一些无用数据会自动消失。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-630.gif" alt="upload successful"></p><p>这是因为<code>ThreadLocal</code>本身的优化，在<code>ThreadLocalMap</code>的<code>getEntry</code>方法里，我们可以看到如下方法<code>getEntryAfterMiss</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">        Entry e = table[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>是的，这个方法就是找不到<code>Entry</code>的处理方法，该方法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == key)</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">                expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                i = nextIndex(i, len);</span><br><span class="line">            e = tab[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个方法一个关键部分就是<code>k == null</code>时调用<code>expungeStaleEntry</code>方法，用来删除旧的<code>Entry</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">        tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">        tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">        Entry e;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">                (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">                i = nextIndex(i, len)) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.value = <span class="keyword">null</span>;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line">                size--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                    tab[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                    <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                    <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                        h = nextIndex(h, len);</span><br><span class="line">                    tab[h] = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>主要逻辑如下：</p><ol><li><p>清理当前脏<code>entry</code>，即将其<code>value</code>引用置为<code>null</code>，并且将<code>table[staleSlot]</code>也置为<code>null</code>。<code>value</code>置为<code>null</code>后该<code>value</code>域变为不可达，在下一次gc的时候就会被回收掉，同时<code>table[staleSlot]</code>为<code>null</code>后以便于存放新的<code>entry</code>;</p></li><li><p>从当前<code>staleSlot</code>位置向后环形（<code>nextIndex</code>）继续搜索，直到遇到哈希桶（<code>tab[i]</code>）为<code>null</code>的时候退出；</p></li><li><p>若在搜索过程再次遇到脏<code>entry</code>，继续将其清除。</p></li></ol><p>除了该方法外，我们在<code>set</code>方法里可以看到对脏<code>entry</code>的处理，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> len = tab.length;</span><br><span class="line">        <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">                e != <span class="keyword">null</span>;</span><br><span class="line">                e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                e.value = value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                replaceStaleEntry(key, value, i);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">        <span class="keyword">int</span> sz = ++size;</span><br><span class="line">        <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">            rehash();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在该方法中针对脏<code>entry</code>做了这样的处理：</p><ol><li><p>如果当前<code>table[i]！=null</code>的话说明hash冲突就需要向后环形查找，若在查找过程中遇到脏<code>entry</code>就通过<code>replaceStaleEntry</code>进行处理；</p></li><li><p>如果当前<code>table[i]==null</code>的话说明新的<code>entry</code>可以直接插入，但是插入后会调用<code>cleanSomeSlots</code>方法检测并清除脏<code>entry</code></p></li></ol><p>我们先来看下<code>replaceStaleEntry</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Back up to check for prior stale entry in current run.</span></span><br><span class="line">    <span class="comment">// We clean out whole runs at a time to avoid continual</span></span><br><span class="line">    <span class="comment">// incremental rehashing due to garbage collector freeing</span></span><br><span class="line">    <span class="comment">// up refs in bunches (i.e., whenever the collector runs).</span></span><br><span class="line">    <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</span><br><span class="line">            (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">            i = prevIndex(i, len))</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find either the key or trailing null slot of run, whichever</span></span><br><span class="line">    <span class="comment">// occurs first</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">            (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">            i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we find key, then we need to swap it</span></span><br><span class="line">        <span class="comment">// with the stale entry to maintain hash table order.</span></span><br><span class="line">        <span class="comment">// The newly stale slot, or any other stale slot</span></span><br><span class="line">        <span class="comment">// encountered above it, can then be sent to expungeStaleEntry</span></span><br><span class="line">        <span class="comment">// to remove or rehash all of the other entries in run.</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line"></span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Start expunge at preceding stale entry if it exists</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If we didn't find stale entry on backward scan, the</span></span><br><span class="line">            <span class="comment">// first stale entry seen while scanning for key is the</span></span><br><span class="line">            <span class="comment">// first still present in the run.</span></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If key not found, put new entry in stale slot</span></span><br><span class="line">        tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">        tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If there are any other stale entries in run, expunge them</span></span><br><span class="line">        <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分代码通过<code>PreIndex</code>方法实现往前环形搜索脏<code>entry</code>的功能，初始时<code>slotToExpunge</code>和<code>staleSlot</code>相同，若在搜索过程中发现了脏<code>entry</code>，则更新<code>slotToExpunge</code>为当前索引<code>i</code>。另外，说明<code>replaceStaleEntry</code>并不仅仅局限于处理当前已知的脏<code>entry</code>，它认为在出现脏<code>entry</code>的相邻位置也有很大概率出现脏<code>entry</code>，所以为了一次处理到位，就需要向前环形搜索，找到前面的脏<code>entry</code>。</p><p>我们再来看下<code>cleanSomeSlots</code>方法的调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cleanSomeSlots</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        i = nextIndex(i, len);</span><br><span class="line">        Entry e = tab[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            n = len;</span><br><span class="line">            removed = <span class="keyword">true</span>;</span><br><span class="line">            i = expungeStaleEntry(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法用来清除一些脏<code>entry</code>，其扫描次数通过<code>n</code>来控制，可以看到<code>n &gt;&gt;&gt;= 1</code>表示每次<code>n</code>除以2进行减小范围搜索，当遇到脏<code>entry</code>时，<code>n = len</code>，就会扩大搜索范围。如果在整个搜索过程没遇到脏entry的话，搜索结束，采用这种方式的主要是用于时间效率上的平衡。</p><h2 id="为什么使用弱引用？"><a href="#为什么使用弱引用？" class="headerlink" title="为什么使用弱引用？"></a>为什么使用弱引用？</h2><p>根据上面的内容，我们来分析下为什么<code>ThreadLocal</code>要使用弱引用。</p><p>假设<code>ThreadLocal</code>使用的是强引用，在业务代码中执行<code>threadLocalInstance==null</code>操作，以清理掉<code>ThreadLocal</code>实例的目的，但是因为<code>ThreadLocalMap</code>的<code>Entry</code>强引用<code>ThreadLocal</code>，因此在gc的时候进行可达性分析，<code>ThreadLocal</code>依然可达，对<code>ThreadLocal</code>并不会进行垃圾回收，这样就无法真正达到业务逻辑的目的，出现逻辑错误。</p><p>假设<code>Entry</code>弱引用<code>ThreadLocal</code>，尽管会出现内存泄漏的问题，但是在<code>ThreadLocal</code>的生命周期里（<code>set,get,remove</code>）里，都会针对<code>key</code>为<code>null</code>的脏<code>Entry</code>进行处理。</p><p>从以上的分析可以看出，使用弱引用的话在<code>ThreadLocal</code>生命周期里会尽可能的保证不出现内存泄漏的问题，达到安全的状态。而且只要我们规范代码，就可以避免内存泄露问题。</p><h2 id="线程退出"><a href="#线程退出" class="headerlink" title="线程退出"></a>线程退出</h2><p>在<code>Thread</code>源码里，我们可以看到<code>exit</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (group != <span class="keyword">null</span>) &#123;</span><br><span class="line">        group.threadTerminated(<span class="keyword">this</span>);</span><br><span class="line">        group = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Aggressively null out all reference fields: see bug 4006245 */</span></span><br><span class="line">    target = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/* Speed the release of some of these resources */</span></span><br><span class="line">    threadLocals = <span class="keyword">null</span>;</span><br><span class="line">    inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line">    inheritedAccessControlContext = <span class="keyword">null</span>;</span><br><span class="line">    blocker = <span class="keyword">null</span>;</span><br><span class="line">    uncaughtExceptionHandler = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到线程退出后，<code>threadLocals</code>变为<code>null</code>，也就意味着GC可以将<code>ThreadLocalMap</code>进行垃圾回收。</p><h2 id="ThreadLocal应用场景"><a href="#ThreadLocal应用场景" class="headerlink" title="ThreadLocal应用场景"></a>ThreadLocal应用场景</h2><p><code>ThreadLocal</code>在一些开源框架下有着广泛应用。</p><ol><li><p>Spring的事务管理</p><p>在Spring事务管理相关类<code>TransactionAspectSupport</code>代码中，我们可以找到这段代码.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...部分代码略</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;TransactionInfo&gt; transactionInfoHolder =</span><br><span class="line"><span class="keyword">new</span> NamedThreadLocal&lt;TransactionInfo&gt;(<span class="string">"Current aspect-driven transaction"</span>);</span><br><span class="line"><span class="comment">//...部分代码略</span></span><br></pre></td></tr></table></figure><p>其目的就是用来存储当前事务相关信息。</p></li><li><p>Logback中的使用</p><p>在<code>Logback</code>的<code>LogbackMDCAdapter</code>相关代码中，也有<code>ThreadLocal</code>的使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...部分代码略</span></span><br><span class="line"><span class="keyword">final</span> ThreadLocal&lt;Map&lt;String, String&gt;&gt; copyOnThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Map&lt;String, String&gt;&gt;();</span><br><span class="line"><span class="keyword">final</span> ThreadLocal&lt;Integer&gt; lastOperation = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;();</span><br><span class="line"><span class="comment">//...部分代码略</span></span><br></pre></td></tr></table></figure></li><li><p>在<code>tomcat</code>相关代码中，<code>org.apache.catalina.core.ApplicationContext</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...部分代码略</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Thread local data used during request dispatch.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;DispatchData&gt; dispatchData = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"> <span class="comment">//...部分代码略</span></span><br></pre></td></tr></table></figure></li><li><p>如果要配置多数据源，我们可以使用<code>ThreadLocal</code>来进行数据源key的切换管理。</p><p> 可以看下这篇文章<a href="https://www.sakuratears.top/blog/SpringBoot%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE.html">SpringBoot多数据源配置</a></p></li></ol><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>我们对<code>Threadlocal</code>进行了详细介绍，除了了解它的主要原理，解决项目中遇到的一些问题外，更要使用好它，每次使用完<code>Threadlocal</code>，应调用<code>remove</code>方法清除数据。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.jianshu.com/p/dde92ec37bd1" rel="external nofollow noopener noreferrer" target="_blank">一篇文章，从源码深入详解ThreadLocal内存泄漏问题</a></li><li><a href="https://www.jianshu.com/p/1a5d288bdaee" rel="external nofollow noopener noreferrer" target="_blank">ThreadLocal小结-到底会不会引起内存泄露</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="ThreadLocal" scheme="https://www.sakuratears.top/tags/ThreadLocal/"/>
    
  </entry>
  
  <entry>
    <title>Java类加载器</title>
    <link href="https://www.sakuratears.top/blog/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.html"/>
    <id>https://www.sakuratears.top/blog/Java类加载器.html</id>
    <published>2020-07-26T13:43:00.000Z</published>
    <updated>2020-07-26T13:48:19.841Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>类加载器是<code>Java</code>语言的一个创新，也是<code>Java</code>语言流行的重要原因之一。它使得<code>Java</code> 类可以被动态加载到 <code>Java</code> 虚拟机中并执行。</p><p>一般来说，<code>Java</code> 应用的开发人员不需要直接同类加载器进行交互。<code>Java</code> 虚拟机默认的行为就已经足够满足大多数情况的需求了。不过如果遇到了需要与类加载器进行交互的情况，而对类加载器的机制又不是很了解的话，就很容易花大量的时间去调试 <code>ClassNotFoundException</code> 和 <code>NoClassDefFoundError</code> 等异常。</p><p>下面我们来了解类加载器的一些概念，来使我们更好地认识类加载器。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>类加载器（class loader）是用来加载 <code>Java</code> 类到 <code>Java</code> 虚拟机中的。</p><p>一般来说，<code>Java</code> 虚拟机使用 <code>Java</code> 类的方式如下：</p><ol><li><code>Java</code> 源程序（.java 文件）在经过 <code>Java</code> 编译器编译之后就被转换成 <code>Java</code> 字节代码（.class 文件）。</li><li>类加载器负责读取 <code>Java</code> 字节代码，并转换成 <code>java.lang.Class</code> 类的一个实例。每个这样的实例用来表示一个 <code>Java</code> 类。</li><li>通过此实例的 <code>newInstance()</code> 方法就可以创建出该类的一个对象。</li></ol><p>PS: 实际的情况可能更加复杂，比如 <code>Java</code> 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。</p><h2 id="java-lang-ClassLoader"><a href="#java-lang-ClassLoader" class="headerlink" title="java.lang.ClassLoader"></a>java.lang.ClassLoader</h2><p>基本上所有的类加载器都是 <code>java.lang.ClassLoader</code> 类的一个实例。</p><p><code>java.lang.ClassLoader</code> 类的基本职责就是根据一个指定的类的名称，找到或者生成其对应的字节代码，然后从这些字节代码中定义出一个 <code>Java</code> 类，即 <code>java.lang.Class</code> 类的一个实例。</p><p>除此之外， <code>ClassLoader</code> 还负责加载 <code>Java</code> 应用所需的资源，如图像文件和配置文件等。</p><p>下面我们主要看下这个类中与加载类相关的方法。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>getParent()</td><td>返回该类加载器的父类加载器。</td></tr><tr><td>loadClass(String name)</td><td>加载名称为 name 的类，返回的结果是 java.lang.Class 类的实例。</td></tr><tr><td>findClass(String name)</td><td>查找名称为 name 的类，返回的结果是 java.lang.Class 类的实例。</td></tr><tr><td>findLoadedClass(String name)</td><td>查找名称为 name 的已经被加载过的类，返回的结果是 java.lang.Class 类的实例。</td></tr><tr><td>defineClass(String name, byte[] b, int off, int len)</td><td>把字节数组 b 中的内容转换成 Java 类，返回的结果是 java.lang.Class 类的实例。这个方法被声明为 final 的。</td></tr><tr><td>resolveClass(Class&lt;?&gt; c)</td><td>链接指定的 Java 类。</td></tr></tbody></table><h2 id="类加载器的树状组织结构"><a href="#类加载器的树状组织结构" class="headerlink" title="类加载器的树状组织结构"></a>类加载器的树状组织结构</h2><p><code>Java</code> 中的类加载器大致可以分成两类，一类是系统提供的，另外一类则是由 <code>Java</code> 应用开发人员编写的。系统提供的类加载器主要有下面三个：</p><ul><li><p><strong>引导类加载器（BootstrapClassLoader）</strong>：它用来加载 <code>Java</code> 的核心库，是用原生代码（C++）来实现的，并不继承自 <code>java.lang.ClassLoader</code> 。</p></li><li><p><strong>扩展类/平台类加载器（ExtClassLoader/PlatformClassLoader）</strong>：扩展类加载器在<code>JDK1.8</code>之后变为平台类加载器。从<code>JDK1.8</code>之后的版本(<code>JDK9,JDK10</code>)提供有一个”<code>PlatformClassLoader</code>“类加载器，而在<code>JDK1.8</code>以前的版本里面提供的加载器为”<code>ExtClassLoader</code>“，因为在JDK的安装目录里面提供有一个<code>ext</code>目录，开发者可以将<code>*.jar</code>文件拷贝到此目录里面，这样就可以直接执行了，但是这样的处理并不安全。最初的时候也是不提倡使用的。所以在<code>JDK9</code>开始就将这样的操作彻底废除了，同时为了与系统类加载器和应用类加载器之间保持设计的平衡，提供了平台类加载器。</p></li><li><p><strong>系统类/应用类加载器（SystemClassLoader/AppClassLoader）</strong>：它根据 <code>Java</code> 应用的类路径（CLASSPATH）来加载 <code>Java</code> 类。一般来说，<code>Java</code> 应用的类都是由它来完成加载的。可以通过 <code>ClassLoader.getSystemClassLoader()</code> 来获取它。</p></li></ul><p>除了系统提供的类加载器以外，我们可以通过继承 <code>java.lang.ClassLoader</code> 类的方式实现自己的类加载器，以满足一些特殊的需求。</p><p>除了引导类加载器之外，所有的类加载器都有一个父类加载器。通过 <code>java.lang.ClassLoader</code> 类的 <code>getParent()</code> 方法可以得到。</p><p>对于系统提供的类加载器来说，系统类加载器的父类加载器是扩展类加载器，而扩展类加载器的父类加载器是引导类加载器；对于我们编写的类加载器来说，其父类加载器是加载此类加载器 <code>Java</code> 类的类加载器。因为类加载器 <code>Java</code> 类如同其它的 <code>Java</code> 类一样，也是要由类加载器来加载的。一般来说，我们编写的类加载器的父类加载器是系统类加载器。类加载器通过这种方式组织起来，形成树状结构。树的根节点就是引导类加载器，如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-627.jpg" alt="upload successful"></p><p>我们提供Java代码来看下类加载器的结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassLoader loader = Test.class.getClassLoader();</span><br><span class="line">        <span class="keyword">while</span> (loader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(loader.toString());</span><br><span class="line">            loader = loader.getParent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会有如下输出（JDK1.8及以上）:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jdk.internal.loader.ClassLoaders$AppClassLoader@726f3b58</span><br><span class="line">jdk.internal.loader.ClassLoaders$PlatformClassLoader@368239c8</span><br></pre></td></tr></table></figure></p><blockquote><p>需要注意的是这里并没有输出引导类加载器，这是由于有些 <code>JDK</code> 的实现对于父类加载器是引导类加载器的情况， <code>getParent()</code> 方法返回 <code>null</code> 。</p></blockquote><h2 id="类加载器的代理模式（双亲委派机制）"><a href="#类加载器的代理模式（双亲委派机制）" class="headerlink" title="类加载器的代理模式（双亲委派机制）"></a>类加载器的代理模式（双亲委派机制）</h2><p>类加载器在尝试自己去查找某个类的字节代码并定义它时，会先代理（委托）给其父类加载器，由父类加载器先去尝试加载这个类，依次类推。</p><p>代理模式（委托模式）第一这样可以避免重复加载，第二是为了保证 <code>Java</code> 核心库的类型安全。所有 <code>Java</code> 应用都至少需要引用 <code>java.lang.Object</code> 类，也就是说在运行的时候， <code>java.lang.Object</code>这个类需要被加载到 <code>Java</code> 虚拟机中。如果这个加载过程由 <code>Java</code> 应用自己的类加载器来完成的话，很可能就存在多个版本的 <code>java.lang.Object</code> 类，而且这些类之间是不兼容的。通过代理模式，对于 <code>Java</code> 核心库的类的加载工作由引导类加载器来统一完成，保证了 <code>Java</code> 应用所使用的都是同一个版本的 <code>Java</code> 核心库的类，是互相兼容的。</p><p>不同的类加载器为相同名称的类创建了额外的名称空间。相同名称的类可以并存在 <code>Java</code> 虚拟机中，只需要用不同的类加载器来加载它们即可。不同类加载器加载的类之间是不兼容的，这就相当于在 <code>Java</code> 虚拟机内部创建了一个个相互隔离的 <code>Java</code> 类空间。</p><p>在<code>ClassLoader</code>类的<code>loadClass</code>方法，我们可以看到这种委派机制，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">//首先从jvm缓存查找该类</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//父类加载器不为空，委托给父类加载器进行加载</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果父类加载器为null,则委托给BootStrap加载器加载</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 若仍然没有找到则调用findclass查找该类</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其大致流程如下：</p><ol><li><p>从 <code>JVM</code> 缓存查找该类，如果该类之前被加载过，则直接从 <code>JVM</code> 缓存返回该类。</p></li><li><p>如果 <code>JVM</code> 缓存不存在该类，则看当前类加载器是否有父加载器，如果有的话则委托父类加载器进行加载，否则委托 <code>BootStrapClassloader</code> 进行加载，如果还是没有找到，则调用当前 <code>Classloader</code> 的 <code>findclass</code> 方法进行查找。</p></li><li><p>从本地<code>Classloader</code>指定路径进行查找，其中<code>findClass</code>方法在路径找到<code>Class</code>文件会加载二进制字节码到内存，然后后会调用<code>native</code>方法<code>defineClass1</code>解析字节码为<code>JVM</code>内部的<code>kclass</code>对象，然后存放到<code>Java</code>堆的方法区。</p></li><li><p>如果需要链接<code>resolve=true</code>，则当字节码加载到内存后进行链接操作，对文件格式和字节码验证，并为 <code>static</code> 字段分配空间并初始化，符号引用转为直接引用，访问控制，方法覆盖等。</p></li></ol><h2 id="加载类的过程"><a href="#加载类的过程" class="headerlink" title="加载类的过程"></a>加载类的过程</h2><p>在前面介绍类加载器的代理模式的时候，提到过类加载器会首先代理给其它类加载器来尝试加载某个类。</p><p>这就意味着真正完成类的加载工作的类加载器和启动这个加载过程的类加载器，有可能不是同一个。</p><p>真正完成类的加载工作是通过调用 <code>defineClass</code> 来实现的；而启动类的加载过程是通过调用 <code>loadClass</code> 来实现的。前者称为一个类的定义加载器（defining loader），后者称为初始加载器（initiating loader）。</p><p>在 <code>Java</code> 虚拟机判断两个类是否相同的时候，使用的是类的定义加载器。</p><p>也就是说，哪个类加载器启动类的加载过程并不重要，重要的是最终定义这个类的加载器。两种类加载器的关联之处在于：一个类的定义加载器是它引用的其它类的初始加载器。</p><p>如类 <code>com.example.Outer</code> 引用了类 <code>com.example.Inner</code> ，则由类 <code>com.example.Outer</code> 的定义加载器负责启动类 <code>com.example.Inner</code> 的加载过程。</p><p>方法 <code>loadClass()</code> 抛出的是 <code>java.lang.ClassNotFoundException</code> 异常；方法 <code>defineClass()</code> 抛出的是 <code>java.lang.NoClassDefFoundError</code> 异常。</p><p>类加载器在成功加载某个类之后，会把得到的 <code>java.lang.Class</code> 类的实例缓存起来。下次再请求加载该类的时候，类加载器会直接使用缓存的类的实例，而不会尝试再次加载。</p><p>也就是说，对于一个类加载器实例来说，相同全名的类只加载一次，即 <code>loadClass</code> 方法不会被重复调用。</p><h2 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h2><p>线程上下文类加载器（context class loader）是从 JDK 1.2 开始引入的。</p><p>类 <code>java.lang.Thread</code> 中的方法 <code>getContextClassLoader()</code> 和 <code>setContextClassLoader(ClassLoader cl)</code> 用来获取和设置线程的上下文类加载器。如果没有通过 <code>setContextClassLoader(ClassLoader cl)</code> 方法进行设置的话，线程将继承其父线程的上下文类加载器。</p><p><code>Java</code>应用运行的初始线程的上下文类加载器是系统类加载器。在线程中运行的代码可以通过此类加载器来加载类和资源。</p><p>线程上下文类加载器所解决的问题：</p><p><code>Java</code> 提供了很多服务提供者接口（Service Provider Interface，SPI），允许第三方为这些接口提供实现。常见的 SPI 有 <code>JDBC、JCE、JNDI、JAXP 和 JBI</code> 等。这些 SPI 的接口由 <code>Java</code> 核心库来提供，这些 SPI 的实现代码很可能是作为 <code>Java</code> 应用所依赖的 <code>jar</code> 包被包含进来，可以通过类路径（CLASSPATH）来找到。而问题在于，SPI 的接口是 <code>Java</code> 核心库的一部分，是由引导类加载器来加载的；SPI 实现的 <code>Java</code> 类一般是由系统类加载器来加载的。引导类加载器是无法找到 SPI 的实现类的，因为它只加载 <code>Java</code> 的核心库。它也不能代理给系统类加载器，因为它是系统类加载器的祖先类加载器。也就是说，类加载器的代理模式无法解决这个问题。</p><p>线程上下文类加载器正好解决了这个问题。如果不做任何的设置，<code>Java</code> 应用的线程的上下文类加载器默认就是系统上下文类加载器。在 SPI 接口的代码中使用线程上下文类加载器，就可以成功的加载到 SPI 实现的类。线程上下文类加载器在很多 SPI 的实现中都会用到。</p><h2 id="Class-forName"><a href="#Class-forName" class="headerlink" title="Class.forName"></a>Class.forName</h2><p><code>Class.forName</code> 是一个静态方法，同样可以用来加载类。</p><p>该方法有两种形式：<code>Class.forName(String name, boolean initialize, ClassLoader loader)</code> 和 <code>Class.forName(String className)</code> 。</p><p>第一种形式的参数 <code>name</code> 表示的是类的全名； <code>initialize</code> 表示是否初始化类；<code>loader</code> 表示加载时使用的类加载器。</p><p>第二种形式则相当于设置了参数 <code>initialize</code> 的值为 <code>true</code>，<code>loader</code> 的值为当前类的类加载器。<code>Class.forName</code> 的一个很常见的用法是在加载数据库驱动的时候。</p><p>如 <code>Class.forName(“org.apache.derby.jdbc.EmbeddedDriver”).newInstance()</code> 用来加载 <code>Apache Derby</code> 数据库的驱动。</p><h2 id="开发自己的类加载器"><a href="#开发自己的类加载器" class="headerlink" title="开发自己的类加载器"></a>开发自己的类加载器</h2><p>虽然在绝大多数情况下，系统默认提供的类加载器实现已经可以满足需求。但是在某些情况下，我们还是需要为应用开发出自己的类加载器。比如我们的应用通过网络来传输 <code>Java</code> 类的字节代码，为了保证安全性，这些字节代码经过了加密处理。这个时候我们就需要自己的类加载器来从某个网络地址上读取加密后的字节代码，接着进行解密和验证，最后定义出要在 <code>Java</code> 虚拟机中运行的类来。下面将通过两个具体的实例来说明类加载器的开发。</p><h3 id="文件系统类加载器"><a href="#文件系统类加载器" class="headerlink" title="文件系统类加载器"></a>文件系统类加载器</h3><p>我们先编写一个类加载器用来加载存储在文件系统上的 <code>Java</code> 字节代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSystemClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String rootDir;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileSystemClassLoader</span><span class="params">(String rootDir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rootDir = rootDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] classData = getClassData(name);</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassData(String className) &#123;</span><br><span class="line">        String path = classNameToPath(className);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream ins = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> bufferSize = <span class="number">4096</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[bufferSize];</span><br><span class="line">            <span class="keyword">int</span> bytesNumRead = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((bytesNumRead = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, bytesNumRead);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">classNameToPath</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rootDir + File.separatorChar</span><br><span class="line">                + className.replace(<span class="string">'.'</span>, File.separatorChar) + <span class="string">".class"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>如上所示，类 <code>FileSystemClassLoader</code> 继承自类 <code>java.lang.ClassLoader</code> 。在 <code>java.lang.ClassLoader</code> 类的常用方法中，一般来说，自己开发的类加载器只需要覆写 <code>findClass(String name)</code> 方法即可。 </p><p>如上面源码所示，<code>loadClass()</code> 封装了前面提到的代理模式的实现。该方法会首先调用 <code>findLoadedClass()</code> 方法来检查该类是否已经被加载过；如果没有加载过的话，会调用父类加载器的 <code>loadClass()</code> 方法来尝试加载该类；如果父类加载器无法加载该类的话，就调用 <code>findClass()</code> 方法来查找该类。</p><p>因此，为了保证类加载器都正确实现代理模式，在开发自己的类加载器时，最好不要覆写 <code>loadClass()</code> 方法，而是覆写 <code>findClass()</code> 方法。</p><p>类 <code>FileSystemClassLoader</code> 的 <code>findClass()</code> 方法首先根据类的全名在硬盘上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 <code>defineClass()</code> 方法来把这些字节代码转换成 <code>java.lang.Class</code> 类的实例。</p><h3 id="网络类加载器"><a href="#网络类加载器" class="headerlink" title="网络类加载器"></a>网络类加载器</h3><p>下面将通过一个网络类加载器来说明如何通过类加载器来实现组件的动态更新。</p><p>即基本的场景是：<code>Java</code> 字节代码（.class）文件存放在服务器上，客户端通过网络的方式获取字节代码并执行。当有版本更新的时候，只需要替换掉服务器上保存的文件即可。通过类加载器可以比较简单的实现这种需求。</p><p>类 <code>NetworkClassLoader</code> 负责通过网络下载 <code>Java</code> 类字节代码并定义出 <code>Java</code> 类。它的实现与 <code>FileSystemClassLoader</code> 类似。</p><p>在通过 <code>NetworkClassLoader</code> 加载了某个版本的类之后，一般有两种做法来使用它。</p><p>第一种做法是使用 <code>Java</code> 反射 API。另外一种做法是使用接口。需要注意的是，并不能直接在客户端代码中引用从服务器上下载的类，因为客户端代码的类加载器找不到这些类。使用 <code>Java</code> 反射 API 可以直接调用 Java 类的方法。而使用接口的做法则是把接口的类放在客户端中，从服务器上加载实现此接口的不同版本的类。在客户端通过相同的接口来使用这些实现类。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String rootUrl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NetworkClassLoader</span><span class="params">(String rootUrl)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.rootUrl = rootUrl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"><span class="keyword">byte</span>[] classData = getClassData(name);</span><br><span class="line"><span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] getClassData(String className) &#123;</span><br><span class="line">String path = classNameToPath(className);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">URL url = <span class="keyword">new</span> URL(path);</span><br><span class="line">InputStream ins = url.openStream();</span><br><span class="line">ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line"><span class="keyword">int</span> bufferSize = <span class="number">4096</span>;</span><br><span class="line"><span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[bufferSize];</span><br><span class="line"><span class="keyword">int</span> bytesNumRead = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((bytesNumRead = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">baos.write(buffer, <span class="number">0</span>, bytesNumRead);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">classNameToPath</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> rootUrl + <span class="string">"/"</span></span><br><span class="line">+ className.replace(<span class="string">'.'</span>, <span class="string">'/'</span>) + <span class="string">".class"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Versioned</span> </span>&#123;</span><br><span class="line"><span class="function">String <span class="title">getVersion</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICalculator</span> <span class="keyword">extends</span> <span class="title">Versioned</span> </span>&#123;</span><br><span class="line"><span class="function">String <span class="title">calculate</span><span class="params">(String expression)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String url = <span class="string">"http://localhost:8080/ClassloaderTest/classes"</span>;</span><br><span class="line">NetworkClassLoader ncl = <span class="keyword">new</span> NetworkClassLoader(url);</span><br><span class="line">String basicClassName = <span class="string">"com.example.CalculatorBasic"</span>;</span><br><span class="line">String advancedClassName = <span class="string">"com.example.CalculatorAdvanced"</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class&lt;?&gt; clazz = ncl.loadClass(basicClassName);</span><br><span class="line">ICalculator calculator = (ICalculator) clazz.newInstance();</span><br><span class="line">System.out.println(calculator.getVersion());</span><br><span class="line">clazz = ncl.loadClass(advancedClassName);</span><br><span class="line">calculator = (ICalculator) clazz.newInstance();</span><br><span class="line">System.out.println(calculator.getVersion());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时需要在服务器提供<code>CalculatorBasic</code>和<code>CalculatorAdvanced</code>的实现，它们继承<code>ICalculator</code>接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorAdvanced</span> <span class="keyword">implements</span> <span class="title">ICalculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">calculate</span><span class="params">(String expression)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Result is "</span> + expression;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"2.0"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorBasic</span> <span class="keyword">implements</span> <span class="title">ICalculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">calculate</span><span class="params">(String expression)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> expression;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"1.0"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>类加载器是 <code>Java</code> 语言的一个创新。它使得动态安装和更新软件组件成为可能。</p><p>本文详细介绍了类加载器的相关话题，包括基本概念、代理模式、线程上下文类加载器等。我们在遇到 <code>ClassNotFoundException</code> 和 <code>NoClassDefFoundError</code> 等异常的时候，应该检查抛出异常的类的类加载器和当前线程的上下文类加载器，从中可以发现问题的所在。</p><p>在开发自己的类加载器的时候，需要注意与已有的类加载器组织结构的协调。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="类加载器" scheme="https://www.sakuratears.top/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java加密算法</title>
    <link href="https://www.sakuratears.top/blog/Java%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.html"/>
    <id>https://www.sakuratears.top/blog/Java加密算法.html</id>
    <published>2020-07-21T15:41:00.000Z</published>
    <updated>2020-07-21T15:42:44.781Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近总结了一些加密算法的相关Java代码，特此整理如下，以备不时之需。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="MD5信息摘要算法"><a href="#MD5信息摘要算法" class="headerlink" title="MD5信息摘要算法"></a>MD5信息摘要算法</h2><p>此算法为不可逆加密算法，是一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值，用于确保信息传输完整一致。</p><p>后来该算法被证实存在弱点，无法防止碰撞破解，因此不适用于安全性认证，对于需要高度安全性的数据，可以采用其他加密算法。</p><p>Java相关代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MD5Utils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_ALGORITHM = <span class="string">"MD5"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认的密码字符串组合，用来将字节转换成 16 进制表示的字符,apache校验下载的文件的正确性用的就是默认的这个组合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">char</span>[] hexDigits = &#123; <span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>,</span><br><span class="line">            <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MessageDigest messagedigest = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            messagedigest = MessageDigest.getInstance(KEY_ALGORITHM);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException ex) &#123;</span><br><span class="line">            log.error(ex.getMessage(),ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成字符串的md5校验值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMD5String</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getMD5String(s.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMD5String</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        messagedigest.update(bytes);</span><br><span class="line">        <span class="keyword">return</span> bufferToHex(messagedigest.digest());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">bufferToHex</span><span class="params">(<span class="keyword">byte</span> bytes[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bufferToHex(bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">bufferToHex</span><span class="params">(<span class="keyword">byte</span> bytes[], <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        StringBuffer stringbuffer = <span class="keyword">new</span> StringBuffer(<span class="number">2</span> * n);</span><br><span class="line">        <span class="keyword">int</span> k = m + n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = m; l &lt; k; l++) &#123;</span><br><span class="line">            appendHexPair(bytes[l], stringbuffer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringbuffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">appendHexPair</span><span class="params">(<span class="keyword">byte</span> bt, StringBuffer stringbuffer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 取字节中高 4 位的数字转换, &gt;&gt;&gt; 为逻辑右移，将符号位一起右移,此处未发现两种符号有何不同</span></span><br><span class="line">        <span class="keyword">char</span> c0 = hexDigits[(bt &amp; <span class="number">0xf0</span>) &gt;&gt; <span class="number">4</span>];</span><br><span class="line">        <span class="comment">// 取字节中低 4 位的数字转换</span></span><br><span class="line">        <span class="keyword">char</span> c1 = hexDigits[bt &amp; <span class="number">0xf</span>];</span><br><span class="line">        stringbuffer.append(c0);</span><br><span class="line">        stringbuffer.append(c1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成字符串指定部分的md5校验值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMD5String</span><span class="params">(String s,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(s))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s = s.toUpperCase();</span><br><span class="line">        <span class="keyword">if</span>(end &gt; start &amp;&amp; end &gt; <span class="number">0</span> &amp;&amp; s.length() &gt;= end)&#123;</span><br><span class="line">            s = s.substring(start, end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getMD5String(s.getBytes()).toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(getMD5String(<span class="string">"123456"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SHA安全散列算法"><a href="#SHA安全散列算法" class="headerlink" title="SHA安全散列算法"></a>SHA安全散列算法</h2><p>我们这儿提到的SHA安全散列算法一般指的它的密码散列函数家族，其有5个算法，分别是SHA-1、SHA-224、SHA-256、SHA-384和SHA-512。</p><p>其加密强度依次上升，SHA加密算法也是一种不可逆加密算法。</p><p>由于目前SHA-1存在暴力破解（碰撞破解）的可能性，因此推荐使用SHA-2（SHA-224、SHA-256、SHA-384、SHA-512）进行数据加密。这4个算法函数都将讯息对应到更长的讯息摘要。</p><p>Java相关代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SHAUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_SHA_1 = <span class="string">"SHA1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_SHA_224 = <span class="string">"SHA-224"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_SHA_256 = <span class="string">"SHA-256"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_SHA_384 = <span class="string">"SHA-384"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_SHA_512 = <span class="string">"SHA-512"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认的密码字符串组合，用来将字节转换成 16 进制表示的字符,apache校验下载的文件的正确性用的就是默认的这个组合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">char</span>[] hexDigits = &#123; <span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>,</span><br><span class="line">            <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MessageDigest messagedigestSHA1 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MessageDigest messagedigestSHA224 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MessageDigest messagedigestSHA256 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MessageDigest messagedigestSHA384 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MessageDigest messagedigestSHA512 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            messagedigestSHA1 = MessageDigest.getInstance(KEY_SHA_1);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException ex) &#123;</span><br><span class="line">            log.error(ex.getMessage(),ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            messagedigestSHA224 = MessageDigest.getInstance(KEY_SHA_224);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException ex) &#123;</span><br><span class="line">            log.error(ex.getMessage(),ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            messagedigestSHA256 = MessageDigest.getInstance(KEY_SHA_256);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException ex) &#123;</span><br><span class="line">            log.error(ex.getMessage(),ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            messagedigestSHA384 = MessageDigest.getInstance(KEY_SHA_384);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException ex) &#123;</span><br><span class="line">            log.error(ex.getMessage(),ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            messagedigestSHA512 = MessageDigest.getInstance(KEY_SHA_512);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException ex) &#123;</span><br><span class="line">            log.error(ex.getMessage(),ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">bufferToHex</span><span class="params">(<span class="keyword">byte</span> bytes[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bufferToHex(bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">bufferToHex</span><span class="params">(<span class="keyword">byte</span> bytes[], <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        StringBuffer stringbuffer = <span class="keyword">new</span> StringBuffer(<span class="number">2</span> * n);</span><br><span class="line">        <span class="keyword">int</span> k = m + n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = m; l &lt; k; l++) &#123;</span><br><span class="line">            appendHexPair(bytes[l], stringbuffer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringbuffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">appendHexPair</span><span class="params">(<span class="keyword">byte</span> bt, StringBuffer stringbuffer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 取字节中高 4 位的数字转换, &gt;&gt;&gt; 为逻辑右移，将符号位一起右移,此处未发现两种符号有何不同</span></span><br><span class="line">        <span class="keyword">char</span> c0 = hexDigits[(bt &amp; <span class="number">0xf0</span>) &gt;&gt; <span class="number">4</span>];</span><br><span class="line">        <span class="comment">// 取字节中低 4 位的数字转换</span></span><br><span class="line">        <span class="keyword">char</span> c1 = hexDigits[bt &amp; <span class="number">0xf</span>];</span><br><span class="line">        stringbuffer.append(c0);</span><br><span class="line">        stringbuffer.append(c1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成字符串的sha1校验值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSHA1String</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSHA1String(s.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSHA1String</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        messagedigestSHA1.update(bytes);</span><br><span class="line">        <span class="keyword">return</span> bufferToHex(messagedigestSHA1.digest());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成字符串的sha224校验值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSHA224String</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSHA224String(s.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSHA224String</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        messagedigestSHA224.update(bytes);</span><br><span class="line">        <span class="keyword">return</span> bufferToHex(messagedigestSHA224.digest());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成字符串的sha256校验值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSHA256String</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSHA256String(s.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSHA256String</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        messagedigestSHA256.update(bytes);</span><br><span class="line">        <span class="keyword">return</span> bufferToHex(messagedigestSHA256.digest());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成字符串的sha384校验值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSHA384String</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSHA384String(s.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSHA384String</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        messagedigestSHA384.update(bytes);</span><br><span class="line">        <span class="keyword">return</span> bufferToHex(messagedigestSHA384.digest());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成字符串的sha512校验值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSHA512String</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSHA512String(s.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSHA512String</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        messagedigestSHA512.update(bytes);</span><br><span class="line">        <span class="keyword">return</span> bufferToHex(messagedigestSHA512.digest());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SHA1:"</span>+getSHA1String(<span class="string">"123456"</span>));</span><br><span class="line">        System.out.println(<span class="string">"SHA224:"</span>+getSHA224String(<span class="string">"123456"</span>));</span><br><span class="line">        System.out.println(<span class="string">"SHA256:"</span>+getSHA256String(<span class="string">"123456"</span>));</span><br><span class="line">        System.out.println(<span class="string">"SHA384:"</span>+getSHA384String(<span class="string">"123456"</span>));</span><br><span class="line">        System.out.println(<span class="string">"SHA512:"</span>+getSHA512String(<span class="string">"123456"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Hmac哈希消息认证码"><a href="#Hmac哈希消息认证码" class="headerlink" title="Hmac哈希消息认证码"></a>Hmac哈希消息认证码</h2><p>Hmac是一种基于Hash函数和密钥进行消息认证的方法，在IPSec和其他网络协议（如SSL）中有广泛应用，现在已经成为Internet安全标准。</p><p>它也是一种不可逆加密算法。</p><p>Hmac运算利用hash算法，以一个消息M和一个密钥K作为输入，生成一个定长的消息摘要作为输出。</p><p>由于存在加密密钥K，因此认证时，加密方和认证方都是需要知道密钥K的。因此需要保证密钥K不被泄露。</p><p>同时密钥K的长度也影响加密算法强度，推荐密钥K随机生成且长度大于n（hash输出值）。</p><p>Hmac根据hash运算的不同，有6种算法，分别是Hmac-SHA1、Hmac-SHA224、Hmac-SHA256、Hmac-SHA284、Hmac-SHA512和Hmac-MD5。</p><p>Java相关代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HmacUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_HMAC_SHA1 = <span class="string">"HmacSHA1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_HMAC_SHA224 = <span class="string">"HmacSHA224"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_HMAC_SHA256 = <span class="string">"HmacSHA256"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_HMAC_SHA384 = <span class="string">"HmacSHA384"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_HMAC_SHA512 = <span class="string">"HmacSHA512"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_HMAC_MD5 = <span class="string">"HmacMD5"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到指定算法的一个密钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> algorithm</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">initMacKey</span><span class="params">(String algorithm)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//得到一个 指定算法密钥的密钥生成器</span></span><br><span class="line">        KeyGenerator keyGenerator = KeyGenerator.getInstance(algorithm);</span><br><span class="line">        <span class="comment">//生成一个密钥</span></span><br><span class="line">        SecretKey secretKey = keyGenerator.generateKey();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = secretKey.getEncoded();</span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HmacSHA 加密算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptText</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">hmacSHAEncrypt</span><span class="params">(String encryptText, String encryptKey,String algorithm)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] data = encryptKey.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        SecretKey secretKey = <span class="keyword">new</span> SecretKeySpec(data, algorithm);</span><br><span class="line">        Mac mac = Mac.getInstance(algorithm);</span><br><span class="line">        mac.init(secretKey);</span><br><span class="line">        <span class="keyword">byte</span>[] text = encryptText.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes =  mac.doFinal(text);</span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HmacSHA1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptText</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">hmacSHA1Encrypt</span><span class="params">(String encryptText, String encryptKey)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hmacSHAEncrypt(encryptText,encryptKey,KEY_HMAC_SHA1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HmacSHA224</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptText</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">hmacSHA224Encrypt</span><span class="params">(String encryptText, String encryptKey)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hmacSHAEncrypt(encryptText,encryptKey,KEY_HMAC_SHA224);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HmacSHA256</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptText</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">hmacSHA256Encrypt</span><span class="params">(String encryptText, String encryptKey)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hmacSHAEncrypt(encryptText,encryptKey,KEY_HMAC_SHA256);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HmacSHA384</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptText</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">hmacSHA384Encrypt</span><span class="params">(String encryptText, String encryptKey)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hmacSHAEncrypt(encryptText,encryptKey,KEY_HMAC_SHA384);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HmacSHA512</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptText</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">hmacSHA512Encrypt</span><span class="params">(String encryptText, String encryptKey)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hmacSHAEncrypt(encryptText,encryptKey,KEY_HMAC_SHA512);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HmacMD5</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptText</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">hmacMD5Encrypt</span><span class="params">(String encryptText, String encryptKey)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hmacSHAEncrypt(encryptText,encryptKey,KEY_HMAC_MD5);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String sha1Key = initMacKey(KEY_HMAC_SHA1);</span><br><span class="line">        System.out.println(<span class="string">"HmacSHA1_Key:"</span>+sha1Key);</span><br><span class="line">        System.out.println(<span class="string">"HmacSHA1_Result:"</span>+hmacSHA1Encrypt(<span class="string">"123456"</span>,sha1Key));</span><br><span class="line"></span><br><span class="line">        String sha224Key = initMacKey(KEY_HMAC_SHA224);</span><br><span class="line">        System.out.println(<span class="string">"HmacSHA224_Key:"</span>+sha224Key);</span><br><span class="line">        System.out.println(<span class="string">"HmacSHA224_Result:"</span>+hmacSHA224Encrypt(<span class="string">"123456"</span>,sha224Key));</span><br><span class="line"></span><br><span class="line">        String sha256Key = initMacKey(KEY_HMAC_SHA256);</span><br><span class="line">        System.out.println(<span class="string">"HmacSHA256_Key:"</span>+sha256Key);</span><br><span class="line">        System.out.println(<span class="string">"HmacSHA256_Result:"</span>+hmacSHA256Encrypt(<span class="string">"123456"</span>,sha256Key));</span><br><span class="line"></span><br><span class="line">        String sha384Key = initMacKey(KEY_HMAC_SHA384);</span><br><span class="line">        System.out.println(<span class="string">"HmacSHA384_Key:"</span>+sha384Key);</span><br><span class="line">        System.out.println(<span class="string">"HmacSHA384_Result:"</span>+hmacSHA384Encrypt(<span class="string">"123456"</span>,sha384Key));</span><br><span class="line"></span><br><span class="line">        String sha512Key = initMacKey(KEY_HMAC_SHA512);</span><br><span class="line">        System.out.println(<span class="string">"HmacSHA512_Key:"</span>+sha512Key);</span><br><span class="line">        System.out.println(<span class="string">"HmacSHA512_Result:"</span>+hmacSHA512Encrypt(<span class="string">"123456"</span>,sha512Key));</span><br><span class="line"></span><br><span class="line">        String md5Key = initMacKey(KEY_HMAC_MD5);</span><br><span class="line">        System.out.println(<span class="string">"HmacMD5_Key:"</span>+md5Key);</span><br><span class="line">        System.out.println(<span class="string">"HmacMD5_Result:"</span>+hmacMD5Encrypt(<span class="string">"123456"</span>,md5Key));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DES加密算法"><a href="#DES加密算法" class="headerlink" title="DES加密算法"></a>DES加密算法</h2><p>DES全称为Data Encryption Standard，直译即数据加密标准，是一种使用密钥加密的块算法。</p><p>它是一种对称可逆加密算法。</p><p>DES的加密密钥也是需要加密方和解密方都知道，因此存在泄漏的可能性。需要保护好密钥。</p><p>同时DES被证明是可以破解的，明文+密钥=密文，这个公式只要知道任何两个，就可以推导出第三个。</p><p>在已经知道明文和对应密文的情况下，通过穷举和暴力破解是可以破解DES的。</p><p>Java相关代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DESUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_ALGORITHM = <span class="string">"DESede"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认的加密算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CIPHER_ALGORITHM = <span class="string">"DESede/CBC/PKCS5Padding"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> iv</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encrypt</span><span class="params">(String data, String key,String iv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] keyBytes = key.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        <span class="keyword">byte</span>[] ivBytes = iv.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        <span class="keyword">if</span>(keyBytes.length &lt; <span class="number">24</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Key字节长度需大于等于24"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ivBytes.length != <span class="number">8</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"IV偏移量需要为8字节"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bt = encrypt(data.getBytes(StandardCharsets.UTF_8), keyBytes,ivBytes);</span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(bt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> iv</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decrypt</span><span class="params">(String data, String key,String iv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] keyBytes = key.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        <span class="keyword">byte</span>[] ivBytes = iv.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        <span class="keyword">if</span>(keyBytes.length &lt; <span class="number">24</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Key字节长度需大于等于24"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ivBytes.length != <span class="number">8</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"IV偏移量需要为8字节"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] buf = Base64.decodeBase64(data);</span><br><span class="line">        <span class="keyword">byte</span>[] bt = decrypt(buf, keyBytes,ivBytes);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(bt, StandardCharsets.UTF_8);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DES加密数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> iv</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encrypt(<span class="keyword">byte</span>[] data, <span class="keyword">byte</span>[] key,<span class="keyword">byte</span>[] iv) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 生成一个可信任的随机数源</span></span><br><span class="line">        SecureRandom sr = <span class="keyword">new</span> SecureRandom();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从原始密钥数据创建DESKeySpec对象</span></span><br><span class="line">        DESedeKeySpec dks = <span class="keyword">new</span> DESedeKeySpec(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个密钥工厂，然后用它把DESKeySpec转换成SecretKey对象</span></span><br><span class="line">        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(KEY_ALGORITHM);</span><br><span class="line">        SecretKey secretKey = keyFactory.generateSecret(dks);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Cipher对象实际完成加密操作</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);</span><br><span class="line"></span><br><span class="line">        IvParameterSpec ips = <span class="keyword">new</span> IvParameterSpec(iv);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用密钥初始化Cipher对象</span></span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, secretKey,ips, sr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DES解密数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> iv</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decrypt(<span class="keyword">byte</span>[] data, <span class="keyword">byte</span>[] key,<span class="keyword">byte</span>[] iv) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 生成一个可信任的随机数源</span></span><br><span class="line">        SecureRandom sr = <span class="keyword">new</span> SecureRandom();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从原始密钥数据创建DESKeySpec对象</span></span><br><span class="line">        DESedeKeySpec dks = <span class="keyword">new</span> DESedeKeySpec(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个密钥工厂，然后用它把DESKeySpec转换成SecretKey对象</span></span><br><span class="line">        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(KEY_ALGORITHM);</span><br><span class="line">        SecretKey secretKey = keyFactory.generateSecret(dks);</span><br><span class="line"></span><br><span class="line">        IvParameterSpec ips = <span class="keyword">new</span> IvParameterSpec(iv);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Cipher对象实际完成解密操作</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用密钥初始化Cipher对象</span></span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, secretKey,ips, sr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String text = <span class="string">"12345611111111111111111111111"</span>;</span><br><span class="line">        String key = <span class="string">"111111111111111111111张"</span>;</span><br><span class="line">        String iv = <span class="string">"张三81"</span>;</span><br><span class="line">        String result = encrypt(text,key,iv);</span><br><span class="line">        System.out.println(<span class="string">"DES加密："</span>+ result);</span><br><span class="line">        System.out.println(<span class="string">"DES解密："</span>+decrypt(result,key,iv));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AES加密算法"><a href="#AES加密算法" class="headerlink" title="AES加密算法"></a>AES加密算法</h2><p>AES（Advanced Encryption Standard），高级加密标准，这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。</p><p>它是一种对称可逆加密算法。</p><p>AES的加密密钥也是需要加密方和解密方都知道，因此也需要保护好密钥。</p><p>在使用AES加密时，我们一般使用CBC加密模式，这种加密模式安全性好，适合传输长报文，缺点是需要初始化向量IV。</p><p>对称加密的加密模式一般有4种，优缺点如下：</p><p>对称/分组密码一般分为流加密(如OFB、CFB等)和块加密(如ECB、CBC等)。对于流加密，需要将分组密码转化为流模式工作。对于块加密(或称分组加密)，如果要加密超过块大小的数据，就需要涉及填充和链加密模式。</p><ul><li><p>ECB(Electronic Code Book电子密码本)模式</p><p>ECB模式是最早采用和最简单的模式，它将加密的数据分成若干组，每组的大小跟加密密钥长度相同，然后每组都用相同的密钥进行加密。</p><p>优点:</p><ol><li>简单；　</li><li>有利于并行计算；</li><li>误差不会被传送；</li></ol><p>缺点:　</p><ol><li>不能隐藏明文的模式；　</li><li>可能对明文进行主动攻击；　</li></ol><p>因此，此模式适于加密小消息。</p></li><li><p>CBC(Cipher Block Chaining，加密块链)模式</p><p>优点：</p><ol><li>不容易主动攻击；</li><li>安全性好于ECB；</li><li>适合传输长度长的报文,是SSL、IPSec的标准。　</li></ol><p>缺点：　</p><ol><li>不利于并行计算；　</li><li>误差传递；　</li><li>需要初始化向量IV</li></ol></li><li><p>CFB(Cipher FeedBack Mode，加密反馈)模式</p><p>优点：</p><ol><li>隐藏了明文模式;　</li><li>分组密码转化为流模式;　</li><li>可以及时加密传送小于分组的数据;　</li></ol><p>缺点:　</p><ol><li>不利于并行计算;　</li><li>误差传送：一个明文单元损坏影响多个单元;　</li><li>唯一的IV;</li></ol></li><li><p>OFB(Output FeedBack，输出反馈)模式</p><p>优点:</p><ol><li>隐藏了明文模式;　</li><li>分组密码转化为流模式;　</li><li>可以及时加密传送小于分组的数据;　</li></ol><p>缺点:　</p><ol><li>不利于并行计算;　</li><li>对明文的主动攻击是可能的;　</li><li>误差传送：一个明文单元损坏影响多个单元</li></ol></li></ul><p>Java相关代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AESUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_ALGORITHM = <span class="string">"AES"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认的加密算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CIPHER_ALGORITHM = <span class="string">"AES/CBC/PKCS5Padding"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 随机数算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RANDOM_ALGORITHM = <span class="string">"SHA1PRNG"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * IV向量长度必须为16</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IV_PARAM_LENGTH = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AES支持的密钥长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SECRET_KEY_LENGTH_128 = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SECRET_KEY_LENGTH_192 = <span class="number">192</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SECRET_KEY_LENGTH_256 = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 密钥种子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String secretKeySeed = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * IV向量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String ivParameterSeed = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AESUtils</span><span class="params">(String secretKeySeed, String ivParameterSeed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.secretKeySeed = secretKeySeed;</span><br><span class="line">        <span class="keyword">if</span> (ivParameterSeed.length() != IV_PARAM_LENGTH) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"iv向量长度必须为16"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.ivParameterSeed=ivParameterSeed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">encrypt</span><span class="params">(String content)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// AES加密</span></span><br><span class="line">        <span class="keyword">byte</span>[] encryptStr = encrypt(content, secretKeySeed,ivParameterSeed);</span><br><span class="line">        <span class="comment">// BASE64位加密</span></span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(encryptStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptStr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decrypt</span><span class="params">(String encryptStr)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// BASE64位解密</span></span><br><span class="line">        <span class="keyword">byte</span>[] decodeBase64 = Base64.decodeBase64(encryptStr);</span><br><span class="line">        <span class="comment">// AES解密</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(decrypt(decodeBase64, secretKeySeed,ivParameterSeed),StandardCharsets.UTF_8);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成加密秘钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> secretKeySeed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> SecretKeySpec <span class="title">getSecretKeySpec</span><span class="params">(<span class="keyword">final</span> String secretKeySeed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//生成指定算法密钥生成器的 KeyGenerator 对象</span></span><br><span class="line">            KeyGenerator keyGenerator = KeyGenerator.getInstance(KEY_ALGORITHM);</span><br><span class="line">            <span class="comment">// 防止linux下 随机生成key</span></span><br><span class="line">            SecureRandom secureRandom = SecureRandom.getInstance(RANDOM_ALGORITHM);</span><br><span class="line">            secureRandom.setSeed(secretKeySeed.getBytes());</span><br><span class="line">            <span class="comment">//AES 要求密钥长度为 128/192/256</span></span><br><span class="line">            keyGenerator.init(SECRET_KEY_LENGTH_128, secureRandom);</span><br><span class="line">            <span class="comment">//生成一个密钥</span></span><br><span class="line">            SecretKey secretKey = keyGenerator.generateKey();</span><br><span class="line">            <span class="comment">// 转换为AES专用密钥</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SecretKeySpec(secretKey.getEncoded(), KEY_ALGORITHM);</span><br><span class="line"><span class="comment">//            //注意：ios不支持使用 KeyGenerator、SecureRandom、SecretKey 生成</span></span><br><span class="line"><span class="comment">//            return new SecretKeySpec(secretKeySeed.getBytes(), KEY_ALGORITHM);</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            log.error(ex.getMessage(), ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成向量秘钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ivParameterSeed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IvParameterSpec <span class="title">getIvParameterSpec</span><span class="params">(<span class="keyword">final</span> String ivParameterSeed)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用CBC模式，需要一个向量iv，可增加加密算法的强度</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IvParameterSpec(ivParameterSeed.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> secretKeySeed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ivParameterSeed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encrypt(String content, String secretKeySeed,String ivParameterSeed) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建密码器</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);</span><br><span class="line">        <span class="comment">// 初始化为加密模式的密码器</span></span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, getSecretKeySpec(secretKeySeed),getIvParameterSpec(ivParameterSeed));</span><br><span class="line">        <span class="comment">// 加密</span></span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(content.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> secretKeySeed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ivParameterSeed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decrypt(<span class="keyword">byte</span>[] content, String secretKeySeed,String ivParameterSeed) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建密码器</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);</span><br><span class="line">        <span class="comment">// 初始化为加密模式的密码器</span></span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, getSecretKeySpec(secretKeySeed),getIvParameterSpec(ivParameterSeed));</span><br><span class="line">        <span class="comment">// 解密</span></span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String secretKeySeed = <span class="string">"test123456"</span>;</span><br><span class="line">        String ivParameterSeed = <span class="string">"ivPar-test-hello"</span>;</span><br><span class="line">        String message = <span class="string">"test1234567890"</span>;</span><br><span class="line">        AESUtils aesUtils = <span class="keyword">new</span> AESUtils(secretKeySeed,ivParameterSeed);</span><br><span class="line">        String a= aesUtils.encrypt(message);</span><br><span class="line">        System.out.println(<span class="string">"加密后的字符："</span> + a);</span><br><span class="line">        System.out.println(<span class="string">"解密后的字符："</span> + aesUtils.decrypt(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RSA加密算法"><a href="#RSA加密算法" class="headerlink" title="RSA加密算法"></a>RSA加密算法</h2><p>它是一种非对称可逆加密算法，其密钥由公钥和私钥组成，公钥外部暴露，用于数据加密，私钥保密，用于解密数据。</p><p>RSA公开密钥密码体制是一种使用不同的加密密钥与解密密钥，“由已知加密密钥推导出解密密钥在计算上是不可行的”密码体制。</p><p>RSA公开密钥密码体制的原理是：根据数论，寻求两个大素数比较简单，而将它们的乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。</p><p>RSA的安全性依赖于大数分解，但是否等同于大数分解一直未能得到理论上的证明，也并没有从理论上证明破译。RSA的难度与大数分解难度等价。</p><p>RSA算法的保密强度随其密钥的长度增加而增强。但是，密钥越长，其加解密所耗用的时间也越长。因此，要根据所保护信息的敏感程度与攻击者破解所要花费的代价值不值得以及系统所要求的反应时间来综合考虑。一般情况下，公钥长度最好选择1024位及以上。</p><p>由于进行的都是大数计算，使得RSA最快的情况也比DES慢上好几倍，无论是软件还是硬件实现。速度一直是RSA的缺陷。一般来说只用于少量数据加密。RSA的速度比对应同样安全级别的对称密码算法要慢1000倍左右。</p><p>由于RSA加密数据长度不超过 <code>密钥长度/8 - 11</code>，解密长度不超过 <code>密钥长度/8</code>，因此对于较长数据，一般有两种方法进行处理：一是在使用RSA加密前，先使用一些对称加密算法将数据加密，使得加密后长度在RSA允许范围内，在使用RSA加密；二是使用RSA分段加密。</p><p>下面代码提供了RSA分段加密的算法，一般情况下，由于RSA加解密速度慢，耗资源，我们在双方通信中，先使用RSA进行通信，成功后协定双方对称加密密钥（如AES密钥），而后在使用对称加密算法（如AES）进行数据传输。</p><p>Java相关代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RSAUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数字签名，密钥算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RSA_KEY_ALGORITHM = <span class="string">"RSA"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数字签名签名/验证算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SIGNATURE_ALGORITHM = <span class="string">"MD5withRSA"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * RSA密钥长度，RSA算法的默认密钥长度是1024密钥长度必须是64的倍数，在512到65536位之间</span></span><br><span class="line"><span class="comment">     * PS:值改变后 最大加密字节数、最大解密字节数会随之变化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEY_SIZE = <span class="number">2048</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * bits转换为byte单位</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BASE_SIZE = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大加密字节数，超出最大字节数需要分组加密</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ENCRYPT_BLOCK = KEY_SIZE / BASE_SIZE - <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大解密字节数，超出最大字节数需要分组解密</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_DECRYPT_BLOCK = KEY_SIZE / BASE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成密钥对</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, String&gt; <span class="title">initKey</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        KeyPairGenerator keygen = KeyPairGenerator.getInstance(RSA_KEY_ALGORITHM);</span><br><span class="line">        <span class="comment">//初始化密钥生成器</span></span><br><span class="line">        keygen.initialize(KEY_SIZE);</span><br><span class="line">        KeyPair keys = keygen.genKeyPair();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] pubKey = keys.getPublic().getEncoded();</span><br><span class="line">        String publicKeyString = Base64.encodeBase64String(pubKey);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] priKey = keys.getPrivate().getEncoded();</span><br><span class="line">        String privateKeyString = Base64.encodeBase64String(priKey);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; keyPairMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        keyPairMap.put(<span class="string">"publicKeyString"</span>, publicKeyString);</span><br><span class="line">        keyPairMap.put(<span class="string">"privateKeyString"</span>, privateKeyString);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> keyPairMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 密钥转成byte[]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decodeBase64(String key) &#123;</span><br><span class="line">        <span class="keyword">return</span> Base64.decodeBase64(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 获取公钥</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> publicKey 公钥字符串</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PublicKey <span class="title">getPublicKey</span><span class="params">(String publicKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">         KeyFactory keyFactory = KeyFactory.getInstance(RSA_KEY_ALGORITHM);</span><br><span class="line">         <span class="keyword">byte</span>[] decodedKey = Base64.decodeBase64(publicKey.getBytes());</span><br><span class="line">         X509EncodedKeySpec keySpec = <span class="keyword">new</span> X509EncodedKeySpec(decodedKey);</span><br><span class="line">         <span class="keyword">return</span> keyFactory.generatePublic(keySpec);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 获取私钥</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> privateKey 私钥字符串</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PrivateKey <span class="title">getPrivateKey</span><span class="params">(String privateKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">         KeyFactory keyFactory = KeyFactory.getInstance(RSA_KEY_ALGORITHM);</span><br><span class="line">         <span class="keyword">byte</span>[] decodedKey = Base64.decodeBase64(privateKey.getBytes());</span><br><span class="line">         PKCS8EncodedKeySpec keySpec = <span class="keyword">new</span> PKCS8EncodedKeySpec(decodedKey);</span><br><span class="line">         <span class="keyword">return</span> keyFactory.generatePrivate(keySpec);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公钥加密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data      加密前的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey 公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 加密后的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encryptByPubKey</span><span class="params">(String data, String publicKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] pubKey = RSAUtils.decodeBase64(publicKey);</span><br><span class="line">        <span class="keyword">byte</span>[] enSign = encryptByPubKey(data.getBytes(), pubKey);</span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(enSign);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公钥加密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data   待加密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pubKey 公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encryptByPubKey(<span class="keyword">byte</span>[] data, <span class="keyword">byte</span>[] pubKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        X509EncodedKeySpec x509KeySpec = <span class="keyword">new</span> X509EncodedKeySpec(pubKey);</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(RSA_KEY_ALGORITHM);</span><br><span class="line">        PublicKey publicKey1 = keyFactory.generatePublic(x509KeySpec);</span><br><span class="line">        Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, publicKey1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标识</span></span><br><span class="line">        <span class="keyword">int</span> offSet = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] resultBytes = &#123;&#125;;</span><br><span class="line">        <span class="keyword">byte</span>[] cache = &#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> inputLength = data.length;</span><br><span class="line">        <span class="keyword">while</span> (inputLength - offSet &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inputLength - offSet &gt; MAX_ENCRYPT_BLOCK) &#123;</span><br><span class="line">                cache = cipher.doFinal(data, offSet, MAX_ENCRYPT_BLOCK);</span><br><span class="line">                offSet += MAX_ENCRYPT_BLOCK;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cache = cipher.doFinal(data, offSet, inputLength - offSet);</span><br><span class="line">                offSet = inputLength;</span><br><span class="line">            &#125;</span><br><span class="line">            resultBytes = Arrays.copyOf(resultBytes, resultBytes.length + cache.length);</span><br><span class="line">            System.arraycopy(cache, <span class="number">0</span>, resultBytes, resultBytes.length - cache.length, cache.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私钥解密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data   待解密的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> priKey 私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decryptByPriKey(<span class="keyword">byte</span>[] data, <span class="keyword">byte</span>[] priKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        PKCS8EncodedKeySpec pkcs8KeySpec = <span class="keyword">new</span> PKCS8EncodedKeySpec(priKey);</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(RSA_KEY_ALGORITHM);</span><br><span class="line">        PrivateKey privateKey1 = keyFactory.generatePrivate(pkcs8KeySpec);</span><br><span class="line">        Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, privateKey1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> inputLen = data.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> offSet = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] cache;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 对数据分段解密</span></span><br><span class="line">        <span class="keyword">byte</span>[] decryptedData = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>(ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream())&#123;</span><br><span class="line">            <span class="keyword">while</span> (inputLen - offSet &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (inputLen - offSet &gt; MAX_DECRYPT_BLOCK) &#123;</span><br><span class="line">                    cache = cipher.doFinal(data, offSet, MAX_DECRYPT_BLOCK);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cache = cipher.doFinal(data, offSet, inputLen - offSet);</span><br><span class="line">                &#125;</span><br><span class="line">                out.write(cache, <span class="number">0</span>, cache.length);</span><br><span class="line">                i++;</span><br><span class="line">                offSet = i * MAX_DECRYPT_BLOCK;</span><br><span class="line">            &#125;</span><br><span class="line">            decryptedData = out.toByteArray();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            log.error(e.getMessage(),e);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> decryptedData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私钥解密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data       解密前的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey 私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 解密后的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decryptByPriKey</span><span class="params">(String data, String privateKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] priKey = RSAUtils.decodeBase64(privateKey);</span><br><span class="line">        <span class="keyword">byte</span>[] design = decryptByPriKey(Base64.decodeBase64(data), priKey);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(design);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 签名</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> signVo 待签名数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey 私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 签名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">sign</span><span class="params">(SignVo signVo, String privateKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">         PrivateKey privateKeys = getPrivateKey(privateKey);</span><br><span class="line">         String data = toSignStrMap(signVo);</span><br><span class="line">         <span class="keyword">byte</span>[] keyBytes = privateKeys.getEncoded();</span><br><span class="line">         PKCS8EncodedKeySpec keySpec = <span class="keyword">new</span> PKCS8EncodedKeySpec(keyBytes);</span><br><span class="line">         KeyFactory keyFactory = KeyFactory.getInstance(RSA_KEY_ALGORITHM);</span><br><span class="line">         PrivateKey key = keyFactory.generatePrivate(keySpec);</span><br><span class="line">         Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM);</span><br><span class="line">         signature.initSign(key);</span><br><span class="line">         signature.update(data.getBytes());</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> String(Base64.encodeBase64(signature.sign()));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 验签</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> signVo 签名实体</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> publicKey 公钥</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> sign 签名</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@return</span> 是否验签通过</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(SignVo signVo, String publicKey, String sign)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">         PublicKey publicKeys = getPublicKey(publicKey);</span><br><span class="line">         String srcData = toSignStrMap(signVo);</span><br><span class="line">         <span class="keyword">byte</span>[] keyBytes = publicKeys.getEncoded();</span><br><span class="line">         <span class="comment">// 初始化公钥</span></span><br><span class="line">         X509EncodedKeySpec keySpec = <span class="keyword">new</span> X509EncodedKeySpec(keyBytes);</span><br><span class="line">         <span class="comment">// 实例化密钥工厂</span></span><br><span class="line">         KeyFactory keyFactory = KeyFactory.getInstance(RSA_KEY_ALGORITHM);</span><br><span class="line">         <span class="comment">// 产生公钥</span></span><br><span class="line">         PublicKey key = keyFactory.generatePublic(keySpec);</span><br><span class="line">         <span class="comment">// 实例化Signature</span></span><br><span class="line">         Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM);</span><br><span class="line">         <span class="comment">// 初始化Signature</span></span><br><span class="line">         signature.initVerify(key);</span><br><span class="line">         signature.update(srcData.getBytes());</span><br><span class="line">         <span class="keyword">return</span> signature.verify(Base64.decodeBase64(sign.getBytes()));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 签名串拼接  格式：标志A&amp;标志B&amp;标志C.....   中间用 &amp; 连接</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> signVo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toSignStrMap</span><span class="params">(SignVo signVo)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(signVo.getSignA()).append(<span class="string">"&amp;"</span>).append(signVo.getSignB()).append(<span class="string">"&amp;"</span>).append(signVo.getSignC());</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Map&lt;String, String&gt; keyMap = initKey();</span><br><span class="line">            String publicKeyString = keyMap.get(<span class="string">"publicKeyString"</span>);</span><br><span class="line">            String privateKeyString = keyMap.get(<span class="string">"privateKeyString"</span>);</span><br><span class="line">            System.out.println(<span class="string">"公钥:"</span> + publicKeyString);</span><br><span class="line">            System.out.println(<span class="string">"私钥:"</span> + privateKeyString);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 待加密数据</span></span><br><span class="line">            String data = <span class="string">"&#123;\"code\":\"0000\",\"data\":&#123;\"list\":[&#123;\"address\":\"互联网创业中心\",\"amount\":120000.0,\"applicationDate\":1594174666000,\"createDate\":1594174666000,\"ecCode\":\"MC0001\",\"ecName\":\"ARJ\",\"ecOrderNumber\":\"20202070817261111\",\"orderNumber\":\"AR202007081017453500\",\"payOrderNumber\":\"\",\"phone\":\"1860000000\",\"productList\":[&#123;\"name\":\"小米18\",\"number\":2,\"pictureUrl\":\"https://dss0.bdstatic.com/-0U0bnSm1A5BphGlnYG/tam-ogel/93d9d2b0e5373b93ca5032d13866fd14_254_144.jpg\",\"price\":60000.0&#125;],\"repayDay\":\"08\",\"stageAmount\":40000.0,\"stageNumber\":3,\"status\":\"01\",\"total\":2,\"updateDate\":1594261066000,\"userId\":\"56f72c55c0cc11ea8c81fa163efd3ee0\"&#125;,&#123;\"address\":\"互联网创业中心\",\"amount\":60000.0,\"applicationDate\":1594173896000,\"createDate\":1594173896000,\"ecCode\":\"MC0001\",\"ecName\":\"ARJ\",\"ecOrderNumber\":\"20202070817260000\",\"orderNumber\":\"AR202007081004565300\",\"payOrderNumber\":\"\",\"phone\":\"137777777\",\"productList\":[&#123;\"name\":\"华为P40\",\"number\":2,\"pictureUrl\":\"https://consumer-img.huawei.com/content/dam/huawei-cbg-site/common/mkt/pdp/phones/p40-pro-plus-specs/cn/dimage.jpg\",\"price\":30000.0&#125;],\"repayDay\":\"08\",\"stageAmount\":20000.0,\"stageNumber\":3,\"status\":\"01\",\"total\":2,\"updateDate\":1594260296000,\"userId\":\"56f72c55c0cc11ea8c81fa163efd3ee0\"&#125;]&#125;,\"msg\":\"成功\",\"showMsg\":\"success\"&#125;"</span>;</span><br><span class="line">            <span class="comment">// 公钥加密</span></span><br><span class="line">            String encrypt = RSAUtils.encryptByPubKey(data, publicKeyString);</span><br><span class="line">            <span class="comment">// 私钥解密</span></span><br><span class="line">            String decrypt = RSAUtils.decryptByPriKey(encrypt, privateKeyString);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"加密前:"</span> + data);</span><br><span class="line">            System.out.println(<span class="string">"加密后:"</span> + encrypt);</span><br><span class="line">            System.out.println(<span class="string">"解密后:"</span> + decrypt);</span><br><span class="line"></span><br><span class="line">            SignVo signVo = <span class="keyword">new</span> SignVo();</span><br><span class="line">            signVo.setSignA(<span class="string">"testA"</span>);</span><br><span class="line">            signVo.setSignB(<span class="string">"testB"</span>);</span><br><span class="line">            signVo.setSignC(<span class="string">"testC"</span>);</span><br><span class="line">            String sign = RSAUtils.sign(signVo,privateKeyString);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"签名:"</span>+sign);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> result = RSAUtils.verify(signVo,publicKeyString,sign);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"验签结果:"</span>+result);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SignVo</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标志A</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String signA;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标志B</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String signB;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标志C</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String signC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DH加密算法"><a href="#DH加密算法" class="headerlink" title="DH加密算法"></a>DH加密算法</h2><p>上面我们说到非对称加密算法加密速度慢，耗资源，可以使用非对称加密算法进行通信，协商密钥后，在使用对称加密算法进行数据传输，这就是DH加密算法的核心。</p><p>其实也可以说DH加密算法是一种建立密钥的方法，而不是加密方法。</p><p>我们以甲乙双方发送数据为模型进行分析：</p><ol><li><p>甲方（消息发送方，下同）构建密钥对（公钥+私钥），甲方公布公钥给乙方（消息接收方，下同）;</p></li><li><p>乙方以甲方发送过来的公钥作为参数构造密钥对（公钥+私钥），将构造出来的公钥公布给甲方;</p></li><li><p>甲方用“甲方的私钥 + 乙方的公钥”构造本地密钥;</p></li><li><p>乙方用“乙方的私钥 + 甲方的公钥”构造本地的密钥;</p></li><li><p>这个时候，甲乙两方本地新构造出来的密钥应该一样，甲乙双方可以通过本地密钥进行数据的加密和解密;</p></li><li><p>然后就可以使用AES/DES这类对称加密算法进行数据的安全传送了。</p></li></ol><p>Java相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DHUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ALGORITHM = <span class="string">"DH"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认密钥字节数</span></span><br><span class="line"><span class="comment">     * 需要为64的倍数，且在512到1024之间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEY_SIZE = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DH加密下需要一种对称加密算法对数据加密，这里我们使用DES，也可以使用其他对称加密算法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SECRET_ALGORITHM = <span class="string">"DES"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公钥私钥Key值，便于从Map获取</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PUBLIC_KEY = <span class="string">"DHPublicKey"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PRIVATE_KEY = <span class="string">"DHPrivateKey"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化甲方密钥</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title">initKey</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(ALGORITHM);</span><br><span class="line">        keyPairGenerator.initialize(KEY_SIZE);</span><br><span class="line"></span><br><span class="line">        KeyPair keyPair = keyPairGenerator.generateKeyPair();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 甲方公钥</span></span><br><span class="line">        DHPublicKey publicKey = (DHPublicKey) keyPair.getPublic();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 甲方私钥</span></span><br><span class="line">        DHPrivateKey privateKey = (DHPrivateKey) keyPair.getPrivate();</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; keyMap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        keyMap.put(PUBLIC_KEY, publicKey);</span><br><span class="line">        keyMap.put(PRIVATE_KEY, privateKey);</span><br><span class="line">        <span class="keyword">return</span> keyMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化乙方密钥</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 甲方公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title">initKey</span><span class="params">(String key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 解析甲方公钥</span></span><br><span class="line">        <span class="keyword">byte</span>[] keyBytes = Base64.decodeBase64(key);</span><br><span class="line">        X509EncodedKeySpec x509KeySpec = <span class="keyword">new</span> X509EncodedKeySpec(keyBytes);</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(ALGORITHM);</span><br><span class="line">        PublicKey pubKey = keyFactory.generatePublic(x509KeySpec);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由甲方公钥构建乙方密钥</span></span><br><span class="line">        DHParameterSpec dhParamSpec = ((DHPublicKey) pubKey).getParams();</span><br><span class="line"></span><br><span class="line">        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(keyFactory.getAlgorithm());</span><br><span class="line">        keyPairGenerator.initialize(dhParamSpec);</span><br><span class="line"></span><br><span class="line">        KeyPair keyPair = keyPairGenerator.generateKeyPair();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 乙方公钥</span></span><br><span class="line">        DHPublicKey publicKey = (DHPublicKey) keyPair.getPublic();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 乙方私钥</span></span><br><span class="line">        DHPrivateKey privateKey = (DHPrivateKey) keyPair.getPrivate();</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; keyMap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        keyMap.put(PUBLIC_KEY, publicKey);</span><br><span class="line">        keyMap.put(PRIVATE_KEY, privateKey);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> keyMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data       待加密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey  甲方公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey 乙方私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encrypt(<span class="keyword">byte</span>[] data, String publicKey,String privateKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成本地密钥</span></span><br><span class="line">        SecretKey secretKey = getSecretKey(publicKey, privateKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数据加密</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(secretKey.getAlgorithm());</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, secretKey);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data  待加密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey 甲方公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey 乙方私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encrypt</span><span class="params">(String data, String publicKey,String privateKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = data.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        <span class="keyword">byte</span>[] result = encrypt(bytes,publicKey,privateKey);</span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data       待解密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey  乙方公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey 乙方私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decrypt(<span class="keyword">byte</span>[] data, String publicKey, String privateKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成本地密钥</span></span><br><span class="line">        SecretKey secretKey = getSecretKey(publicKey, privateKey);</span><br><span class="line">        <span class="comment">// 数据解密</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(secretKey.getAlgorithm());</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, secretKey);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 待解密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey 乙方公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey 甲方私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decrypt</span><span class="params">(String data, String publicKey, String privateKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = Base64.decodeBase64(data);</span><br><span class="line">        <span class="keyword">byte</span>[] result = decrypt(bytes,publicKey,privateKey);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(result,StandardCharsets.UTF_8);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建密钥</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey  公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey 私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> SecretKey <span class="title">getSecretKey</span><span class="params">(String publicKey, String privateKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化公钥</span></span><br><span class="line">        <span class="keyword">byte</span>[] pubKeyBytes = Base64.decodeBase64(publicKey);</span><br><span class="line"></span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(ALGORITHM);</span><br><span class="line">        X509EncodedKeySpec x509KeySpec = <span class="keyword">new</span> X509EncodedKeySpec(pubKeyBytes);</span><br><span class="line">        PublicKey pubKey = keyFactory.generatePublic(x509KeySpec);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化私钥</span></span><br><span class="line">        <span class="keyword">byte</span>[] priKeyBytes = Base64.decodeBase64(privateKey);</span><br><span class="line"></span><br><span class="line">        PKCS8EncodedKeySpec pkcs8KeySpec = <span class="keyword">new</span> PKCS8EncodedKeySpec(priKeyBytes);</span><br><span class="line">        Key priKey = keyFactory.generatePrivate(pkcs8KeySpec);</span><br><span class="line"></span><br><span class="line">        KeyAgreement keyAgree = KeyAgreement.getInstance(keyFactory.getAlgorithm());</span><br><span class="line">        keyAgree.init(priKey);</span><br><span class="line">        keyAgree.doPhase(pubKey, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成本地密钥</span></span><br><span class="line">        SecretKey secretKey = keyAgree.generateSecret(SECRET_ALGORITHM);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> secretKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取得私钥</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyMap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPrivateKey</span><span class="params">(Map&lt;String, Object&gt; keyMap)</span></span>&#123;</span><br><span class="line">        Key key = (Key) keyMap.get(PRIVATE_KEY);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(key.getEncoded());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取得公钥</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyMap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPublicKey</span><span class="params">(Map&lt;String, Object&gt; keyMap)</span></span>&#123;</span><br><span class="line">        Key key = (Key) keyMap.get(PUBLIC_KEY);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(key.getEncoded());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 生成甲方密钥对</span></span><br><span class="line">        Map&lt;String, Object&gt; aKeyMap = DHUtils.initKey();</span><br><span class="line">        String aPublicKey = DHUtils.getPublicKey(aKeyMap);</span><br><span class="line">        String aPrivateKey = DHUtils.getPrivateKey(aKeyMap);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"甲方公钥:"</span> + aPublicKey);</span><br><span class="line">        System.out.println(<span class="string">"甲方私钥:"</span> + aPrivateKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由甲方公钥产生本地密钥对</span></span><br><span class="line">        Map&lt;String, Object&gt; bKeyMap = DHUtils.initKey(aPublicKey);</span><br><span class="line">        String bPublicKey = DHUtils.getPublicKey(bKeyMap);</span><br><span class="line">        String bPrivateKey = DHUtils.getPrivateKey(bKeyMap);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"乙方公钥:"</span> + bPublicKey);</span><br><span class="line">        System.out.println(<span class="string">"乙方私钥:"</span> + bPrivateKey);</span><br><span class="line"></span><br><span class="line">        String aInput = <span class="string">"abc "</span>;</span><br><span class="line">        System.out.println(<span class="string">"原数据: "</span> + aInput);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由甲方公钥，乙方私钥构建密文</span></span><br><span class="line">        String aCode = DHUtils.encrypt(aInput, aPublicKey,bPrivateKey);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"加密："</span>+aCode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由乙方公钥，甲方私钥解密</span></span><br><span class="line">        String aDecode = DHUtils.decrypt(aCode, bPublicKey, aPrivateKey);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"解密: "</span> + aDecode);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String bInput = <span class="string">"def "</span>;</span><br><span class="line">        System.out.println(<span class="string">"原数据: "</span> + bInput);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由乙方公钥，甲方私钥构建密文</span></span><br><span class="line">        String bCode = DHUtils.encrypt(bInput, bPublicKey,aPrivateKey);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"加密："</span>+bCode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由甲方公钥，乙方私钥解密</span></span><br><span class="line">        String bDecode = DHUtils.decrypt(bCode, aPublicKey, bPrivateKey);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"解密: "</span> + bDecode);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ECC椭圆加密算法"><a href="#ECC椭圆加密算法" class="headerlink" title="ECC椭圆加密算法"></a>ECC椭圆加密算法</h2><p>椭圆加密算法（ECC）是一种公钥加密体制，其数学基础是利用椭圆曲线上的有理点构成Abel加法群上椭圆离散对数的计算困难性。</p><p>因此其也是一种非对称可逆加密算法。</p><p>相比RSA加密算法，ECC加密算法的安全性更高，有研究表明160位的椭圆密钥与1024位的RSA密钥安全性相同。</p><p>同时在私钥的加密解密速度上，ECC算法比RSA速度更快。</p><p>Java目前不支持ECC算法的加解密，只支持公私钥的生成，这儿我们引入<code>org.bouncycastle.bcprov-jdk15on</code>包，来实现Java下的ECC加密算法。</p><p>pom文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.bouncycastle/bcprov-jdk15on --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.bouncycastle&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;bcprov-jdk15on&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.66&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>Java相关代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ECCUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ALGORITHM = <span class="string">"EC"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PROVIDER = <span class="string">"BC"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TRANSFORM = <span class="string">"ECIES"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Map key值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PUBLIC_KEY = <span class="string">"publicKey"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PRIVATE_KEY = <span class="string">"privateKey"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Java目前不支持ECC加解密，只支持公私钥的生成</span></span><br><span class="line"><span class="comment">     * 这儿我们使用BouncyCastleProvider来支持ECC加密算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        Security.addProvider(<span class="keyword">new</span> BouncyCastleProvider());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成秘钥对</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> KeyPair <span class="title">getKeyPair</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(ALGORITHM, PROVIDER);</span><br><span class="line"></span><br><span class="line">        keyPairGenerator.initialize(SIZE, <span class="keyword">new</span> SecureRandom());</span><br><span class="line">        KeyPair keyPair = keyPairGenerator.generateKeyPair();</span><br><span class="line">        <span class="keyword">return</span> keyPair;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyPair</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPublicKey</span><span class="params">(KeyPair keyPair)</span></span>&#123;</span><br><span class="line">        ECPublicKey publicKey = (ECPublicKey) keyPair.getPublic();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = publicKey.getEncoded();</span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyPair</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPrivateKey</span><span class="params">(KeyPair keyPair)</span></span>&#123;</span><br><span class="line">        ECPrivateKey privateKey = (ECPrivateKey) keyPair.getPrivate();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = privateKey.getEncoded();</span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(bytes);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将Base64编码后的公钥转换成PublicKey对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pubStr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ECPublicKey <span class="title">string2PublicKey</span><span class="params">(String pubStr)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] keyBytes = Base64.decodeBase64(pubStr);</span><br><span class="line"></span><br><span class="line">        X509EncodedKeySpec keySpec = <span class="keyword">new</span> X509EncodedKeySpec(keyBytes);</span><br><span class="line"></span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(ALGORITHM,PROVIDER);</span><br><span class="line"></span><br><span class="line">        ECPublicKey publicKey = (ECPublicKey) keyFactory.generatePublic(keySpec);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> publicKey;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将Base64编码后的私钥转换成PrivateKey对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> priStr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ECPrivateKey <span class="title">string2PrivateKey</span><span class="params">(String priStr)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] keyBytes = Base64.decodeBase64(priStr);</span><br><span class="line"></span><br><span class="line">        PKCS8EncodedKeySpec keySpec = <span class="keyword">new</span> PKCS8EncodedKeySpec(keyBytes);</span><br><span class="line"></span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(ALGORITHM, PROVIDER);</span><br><span class="line"></span><br><span class="line">        ECPrivateKey privateKey = (ECPrivateKey) keyFactory.generatePrivate(keySpec);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> privateKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用公钥加密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encryptByPublicKey(<span class="keyword">byte</span>[] content,PublicKey publicKey) <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">        Cipher cipher = Cipher.getInstance(TRANSFORM,PROVIDER);</span><br><span class="line"></span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE,publicKey);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = cipher.doFinal(content);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私钥解密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decryptByPrivateKey(<span class="keyword">byte</span>[] content, PrivateKey privateKey) <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">        Cipher cipher = Cipher.getInstance(TRANSFORM,PROVIDER);</span><br><span class="line"></span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE,privateKey);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = cipher.doFinal(content);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encrypt</span><span class="params">(String content,String publicKey)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ECPublicKey pubKey = string2PublicKey(publicKey);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = content.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        <span class="keyword">byte</span>[] result = encryptByPublicKey(bytes,pubKey);</span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cipherText</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decrypt</span><span class="params">(String cipherText,String privateKey)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ECPrivateKey priKey = string2PrivateKey(privateKey);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = Base64.decodeBase64(cipherText);</span><br><span class="line">        <span class="keyword">byte</span>[] result = decryptByPrivateKey(bytes,priKey);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(result,StandardCharsets.UTF_8);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成一组密钥对</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String,String&gt; <span class="title">initKeyPairStr</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        KeyPair keyPair = ECCUtils.getKeyPair();</span><br><span class="line">        String publicKeyStr =ECCUtils.getPublicKey(keyPair);</span><br><span class="line">        String privateKeyStr = ECCUtils.getPrivateKey(keyPair);</span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(PUBLIC_KEY,publicKeyStr);</span><br><span class="line">        map.put(PRIVATE_KEY,privateKeyStr);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String text = <span class="string">"131sdfsfd张庆伟金额取"</span>;</span><br><span class="line">        Map&lt;String,String&gt; keyPair = initKeyPairStr();</span><br><span class="line">        String publicKey = keyPair.get(PUBLIC_KEY);</span><br><span class="line">        String privateKey = keyPair.get(PRIVATE_KEY);</span><br><span class="line">        System.out.println(<span class="string">"公钥："</span>+publicKey);</span><br><span class="line">        System.out.println(<span class="string">"私钥："</span>+privateKey);</span><br><span class="line">        String encrypt = encrypt(text,publicKey);</span><br><span class="line">        System.out.println(<span class="string">"加密数据："</span>+encrypt);</span><br><span class="line">        String decrypt = decrypt(encrypt,privateKey);</span><br><span class="line">        System.out.println(<span class="string">"解密数据："</span>+decrypt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是比较常用的一些加密算法，当然有一些其他的加密算法，如DSA等这儿未作涉及，有兴趣的也可以查看相关资料等。</p><p>了解一些加密算法，以便在设计系统时可以正确选择合适的数据加密算法，来保证系统更加稳定、可靠的运行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="加密算法" scheme="https://www.sakuratears.top/tags/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Mysql数据库设计命名规范</title>
    <link href="https://www.sakuratears.top/blog/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83.html"/>
    <id>https://www.sakuratears.top/blog/Mysql数据库设计命名规范.html</id>
    <published>2020-07-12T08:15:00.000Z</published>
    <updated>2021-01-10T10:08:42.099Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数据库涉及字符规范"><a href="#数据库涉及字符规范" class="headerlink" title="数据库涉及字符规范"></a>数据库涉及字符规范</h1><p>采用 <code>26</code> 个英文字母（区分大小写）和 <code>0-9</code> 这十个自然数，加上下划线<code>‘_’</code>组成，共<code>37</code>个字符。不能出现其他字符(注释除外)。</p><p><strong>注意事项：</strong></p><ol><li><p>以上命名都不得超过 <code>30</code> 个字符的系统限制。变量名的长度限制为<code>29</code>（不包括标识字符<code>@</code>）。</p></li><li><p>数据对象、变量的命名都采用英文字符，禁止使用中文命名。绝对不要在对象名的字符之间留空格。</p></li><li><p>小心保留词，要保证你的字段名没有和保留词、数据库系统或者常用访问方法冲突, 当表名或字段名乃至数据库名和保留字冲突时，在sql语句里可以用撇号（<code>`</code>）括起来。</p></li><li><p>保持字段名和类型的一致性，在命名字段并为其指定数据类型的时候一定要保证一致性。假如数据类型在一个表里是整数，那在另一个表里也要保证是整型。</p></li></ol><h1 id="数据库命名规范"><a href="#数据库命名规范" class="headerlink" title="数据库命名规范"></a>数据库命名规范</h1><p>数据库名使用小写英文以及下划线组成（公司简称+项目名）。比如:</p><p><code>baidu_oa<br>ailibaba_cloud</code></p><p>备份数据库名使用正式库名加上备份时间组成，如:</p><p><code>dbname_20150206</code></p><p>数据库创建时，显式指定字符集。</p><h1 id="数据库表命名规范"><a href="#数据库表命名规范" class="headerlink" title="数据库表命名规范"></a>数据库表命名规范</h1><p>数据表名使用小写英文以及下划线组成（项目名+表信息），并且创建数据库时，显式指定默认字符集。</p><p>比如:</p><p><code>oa_user<br>oa_workflow_steps</code></p><p>备份数据表名使用正式表名加上备份时间组成，如:</p><p><code>oa_user_20150206<br>oa_workflow_step_20150206</code></p><h1 id="字段命名规范"><a href="#字段命名规范" class="headerlink" title="字段命名规范"></a>字段命名规范</h1><p>字段名称使用单词组合完成，首字母小写，单词之间用<code>“_”</code>分隔，最好是带表名前缀，自增id最好创建与业务无关.</p><p>如<code>oa_user</code>表的字段:</p><p><code>user_id<br>user_name</code></p><p>表与表之间的相关联字段要用统一名称。</p><h1 id="索引命名规范"><a href="#索引命名规范" class="headerlink" title="索引命名规范"></a>索引命名规范</h1><p>索引名称为<code>idx_列名<em>表名缩写</em></code>，唯一索引名称为<code>uniq列名_表名缩写</code>,其中表名和关联字段名如果过长，可以取表名、关联字段名的前 5 个字母，如果表名、关联字段为多个单词组合，可以取前一个单词，外加后续其它单词的首字母作为字段名。</p><p>如:</p><p>普通索引:<code>idx_user_name_oa</code></p><p>唯一索引：<code>uqidx_user_name_oa</code></p><p><strong>注意事项：</strong></p><ul><li>单个索引长度不超过<code>64KB</code></li><li>单个表索引不超过<code>8</code>个</li></ul><h1 id="字段类型规范"><a href="#字段类型规范" class="headerlink" title="字段类型规范"></a>字段类型规范</h1><p>规则：用尽量少的存储空间来存数一个字段的数据。</p><ol><li><p><code>char(n)</code>和<code>varchar(n)</code>中括号中<code>n</code>代表字符的个数，并不代表字节个数，所以当使用了中文的时候(UTF8)意味着可以插入<code>m</code>个中文，但是实际会占用<code>m*3</code>个字节。</p></li><li><p>同时<code>char</code>和<code>varchar</code>最大的区别就在于<code>char</code>不管实际<code>value</code>都会占用<code>n</code>个字符的空间，而<code>varchar</code>只会占用实际字符应该占用的空间+1，并且实际空间+1&lt;=n。</p></li><li><p>超过<code>char</code>和<code>varchar</code>的<code>n</code>设置后，字符串会被截断。</p></li><li><p><code>char</code>的上限为<code>255</code>字节，<code>varchar</code>的上限<code>65535</code>字节，<code>text</code>的上限为<code>65535</code>。</p></li><li><p><code>char</code>在存储的时候会截断尾部的空格，<code>varchar</code>和<code>text</code>不会。</p></li><li><p><code>varchar</code>会使用<code>1-3</code>个字节来存储长度，<code>text</code>不会。</p></li></ol><table><thead><tr><th>Value</th><th>CHAR(4)</th><th>Storage Required</th><th>VARCHAR(4)</th><th>Storage Required</th></tr></thead><tbody><tr><td>‘’</td><td>‘    ‘</td><td>4 bytes</td><td>‘’</td><td>1 byte</td></tr><tr><td>‘ab’</td><td>‘ab  ‘</td><td>4 bytes</td><td>‘ab’</td><td>3 bytes</td></tr><tr><td>‘abcd’</td><td>‘abcd’</td><td>4 bytes</td><td>‘abcd’</td><td>5 bytes</td></tr><tr><td>‘abcdefgh’</td><td>‘abcd’</td><td>4 bytes</td><td>‘abcd’</td><td>5 bytes</td></tr></tbody></table><p>总体来说：</p><ul><li><code>char</code>，存定长，速度快，存在空间浪费的可能，会处理尾部空格，上限<code>255</code>。</li><li><code>varchar</code>，存变长，速度慢，不存在空间浪费，不处理尾部空格，上限<code>65535</code>，但是有存储长度实际<code>65532</code>最大可用。</li><li><code>text</code>，存变长大数据，速度慢，不存在空间浪费，不处理尾部空格，上限<code>65535</code>，会用额外空间存放数据长度，顾可以全部使用<code>65535</code>。</li></ul><p>接下来，我们说下这个场景的问题：</p><p>当<code>varchar(n)</code>后面的n非常大的时候我们是使用<code>varchar</code>好，还是<code>text</code>好呢？</p><p>这是个明显的量变引发质变的问题。我们从2个方面考虑，第一是空间，第二是性能。</p><p>首先从空间方面：</p><p>从官方文档中我们可以得知当<code>varchar</code>大于某些数值的时候，其会自动转换为<code>text</code>，大概规则如下：</p><ul><li>大于<code>varchar(255)</code>变为 <code>tinytext</code></li><li>大于<code>varchar(500)</code>变为 <code>text</code></li><li>大于<code>varchar(20000)</code>变为 <code>mediumtext</code></li></ul><p>所以对于过大的内容使用<code>varchar</code>和<code>text</code>没有太多区别。</p><p>比如能用<code>int</code>的就不用<code>char</code>或者<code>varchar</code>，能用<code>varchar(20)</code>的就不用<code>varchar(255)</code>。</p><p>时间戳字段尽量用<code>int</code>型。</p><p>尽量避免大字段<code>blob</code>，<code>text</code>，<code>longtext</code>，如强制需要大字段，不要集中存放在一个表中，分多表存放。查询语句<code>where</code>条件不要落在大字段上。</p><p>相关文档: </p><ul><li><a href="https://dev.mysql.com/doc/refman/5.6/en/column-count-limit.html" rel="external nofollow noopener noreferrer" target="_blank">行的大小限制</a></li><li><a href="https://dev.mysql.com/doc/refman/5.6/en/storage-requirements.html" rel="external nofollow noopener noreferrer" target="_blank">表数据类型的选型手册</a></li><li><a href="https://dev.mysql.com/doc/refman/5.6/en/string-type-syntax.html" rel="external nofollow noopener noreferrer" target="_blank">大对象数据类型的概述</a></li></ul><h1 id="操作规范"><a href="#操作规范" class="headerlink" title="操作规范"></a>操作规范</h1><ul><li><p>创建表时需添加表级别和列级别注释，显示指定存储引擎、默认字符集、自增开始值，<code>id</code>列无特殊要求，建议使用<code>int</code>值。</p></li><li><p>如无备注，则表中的第一个<code>id</code>字段一定是主键且为自动增长；</p></li><li><p>如无备注，则数值类型的字段请使用<code>UNSIGNED</code>属性；</p></li><li><p>如无备注，所有字段都设置<code>NOT NULL</code>，并设置默认值；</p></li><li><p>如无备注，所有的布尔值字段，如<code>is_hot</code>、<code>is_deleted</code>，都必须设置一个默认值，并设为<code>0</code>；</p></li><li><p>所有的数字类型字段，都必须设置一个默认值，并设为<code>0</code>；</p></li><li><p>针对<code>varchar</code>类型字段的程序处理，请验证用户输入，不要超出其预设的长度；</p></li><li><p>建表时将数据字典中的字段中文名和属性备注写入数据表的备注中(“PK、自动增长”不用写)；</p></li><li><p>如无说明，建表时一律采用<code>innodb</code>引擎；</p></li><li><p>尽量采用批量<code>SQL</code>语句,减少与数据库交互次数；</p></li><li><p>提交线上建表改表需求,必须详细注明涉及到的所有<code>SQL</code>语句(包括<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>)，便于DBA进行审核和优化。</p></li></ul><h1 id="数据库用户创建规范"><a href="#数据库用户创建规范" class="headerlink" title="数据库用户创建规范"></a>数据库用户创建规范</h1><p>采用<code>26</code>个英文字母（区分大小写）和<code>0-9</code>这十个自然数，加上下划线<code>‘_’</code>组成，共<code>37</code>个字符。不能出现其他字符（注释除外）。</p><p><strong>注意事项:</strong></p><ul><li>以上命名都不得超过<code>16</code>个字符的系统限制。</li><li><p>数据库用户一律采用小写，由以下几个部分组成，使用<code>人员<em>项目名</em>连接途径_用户权限</code>组成；</p><p>例如:管理平台账号，<code>d_mg_web_dml</code>，<code>d_mg_pc_web_dml</code></p></li></ul><h1 id="其他设计技巧"><a href="#其他设计技巧" class="headerlink" title="其他设计技巧"></a>其他设计技巧</h1><ol><li><p>避免使用存储过程、触发器、视图、自定义函数等，这些高级特性有性能问题，以及未知BUG较多。业务逻辑放到数据库会造成数据库的<code>DDL</code>、<code>SCALE OUT</code>、 <code>SHARDING</code>等变得更加困难。</p></li><li><p>分区表对分区键有严格要求；分区表在表变大后,执行<code>DDL</code>、<code>SHARDING</code>、单表恢复等都变得更加困难。因此禁止使用分区表,并建议业务端手动<code>SHARDING</code>。</p></li><li><p>使用常用英语（或者其他任何语言）而不要使用拼音首字母缩写。</p></li><li><p>将大字段、访问频率低的字段拆分到单独的表中存储，分离冷热数据, 有利于有效利用缓存，防止读入无用的冷数据，较少磁盘IO，同时保证热数据常驻内存提高缓存。</p></li><li><p>禁止有<code>super</code>权限的应用程序账号存在, 安全第一。<code>super</code>权限会导致<code>read only</code>失效，导致较多诡异问题而且很难追踪。</p></li><li><p>不要在MySQL数据库中存放业务逻辑, 数据库是有状态的服务，变更复杂而且速度慢，如果把业务逻辑放到数据库中，将会限制业务的快速发展。建议把业务逻辑提前，放到前端或中间逻辑层，而把数据库作为存储层，实现逻辑与存储的分离。</p></li><li><p>不建议使用<code>enum</code>,<code>set</code>,<code>blob</code>,<code>text</code>字段，如非用<code>blob</code>或<code>text</code>字段，请将<code>blob</code>或<code>text</code>内容存放到文件系统中，数据库中只存放文件系统的<code>url</code>地址，或将该类字段单独存放到一张小表中（首推第一种方法）。</p></li></ol><p>附：建表示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`manager_test`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">20</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`staff_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'操作人员id'</span>,</span><br><span class="line">  <span class="string">`staff_name`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'人员名称'</span>,</span><br><span class="line">  <span class="string">`url`</span> <span class="built_in">varchar</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'操作路径'</span>,</span><br><span class="line">  <span class="string">`method`</span> <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'操作方式'</span>,</span><br><span class="line">  <span class="string">`params`</span> <span class="built_in">varchar</span>(<span class="number">10</span>)<span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'操作参数'</span>,</span><br><span class="line">  <span class="string">`ip`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'ip'</span>,</span><br><span class="line">  <span class="string">`time`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'操作时间'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_staff_id_ct`</span> (<span class="string">`staff_id `</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">1</span><span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</span><br></pre></td></tr></table></figure><h1 id="数据库用户命名规范"><a href="#数据库用户命名规范" class="headerlink" title="数据库用户命名规范"></a>数据库用户命名规范</h1><p>用户命名规则，分为四段，每段规则如下</p><p>示例：<code>d_zq_pc_dml</code></p><ul><li><p>第一段：环境名(<code>d:develop，t:test,p:product</code>)</p></li><li><p>第二段：项目名首字母</p></li><li><p>第三段：连接源(pc:桌面终端，web:程序)</p></li><li><p>第四段：权限(<code>sel:select，dml:select，insert，update，delete</code>)</p></li></ul><p><strong>注意事项：</strong></p><p>禁止程序具有<code>file</code>、<code>super</code>权限。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="MYSQL" scheme="https://www.sakuratears.top/tags/MYSQL/"/>
    
  </entry>
  
  <entry>
    <title>Redis开发规范</title>
    <link href="https://www.sakuratears.top/blog/Redis%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83.html"/>
    <id>https://www.sakuratears.top/blog/Redis开发规范.html</id>
    <published>2020-07-12T08:13:00.000Z</published>
    <updated>2020-07-12T08:14:22.389Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="键值设计"><a href="#键值设计" class="headerlink" title="键值设计"></a>键值设计</h1><h2 id="key名设计"><a href="#key名设计" class="headerlink" title="key名设计"></a>key名设计</h2><ol><li><p>【建议】: 可读性和可管理性</p><p> 以业务名(或数据库名)为前缀(防止key冲突)，用冒号分隔，比如业务名:表名:id</p><p> <code>ugc:video:1</code></p></li><li><p>【建议】：简洁性</p><p> 保证语义的前提下，控制key的长度，当key较多时，内存占用也不容忽视，例如：</p><p> <code>user:{uid}:friends:messages:{mid}</code></p><p> 简化为</p><p> <code>u:{uid}:fr:m:{mid}</code></p></li><li><p>【强制】：不要包含特殊字符</p><p> 反例：包含空格、换行、单双引号以及其他转义字符</p></li></ol><h2 id="value设计"><a href="#value设计" class="headerlink" title="value设计"></a>value设计</h2><ol><li><p>【强制】：拒绝<code>bigkey</code>(防止网卡流量、慢查询)</p><p> <code>String</code>类型控制在10KB以内，<code>hash</code>、<code>list</code>、<code>set</code>、<code>zset</code>元素个数不要超过5000。</p><p> 反例：一个包含200万个元素的<code>list</code>。</p><p> 非字符串的<code>bigkey</code>，不要使用<code>del</code>删除，使用<code>hscan</code>、<code>sscan</code>、<code>zscan</code>方式渐进式删除，同时要注意防止<code>bigkey</code>过期时间自动删除问题(例如一个200万的<code>zset</code>设置1小时过期，会触发del操作，造成阻塞，而且该操作不会不出现在慢查询中(latency可查))，查找方法和删除方法</p></li><li><p>【推荐】：选择适合的数据类型。</p><p> 例如：实体类型(要合理控制和使用数据结构内存编码优化配置,例如<code>ziplist</code>，但也要注意节省内存和性能之间的平衡)</p><p> 反例：</p><p> <code>set user:1:name tom</code></p><p> set user:1:age 19</p><p> set user:1:favor football</p><p> 正例:</p><p> <code>hmset user:1 name tom age 19 favor football</code></p></li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li><p>【推荐】：控制key的生命周期，redis不是垃圾桶。</p><p> 建议使用<code>expire</code>设置过期时间(条件允许可以打散过期时间，防止集中过期)，不过期的数据重点关注<code>idle time</code>。</p></li></ol><h1 id="命令使用"><a href="#命令使用" class="headerlink" title="命令使用"></a>命令使用</h1><ol><li><p>【推荐】 O(N)命令关注N的数量</p><p> 例如<code>hgetall</code>、<code>lrange</code>、<code>smembers</code>、<code>zrange</code>、<code>sinter</code>等并非不能使用，但是需要明确N的值。有遍历的需求可以使用<code>hscan</code>、<code>sscan</code>、<code>zscan</code>代替。</p></li><li><p>【推荐】：禁用命令</p><p> 禁止线上使用<code>keys</code>、<code>flushall</code>、<code>flushdb</code>等，通过redis的<code>rename</code>机制禁掉命令，或者使用<code>scan</code>的方式渐进式处理。</p></li><li><p>【推荐】合理使用<code>select</code></p><p> redis的多数据库较弱，使用数字进行区分，很多客户端支持较差，同时多业务用多数据库实际还是单线程处理，会有干扰。</p></li><li><p>【推荐】使用批量操作提高效率</p><p> 原生命令：例如<code>mget</code>、<code>mset</code>。</p><p> 非原生命令：可以使用<code>pipeline</code>提高效率。</p><p> 但要注意控制一次批量操作的元素个数(例如500以内，实际也和元素字节数有关)。</p><p> 注意两者不同：</p><ul><li>原生是原子操作，<code>pipeline</code>是非原子操作。</li><li><code>pipeline</code>可以打包不同的命令，原生做不到</li><li><code>pipeline</code>需要客户端和服务端同时支持。</li></ul></li><li><p>【建议】Redis事务功能较弱，不建议过多使用</p><p> Redis的事务功能较弱(不支持回滚)，而且集群版本(自研和官方)要求一次事务操作的key必须在一个slot上(可以使用hashtag功能解决)</p></li><li><p>【建议】Redis集群版本在使用Lua上有特殊要求：</p><ul><li>所有key都应该由 KEYS 数组来传递，<code>redis.call/pcall</code> 里面调用的redis命令，key的位置，必须是KEYS array, 否则直接返回error，<code>“-ERR bad lua script for redis cluster, all the keys that the script uses should be passed using the KEYS arrayrn”</code></li><li>所有key，必须在1个slot上，否则直接返回error, <code>“-ERR eval/evalsha command keys must in same slotrn”</code></li></ul></li><li><p>【建议】必要情况下使用<code>monitor</code>命令时，要注意不要长时间使用。</p></li></ol><h1 id="客户端使用"><a href="#客户端使用" class="headerlink" title="客户端使用"></a>客户端使用</h1><ol><li><p>【推荐】 避免多个应用使用一个Redis实例</p><p> 正例：不相干的业务拆分，公共数据做服务化。</p></li><li><p>【推荐】 使用带有连接池的数据库，可以有效控制连接，同时提高效率，标准使用方式：</p></li><li><p>【建议】 高并发下建议客户端添加熔断功能(例如netflix hystrix)</p></li><li><p>【推荐】 设置合理的密码，如有必要可以使用SSL加密访问（阿里云Redis支持）</p></li><li><p>【建议】根据自身业务类型，选好<code>maxmemory-policy</code>(最大内存淘汰策略)，设置好过期时间。</p><p> 默认策略是volatile-lru，即超过最大内存后，在过期键中使用lru算法进行key的剔除，保证不过期数据不被删除，但是可能会出现OOM问题。</p><p> 其他策略如下：</p><ul><li>allkeys-lru：根据LRU算法删除键，不管数据有没有设置超时属性，直到腾出足够空间为止。</li><li>allkeys-random：随机删除所有键，直到腾出足够空间为止。</li><li>volatile-random：随机删除过期键，直到腾出足够空间为止。</li><li>volatile-ttl：根据键值对象的ttl属性，删除最近将要过期数据。如果没有，回退到noeviction策略。</li><li>noeviction：不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息<code>“(error) OOM command not allowed when used memory”</code>，此时Redis只响应读操作。</li></ul></li></ol><h1 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h1><ol><li><p>【推荐】：数据同步</p><p> redis间数据同步可以使用：redis-port</p></li><li><p>【推荐】：big key搜索</p><p> <a href="https://developer.aliyun.com/article/117042" rel="external nofollow noopener noreferrer" target="_blank">redis大key搜索工具</a></p></li><li><p>【推荐】：热点key寻找(内部实现使用monitor，所以建议短时间使用)</p><p> <a href="https://github.com/facebookarchive/redis-faina" rel="external nofollow noopener noreferrer" target="_blank">facebook的redis-faina</a></p><p> PS:阿里云Redis已经在内核层面解决热点key问题。</p></li></ol><h1 id="附录：删除bigkey"><a href="#附录：删除bigkey" class="headerlink" title="附录：删除bigkey"></a>附录：删除bigkey</h1><ul><li><p>下面操作可以使用<code>pipeline</code>加速。</p></li><li><p>redis 4.0已经支持key的异步删除。</p></li></ul><ol><li>Hash删除: hscan + hdel</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delBigHash</span><span class="params">(String host,<span class="keyword">int</span> port,String password,String bigHashKey)</span></span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(host,port);</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isNotEmpty(password))&#123;</span><br><span class="line">        jedis.auth(password);</span><br><span class="line">    &#125;</span><br><span class="line">    ScanParams scanParams = <span class="keyword">new</span> ScanParams().count(<span class="number">100</span>);</span><br><span class="line">    String cursor = <span class="string">"0"</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        ScanResult&lt;Map.Entry&lt;String,String&gt;&gt; scanResult = jedis.hscan(bigHashKey,cursor,scanParams);</span><br><span class="line">        List&lt;Map.Entry&lt;String,String&gt;&gt; entryList = scanResult.getResult();</span><br><span class="line">        <span class="keyword">if</span>(CollectionUtils.isNotEmpty(entryList))&#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : entryList) &#123;</span><br><span class="line">                jedis.hdel(bigHashKey,entry.getKey());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = scanResult.getStringCursor();</span><br><span class="line">    &#125;<span class="keyword">while</span> (!<span class="string">"0"</span>.equals(cursor));</span><br><span class="line">    <span class="comment">//删除bigHashKey</span></span><br><span class="line">    jedis.del(bigHashKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>List删除: ltrim</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delBigList</span><span class="params">(String host,<span class="keyword">int</span> port,String password,String bigListKey)</span></span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(host,port);</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isNotEmpty(password))&#123;</span><br><span class="line">        jedis.auth(password);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> llen = jedis.llen(bigListKey);</span><br><span class="line">    <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">while</span> (counter&lt;llen)&#123;</span><br><span class="line">        <span class="comment">//每次从左边截掉100个</span></span><br><span class="line">        jedis.ltrim(bigListKey,left,llen);</span><br><span class="line">        counter += left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除bigListKey</span></span><br><span class="line">    jedis.del(bigListKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>Set删除: sscan + srem</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delBigSet</span><span class="params">(String host,<span class="keyword">int</span> port,String password,String bigSetKey)</span></span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(host,port);</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isNotEmpty(password))&#123;</span><br><span class="line">        jedis.auth(password);</span><br><span class="line">    &#125;</span><br><span class="line">    ScanParams scanParams = <span class="keyword">new</span> ScanParams().count(<span class="number">100</span>);</span><br><span class="line">    String cursor = <span class="string">"0"</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        ScanResult&lt;String&gt; scanResult = jedis.sscan(bigSetKey,cursor,scanParams);</span><br><span class="line">        List&lt;String&gt; memberList = scanResult.getResult();</span><br><span class="line">        <span class="keyword">if</span>(CollectionUtils.isNotEmpty(memberList))&#123;</span><br><span class="line">            <span class="keyword">for</span> (String s : memberList) &#123;</span><br><span class="line">                jedis.srem(bigSetKey,s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = scanResult.getStringCursor();</span><br><span class="line">    &#125;<span class="keyword">while</span> (!<span class="string">"0"</span>.equals(cursor));</span><br><span class="line">    <span class="comment">//删除bigSetKey</span></span><br><span class="line">    jedis.del(bigSetKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>SortedSet删除: zscan + zrem</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delBigZset</span><span class="params">(String host,<span class="keyword">int</span> port,String password,String bigZsetKey)</span></span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(host,port);</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isNotEmpty(password))&#123;</span><br><span class="line">        jedis.auth(password);</span><br><span class="line">    &#125;</span><br><span class="line">    ScanParams scanParams = <span class="keyword">new</span> ScanParams().count(<span class="number">100</span>);</span><br><span class="line">    String cursor = <span class="string">"0"</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        ScanResult&lt;Tuple&gt; scanResult = jedis.zscan(bigZsetKey,cursor,scanParams);</span><br><span class="line">        List&lt;Tuple&gt; tupleList = scanResult.getResult();</span><br><span class="line">        <span class="keyword">if</span>(CollectionUtils.isNotEmpty(tupleList))&#123;</span><br><span class="line">            <span class="keyword">for</span> (Tuple tuple : tupleList) &#123;</span><br><span class="line">                jedis.zrem(bigZsetKey,tuple.getElement());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = scanResult.getStringCursor();</span><br><span class="line">    &#125;<span class="keyword">while</span> (!<span class="string">"0"</span>.equals(cursor));</span><br><span class="line">    <span class="comment">//删除bigZsetKey</span></span><br><span class="line">    jedis.del(bigZsetKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Redis" scheme="https://www.sakuratears.top/tags/Redis/"/>
    
  </entry>
  
</feed>
