<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SakuraTears的博客</title>
  
  <subtitle>越努力越幸运</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.sakuratears.top/"/>
  <updated>2020-11-21T10:13:40.152Z</updated>
  <id>https://www.sakuratears.top/</id>
  
  <author>
    <name>SakuraTears</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CAS详解</title>
    <link href="https://www.sakuratears.top/blog/CAS%E8%AF%A6%E8%A7%A3.html"/>
    <id>https://www.sakuratears.top/blog/CAS详解.html</id>
    <published>2020-11-21T09:24:00.000Z</published>
    <updated>2020-11-21T10:13:40.152Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>CAS全称CompareAndSwap，比较并交换，主要是通过处理器的指令来保证操作的原子性，它包含三个操作数：</p><ol><li>变量内存地址，V表示</li><li>旧的预期值，A表示</li><li>准备设置的新值，B表示</li></ol><p>当执行CAS指令时，只有当V等于A时，才会用B去更新V的值，否则就不会执行更新操作。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="CAS原理"><a href="#CAS原理" class="headerlink" title="CAS原理"></a>CAS原理</h2><p>CAS的伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">//备份旧数据</span></span><br><span class="line">    <span class="comment">//基于旧数据构造新数据B</span></span><br><span class="line">&#125;<span class="keyword">while</span> (!CAS(变量内存地址,旧的预期值,准备设置的新值));</span><br></pre></td></tr></table></figure><p>如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-667.jpg" alt="upload successful"></p><ol><li>我们假设线程1和线程2同时访问变量V=33，两线程将变量值33拷贝到各自工作空间内存；</li><li>两线程分别进行 +1 操作，分别得到准备设置的新值34，而后进行值设置，对V进行 CAS 操作；</li><li>线程1操作成功，将值设置为34，完成后并更新自己本地值A=34；</li><li>这时候线程2操作就会返回失败，因为V的值以及被线程1设置为了34；</li><li>失败后，它会进行重试，它需要在获取34到本地，进行 +1 操作，再进行CAS(34,34,35)的操作，而后线程2将值设置成功。</li></ol><p>大家可能会有个疑问，如果在第2步，线程1和线程2同时进行CAS操作，是如何保证原子性的呢？</p><p>在<code>sun.misc.Unsafe</code>类中，我们可以看到<code>CompareAndSwap</code>方法是调用的原生代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object var1, <span class="keyword">long</span> var2, Object var4, Object var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4, <span class="keyword">long</span> var6)</span></span>;</span><br></pre></td></tr></table></figure><p>我们来分析一下它们的相关代码。</p><h2 id="CAS源码解析"><a href="#CAS源码解析" class="headerlink" title="CAS源码解析"></a>CAS源码解析</h2><p>我们以<code>compareAndSwapInt</code>为例，在<a href="http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/87ee5ee27509/src/share/vm/prims/unsafe.cpp" rel="external nofollow noopener noreferrer" target="_blank">openjdk 1.8 unsafe.cpp</a>里可以找到如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  UnsafeWrapper(<span class="string">"Unsafe_CompareAndSwapInt"</span>);</span><br><span class="line">  oop p = JNIHandles::resolve(obj);</span><br><span class="line">  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);</span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure><p>其对应我们的<code>sun.misc.Unsafe</code>类中的<code>compareAndSwapInt</code>方法。</p><p>关键方法为<code>Atomic::cmpxchg(x, addr, e)</code>，它位于<a href="http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/87ee5ee27509/src/share/vm/runtime/atomic.cpp" rel="external nofollow noopener noreferrer" target="_blank">openjdk 1.8 atomic.cpp</a>文件中，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> Atomic::cmpxchg(<span class="keyword">unsigned</span> <span class="keyword">int</span> exchange_value,</span><br><span class="line">                         <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>* dest, <span class="keyword">unsigned</span> <span class="keyword">int</span> compare_value) &#123;</span><br><span class="line">  assert(<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>) == <span class="keyword">sizeof</span>(jint), <span class="string">"more work to do"</span>);</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)Atomic::cmpxchg((jint)exchange_value, (<span class="keyword">volatile</span> jint*)dest,</span><br><span class="line">                                       (jint)compare_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Atomic::cmpxchg((jint)exchange_value, (volatile jint*)dest,(jint)compare_value)</code>方法位于<a href="http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/87ee5ee27509/src/os_cpu/windows_x86/vm/atomic_windows_x86.inline.hpp" rel="external nofollow noopener noreferrer" target="_blank">openjdk 1.8 atomic_windows_x86.inline.hpp</a>文件中，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> jint     Atomic::cmpxchg    (jint     exchange_value, <span class="keyword">volatile</span> jint*     dest, jint     compare_value) &#123;</span><br><span class="line">  <span class="comment">// alternative for InterlockedCompareExchange</span></span><br><span class="line">  <span class="keyword">int</span> mp = os::is_MP();</span><br><span class="line">  __asm &#123;</span><br><span class="line">    mov edx, dest</span><br><span class="line">    mov ecx, exchange_value</span><br><span class="line">    mov eax, compare_value</span><br><span class="line">    LOCK_IF_MP(mp)</span><br><span class="line">    cmpxchg dword ptr [edx], ecx</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mp</code>是<code>os::is_MP()</code>的返回结果，<code>os::is_MP()</code>是一个内联函数，用来判断当前系统是否为多处理器。</p><p>如果当前系统是多处理器，该函数返回1，否则，返回0。</p><p><code>LOCK_IF_MP(mp)</code>会根据<code>mp</code>的值来决定是否为<code>cmpxchg</code>指令添加<code>lock</code>前缀。</p><ul><li>如果通过<code>mp</code>判断当前系统是多处理器（即<code>mp</code>值为1），则为<code>cmpxchg</code>指令添加<code>lock</code>前缀。</li><li>否则，不加<code>lock</code>前缀。</li></ul><p>这是一种优化手段，单处理器的环境没有必要添加<code>lock</code>前缀，只有在多核情况下才会添加<code>lock</code>前缀，因为<code>lock</code>会导致性能下降。</p><p><code>cmpxchg</code>是汇编指令，作用是比较并交换操作数。</p><p><strong>关于lock指令</strong></p><ol><li>确保对内存的读-改-写操作原子执行。在Pentium及Pentium之前的处理器中，带有lock前缀的指令在执行期间会锁住总线，使得其他处理器暂时无法通过总线访问内存。很显然，这会带来昂贵的开销。从Pentium 4，Intel Xeon及P6处理器开始，intel在原有总线锁的基础上做了一个很有意义的优化：如果要访问的内存区域（area of memory）在lock前缀指令执行期间已经在处理器内部的缓存中被锁定（即包含该内存区域的缓存行当前处于独占或以修改状态），并且该内存区域被完全包含在单个缓存行（cache line）中，那么处理器将直接执行该指令。由于在指令执行期间该缓存行会一直被锁定，其它处理器无法读/写该指令要访问的内存区域，因此能保证指令执行的原子性。这个操作过程叫做缓存锁定（cache locking），缓存锁定将大大降低lock前缀指令的执行开销，但是当多处理器之间的竞争程度很高或者指令访问的内存地址未对齐时，仍然会锁住总线。</li><li>禁止该指令与之前和之后的读和写指令重排序。</li><li>把写缓冲区中的所有数据刷新到内存中。</li></ol><p>上面的第1点保证了CAS操作是一个原子操作，第2点和第3点所具有的内存屏障效果，保证了CAS同时具有<code>volatile</code>读和<code>volatile</code>写的内存语义。</p><p>有关<code>lock</code>指令更多内容，我们可以下载<a href="https://www.intel.cn/content/www/cn/zh/architecture-and-technology/64-ia-32-architectures-software-developer-vol-2a-manual.html" rel="external nofollow noopener noreferrer" target="_blank">Intel 官方文档</a> 来查看。</p><h2 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h2><p>虽然CAS很高效的解决了原子操作问题，但CAS仍有3个主要缺点：</p><ol><li>ABA问题：ABA的问题指的是在CAS更新的过程中，当读取到的值是A，然后准备赋值的时候仍然是A，但是实际上有可能A的值被改成了B，然后又被改回了A，这个CAS更新的漏洞就叫做ABA。只是ABA的问题大部分场景下都不影响并发的最终效果。</li></ol><p>Java中有<code>AtomicStampedReference</code>来解决这个问题，它加入了预期标志和更新后标志两个字段，更新时不光检查值，还要检查当前的标志是否等于预期标志，全部相等的话才会更新。</p><p>我们来简单看下它的部分代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicStampedReference</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> T reference;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> stamp;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Pair</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.reference = reference;</span><br><span class="line">            <span class="keyword">this</span>.stamp = stamp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">of</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(reference, stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Pair&lt;V&gt; pair;</span><br><span class="line">    <span class="comment">//....部分代码略</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                V   newReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> expectedStamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> newStamp)</span> </span>&#123;</span><br><span class="line">    Pair&lt;V&gt; current = pair;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        expectedReference == current.reference &amp;&amp;</span><br><span class="line">        expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">        ((newReference == current.reference &amp;&amp;</span><br><span class="line">            newStamp == current.stamp) ||</span><br><span class="line">            casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...部分代码略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>AtomicStampedReference</code>类中除了对象引用<code>reference</code>，还加入了标志字段<code>stamp</code>来解决ABA问题。</p><ol start="2"><li>循环时间长开销大：自旋CAS的方式如果长时间不成功，会给CPU带来很大的开销。</li></ol><p>上面图示中我们提到线程2如果更新不成功，会进行重试，其采用自旋方式进行重试，如果有多个线程操作共享变量时，部分线程可能自旋时间过长，对CPU造成较大开销。</p><ol start="3"><li>只能保证一个共享变量的原子操作：只对一个共享变量操作可以保证原子性，但是多个则不行，多个可以通过<code>AtomicReference</code>来处理或者使用锁<code>synchronized</code>实现。</li></ol><p>我们来看下<code>AtomicReference</code>的部分代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReference</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">1848883965231344442L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicReference.class.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> V value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...部分代码略</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V expect, V update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...部分代码略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到它是通过<code>compareAndSwapObject</code>函数来实现的。</p><p>经过上面分析，我们可以看到CAS操作和乐观锁的性质类似。</p><h2 id="CAS应用"><a href="#CAS应用" class="headerlink" title="CAS应用"></a>CAS应用</h2><p>CAS在<code>java.util.concurrent</code>包下的类中有大量被应用，有兴趣的同学可以看一下。</p><h2 id="CAS的开销"><a href="#CAS的开销" class="headerlink" title="CAS的开销"></a>CAS的开销</h2><p>CAS（比较并交换）是CPU指令级的操作，只有一步原子操作，所以非常快。而且CAS避免了请求操作系统来裁定锁的问题，不用麻烦操作系统，直接在CPU内部就搞定了。但CAS就没有开销了吗？不！有cache miss的情况。这个问题比较复杂，首先需要了解CPU的硬件体系结构：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-668.png" alt="upload successful"></p><p>上图可以看到一个8核CPU计算机系统，每个CPU有cache（CPU内部的高速缓存，寄存器），管芯内还带有一个互联模块，使管芯内的两个核可以互相通信。在图中央的系统互联模块可以让四个管芯相互通信，并且将管芯与主存连接起来。数据以“缓存线”为单位在系统中传输，“缓存线”对应于内存中一个 2 的幂大小的字节块，大小通常为 32 到 256 字节之间。当 CPU 从内存中读取一个变量到它的寄存器中时，必须首先将包含了该变量的缓存线读取到 CPU 高速缓存。同样地，CPU 将寄存器中的一个值存储到内存时，不仅必须将包含了该值的缓存线读到 CPU 高速缓存，还必须确保没有其他 CPU 拥有该缓存线的拷贝。</p><p>比如，如果 CPU0 在对一个变量执行“比较并交换”（CAS）操作，而该变量所在的缓存线在 CPU7 的高速缓存中，就会发生以下经过简化的事件序列：</p><ul><li>CPU0 检查本地高速缓存，没有找到缓存线。</li><li>请求被转发到 CPU0 和 CPU1 的互联模块，检查 CPU1 的本地高速缓存，没有找到缓存线。</li><li>请求被转发到系统互联模块，检查其他三个管芯，得知缓存线被 CPU6和 CPU7 所在的管芯持有。</li><li>请求被转发到 CPU6 和 CPU7 的互联模块，检查这两个 CPU 的高速缓存，在 CPU7 的高速缓存中找到缓存线。</li><li>CPU7 将缓存线发送给所属的互联模块，并且刷新自己高速缓存中的缓存线。</li><li>CPU6 和 CPU7 的互联模块将缓存线发送给系统互联模块。</li><li>系统互联模块将缓存线发送给 CPU0 和 CPU1 的互联模块。</li><li>CPU0 和 CPU1 的互联模块将缓存线发送给 CPU0 的高速缓存。</li><li>CPU0 现在可以对高速缓存中的变量执行 CAS 操作了</li></ul><p>以上是刷新不同CPU缓存的开销。最好情况下的 CAS 操作消耗大概 40 纳秒，超过 60 个时钟周期。这里的“最好情况”是指对某一个变量执行 CAS 操作的 CPU 正好是最后一个操作该变量的CPU，所以对应的缓存线已经在 CPU 的高速缓存中了，类似地，最好情况下的锁操作（一个“round trip 对”包括获取锁和随后的释放锁）消耗超过 60 纳秒，超过 100 个时钟周期。这里的“最好情况”意味着用于表示锁的数据结构已经在获取和释放锁的 CPU 所属的高速缓存中了。锁操作比 CAS 操作更加耗时，是因深入理解并行编程<br>为锁操作的数据结构中需要两个原子操作。缓存未命中消耗大概 140 纳秒，超过 200 个时钟周期。需要在存储新值时查询变量的旧值的 CAS 操作，消耗大概 300 纳秒，超过 500 个时钟周期。想想这个，在执行一次 CAS 操作的时间里，CPU 可以执行 500 条普通指令。这表明了细粒度锁的局限性。</p><p>以下是cache miss cas 和lock的性能对比：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-669.png" alt="upload successful"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇文章我们讲到了CAS的一些特点，大致了解了CAS的一些原理，在实际工作中，针对于一些场景，也可以使用CAS来操作。</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="https://www.cnblogs.com/Mainz/p/3546347.html" rel="external nofollow noopener noreferrer" target="_blank">非阻塞同步算法与CAS(Compare and Swap)无锁算法</a></li><li><a href="http://hg.openjdk.java.net/jdk8" rel="external nofollow noopener noreferrer" target="_blank">openjdk hotspot 1.8源码</a></li><li><a href="https://www.intel.cn/content/www/cn/zh/architecture-and-technology/64-ia-32-architectures-software-developer-vol-2a-manual.html" rel="external nofollow noopener noreferrer" target="_blank">Intel 官方文档</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="CAS" scheme="https://www.sakuratears.top/tags/CAS/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Hystrix服务容错保护入门</title>
    <link href="https://www.sakuratears.top/blog/Spring-Cloud-Hystrix%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99%E4%BF%9D%E6%8A%A4%E5%85%A5%E9%97%A8.html"/>
    <id>https://www.sakuratears.top/blog/Spring-Cloud-Hystrix服务容错保护入门.html</id>
    <published>2020-11-21T09:13:00.000Z</published>
    <updated>2020-11-21T09:25:02.213Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在微服务中，系统由许多服务单元构成，各单元的应用间通过服务注册与订阅的方式互相依赖。由于每个单元都在不同的进程中进行，依赖通过远程调用的方式执行，这样就有可能因为网络原因或者依赖服务自身问题出现调用故障或延迟，这些问题会直接导致调用方的对外服务也出现延迟，若此时调用方的请求不断增加，最后就会因等待出现故障的依赖方响应而形成任务积压，最终导致自身服务瘫痪。</p><p>由于微服务中存在众多服务单元，若一个单元出现故障，就很容易因依赖关系而引发故障的蔓延，最终导致整个系统瘫痪。未解决这样的问题，产生了断路器等一系列服务保护机制，而 Spring Cloud Hystrix 就是其中之一。</p><p>Spring Cloud Hystrix 基于 Netflix 开源框架 Hystrix 实现，具备 服务降级、服务熔断、线程和信号隔离、请求缓存、请求合并以及服务监控等强大功能。</p><p>接下来，我们从一个示例来了解它的使用及原理。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>由于内容较多，这篇文章我们先来了解下 Hystrix 的一个简单例子，然后再来了解两种模式：命令模式 和 观察者-订阅者模式。</p><h2 id="Hystrix示例"><a href="#Hystrix示例" class="headerlink" title="Hystrix示例"></a>Hystrix示例</h2><p>在Eureka和Ribbon的例子里，我们创建了 eureka-server、sakura-service、sakura-consumer服务，简单实现了微服务的调用。</p><p>PS：详见此文章<a href="https://www.sakuratears.top/blog/Eureka%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.html">Eureka简介及简单使用</a></p><p>我们启动3个 eureka-server（高可用服务注册中心）端口号为8001、8002、8003，启动2个sakura-service 模拟服务提供方，端口号为9001、9002，启动1个sakura-service 模拟服务提供方，端口号7001。</p><p>正常情况下，我们访问 <a href="http://host:port/consumer" rel="external nofollow noopener noreferrer" target="_blank">http://host:port/consumer</a> 会提示HelloWorld信息，如下图。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-662.jpg" alt="upload successful"></p><p>现在我们模拟服务提供方部分服务故障，停掉 sakura-service 的一个节点 9002 ，再次访问 <a href="http://host:port/consumer" rel="external nofollow noopener noreferrer" target="_blank">http://host:port/consumer</a> ，有时候正常，有时候会出现如下错误。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-663.jpg" alt="upload successful"></p><p>同时反应缓慢，因为需要等到我们这边服务调用超时，这种错误信息当调用方请求不断增加后，易出现任务积压，从而导致调用方对外服务也变得不可用。</p><p>下面我们引入 Spring Cloud Hystrix。</p><ul><li><p>在 sakura-consumer 工程的 <code>pom.xml</code>的 <code>dependency</code> 节点中引入 <code>spring-cloud-starter-netflix-hystrix</code>依赖。</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在 sakura-consumer 工程的主类<code>SakuraConsumerApplication</code>中使用<code>@EnableCircuitBreaker</code>开启断路器功能。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="meta">@RibbonClient</span>(name = <span class="string">"sakura"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SakuraConsumerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SakuraConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>改造服务消费方式，我们新增<code>SakuraService</code>类，注入<code>RestTemplate</code>。然后在<code>SakuraController</code>中注入<code>SakuraService</code>，并对其方法<code>hello</code>进行调用，同时，在<code>hello</code>方法上增加<code>@HystrixCommand</code>注解来指定回调方法。如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SakuraService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"helloFallback"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForEntity(<span class="string">"http://SAKURA-SERVICE/hello"</span>,String.class).getBody();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloFallback</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SakuraController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SakuraService sakuraService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/consumer"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sakuraService.hello();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这时候我们启动 sakura-consumer，同时停掉 sakura-service 的一个节点 9002 ，再次访问 <a href="http://host:port/consumer" rel="external nofollow noopener noreferrer" target="_blank">http://host:port/consumer</a> ，我们多次访问，可以看到有时候正常，有时候提示如下：</p><p>正常显示：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-664.jpg" alt="upload successful"></p><p>访问到服务异常的实例后提示：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-665.jpg" alt="upload successful"></p><p>上面的信息说明了当consumer访问到异常的实例后，不再返回之前的错误内容，而输出内容为error，也就是我们指定的 Hystrix 服务回调，即<code>helloFallback</code>里的内容。</p><p>这种是属于服务异常的情况，我们也可以模拟服务请求阻塞（长时间无响应）的情况，我们来看一下：</p><p>我们对sakura-service进行部分修改，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SakuraController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务注册</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"eurekaRegistration"</span>)</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Registration registration;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/hello"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> time = <span class="keyword">new</span> Random().nextInt(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">"sleepTime:"</span>+time);</span><br><span class="line">        Thread.sleep(time);</span><br><span class="line">        System.out.println(<span class="string">"Host:"</span>+registration.getHost()</span><br><span class="line">                +<span class="string">";ServiceID:"</span>+registration.getServiceId()</span><br><span class="line">                +<span class="string">";port:"</span>+registration.getPort()</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使其收到请求后随机0~3000ms在进行处理，而后重新启动 sakura-service （9001、9002）。</p><p>我们通过全局配置，在<code>application.properties</code>文件里设置 Hystrix 超时时间为 2000ms。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=2000</span><br></pre></td></tr></table></figure><p>然后我们调用 <a href="http://host:port/consumer" rel="external nofollow noopener noreferrer" target="_blank">http://host:port/consumer</a> ，可以看到当响应时间在 2000ms 内时，输出 Hello World，否则输出 error。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-666.jpg" alt="upload successful"></p><p>上面就是服务消费者因调用的服务超时从而触发熔断请求，并调用回调逻辑返回结果。</p><p>在了解 Hystrix 原理及详情之前，我们需要先对一下部分内容有所熟悉。</p><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>命令模式，它可以将来自客户端的请求封装成一个对象，从而让我们可以使用不同的请求对客户端进行参数化。它可以被用于实现“行为请求者”与“行为实现者”的解耦，以便使两者可以适应变化。</p><p>我们通过代码来看下命令模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//命令接收者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//真正的业务逻辑</span></span><br><span class="line">        System.out.println(<span class="string">"12345678"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//命令接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体命令实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Receiver receiver;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteCommand</span><span class="params">(Receiver receiver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver.action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端调用者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Invoker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(Command command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Receiver receiver = <span class="keyword">new</span> Receiver();</span><br><span class="line">        Command command = <span class="keyword">new</span> ConcreteCommand(receiver);</span><br><span class="line">        Invoker invoker = <span class="keyword">new</span> Invoker();</span><br><span class="line">        invoker.setCommand(command);</span><br><span class="line">        invoker.action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码对象示意如下：</p><ul><li>Receiver：接收者，它知道如何处理具体的业务逻辑。</li><li>Command：抽象命令，它定义了一个命令对象应具备的一系列命令操作，如<code>execute</code>，<code>undo</code>，<code>redo</code>等。当命令操作被调用的时候就会触发接收者去做具体命令对应的业务逻辑。</li><li>ConcreteCommand：具体的命令实现，在这里它绑定了命令操作与接收者之间的关系，<code>execute</code>命令的实现委托给了<code>Receiver</code>的<code>action</code>函数。</li><li>Invoker：调用者，它持有一个命令对象，并且可以在需要的时候通过命令对象完成具体的业务逻辑。</li></ul><p>从上面的例子我们可以看到，调用者<code>Invoker</code>与操作者<code>Receiver</code>通过<code>Command</code>命令接口实现了解耦。</p><p>对于调用者来说，我们可以为其注入多个命令操作，比如新建文件、复制文件、删除文件等操作，调用者只需在需要的时候调用即可，而不需要知道这些操作命令实际是如何实现的。</p><p>上面的示例中，我们可以发现，<code>Invoker</code>与<code>Receiver</code>的关系非常类似于“请求-响应”模式，所以它比较适用于实现记录日志、撤销操作、队列请求等。</p><p>下面这些情况下应考虑使用命令模式。</p><ul><li>使用命令模式作为“回调（Callback）”在面向对象系统中的替代。“Callback”讲的便是先将一个函数登记上，然后在以后在调用此函数。</li><li>需要在不同的时间指定请求、将请求排队。一个命令对象和原先的请求发出者可以有不同的生命期。换言之，原先的请求发出者可能已经不在了，而命令对象本身仍然是活动的。这时命令的接收者可以是在本地，也可以在网络的另一个地址。命令对象可以在序列化之后传送到另一台机器上去。</li><li>系统需要支持命令的撤销。命令对象可以把状态存储起来，等到客户端需要撤销命令所产生的效果时，可以调用<code>undo()</code>方法，把命令所产生的效果撤销掉。命令对象还可以提高<code>redo()</code>方法，以供客户端在需要时再重新实施命令效果。</li><li>如果要将系统中所有的数据更新到日志里，以便在系统崩溃是，可以根据日志读回所有的数据更新命令，重新调用<code>execute()</code>方法一条一条执行这些命令，从而恢复系统在崩溃前所做的数据更新。</li></ul><p>在 Hystrix 中，共有两种命令对象，如下：</p><ul><li>HystrixCommand ： 用在依赖的服务返回单个操作结果的时候。</li><li>HystrixObservableCommand ： 用在依赖的服务返回多个操作结果的时候。</li></ul><p>上面两个命令对象分别有两种命令执行方式，如下：</p><p>HystrixCommand：</p><ul><li>execute()：同步执行，从依赖的服务返回一个单一的结果对象，或是在发生错误的时候抛出异常。</li><li>queue()：异步执行，直接返回一个 <code>Future</code> 对象，其中包含了服务执行结束时要返回的单一结果对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R value = command.execute();</span><br><span class="line">Future&lt;R&gt; fValue = command.queue();</span><br></pre></td></tr></table></figure><p>HystrixObservableCommand:</p><ul><li>observe()：返回<code>Observable</code>对象，它代表了操作的多个结果，它是一个<strong>Hot Observable</strong>。</li><li>toObservable()：同样会返回<code>Observable</code>对象，也代表了操作的多个结果，但它返回的是一个<strong>Cold Observable</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;R&gt; ohValue = command.observe();</span><br><span class="line">Observable&lt;R&gt; ocValue = command.toObservable();</span><br></pre></td></tr></table></figure><p>在Hystrix底层大量使用了<strong>RxJava</strong>，我们在介绍Hystrix原理时，先对<strong>RxJava</strong>的 观察者-订阅者 模式来做一个简单了解。</p><h2 id="RxJava-观察者-订阅者模式"><a href="#RxJava-观察者-订阅者模式" class="headerlink" title="RxJava 观察者-订阅者模式"></a>RxJava 观察者-订阅者模式</h2><p>上面我们所提到的<code>Observable</code>对象就是<strong>RxJava</strong>的核心内容之一，可以把它理解为“事件源”或是“被观察者”，与其对应的<code>Subscriber</code>对象，可以理解为“订阅者”或是“观察者”。这两个对象是<strong>RxJava</strong>响应式编程的重要组成部分。</p><ul><li><code>Observable</code>用来向订阅者<code>Subscriber</code>对象发布事件，<code>Subscriber</code>对象则在接收到事件后对其进行处理，而在这里所指的的事件通常就是对依赖服务的调用。</li><li>一个<code>Observable</code>可以发出多个事件，直到结束或者发生异常。</li><li><code>Observable</code>对象每发出一个事件，就会调用对应观察者<code>Subscriber</code>对象的<code>onNext()</code>方法。</li><li>每一个<code>Observable</code>的执行，最后一定会通过调用<code>Subscriber.onCompleted()</code>或者<code>Subscriber.onError()</code>来结束该事件的操作流。</li></ul><p>我们通过一个例子来看一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建事件源observable</span></span><br><span class="line">        Observable&lt;String&gt; observable = Observable.unsafeCreate(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</span><br><span class="line">                subscriber.onNext(<span class="string">"Hello World"</span>);</span><br><span class="line">                subscriber.onNext(<span class="string">"I am sakuratears"</span>);</span><br><span class="line">                subscriber.onCompleted();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Subscriber&lt;String&gt; subscriber = <span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"completed"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Subscriber:"</span>+s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//订阅</span></span><br><span class="line">        observable.subscribe(subscriber);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该示例中，我们创建了一个简单的事件源<code>observable</code>，一个对事件传递内容输出的订阅者<code>subscriber</code>，通过<code>observable.subscribe(subscriber)</code>来触发事件的发布。</p><p>对于事件源<code>observable</code>，有两个不同的概念： <strong>Hot Observable</strong> 和 <strong>Cold Observable</strong>。其中<strong>Hot Observable</strong>，它不论“事件源”是否有“订阅者”，都会在创建后对事件进行发布，所以对于<strong>Hot Observable</strong>的每一个“订阅者”都有可能是从“事件源”的中途开始的，并可能只是看到了整个操作过程的局部过程。而<strong>Cold Observable</strong>在没有“订阅者”的时候并不会发布事件，而是进行等待，直到有“订阅者”之后才进行发布事件，所以对于<strong>Cold Observable</strong>的订阅者，它可以保证从一开始看到整个操作的全部过程。</p><p>以上就是在熟悉 Hystrix 源码时，我们应该有所了解的部分内容。</p><p>我们将在下篇文章详细分析 Hystrix 的一些内容。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇文章我们通过一个 Hystrix 的示例，对 Hystrix 有了简单的认识，同时简单介绍了两种模式，在 Hystrix 中，便使用了这两种模式，我们将在下篇文章详细分析，并进一步了解 Hystrix 的一些特点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="SpringCloud" scheme="https://www.sakuratears.top/tags/SpringCloud/"/>
    
      <category term="Hystrix" scheme="https://www.sakuratears.top/tags/Hystrix/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud Ribbon 配置详解</title>
    <link href="https://www.sakuratears.top/blog/SpringCloud-Ribbon-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3.html"/>
    <id>https://www.sakuratears.top/blog/SpringCloud-Ribbon-配置详解.html</id>
    <published>2020-11-01T10:02:00.000Z</published>
    <updated>2020-11-03T14:46:07.494Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在前面的文章中我们分析了SpringCloud Ribbon的源码，了解了Ribbon的特点及一些重要接口。这篇文章我们来看下Ribbon在使用时的各种配置。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Ribbon的自动化配置"><a href="#Ribbon的自动化配置" class="headerlink" title="Ribbon的自动化配置"></a>Ribbon的自动化配置</h2><p>由于Ribbon中定义的每个接口都有多种不同的策略实现，同时这些接口之间又有一定的依赖关系，某些开发者开始时很难上手，不知道如何选择具体实现策略等。</p><p>Spring Cloud Ribbon的自动化配置恰恰能够解决这种问题，当我们引入Spring Cloud Ribbon依赖之后，就能自动化构建下面这些接口的实现。</p><ul><li><code>IClientConfig</code>：Ribbon的客户端配置，默认采用<code>com.netflix.client.config.DefaultClientConfigImpl</code>实现。</li><li><code>IRule</code>：Ribbon的负载均衡策略，默认采用<code>com.netflix.loadbalancer.ZoneAvoidanceRule</code>实现，该策略能够在多区域环境下选出最佳区域的实例进行访问。</li><li><code>IPing</code>：Ribbon的实例检查策略，默认采用<code>com.netflix.loadbalancer.NoOpPing</code>实现，该策略不会检查实例是否可用，直接返回<code>true</code>，默认所有实例都是可用的。</li><li><code>ServerList&lt;Server&gt;</code>：服务实例清单维护机制，默认采用<code>com.netflix.loadbalancer.ConfigurationBasedServerList</code>实现。</li><li><code>ServerListFilter&lt;Server&gt;</code>：服务实例清单过滤机制，默认采用<code>org.springframework.cloud.netflix.ribbon.ZonePreferenceServerListFilter</code>实现，该策略能够优先过滤出与请求调用方处于同区域的服务实例。</li><li><code>ILoadBalancer</code>：负载均衡器，默认采用<code>com.netflix.loadbalancer.ZoneAwareLoadBalancer</code>实现，它具备了区域感知的能力。</li></ul><p>通过自动化配置的实现，我们可以轻松地实现客户端负载均衡。如果我们想实现一些个性化需求，也可以替换掉这些默认实现。</p><h2 id="代码配置"><a href="#代码配置" class="headerlink" title="代码配置"></a>代码配置</h2><p>如果我们想实现个性化配置，可以通过实现自定义的配置来完成，如下：</p><p>我们制定配置为<code>CustomLoadBalancer</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@RibbonClient</span>(name = <span class="string">"sakura"</span>,configuration = CustomLoadBalancer.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SakuraConsumerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SakuraConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实现如下：</p><p>使用了<code>NIWSDiscoveryPing</code>、<code>RandomRule</code>和我们前面文章自写的<code>ParallelPingStrategy</code>策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomLoadBalancer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">ILoadBalancer <span class="title">loadBalancer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BaseLoadBalancer(<span class="keyword">new</span> NIWSDiscoveryPing(),<span class="keyword">new</span> RandomRule(),<span class="keyword">new</span> ParallelPingStrategy());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，如果我们不需这么多改动，只想改变负载均衡策略。则如下配置即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerRule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IRule <span class="title">rule</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RandomRule();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他也与之类似。</p><p>这种配置方式唯一一个缺点是对于集群部署，如果我们想让每个节点的策略不同，需要变更相关代码，当然一般情况下每个节点的策略应是一致的。</p><h2 id="配置文件配置"><a href="#配置文件配置" class="headerlink" title="配置文件配置"></a>配置文件配置</h2><p>相比代码配置，使用配置文件配置相关参数更加灵活。</p><p>我们在<code>org.springframework.cloud.netflix.ribbon.PropertiesFactory</code>这个类里可以看到如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Map&lt;Class, String&gt; classToProperty = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PropertiesFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">classToProperty.put(ILoadBalancer.class, <span class="string">"NFLoadBalancerClassName"</span>);</span><br><span class="line">classToProperty.put(IPing.class, <span class="string">"NFLoadBalancerPingClassName"</span>);</span><br><span class="line">classToProperty.put(IRule.class, <span class="string">"NFLoadBalancerRuleClassName"</span>);</span><br><span class="line">classToProperty.put(ServerList.class, <span class="string">"NIWSServerListClassName"</span>);</span><br><span class="line">classToProperty.put(ServerListFilter.class, <span class="string">"NIWSServerListFilterClassName"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSet</span><span class="params">(Class clazz, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> StringUtils.hasText(getClassName(clazz, name));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getClassName</span><span class="params">(Class clazz, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.classToProperty.containsKey(clazz)) &#123;</span><br><span class="line">String classNameProperty = <span class="keyword">this</span>.classToProperty.get(clazz);</span><br><span class="line">String className = environment</span><br><span class="line">.getProperty(name + <span class="string">"."</span> + NAMESPACE + <span class="string">"."</span> + classNameProperty);</span><br><span class="line"><span class="keyword">return</span> className;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> &lt;C&gt; <span class="function">C <span class="title">get</span><span class="params">(Class&lt;C&gt; clazz, IClientConfig config, String name)</span> </span>&#123;</span><br><span class="line">String className = getClassName(clazz, name);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(className)) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class&lt;?&gt; toInstantiate = Class.forName(className);</span><br><span class="line"><span class="keyword">return</span> (C) SpringClientFactory.instantiateWithConfig(toInstantiate,</span><br><span class="line">config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unknown class to load "</span> + className</span><br><span class="line">+ <span class="string">" for class "</span> + clazz + <span class="string">" named "</span> + name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类可以动态地为<code>RibbonClient</code>创建接口实现。使用时，我们只需要&lt;clientName&gt;.ribbon.&lt;key&gt;=&lt;value&gt;的形式进行配置即可。</p><p>比如上面我们的代码配置，则可以用配置文件进行如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sakura.ribbon.NFLoadBalancerPingClassName = com.netflix.niws.loadbalancer.NIWSDiscoveryPing</span><br><span class="line">sakura.ribbon.NFLoadBalancerRuleClassName = com.netflix.loadbalancer.RandomRule</span><br><span class="line">sakura.ribbon.NFLoadBalancerClassName = com.zwt.sakuraconsumer.loadbalancer.CustomLoadBalancer</span><br></pre></td></tr></table></figure><h3 id="关于参数配置"><a href="#关于参数配置" class="headerlink" title="关于参数配置"></a>关于参数配置</h3><p>对于Ribbon的参数配置通常有两种方式：全局配置及指定客户端配置。</p><ul><li><p>全局配置：全局配置很简单，类如如下形式即可，ribbon.&lt;key&gt;=&lt;value&gt;格式配置即可。</p><p>  比如，我们全局配置Ribbon创建连接的超时时间。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ribbon.ConnectTimeout=300</span><br></pre></td></tr></table></figure><p>  全局配置可以作为默认值使用，当指定客户端配置了相应的key的值时，将覆盖全局配置的内容。</p></li><li><p>指定客户端配置：采用&lt;client&gt;.ribbon.&lt;key&gt;=&lt;value&gt;的格式进行配置。其中的&lt;client&gt;代表客户端名称，我们可以通过在<code>@RibbonClient</code>进行指定。</p><p>  比如，我们可以为客户端指定具体的实例清单，如下：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sakura.ribbon.listOfServers=localhost:8001,localhost:8002</span><br></pre></td></tr></table></figure></li></ul><p>在<code>com.netflix.client.config.CommonClientConfigKey</code>类中，我们可以找到Ribbon更为详细的配置参数内容。</p><p>我把参数详细信息整理如下，大家可以参考下：</p><table><thead><tr><th>配置项</th><th>类型</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>AppName</td><td>String</td><td></td><td>应用名称</td></tr><tr><td>Version</td><td>String</td><td></td><td>应用版本号</td></tr><tr><td>Port</td><td>Integer</td><td>7001</td><td>端口号</td></tr><tr><td>SecurePort</td><td>Integer</td><td>443</td><td>安全端口号</td></tr><tr><td>VipAddress</td><td>String</td><td></td><td>虚拟IP地址</td></tr><tr><td>ForceClientPortConfiguration</td><td>Boolean</td><td>false</td><td>是否强制使用客户端口号配置</td></tr><tr><td>DeploymentContextBasedVipAddresses</td><td>String</td><td></td><td></td></tr><tr><td>MaxAutoRetries</td><td>Integer</td><td>0</td><td>当前实例连接最大重试次数</td></tr><tr><td>MaxAutoRetriesNextServer</td><td>Integer</td><td>1</td><td>实例连接最大重试次数，超过会换其他实例重试</td></tr><tr><td>OkToRetryOnAllOperations</td><td>Boolean</td><td>false</td><td>是否对所有请求操作进行重试</td></tr><tr><td>RequestSpecificRetryOn</td><td>Boolean</td><td>false</td><td>是否对特殊请求进行重试</td></tr><tr><td>ReceiveBufferSize</td><td>Integer</td><td></td><td>接收到的数据流长度限制</td></tr><tr><td>EnablePrimeConnections</td><td>Boolean</td><td>false</td><td>启用预连接 （关于预连接请参考下文）</td></tr><tr><td>PrimeConnectionsClassName</td><td>String</td><td>com.netflix.niws.client.http.HttpPrimeConnection</td><td>预连接类名</td></tr><tr><td>MaxRetriesPerServerPrimeConnection</td><td>Integer</td><td>9</td><td>每个server的预连接最大重试次数</td></tr><tr><td>MaxTotalTimeToPrimeConnections</td><td>Integer</td><td>30000</td><td>预连接超时时间</td></tr><tr><td>MinPrimeConnectionsRatio</td><td>Float</td><td>1.0f</td><td>预连接最小时间间隔</td></tr><tr><td>PrimeConnectionsURI</td><td>String</td><td>/</td><td>预连接URI</td></tr><tr><td>PoolMaxThreads</td><td>Integer</td><td>200</td><td>连接池内最大可用线程数</td></tr><tr><td>PoolMinThreads</td><td>Integer</td><td>1</td><td>连接池内最小可用线程数</td></tr><tr><td>PoolKeepAliveTime</td><td>Integer</td><td>15 * 60L</td><td>连接在池内存活时间，默认15min</td></tr><tr><td>PoolKeepAliveTimeUnits</td><td>String</td><td>SECONDS</td><td>连接在池内存活时间单位</td></tr><tr><td>EnableConnectionPool</td><td>Boolean</td><td>true</td><td>是否启用连接池</td></tr><tr><td>MaxHttpConnectionsPerHost</td><td>Integer</td><td>50</td><td>已过时，详见MaxConnectionsPerHost</td></tr><tr><td>MaxTotalHttpConnections</td><td>Integer</td><td>200</td><td>已过时，详见MaxTotalConnections</td></tr><tr><td>MaxConnectionsPerHost</td><td>Integer</td><td>50</td><td>每个主机的最大连接数</td></tr><tr><td>MaxTotalConnections</td><td>Integer</td><td>200</td><td>最大连接总数</td></tr><tr><td>IsSecure</td><td>Boolean</td><td>false</td><td>是否安全连接</td></tr><tr><td>GZipPayload</td><td>Boolean</td><td>true</td><td>是否启用GZip传输</td></tr><tr><td>ConnectTimeout</td><td>Integer</td><td>2000</td><td>请求连接超时时间</td></tr><tr><td>BackoffTimeout</td><td>Integer</td><td></td><td></td></tr><tr><td>ReadTimeout</td><td>Integer</td><td>5000</td><td>请求处理超时时间</td></tr><tr><td>SendBufferSize</td><td>Integer</td><td></td><td>发送的数据最大长度</td></tr><tr><td>StaleCheckingEnabled</td><td>Boolean</td><td></td><td></td></tr><tr><td>Linger</td><td>Integer</td><td></td><td></td></tr><tr><td>ConnectionManagerTimeout</td><td>Integer</td><td>2000</td><td>连接管理器超时时间</td></tr><tr><td>FollowRedirects</td><td>Boolean</td><td>false</td><td>连接是否自动处理重定向</td></tr><tr><td>ConnectionPoolCleanerTaskEnabled</td><td>Boolean</td><td>true</td><td>是否启用连接池自动清理任务</td></tr><tr><td>ConnIdleEvictTimeMilliSeconds</td><td>Integer</td><td>30000</td><td>空闲连接存活时间</td></tr><tr><td>ConnectionCleanerRepeatInterval</td><td>Integer</td><td>30000</td><td>连接清理时间间隔</td></tr><tr><td>EnableGZIPContentEncodingFilter</td><td>Boolean</td><td>false</td><td>是否启用GZIP编码过滤</td></tr><tr><td>ProxyHost</td><td>String</td><td></td><td>服务代理地址</td></tr><tr><td>ProxyPort</td><td>Integer</td><td>Integer.MIN_VALUE + 1</td><td>代理服务端口号，默认值没有实际用途，如果使用需要用户自行设置</td></tr><tr><td>KeyStore</td><td>String</td><td></td><td></td></tr><tr><td>KeyStorePassword</td><td>String</td><td></td><td></td></tr><tr><td>TrustStore</td><td>String</td><td></td><td></td></tr><tr><td>TrustStorePassword</td><td>String</td><td></td><td></td></tr><tr><td>IsClientAuthRequired</td><td>Boolean</td><td>false</td><td>是否需要客户端安全认证（如果请求需要的话）</td></tr><tr><td>CustomSSLSocketFactoryClassName</td><td>String</td><td></td><td>用户自定义的SSL连接类</td></tr><tr><td>IsHostnameValidationRequired</td><td>Boolean</td><td></td><td>是否需要校验</td></tr><tr><td>IgnoreUserTokenInConnectionPoolForSecureClient</td><td>Boolean</td><td></td><td></td></tr><tr><td>ClientClassName</td><td>String</td><td>com.netflix.niws.client.http.RestClient</td><td>请求客户端的实现类</td></tr><tr><td>InitializeNFLoadBalancer</td><td>Boolean</td><td>true</td><td>是否初始化Ribbon负载均衡器</td></tr><tr><td>NFLoadBalancerClassName</td><td>String</td><td>com.netflix.loadbalancer.ZoneAwareLoadBalancer</td><td>使用的负载均衡器类名</td></tr><tr><td>NFLoadBalancerRuleClassName</td><td>String</td><td>com.netflix.loadbalancer.AvailabilityFilteringRule</td><td>负载均衡器的过滤规则</td></tr><tr><td>NFLoadBalancerPingClassName</td><td>String</td><td>com.netflix.loadbalancer.DummyPing</td><td>负载均衡器的ping规则</td></tr><tr><td>NFLoadBalancerPingInterval</td><td>Integer</td><td>30</td><td>ping间隔时间</td></tr><tr><td>NFLoadBalancerMaxTotalPingTime</td><td>Integer</td><td>2</td><td>ping的最大次数</td></tr><tr><td>NFLoadBalancerStatsClassName</td><td>String</td><td>com.netflix.loadbalancer.LoadBalancerStats</td><td>负载均衡状态统计类</td></tr><tr><td>NIWSServerListClassName</td><td>String</td><td>com.netflix.loadbalancer.ConfigurationBasedServerList</td><td>获取服务列表所使用的类</td></tr><tr><td>ServerListUpdaterClassName</td><td>String</td><td>com.netflix.loadbalancer.PollingServerListUpdater</td><td>服务列表更新所使用的类</td></tr><tr><td>NIWSServerListFilterClassName</td><td>String</td><td>com.netflix.loadbalancer.ZoneAffinityServerListFilter</td><td>区域甄别服务列表过滤类名</td></tr><tr><td>ServerListRefreshInterval</td><td>Integer</td><td>30 * 1000 ms</td><td>服务列表刷新间隔，单位毫秒</td></tr><tr><td>EnableMarkingServerDownOnReachingFailureLimit</td><td>Boolean</td><td></td><td></td></tr><tr><td>ServerDownFailureLimit</td><td>Integer</td><td></td><td></td></tr><tr><td>ServerDownStatWindowInMillis</td><td>Integer</td><td></td><td></td></tr><tr><td>EnableZoneAffinity</td><td>Boolean</td><td>false</td><td>是否开启区域甄别</td></tr><tr><td>EnableZoneExclusivity</td><td>Boolean</td><td>false</td><td>是否开启ZoneAffinity</td></tr><tr><td>PrioritizeVipAddressBasedServers</td><td>Boolean</td><td>true</td><td></td></tr><tr><td>VipAddressResolverClassName</td><td>String</td><td>com.netflix.client.SimpleVipAddressResolver</td><td></td></tr><tr><td>TargetRegion</td><td>String</td><td></td><td></td></tr><tr><td>RulePredicateClasses</td><td>String</td><td></td><td></td></tr><tr><td>RequestIdHeaderName</td><td>String</td><td></td><td></td></tr><tr><td>UseIPAddrForServer</td><td>Boolean</td><td>false</td><td>是否使用IP地址请求</td></tr><tr><td>listOfServers</td><td>String</td><td>“”</td><td>为客户端指定具体的实例清单</td></tr></tbody></table><p><strong>预连接</strong></p><p>对于那些拥有客户端负载均衡，并且知道要链接的服务器集群的客户端，我们可以预先与服务端建立连接，进行“预热”，这样做的好处是对于一些有防火墙的服务应用，请求时可以快速与之建立连接，提高应用体验。</p><p>详细信息可以查看 <code>com.netflix.niws.client.http.HttpPrimeConnection</code> 预连接处理类，这儿就不过多介绍了。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>关于上面的参数，很多是关于对Ribbon使用的HttpClient的配置，不太了解的可以先了解下HttpClient的一些参数配置等。</p><p>参数都遵循&lt;client&gt;.ribbon.&lt;key&gt;=&lt;value&gt;的配置。</p><p>比如我们以Ribbon的重试机制来进行举例，Spring Cloud整合了 Spring Retry来增强RestTemplate的重试能力，对于我们只需简单的配置，便可以实现重试功能。</p><p>我们在配置文件中添加如下配置信息，其配置信息含义已经说明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 该参数用来开启重试机制</span><br><span class="line">spring.cloud.loadbalancer.retry.enabled=true</span><br><span class="line"></span><br><span class="line">//断路器超时时间（断路器超时时间需要大于Ribbon超时时间，不然不会触发重试，有关断路器的内容，我们后面在了解）</span><br><span class="line">hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=10000</span><br><span class="line"></span><br><span class="line">//请求连接的超时时间</span><br><span class="line">sakura.ribbon.ConnectTimeout = 250</span><br><span class="line"></span><br><span class="line">//请求处理的超时时间</span><br><span class="line">sakura.ribbon.ReadTimeout= 1000</span><br><span class="line"></span><br><span class="line">//对所有请求操作进行重试</span><br><span class="line">sakura.ribbon.OkToRetryOnAllOperations = true</span><br><span class="line"></span><br><span class="line">//切换实例的重试次数</span><br><span class="line">sakura.ribbon.MaxAutoRetriesNextServer = 2</span><br><span class="line"></span><br><span class="line">//对当前实例的重试次数</span><br><span class="line">sakura.ribbon.MaxAutoRetries = 1</span><br></pre></td></tr></table></figure><p>根据如上配置，当访问到故障请求时，Ribbon会再尝试访问一次当前实例（访问次数取决于<code>MaxAutoRetries</code>），如果不行，就换一个实例进行访问，如果还是不行，再换一次实例访问（更换次数取决于<code>MaxAutoRetriesNextServer</code>），如果依然不行，返回失败。</p><h3 id="与Eureka结合"><a href="#与Eureka结合" class="headerlink" title="与Eureka结合"></a>与Eureka结合</h3><p>当我们在 Spring Cloud 的应用中同时引入 Spring Cloud Ribbon 和 Spring Cloud Eureka 依赖时，会触发 Eureka 中实现的对 Ribbon 的自动化配置。这时<code>ServerList</code>的维护机制实现将被<code>com.netflix.niws.loadbalancer.DiscoveryEnabledNIWSServerList</code>的实例所覆盖，该实现会将服务列表交给 Eureka 的服务治理机制来进行维护；<code>IPing</code>的实现将被<code>com.netflix.niws.loadbalancer.NIWSDiscoveryPing</code>的实例所覆盖，该实例也将实例检查的任务交给了服务治理框架来进行维护。默认情况下，用于获取实例请求的<code>ServerList</code>接口实现将采用 Spring Cloud Eureka 中封装的 <code>org.springframework.cloud.netflix.ribbon.eureka.DomainExtractingServerList</code>,其目的是为了让实例维护策略更加通用。</p><p>由于 Eureka 会为我们维护所有服务实例的清单，因此结合使用的时候，我们无需再配置类似<code>sakura.ribbon.listOfServers</code>的参数来指定服务实例清单。</p><p>此外，由于 Spring Cloud Ribbon 默认实现了区域亲和策略，所以我们可以通过 Eureka 实例的元数据配置来实现区域化的实例配置方案。比如，可以将处于不同机房的实例配置成不同的区域值，以作为跨区域的容错机制实现。而实现方式非常简单，只需在服务实例的元数据中增加 <code>zone</code>参数来指定自己所在的区域，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eureka.instance.metadataMap.zone=beijing</span><br></pre></td></tr></table></figure><p>在 Spring Cloud Ribbon 和 Spring Cloud Eureka 结合的工程中，我们也可以通过参数配置来禁用 Eureka 对 Ribbon 服务实例的维护实现。只需在配置文件加入如下参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ribbon.eureka.enabled=false</span><br></pre></td></tr></table></figure><p>禁用后，我们服务实例的维护需要手动指定<code>listOfServers</code>等参数。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是关于 Spring Cloud Ribbon 的一些配置及介绍，实际应用中，我们大多数与 Eureka 结合使用，很多遵循默认配置，真正的开箱即用，但我们也应对它们的配置及原理有所了解，方便我们更好的使用及解决可能出现的一系列问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="SpringCloud" scheme="https://www.sakuratears.top/tags/SpringCloud/"/>
    
      <category term="Ribbon" scheme="https://www.sakuratears.top/tags/Ribbon/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud Ribbon 负载均衡策略</title>
    <link href="https://www.sakuratears.top/blog/SpringCloud-Ribbon-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5.html"/>
    <id>https://www.sakuratears.top/blog/SpringCloud-Ribbon-负载均衡策略.html</id>
    <published>2020-10-18T13:29:00.000Z</published>
    <updated>2020-11-01T10:01:45.392Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>通过上篇文章对于SpringCloud Ribbon 负载均衡器的解读，我们已经对 Ribbon 实现负载均衡器以及其中包含的服务实例过滤器、服务实例信息存储对象、区域的信息快照等有了深入的认识和理解，接下来我们来看下负载均衡的几个策略实现。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>Ribbon中的负载均衡选择策略通过实现<code>IRule</code>接口来实现。具体关系如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-661.jpg" alt="upload successful"></p><p>下面我们来看下各种负载均衡策略。</p><h2 id="AbstractLoadBalancerRule"><a href="#AbstractLoadBalancerRule" class="headerlink" title="AbstractLoadBalancerRule"></a>AbstractLoadBalancerRule</h2><p>负载均衡策略的抽象类，在该抽象类中定义了负载均衡器<code>ILoadBalancer</code>对象，该对象能够在具体实现选择服务策略时，获取到一些负载均衡中维护的信息来作为分配依据，并以此设计一些算法来实现针对特定场景的高效策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractLoadBalancerRule</span> <span class="keyword">implements</span> <span class="title">IRule</span>, <span class="title">IClientConfigAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ILoadBalancer lb;</span><br><span class="line">        </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLoadBalancer</span><span class="params">(ILoadBalancer lb)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lb = lb;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ILoadBalancer <span class="title">getLoadBalancer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lb;</span><br><span class="line">    &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RandomRule"><a href="#RandomRule" class="headerlink" title="RandomRule"></a>RandomRule</h2><p>该策略实现了从服务实例清单中随机选择一个服务实例的功能。其具体实现如下：</p><p>主要由<code>choose</code>函数完成，委托给函数<code>choose(ILoadBalancer lb, Object key)</code>来实现。</p><ol><li>获取可用实例列表<code>upList</code>和所有实例列表<code>allList</code>；</li><li>获取一个随机数，通过<code>chooseRandomInt(serverCount)</code>函数；</li><li>将该随机数作为<code>upList</code>的索引值来返回具体实例；</li><li>选择逻辑处于一个循环中，正常情况下，每次都应该选出一个具体实例，如果出现死循环获取不到服务实例的情况，则可能出现一些问题。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(ILoadBalancer lb, Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lb == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Server server = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Server&gt; upList = lb.getReachableServers();</span><br><span class="line">        List&lt;Server&gt; allList = lb.getAllServers();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> serverCount = allList.size();</span><br><span class="line">        <span class="keyword">if</span> (serverCount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = chooseRandomInt(serverCount);</span><br><span class="line">        server = upList.get(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (server.isAlive()) &#123;</span><br><span class="line">            <span class="keyword">return</span> (server);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        server = <span class="keyword">null</span>;</span><br><span class="line">        Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> server;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">chooseRandomInt</span><span class="params">(<span class="keyword">int</span> serverCount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ThreadLocalRandom.current().nextInt(serverCount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> choose(getLoadBalancer(), key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RoundRobinRule"><a href="#RoundRobinRule" class="headerlink" title="RoundRobinRule"></a>RoundRobinRule</h2><p>该策略实现了按照线性轮询的方式一次选择每个服务实例的功能。其具体实现逻辑如下：</p><ol><li>获取可用实例列表<code>reachableServers</code>和所有实例列表<code>allServers</code>，并记录它们的数量<code>upCount</code>、<code>serverCount</code>；</li><li>获取下一个可用服务的索引，主要通过<code>incrementAndGetModulo</code>函数实现；</li><li>选择逻辑处于循环中，与<code>RandomRule</code>不同的是，如果一直选不到<code>server</code>超过10次，该循环终止，打印警告日志并返回null。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(ILoadBalancer lb, Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lb == <span class="keyword">null</span>) &#123;</span><br><span class="line">        log.warn(<span class="string">"no load balancer"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Server server = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (server == <span class="keyword">null</span> &amp;&amp; count++ &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        List&lt;Server&gt; reachableServers = lb.getReachableServers();</span><br><span class="line">        List&lt;Server&gt; allServers = lb.getAllServers();</span><br><span class="line">        <span class="keyword">int</span> upCount = reachableServers.size();</span><br><span class="line">        <span class="keyword">int</span> serverCount = allServers.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((upCount == <span class="number">0</span>) || (serverCount == <span class="number">0</span>)) &#123;</span><br><span class="line">            log.warn(<span class="string">"No up servers available from load balancer: "</span> + lb);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> nextServerIndex = incrementAndGetModulo(serverCount);</span><br><span class="line">        server = allServers.get(nextServerIndex);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/* Transient. */</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (server.isAlive() &amp;&amp; (server.isReadyToServe())) &#123;</span><br><span class="line">            <span class="keyword">return</span> (server);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Next.</span></span><br><span class="line">        server = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">        log.warn(<span class="string">"No available alive servers after 10 tries from load balancer: "</span></span><br><span class="line">                + lb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> server;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">incrementAndGetModulo</span><span class="params">(<span class="keyword">int</span> modulo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = nextServerCyclicCounter.get();</span><br><span class="line">        <span class="keyword">int</span> next = (current + <span class="number">1</span>) % modulo;</span><br><span class="line">        <span class="keyword">if</span> (nextServerCyclicCounter.compareAndSet(current, next))</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> choose(getLoadBalancer(), key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RetryRule"><a href="#RetryRule" class="headerlink" title="RetryRule"></a>RetryRule</h2><p>该策略实现了一个具备重试机制的实例选择功能。其具体实现逻辑如下：</p><ol><li>内部定义一个<code>IRule</code>对象，默认使用<code>RoundRobinRule</code>实例；</li><li><code>choose</code>函数中实现了对内部策略进行反复尝试的策略；</li><li>若期间能够选择到具体实例就返回，若选择不到就根据设置的尝试结束时间为阈值<code>maxRetryMillis</code>，当超过阈值后就返回null。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryRule</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalancerRule</span> </span>&#123;</span><br><span class="line">IRule subRule = <span class="keyword">new</span> RoundRobinRule();</span><br><span class="line"><span class="keyword">long</span> maxRetryMillis = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RetryRule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RetryRule</span><span class="params">(IRule subRule)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.subRule = (subRule != <span class="keyword">null</span>) ? subRule : <span class="keyword">new</span> RoundRobinRule();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RetryRule</span><span class="params">(IRule subRule, <span class="keyword">long</span> maxRetryMillis)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.subRule = (subRule != <span class="keyword">null</span>) ? subRule : <span class="keyword">new</span> RoundRobinRule();</span><br><span class="line"><span class="keyword">this</span>.maxRetryMillis = (maxRetryMillis &gt; <span class="number">0</span>) ? maxRetryMillis : <span class="number">500</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRule</span><span class="params">(IRule subRule)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.subRule = (subRule != <span class="keyword">null</span>) ? subRule : <span class="keyword">new</span> RoundRobinRule();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> IRule <span class="title">getRule</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> subRule;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaxRetryMillis</span><span class="params">(<span class="keyword">long</span> maxRetryMillis)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (maxRetryMillis &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.maxRetryMillis = maxRetryMillis;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.maxRetryMillis = <span class="number">500</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getMaxRetryMillis</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> maxRetryMillis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLoadBalancer</span><span class="params">(ILoadBalancer lb)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.setLoadBalancer(lb);</span><br><span class="line">subRule.setLoadBalancer(lb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Loop if necessary. Note that the time CAN be exceeded depending on the</span></span><br><span class="line"><span class="comment"> * subRule, because we're not spawning additional threads and returning</span></span><br><span class="line"><span class="comment"> * early.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(ILoadBalancer lb, Object key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> requestTime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">long</span> deadline = requestTime + maxRetryMillis;</span><br><span class="line"></span><br><span class="line">Server answer = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">answer = subRule.choose(key);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (((answer == <span class="keyword">null</span>) || (!answer.isAlive()))</span><br><span class="line">&amp;&amp; (System.currentTimeMillis() &lt; deadline)) &#123;</span><br><span class="line"></span><br><span class="line">InterruptTask task = <span class="keyword">new</span> InterruptTask(deadline</span><br><span class="line">- System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">answer = subRule.choose(key);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (((answer == <span class="keyword">null</span>) || (!answer.isAlive()))</span><br><span class="line">&amp;&amp; (System.currentTimeMillis() &lt; deadline)) &#123;</span><br><span class="line"><span class="comment">/* pause and retry hoping it's transient */</span></span><br><span class="line">Thread.yield();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task.cancel();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((answer == <span class="keyword">null</span>) || (!answer.isAlive())) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> choose(getLoadBalancer(), key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initWithNiwsConfig</span><span class="params">(IClientConfig clientConfig)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WeightedResponseTimeRule"><a href="#WeightedResponseTimeRule" class="headerlink" title="WeightedResponseTimeRule"></a>WeightedResponseTimeRule</h2><p>该策略是对<code>RoundRobinRule</code>的扩展，增加了根据实例的运行情况来计算权重，并根据权重来挑选实例，以达到更优的分配效果。</p><p>其主要构成如下：</p><h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><p><code>WeightedResponseTimeRule</code>策略在初始化的时候会通过<code>serverWeightTimer.schedule</code>启动一个定时任务，用来为每个服务实例计算权重，该任务默认30s执行一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//....</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_TIMER_INTERVAL = <span class="number">30</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverWeightTaskTimerInterval = DEFAULT_TIMER_INTERVAL;</span><br><span class="line"></span><br><span class="line"><span class="comment">//....</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLoadBalancer</span><span class="params">(ILoadBalancer lb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.setLoadBalancer(lb);</span><br><span class="line">    <span class="keyword">if</span> (lb <span class="keyword">instanceof</span> BaseLoadBalancer) &#123;</span><br><span class="line">        name = ((BaseLoadBalancer) lb).getName();</span><br><span class="line">    &#125;</span><br><span class="line">    initialize(lb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ILoadBalancer lb)</span> </span>&#123;        </span><br><span class="line">    <span class="keyword">if</span> (serverWeightTimer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        serverWeightTimer.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    serverWeightTimer = <span class="keyword">new</span> Timer(<span class="string">"NFLoadBalancer-serverWeightTimer-"</span></span><br><span class="line">            + name, <span class="keyword">true</span>);</span><br><span class="line">    serverWeightTimer.schedule(<span class="keyword">new</span> DynamicServerWeightTask(), <span class="number">0</span>,</span><br><span class="line">            serverWeightTaskTimerInterval);</span><br><span class="line">    <span class="comment">// do a initial run</span></span><br><span class="line">    ServerWeight sw = <span class="keyword">new</span> ServerWeight();</span><br><span class="line">    sw.maintainWeights();</span><br><span class="line"></span><br><span class="line">    Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            logger</span><br><span class="line">                    .info(<span class="string">"Stopping NFLoadBalancer-serverWeightTimer-"</span></span><br><span class="line">                            + name);</span><br><span class="line">            serverWeightTimer.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//....</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DynamicServerWeightTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServerWeight serverWeight = <span class="keyword">new</span> ServerWeight();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverWeight.maintainWeights();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">"Error running DynamicServerWeightTask for &#123;&#125;"</span>, name, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//....</span></span><br></pre></td></tr></table></figure><h3 id="权重计算"><a href="#权重计算" class="headerlink" title="权重计算"></a>权重计算</h3><p>在源码中我们可以找到用于存储权重的对象 <code>List<double> accumulatedWeights = new ArrayList<double>()</double></double></code>，该<code>List</code>中每个权重值所处的位置对应了负载均衡器维护的实例清单中所有实例所在清单中的位置。</p><p>维护实例权重的计算过程通过<code>maintainWeights</code>函数实现，其代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">maintainWeights</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ILoadBalancer lb = getLoadBalancer();</span><br><span class="line">    <span class="keyword">if</span> (lb == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!serverWeightAssignmentInProgress.compareAndSet(<span class="keyword">false</span>,  <span class="keyword">true</span>))  &#123;</span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        logger.info(<span class="string">"Weight adjusting job started"</span>);</span><br><span class="line">        AbstractLoadBalancer nlb = (AbstractLoadBalancer) lb;</span><br><span class="line">        LoadBalancerStats stats = nlb.getLoadBalancerStats();</span><br><span class="line">        <span class="keyword">if</span> (stats == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// no statistics, nothing to do</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> totalResponseTime = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// find maximal 95% response time</span></span><br><span class="line">        <span class="keyword">for</span> (Server server : nlb.getAllServers()) &#123;</span><br><span class="line">            <span class="comment">// this will automatically load the stats if not in cache</span></span><br><span class="line">            ServerStats ss = stats.getSingleServerStat(server);</span><br><span class="line">            totalResponseTime += ss.getResponseTimeAvg();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// weight for each server is (sum of responseTime of all servers - responseTime)</span></span><br><span class="line">        <span class="comment">// so that the longer the response time, the less the weight and the less likely to be chosen</span></span><br><span class="line">        Double weightSoFar = <span class="number">0.0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// create new list and hot swap the reference</span></span><br><span class="line">        List&lt;Double&gt; finalWeights = <span class="keyword">new</span> ArrayList&lt;Double&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Server server : nlb.getAllServers()) &#123;</span><br><span class="line">            ServerStats ss = stats.getSingleServerStat(server);</span><br><span class="line">            <span class="keyword">double</span> weight = totalResponseTime - ss.getResponseTimeAvg();</span><br><span class="line">            weightSoFar += weight;</span><br><span class="line">            finalWeights.add(weightSoFar);   </span><br><span class="line">        &#125;</span><br><span class="line">        setWeights(finalWeights);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(<span class="string">"Error calculating server weights"</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        serverWeightAssignmentInProgress.set(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数实现内容如下：</p><ul><li>根据<code>LoadBalancerStats</code>中记录的每个实例的统计信息，累加所有实例的平均响应时间，得到总平均响应时间<code>totalResponseTime</code>，该值会用于后续计算。</li><li>为负载均衡器中维护的实例清单逐个计算权重（从第一个开始），计算规则为<code>weightSoFar+totalResponseTime-实例平均响应时间</code>，其中<code>weightSoFar</code>初始化为0，并且每计算好一个权重需要累加到<code>weightSoFar</code>上供下次计算使用。</li></ul><p>如下例子：</p><p>假设4个实例A、B、C、D，它们平均响应时间为10、40、80、100，所以总响应时间为10+40+80+100=230，根据上面，可以计算出实例A、B、C、D的权重：</p><ul><li>A：230 - 10 = 220</li><li>B：220 + (230 - 40) = 410</li><li>C：410 + (230 - 80) = 560</li><li>D：560 + (230 - 100) = 690</li></ul><p>需要注意的是，这里的权重值只是表示了各实例权重区间上限，并非实例优先级。实例A、B、C、D的权重区间如下：</p><ul><li>A：[0,220]</li><li>B：(220,410]</li><li>C：(410,560]</li><li>D：(560,690)</li></ul><p>可以看到，每个区间的宽度就是：总平均响应时间-实例的平均响应时间，所有实例的平均响应时间越短、权重区间的宽度越大，宽度越大被选中的概率就越高。</p><p>我们再来看下区间边界的开闭是如何确定的。</p><h3 id="实例选择"><a href="#实例选择" class="headerlink" title="实例选择"></a>实例选择</h3><p>我们来看下该策略的实例选择算法相关代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(ILoadBalancer lb, Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lb == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Server server = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// get hold of the current reference in case it is changed from the other thread</span></span><br><span class="line">        List&lt;Double&gt; currentWeights = accumulatedWeights;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Server&gt; allList = lb.getAllServers();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> serverCount = allList.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (serverCount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> serverIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// last one in the list is the sum of all weights</span></span><br><span class="line">        <span class="keyword">double</span> maxTotalWeight = currentWeights.size() == <span class="number">0</span> ? <span class="number">0</span> : currentWeights.get(currentWeights.size() - <span class="number">1</span>); </span><br><span class="line">        <span class="comment">// No server has been hit yet and total weight is not initialized</span></span><br><span class="line">        <span class="comment">// fallback to use round robin</span></span><br><span class="line">        <span class="keyword">if</span> (maxTotalWeight &lt; <span class="number">0.001</span>d || serverCount != currentWeights.size()) &#123;</span><br><span class="line">            server =  <span class="keyword">super</span>.choose(getLoadBalancer(), key);</span><br><span class="line">            <span class="keyword">if</span>(server == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> server;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// generate a random weight between 0 (inclusive) to maxTotalWeight (exclusive)</span></span><br><span class="line">            <span class="keyword">double</span> randomWeight = random.nextDouble() * maxTotalWeight;</span><br><span class="line">            <span class="comment">// pick the server index based on the randomIndex</span></span><br><span class="line">            <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (Double d : currentWeights) &#123;</span><br><span class="line">                <span class="keyword">if</span> (d &gt;= randomWeight) &#123;</span><br><span class="line">                    serverIndex = n;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    n++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            server = allList.get(serverIndex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/* Transient. */</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (server.isAlive()) &#123;</span><br><span class="line">            <span class="keyword">return</span> (server);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Next.</span></span><br><span class="line">        server = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> server;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其代码逻辑主要如下：</p><ol><li>生成一个 [0,最大权重值) 区间内的随机数。</li><li>遍历权重列表，比较权重值与随机数的大小，如果权重值大于等于随机数，就拿当前权重列表的索引值去服务实例列表中获取具体的实例。因此每个权重区间为 (x,y] 的形式，由于随机数的最小值可以为0，所以第一个实例的下限是闭区间，随机数最大值取不到权重最大值，所以最后一个实例上限是开区间。</li></ol><p>按照上面的例子，如果随机数为230，则该值位于第二区间，所以此时就会选择实例B进行请求。</p><h2 id="ClientConfigEnabledRoundRobinRule"><a href="#ClientConfigEnabledRoundRobinRule" class="headerlink" title="ClientConfigEnabledRoundRobinRule"></a>ClientConfigEnabledRoundRobinRule</h2><p>该策略较为特殊，我们一般不直接使用它。因为它本身没有实现任何特殊的处理逻辑，如代码所示，在它内部定义了一个<code>RoundRobinRule</code>策略，而<code>choose</code>函数的实现也正是使用了<code>RoundRobinRule</code>的线下轮询机制。</p><p>虽然我们不会直接使用该策略，但是通过继承该策略，默认的<code>choose</code>就实现了线性轮询机制，在子类中做一些高级策略时通常可能存在一些无法实施的情况，那么就可以使用父类的实现作为备选。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientConfigEnabledRoundRobinRule</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalancerRule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    RoundRobinRule roundRobinRule = <span class="keyword">new</span> RoundRobinRule();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initWithNiwsConfig</span><span class="params">(IClientConfig clientConfig)</span> </span>&#123;</span><br><span class="line">        roundRobinRule = <span class="keyword">new</span> RoundRobinRule();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLoadBalancer</span><span class="params">(ILoadBalancer lb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.setLoadBalancer(lb);</span><br><span class="line">    roundRobinRule.setLoadBalancer(lb);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (roundRobinRule != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> roundRobinRule.choose(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"This class has not been initialized with the RoundRobinRule class"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BestAvailableRule"><a href="#BestAvailableRule" class="headerlink" title="BestAvailableRule"></a>BestAvailableRule</h2><p>该策略继承自<code>ClientConfigEnabledRoundRobinRule</code>，同时在实现中注入了负载均衡器统计对象<code>LoadBalancerStats</code>，算法通过利用统计对象中保存的实例信息来选择满足要求的实例。</p><p>通过代码我们可以看到，它通过遍历负载均衡器中维护的所有实例，会过滤掉故障实例，并找出并发请求数最小的一个，所以该策略的特性是可以选出最空闲的实例。</p><p>当<code>LoadBalancerStats</code>对象为空时，会使用父类的<code>RoundRobinRule</code>策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BestAvailableRule</span> <span class="keyword">extends</span> <span class="title">ClientConfigEnabledRoundRobinRule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LoadBalancerStats loadBalancerStats;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (loadBalancerStats == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.choose(key);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Server&gt; serverList = getLoadBalancer().getAllServers();</span><br><span class="line">        <span class="keyword">int</span> minimalConcurrentConnections = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">        Server chosen = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Server server: serverList) &#123;</span><br><span class="line">            ServerStats serverStats = loadBalancerStats.getSingleServerStat(server);</span><br><span class="line">            <span class="keyword">if</span> (!serverStats.isCircuitBreakerTripped(currentTime)) &#123;</span><br><span class="line">                <span class="keyword">int</span> concurrentConnections = serverStats.getActiveRequestsCount(currentTime);</span><br><span class="line">                <span class="keyword">if</span> (concurrentConnections &lt; minimalConcurrentConnections) &#123;</span><br><span class="line">                    minimalConcurrentConnections = concurrentConnections;</span><br><span class="line">                    chosen = server;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (chosen == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.choose(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> chosen;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLoadBalancer</span><span class="params">(ILoadBalancer lb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setLoadBalancer(lb);</span><br><span class="line">        <span class="keyword">if</span> (lb <span class="keyword">instanceof</span> AbstractLoadBalancer) &#123;</span><br><span class="line">            loadBalancerStats = ((AbstractLoadBalancer) lb).getLoadBalancerStats();            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PredicateBasedRule"><a href="#PredicateBasedRule" class="headerlink" title="PredicateBasedRule"></a>PredicateBasedRule</h2><p>这是一个抽象策略，它也继承自<code>ClientConfigEnabledRoundRobinRule</code>，其基础逻辑如下：</p><p>先通过子类中实现的<code>Predicate</code>逻辑来过滤一部分服务实例，然后再以线性轮询的方式从过滤后的实例清单中选出一个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PredicateBasedRule</span> <span class="keyword">extends</span> <span class="title">ClientConfigEnabledRoundRobinRule</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AbstractServerPredicate <span class="title">getPredicate</span><span class="params">()</span></span>;</span><br><span class="line">        </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        ILoadBalancer lb = getLoadBalancer();</span><br><span class="line">        Optional&lt;Server&gt; server = getPredicate().chooseRoundRobinAfterFiltering(lb.getAllServers(), key);</span><br><span class="line">        <span class="keyword">if</span> (server.isPresent()) &#123;</span><br><span class="line">            <span class="keyword">return</span> server.get();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它是通过 Google Guava Collection 工具对集合进行过滤的接口<code>Predicate</code>来实现的。我们来看下<code>AbstractServerPredicate</code>的部分关键逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractServerPredicate</span> <span class="keyword">implements</span> <span class="title">Predicate</span>&lt;<span class="title">PredicateKey</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Optional&lt;Server&gt; <span class="title">chooseRoundRobinAfterFiltering</span><span class="params">(List&lt;Server&gt; servers)</span> </span>&#123;</span><br><span class="line">        List&lt;Server&gt; eligible = getEligibleServers(servers);</span><br><span class="line">        <span class="keyword">if</span> (eligible.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Optional.absent();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Optional.of(eligible.get(incrementAndGetModulo(eligible.size())));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Server&gt; <span class="title">getEligibleServers</span><span class="params">(List&lt;Server&gt; servers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getEligibleServers(servers, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Server&gt; <span class="title">getEligibleServers</span><span class="params">(List&lt;Server&gt; servers, Object loadBalancerKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (loadBalancerKey == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ImmutableList.copyOf(Iterables.filter(servers, <span class="keyword">this</span>.getServerOnlyPredicate()));            </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            List&lt;Server&gt; results = Lists.newArrayList();</span><br><span class="line">            <span class="keyword">for</span> (Server server: servers) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.apply(<span class="keyword">new</span> PredicateKey(loadBalancerKey, server))) &#123;</span><br><span class="line">                    results.add(server);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> results;            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个抽象策略只是提供一个实现过滤清单的模板，具体实现需要其子类去完成（实现<code>Predicate</code>接口的<code>apply</code>方法），过滤清单后得到符合条件的实例，轮询选择。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GwtCompatible</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(@Nullable T var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(@Nullable Object var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AvailabilityFilteringRule"><a href="#AvailabilityFilteringRule" class="headerlink" title="AvailabilityFilteringRule"></a>AvailabilityFilteringRule</h2><p>该策略继承自<code>PredicateBasedRule</code>，其过滤条件使用了<code>AvailabilityPredicate</code>。</p><p><code>AvailabilityPredicate</code>的关键代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AvailabilityPredicate</span> <span class="keyword">extends</span>  <span class="title">AbstractServerPredicate</span> </span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(@Nullable PredicateKey input)</span> </span>&#123;</span><br><span class="line">        LoadBalancerStats stats = getLBStats();</span><br><span class="line">        <span class="keyword">if</span> (stats == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> !shouldSkipServer(stats.getSingleServerStat(input.getServer()));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">shouldSkipServer</span><span class="params">(ServerStats stats)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">if</span> ((CIRCUIT_BREAKER_FILTERING.get() &amp;&amp; stats.isCircuitBreakerTripped()) </span><br><span class="line">                || stats.getActiveRequestsCount() &gt;= activeConnectionsLimit.get()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码，我们可以看到该策略的主要过滤逻辑：</p><ul><li>是否故障，即断路器是否生效已断开。</li><li>实例的并发请求数大于阈值，默认<code>Integer.MAX_VALUE</code>，该配置可通过参数<clientname>.<namespace>.ActiveConnectionsLimit 来修改。</namespace></clientname></li></ul><p>这两项只要满足一个就返回false，代表节点可能故障或者负载过高，不适用处理请求，会被过滤掉，都不满足返回true，表示该节点可被选择用于处理请求。</p><p>除了上面的过滤方法，该策略的<code>choose</code>函数也做了一些改进优化，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AvailabilityFilteringRule</span> <span class="keyword">extends</span> <span class="title">PredicateBasedRule</span> </span>&#123; </span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initWithNiwsConfig</span><span class="params">(IClientConfig clientConfig)</span> </span>&#123;</span><br><span class="line">    predicate = CompositePredicate.withPredicate(<span class="keyword">new</span> AvailabilityPredicate(<span class="keyword">this</span>, clientConfig))</span><br><span class="line">                .addFallbackPredicate(AbstractServerPredicate.alwaysTrue())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        Server server = roundRobinRule.choose(key);</span><br><span class="line">        <span class="keyword">while</span> (count++ &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (predicate.apply(<span class="keyword">new</span> PredicateKey(server))) &#123;</span><br><span class="line">                <span class="keyword">return</span> server;</span><br><span class="line">            &#125;</span><br><span class="line">            server = roundRobinRule.choose(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.choose(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>choose</code>函数的实现逻辑并不像父类那样，先遍历所有节点进行过滤，然后在过滤后的集合中选择实例。</p><p>而是先以线性的方式选择一个实例，接着用过滤条件判断该实例是否满足要求，满足直接使用该实例，不满足选择下一个实例，并进行检查，如此循环进行，如果这个过程重复了10次还是没有找到符合要求的实例，就采用父类的实现方案。</p><p>该策略通过线性抽样的方式直接尝试寻找可用且较空闲的实例来使用，优化了父类每次都要遍历所有实例的开销。</p><h2 id="ZoneAvoidanceRule"><a href="#ZoneAvoidanceRule" class="headerlink" title="ZoneAvoidanceRule"></a>ZoneAvoidanceRule</h2><p>该策略也是<code>PredicateBasedRule</code>的实现类。可以看到它使用了<code>CompositePredicate</code>来进行服务清单过滤。这是一个组合过滤条件，在其构造函数中，它以<code>ZoneAvoidancePredicate</code>为主过滤条件，<code>AvailabilityPredicate</code>为次过滤条件来进行过滤。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZoneAvoidanceRule</span> <span class="keyword">extends</span> <span class="title">PredicateBasedRule</span> </span>&#123;</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">    <span class="keyword">private</span> CompositePredicate compositePredicate;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZoneAvoidanceRule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        ZoneAvoidancePredicate zonePredicate = <span class="keyword">new</span> ZoneAvoidancePredicate(<span class="keyword">this</span>);</span><br><span class="line">        AvailabilityPredicate availabilityPredicate = <span class="keyword">new</span> AvailabilityPredicate(<span class="keyword">this</span>);</span><br><span class="line">        compositePredicate = createCompositePredicate(zonePredicate, availabilityPredicate);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ZoneAvoidanceRule</code>在实现的时候并没有像<code>AvailabilityFilteringRule</code>那样重写<code>choose</code>函数来优化，所以它和父类一样，先过滤清单，再轮询选择。</p><p>过滤条件就是上面提到的两个组合条件，我们先来看下<code>CompositePredicate</code>的部分源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositePredicate</span> <span class="keyword">extends</span> <span class="title">AbstractServerPredicate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AbstractServerPredicate delegate;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> List&lt;AbstractServerPredicate&gt; fallbacks = Lists.newArrayList();</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minimalFilteredServers = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> minimalFilteredPercentage = <span class="number">0</span>;    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(@Nullable PredicateKey input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> delegate.apply(input);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> CompositePredicate toBuild;</span><br><span class="line">        </span><br><span class="line">        Builder(AbstractServerPredicate primaryPredicate) &#123;</span><br><span class="line">            toBuild = <span class="keyword">new</span> CompositePredicate();    </span><br><span class="line">            toBuild.delegate = primaryPredicate;                    </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Builder(AbstractServerPredicate ...primaryPredicates) &#123;</span><br><span class="line">            toBuild = <span class="keyword">new</span> CompositePredicate();</span><br><span class="line">            Predicate&lt;PredicateKey&gt; chain = Predicates.&lt;PredicateKey&gt;and(primaryPredicates);</span><br><span class="line">            toBuild.delegate =  AbstractServerPredicate.ofKeyPredicate(chain);                </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">addFallbackPredicate</span><span class="params">(AbstractServerPredicate fallback)</span> </span>&#123;</span><br><span class="line">            toBuild.fallbacks.add(fallback);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setFallbackThresholdAsMinimalFilteredNumberOfServers</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">            toBuild.minimalFilteredServers = number;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setFallbackThresholdAsMinimalFilteredPercentage</span><span class="params">(<span class="keyword">float</span> percent)</span> </span>&#123;</span><br><span class="line">            toBuild.minimalFilteredPercentage = percent;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> CompositePredicate <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> toBuild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Builder <span class="title">withPredicates</span><span class="params">(AbstractServerPredicate ...primaryPredicates)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Builder(primaryPredicates);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Builder <span class="title">withPredicate</span><span class="params">(AbstractServerPredicate primaryPredicate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Builder(primaryPredicate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the filtered servers from primary predicate, and if the number of the filtered servers</span></span><br><span class="line"><span class="comment">     * are not enough, trying the fallback predicates  </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Server&gt; <span class="title">getEligibleServers</span><span class="params">(List&lt;Server&gt; servers, Object loadBalancerKey)</span> </span>&#123;</span><br><span class="line">        List&lt;Server&gt; result = <span class="keyword">super</span>.getEligibleServers(servers, loadBalancerKey);</span><br><span class="line">        Iterator&lt;AbstractServerPredicate&gt; i = fallbacks.iterator();</span><br><span class="line">        <span class="keyword">while</span> (!(result.size() &gt;= minimalFilteredServers &amp;&amp; result.size() &gt; (<span class="keyword">int</span>) (servers.size() * minimalFilteredPercentage))</span><br><span class="line">                &amp;&amp; i.hasNext()) &#123;</span><br><span class="line">            AbstractServerPredicate predicate = i.next();</span><br><span class="line">            result = predicate.getEligibleServers(servers, loadBalancerKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面源码，可以看到<code>CompositePredicate</code>是可以支持多个过滤条件的，它们存储在<code>fallbacks</code>的List里。</p><p>我们指定传入的过滤条件参数顺序就是过滤条件的优先级，因为它们放入List后是有序的。</p><p>我们主要来看下<code>getEligibleServers</code>的逻辑：</p><ul><li>使用主过滤条件对所有实例过滤并返回过滤后的实例清单。</li><li>依次使用次过滤条件列表中的过滤条件对上面的过滤结果进行过滤。</li><li>每次过滤后（包括主过滤条件和次过滤条件），都需要判断下面两个条件，只要有一个不符合就不再进行过滤，将当前结果返回供线性轮询算法选择：<ul><li>过滤后的实例总数 &gt;= 最小过滤实例数（minimalFilteredServers，默认为1）.</li><li>过滤后的实例比例 &gt; 最小过滤百分比（minimalFilteredPercentage，默认为0）.</li></ul></li></ul><p>对于传入的两个过滤条件，<code>AvailabilityPredicate</code>我们上面有介绍，我们来看下<code>ZoneAvoidancePredicate</code>。</p><p>其主要逻辑部分如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZoneAvoidancePredicate</span> <span class="keyword">extends</span>  <span class="title">AbstractServerPredicate</span> </span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(@Nullable PredicateKey input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!ENABLED.get()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String serverZone = input.getServer().getZone();</span><br><span class="line">        <span class="keyword">if</span> (serverZone == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// there is no zone information from the server, we do not want to filter</span></span><br><span class="line">            <span class="comment">// out this server</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LoadBalancerStats lbStats = getLBStats();</span><br><span class="line">        <span class="keyword">if</span> (lbStats == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// no stats available, do not filter</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lbStats.getAvailableZones().size() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// only one zone is available, do not filter</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String, ZoneSnapshot&gt; zoneSnapshot = ZoneAvoidanceRule.createSnapshot(lbStats);</span><br><span class="line">        <span class="keyword">if</span> (!zoneSnapshot.keySet().contains(serverZone)) &#123;</span><br><span class="line">            <span class="comment">// The server zone is unknown to the load balancer, do not filter it out </span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        logger.debug(<span class="string">"Zone snapshots: &#123;&#125;"</span>, zoneSnapshot);</span><br><span class="line">        Set&lt;String&gt; availableZones = ZoneAvoidanceRule.getAvailableZones(zoneSnapshot, triggeringLoad.get(), triggeringBlackoutPercentage.get());</span><br><span class="line">        logger.debug(<span class="string">"Available zones: &#123;&#125;"</span>, availableZones);</span><br><span class="line">        <span class="keyword">if</span> (availableZones != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> availableZones.contains(input.getServer().getZone());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码逻辑：</p><ul><li><code>niws.loadbalancer.zoneAvoidanceRule.enabled</code> 配置参数是否开启，如果为false，该过滤条件直接返回true。</li><li>拿到实例的<code>Zone</code>，如果为空，该过滤条件直接返回true。</li><li>拿到实例的<code>LoadBalancerStats</code>，如果为空或者可用<code>Zone</code>数量小于等于1，该过滤条件直接返回true。</li><li>通过<code>ZoneAvoidanceRule.createSnapshot</code>函数拿到<code>Zone</code>映射，如果该映射里不包含该实例的<code>Zone</code>，该过滤条件直接返回true。</li><li>否则通过<code>ZoneAvoidanceRule.getAvailableZones</code>拿到可用<code>Zone</code>列表，如果列表不为空，返回是否包含该实例的<code>Zone</code>结果；如果为空，直接返回false。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是关于Spring Cloud Ribbon 负载均衡策略的全部内容，通过了解Ribbon的负载均衡策略，可以使我们更好的了解到Ribbon的一些特性，对Ribbon有更深入的了解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="SpringCloud" scheme="https://www.sakuratears.top/tags/SpringCloud/"/>
    
      <category term="Ribbon" scheme="https://www.sakuratears.top/tags/Ribbon/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud Ribbon 负载均衡器</title>
    <link href="https://www.sakuratears.top/blog/SpringCloud-Ribbon-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8.html"/>
    <id>https://www.sakuratears.top/blog/SpringCloud-Ribbon-负载均衡器.html</id>
    <published>2020-10-11T05:50:00.000Z</published>
    <updated>2020-10-18T13:28:26.265Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上篇文章我们介绍了Spring Cloud Ribbon中实现客户端负载均衡的一些基本脉络，了解了它的一些特点。</p><p>虽然Spring Cloud 中定义了 <code>LoadBalancerClient</code>作为负载均衡器的通用接口，并且针对Ribbon实现了<code>RibbonLoadBalancerClient</code>，但是它在具体实现客户端负载均衡时，是通过Ribbon的<code>ILoadBalancer</code>接口实现的。</p><p>我们这篇文章来看下<code>ILoadBalancer</code>接口的实现类，来了解它是如何实现客户端负载均衡的。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="AbstractLoadBalancer"><a href="#AbstractLoadBalancer" class="headerlink" title="AbstractLoadBalancer"></a>AbstractLoadBalancer</h2><p><code>AbstractLoadBalancer</code>是<code>ILoadBalancer</code>接口的抽象实现。该类中定义了一个关于服务实例的分组枚举类<code>ServerGroup</code>，包含三种不同的类型。</p><ul><li>ALL：所有服务实例。</li><li>STATUS_UP：正常服务的实例。</li><li>STATUS_NOT_UP：停止服务的实例。</li></ul><p>另外还实现一个<code>chooseServer()</code>函数，该函数通过调用接口的<code>chooseServer(Object key)</code>实现，其中参数<code>key</code>为<code>null</code>，表示在选择具体服务实例时忽略<code>key</code>的条件判断。</p><p>还定义了两个抽象函数：</p><ul><li>getServerList(ServerGroup serverGroup)：根据分组类型来获取不同的服务列表。</li><li>getLoadBalancerStats()：定义获取<code>LoadBalancerStats</code>对象的方法。</li></ul><p>PS：<code>LoadBalancerStats</code>对象用来存储负载均衡器中各个服务实例当前的属性和统计信息。这些信息可以帮助我们观察负载均衡器的运行情况，制定合适的负载均衡策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractLoadBalancer</span> <span class="keyword">implements</span> <span class="title">ILoadBalancer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> ServerGroup&#123;</span><br><span class="line">        ALL,</span><br><span class="line">        STATUS_UP,</span><br><span class="line">        STATUS_NOT_UP        </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Server <span class="title">chooseServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> chooseServer(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;Server&gt; <span class="title">getServerList</span><span class="params">(ServerGroup serverGroup)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> LoadBalancerStats <span class="title">getLoadBalancerStats</span><span class="params">()</span></span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BaseLoadBalancer"><a href="#BaseLoadBalancer" class="headerlink" title="BaseLoadBalancer"></a>BaseLoadBalancer</h2><p><code>BaseLoadBalancer</code>类是Ribbon负载均衡器的基础实现类，该类中定义了很多有关负载均衡器的基础内容。</p><ul><li><p>定义维护了两个存储服务实例Server对象列表。一个用于存储所有服务实例的清单，一个用于存储正常服务的清单。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Monitor</span>(name = PREFIX + <span class="string">"AllServerList"</span>, type = DataSourceType.INFORMATIONAL)</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> List&lt;Server&gt; allServerList = Collections</span><br><span class="line">        .synchronizedList(<span class="keyword">new</span> ArrayList&lt;Server&gt;());</span><br><span class="line"><span class="meta">@Monitor</span>(name = PREFIX + <span class="string">"UpServerList"</span>, type = DataSourceType.INFORMATIONAL)</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> List&lt;Server&gt; upServerList = Collections</span><br><span class="line">        .synchronizedList(<span class="keyword">new</span> ArrayList&lt;Server&gt;());</span><br></pre></td></tr></table></figure></li><li><p>定义了用来存储负载均衡服务器各服务实例属性和统计信息的<code>LoadBalancerStats</code>对象。</p></li><li>定义了检查服务实例是否正常的<code>IPing</code>对象，在<code>BaseLoadBalancer</code>中默认为<code>null</code>，需要在构造时注入它的具体实现。</li><li><p>定义了检查服务实例操作的执行策略对象<code>IPingStrategy</code>，在<code>BaseLoadBalancer</code>中默认使用了该类中定义的静态内部类<code>SerialPingStrategy</code>实现。</p><p>  根据源码，我们可以看到该策略采用线性遍历ping服务实例的方式实现检查。该策略在当<code>IPing</code>的实现速度并不理想，或者<code>Server</code>列表过大时，可能会影响系统性能，这时候需要通过实现<code>IPingStrategy</code>接口并重写<code>pingServers(IPing ping, Server[] servers)</code>函数去扩展ping的执行策略。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialPingStrategy</span> <span class="keyword">implements</span> <span class="title">IPingStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span>[] pingServers(IPing ping, Server[] servers) &#123;</span><br><span class="line">        <span class="keyword">int</span> numCandidates = servers.length;</span><br><span class="line">        <span class="keyword">boolean</span>[] results = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCandidates];</span><br><span class="line"></span><br><span class="line">        logger.debug(<span class="string">"LoadBalancer:  PingTask executing [&#123;&#125;] servers configured"</span>, numCandidates);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCandidates; i++) &#123;</span><br><span class="line">            results[i] = <span class="keyword">false</span>; <span class="comment">/* Default answer is DEAD. */</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (ping != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    results[i] = ping.isAlive(servers[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(<span class="string">"Exception while pinging Server: '&#123;&#125;'"</span>, servers[i], e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  比如我们想改成并行处理，则需要写自己的并行ping策略，如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParallelPingStrategy</span> <span class="keyword">implements</span> <span class="title">IPingStrategy</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory</span><br><span class="line">        .getLogger(ParallelPingStrategy.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span>[] pingServers(IPing ping, Server[] servers) &#123;</span><br><span class="line">        <span class="keyword">int</span> numCandidates = servers.length;</span><br><span class="line">        <span class="keyword">boolean</span>[] results = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCandidates];</span><br><span class="line"></span><br><span class="line">        logger.debug(<span class="string">"LoadBalancer:  PingTask executing [&#123;&#125;] servers configured"</span>, numCandidates);</span><br><span class="line"></span><br><span class="line">        List&lt;Future&lt;Boolean&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        ExecutorService ex = Executors.newFixedThreadPool(numCandidates+<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Server server : servers) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ping !=<span class="keyword">null</span>)&#123;</span><br><span class="line">                futures.add(ex.submit(()-&gt;ping.isAlive(server)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCandidates; i++) &#123;</span><br><span class="line">            results[i] = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(!futures.isEmpty())&#123;</span><br><span class="line">                    results[i] = futures.get(i).get();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                logger.error(<span class="string">"Exception while pinging Server: '&#123;&#125;'"</span>, servers[i], e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  然后添加到配置即可。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomLoadBalancer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">ILoadBalancer <span class="title">loadBalancer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BaseLoadBalancer(<span class="keyword">new</span> NIWSDiscoveryPing(),<span class="keyword">new</span> RandomRule(),<span class="keyword">new</span> ParallelPingStrategy());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@RibbonClient</span>(name = <span class="string">"sakura"</span>,configuration = CustomLoadBalancer.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SakuraConsumerApplication</span> </span>&#123;</span><br><span class="line">    <span class="comment">//.....略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义了负载均衡的处理规则<code>IRule</code>对象，从<code>BaseLoadBalancer</code>中的<code>chooseServer(Object key)</code>源码，我们可以知道，负载均衡器实际将服务实例选择任务委托给了<code>IRule</code>实例中的<code>choose</code>函数来实现，而这里默认初始化了<code>RoundRobinRule</code>作为<code>IRule</code>的实现对象。<code>RoundRobinRule</code>实现的是最基本的线性负载均衡规则。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">chooseServer</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (counter == <span class="keyword">null</span>) &#123;</span><br><span class="line">        counter = createCounter();</span><br><span class="line">    &#125;</span><br><span class="line">    counter.increment();</span><br><span class="line">    <span class="keyword">if</span> (rule == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> rule.choose(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.warn(<span class="string">"LoadBalancer [&#123;&#125;]:  Error choosing server for key &#123;&#125;"</span>, name, key, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动ping任务：在<code>BaseLoadBalancer</code>的默认构造函数中，会直接启动一个用于定时检查Server是否健康的任务。该任务默认的执行间隔时间为10s。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BaseLoadBalancer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = DEFAULT_NAME;</span><br><span class="line">    <span class="keyword">this</span>.ping = <span class="keyword">null</span>;</span><br><span class="line">    setRule(DEFAULT_RULE);</span><br><span class="line">    setupPingTask();</span><br><span class="line">    lbStats = <span class="keyword">new</span> LoadBalancerStats(DEFAULT_NAME);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setupPingTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (canSkipPing()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lbTimer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        lbTimer.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    lbTimer = <span class="keyword">new</span> ShutdownEnabledTimer(<span class="string">"NFLoadBalancer-PingTimer-"</span> + name,</span><br><span class="line">            <span class="keyword">true</span>);</span><br><span class="line">    lbTimer.schedule(<span class="keyword">new</span> PingTask(), <span class="number">0</span>, pingIntervalSeconds * <span class="number">1000</span>);</span><br><span class="line">    forceQuickPing();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现了<code>ILoadBalancer</code>接口定义的负载均衡器应具备以下一系列基本操作。</p><ul><li><p>addServers(List<server> newServers)：向负载均衡器中添加新的服务实例列表。</server></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addServers</span><span class="params">(List&lt;Server&gt; newServers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (newServers != <span class="keyword">null</span> &amp;&amp; newServers.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ArrayList&lt;Server&gt; newList = <span class="keyword">new</span> ArrayList&lt;Server&gt;();</span><br><span class="line">            newList.addAll(allServerList);</span><br><span class="line">            newList.addAll(newServers);</span><br><span class="line">            setServersList(newList);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">"LoadBalancer [&#123;&#125;]: Exception while adding Servers"</span>, name, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>chooseServer(Object key)：挑选一个具体服务实例。代码见上面。</p></li><li><p>markServerDown(Server server)：标记某个服务实例暂停服务。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">markServerDown</span><span class="params">(Server server)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (server == <span class="keyword">null</span> || !server.isAlive()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logger.error(<span class="string">"LoadBalancer [&#123;&#125;]:  markServerDown called on [&#123;&#125;]"</span>, name, server.getId());</span><br><span class="line">    server.setAlive(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// forceQuickPing();</span></span><br><span class="line"></span><br><span class="line">    notifyServerStatusChangeListener(singleton(server));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>getReachableServers()：获取可用的服务实例列表。由于<code>BaseLoadBalancer</code>中单独维护了一个正常服务的实例清单，所以直接返回即可。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Server&gt; <span class="title">getReachableServers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableList(upServerList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>getAllServers()：获取所有的服务实例列表。同样由于<code>BaseLoadBalancer</code>中单独维护了一个所有服务的实例清单，所以直接返回即可。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Server&gt; <span class="title">getAllServers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableList(allServerList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="DynamicServerListLoadBalancer"><a href="#DynamicServerListLoadBalancer" class="headerlink" title="DynamicServerListLoadBalancer"></a>DynamicServerListLoadBalancer</h2><p><code>DynamicServerListLoadBalancer</code>类继承于<code>BaseLoadBalancer</code>类，它是对基础负载均衡器的扩展。在该负载均衡器中，实现了服务实例清单在运行期的动态更新能力；同时它还具备了对服务实例清单的过滤功能。</p><p>我们来看下相比<code>BaseLoadBalancer</code>，该类新增了哪些内容。</p><ul><li><p>ServerList</p><p>  在类成员定义中，我们可以发现新增了一个关于服务列表的操作对象<code>ServerList<t> serverListImpl</t></code>，泛型 T 根据<code>DynamicServerListLoadBalancer<t extends="" server=""></t></code>可知它是一个<code>Server</code>的子类。</p><p>  <code>ServerList</code>接口定义如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServerList</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Server</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getInitialListOfServers</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getUpdatedListOfServers</span><span class="params">()</span></span>;   </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>getInitialListOfServers()：获取初始化的服务实例清单。</li><li><p>getUpdatedListOfServers()：获取更新的服务实例清单。</p><p><code>DynamicServerListLoadBalancer</code>里默认是使用哪个<code>ServerList</code>的实现类呢？</p><p>在<code>EurekaRibbonClientConfiguration</code>类中，我们可以找到如下创建<code>ServerList</code>实例的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="keyword">public</span> ServerList&lt;?&gt; ribbonServerList(IClientConfig config, Provider&lt;EurekaClient&gt; eurekaClientProvider) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(ServerList.class, serviceId)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(ServerList.class, config, serviceId);</span><br><span class="line">&#125;</span><br><span class="line">DiscoveryEnabledNIWSServerList discoveryServerList = <span class="keyword">new</span> DiscoveryEnabledNIWSServerList(</span><br><span class="line">config, eurekaClientProvider);</span><br><span class="line">DomainExtractingServerList serverList = <span class="keyword">new</span> DomainExtractingServerList(</span><br><span class="line">discoveryServerList, config, <span class="keyword">this</span>.approximateZoneFromHostname);</span><br><span class="line"><span class="keyword">return</span> serverList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们看到它构造函数传入了<code>DiscoveryEnabledNIWSServerList</code>，我们来看下代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DomainExtractingServerList</span> <span class="keyword">implements</span> <span class="title">ServerList</span>&lt;<span class="title">DiscoveryEnabledServer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServerList&lt;DiscoveryEnabledServer&gt; list;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RibbonProperties ribbon;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> approximateZoneFromHostname;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DomainExtractingServerList</span><span class="params">(ServerList&lt;DiscoveryEnabledServer&gt; list,</span></span></span><br><span class="line"><span class="function"><span class="params">            IClientConfig clientConfig, <span class="keyword">boolean</span> approximateZoneFromHostname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">        <span class="keyword">this</span>.ribbon = RibbonProperties.from(clientConfig);</span><br><span class="line">        <span class="keyword">this</span>.approximateZoneFromHostname = approximateZoneFromHostname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;DiscoveryEnabledServer&gt; <span class="title">getInitialListOfServers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;DiscoveryEnabledServer&gt; servers = setZones(<span class="keyword">this</span>.list</span><br><span class="line">                .getInitialListOfServers());</span><br><span class="line">        <span class="keyword">return</span> servers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;DiscoveryEnabledServer&gt; <span class="title">getUpdatedListOfServers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;DiscoveryEnabledServer&gt; servers = setZones(<span class="keyword">this</span>.list</span><br><span class="line">                .getUpdatedListOfServers());</span><br><span class="line">        <span class="keyword">return</span> servers;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到调用了<code>DiscoveryEnabledNIWSServerList</code>的<code>getInitialListOfServers()</code>方法和<code>getUpdatedListOfServers()</code>方法。这两个方法通过<code>EurekaClient</code>从服务中心中获取到具体的服务实例列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;DiscoveryEnabledServer&gt; <span class="title">getInitialListOfServers</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obtainServersViaDiscovery();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;DiscoveryEnabledServer&gt; <span class="title">getUpdatedListOfServers</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obtainServersViaDiscovery();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;DiscoveryEnabledServer&gt; <span class="title">obtainServersViaDiscovery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;DiscoveryEnabledServer&gt; serverList = <span class="keyword">new</span> ArrayList&lt;DiscoveryEnabledServer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eurekaClientProvider == <span class="keyword">null</span> || eurekaClientProvider.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        logger.warn(<span class="string">"EurekaClient has not been initialized yet, returning an empty list"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;DiscoveryEnabledServer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EurekaClient eurekaClient = eurekaClientProvider.get();</span><br><span class="line">    <span class="keyword">if</span> (vipAddresses!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (String vipAddress : vipAddresses.split(<span class="string">","</span>)) &#123;</span><br><span class="line">            <span class="comment">// if targetRegion is null, it will be interpreted as the same region of client</span></span><br><span class="line">            List&lt;InstanceInfo&gt; listOfInstanceInfo = eurekaClient.getInstancesByVipAddress(vipAddress, isSecure, targetRegion);</span><br><span class="line">            <span class="keyword">for</span> (InstanceInfo ii : listOfInstanceInfo) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ii.getStatus().equals(InstanceStatus.UP)) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(shouldUseOverridePort)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(logger.isDebugEnabled())&#123;</span><br><span class="line">                            logger.debug(<span class="string">"Overriding port on client name: "</span> + clientName + <span class="string">" to "</span> + overridePort);</span><br><span class="line">                        &#125;</span><br><span class="line">                        InstanceInfo copy = <span class="keyword">new</span> InstanceInfo(ii);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span>(isSecure)&#123;</span><br><span class="line">                            ii = <span class="keyword">new</span> InstanceInfo.Builder(copy).setSecurePort(overridePort).build();</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            ii = <span class="keyword">new</span> InstanceInfo.Builder(copy).setPort(overridePort).build();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    DiscoveryEnabledServer des = createServer(ii, isSecure, shouldUseIpAddr);</span><br><span class="line">                    serverList.add(des);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (serverList.size()&gt;<span class="number">0</span> &amp;&amp; prioritizeVipAddressBasedServers)&#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// if the current vipAddress has servers, we dont use subsequent vipAddress based servers</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> serverList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>ServerListUpdater</p><p>  通过上面内容，我们已经知道Ribbon可以从Eureka Server中获取服务实例清单。那么它又是如何触发向Eureka Server去获取服务清单以及如何在获取到服务实例清单后更新本地的服务实例清单的呢？</p><p>  这就要涉及到<code>ServerListUpdater</code>的内容了，我们来看一下。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> ServerListUpdater.UpdateAction updateAction = <span class="keyword">new</span> ServerListUpdater.UpdateAction() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        updateListOfServers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  我们来看下<code>ServerListUpdater</code>接口内容。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServerListUpdater</span> </span>&#123;</span><br><span class="line">    <span class="comment">//服务更新接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UpdateAction</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">doUpdate</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动服务更新</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(UpdateAction updateAction)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//停止服务更新器</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取最近的更新时间戳</span></span><br><span class="line">    <span class="function">String <span class="title">getLastUpdate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取上一次更新到现在的时间间隔，单位毫秒</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getDurationSinceLastUpdateMs</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取错过的更新周期数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumberMissedCycles</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取核心线程数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCoreThreads</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <code>ServerListUpdater</code>的实现类有两个，如下：</p><ul><li><p>PollingServerListUpdater：动态服务列表更新的默认策略，使用的是定时任务的方式进行服务列表的更新。</p></li><li><p>EurekaNotificationServerListUpdater：利用Eureka事件监听器来驱动服务列表的更新操作。</p></li></ul></li><li><p>ServerListFilter</p><p>  我们回到<code>UpdateAction</code>，看一下<code>doUpdate</code>的具体调用方法，可以看到它调用了<code>updateListOfServers</code>方法。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateListOfServers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;T&gt; servers = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">    <span class="keyword">if</span> (serverListImpl != <span class="keyword">null</span>) &#123;</span><br><span class="line">        servers = serverListImpl.getUpdatedListOfServers();</span><br><span class="line">        LOGGER.debug(<span class="string">"List of Servers for &#123;&#125; obtained from Discovery client: &#123;&#125;"</span>,</span><br><span class="line">                getIdentifier(), servers);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (filter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            servers = filter.getFilteredListOfServers(servers);</span><br><span class="line">            LOGGER.debug(<span class="string">"Filtered List of Servers for &#123;&#125; obtained from Discovery client: &#123;&#125;"</span>,</span><br><span class="line">                    getIdentifier(), servers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    updateAllServerList(servers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  可以看到用到了前面ServerList的<code>getUpdatedListOfServers</code>方法。用于从Eureka Server中获取服务可用实例列表。</p><p>  同时引入了一个新对象 filter，它是通过<code>ServerListFilter</code>进行定义的。</p><p>  <code>ServerListFilter</code>接口只定义了一个方法，<code>getFilteredListOfServers(List<t> servers)</t></code>，用于实现对服务实例列表按照过滤规则进行过滤。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServerListFilter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Server</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getFilteredListOfServers</span><span class="params">(List&lt;T&gt; servers)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  它有四个具体实现及一个抽象实现。</p><ul><li><p>AbstractServerListFilter</p><p>  抽象过滤器，这里定一个一个重要依据对象<code>LoadBalancerStats</code>，用来存储关于负载均衡器的一些属性和统计信息。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractServerListFilter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Server</span>&gt; <span class="keyword">implements</span> <span class="title">ServerListFilter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> LoadBalancerStats stats;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLoadBalancerStats</span><span class="params">(LoadBalancerStats stats)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stats = stats;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> LoadBalancerStats <span class="title">getLoadBalancerStats</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stats;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ZoneAffinityServerListFilter  </p><p>  区域感知过滤器，该过滤器会基于“区域感知”方式实现服务过滤。也就是说它会根据提供服务的实例所处的区域（Zone）与消费者自身所处区域（Zone）进行比较，过滤掉不是同处于一个区域的实例。关键代码：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getFilteredListOfServers</span><span class="params">(List&lt;T&gt; servers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (zone != <span class="keyword">null</span> &amp;&amp; (zoneAffinity || zoneExclusive) &amp;&amp; servers !=<span class="keyword">null</span> &amp;&amp; servers.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        List&lt;T&gt; filteredServers = Lists.newArrayList(Iterables.filter(</span><br><span class="line">                servers, <span class="keyword">this</span>.zoneAffinityPredicate.getServerOnlyPredicate()));</span><br><span class="line">        <span class="keyword">if</span> (shouldEnableZoneAffinity(filteredServers)) &#123;</span><br><span class="line">            <span class="keyword">return</span> filteredServers;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (zoneAffinity) &#123;</span><br><span class="line">            overrideCounter.increment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> servers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>DefaultNIWSServerListFilter</p><p>  该过滤器完全继承自 <code>ZoneAffinityServerListFilter</code>，是默认的NIWS（Netflix Internal Web Service）过滤器。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultNIWSServerListFilter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Server</span>&gt; <span class="keyword">extends</span> <span class="title">ZoneAffinityServerListFilter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ServerListSubsetFilter</p><p>  该过滤器也继承自<code>ZoneAffinityServerListFilter</code>，它非常适合用于拥有大规模服务器集群的系统。因为它可以产生一个“区域感知”结果的子集列表，同时它还能够通过比较服务实例的通信失败数量和并发连接数来判定该服务是否健康来选择性地从服务实例列表中剔除那些相对不够健康的实例。该过滤器实现主要有3步。</p><ol><li>获取“区域感知”的过滤结果，作为候选的服务实例清单。</li><li><p>从当前消费者维护的服务实例子集中剔除那些相对不够健康的实例（同时也将这些实例从候选清单中剔除，防止第三步的时候又被选入），不够健康的标准如下。</p><p> a. 服务实例的并发连接数超过客户端配置的值，默认0，配置参数为<clientname>.<namespace>.ServerListSubsetFilter.eliminationConnectionThresold。</namespace></clientname></p><p> b. 服务实例的失败数超过客户端配置的值，默认0，配置参数为<clientname>.<namespace>.ServerListSubsetFilter.eliminationFailureThresold。</namespace></clientname></p><p> c. 如果按符合上面任一规则的服务实例剔除后，剔除比例小于客户端默认配置的百分比，默认为0.1（10%），配置参数为<clientname>.<namespace>.ServerListSubsetFilter.forceEliminationPercent，那么就先对剩下的实例列表进行健康排序，再从最不健康的实例进行剔除，直到达到配置剔除的百分比。</namespace></clientname></p></li><li><p>在完成剔除后，清单至少已经少了10%（默认值）的服务实例，最后通过随机的方式从候选清单中选出一批实例加入到清单中，以保持服务实例子集与原来的数量一致，默认实例子集数量为20，配置参数<clientname>.<namespace>.ServerListSubsetFilter.size。</namespace></clientname></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getFilteredListOfServers</span><span class="params">(List&lt;T&gt; servers)</span> </span>&#123;</span><br><span class="line">    List&lt;T&gt; zoneAffinityFiltered = <span class="keyword">super</span>.getFilteredListOfServers(servers);</span><br><span class="line">    Set&lt;T&gt; candidates = Sets.newHashSet(zoneAffinityFiltered);</span><br><span class="line">    Set&lt;T&gt; newSubSet = Sets.newHashSet(currentSubset);</span><br><span class="line">    LoadBalancerStats lbStats = getLoadBalancerStats();</span><br><span class="line">    <span class="keyword">for</span> (T server: currentSubset) &#123;</span><br><span class="line">        <span class="comment">// this server is either down or out of service</span></span><br><span class="line">        <span class="keyword">if</span> (!candidates.contains(server)) &#123;</span><br><span class="line">            newSubSet.remove(server);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ServerStats stats = lbStats.getSingleServerStat(server);</span><br><span class="line">            <span class="comment">// remove the servers that do not meet health criteria</span></span><br><span class="line">            <span class="keyword">if</span> (stats.getActiveRequestsCount() &gt; eliminationConnectionCountThreshold.get()</span><br><span class="line">                    || stats.getFailureCount() &gt; eliminationFailureCountThreshold.get()) &#123;</span><br><span class="line">                newSubSet.remove(server);</span><br><span class="line">                <span class="comment">// also remove from the general pool to avoid selecting them again</span></span><br><span class="line">                candidates.remove(server);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> targetedListSize = sizeProp.get();</span><br><span class="line">    <span class="keyword">int</span> numEliminated = currentSubset.size() - newSubSet.size();</span><br><span class="line">    <span class="keyword">int</span> minElimination = (<span class="keyword">int</span>) (targetedListSize * eliminationPercent.get());</span><br><span class="line">    <span class="keyword">int</span> numToForceEliminate = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (targetedListSize &lt; newSubSet.size()) &#123;</span><br><span class="line">        <span class="comment">// size is shrinking</span></span><br><span class="line">        numToForceEliminate = newSubSet.size() - targetedListSize;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (minElimination &gt; numEliminated) &#123;</span><br><span class="line">        numToForceEliminate = minElimination - numEliminated; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (numToForceEliminate &gt; newSubSet.size()) &#123;</span><br><span class="line">        numToForceEliminate = newSubSet.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (numToForceEliminate &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        List&lt;T&gt; sortedSubSet = Lists.newArrayList(newSubSet);           </span><br><span class="line">        Collections.sort(sortedSubSet, <span class="keyword">this</span>);</span><br><span class="line">        List&lt;T&gt; forceEliminated = sortedSubSet.subList(<span class="number">0</span>, numToForceEliminate);</span><br><span class="line">        newSubSet.removeAll(forceEliminated);</span><br><span class="line">        candidates.removeAll(forceEliminated);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// after forced elimination or elimination of unhealthy instances,</span></span><br><span class="line">    <span class="comment">// the size of the set may be less than the targeted size,</span></span><br><span class="line">    <span class="comment">// then we just randomly add servers from the big pool</span></span><br><span class="line">    <span class="keyword">if</span> (newSubSet.size() &lt; targetedListSize) &#123;</span><br><span class="line">        <span class="keyword">int</span> numToChoose = targetedListSize - newSubSet.size();</span><br><span class="line">        candidates.removeAll(newSubSet);</span><br><span class="line">        <span class="keyword">if</span> (numToChoose &gt; candidates.size()) &#123;</span><br><span class="line">            <span class="comment">// Not enough healthy instances to choose, fallback to use the</span></span><br><span class="line">            <span class="comment">// total server pool</span></span><br><span class="line">            candidates = Sets.newHashSet(zoneAffinityFiltered);</span><br><span class="line">            candidates.removeAll(newSubSet);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;T&gt; chosen = randomChoose(Lists.newArrayList(candidates), numToChoose);</span><br><span class="line">        <span class="keyword">for</span> (T server: chosen) &#123;</span><br><span class="line">            newSubSet.add(server);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    currentSubset = newSubSet;       </span><br><span class="line">    <span class="keyword">return</span> Lists.newArrayList(newSubSet);            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>ZonePreferenceServerListFilter</p><p>  Spring Cloud整合是新增的过滤器。若使用Spring Cloud整合Eureka 和 Ribbon时会默认使用该过滤器。它实现通过配置或者Eureka实例元数据的所属区域（Zone）来过滤出同区域的服务实例。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Server&gt; <span class="title">getFilteredListOfServers</span><span class="params">(List&lt;Server&gt; servers)</span> </span>&#123;</span><br><span class="line">    List&lt;Server&gt; output = <span class="keyword">super</span>.getFilteredListOfServers(servers);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.zone != <span class="keyword">null</span> &amp;&amp; output.size() == servers.size()) &#123;</span><br><span class="line">        List&lt;Server&gt; local = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Server server : output) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.zone.equalsIgnoreCase(server.getZone())) &#123;</span><br><span class="line">                local.add(server);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!local.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> local;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="ZoneAwareLoadBalancer"><a href="#ZoneAwareLoadBalancer" class="headerlink" title="ZoneAwareLoadBalancer"></a>ZoneAwareLoadBalancer</h2><p><code>ZoneAwareLoadBalancer</code>负载均衡器是对<code>DynamicServerListLoadBalancer</code>的扩展。在<code>DynamicServerListLoadBalancer</code>中，并没有重写选择具体服务实例的<code>chooseServer</code>函数，所以它依然会采用<code>BaseLoadBalancer</code>中实现的算法。使用<code>RoundRobinRule</code>规则，以线性轮询的方式来选择调用的服务实例，该算法并没有区域（Zone）的概念。这样就会周期性的产生跨区域访问情况，由于跨区域有更高的延迟，这些区域实例主要以防止区域性故障来实现高可用的目的，而不能作为常规的访问性实例，所以在多区域部署的情况下会有一定的问题。</p><p>而<code>ZoneAwareLoadBalancer</code>则可以避免这样的问题，我们来看下它是如何实现的。</p><p>我们可以看到它并没有重写<code>setServersList</code>，而是重写了<code>setServerListForZones</code>，我们先来看下<code>DynamicServerListLoadBalancer</code>的部分代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setServersList</span><span class="params">(List lsrv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.setServersList(lsrv);</span><br><span class="line">    List&lt;T&gt; serverList = (List&lt;T&gt;) lsrv;</span><br><span class="line">    Map&lt;String, List&lt;Server&gt;&gt; serversInZones = <span class="keyword">new</span> HashMap&lt;String, List&lt;Server&gt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Server server : serverList) &#123;</span><br><span class="line">        <span class="comment">// make sure ServerStats is created to avoid creating them on hot</span></span><br><span class="line">        <span class="comment">// path</span></span><br><span class="line">        getLoadBalancerStats().getSingleServerStat(server);</span><br><span class="line">        String zone = server.getZone();</span><br><span class="line">        <span class="keyword">if</span> (zone != <span class="keyword">null</span>) &#123;</span><br><span class="line">            zone = zone.toLowerCase();</span><br><span class="line">            List&lt;Server&gt; servers = serversInZones.get(zone);</span><br><span class="line">            <span class="keyword">if</span> (servers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                servers = <span class="keyword">new</span> ArrayList&lt;Server&gt;();</span><br><span class="line">                serversInZones.put(zone, servers);</span><br><span class="line">            &#125;</span><br><span class="line">            servers.add(server);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    setServerListForZones(serversInZones);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setServerListForZones</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Map&lt;String, List&lt;Server&gt;&gt; zoneServersMap)</span> </span>&#123;</span><br><span class="line">    LOGGER.debug(<span class="string">"Setting server list for zones: &#123;&#125;"</span>, zoneServersMap);</span><br><span class="line">    getLoadBalancerStats().updateZoneServerMapping(zoneServersMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>setServersList</code>在最后调用了<code>setServerListForZones</code>方法，而<code>ZoneAwareLoadBalancer</code>重写了<code>setServerListForZones</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setServerListForZones</span><span class="params">(Map&lt;String, List&lt;Server&gt;&gt; zoneServersMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.setServerListForZones(zoneServersMap);</span><br><span class="line">    <span class="keyword">if</span> (balancers == <span class="keyword">null</span>) &#123;</span><br><span class="line">        balancers = <span class="keyword">new</span> ConcurrentHashMap&lt;String, BaseLoadBalancer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;Server&gt;&gt; entry: zoneServersMap.entrySet()) &#123;</span><br><span class="line">        String zone = entry.getKey().toLowerCase();</span><br><span class="line">        getLoadBalancer(zone).setServersList(entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// check if there is any zone that no longer has a server</span></span><br><span class="line">    <span class="comment">// and set the list to empty so that the zone related metrics does not</span></span><br><span class="line">    <span class="comment">// contain stale data</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, BaseLoadBalancer&gt; existingLBEntry: balancers.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!zoneServersMap.keySet().contains(existingLBEntry.getKey())) &#123;</span><br><span class="line">            existingLBEntry.getValue().setServersList(Collections.emptyList());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到它创建了一个名为<code>balancers</code>的<code>ConcurrentHashMap</code>，用来存储每个Zone区域对应的负载均衡器。</p><p>再来看下它的<code>chooseServer</code>方法，看它如何挑选实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">chooseServer</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!ENABLED.get() || getLoadBalancerStats().getAvailableZones().size() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Zone aware logic disabled or there is only one zone"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.chooseServer(key);</span><br><span class="line">    &#125;</span><br><span class="line">    Server server = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        LoadBalancerStats lbStats = getLoadBalancerStats();</span><br><span class="line">        Map&lt;String, ZoneSnapshot&gt; zoneSnapshot = ZoneAvoidanceRule.createSnapshot(lbStats);</span><br><span class="line">        logger.debug(<span class="string">"Zone snapshots: &#123;&#125;"</span>, zoneSnapshot);</span><br><span class="line">        <span class="keyword">if</span> (triggeringLoad == <span class="keyword">null</span>) &#123;</span><br><span class="line">            triggeringLoad = DynamicPropertyFactory.getInstance().getDoubleProperty(</span><br><span class="line">                    <span class="string">"ZoneAwareNIWSDiscoveryLoadBalancer."</span> + <span class="keyword">this</span>.getName() + <span class="string">".triggeringLoadPerServerThreshold"</span>, <span class="number">0.2</span>d);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (triggeringBlackoutPercentage == <span class="keyword">null</span>) &#123;</span><br><span class="line">            triggeringBlackoutPercentage = DynamicPropertyFactory.getInstance().getDoubleProperty(</span><br><span class="line">                    <span class="string">"ZoneAwareNIWSDiscoveryLoadBalancer."</span> + <span class="keyword">this</span>.getName() + <span class="string">".avoidZoneWithBlackoutPercetage"</span>, <span class="number">0.99999</span>d);</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;String&gt; availableZones = ZoneAvoidanceRule.getAvailableZones(zoneSnapshot, triggeringLoad.get(), triggeringBlackoutPercentage.get());</span><br><span class="line">        logger.debug(<span class="string">"Available zones: &#123;&#125;"</span>, availableZones);</span><br><span class="line">        <span class="keyword">if</span> (availableZones != <span class="keyword">null</span> &amp;&amp;  availableZones.size() &lt; zoneSnapshot.keySet().size()) &#123;</span><br><span class="line">            String zone = ZoneAvoidanceRule.randomChooseZone(zoneSnapshot, availableZones);</span><br><span class="line">            logger.debug(<span class="string">"Zone chosen: &#123;&#125;"</span>, zone);</span><br><span class="line">            <span class="keyword">if</span> (zone != <span class="keyword">null</span>) &#123;</span><br><span class="line">                BaseLoadBalancer zoneLoadBalancer = getLoadBalancer(zone);</span><br><span class="line">                server = zoneLoadBalancer.chooseServer(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(<span class="string">"Error choosing server using zone aware logic for load balancer=&#123;&#125;"</span>, name, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (server != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> server;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.debug(<span class="string">"Zone avoidance logic is not invoked."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.chooseServer(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由源码可知，只有当负载均衡器中维护的实例所属的Zone区域个数大于1的时候才会执行选择策略。可以看到当区域个数大于1时，使用的规则为<code>ZoneAvoidanceRule</code>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过本篇文章，我们大致了解了几种Ribbon客户端负载均衡器的一些特点。后面我们将对负载均衡的一些策略做相关整理及梳理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="SpringCloud" scheme="https://www.sakuratears.top/tags/SpringCloud/"/>
    
      <category term="Ribbon" scheme="https://www.sakuratears.top/tags/Ribbon/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud客户端负载均衡Ribbon</title>
    <link href="https://www.sakuratears.top/blog/SpringCloud%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1Ribbon.html"/>
    <id>https://www.sakuratears.top/blog/SpringCloud客户端负载均衡Ribbon.html</id>
    <published>2020-10-11T04:49:00.000Z</published>
    <updated>2020-10-11T05:00:23.427Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Spring Cloud Ribbon是一个基于HTTP和TCP的客户端负载均衡工具，它基于Netflix Ribbon实现。通过Spring Cloud的封装，可以让我们轻松地将面向服务的REST模版请求自动转换成客户端负载均衡的服务调用。</p><p>这篇文章我们来看下如何使用Ribbon来实现客户端负载均衡，以及Ribbon实现负载均衡的原理。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="客户端负载均衡"><a href="#客户端负载均衡" class="headerlink" title="客户端负载均衡"></a>客户端负载均衡</h2><p>负载均衡在系统架构中非常重要，是系统实现高可用、网络压力缓解、处理能力扩容的重要手段之一。一般情况下，我们所说的负载均衡大都指的服务端的负载均衡，通常分为硬件负载均衡和软件负载均衡。</p><p>硬件负载均衡，主要通过在服务器节点之间安装专门用于负载均衡的设备来实现，如F5。</p><p>软件负载均衡，主要通过在服务器上安装一些具有负载均衡的模块或者软件来实现，如Nginx。</p><p>负载均衡设备或者软件都会维护一个下挂可用的服务端清单，通过心跳检测来剔除故障的服务节点以保证清单中都是可以正常访问的服务节点。客户端发送请求到负载均衡设备，设备按照某种算法（轮询、权重等）从清单里取出一台服务地址，进行转发。</p><p>客户端负载均衡和上面说的服务端负载均衡最大的不同点在于上面提到的服务清单所存储的位置。在客户端负载均衡中，所有客户端都需要维护自己要访问的服务器清单，这些服务端清单来自注册中心。当然，客户端负载均衡也要通过心跳检测服务的健康性，这个步骤需要注册中心配合完成。</p><h2 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h2><p>在之前<a href="https://www.sakuratears.top/blog/Eureka%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.html">Eureka的例子</a>中，我们引入了Ribbon实现负载均衡功能，同时知道了通过给<code>RestTemplate</code>对象配置<code>@LoadBalanced</code>注解便可以开启客户端负载均衡。</p><p>在了解Ribbon之前，我们先聊聊<code>RestTemplate</code>。</p><p>我们可以看到<code>RestTemplate</code>是属于spring web模块的一个类，顾名思义，它是spring用来发送REST请求的封装模板。</p><p>对于GET请求，可以看到主要有两种类型的函数方法。</p><p>第一种，<code>getForEntity</code>函数。返回<code>ResponseEntity</code>对象。它有三个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">ResponseEntity&lt;T&gt; <span class="title">getForEntity</span><span class="params">(String url, Class&lt;T&gt; responseType, Object... uriVariables)</span> <span class="keyword">throws</span> RestClientException </span>&#123;<span class="comment">/**/&#125;</span></span><br><span class="line"><span class="comment">//2.</span></span><br><span class="line"><span class="comment">public &lt;T&gt; ResponseEntity&lt;T&gt; getForEntity(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) throws RestClientException &#123;/**/</span>&#125;</span><br><span class="line"><span class="comment">//3.</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">ResponseEntity&lt;T&gt; <span class="title">getForEntity</span><span class="params">(URI url, Class&lt;T&gt; responseType)</span> <span class="keyword">throws</span> RestClientException </span>&#123;<span class="comment">/**/&#125;</span></span><br></pre></td></tr></table></figure><p>对于第一个方法，其uriVariables里为GET请求的参数，通过url占位符的方式使用，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ResponseEntity&lt;String&gt; responseEntity = restTemplate.getForEntity(<span class="string">"http://SAKURA-SERVICE/hello?name=&#123;1&#125;"</span>,String.class,<span class="string">"aaa"</span>);</span><br><span class="line">String body = responseEntity.getBody();</span><br></pre></td></tr></table></figure><p>其中访问SAKURA-SERVICE服务的hello接口时，”aaa”会替换掉{1}。</p><p>如果返回对象是个User，那么如下实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ResponseEntity&lt;User&gt; responseEntity = restTemplate.getForEntity(<span class="string">"http://SAKURA-SERVICE/hello?name=&#123;1&#125;"</span>,User.class,<span class="string">"aaa"</span>);</span><br><span class="line">User body = responseEntity.getBody();</span><br></pre></td></tr></table></figure><p>第2，3个方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.我们使用name作为占位符，则map里需要put一个key为name的参数</span></span><br><span class="line">Map&lt;String,String&gt; map =<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"name"</span>,<span class="string">"aaa"</span>);</span><br><span class="line">ResponseEntity&lt;String&gt; responseEntity1 = restTemplate.getForEntity(<span class="string">"http://SAKURA-SERVICE/hello?name=&#123;name&#125;"</span>,String.class,map);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.构建uri</span></span><br><span class="line">UriComponents uriComponents = UriComponentsBuilder.fromUriString(<span class="string">"http://SAKURA-SERVICE/hello?name=&#123;name&#125;"</span>).build().expand(<span class="string">"aaa"</span>).encode();</span><br><span class="line">URI uri = uriComponents.toUri();</span><br><span class="line">ResponseEntity&lt;String&gt; responseEntity2 = restTemplate.getForEntity(uri,String.class);</span><br></pre></td></tr></table></figure><p>第二种，<code>getForObject</code>函数。该方法是对<code>getForEntity</code>的进一步封装。</p><p>我们使用时十分简单，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = restTemplate.getForObject(uri,String.class);</span><br><span class="line"></span><br><span class="line">User user = restTemplate.getForObject(uri1,User.class);</span><br></pre></td></tr></table></figure><p>它也有3个重载方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getForObject</span><span class="params">(String url, Class&lt;T&gt; responseType, Object... uriVariables)</span> <span class="keyword">throws</span> RestClientException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getForObject</span><span class="params">(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)</span> <span class="keyword">throws</span> RestClientException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getForObject</span><span class="params">(URI url, Class&lt;T&gt; responseType)</span> <span class="keyword">throws</span> RestClientException </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>对于POST请求，与GET类似，它也有<code>postForEntity</code>和<code>postForObject</code>函数。</p><p>它们的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">postForObject</span><span class="params">(String url, @Nullable Object request, Class&lt;T&gt; responseType,</span></span></span><br><span class="line"><span class="function"><span class="params">Object... uriVariables)</span> <span class="keyword">throws</span> RestClientException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">postForObject</span><span class="params">(String url, @Nullable Object request, Class&lt;T&gt; responseType,</span></span></span><br><span class="line"><span class="function"><span class="params">Map&lt;String, ?&gt; uriVariables)</span> <span class="keyword">throws</span> RestClientException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">postForObject</span><span class="params">(URI url, @Nullable Object request, Class&lt;T&gt; responseType)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> RestClientException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">ResponseEntity&lt;T&gt; <span class="title">postForEntity</span><span class="params">(String url, @Nullable Object request,</span></span></span><br><span class="line"><span class="function"><span class="params">Class&lt;T&gt; responseType, Object... uriVariables)</span> <span class="keyword">throws</span> RestClientException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">ResponseEntity&lt;T&gt; <span class="title">postForEntity</span><span class="params">(String url, @Nullable Object request,</span></span></span><br><span class="line"><span class="function"><span class="params">Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)</span> <span class="keyword">throws</span> RestClientException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">ResponseEntity&lt;T&gt; <span class="title">postForEntity</span><span class="params">(URI url, @Nullable Object request, Class&lt;T&gt; responseType)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> RestClientException </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>它们的使用与GET类似，我们就不在过多介绍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User(<span class="string">"aaaa"</span>,<span class="number">18</span>);</span><br><span class="line">ResponseEntity&lt;String&gt; responseEntity = restTemplate.postForEntity(<span class="string">"http://SAKURA-SERVICE/hello"</span>,user,String.class);</span><br><span class="line">String body = responseEntity.getBody();</span><br></pre></td></tr></table></figure><p>另外POST里还有一种<code>postForLocation</code>函数，用来提交资源并返回新资源URI，它也有三种重载方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User(<span class="string">"aaaa"</span>,<span class="number">18</span>);</span><br><span class="line">URI uri = restTemplate.postForLocation(<span class="string">"http://SAKURA-SERVICE/hello"</span>,user);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> URI <span class="title">postForLocation</span><span class="params">(String url, @Nullable Object request, Object... uriVariables)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> RestClientException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> URI <span class="title">postForLocation</span><span class="params">(String url, @Nullable Object request, Map&lt;String, ?&gt; uriVariables)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> RestClientException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> URI <span class="title">postForLocation</span><span class="params">(URI url, @Nullable Object request)</span> <span class="keyword">throws</span> RestClientException </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><code>RestTemplate</code>里的其他方法，如PUT、DELETE等我们不再介绍，有兴趣的可以看看源码。</p><h2 id="Ribbon源码"><a href="#Ribbon源码" class="headerlink" title="Ribbon源码"></a>Ribbon源码</h2><p>分析完<code>RestTemplate</code>后，我们会想，<code>RestTemplate</code>本是Spring本是的东西，如何通过Ribbon实现负载均衡的呢？</p><p>因为我们之前的例子讲到当<code>RestTemplate</code>作用上<code>@LoadBalanced</code>注解后，便可以实现负载均衡了，因此我们从<code>@LoadBalanced</code>注解开始看起吧。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-656.jpg" alt="upload successful"></p><p>通过<code>@LoadBalanced</code>注释可以看到，该注解用来给<code>RestTemplate</code>做标记，以使用负载均衡的客户端<code>LoadBalancerClient</code>来配置它。</p><p>我们搜索<code>LoadBalancerClient</code>可以发现这是Spring Cloud定义的一个接口。如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-657.jpg" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-658.jpg" alt="upload successful"></p><p>通过该接口，可以大致了解负载均衡客户端应具备的几种能力。</p><ol><li><p><code>choose</code>方法：根据传入的服务名serviceId，从负载均衡器中挑选一个对应服务的实例。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ServiceInstance <span class="title">choose</span><span class="params">(String serviceId)</span></span></span><br></pre></td></tr></table></figure></li><li><p><code>execute</code>方法：使用从负载均衡器中挑选出来的服务实例来执行请求内容。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String serviceId, LoadBalancerRequest&lt;T&gt; request)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String serviceId, ServiceInstance serviceInstance,LoadBalancerRequest&lt;T&gt; request)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>reconstructURI</code>方法：为系统构建一个合适的host:port形式的URI。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">URI <span class="title">reconstructURI</span><span class="params">(ServiceInstance instance, URI original)</span></span>;</span><br></pre></td></tr></table></figure></li></ol><p>我们再来看一下<code>LoadBalancerAutoConfiguration</code>这个类，这个类是实现客户端负载均衡的自动化配置类。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-659.jpg" alt="upload successful"></p><p>根据上图，我们可以知道，Ribbon实现负载均衡自动化配置需要满足下面两个条件：</p><ul><li><code>@ConditionalOnClass(RestTemplate.class)</code>：当前工程环境中需要存在<code>RestTemplate</code>类。</li><li><code>@ConditionalOnBean(LoadBalancerClient.class)</code>：需要存在<code>LoadBalancerClient</code>接口的实现Bean。</li></ul><p>该自动化配置类主要完成以下几个功能：</p><ul><li>创建一个<code>LoadBalancerInterceptor</code>的 Bean，用于实现对客户端发起请求时进行拦截，以实现客户端负载均衡。</li><li>创建一个<code>RetryLoadBalancerInterceptor</code>的Bean，用于实现客户端负载均衡的重试机制。</li><li>创建一个<code>RestTemplateCustomizer</code>的 Bean，用于给<code>RestTemplate</code>增加<code>LoadBalancerInterceptor</code>和<code>RetryLoadBalancerInterceptor</code>拦截器。</li><li>维护一个被<code>@LoadBalanced</code>修饰的<code>RestTemplate</code>对象列表，并在这里进行初始化，通过调用<code>RestTemplateCustomizer</code>实例来给需要客户端负载均衡的<code>RestTemplate</code>增加<code>LoadBalancerInterceptor</code>和<code>RetryLoadBalancerInterceptor</code>拦截器。</li></ul><p><code>LoadBalancerInterceptor</code>相关代码如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-660.jpg" alt="upload successful"></p><p>通过源码以及之前的自动化配置类，我们可以看到在拦截器中注入了<code>LoadBalancerClient</code>的实现。当一个被<code>@LoadBalanced</code>注解修饰的<code>RestTemplate</code>对象向外发起HTTP请求时，会被<code>LoadBalancerInterceptor</code>类的<code>intercept</code>所拦截。由于我们在使用<code>RestTemplate</code>时采用了服务名作为host，所以直接从<code>HttpRequest</code>的URI对象中通过<code>getHost()</code>就可以拿到服务名，然后调用<code>execute</code>函数去根据服务名来选择实例并发起实际的请求。</p><p>我们上面讲到了<code>LoadBalancerClient</code>，它只是一个接口，我们现在来看下它的实现类。我们很容易就可以找到它的实现类<code>RibbonLoadBalancerClient</code>。</p><p>这个类我们主要看下它的<code>execute</code>方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String serviceId, LoadBalancerRequest&lt;T&gt; request, Object hint)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ILoadBalancer loadBalancer = getLoadBalancer(serviceId);</span><br><span class="line">    Server server = getServer(loadBalancer, hint);</span><br><span class="line">    <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No instances available for "</span> + serviceId);</span><br><span class="line">    &#125;</span><br><span class="line">    RibbonServer ribbonServer = <span class="keyword">new</span> RibbonServer(serviceId, server, isSecure(server,</span><br><span class="line">            serviceId), serverIntrospector(serviceId).getMetadata(server));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> execute(serviceId, ribbonServer, request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String serviceId, ServiceInstance serviceInstance, LoadBalancerRequest&lt;T&gt; request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Server server = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(serviceInstance <span class="keyword">instanceof</span> RibbonServer) &#123;</span><br><span class="line">        server = ((RibbonServer)serviceInstance).getServer();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No instances available for "</span> + serviceId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RibbonLoadBalancerContext context = <span class="keyword">this</span>.clientFactory</span><br><span class="line">            .getLoadBalancerContext(serviceId);</span><br><span class="line">    RibbonStatsRecorder statsRecorder = <span class="keyword">new</span> RibbonStatsRecorder(context, server);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        T returnVal = request.apply(serviceInstance);</span><br><span class="line">        statsRecorder.recordStats(returnVal);</span><br><span class="line">        <span class="keyword">return</span> returnVal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// catch IOException and rethrow so RestTemplate behaves correctly</span></span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        statsRecorder.recordStats(ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        statsRecorder.recordStats(ex);</span><br><span class="line">        ReflectionUtils.rethrowRuntimeException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Server <span class="title">getServer</span><span class="params">(ILoadBalancer loadBalancer, Object hint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (loadBalancer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Use 'default' on a null hint, or just pass it on?</span></span><br><span class="line">    <span class="keyword">return</span> loadBalancer.chooseServer(hint != <span class="keyword">null</span> ? hint : <span class="string">"default"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在<code>execute</code>函数的实现中，第一步就是通过<code>getServer</code>根据传入的服务名<code>serviceId</code>去获取具体的服务实例。</p><p>同时可以看到<code>getServer</code>函数的实现，调用的是<code>ILoadBalancer</code>接口中定义的<code>chooseServer</code>函数。</p><p>对于<code>ILoadBalancer</code>接口，该接口定义了一个客户端负载均衡需要的一系列抽象操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ILoadBalancer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addServers</span><span class="params">(List&lt;Server&gt; newServers)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Server <span class="title">chooseServer</span><span class="params">(Object key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">markServerDown</span><span class="params">(Server server)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Server&gt; <span class="title">getReachableServers</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Server&gt; <span class="title">getAllServers</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>addServers：向负载均衡器中维护的实例列表增加服务实例。</li><li>chooseServer：通过某种策略，从负载均衡器中挑选出一个具体的服务实例。</li><li>markServerDown：用来通知和标识负载均衡器中某个具体实例已经停止服务，不然负载均衡器在下一次获取服务实例清单前会认为服务实例正常，实际访问时出现问题。</li><li>getReachableServers：获取当前正常服务的实例列表。</li><li>getAllServers：获取所有已知服务实例列表，包括正常服务和停止服务的实例。</li></ul><p>该接口的实现就是对负载均衡策略的一些扩展，这部分我们下节在详细讨论。</p><p>在<code>RibbonClientConfiguration</code>配置类中，我们可以看到如下代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ILoadBalancer <span class="title">ribbonLoadBalancer</span><span class="params">(IClientConfig config,</span></span></span><br><span class="line"><span class="function"><span class="params">        ServerList&lt;Server&gt; serverList, ServerListFilter&lt;Server&gt; serverListFilter,</span></span></span><br><span class="line"><span class="function"><span class="params">        IRule rule, IPing ping, ServerListUpdater serverListUpdater)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(ILoadBalancer.class, name)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(ILoadBalancer.class, config, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ZoneAwareLoadBalancer&lt;&gt;(config, rule, ping, serverList,</span><br><span class="line">            serverListFilter, serverListUpdater);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到Ribbon默认使用<code>ZoneAwareLoadBalancer</code>来实现负载均衡器。</p><p>我们在回到<code>RibbonLoadBalancerClient</code>的代码逻辑，当通过<code>ZoneAwareLoadBalancer</code>的<code>chooseServer</code>函数获取了负载均衡策略分配到的服务实例Server后，将其内容包装成<code>RibbonServer</code>对象，然后使用该对象回调<code>LoadBalancerInterceptor</code>请求拦截器中<code>LoadBalancerRequest</code>的<code>apply(ServiceInstance instance)</code>函数，向一个具体服务实例发起请求。</p><p>在<code>apply(ServiceInstance instance)</code>函数中传入的<code>ServiceInstance</code>接口对象是对服务实例的抽象定义。其内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceInstance</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">default</span> String <span class="title">getInstanceId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">getServiceId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">getHost</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getPort</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSecure</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">URI <span class="title">getUri</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Map&lt;String, String&gt; <span class="title">getMetadata</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">default</span> String <span class="title">getScheme</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的<code>RibbonServer</code>对象就是该接口对的一个实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonServer</span> <span class="keyword">implements</span> <span class="title">ServiceInstance</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String serviceId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Server server;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> secure;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; metadata;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RibbonServer</span><span class="params">(String serviceId, Server server)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(serviceId, server, <span class="keyword">false</span>, Collections.emptyMap());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RibbonServer</span><span class="params">(String serviceId, Server server, <span class="keyword">boolean</span> secure,</span></span></span><br><span class="line"><span class="function"><span class="params">            Map&lt;String, String&gt; metadata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serviceId = serviceId;</span><br><span class="line">        <span class="keyword">this</span>.server = server;</span><br><span class="line">        <span class="keyword">this</span>.secure = secure;</span><br><span class="line">        <span class="keyword">this</span>.metadata = metadata;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//.....部分代码略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>分析到这里，我们大致理清Spring Cloud Ribbon中实现负载均衡的基本脉络，了解了它的一些源码。后面我们会再来看下Ribbon的负载均衡器及负载均衡策略的一些东西。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="SpringCloud" scheme="https://www.sakuratears.top/tags/SpringCloud/"/>
    
      <category term="Ribbon" scheme="https://www.sakuratears.top/tags/Ribbon/"/>
    
  </entry>
  
  <entry>
    <title>面试问题总结</title>
    <link href="https://www.sakuratears.top/blog/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.html"/>
    <id>https://www.sakuratears.top/blog/面试问题总结.html</id>
    <published>2020-08-30T03:28:00.000Z</published>
    <updated>2020-08-30T03:30:29.160Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Redis高并发和快速的原因"><a href="#Redis高并发和快速的原因" class="headerlink" title="Redis高并发和快速的原因"></a><code>Redis</code>高并发和快速的原因</h1><h2 id="Redis高并发和快速的原因-1"><a href="#Redis高并发和快速的原因-1" class="headerlink" title="Redis高并发和快速的原因"></a><code>Redis</code>高并发和快速的原因</h2><ol><li><code>Redis</code>是基于内存的，内存的读写速度非常快；</li><li><code>Redis</code>是单线程的，省去了很多上下文切换线程的时间；</li><li><code>Redis</code>使用多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用<code>epoll</code>，采用了<code>epoll+</code>自己实现的简单的事件框架。<code>epoll</code>中的读、写、关闭、连接都转化成了事件，然后利用<code>epoll</code>的多路复用特性，绝不在io上浪费一点时间。</li></ol><h2 id="为什么Redis是单线程的"><a href="#为什么Redis是单线程的" class="headerlink" title="为什么Redis是单线程的"></a>为什么<code>Redis</code>是单线程的</h2><ol><li><p>官方答案</p><p> 因为<code>Redis</code>是基于内存的操作，CPU不是<code>Redis</code>的瓶颈，<code>Redis</code>的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p></li><li><p>性能指标</p><p> 关于<code>Redis</code>的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。</p></li><li><p>详细原因</p><ul><li><p>不需要各种锁的性能消耗</p><p>  <code>Redis</code>的数据结构并不全是简单的<code>Key-Value</code>，还有<code>list</code>，<code>hash</code>等复杂的结构，这些结构有可能会进行很细粒度的操作，比如在很长的列表后面添加一个元素，在<code>hash</code>当中添加或者删除一个对象。这些操作可能就需要加非常多的锁，导致的结果是同步开销大大增加。</p><p>  总之，在单线程的情况下，就不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。</p></li><li><p>单线程多进程集群方案</p><p>  单线程的威力实际上非常强大，每核心效率也非常高，多线程自然是可以比单线程有更高的性能上限，但是在今天的计算环境中，即使是单机多线程的上限也往往不能满足需要了，需要进一步摸索的是多服务器集群化的方案，这些方案中多线程的技术照样是用不上的。</p><p>  所以单线程、多进程的集群不失为一个时髦的解决方案。</p></li><li><p>CPU消耗</p><p>  采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU。</p><p>  但是如果CPU成为<code>Redis</code>瓶颈，或者不想让服务器其他CUP核闲置，那怎么办？</p><p>  可以考虑多起几个<code>Redis</code>进程，<code>Redis</code>是<code>key-value</code>数据库，不是关系数据库，数据之间没有约束。只要客户端分清哪些<code>key</code>放在哪个<code>Redis</code>进程上就可以了。</p></li></ul></li></ol><h2 id="Redis单线程的优劣势"><a href="#Redis单线程的优劣势" class="headerlink" title="Redis单线程的优劣势"></a><code>Redis</code>单线程的优劣势</h2><ol><li><p>单进程单线程优势</p><ul><li>代码更清晰，处理逻辑更简单；</li><li>不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</li><li>不存在多进程或者多线程导致的切换而消耗CPU。</li></ul></li><li><p>单进程单线程弊端</p><ul><li>无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善。</li></ul></li><li><p>IO多路复用技术</p><p> <code>Redis</code> 采用网络IO多路复用技术来保证在多连接的时候， 系统的高吞吐量。</p><p> 多路-指的是多个<code>socket</code>连接，复用-指的是复用一个线程。多路复用主要有三种技术：<code>select</code>，<code>poll</code>，<code>epoll</code>。<code>epoll</code>是最新的也是目前最好的多路复用技术。</p><p> 这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且<code>Redis</code>在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了<code>Redis</code>具有很高的吞吐量。</p></li></ol><h2 id="Redis高并发快总结"><a href="#Redis高并发快总结" class="headerlink" title="Redis高并发快总结"></a>Redis高并发快总结</h2><ol><li><code>Redis</code>是纯内存数据库，一般都是简单的存取操作，线程占用的时间很多，时间的花费主要集中在IO上，所以读取速度快。</li><li>再说一下IO，<code>Redis</code>使用的是非阻塞IO，IO多路复用，使用了单线程来轮询描述符，将数据库的开、关、读、写都转换成了事件，减少了线程切换时上下文的切换和竞争。</li><li><code>Redis</code>采用了单线程的模型，保证了每个操作的原子性，也减少了线程的上下文切换和竞争。</li><li>另外，数据结构也帮了不少忙，<code>Redis</code>全程使用<code>hash</code>结构，读取速度快，还有一些特殊的数据结构，对数据存储进行了优化，如压缩表，对短数据进行压缩存储，再如，跳表，使用有序的数据结构加快读取的速度。</li><li>还有一点，<code>Redis</code>采用自己实现的事件分离器，效率比较高，内部采用非阻塞的执行方式，吞吐能力比较大。</li></ol><h1 id="Spring中BeanFactory和ApplicationContext的区别"><a href="#Spring中BeanFactory和ApplicationContext的区别" class="headerlink" title="Spring中BeanFactory和ApplicationContext的区别"></a><code>Spring</code>中<code>BeanFactory</code>和<code>ApplicationContext</code>的区别</h1><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-655.jpg" alt="upload successful"></p><ol><li><p>国际化</p><p> <code>BeanFactory</code>是不支持国际化功能的，因为<code>BeanFactory</code>没有扩展<code>Spring</code>中<code>MessageResource</code>接口。相反，由于<code>ApplicationContext</code>扩展了<code>MessageResource</code>接口，因而具有消息处理的能力(i18N)。</p></li><li><p>强大的事件机制(Event) </p><p> 基本上牵涉到事件(Event)方面的设计，就离不开观察者模式，<code>ApplicationContext</code>的事件机制主要通过<code>ApplicationEvent</code>和<code>ApplicationListener</code>这两个接口来提供的，和<code>java swing</code>中的事件机制一样。即当<code>ApplicationContext</code>中发布一个事件的时，所有扩展了<code>ApplicationListener</code>的<code>Bean</code>都将会接受到这个事件，并进行相应的处理。</p></li><li><p>底层资源的访问 </p><p> <code>ApplicationContext</code>扩展了<code>ResourceLoader</code>(资源加载器)接口，从而可以用来加载多个<code>Resource</code>，而<code>BeanFactory</code>是没有扩展<code>ResourceLoader</code>。</p></li><li><p>对Web应用的支持 </p><p> 与<code>BeanFactory</code>通常以编程的方式被创建不同的是，<code>ApplicationContext</code>能以声明的方式创建，如使用<code>ContextLoader</code>。当然你也可以使用<code>ApplicationContext</code>的实现之一来以编程的方式创建<code>ApplicationContext</code>实例 。</p></li><li><p>延迟加载</p><ul><li><p><code>BeanFactroy</code>采用的是延迟加载形式来注入<code>Bean</code>的，即只有在使用到某个<code>Bean</code>时(调用<code>getBean()</code>)，才对该<code>Bean</code>进行加载实例化，这样，我们就不能发现一些存在的<code>spring</code>的配置问题。而<code>ApplicationContext</code>则相反，它是在容器启动时，一次性创建了所有的<code>Bean</code>。这样，在容器启动时，我们就可以发现<code>Spring</code>中存在的配置错误。</p></li><li><p><code>BeanFactory</code>和<code>ApplicationContext</code>都支持<code>BeanPostProcessor</code>、<code>BeanFactoryPostProcessor</code>的使用，但两者之间的区别是：<code>BeanFactory</code>需要手动注册，而<code>ApplicationContext</code>则是自动注册。</p></li></ul></li></ol><p>可以看到:</p><ul><li><p><code>ApplicationContext</code>继承了<code>BeanFactory</code>，<code>BeanFactory</code>是<code>Spring</code>中比较原始的<code>Factory</code>，它不支持<code>AOP</code>、<code>Web</code>等<code>Spring</code>插件，而<code>ApplicationContext</code>不仅包含了<code>BeanFactory</code>的所有功能，还支持<code>Spring</code>的各种插件，还以一种面向框架的方式工作以及对上下文进行分层和实现继承。</p></li><li><p><code>BeanFactory</code>是<code>Spring</code>框架的基础设施，面向<code>Spring</code>本身；而<code>ApplicationContext</code>面向使用<code>Spring</code>的开发者，相比<code>BeanFactory</code>提供了更多面向实际应用的功能，几乎所有场合都可以直接使用<code>ApplicationContext</code>而不是底层的<code>BeanFactory</code>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Redis" scheme="https://www.sakuratears.top/tags/Redis/"/>
    
      <category term="Spring" scheme="https://www.sakuratears.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Redis淘汰策略</title>
    <link href="https://www.sakuratears.top/blog/Redis%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5.html"/>
    <id>https://www.sakuratears.top/blog/Redis淘汰策略.html</id>
    <published>2020-08-19T14:35:00.000Z</published>
    <updated>2020-08-19T14:40:16.254Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>当Ridis被用作缓存时，我们添加新数据后可以很方便的删除旧数据。这种行为在开发过程中十分常见，这种行为是内存型数据库的默认行为。</p><p>当然，数据库对旧数据进行处理的前提是我们的数据存储达到了设定的值。</p><p>在Redis中，LRU（Less Recently Used）是比较常用的数据淘汰策略，其方式就是当内存达到指定值时，清除一部分当前较少被使用（Less Recently Used）的数据。</p><p>从Redis 4.0版本开始，Redis引入了一个新的内存数据淘汰策略LFU（Least Frequently Used），清除最不经常使用的的内存数据。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Maxmemory配置指令"><a href="#Maxmemory配置指令" class="headerlink" title="Maxmemory配置指令"></a>Maxmemory配置指令</h2><p><code>maxmemory</code> 配置指令是用来配置<code>Redis</code>使用指定数量的内存数据集。</p><p>我们可以使用<code>redis.conf</code>文件设置配置指令，或者在运行时使用<code>CONFIG set</code>命令设置。</p><p>比如，我们想限制<code>Redis</code>使用最大100M的内存，则可以在<code>redis.conf</code>文件中如下配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory 100mb</span><br></pre></td></tr></table></figure><p>将<code>maxmemory</code>设置为0会导致没有内存限制。这是64位系统的默认行为，而32位系统使用隐式内存限制为<code>3GB</code>。</p><p>当达到指定的内存量时，我们可以设定不同的淘汰策略。Redis可以只返回错误的命令，这可能导致更多的内存被使用，或者它可以淘汰一些旧数据，以便添加新的数据。</p><h2 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h2><p>当数据量达到<code>maxmemory</code>限制时，<code>Redis</code>的确切行为是使用<code>maxmemory-policy</code>配置指令配置的。</p><p>有以下策略：</p><ul><li><strong>noeviction</strong>：当达到内存限制且客户端试图执行可能导致使用更多内存的命令时返回错误(大多数是<code>write </code>命令，除了<code>DEL</code>和其他一些异常)。</li><li><strong>allkeys-lru</strong>：通过首先尝试删除最近使用较少的(LRU)键来删除数据，以便为添加的新数据腾出空间。</li><li><strong>volatile-lru</strong>：通过尝试首先删除最近较少使用的(LRU)键，但仅在具有过期时间的键中删除，从而为添加的新数据腾出空间。</li><li><strong>allkeys-random</strong>：随机删除键，以便为添加的新数据腾出空间。</li><li><strong>volatile-random</strong>：随机删除键，以便为添加的新数据腾出空间，但仅删除具有过期时间的键。</li><li><strong>volatile-ttl</strong>：删除具有过期时间的键值，并首先尝试删除具有较短生存时间(TTL)的键值，以便为添加的新数据腾出空间。</li></ul><p>如果没有匹配到先决条件的淘汰键，<code>volatile-lru</code>、<code>volatile-random</code>和<code>volatile-ttl</code>策略的行为类似于<code>noeviction</code>。</p><p>根据应用程序的访问模式选择正确的回收策略是十分重要的，但是我们也可以在运行时重新配置策略，当应用程序运行时，使用 <code>Redis </code><code>INFO</code> 命令输出信息来监控缓存丢失和命中的数量，以便调整我们的设置。</p><p>一般经验法则：</p><ul><li>当我们的请求数据量呈<strong>幂律分布</strong>时，即访问一部分元素比其它元素更频繁时，可以使用<strong>allkeys-lru</strong>策略，这是一个不错的选择。</li><li>如果我们的访问比较均匀，所有的键都可能平等的被访问（期望分布均匀），那么可以使用<strong>allkeys-random</strong>策略。</li><li>如果我们创建对象的时候，设置了对象的过期时间（TTL），那么可以使用<strong>volatile-ttl</strong>策略。</li><li>当我们使用Redis单例缓存持久数据时，<strong>volatile-lru</strong>和<strong>volatile-random</strong>策略就非常有用了。当然，使用两个Redis实例来解决这个问题通常更好。</li></ul><p>需要注意的是，为键设置过期时间会消耗内存，因此使用<strong>allkeys-lru</strong>这样的策略更能有效地利用内存，因为在内存压力下不需要为要淘汰的键设置过期时间。</p><blockquote><p>幂律分布：数学模型，如二八原则：20%的人口拥有80%的财富，20%的上市公司创造80%的价值，80%的收入来自20%的商品等等。</p></blockquote><h2 id="淘汰过程如何进行"><a href="#淘汰过程如何进行" class="headerlink" title="淘汰过程如何进行"></a>淘汰过程如何进行</h2><p>我们需要知道淘汰策略是如下进行的：</p><ol><li>客户端运行一个新命令，导致更多数据被添加；</li><li><code>Redis</code>检查内存使用，如果超过<code>maxmemory</code>限制，便会根据策略淘汰数据；</li><li>执行一个新命令，以此类推。</li></ol><p>所以实际是不断的跨越<code>maxmemory</code>边界限制，检测到，而后通过淘汰某些数据使内存回到限制下。</p><p>如果一个命令导致一段时间内使用了大量内存（如向一个大集合<code>big set</code>里插入一个新的<code>key</code>），那么内存限制可能会短时间内超过很多。</p><h2 id="近似LRU算法"><a href="#近似LRU算法" class="headerlink" title="近似LRU算法"></a>近似LRU算法</h2><p>需要注意的是<code>Redis</code>的<code>LRU</code>算法只是一个近似的实现。这就意味着<code>Redis</code>并不一定能淘汰最佳的需要被淘汰的数据。</p><p><code>Redis</code>通过运行近似<code>LRU</code>算法，对少量数据<code>key</code>进行采样，然后在采样数据中找到最好的（访问时间最旧的<code>key</code>），并将其淘汰。</p><p>从Redis 3.0以后，算法得到了改进，采取了一个好的候选淘汰池。这提高了算法的性能，使其更能够更接近真实LRU算法的行为。</p><p><code>Redis</code>的<code>LRU</code>算法有一个比较重要的点，我们可以改变样本数量来调整算法的精度，参数控制如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory-samples 5</span><br></pre></td></tr></table></figure><p><code>Redis</code>不使用真正<code>LRU</code>算法的根本原因是其需要很多内存。其实对于使用<code>Redis</code>的应用来说，这个近似<code>LRU</code>算法和真正的<code>LRU</code>算法是等价的。</p><p>下面是<code>Redis</code>使用的<code>LRU</code>近似值与真实<code>LRU</code>之间的图形比较。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-654.png" alt="upload successful"></p><p>上述图形生成过程：使用给定数量的<code>key</code>填充<code>Redis</code>，然后从第一个键访问到最后一个键，因此第一个键是使用<code>LRU</code>算法淘汰的最佳候选键。然后增加50%的键，迫使<code>Redis</code>淘汰一半的键。</p><p>可以看到上图的数据点，形成了3个不同的带。</p><ul><li>浅灰色带是被淘汰的对象。</li><li>灰色带是未被淘汰的对象。</li><li>绿带是新添加的对象。</li></ul><p>在理论上的<code>LRU</code>实现中，我们期望在旧的键中，将前一半淘汰。而<code>Redis LRU</code>算法只会概率地使旧键被淘汰。</p><p>正如我们所看到的，与<code>Redis 2.8</code>相比，<code>Redis 3.0</code>在5个样本上做得更好，但是大多数最新访问的对象仍然保留在<code>Redis 2.8</code>中。在<code>Redis 3.0</code>中使用10个样本大小，这个近似非常接近于理论性能的<code>Redis 3.0</code>。</p><p>需要注意的是，<code>LRU</code>只是一个模型，用于预测给定<code>key</code>在未来被访问的可能性。此外，如果我们数据访问模式与幂律分布非常相似，那么大多数访问将位于<code>LRU</code>近似算法能够很好处理的键集中。</p><p>在模拟中，我们发现使用幂律访问模式，真实<code>LRU</code>近似和<code>Redis LRU</code>近似之间的差异极小或不存在。</p><p>但是，我们可以以额外的CPU使用为代价将样本大小增加到10，以接近真实的<code>LRU</code>，并检查这是否会对缓存漏报率产生影响。</p><p>通过使用配置集<code>maxmemory-samples \<count></count></code>命令，在生产环境中使用不同的样本大小值进行试验，这非常简单。</p><h2 id="新的LFU策略模式"><a href="#新的LFU策略模式" class="headerlink" title="新的LFU策略模式"></a>新的LFU策略模式</h2><p>在<code>Redis 4.0</code>中，我们可以使用一种新的淘汰策略模式，<code>LFU</code>（Least Frequently Used）。在某些情况下，这种策略模式可能更好（提供更好的命中/丢失比率），因为使用<code>LFU</code>，<code>Redis</code>会尝试跟踪访问条目的频率，所以使用很少的会被清除，而经常使用的会被留在内存中。</p><p>而我们想下<code>LRU</code>，最近访问过但实际上几乎从未请求过的项将不会淘汰，因此风险是淘汰一个将来有更高机会被请求的键。<code>LFU</code>不存在这个问题，一般来说能更好地适应不同的访问模式。</p><p><code>LFU</code>有以下策略模式可以使用：</p><ul><li>volatile-lfu：在设置过期时间的键里使用近似LFU模式淘汰键。</li><li>allkeys-lfu：使用近似LFU模式淘汰任何键。</li></ul><p><code>LFU</code>和<code>LRU</code>有些类似：它使用概率计算器，一种叫<a href="https://en.wikipedia.org/wiki/Approximate_counting_algorithm" rel="external nofollow noopener noreferrer" target="_blank"><code>Morris counter</code></a>的计数器。根据一些对象的访问频率，结合衰减期来进行估算。</p><p>信息采样类似于<code>LRU</code>，选择一个合适的候选数据以便淘汰掉。</p><p>与<code>LRU</code>不同的是，<code>LFU</code>有某些参数可调，如果一个频繁的条目不再被访问，它的排名应该降低多快？ 还可以调优Morris计数器范围，以便更好地使算法适应特定的用例。</p><p><code>Redis 4.0</code>默认配置如下：</p><ul><li>大约一百万个请求使计数器饱和。</li><li>每隔一分钟衰减一下计数器。</li></ul><p>这些值是比较合理的，并且是经过实验测试的，但是用户可能希望使用这些配置设置来选择最优值。</p><p>关于如何调优这些参数的说明可以在源代码分发版的示例<code>redis.conf</code>文件中找到，但简单地说，它们是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lfu-log-factor 10</span><br><span class="line">lfu-decay-time 1</span><br></pre></td></tr></table></figure><p>lfu-decay-time ：衰减时间，计数器应衰减的分钟数，当采样并发现比该值更早的值时。一个特殊的值0表示:每次扫描时总是衰减计数器，很少有用。</p><p>lfu-log-factor ：计数器对数因子，使计数器达到饱和所需的命中次数，该次数刚好在0-255范围内。系数越高，为了达到最大值，需要的访问次数就越多。系数越低，计数器对于低访问频率的表现越好，由下表可知:</p><table><thead><tr><th>factor</th><th>100 hits</th><th>1000 hits</th><th>100K hits</th><th>1M hits</th><th>10M hits</th></tr></thead><tbody><tr><td>0</td><td>104</td><td>255</td><td>255</td><td>255</td><td>255</td></tr><tr><td>1</td><td>18</td><td>49</td><td>255</td><td>255</td><td>255</td></tr><tr><td>10</td><td>10</td><td>18</td><td>142</td><td>255</td><td>255</td></tr><tr><td>100</td><td>8</td><td>11</td><td>49</td><td>143</td><td>255</td></tr></tbody></table><p>所以基本上这个因子就是在低访问和高访问之间进行权衡。更多的信息可以在示例<code>redis.conf</code>文件中获得。</p><p>由于<code>LFU</code>是一个新特性，如果我们在实际使用中可以与<code>LRU</code>进行比较，得到的信息及疑问可以反馈给<code>Redis</code>官方。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文通过对<code>Redis</code>淘汰策略的介绍，了解了<code>Redis</code>淘汰模式的一些特点和用法，这对我们是比较有帮助的。</p><h1 id="参考-翻译"><a href="#参考-翻译" class="headerlink" title="参考/翻译"></a>参考/翻译</h1><ol><li><a href="https://redis.io/topics/lru-cache" rel="external nofollow noopener noreferrer" target="_blank">Using Redis as an LRU cache</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Redis" scheme="https://www.sakuratears.top/tags/Redis/"/>
    
      <category term="淘汰策略" scheme="https://www.sakuratears.top/tags/%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>Java实体对象映射工具MapStruct</title>
    <link href="https://www.sakuratears.top/blog/Java%E5%AE%9E%E4%BD%93%E5%AF%B9%E8%B1%A1%E6%98%A0%E5%B0%84%E5%B7%A5%E5%85%B7MapStruct.html"/>
    <id>https://www.sakuratears.top/blog/Java实体对象映射工具MapStruct.html</id>
    <published>2020-08-17T12:49:00.000Z</published>
    <updated>2020-08-17T12:50:11.163Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天我们来介绍一款非常优秀的实体对象映射工具，<a href="https://mapstruct.org/" rel="external nofollow noopener noreferrer" target="_blank"><code>MapStruct</code></a>。</p><p>在开发的时候我们会看到业务代码之间有很多的<code>JavaBean</code>之间的相互转化，非常影响美观，但是又不得不存在。</p><p>通常的<code>JavaBean</code>处理方法是通过Spring或者Apache提供的<code>BeanUtils</code>工具，而对于一些不匹配的属性，通过<code>get/set</code>方法解决。</p><p>由于<code>BeanUtils</code>使用反射机制，故其在大量使用时可能会影响到性能，同时对于不匹配的属性，如果较多，<code>get/set</code>起来也非常麻烦和繁琐。</p><p>对于一些特殊类型不一致的字段，如<code>DO</code>里为<code>Date</code>类型，可能<code>DTO</code>里需要变为时间的<code>String</code>类型，我们需要调用指定方法进行处理，再进行<code>get/set</code>。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>而<code>MapStruct</code>可以让我们从这种复杂而繁琐的工作中解放出来。</p><p><code>MapSturct</code> 是一个生成类型安全，高性能且无依赖的<code>JavaBean</code>映射代码的注解处理器（annotation processor）。</p><p>它可以让我们通过注解的方式，生成<code>JavaBean</code>之间的映射代码，相较于反射，更安全更高效。</p><p>让我们来看一下。</p><h2 id="MapStruct引入"><a href="#MapStruct引入" class="headerlink" title="MapStruct引入"></a>MapStruct引入</h2><p>首先我们需要在<code>Maven</code>项目中引入<code>MapSturct</code>的相关Jar包。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">org.mapstruct.version</span>&gt;</span>1.3.1.Final<span class="tag">&lt;/<span class="name">org.mapstruct.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mapstruct/mapstruct --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mapstruct<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapstruct<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;org.mapstruct.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mapstruct<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapstruct-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;org.mapstruct.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>有两个，<code>mapstruct</code>是主要包，<code>mapstruct-processor</code>用来辅助生成<code>JavaBean</code>之间的映射代码。</p><h2 id="MapStruct使用"><a href="#MapStruct使用" class="headerlink" title="MapStruct使用"></a>MapStruct使用</h2><p>我们根据例子来看如何使用<code>MapSturct</code>。</p><p>我们这儿有两个<code>JavaBean</code>，<code>PersonDO</code>和<code>PersonDTO</code>，现在我们将<code>PersonDO</code>转为<code>PersonDTO</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDTO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Gender gender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Gender &#123;</span><br><span class="line">    MAN,MALE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转化时需要编写<code>Mapper</code>，即对象映射器，是一个接口，如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonConverter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    PersonConverter INSTANCE = Mappers.getMapper(PersonConverter.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mapping</span>(source = <span class="string">"name"</span>, target = <span class="string">"userName"</span>)</span><br><span class="line">    <span class="function">PersonDTO <span class="title">do2dto</span><span class="params">(PersonDO person)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用注解<code>@Mapper</code>定义一个<code>Converter</code>接口，在其中定义一个<code>do2dto</code>方法，方法的入参类型是<code>PersonDO</code>，出参类型是<code>PersonDTO</code>，这个方法就用于将<code>PersonDO</code>转成<code>PersonDTO</code>。</p><p>测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PersonDO personDO = <span class="keyword">new</span> PersonDO();</span><br><span class="line">        personDO.setName(<span class="string">"Sakura"</span>);</span><br><span class="line">        personDO.setAge(<span class="number">27</span>);</span><br><span class="line">        personDO.setId(<span class="number">1</span>);</span><br><span class="line">        personDO.setGender(Gender.MAN.name());</span><br><span class="line"></span><br><span class="line">        PersonDTO personDTO = PersonConverter.INSTANCE.do2dto(personDO);</span><br><span class="line">        System.out.println(personDTO);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PersonDTO(userName=Sakura, age=27, gender=MAN)</span><br></pre></td></tr></table></figure><p>由上面的例子可以看到<code>MapSturct</code>成功将<code>PersonDO</code>转成<code>PersonDTO</code>。</p><h2 id="MapStruct字段映射处理"><a href="#MapStruct字段映射处理" class="headerlink" title="MapStruct字段映射处理"></a>MapStruct字段映射处理</h2><p>两个<code>JavaBean</code>对象进行映射，属性名称一致的字段可以相互映射，不一致的如何处理呢？</p><h3 id="两个字段名字不一致"><a href="#两个字段名字不一致" class="headerlink" title="两个字段名字不一致"></a>两个字段名字不一致</h3><p>从上面的例子可以看出，我们只需要使用<code>@Mapping</code>注解。在转换方法上设置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapping</span>(source = <span class="string">"name"</span>, target = <span class="string">"userName"</span>)</span><br></pre></td></tr></table></figure><p>即可。其含义是将<code>name</code>字段的值映射给<code>userName</code>。</p><h3 id="MapStruct可以映射的类型"><a href="#MapStruct可以映射的类型" class="headerlink" title="MapStruct可以映射的类型"></a>MapStruct可以映射的类型</h3><p>在上面例子，我们发现<code>age</code>字段完成映射，其类型一个为<code>int</code>，另一个为包装类。</p><p><code>gender</code>字段完成映射，其类型一个为枚举，一个为<code>String</code>。</p><p>一般情况下，<code>MapSturct</code>会对部分类型做自动映射，而不需要我们额外配置。</p><ul><li>基本类型及其他们对应的包装类型。</li><li>基本类型的包装类型和String类型之间</li><li>String类型和枚举类型之间</li></ul><h3 id="自定义常量和默认值"><a href="#自定义常量和默认值" class="headerlink" title="自定义常量和默认值"></a>自定义常量和默认值</h3><p>如果我们想在转换中，给某个属性一个固定值，可以使用<code>constant</code>。</p><p>比如<code>PersonDTO</code>里新增身高字段。而<code>PersonDO</code>里没有，那么我们可以在转换时赋予默认值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDTO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Gender gender;</span><br><span class="line">    <span class="keyword">private</span> Integer height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapping</span>(target = <span class="string">"height"</span>,constant = <span class="string">"175"</span>)</span><br></pre></td></tr></table></figure><p>而对于某一个属性，如果映射后为空，我们可以给予其默认值，使用<code>defaultValue</code>，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapping</span>(target = <span class="string">"gender"</span>,defaultValue = <span class="string">"MAN"</span>)</span><br></pre></td></tr></table></figure><h3 id="类型不一致的映射"><a href="#类型不一致的映射" class="headerlink" title="类型不一致的映射"></a>类型不一致的映射</h3><p>在实际转化中，有可能字段类型是不一致的，如何进行映射呢？</p><p>我们使用上面的例子，在<code>PersonDO</code>里增加生日属性，为<code>Date</code>类型，<code>PersonDTO</code>里为<code>String</code>类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDTO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Gender gender;</span><br><span class="line">    <span class="keyword">private</span> Integer height;</span><br><span class="line">    <span class="keyword">private</span> String birthday;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候我们可以使用如下方法转化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapping</span>(source = <span class="string">"name"</span>, target = <span class="string">"userName"</span>)</span><br><span class="line"><span class="meta">@Mapping</span>(target = <span class="string">"height"</span>,constant = <span class="string">"175"</span>)</span><br><span class="line"><span class="meta">@Mapping</span>(target = <span class="string">"birthday"</span>,dateFormat = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span><br><span class="line"><span class="function">PersonDTO <span class="title">do2dto</span><span class="params">(PersonDO person)</span></span>;</span><br></pre></td></tr></table></figure><p>运行后可以看到正确输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PersonDTO(userName=Sakura, age=27, gender=MAN, height=175, birthday=2020-08-17 15:20:16)</span><br></pre></td></tr></table></figure><p><code>dateFormat</code>是<code>MapStruct</code>自带的属性，如果我们的属性映射方法比较复杂呢？</p><p>当然，<code>MapStruct</code>支持我们自定义属性转换的方法，我们来看一下。</p><p>我们新增一个兴趣爱好字段，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; hobbies;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDTO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Gender gender;</span><br><span class="line">    <span class="keyword">private</span> Integer height;</span><br><span class="line">    <span class="keyword">private</span> String birthday;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; strHobbies;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> HobbiesEnum &#123;</span><br><span class="line">    FOOTBALL(<span class="number">1</span>,<span class="string">"足球"</span>),</span><br><span class="line">    READ_BOOK(<span class="number">2</span>,<span class="string">"读书"</span>),</span><br><span class="line">    PLAY_GAME(<span class="number">3</span>,<span class="string">"玩游戏"</span>),</span><br><span class="line">    SINGING(<span class="number">4</span>,<span class="string">"唱歌"</span>),</span><br><span class="line">    TRAVEL(<span class="number">5</span>,<span class="string">"旅行"</span>);</span><br><span class="line">    <span class="keyword">private</span> Integer value;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get/set 构造器略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取一个枚举</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HobbiesEnum <span class="title">getEnum</span><span class="params">(Integer value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(HobbiesEnum.values()).filter(e-&gt;e.value.equals(value)).findFirst().orElse(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要完成<code>List<integer> hobbies</integer></code>对<code>List<string> strHobbies</string></code>的转化，我们可以使用如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonConverter</span> </span>&#123;</span><br><span class="line">    PersonConverter INSTANCE = Mappers.getMapper(PersonConverter.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mapping</span>(source = <span class="string">"name"</span>, target = <span class="string">"userName"</span>)</span><br><span class="line">    <span class="meta">@Mapping</span>(target = <span class="string">"height"</span>,constant = <span class="string">"175"</span>)</span><br><span class="line">    <span class="meta">@Mapping</span>(target = <span class="string">"gender"</span>,defaultValue = <span class="string">"MAN"</span>)</span><br><span class="line">    <span class="meta">@Mapping</span>(target = <span class="string">"birthday"</span>,dateFormat = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span><br><span class="line">    <span class="meta">@Mapping</span>(target = <span class="string">"strHobbies"</span>,expression = <span class="string">"java(getHobbiesStr(person.getHobbies()))"</span>)</span><br><span class="line">    <span class="function">PersonDTO <span class="title">do2dto</span><span class="params">(PersonDO person)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 爱好映射</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> integers</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> List&lt;String&gt; <span class="title">getHobbiesStr</span><span class="params">(List&lt;Integer&gt; integers)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Integer integer : integers) &#123;</span><br><span class="line">            HobbiesEnum hobbiesEnum = HobbiesEnum.getEnum(integer);</span><br><span class="line">            <span class="keyword">if</span>(hobbiesEnum!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                list.add(hobbiesEnum.getDesc());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：java1.8接口支持自定义default方法，<code>expression = “java(getHobbiesStr(person.getHobbies()))”</code>这段代码也可以指向自己写的某个方法，需要具体路径包名。</p><p>上面代码还是非常好理解的，这儿就不过多叙述。</p><h3 id="多个属性映射"><a href="#多个属性映射" class="headerlink" title="多个属性映射"></a>多个属性映射</h3><p><code>MapStruct</code>还支持将多个实体数据组装到一个实体中，如下：</p><p>比如上面的例子，我们的身高属性来自另一个<code>Bean</code>，则代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeightDO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> Integer height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则组装数据的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapping</span>(source = <span class="string">"person.name"</span>, target = <span class="string">"userName"</span>)</span><br><span class="line"><span class="meta">@Mapping</span>(source = <span class="string">"height.height"</span>,target = <span class="string">"height"</span>)</span><br><span class="line"><span class="meta">@Mapping</span>(target = <span class="string">"gender"</span>,defaultValue = <span class="string">"MAN"</span>)</span><br><span class="line"><span class="meta">@Mapping</span>(target = <span class="string">"birthday"</span>,dateFormat = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span><br><span class="line"><span class="meta">@Mapping</span>(target = <span class="string">"strHobbies"</span>,expression = <span class="string">"java(getHobbiesStr(person.getHobbies()))"</span>)</span><br><span class="line"><span class="function">PersonDTO <span class="title">do2dto</span><span class="params">(PersonDO person,HeightDO height)</span></span>;</span><br></pre></td></tr></table></figure><p>对于<code>source</code>属性，需要指定来自哪个<code>DO</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PersonDO personDO = <span class="keyword">new</span> PersonDO();</span><br><span class="line">        personDO.setName(<span class="string">"Sakura"</span>);</span><br><span class="line">        personDO.setAge(<span class="number">27</span>);</span><br><span class="line">        personDO.setId(<span class="number">1</span>);</span><br><span class="line">        personDO.setBirthday(<span class="keyword">new</span> Date());</span><br><span class="line">        personDO.setGender(Gender.MAN.name());</span><br><span class="line">        List&lt;Integer&gt; list  =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line">        personDO.setHobbies(list);</span><br><span class="line"></span><br><span class="line">        HeightDO heightDO = <span class="keyword">new</span> HeightDO();</span><br><span class="line">        heightDO.setHeight(<span class="number">178</span>);</span><br><span class="line"></span><br><span class="line">        PersonDTO personDTO = PersonConverter.INSTANCE.do2dto(personDO,heightDO);</span><br><span class="line">        System.out.println(personDTO);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PersonDTO(userName=Sakura, age=27, gender=MAN, height=178, birthday=2020-08-17 15:52:14, strHobbies=[足球, 玩游戏])</span><br></pre></td></tr></table></figure><h3 id="更新现有Bean实例"><a href="#更新现有Bean实例" class="headerlink" title="更新现有Bean实例"></a>更新现有Bean实例</h3><p><code>MapStruct</code>还支持将一个<code>Bean</code>的属性更新到另一个<code>Bean</code>的同名属性里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateDTOfromDO</span><span class="params">(PersonDO person, @MappingTarget PersonDTO personDTO)</span></span>;</span><br></pre></td></tr></table></figure><p>需要注意这个对于同名属性，如果<code>DO</code>上有值，那么<code>DTO</code>上的值将被覆盖，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PersonDTO dto = <span class="keyword">new</span> PersonDTO();</span><br><span class="line">dto.setAge(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">PersonDO aDo = <span class="keyword">new</span> PersonDO();</span><br><span class="line">aDo.setName(<span class="string">"Sakura"</span>);</span><br><span class="line">aDo.setAge(<span class="number">27</span>);</span><br><span class="line">aDo.setId(<span class="number">1</span>);</span><br><span class="line">aDo.setBirthday(<span class="keyword">new</span> Date());</span><br><span class="line">aDo.setGender(Gender.MAN.name());</span><br><span class="line"></span><br><span class="line">PersonConverter.INSTANCE.updateDTOfromDO(aDo,dto);</span><br><span class="line">System.out.println(dto);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PersonDTO(userName=null, age=27, gender=MAN, height=null, birthday=2020/8/17 下午4:29, strHobbies=null)</span><br></pre></td></tr></table></figure><h3 id="继承反转配置"><a href="#继承反转配置" class="headerlink" title="继承反转配置"></a>继承反转配置</h3><p><code>MapStruct</code>在存在<code>DO</code>转换为<code>DTO</code>的前提下，还支持将<code>DTO</code>转换为<code>DO</code>，而且不用我们复杂的配置。</p><p>方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonConverter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    PersonConverter INSTANCE = Mappers.getMapper(PersonConverter.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mapping</span>(source = <span class="string">"name"</span>, target = <span class="string">"userName"</span>)</span><br><span class="line">    <span class="meta">@Mapping</span>(target = <span class="string">"height"</span>,constant = <span class="string">"175"</span>)</span><br><span class="line">    <span class="meta">@Mapping</span>(target = <span class="string">"gender"</span>,defaultValue = <span class="string">"MAN"</span>)</span><br><span class="line">    <span class="meta">@Mapping</span>(target = <span class="string">"birthday"</span>,dateFormat = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span><br><span class="line">    <span class="meta">@Mapping</span>(target = <span class="string">"strHobbies"</span>,expression = <span class="string">"java(getHobbiesStr(person.getHobbies()))"</span>)</span><br><span class="line">    <span class="function">PersonDTO <span class="title">do2dto</span><span class="params">(PersonDO person)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@InheritInverseConfiguration</span>(name = <span class="string">"do2dto"</span>)</span><br><span class="line">    <span class="function">PersonDO <span class="title">dto2do</span><span class="params">(PersonDTO personDTO)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只需要<code>@InheritInverseConfiguration</code>注解即可解决，<code>name</code>属性指向<code>DO</code>转换为<code>DTO</code>的方法。</p><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PersonDTO dto1 = <span class="keyword">new</span> PersonDTO();</span><br><span class="line">dto1.setAge(<span class="number">27</span>);</span><br><span class="line">dto1.setBirthday(<span class="string">"2018-11-11 12:12:12"</span>);</span><br><span class="line">dto1.setGender(Gender.MAN);</span><br><span class="line">dto1.setHeight(<span class="number">175</span>);</span><br><span class="line">dto1.setUserName(<span class="string">"Sakura"</span>);</span><br><span class="line">List&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list1.add(<span class="string">"足球"</span>);</span><br><span class="line">list1.add(<span class="string">"玩游戏"</span>);</span><br><span class="line">dto1.setStrHobbies(list1);</span><br><span class="line">PersonDO personDO1 = PersonConverter.INSTANCE.dto2do(dto1);</span><br><span class="line">System.out.println(personDO1);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PersonDO(id=null, name=Sakura, age=27, gender=MAN, birthday=Sun Nov 11 12:12:12 CST 2018, hobbies=null)</span><br></pre></td></tr></table></figure><p>这儿需要注意的是我们看到<code>Hobbies</code>属性并没有转化，这是正常的，这个需要我们配置<code>@Mapping</code>，写出并指定兴趣爱好转化的逆向方法。</p><h2 id="MapStruct的性能"><a href="#MapStruct的性能" class="headerlink" title="MapStruct的性能"></a>MapStruct的性能</h2><p><code>MapStruct</code>的性能是非常优秀的，我们来测试一下：</p><p>为简化代码，我们是<code>DO</code>和<code>DTO</code>尽可能的简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDTO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MapStruct</code>相关方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestConverter</span> </span>&#123;</span><br><span class="line">    TestConverter INSTANCE = Mappers.getMapper(TestConverter.class);</span><br><span class="line"></span><br><span class="line">    <span class="function">TestDTO <span class="title">do2dto</span><span class="params">(TestDO testDO)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用<code>Spring</code>自带的<code>BeanUtils</code>工具类来与其进行比较：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NUM = <span class="number">100000</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start1 = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;NUM;i++)&#123;</span><br><span class="line">            TestDO testDO = <span class="keyword">new</span> TestDO();</span><br><span class="line">            testDO.setA(i);</span><br><span class="line">            TestDTO testDTO = <span class="keyword">new</span> TestDTO();</span><br><span class="line">            BeanUtils.copyProperties(testDO,testDTO);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"BeanUtils属性拷贝耗时："</span>+(System.currentTimeMillis()-start1)+<span class="string">"ms"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> start2 = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;NUM;i++)&#123;</span><br><span class="line">            TestDO testDO = <span class="keyword">new</span> TestDO();</span><br><span class="line">            testDO.setA(i);</span><br><span class="line">            TestDTO dto = TestConverter.INSTANCE.do2dto(testDO);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"MapStruct处理耗时："</span>+(System.currentTimeMillis()-start2)+<span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们以100000个对象为样本，得到如下输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BeanUtils属性拷贝耗时：1903ms</span><br><span class="line">MapStruct处理耗时：5ms</span><br></pre></td></tr></table></figure><p>可以看到差距是非常大的。</p><p><code>MapStruct</code>为什么有如此优秀的性能呢？</p><p>其实核心点在于：<code>MapStruct</code>在编译期间，就生成了对象映射代码，确保了高性能，同时编译期间也可以发现可能存在的映射问题。</p><p>在上面的<code>TestConverter</code>中，经过代码编译后，<code>MapStruct</code>会生成一个<code>TestConverterImpl</code>的实现类，帮我们进行对象属性转换。</p><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Generated</span>(</span><br><span class="line">    value = <span class="string">"org.mapstruct.ap.MappingProcessor"</span>,</span><br><span class="line">    date = <span class="string">"2020-08-17T17:00:26+0800"</span>,</span><br><span class="line">    comments = <span class="string">"version: 1.3.1.Final, compiler: javac, environment: Java 9 (Oracle Corporation)"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConverterImpl</span> <span class="keyword">implements</span> <span class="title">TestConverter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestDTO <span class="title">do2dto</span><span class="params">(TestDO testDO)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( testDO == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TestDTO testDTO = <span class="keyword">new</span> TestDTO();</span><br><span class="line"></span><br><span class="line">        testDTO.setA( testDO.getA() );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> testDTO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在运行之前就相当于我们手写<code>get/set</code>方法，相比反射，速度更快。</p><p>其编译工作主要由<code>mapstruct-processor</code>包完成。</p><p>PS：<code>PersonConverterImpl</code>的相关实现这儿就不展示了，大家可以看下它是如何处理的，比如对于一些自定义方法等。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文介绍了一款Java对象映射工具，<code>MapStruct</code>。相比传统<code>BeanUtils</code>有着更高的性能。</p><p>映射代码在编译期间生成，相当于替我们手写了<code>get/set</code>，不仅相比反射具有很好的性能，同时还可以在编译期间发现可能存在的映射问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="MapStruct" scheme="https://www.sakuratears.top/tags/MapStruct/"/>
    
  </entry>
  
  <entry>
    <title>CountDownLatch和CylicBarrier以及Semaphare</title>
    <link href="https://www.sakuratears.top/blog/CountDownLatch%E5%92%8CCylicBarrier%E4%BB%A5%E5%8F%8ASemaphare.html"/>
    <id>https://www.sakuratears.top/blog/CountDownLatch和CylicBarrier以及Semaphare.html</id>
    <published>2020-08-17T12:46:00.000Z</published>
    <updated>2020-08-17T12:48:36.902Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>再说这三个工具时，需要先了解一下AQS框架，所谓AQS，指的是<code>AbstractQueuedSynchronizer</code>，它提供了一种实现阻塞锁和一系列依赖FIFO等待队列的同步器的框架，<code>ReentrantLock</code>、<code>Semaphore</code>、<code>CountDownLatch</code>、<code>CyclicBarrier</code>等并发类均是基于AQS来实现的，具体用法是通过继承AQS实现其模板方法，然后将子类作为同步组件的内部类。</p><p>我们这篇文章先了解下这三个AQS框架工具类，后面在整体入手了解AQS框架的一些特点及源码。</p><p>无论是这几个工具类，还是AQS框架，都是JDK1.5之后出现的，位于<code>java.util.concurrent</code>包下，是由著名的<code>Doug Lea</code>操刀实现并完成设计的。</p><p>PS：<code>ReentrantLock</code>我在另一篇文章有介绍，这儿就不过多叙述。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p><code>CountDownLatch</code> 作为一种同步辅助工具，允许一个或多个线程等待，直到在其他线程中执行的一组操作完成。</p><p>我们可以使用给定的<code>count</code>初始化一个<code>CountDownLatch</code>。</p><p><code>CountDownLatch</code>有两个关键方法，<code>countDown</code>和<code>await</code>。</p><p>当我们调用<code>countDown</code>方法时，<code>await</code>方法会被阻塞，直到计数<code>count</code>为0后，所有的等待线程才会都被释放。</p><p>需要注意<code>CountDownLatch</code>是一次性的，计数不会重置。如果我们需要一个可以重置的计数工具版本，我们可以使用<code>CyclicBarrier</code></p><p>我们可以使用这个同步工具做一些事情，实现一些功能。</p><p>比如初始化一个计数为1的<code>CountDownLatch</code>，可以作为一个简单的开/关锁，或者阀门。所有调用<code>await</code>的线程都在阀门处等待，直到它被一个调用<code>countDown</code>的线程打开。<br>初始化为N的<code>CountDownLatch</code>可以让一个线程等待，直到N个线程已经完成某个动作，或者某个动作已经完成N次。</p><p><code>CountDownLatch</code>的一个特点是，它不要求调用<code>countDown</code>的线程在继续执行之前等待计数为零，它只是阻止任何线程通过<code>await</code>，直到所有线程都通过。</p><p>另一种典型的用法是将一个问题分成N个部分，用<code>Runnable</code>（或<code>Callable</code>）描述每个部分，该<code>Runnable</code>执行该部分并在<code>CountDownLatch</code>上向下计数，然后将所有<code>Runnable</code>排队到一个执行器。当所有子任务完成后，协调线程将能够通过<code>await</code>方法。(当需要重复计数时，请使用<code>CyclicBarrier</code>)</p><p>我们以一个例子来看下<code>CountDownLatch</code>的使用。</p><p>例子：我们以田径赛跑为例，运动员在裁判枪响后同时起跑，因此起跑时需要使用<code>CountDownLatch</code>来控制，跑完后，每个运动员结束时间是不同的，我们需要等所有运动员完成后统计他们的时间进行比较。</p><p>相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//我们以田径跑步运动来进行举例，假设有十名运动员，裁判枪响后起跑，全部跑完后统计成绩。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个定长线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService executorService = Executors.newFixedThreadPool(N);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="comment">//开始标志</span></span><br><span class="line">        CountDownLatch startSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//结束标志</span></span><br><span class="line">        CountDownLatch doneSignal = <span class="keyword">new</span> CountDownLatch(N);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            executorService.submit(<span class="keyword">new</span> Runner(startSignal,doneSignal,i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"起跑预备阶段---&gt;"</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        startSignal.countDown();</span><br><span class="line">        System.out.println(<span class="string">"裁判枪响，所有人开跑---&gt;"</span>);</span><br><span class="line">        doneSignal.await();</span><br><span class="line">        System.out.println(<span class="string">"跑步完成，统计每个人的时间"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runner</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Map</span>&lt;<span class="title">Integer</span>,<span class="title">Integer</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch startSignal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch doneSignal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer i;</span><br><span class="line"></span><br><span class="line">    Runner(CountDownLatch startSignal, CountDownLatch doneSignal,Integer i) &#123;</span><br><span class="line">        <span class="keyword">this</span>.startSignal = startSignal;</span><br><span class="line">        <span class="keyword">this</span>.doneSignal = doneSignal;</span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;Integer,Integer&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> time;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            startSignal.await();</span><br><span class="line">            time = doRun();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">            time = -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            doneSignal.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(i,time);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doRun</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> time = random.nextInt(<span class="number">2000</span>)+<span class="number">10000</span>;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(time);</span><br><span class="line">        System.out.println(<span class="string">"第"</span> +i+ <span class="string">"位运动员"</span> + <span class="string">"running......耗时"</span>+ (<span class="keyword">double</span>)(time)/<span class="number">1000</span> + <span class="string">"秒"</span>);</span><br><span class="line">        <span class="keyword">return</span> time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其具体逻辑如下：</p><ol><li>预备起跑阶段（主线程sleep 10s用于模拟准备），一个名为<code>startSignal</code>的<code>CountDownLatch</code>模拟裁判，计数为1。</li><li>使用<code>startSignal.countDown()</code>方法对每个<code>Runner</code>的<code>doRun();</code>进行阻塞（<code>startSignal.await();</code>），模拟裁判发枪。</li><li>发枪后<code>startSignal.await();</code>方法通过，每个<code>Runner</code>执行自己的<code>doRun();</code>方法完成跑步。</li><li>在统计最后成绩时，使用了<code>doneSignal</code>，计数为N，我们只有当全部运动员完成后才能对其进行排名。</li></ol><p>相关输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">起跑预备阶段---&gt;</span><br><span class="line">裁判枪响，所有人开跑---&gt;</span><br><span class="line">第9位运动员running......耗时10.169秒</span><br><span class="line">第8位运动员running......耗时10.279秒</span><br><span class="line">第7位运动员running......耗时10.432秒</span><br><span class="line">第0位运动员running......耗时10.465秒</span><br><span class="line">第1位运动员running......耗时10.633秒</span><br><span class="line">第5位运动员running......耗时10.748秒</span><br><span class="line">第2位运动员running......耗时10.993秒</span><br><span class="line">第3位运动员running......耗时11.333秒</span><br><span class="line">第6位运动员running......耗时11.337秒</span><br><span class="line">第4位运动员running......耗时11.847秒</span><br><span class="line">跑步完成，统计每个人的时间</span><br></pre></td></tr></table></figure><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p><code>CyclicBarrier</code>一种同步辅助工具，它允许一组线程都等待对方到达公共障碍点。<br>在涉及固定大小的线程的程序中，CyclicBarriers非常有用，这些线程必须偶尔相互等待。</p><p>该屏障之所以称为循环屏障（<code>CyclicBarrier</code>），是因为它可以在等待的线程被释放之后被重用。</p><p><code>CyclicBarrier</code>支持一个可选的“<code>Runnable</code>”命令，该命令在每个屏障点运行一次，在队列中的最后一个线程到达之后，但是在所有线程被释放之前运行。可通过构造函数传入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个屏障操作对于在任何一个线程继续之前更新共享状态非常有帮助的。</p><p>我们下面来看个例子，这儿我们使用大文件拆分成小文件进行上传来举例。如下，先上代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个可缓存的线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        List&lt;<span class="keyword">byte</span>[]&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (FileInputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"C:\\Users\\DELL-3020\\Desktop\\hacker's delight.pdf"</span>))&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024000</span>];</span><br><span class="line">            <span class="comment">// 读入多个字节到字节数组中，byteRead为一次读入的字节数</span></span><br><span class="line">            <span class="keyword">while</span> (input.read(buffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">                list.add(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(list.size(),()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">"上传已全部完成"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        List&lt;Future&lt;Boolean&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            Future&lt;Boolean&gt; future =  executorService.submit(<span class="keyword">new</span> UploadHelper(i,list.get(i),cyclicBarrier));</span><br><span class="line">            futures.add(future);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (Future&lt;Boolean&gt; future : futures) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!future.get().equals(Boolean.TRUE))&#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"上传结果"</span>+flag);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UploadHelper</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> N;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] bytes;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier barrier;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UploadHelper</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">byte</span>[] bytes, CyclicBarrier barrier)</span> </span>&#123;</span><br><span class="line">        N = n;</span><br><span class="line">        <span class="keyword">this</span>.bytes = bytes;</span><br><span class="line">        <span class="keyword">this</span>.barrier = barrier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = doUpload(N,bytes);</span><br><span class="line">        barrier.await();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上传逻辑</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doUpload</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">byte</span>[] bytes)</span></span>&#123;</span><br><span class="line">        <span class="comment">//假设的上传逻辑</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">            Random random = <span class="keyword">new</span> Random();</span><br><span class="line">            <span class="keyword">int</span> time = random.nextInt(<span class="number">2000</span>)+<span class="number">10000</span>;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(time);</span><br><span class="line">            System.out.println(<span class="string">"第"</span>+ n + <span class="string">"份数据上传耗时"</span>+ (<span class="keyword">double</span>)(time)/<span class="number">1000</span> + <span class="string">"秒"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>UploadHelper</code>类用来处理上传逻辑，我们将文件按照1M（1024000bit）进行分割，<code>UploadHelper</code>接受三个参数，n表示第多少份，用于上传完成后数据的按顺序拼接。bytes表示每份的数据。barrier屏障用于监测所有上传是否完成，完成后执行新的逻辑（比如通知用户上传完成等）。</p><p>我们运行后，结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">第8份数据上传耗时10.399秒</span><br><span class="line">第3份数据上传耗时10.466秒</span><br><span class="line">第0份数据上传耗时10.609秒</span><br><span class="line">第2份数据上传耗时10.71秒</span><br><span class="line">第6份数据上传耗时10.915秒</span><br><span class="line">第9份数据上传耗时11.093秒</span><br><span class="line">第10份数据上传耗时11.167秒</span><br><span class="line">第5份数据上传耗时11.2秒</span><br><span class="line">第1份数据上传耗时11.521秒</span><br><span class="line">第7份数据上传耗时11.536秒</span><br><span class="line">第4份数据上传耗时11.905秒</span><br><span class="line">上传已全部完成</span><br><span class="line">上传结果true</span><br></pre></td></tr></table></figure><p>可以看到<code>上传已全部完成</code>是在上传全部完成后输出的，这句话在<code>CyclicBarrier</code>构造器的<code>Runnable</code>参数里。</p><p>其实这儿我们也可以模拟一个接受逻辑，通过屏障操作，当我们接收到全部数据后，最后将所有数据合并在一起。</p><p>这儿的代码就交给大家去实现了。</p><p>这儿有一点需要注意，如果屏障操作(barrier)不依赖于被挂起的线程，那么任何线程都可以在它被释放时执行我们想要的动作。为实现这一点，调用<code>await</code>方法会返回<code>barrier</code>处该线程的到达索引。然后我们可以选择哪个线程执行<code>barrier</code>操作。</p><p>比如我们在<code>UploadHelper</code>的<code>call()</code>方法里添上如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = doUpload(N,bytes);</span><br><span class="line">    <span class="keyword">if</span>(barrier.await()==N)&#123;</span><br><span class="line">        System.out.println(<span class="string">"第"</span>+N+<span class="string">"个线程执行barrier操作"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以多次运行，可以发现每次barrier的线程都是不一样的。有可能有一个，也有可能多个。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">第4份数据上传耗时10.04秒</span><br><span class="line">第1份数据上传耗时10.196秒</span><br><span class="line">第2份数据上传耗时10.235秒</span><br><span class="line">第3份数据上传耗时10.282秒</span><br><span class="line">第6份数据上传耗时10.547秒</span><br><span class="line">第9份数据上传耗时10.713秒</span><br><span class="line">第5份数据上传耗时10.784秒</span><br><span class="line">第7份数据上传耗时11.146秒</span><br><span class="line">第10份数据上传耗时11.68秒</span><br><span class="line">第8份数据上传耗时11.787秒</span><br><span class="line">第0份数据上传耗时11.864秒</span><br><span class="line">上传已全部完成</span><br><span class="line">第0个线程执行barrier操作</span><br><span class="line">第6个线程执行barrier操作</span><br><span class="line">上传结果true</span><br></pre></td></tr></table></figure><p>这时候我们可以把<code>barrier.await()==N</code> 变为<code>barrier.await()==5</code>就可以让第5个线程执行barrier操作，而不是其他的线程执行<code>barrier</code>。</p><p><code>CyclicBarrier</code>使用了<code>“all-or-none breakage”</code>模型，指的是所有互相等待的线程，要么一起通过<code>barrier</code>，要么一个都不要通过。</p><p>如果有一个线程因为中断、失败或者超时等原因失败了，则barrier会被<code>broken</code>，所有等待在该<code>barrier</code>上的线程都会抛出<code>BrokenBarrierException</code>（或者<code>InterruptedException</code>）。</p><p>比如我们在<code>UploadHelper</code>类里<code>doUpload</code>方法里添加如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设第5个线程异常了</span></span><br><span class="line"><span class="keyword">if</span>(N==<span class="number">5</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"第"</span>+N+<span class="string">"个线程处理出现异常"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们执行后可以发现上传永远完成不了，其它线程会在<code>barrier</code>处永远等待。</p><p>所以我们在编写代码时在内部方法要处理好可能出现的异常问题。</p><p>另外<code>CyclicBarrier</code>提供了一个<code>await(long timeout, TimeUnit unit)</code>方法，我们可以指定<code>await</code>的最长时间。</p><p>我们指定<code>await</code>时间为15s，同时在<code>doUpload</code>方法里设定第5个线程执行出现异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = doUpload(N,bytes);</span><br><span class="line">    barrier.await(<span class="number">15</span>,TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doUpload</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">byte</span>[] bytes)</span></span>&#123;</span><br><span class="line">    <span class="comment">//假设的上传逻辑</span></span><br><span class="line">    <span class="keyword">if</span>(N==<span class="number">5</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"第"</span>+N+<span class="string">"个线程处理出现异常"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> time = random.nextInt(<span class="number">2000</span>)+<span class="number">10000</span>;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(time);</span><br><span class="line">        System.out.println(<span class="string">"第"</span>+ n + <span class="string">"份数据上传耗时"</span>+ (<span class="keyword">double</span>)(time)/<span class="number">1000</span> + <span class="string">"秒"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行后我们就会看到<code>BrokenBarrierException</code>的出现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">第10份数据上传耗时10.037秒</span><br><span class="line">第2份数据上传耗时10.229秒</span><br><span class="line">第9份数据上传耗时10.287秒</span><br><span class="line">第0份数据上传耗时10.799秒</span><br><span class="line">第3份数据上传耗时11.025秒</span><br><span class="line">第4份数据上传耗时11.111秒</span><br><span class="line">第6份数据上传耗时11.863秒</span><br><span class="line">第8份数据上传耗时11.887秒</span><br><span class="line">第1份数据上传耗时11.904秒</span><br><span class="line">第7份数据上传耗时11.961秒</span><br><span class="line">Exception in thread &quot;main&quot; java.util.concurrent.ExecutionException: java.util.concurrent.BrokenBarrierException</span><br><span class="line">at java.base/java.util.concurrent.FutureTask.report(FutureTask.java:122)</span><br><span class="line">at java.base/java.util.concurrent.FutureTask.get(FutureTask.java:191)</span><br><span class="line">at com.zwt.helputils.utils.aqs.CyclicBarrierDemo.main(CyclicBarrierDemo.java:44)</span><br><span class="line">Caused by: java.util.concurrent.BrokenBarrierException</span><br><span class="line">at java.base/java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:251)</span><br><span class="line">at java.base/java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:436)</span><br><span class="line">at com.zwt.helputils.utils.aqs.UploadHelper.call(CyclicBarrierDemo.java:66)</span><br><span class="line">at com.zwt.helputils.utils.aqs.UploadHelper.call(CyclicBarrierDemo.java:52)</span><br><span class="line">at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)</span><br><span class="line">at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)</span><br><span class="line">at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)</span><br><span class="line">at java.base/java.lang.Thread.run(Thread.java:844)</span><br></pre></td></tr></table></figure><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p><code>Semaphore</code>也被称为计数信号量，从概念上来讲，它维护一组许可。</p><p>主要方法有两个，<code>acquire</code>和<code>release</code>，<code>acquire</code>方法用来阻止获取者获得资源许可，直到许可存在可用的为止。<code>release</code>用于添加一个许可，潜在的意义相当于释放了一个阻塞的获取者。</p><p>需要注意的是<code>Semaphore</code>并不会保存可用资源对象，而是只保留可用资源数量的计数，并进行许可或阻塞操作。</p><p><code>Semaphore</code>通常用于限制能够访问某些(物理或逻辑)资源的线程数量。</p><p>比如我们有一个方法，如果需要对其进行并发限制，可以使用<code>Semaphore</code>来实现，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定数量为5的Semaphore</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span><span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="comment">//假设方法需要执行5s</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        log.info(<span class="string">"这是test方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 并发限制</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">limit</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        semaphore.acquire();</span><br><span class="line">        doSomething();</span><br><span class="line">        semaphore.release();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        SemaphoreDemo semaphoreDemo = <span class="keyword">new</span> SemaphoreDemo();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphoreDemo.limit();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码指定数量为5的<code>Semaphore</code>，<code>limit()</code>方法用来进行并发控制，如上代码的意思是最多允许5个线程调用<code>doSomething()</code>方法。</p><p>输出如下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">15:14:50.471 [Thread-1] INFO com.zwt.helputils.utils.aqs.SemaphoreDemo - 这是test方法</span><br><span class="line">15:14:50.470 [Thread-0] INFO com.zwt.helputils.utils.aqs.SemaphoreDemo - 这是test方法</span><br><span class="line">15:14:50.471 [Thread-7] INFO com.zwt.helputils.utils.aqs.SemaphoreDemo - 这是test方法</span><br><span class="line">15:14:50.471 [Thread-2] INFO com.zwt.helputils.utils.aqs.SemaphoreDemo - 这是test方法</span><br><span class="line">15:14:50.470 [Thread-3] INFO com.zwt.helputils.utils.aqs.SemaphoreDemo - 这是test方法</span><br><span class="line">//...注意这儿停顿5s</span><br><span class="line">15:14:55.476 [Thread-6] INFO com.zwt.helputils.utils.aqs.SemaphoreDemo - 这是test方法</span><br><span class="line">15:14:55.476 [Thread-11] INFO com.zwt.helputils.utils.aqs.SemaphoreDemo - 这是test方法</span><br><span class="line">15:14:55.476 [Thread-5] INFO com.zwt.helputils.utils.aqs.SemaphoreDemo - 这是test方法</span><br><span class="line">15:14:55.476 [Thread-4] INFO com.zwt.helputils.utils.aqs.SemaphoreDemo - 这是test方法</span><br><span class="line">15:14:55.477 [Thread-13] INFO com.zwt.helputils.utils.aqs.SemaphoreDemo - 这是test方法</span><br><span class="line">//...注意这儿停顿5s</span><br><span class="line">15:15:00.477 [Thread-12] INFO com.zwt.helputils.utils.aqs.SemaphoreDemo - 这是test方法</span><br><span class="line">15:15:00.477 [Thread-14] INFO com.zwt.helputils.utils.aqs.SemaphoreDemo - 这是test方法</span><br><span class="line">15:15:00.477 [Thread-10] INFO com.zwt.helputils.utils.aqs.SemaphoreDemo - 这是test方法</span><br><span class="line">15:15:00.478 [Thread-9] INFO com.zwt.helputils.utils.aqs.SemaphoreDemo - 这是test方法</span><br><span class="line">15:15:00.478 [Thread-8] INFO com.zwt.helputils.utils.aqs.SemaphoreDemo - 这是test方法</span><br></pre></td></tr></table></figure><p>当我们初始化数量为1的<code>Semaphore</code>时，此时只有一个可用许可，因此可以当做互斥锁来用。这种通常称为二进制信号量，因为它只有两种状态：1个可用许可，0个可用许可。</p><p>当我们使用这种方式时，相比较<code>java.util.concurrent.locks</code>包的锁实现，它有一些额外的特点：即“锁”可以由所有者以外的线程释放，因为<code>Semaphore</code>没有所有权的概念。</p><p>这在某些情况下是十分有用的，比如死锁恢复。</p><p>除了数量以外，<code>Semaphore</code>构造函数还可以接受一个“公平性”参数。</p><p>当参数设置为<code>false</code>时，<code>Semaphore</code>不能保证线程获得许可的顺序。也就是说，抢占是允许的，调用<code>acquire</code>的线程可以比正在等待的线程提前分配许可 ———— 逻辑上，新线程将自己放在等待线程队列的头部。</p><p>当参数为<code>true</code>时，<code>Semaphore</code>保证调用<code>acquire</code>方法的线程按照顺序获得许可（先进先出FIFO）。需要注意FIFO的顺序适用于这些方法中特定的内部执行点。因此，一个线程可能在另一个线程之前调用<code>acquire</code>，但是在另一个线程之后到达顺序点，从该方法返回时也是如此。另外，<code>tryAcquire</code>方法不支持公平性设置，但是会接受任何可用的许可。</p><p>通常，用于控制资源访问的<code>Semaphore</code>应该初始化为公平，以确保没有线程因为访问资源而耗尽。当将<code>Semaphore</code>用于其他类型的同步控制时，非公平的吞吐量优势常常超过公平性<code>Semaphore</code>。</p><p>另外，<code>Semaphore</code>还提供了<code>acquire(int)</code>和<code>release(int)</code>等方便方法，这些方法通常比循环更有效。</p><p>但是，它们没有优先顺序，例如，如果线程A调用<code>s.acquire(3)</code>，线程B调用<code>s.acquire(2)</code>，并且有两个许可可用，那么不能保证线程B会获得它们，除非它的<code>acquire</code>先来，并且信号量<code>s</code>处于公平模式。</p><h2 id="AbstractQueuedSynchronizer"><a href="#AbstractQueuedSynchronizer" class="headerlink" title="AbstractQueuedSynchronizer"></a>AbstractQueuedSynchronizer</h2><p>我们可以看到无论是<code>CountDownLatch</code>、<code>CyclicBarrier</code>（底层<code>ReentrantLock</code>）、<code>Semaphore</code>还是<code>ReentrantLock</code>，底层均是由<code>AbstractQueuedSynchronizer</code>实现的。</p><p>我们将在后面来分析下AQS框架的一些特点和源码。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文对<code>CountDownLatch</code>、<code>CyclicBarrier</code>和<code>Semaphore</code>进行了一些分析，列举的它们的一些特点和用法。</p><p>对于<code>CountDownLatch</code>，其是在做减法，本身不能重置计数，只能使用一次。</p><p><code>CyclicBarrier</code>是做加法，通过<code>reset()</code>方法可以重置计数，可以多次使用，不过重置需要等到计数结束。</p><p><code>Semaphore</code>主要控制对资源的访问，可以实现控制并发线程的数量，而<code>CountDownLatch</code>和<code>CyclicBarrier</code>是无法实现此功能的，而且<code>Semaphore</code>在控制资源访问时，本身相当于信号量控制标识，不会对资源本身加锁。</p><p>以上就是三种线程同步工具的全部内容。</p><h1 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h1><p>相关代码可在我的<a href="https://github.com/javazwt" rel="external nofollow noopener noreferrer" target="_blank">GitHub</a>上找到。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="CountDownLatch" scheme="https://www.sakuratears.top/tags/CountDownLatch/"/>
    
      <category term="CylicBarrier" scheme="https://www.sakuratears.top/tags/CylicBarrier/"/>
    
      <category term="Semaphare" scheme="https://www.sakuratears.top/tags/Semaphare/"/>
    
  </entry>
  
  <entry>
    <title>工作中遇到的问题总结</title>
    <link href="https://www.sakuratears.top/blog/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.html"/>
    <id>https://www.sakuratears.top/blog/工作中遇到的问题总结.html</id>
    <published>2020-08-09T01:27:00.000Z</published>
    <updated>2020-08-09T01:33:43.569Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="工作问题总结"><a href="#工作问题总结" class="headerlink" title="工作问题总结"></a>工作问题总结</h1><p>总结了工作中遇到的一些问题及bug。</p><h2 id="Mysql-group-by-不区分大小写的问题"><a href="#Mysql-group-by-不区分大小写的问题" class="headerlink" title="Mysql group by 不区分大小写的问题"></a>Mysql group by 不区分大小写的问题</h2><p>在Mysql中，如果不特意指定字段，字段数据在group by时是不区分大小写的。</p><p>如下图：</p><p>对于user表，我们有4个用户，通过user_name group by之后我们只得到了两条数据。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-648.jpg" alt="upload successful"></p><p>可以看到，如果不特殊处理的话，Mysql在group by时是不区分大小写的。</p><p>解决方案有两个，都是通过<code>BINARY</code>关键字解决：</p><p><code>BINARY</code> 运算符将紧随其后的<code>string</code> 转换为 二进制字符串。</p><p>主要用来强制进行按字节进行比较的数据。这使得字符串比较是区分大小写的, 不管原始的列定义是否是 <code>BINARY</code> 或者 <code>BLOB</code>。<code>BINARY</code> 也对字符串末尾的空格敏感。</p><ol><li><p>对于查询，我们使用<code>BINARY</code> 关键字。如下图效果：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_name,<span class="keyword">COUNT</span>(<span class="number">1</span>) <span class="keyword">from</span> <span class="string">`user`</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="built_in">BINARY</span> user_name;</span><br></pre></td></tr></table></figure><p> <img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-649.jpg" alt="upload successful"></p><p> 可以看到得到了我们想要的结果。</p></li><li><p>当然也可以给表结构字段添加<code>BINARY</code>来解决，这会改变表的字符集及排序规则。</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`user`</span></span><br><span class="line"><span class="keyword">MODIFY</span> <span class="keyword">COLUMN</span> <span class="string">`user_name`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="built_in">BINARY</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户名'</span>;</span><br></pre></td></tr></table></figure><p> 得到的表结构如下，我们再进行group by查询，可以看到指定字段已经区分了大小写。</p><p> <img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-650.jpg" alt="upload successful"></p><p> 当然对于大小写敏感的字段数据，我们可以在建表的时候直接指定字段的字符集及排序规则。</p></li></ol><h2 id="List去重问题"><a href="#List去重问题" class="headerlink" title="List去重问题"></a>List去重问题</h2><ol><li><p>当然我们可以使用Set进行去重。</p></li><li><p>对于Java 8之后，我们可以使用流进行去重，如下语法：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().distinct().collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>对于对象列表的话，我们应重写对象的<code>hashCode()</code>和<code>equals()</code>方法，再使用流的<code>distinct()</code>方法来进行去重。</p><p><code>distinct()</code>方法不提供按照属性对对象列表进行去重的直接实现。它是基于<code>hashCode()</code>和<code>equals()</code>工作的。</p><p>我们如果想按照属性对对象列表进行去重，除了使用普通循环处理外，还可以构建一个我们自己的<code>Predicate</code>实例，通过流过滤来实现，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createDate;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Phone</span><span class="params">(String phone, LocalDateTime createDate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.phone = phone;</span><br><span class="line">        <span class="keyword">this</span>.createDate = createDate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Phone&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> Phone(<span class="string">"11111"</span>, LocalDateTime.of(<span class="number">2020</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">11</span>,<span class="number">00</span>,<span class="number">00</span>)));</span><br><span class="line">        list.add(<span class="keyword">new</span> Phone(<span class="string">"22222"</span>, LocalDateTime.of(<span class="number">2020</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">00</span>,<span class="number">00</span>)));</span><br><span class="line">        list.add(<span class="keyword">new</span> Phone(<span class="string">"44444"</span>, LocalDateTime.of(<span class="number">2020</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">00</span>,<span class="number">00</span>)));</span><br><span class="line">        list.add(<span class="keyword">new</span> Phone(<span class="string">"11111"</span>, LocalDateTime.of(<span class="number">2020</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">00</span>,<span class="number">00</span>)));</span><br><span class="line">        list.add(<span class="keyword">new</span> Phone(<span class="string">"22222"</span>, LocalDateTime.of(<span class="number">2020</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">11</span>,<span class="number">00</span>,<span class="number">00</span>)));</span><br><span class="line"></span><br><span class="line">        list.stream().filter(distinctByKey(Phone::getCreateDate)).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Predicate&lt;T&gt; <span class="title">distinctByKey</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ?&gt; keyExtractor)</span> </span>&#123;</span><br><span class="line">        Map&lt;Object,Boolean&gt; seen = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> t -&gt; seen.putIfAbsent(keyExtractor.apply(t), Boolean.TRUE) == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其关键方法就是<code>distinctByKey</code>方法，这个方法原理很简单，我们将对象属性放入HashMap中，通过它的<code>putIfAbsent</code>来判断是否放入成功，不成功返回false，<code>filter</code>自动过滤此对象。</p><p>上面的例子中，我们如果在对phone号码进行去重的时候，只想要时间比较新的怎么办呢？</p><p>很简单，我们只需在处理是先对流按照时间进行排序即可，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list.stream().sorted(Comparator.comparing(Phone::getCreateDate).reversed())</span><br><span class="line">                .filter(distinctByKey(Phone::getCreateDate)).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h2 id="Mysql字符集问题"><a href="#Mysql字符集问题" class="headerlink" title="Mysql字符集问题"></a>Mysql字符集问题</h2><p>我在插入Mysql数据库表情等特殊符号时遇到了如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">......Cause: java.sql.SQLException: Incorrect string value: &apos;\xF0\x9D\x91\x80\xF0\x9D...&apos; for column &apos;xxxxx&apos; at row 1......</span><br></pre></td></tr></table></figure><p>如果我们的目标表字符集设置的是<code>CHARSET=utf8mb4</code>但仍是有这种问题，可能是Mysql数据库连接的字符集不正确。</p><p>我们可以通过<code>SHOW VARIABLES LIKE ‘character_set_%’;</code>来查看当前Mysql数据库连接字符集。如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-651.jpg" alt="upload successful"></p><p>其中：</p><ul><li>character_set_client：指客户端字符集属性</li><li>character_set_connection：指连接字符集属性</li><li>character_set_database：指数据库字符集属性</li><li>character_set_filesystem：指文件系统字符集属性</li><li>character_set_results：指返回结果字符集属性</li><li>character_set_server：指服务端字符集属性</li><li>character_set_system：指系统字符集属性</li><li>character_sets_dir：指字符集路径</li></ul><p>影响我们保存和读取的主要为<code>character_set_client</code>、<code>character_set_connection</code>和<code>character_set_results</code>这三个属性。</p><p>比如下面图示，我们保存数据失败了。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-652.jpg" alt="upload successful"></p><p>这时候我们设置一下这三个属性为<code>utf8mb4</code>即可。如下:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SET</span> character_set_client = utf8mb4;</span><br><span class="line"><span class="built_in">SET</span> character_set_results = utf8mb4;</span><br><span class="line"><span class="built_in">SET</span> character_set_connection = utf8mb4;</span><br></pre></td></tr></table></figure><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-653.jpg" alt="upload successful"></p><p>PS:这时候该表的<code>CHARSET</code>需要为<code>utf8mb4</code>。</p><p>这三个设置也可以用一条设置代替。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SET</span> NAMES 'utf8mb4';</span><br></pre></td></tr></table></figure><p>需要注意的是这种设置只在本次连接中有效，当连接中断时，需要重新设置。</p><p>我们在开发时，程序调用，可以通过<code>jdbcUrl</code>进行设置。如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbc.url=jdbc:mysql://xx:xx:xxx:xxx/test?useUnicode=true&amp;amp;characterEncoding=utf8mb4</span><br></pre></td></tr></table></figure><p>出现上面异常一般的解决步骤：</p><ol><li><p>检查数据表字符集是不是<code>utf8mb4</code>，不是的话需要通过如下语句进行修改。</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name [[<span class="keyword">DEFAULT</span>] <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> charset_name] [<span class="keyword">COLLATE</span> collation_name]</span><br></pre></td></tr></table></figure></li><li><p>检查<code>character_set_client</code>、<code>character_set_connection</code>和<code>character_set_results</code>这三个属性的设置，一般情况下我们在程序里配置<code>characterEncoding=utf8mb4</code>即可。</p></li></ol><h2 id="Java-过滤-utf8mb4-字符"><a href="#Java-过滤-utf8mb4-字符" class="headerlink" title="Java 过滤 utf8mb4 字符"></a>Java 过滤 utf8mb4 字符</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 过滤utf8mb4字符</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> text</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">filterOffUtf8Mb4</span><span class="params">(String text)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = text.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(bytes.length);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; bytes.length) &#123;</span><br><span class="line">        <span class="keyword">short</span> b = bytes[i];</span><br><span class="line">        <span class="keyword">if</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            buffer.put(bytes[i++]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 去掉符号位</span></span><br><span class="line">        b += <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (((b &gt;&gt; <span class="number">5</span>) ^ <span class="number">0x6</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            buffer.put(bytes, i, <span class="number">2</span>);</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (((b &gt;&gt; <span class="number">4</span>) ^ <span class="number">0xE</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            buffer.put(bytes, i, <span class="number">3</span>);</span><br><span class="line">            i += <span class="number">3</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (((b &gt;&gt; <span class="number">3</span>) ^ <span class="number">0x1E</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            i += <span class="number">4</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (((b &gt;&gt; <span class="number">2</span>) ^ <span class="number">0x3E</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            i += <span class="number">5</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (((b &gt;&gt; <span class="number">1</span>) ^ <span class="number">0x7E</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            i += <span class="number">6</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            buffer.put(bytes[i++]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    buffer.flip();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(buffer.array(), StandardCharsets.UTF_8);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法可以过滤掉utf8mb4字符（4字节的UTF-8字符）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="工作" scheme="https://www.sakuratears.top/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Java代理模式</title>
    <link href="https://www.sakuratears.top/blog/Java%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.html"/>
    <id>https://www.sakuratears.top/blog/Java代理模式.html</id>
    <published>2020-08-02T09:36:00.000Z</published>
    <updated>2020-08-02T09:48:45.380Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>代理(Proxy)是一种设计模式，提供了间接对目标对象进行访问的方式，即通过代理对象访问目标对象。</p><p>这样做的好处是：可以在目标对象实现的功能上，增加额外的功能补充，即扩展目标对象的功能。</p><p>这就符合了设计模式的开闭原则，即在对既有代码不改动的情况下进行功能的扩展。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>我们一般认为Java中有三种代理模式：静态代理、动态代理和Cglib代理。</p><p>其中Cglib代理需要借助cglib三方jar包实现。</p><p>我们来看下三种代理模式，以及它们的一些特点。</p><p>我们下面以代码来看下代理的例子。</p><p>我们现在有一个<code>Subject</code>接口，同时有两个实现类<code>RunSubject</code>和<code>SingSubject</code>，接口中有一个方法<code>doSomething</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 做一些事</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doSomething</span><span class="params">(String str)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doSomething</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(str + <span class="string">" running..."</span>);</span><br><span class="line">        <span class="keyword">return</span> str + <span class="string">" running..."</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doSomething</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(str+<span class="string">" singing..."</span>);</span><br><span class="line">        <span class="keyword">return</span> str+<span class="string">" singing..."</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们想在<code>doSomething</code>之前和之后记录一些日志，如何实现呢。</p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>静态代理在使用时，需要定义接口或者父类，被代理对象与代理对象一起实现相同的接口或者是继承相同父类。从而实现我们想要的功能。</p><p>根据上面所说，我们可以定义一个StaticProxy类实现此功能，该类需要实现<code>Subject</code>接口，当然，我们也需要被代理对象，以实现我们<code>doSomething</code>的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkStaticProxyImpl</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 被代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Subject subject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JdkStaticProxyImpl</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doSomething</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用之前的逻辑</span></span><br><span class="line">        System.out.println(<span class="string">"在方法调用之前记录日志-----&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        String returnValue = subject.doSomething(str);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用之后的逻辑</span></span><br><span class="line">        System.out.println(<span class="string">"在方法调用之后记录日志-----&gt;"</span>);</span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subject runSubject = <span class="keyword">new</span> RunSubject();</span><br><span class="line">        Subject subject = <span class="keyword">new</span> JdkStaticProxyImpl(runSubject);</span><br><span class="line">        subject.doSomething(<span class="string">"ccc"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在方法调用之前记录日志-----&gt;</span><br><span class="line">ccc running...</span><br><span class="line">在方法调用之后记录日志-----&gt;</span><br></pre></td></tr></table></figure><p>这种代理方法优点是可以在不修改目标对象的功能前提下，对目标功能扩展。</p><p>但缺点也十分明显，上面只是对于<code>Subject</code>的代理，如果我们有其他的接口及其实现类，如果也需要该扩展功能，那么也要为其写代理类。</p><p>会导致我们会有很多代理类，且如果接口增加方法，那么我们也需要修改代理类，即便这个新增的方法可能不需要额外扩展功能。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>上面静态代理的缺点比较明显，如何解决呢？</p><p>我们可以使用动态代理，Java中为我们提供了生成代理对象的API，<code>java.lang.reflect.Proxy</code>。</p><p>实现代理需要调用<code>newProxyInstance</code>方法，它接受三个参数，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>ClassLoader loader：指定当前目标对象使用类加载器，获取加载器的方法是固定的，我们一般使用 <code>getClass().getClassLoader();</code>即可获取目标对象的类加载器。</li><li>Class&lt;?&gt;[] interfaces：目标对象实现的接口的类型，使用泛型方式确认类型，一般使用<code>getClass().getInterfaces();</code>方式取得。</li><li>InvocationHandler h：事件处理，执行目标对象的方法时，会触发事件处理器的方法，会把当前执行目标对象的方法作为参数传入。这个需要我们手动实现要实现的扩展功能。</li></ul><p>对于上面的<code>Subject</code>接口的实现类<code>RunSubject</code>和<code>SingSubject</code>，我们以代码来看下JDK动态代理如何实现功能扩展。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicProxyImpl</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object subject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JdkDynamicProxyImpl</span><span class="params">(Object subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//调用之前的逻辑</span></span><br><span class="line">        System.out.println(<span class="string">"在"</span>+method+<span class="string">"方法调用之前记录日志-----&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用</span></span><br><span class="line">        Object returnValue = method.invoke(subject, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用之后的逻辑</span></span><br><span class="line">        System.out.println(<span class="string">"在"</span>+method+<span class="string">"方法调用之后记录日志-----&gt;"</span>);</span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subject runSubject = <span class="keyword">new</span> RunSubject();</span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> JdkDynamicProxyImpl(runSubject);</span><br><span class="line">        ClassLoader loader = runSubject.getClass().getClassLoader();</span><br><span class="line">        Class[] interfaces = runSubject.getClass().getInterfaces();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Subject subject = (Subject) Proxy.newProxyInstance(loader, interfaces, handler);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"动态代理对象的类型："</span>+subject.getClass().getName());</span><br><span class="line"></span><br><span class="line">        subject.doSomething(<span class="string">"aaa"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行后如下输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">动态代理对象的类型：com.sun.proxy.$Proxy0</span><br><span class="line">在public abstract java.lang.String com.zwt.helputils.utils.proxy.Subject.doSomething(java.lang.String)方法调用之前记录日志-----&gt;</span><br><span class="line">aaa running...</span><br><span class="line">在public abstract java.lang.String com.zwt.helputils.utils.proxy.Subject.doSomething(java.lang.String)方法调用之后记录日志-----&gt;</span><br></pre></td></tr></table></figure><p>上面的<code>JdkDynamicProxyImpl</code>类，我们不仅可以用来代理<code>Subject</code>接口的实现类以实现日志增强功能，如果别的类（比如A）也想实现日志增强，那么只需要A实现一个自己的接口 AInterface 即可。</p><p>可以看到，对于一种增强，我们创建一个代理类即可，这比静态代理要方便简洁很多。</p><p>但这种动态代理有一个缺陷，就是被代理对象（目标对象）一定要实现接口，否则无法实现动态代理。</p><h2 id="Cglib代理"><a href="#Cglib代理" class="headerlink" title="Cglib代理"></a>Cglib代理</h2><p>上面的两种代理方式，也可以认为JDK传统的代理方式，目标对象必须实现接口，否则无法完成代理，但实际中，不一定所有的对象都会实现接口。</p><p>对于没有接口的对象，如果要实现对其的代理，应该如何实现呢？</p><p>我们可以使用继承目标类以目标对象子类的方式实现代理，这种方法就叫做Cglib代理，也叫作子类代理，它是在内存中构建一个子类对象从而实现对目标对象功能的扩展。</p><p>要实现Cglib代理，需要引入三方Cglib包，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/cglib/cglib --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cglib&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxyImpl</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CglibProxyImpl</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">// 回调方法</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//调用之前的逻辑</span></span><br><span class="line">        System.out.println(<span class="string">"在"</span>+method+<span class="string">"方法调用之前记录日志-----&gt;"</span>);</span><br><span class="line">        Object value = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        <span class="comment">//调用之后的逻辑</span></span><br><span class="line">        System.out.println(<span class="string">"在"</span>+method+<span class="string">"方法调用之后记录日志-----&gt;"</span>);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subject runSubject = <span class="keyword">new</span> RunSubject();</span><br><span class="line">        Subject subject1 = (Subject) <span class="keyword">new</span> CglibProxyImpl(runSubject).getInstance();</span><br><span class="line">        subject1.doSomething(<span class="string">"bbb"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在<span class="keyword">public</span> java.lang.String com.zwt.helputils.utils.proxy.RunSubject.doSomething(java.lang.String)方法调用之前记录日志-----&gt;</span><br><span class="line">bbb running...</span><br><span class="line">在<span class="keyword">public</span> java.lang.String com.zwt.helputils.utils.proxy.RunSubject.doSomething(java.lang.String)方法调用之后记录日志-----&gt;</span><br></pre></td></tr></table></figure><p>这种代理方式显然有一个缺点，就是当目标对象类是<code>final</code>的时候，我们是无法继承目标类的，因此也就无法实现Cglib代理。</p><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p>上面我们总结了3种代理方式，及其使用，对于Jdk动态代理和Cglib动态代理代码，我们可以整合成一个<code>Factory</code>，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object subject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxyFactory</span><span class="params">(Object subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"JDK"</span>:</span><br><span class="line">                <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                        subject.getClass().getClassLoader(),</span><br><span class="line">                        subject.getClass().getInterfaces(),</span><br><span class="line">                        <span class="keyword">new</span> JdkDynamicProxyImpl(subject)</span><br><span class="line">                );</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"Cglib"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> CglibProxyImpl(subject).getInstance();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"找不到指定的代理方式！！！！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subject runSubject = <span class="keyword">new</span> RunSubject();</span><br><span class="line">        Subject subject3 = (Subject) <span class="keyword">new</span> DynamicProxyFactory(runSubject).getInstance(<span class="string">"JDK"</span>);</span><br><span class="line">        subject3.doSomething(<span class="string">"1234"</span>);</span><br><span class="line">        Subject subject4 = (Subject) <span class="keyword">new</span> DynamicProxyFactory(runSubject).getInstance(<span class="string">"Cglib"</span>);</span><br><span class="line">        subject4.doSomething(<span class="string">"5678"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以选择自己适合的代理方式，Spring AOP中就有类似的代码，只不过逻辑判断等更复杂些。</p><p>在Spring AOP中，如果加入容器的目标对象有实现接口，那么就用JDK代理；如果目标对象没有实现接口，那么就用Cglib代理。</p><p>有兴趣的同学可以看下AOP的相关代码。在<code>DefaultAopProxyFactory</code>类中，部分代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAopProxyFactory</span> <span class="keyword">implements</span> <span class="title">AopProxyFactory</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line"><span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</span><br><span class="line"><span class="string">"Either an interface or a target is required for proxy creation."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//部分代码略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Cglib警告"><a href="#Cglib警告" class="headerlink" title="Cglib警告"></a>Cglib警告</h2><p>在使用Cglib进行代理的时候，我们可以看到如下警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WARNING: An illegal reflective access operation has occurred</span><br><span class="line">WARNING: Illegal reflective access by net.sf.cglib.core.ReflectUtils$1 (file:/E:/maven-localRepository/local/repo/cglib/cglib/3.3.0/cglib-3.3.0.jar) to method java.lang.ClassLoader.defineClass(java.lang.String,byte[],int,int,java.security.ProtectionDomain)</span><br><span class="line">WARNING: Please consider reporting this to the maintainers of net.sf.cglib.core.ReflectUtils$1</span><br><span class="line">WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations</span><br><span class="line">WARNING: All illegal access operations will be denied in a future release</span><br></pre></td></tr></table></figure><p>我们可以看下<code>ClassLoader.defineClass(String,byte[],int,int,ProtectionDomain)</code>这个类。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-632.jpg" alt="upload successful"></p><p>可以看到它是<code>protected final</code>的，理论上外部包是不能调用它的，那么Cglib是如何实现调用的呢。</p><p>打开Cglib的<code>ReflectUtils</code>类，我们看到下图。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-633.jpg" alt="upload successful"></p><p>可以看到它通过<code>Class.forName</code>拿到<code>java.lang.ClassLoader</code>，然后拿到<code>defineClass</code>方法，改变了其可访问性<code>defineClass.setAccessible(true);</code>。</p><p>这也就是为什么JVM会发出警告的原因，因为正常情况下我们是不被允许访问此方法的（非法反射）。</p><p>还可以看到如果拿不到该方法（被限制后，抛出异常），那么它会尝试去拿<code>sun.misc.Unsafe.defineClass</code>方法。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-634.jpg" alt="upload successful"></p><p>如果我们不想看到这个警告，可以添加 VM 参数来屏蔽它。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--illegal-access=deny</span><br></pre></td></tr></table></figure><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-635.jpg" alt="upload successful"></p><h2 id="JDK动态代理源码分析"><a href="#JDK动态代理源码分析" class="headerlink" title="JDK动态代理源码分析"></a>JDK动态代理源码分析</h2><p>我们现在来分析下JDK动态代理是如何实现的，先看<code>Proxy.newProxyInstance</code>方法。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-636.jpg" alt="upload successful"></p><p>可以看到<code>Constructor&lt;?&gt; cons = getProxyConstructor(caller, loader, interfaces);</code>用来生成了构造器，而后通过<code>newProxyInstance(caller, cons, h);</code>生成对象。</p><p>我们看一下<code>getProxyConstructor</code>这个方法。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-637.jpg" alt="upload successful"></p><p>它分为只有一个接口和实现多个接口的两种处理逻辑，我们看其中一个就行，主要是<code>new ProxyBuilder(ld, clv.key()).build()</code>这个方法，用来生成代理类。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-638.jpg" alt="upload successful"></p><p>在<code>build</code>方法里，我们看到这个调用<code>Class&lt;?&gt; proxyClass = defineProxyClass(module, interfaces);</code>，这就是生成代理类的方法。</p><p>继续跟踪<code>defineProxyClass</code>方法，如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-639.jpg" alt="upload successful"></p><p>在这个方法中，我们可以看到生成代理类字节码的方法调用<code>byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces.toArray(EMPTY_CLASS_ARRAY), accessFlags);</code></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-640.jpg" alt="upload successful"></p><p>跟踪<code>generateProxyClass</code>方法，方法里有一个参数<code>saveGeneratedFiles</code>用来是否保存生成的代理类。</p><p>正常情况下这个值是false，即不保存。</p><p>但是我们想看生成的代理类的话，由于<code>ProxyGenerator.generateProxyClass</code>类及方法本身都是<code>non-public</code>的，所以我们无法直接调用此方法生成代理类。</p><p>因此可以借助<code>saveGeneratedFiles</code>参数。</p><p>观察代码<code>saveGeneratedFiles</code>的定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** debugging flag for saving generated class files */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> saveGeneratedFiles =</span><br><span class="line">    java.security.AccessController.doPrivileged(</span><br><span class="line">        <span class="keyword">new</span> GetBooleanAction(</span><br><span class="line">            <span class="string">"jdk.proxy.ProxyGenerator.saveGeneratedFiles"</span>)).booleanValue();</span><br></pre></td></tr></table></figure><p>所以我们在 VM 变量里配置<code>-Djdk.proxy.ProxyGenerator.saveGeneratedFiles=true</code>就可以将生成的代理类保存到本地。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-641.jpg" alt="upload successful"></p><p>如上图，运行后生成的代理类在<code>com.sun.proxy</code>包下。我们打开这个代理类（IDEA自带反编译）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sun.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zwt.helputils.utils.proxy.Subject;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">doSomething</span><span class="params">(String var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m3 = Class.forName(<span class="string">"com.zwt.helputils.utils.proxy.Subject"</span>).getMethod(<span class="string">"doSomething"</span>, Class.forName(<span class="string">"java.lang.String"</span>));</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到它继承自<code>Proxy</code>并实现了我们定义的<code>Subject</code>接口。也就是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Subject subject = (Subject) Proxy.newProxyInstance(loader, interfaces, handler);</span><br></pre></td></tr></table></figure><p>实际是<code>Subject</code>接口的一个实例，我们调用<code>doSomething</code>方法，实际调用代理类<code>$Proxy0</code>的<code>doSomething</code>方法。</p><p>而在实现<code>Subject</code>接口方法的内部，通过反射调用了<code>InvocationHandler</code>实现类的<code>invoke</code>方法。</p><p>由上面内容可以看出，Java动态代理主要有以下几步：</p><ol><li>通过实现<code>InvocationHandler</code>接口创建自己的调用处理器；</li><li>通过为<code>Proxy</code>类指定<code>ClassLoader</code>对象和一组<code>interface</code>来创建动态代理类；</li><li>通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型；</li><li>通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。</li></ol><h2 id="Cglib代理源码分析"><a href="#Cglib代理源码分析" class="headerlink" title="Cglib代理源码分析"></a>Cglib代理源码分析</h2><p>我们再来看下Cglib的代理是如何实现的。根据如下方法，我们直接跟踪到<code>create</code>方法里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">    enhancer.setSuperclass(target.getClass());</span><br><span class="line">    <span class="comment">// 回调方法</span></span><br><span class="line">    enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 创建代理对象</span></span><br><span class="line">    <span class="keyword">return</span> enhancer.create();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    classOnly = <span class="keyword">false</span>;</span><br><span class="line">    argumentTypes = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> createHelper();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看一下<code>createHelper()</code>方法。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-642.jpg" alt="upload successful"></p><p>其主要方法为<code>Object result = super.create(key);</code>，用来创建代理类。其代码如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-643.jpg" alt="upload successful"></p><p>主要方法<code>Object obj = data.get(this, getUseCache());</code>用来生成代理类，<code>firstInstance((Class) obj);</code>和<code>nextInstance(obj);</code>用来生成代理对象。</p><p>先来看下<code>get</code>方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(AbstractClassGenerator gen, <span class="keyword">boolean</span> useCache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!useCache) &#123;</span><br><span class="line">        <span class="keyword">return</span> gen.generate(ClassLoaderData.<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Object cachedValue = generatedClasses.get(gen);</span><br><span class="line">        <span class="keyword">return</span> gen.unwrapCachedValue(cachedValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到它调用了<code>gen.generate(ClassLoaderData.this)</code>用于生成代理类，继续跟踪调用。</p><p>可以看到<code>generate</code>最终调用了<code>ReflectUtils.defineClass</code>去生成代理类。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-644.jpg" alt="upload successful"></p><p><code>ReflectUtils.defineClass</code>方法中利用反射调用执行<code>ClassLoader.defineClass</code>方法去生成代理类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Class <span class="title">defineClass</span><span class="params">(String className, <span class="keyword">byte</span>[] b, ClassLoader loader, ProtectionDomain protectionDomain)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class c;</span><br><span class="line">    <span class="keyword">if</span> (DEFINE_CLASS != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Object[] args = <span class="keyword">new</span> Object[]&#123;className, b, <span class="keyword">new</span> Integer(<span class="number">0</span>), <span class="keyword">new</span> Integer(b.length), protectionDomain &#125;;</span><br><span class="line">        c = (Class)DEFINE_CLASS.invoke(loader, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DEFINE_CLASS_UNSAFE != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Object[] args = <span class="keyword">new</span> Object[]&#123;className, b, <span class="keyword">new</span> Integer(<span class="number">0</span>), <span class="keyword">new</span> Integer(b.length), loader, protectionDomain &#125;;</span><br><span class="line">        c = (Class)DEFINE_CLASS_UNSAFE.invoke(UNSAFE, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CodeGenerationException(THROWABLE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Force static initializers to run.</span></span><br><span class="line">    Class.forName(className, <span class="keyword">true</span>, loader);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用VM参数来指定Cglib使代理类文件落地。如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dcglib.debugLocation=E:\\WorkSpace\\helputils\\com\\cglib</span><br></pre></td></tr></table></figure><p>这个参数也可以通过代码设置，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, <span class="string">"E:\\WorkSpace\\helputils\\com\\cglib"</span>);</span><br></pre></td></tr></table></figure><p>我们运行下Test，可以看到生成如下类。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-645.jpg" alt="upload successful"></p><p>我们重点关注中间那个类，这个类继承<code>RunSubject</code>，这也印证了我们上面所说，Cglib是依靠继承目标类来实现代理的。</p><p>这个类代码比较多，我就不粘上来了，我们用图片看下它的几个关键部分。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-646.jpg" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-647.jpg" alt="upload successful"></p><p>由上面内容我们可以看到Cglib代理的几个步骤：</p><ol><li>通过实现<code>MethodInterceptor (extends Callback)</code>接口（或者自己实现<code>CallBack</code>接口）创建自己回调类；</li><li>通过<code>Enhancer</code>类指定目标类为超类<code>superClass</code>，并指定我们上面的回调类；</li><li>通过反射机制实现对目标类的继承，创建代理类；</li><li>代理类在调用指定方法时，如果需要回调，会通过反射拿到回调类要执行的内容；如果没有回调类，会直接执行目标类指定方法。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是关于代理模式的全部内容，我们也分析了各种代理模式的一些特点及原理。</p><p>实际中主要常用的就是JDK动态代理和Cglib代理。</p><p>JDK动态代理，是Java自带的代理模式，无需依赖，也没有警告等信息，唯一缺点就是需要目标类实现接口，只能对实现接口的类进行代理。</p><p>Cglib代理，内部使用asm，直接修改字节码进行增强子类，也就是通过继承的方式进行代理，不关心目标类是否继承接口，但是无法处理<code>final</code>的类（无法被继承）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="代理模式" scheme="https://www.sakuratears.top/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal</title>
    <link href="https://www.sakuratears.top/blog/ThreadLocal.html"/>
    <id>https://www.sakuratears.top/blog/ThreadLocal.html</id>
    <published>2020-07-30T14:51:00.000Z</published>
    <updated>2020-07-30T14:58:33.734Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>ThreadLocal</code>是一个本地线程副本变量存储工具类。主要用于将一个线程和该线程存放的副本对象做一个映射（Map），各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不同的变量值完成操作的场景。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>我们根据代码了解下<code>ThreadLocal</code>。</p><p>在了解<code>ThreadLocal</code>之前，我们先带着几个问题：</p><ol><li><code>ThreadLocal</code>的每个线程的私有变量保存在哪里？</li><li>大家说的关于<code>ThreadLocal</code>使用不当会发生内存泄露又是怎么回事？</li><li><code>ThreadLocal</code>弱引用导致内存泄露又是怎么回事？为什么要使用弱引用？</li><li>对于可能出现的内存泄露，<code>ThreadLocal</code>本身有哪些优化？我们编码时应该如何避免内存泄露？</li><li><code>ThreadLocal</code>的应用场景？</li></ol><p>首先我们先来看下<code>ThreadLocal</code>的几个重要方法。</p><h2 id="ThreadLocal的主要方法"><a href="#ThreadLocal的主要方法" class="headerlink" title="ThreadLocal的主要方法"></a>ThreadLocal的主要方法</h2><p><code>ThreadLocal</code>有三个重要方法，如下：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public T get()</td><td>该方法用于获取线程本地变量副本</td></tr><tr><td>public void set(T value)</td><td>该方法用于设置线程本地变量副本</td></tr><tr><td>public void remove()</td><td>该方法用于移除线程本地变量副本</td></tr></tbody></table><p>三个方法的相关源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面<code>get()</code>方法的源码可以看到，本地变量副本是由一个叫<code>ThreadLocalMap</code>的对象维护的，我们看一下<code>getMap(t)</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//.........部分代码略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment">     * by the ThreadLocal class. */</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.........部分代码略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在<code>Thread</code>类里维护着一个<code>ThreadLocalMap</code>，该线程的本地变量副本就会存到这儿。</p><p>再来看下这个变量赋予初始值的过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们通过<code>set</code>方法设置本地变量副本时，如果<code>ThreadLocalMap</code>为<code>null</code>，就会调用<code>createMap</code>将初始值放入。</p><p>而对于<code>get</code>方法，如果<code>ThreadLocalMap</code>为<code>null</code>，就会调用<code>setInitialValue</code>方法，最终调用<code>createMap</code>方法，此时初始值为<code>null</code>。</p><p>我们继续看下<code>ThreadLocalMap</code>的相关源码。</p><h2 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h2><p><code>ThreadLocalMap</code>的主要代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">        table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">        <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">        table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        setThreshold(INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//.....部分代码略</span></span><br></pre></td></tr></table></figure><p>可以看到<code>ThreadLocalMap</code>内部是通过<code>Entry</code>的value来维护变量副本的，其key为<code>ThreadLocal</code>本身。</p><p>而且<code>Entry</code>的key为<strong>弱引用（WeakReference）</strong>。</p><h2 id="关于Java引用"><a href="#关于Java引用" class="headerlink" title="关于Java引用"></a>关于Java引用</h2><p>Java中的引用按照引用强度不同分为四种，从强到弱依次为：强引用、软引用、弱引用和虚引用。</p><p>引用的强度，代表了对内存占用的能力大小，具体体现在GC的时候，会不会被回收，什么时候被回收。</p><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>我们一般很少提及它，但它无处不在。其实我们创建一个对象便是强引用，如<code>StringBuffer buffer = new StringBuffer();</code>。</p><p>HotSpot JVM目前的垃圾回收算法一般默认是可达性算法，即在每一轮GC的时候，选定一些对象作为GC ROOT，然后以它们为根发散遍历，遍历完成之后，如果一个对象不被任何GC ROOT引用，那么它就是不可达对象，则在接下来的GC过程中很可能会被回收。</p><p>如果我们在垃圾回收时还有对buffer的引用，那么它便不会被垃圾回收器回收。</p><h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>软引用是用来描述一些还有用但是并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收返回之后进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。JDK1.2之后提供了<code>SoftReference</code>来实现软引用。</p><p>相对于强引用，软引用在内存充足时可能不会被回收，在内存不够时会被回收。</p><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>弱引用也是用来描述非必须的对象的，但它的强度更弱，被弱引用关联的对象只能生存到下一次GC发生之前，也就是说下一次GC就会被回收。JDK1.2之后，提供了<code>WeakReference</code>来实现弱引用。</p><h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>虚引用也成为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间造成影响，也无法通过虚引用来取得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是在这个对象被GC时收到一个系统通知。JDK1.2之后提供了<code>PhantomReference</code>来实现虚引用。</p><h2 id="ThreadLocal内存模型"><a href="#ThreadLocal内存模型" class="headerlink" title="ThreadLocal内存模型"></a>ThreadLocal内存模型</h2><p>由上面内容，下面<code>ThreadLocal</code>的内存模型也是比较好理解的。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-628.jpg" alt="upload successful"></p><ul><li><p>线程运行时，我们定义的<code>ThreadLocal</code>对象被初始化，存储在<code>Heap</code>，同时线程运行的栈区保存了指向该实例的引用，也就是图中的<code>ThreadLocalRef</code>。</p></li><li><p>当<code>ThreadLocal</code>的<code>set/get</code>被调用时，虚拟机会根据当前线程的引用也就是<code>CurrentThreadRef</code>找到其对应在堆区的实例，然后查看其对用的<code>ThreadLocalMap</code>实例是否被创建，如果没有，则创建并初始化。</p></li><li><p><code>Map</code>实例化之后，也就拿到了该<code>ThreadLocalMap</code>的句柄，然后如果将当前<code>ThreadLocal</code>对象作为<code>key</code>，进行存取操作。</p></li><li><p>图中的虚线，表示<code>key</code>对<code>ThreadLocal</code>实例的引用是个弱引用。</p></li></ul><h2 id="内存泄露分析"><a href="#内存泄露分析" class="headerlink" title="内存泄露分析"></a>内存泄露分析</h2><p>根据上面内容，我们可以知道 <code>ThreadLocal</code>是被<code>ThreadLocalMap</code>以弱引用的方式关联着，因此如果<code>ThreadLocal</code>没有被<code>ThreadLocalMap</code>以外的对象引用，则在下一次GC的时候，<code>ThreadLocal</code>实例就会被回收，那么此时<code>ThreadLocalMap</code>里的一组<code>Entry</code>的K就是<code>null</code>了，因此在没有额外操作的情况下，此处的V便不会被外部访问到，而且只要<code>Thread</code>实例一直存在，<code>Thread</code>实例就强引用着<code>ThreadLocalMap</code>，因此<code>ThreadLocalMap</code>就不会被回收，那么这里K为<code>null</code>的V就一直占用着内存。</p><p>因此发生内存泄露的条件是：</p><ul><li><code>ThreadLocal</code>没有被外部强引用；</li><li><code>ThreadLocal</code>实例被回收；</li><li>但是<code>Thread</code>实例一直存活，一直强引用着<code>ThreadLocalMap</code>，也就是说<code>ThreadLocalMap</code>也不会被GC。</li></ul><p>也就是说，如果<code>ThreadLocal</code>使用不当，是有可能发生内存泄露的。</p><blockquote><p>我们这里说的内存泄露，指的是开发者使用不当造成的，而非<code>ThreadLocal</code>本身的问题。</p></blockquote><p>一个典型的例子就是线程池，如果我们在线程池的task里实例化了<code>ThreadLocal</code>对象，线程使用完后，回归线程池，但是本身并不会结束，但是task任务结束了，对<code>ThreadLocal</code>的强引用结束了，这时候在<code>ThreadLocalMap</code>中的<code>value</code>没有被任何清理机制有效清理。</p><p>我们可以模拟这种内存泄露情况，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个定长线程池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> k = a;</span><br><span class="line">            executorService.submit(()-&gt;&#123;</span><br><span class="line">                System.out.println(<span class="string">"线程ID："</span> + Thread.currentThread().getId());</span><br><span class="line">                ThreadLocal&lt;Integer&gt; t = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">                t.set(k);</span><br><span class="line">                System.out.println(<span class="string">"Value:"</span>+ t.get());</span><br><span class="line">            &#125;);</span><br><span class="line">            a+=<span class="number">1</span>;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//            MemoryMXBean mem =  ManagementFactory.getMemoryMXBean();</span></span><br><span class="line"><span class="comment">//            System.out.println("USED RAM：" + mem.getHeapMemoryUsage().getUsed() / 1024 / 1024 + "MB");</span></span><br><span class="line">        &#125;<span class="keyword">while</span> (a &lt; <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，我们模拟了一个长度为1的定长线程池（为了简化），这个线程池只有一个线程，我们在task里创建了<code>ThreadLocal</code>对象，当task结束后，实际<code>Thread</code>是还存活的。</p><p>我们通过<code>debug</code>模式，执行若干次，可以看到<code>ThreadLocalMap</code>里那些无用的<code>value</code>，如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-629.jpg" alt="upload successful"></p><p>这实际上就发生了内存泄露问题。</p><p>其实，我们调用<code>ThreadLocal</code>里提供的<code>remove</code>方法，变会完全解决这个问题。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-631.jpg" alt="upload successful"></p><p>如上图，我们如果使用完后添加<code>remove</code>方法删除变量副本，可以看到无论运行多少次，也不会出现内存泄露问题。</p><blockquote><p>不要觉得这个内存泄露条件自己不会碰到，实际上无论Http，数据库连接等都有线程池的概念，我们每一段代码如果使用<code>ThreadLocal</code>都可能成为task那段的一部分，使用不好就可能出现内存泄露问题。</p><p>因此在日常编码中一定要养成良好的编码习惯。</p></blockquote><h2 id="ThreadLocal的优化"><a href="#ThreadLocal的优化" class="headerlink" title="ThreadLocal的优化"></a>ThreadLocal的优化</h2><p>如果上面那个内存泄露的例子我们多运行一段时间，跟着<code>debug</code>，会发现<code>ThreadLocalMap</code>并不会一直增长的。</p><p>如下图，可以看到一些无用数据会自动消失。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-630.gif" alt="upload successful"></p><p>这是因为<code>ThreadLocal</code>本身的优化，在<code>ThreadLocalMap</code>的<code>getEntry</code>方法里，我们可以看到如下方法<code>getEntryAfterMiss</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">        Entry e = table[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>是的，这个方法就是找不到<code>Entry</code>的处理方法，该方法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == key)</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">                expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                i = nextIndex(i, len);</span><br><span class="line">            e = tab[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个方法一个关键部分就是<code>k == null</code>时调用<code>expungeStaleEntry</code>方法，用来删除旧的<code>Entry</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">        tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">        tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">        Entry e;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">                (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">                i = nextIndex(i, len)) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.value = <span class="keyword">null</span>;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line">                size--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                    tab[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                    <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                    <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                        h = nextIndex(h, len);</span><br><span class="line">                    tab[h] = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>主要逻辑如下：</p><ol><li><p>清理当前脏<code>entry</code>，即将其<code>value</code>引用置为<code>null</code>，并且将<code>table[staleSlot]</code>也置为<code>null</code>。<code>value</code>置为<code>null</code>后该<code>value</code>域变为不可达，在下一次gc的时候就会被回收掉，同时<code>table[staleSlot]</code>为<code>null</code>后以便于存放新的<code>entry</code>;</p></li><li><p>从当前<code>staleSlot</code>位置向后环形（<code>nextIndex</code>）继续搜索，直到遇到哈希桶（<code>tab[i]</code>）为<code>null</code>的时候退出；</p></li><li><p>若在搜索过程再次遇到脏<code>entry</code>，继续将其清除。</p></li></ol><p>除了该方法外，我们在<code>set</code>方法里可以看到对脏<code>entry</code>的处理，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> len = tab.length;</span><br><span class="line">        <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">                e != <span class="keyword">null</span>;</span><br><span class="line">                e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                e.value = value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                replaceStaleEntry(key, value, i);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">        <span class="keyword">int</span> sz = ++size;</span><br><span class="line">        <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">            rehash();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在该方法中针对脏<code>entry</code>做了这样的处理：</p><ol><li><p>如果当前<code>table[i]！=null</code>的话说明hash冲突就需要向后环形查找，若在查找过程中遇到脏<code>entry</code>就通过<code>replaceStaleEntry</code>进行处理；</p></li><li><p>如果当前<code>table[i]==null</code>的话说明新的<code>entry</code>可以直接插入，但是插入后会调用<code>cleanSomeSlots</code>方法检测并清除脏<code>entry</code></p></li></ol><p>我们先来看下<code>replaceStaleEntry</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Back up to check for prior stale entry in current run.</span></span><br><span class="line">    <span class="comment">// We clean out whole runs at a time to avoid continual</span></span><br><span class="line">    <span class="comment">// incremental rehashing due to garbage collector freeing</span></span><br><span class="line">    <span class="comment">// up refs in bunches (i.e., whenever the collector runs).</span></span><br><span class="line">    <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</span><br><span class="line">            (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">            i = prevIndex(i, len))</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find either the key or trailing null slot of run, whichever</span></span><br><span class="line">    <span class="comment">// occurs first</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">            (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">            i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we find key, then we need to swap it</span></span><br><span class="line">        <span class="comment">// with the stale entry to maintain hash table order.</span></span><br><span class="line">        <span class="comment">// The newly stale slot, or any other stale slot</span></span><br><span class="line">        <span class="comment">// encountered above it, can then be sent to expungeStaleEntry</span></span><br><span class="line">        <span class="comment">// to remove or rehash all of the other entries in run.</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line"></span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Start expunge at preceding stale entry if it exists</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If we didn't find stale entry on backward scan, the</span></span><br><span class="line">            <span class="comment">// first stale entry seen while scanning for key is the</span></span><br><span class="line">            <span class="comment">// first still present in the run.</span></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If key not found, put new entry in stale slot</span></span><br><span class="line">        tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">        tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If there are any other stale entries in run, expunge them</span></span><br><span class="line">        <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分代码通过<code>PreIndex</code>方法实现往前环形搜索脏<code>entry</code>的功能，初始时<code>slotToExpunge</code>和<code>staleSlot</code>相同，若在搜索过程中发现了脏<code>entry</code>，则更新<code>slotToExpunge</code>为当前索引<code>i</code>。另外，说明<code>replaceStaleEntry</code>并不仅仅局限于处理当前已知的脏<code>entry</code>，它认为在出现脏<code>entry</code>的相邻位置也有很大概率出现脏<code>entry</code>，所以为了一次处理到位，就需要向前环形搜索，找到前面的脏<code>entry</code>。</p><p>我们再来看下<code>cleanSomeSlots</code>方法的调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cleanSomeSlots</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        i = nextIndex(i, len);</span><br><span class="line">        Entry e = tab[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            n = len;</span><br><span class="line">            removed = <span class="keyword">true</span>;</span><br><span class="line">            i = expungeStaleEntry(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法用来清除一些脏<code>entry</code>，其扫描次数通过<code>n</code>来控制，可以看到<code>n &gt;&gt;&gt;= 1</code>表示每次<code>n</code>除以2进行减小范围搜索，当遇到脏<code>entry</code>时，<code>n = len</code>，就会扩大搜索范围。如果在整个搜索过程没遇到脏entry的话，搜索结束，采用这种方式的主要是用于时间效率上的平衡。</p><h2 id="为什么使用弱引用？"><a href="#为什么使用弱引用？" class="headerlink" title="为什么使用弱引用？"></a>为什么使用弱引用？</h2><p>根据上面的内容，我们来分析下为什么<code>ThreadLocal</code>要使用弱引用。</p><p>假设<code>ThreadLocal</code>使用的是强引用，在业务代码中执行<code>threadLocalInstance==null</code>操作，以清理掉<code>ThreadLocal</code>实例的目的，但是因为<code>ThreadLocalMap</code>的<code>Entry</code>强引用<code>ThreadLocal</code>，因此在gc的时候进行可达性分析，<code>ThreadLocal</code>依然可达，对<code>ThreadLocal</code>并不会进行垃圾回收，这样就无法真正达到业务逻辑的目的，出现逻辑错误。</p><p>假设<code>Entry</code>弱引用<code>ThreadLocal</code>，尽管会出现内存泄漏的问题，但是在<code>ThreadLocal</code>的生命周期里（<code>set,get,remove</code>）里，都会针对<code>key</code>为<code>null</code>的脏<code>Entry</code>进行处理。</p><p>从以上的分析可以看出，使用弱引用的话在<code>ThreadLocal</code>生命周期里会尽可能的保证不出现内存泄漏的问题，达到安全的状态。而且只要我们规范代码，就可以避免内存泄露问题。</p><h2 id="线程退出"><a href="#线程退出" class="headerlink" title="线程退出"></a>线程退出</h2><p>在<code>Thread</code>源码里，我们可以看到<code>exit</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (group != <span class="keyword">null</span>) &#123;</span><br><span class="line">        group.threadTerminated(<span class="keyword">this</span>);</span><br><span class="line">        group = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Aggressively null out all reference fields: see bug 4006245 */</span></span><br><span class="line">    target = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/* Speed the release of some of these resources */</span></span><br><span class="line">    threadLocals = <span class="keyword">null</span>;</span><br><span class="line">    inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line">    inheritedAccessControlContext = <span class="keyword">null</span>;</span><br><span class="line">    blocker = <span class="keyword">null</span>;</span><br><span class="line">    uncaughtExceptionHandler = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到线程退出后，<code>threadLocals</code>变为<code>null</code>，也就意味着GC可以将<code>ThreadLocalMap</code>进行垃圾回收。</p><h2 id="ThreadLocal应用场景"><a href="#ThreadLocal应用场景" class="headerlink" title="ThreadLocal应用场景"></a>ThreadLocal应用场景</h2><p><code>ThreadLocal</code>在一些开源框架下有着广泛应用。</p><ol><li><p>Spring的事务管理</p><p>在Spring事务管理相关类<code>TransactionAspectSupport</code>代码中，我们可以找到这段代码.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...部分代码略</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;TransactionInfo&gt; transactionInfoHolder =</span><br><span class="line"><span class="keyword">new</span> NamedThreadLocal&lt;TransactionInfo&gt;(<span class="string">"Current aspect-driven transaction"</span>);</span><br><span class="line"><span class="comment">//...部分代码略</span></span><br></pre></td></tr></table></figure><p>其目的就是用来存储当前事务相关信息。</p></li><li><p>Logback中的使用</p><p>在<code>Logback</code>的<code>LogbackMDCAdapter</code>相关代码中，也有<code>ThreadLocal</code>的使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...部分代码略</span></span><br><span class="line"><span class="keyword">final</span> ThreadLocal&lt;Map&lt;String, String&gt;&gt; copyOnThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Map&lt;String, String&gt;&gt;();</span><br><span class="line"><span class="keyword">final</span> ThreadLocal&lt;Integer&gt; lastOperation = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;();</span><br><span class="line"><span class="comment">//...部分代码略</span></span><br></pre></td></tr></table></figure></li><li><p>在<code>tomcat</code>相关代码中，<code>org.apache.catalina.core.ApplicationContext</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...部分代码略</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Thread local data used during request dispatch.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;DispatchData&gt; dispatchData = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"> <span class="comment">//...部分代码略</span></span><br></pre></td></tr></table></figure></li><li><p>如果要配置多数据源，我们可以使用<code>ThreadLocal</code>来进行数据源key的切换管理。</p><p> 可以看下这篇文章<a href="https://www.sakuratears.top/blog/SpringBoot%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE.html">SpringBoot多数据源配置</a></p></li></ol><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>我们对<code>Threadlocal</code>进行了详细介绍，除了了解它的主要原理，解决项目中遇到的一些问题外，更要使用好它，每次使用完<code>Threadlocal</code>，应调用<code>remove</code>方法清除数据。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.jianshu.com/p/dde92ec37bd1" rel="external nofollow noopener noreferrer" target="_blank">一篇文章，从源码深入详解ThreadLocal内存泄漏问题</a></li><li><a href="https://www.jianshu.com/p/1a5d288bdaee" rel="external nofollow noopener noreferrer" target="_blank">ThreadLocal小结-到底会不会引起内存泄露</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="ThreadLocal" scheme="https://www.sakuratears.top/tags/ThreadLocal/"/>
    
  </entry>
  
  <entry>
    <title>Java类加载器</title>
    <link href="https://www.sakuratears.top/blog/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.html"/>
    <id>https://www.sakuratears.top/blog/Java类加载器.html</id>
    <published>2020-07-26T13:43:00.000Z</published>
    <updated>2020-07-26T13:48:19.841Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>类加载器是<code>Java</code>语言的一个创新，也是<code>Java</code>语言流行的重要原因之一。它使得<code>Java</code> 类可以被动态加载到 <code>Java</code> 虚拟机中并执行。</p><p>一般来说，<code>Java</code> 应用的开发人员不需要直接同类加载器进行交互。<code>Java</code> 虚拟机默认的行为就已经足够满足大多数情况的需求了。不过如果遇到了需要与类加载器进行交互的情况，而对类加载器的机制又不是很了解的话，就很容易花大量的时间去调试 <code>ClassNotFoundException</code> 和 <code>NoClassDefFoundError</code> 等异常。</p><p>下面我们来了解类加载器的一些概念，来使我们更好地认识类加载器。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>类加载器（class loader）是用来加载 <code>Java</code> 类到 <code>Java</code> 虚拟机中的。</p><p>一般来说，<code>Java</code> 虚拟机使用 <code>Java</code> 类的方式如下：</p><ol><li><code>Java</code> 源程序（.java 文件）在经过 <code>Java</code> 编译器编译之后就被转换成 <code>Java</code> 字节代码（.class 文件）。</li><li>类加载器负责读取 <code>Java</code> 字节代码，并转换成 <code>java.lang.Class</code> 类的一个实例。每个这样的实例用来表示一个 <code>Java</code> 类。</li><li>通过此实例的 <code>newInstance()</code> 方法就可以创建出该类的一个对象。</li></ol><p>PS: 实际的情况可能更加复杂，比如 <code>Java</code> 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。</p><h2 id="java-lang-ClassLoader"><a href="#java-lang-ClassLoader" class="headerlink" title="java.lang.ClassLoader"></a>java.lang.ClassLoader</h2><p>基本上所有的类加载器都是 <code>java.lang.ClassLoader</code> 类的一个实例。</p><p><code>java.lang.ClassLoader</code> 类的基本职责就是根据一个指定的类的名称，找到或者生成其对应的字节代码，然后从这些字节代码中定义出一个 <code>Java</code> 类，即 <code>java.lang.Class</code> 类的一个实例。</p><p>除此之外， <code>ClassLoader</code> 还负责加载 <code>Java</code> 应用所需的资源，如图像文件和配置文件等。</p><p>下面我们主要看下这个类中与加载类相关的方法。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>getParent()</td><td>返回该类加载器的父类加载器。</td></tr><tr><td>loadClass(String name)</td><td>加载名称为 name 的类，返回的结果是 java.lang.Class 类的实例。</td></tr><tr><td>findClass(String name)</td><td>查找名称为 name 的类，返回的结果是 java.lang.Class 类的实例。</td></tr><tr><td>findLoadedClass(String name)</td><td>查找名称为 name 的已经被加载过的类，返回的结果是 java.lang.Class 类的实例。</td></tr><tr><td>defineClass(String name, byte[] b, int off, int len)</td><td>把字节数组 b 中的内容转换成 Java 类，返回的结果是 java.lang.Class 类的实例。这个方法被声明为 final 的。</td></tr><tr><td>resolveClass(Class&lt;?&gt; c)</td><td>链接指定的 Java 类。</td></tr></tbody></table><h2 id="类加载器的树状组织结构"><a href="#类加载器的树状组织结构" class="headerlink" title="类加载器的树状组织结构"></a>类加载器的树状组织结构</h2><p><code>Java</code> 中的类加载器大致可以分成两类，一类是系统提供的，另外一类则是由 <code>Java</code> 应用开发人员编写的。系统提供的类加载器主要有下面三个：</p><ul><li><p><strong>引导类加载器（BootstrapClassLoader）</strong>：它用来加载 <code>Java</code> 的核心库，是用原生代码（C++）来实现的，并不继承自 <code>java.lang.ClassLoader</code> 。</p></li><li><p><strong>扩展类/平台类加载器（ExtClassLoader/PlatformClassLoader）</strong>：扩展类加载器在<code>JDK1.8</code>之后变为平台类加载器。从<code>JDK1.8</code>之后的版本(<code>JDK9,JDK10</code>)提供有一个”<code>PlatformClassLoader</code>“类加载器，而在<code>JDK1.8</code>以前的版本里面提供的加载器为”<code>ExtClassLoader</code>“，因为在JDK的安装目录里面提供有一个<code>ext</code>目录，开发者可以将<code>*.jar</code>文件拷贝到此目录里面，这样就可以直接执行了，但是这样的处理并不安全。最初的时候也是不提倡使用的。所以在<code>JDK9</code>开始就将这样的操作彻底废除了，同时为了与系统类加载器和应用类加载器之间保持设计的平衡，提供了平台类加载器。</p></li><li><p><strong>系统类/应用类加载器（SystemClassLoader/AppClassLoader）</strong>：它根据 <code>Java</code> 应用的类路径（CLASSPATH）来加载 <code>Java</code> 类。一般来说，<code>Java</code> 应用的类都是由它来完成加载的。可以通过 <code>ClassLoader.getSystemClassLoader()</code> 来获取它。</p></li></ul><p>除了系统提供的类加载器以外，我们可以通过继承 <code>java.lang.ClassLoader</code> 类的方式实现自己的类加载器，以满足一些特殊的需求。</p><p>除了引导类加载器之外，所有的类加载器都有一个父类加载器。通过 <code>java.lang.ClassLoader</code> 类的 <code>getParent()</code> 方法可以得到。</p><p>对于系统提供的类加载器来说，系统类加载器的父类加载器是扩展类加载器，而扩展类加载器的父类加载器是引导类加载器；对于我们编写的类加载器来说，其父类加载器是加载此类加载器 <code>Java</code> 类的类加载器。因为类加载器 <code>Java</code> 类如同其它的 <code>Java</code> 类一样，也是要由类加载器来加载的。一般来说，我们编写的类加载器的父类加载器是系统类加载器。类加载器通过这种方式组织起来，形成树状结构。树的根节点就是引导类加载器，如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-627.jpg" alt="upload successful"></p><p>我们提供Java代码来看下类加载器的结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassLoader loader = Test.class.getClassLoader();</span><br><span class="line">        <span class="keyword">while</span> (loader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(loader.toString());</span><br><span class="line">            loader = loader.getParent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会有如下输出（JDK1.8及以上）:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jdk.internal.loader.ClassLoaders$AppClassLoader@726f3b58</span><br><span class="line">jdk.internal.loader.ClassLoaders$PlatformClassLoader@368239c8</span><br></pre></td></tr></table></figure></p><blockquote><p>需要注意的是这里并没有输出引导类加载器，这是由于有些 <code>JDK</code> 的实现对于父类加载器是引导类加载器的情况， <code>getParent()</code> 方法返回 <code>null</code> 。</p></blockquote><h2 id="类加载器的代理模式（双亲委派机制）"><a href="#类加载器的代理模式（双亲委派机制）" class="headerlink" title="类加载器的代理模式（双亲委派机制）"></a>类加载器的代理模式（双亲委派机制）</h2><p>类加载器在尝试自己去查找某个类的字节代码并定义它时，会先代理（委托）给其父类加载器，由父类加载器先去尝试加载这个类，依次类推。</p><p>代理模式（委托模式）第一这样可以避免重复加载，第二是为了保证 <code>Java</code> 核心库的类型安全。所有 <code>Java</code> 应用都至少需要引用 <code>java.lang.Object</code> 类，也就是说在运行的时候， <code>java.lang.Object</code>这个类需要被加载到 <code>Java</code> 虚拟机中。如果这个加载过程由 <code>Java</code> 应用自己的类加载器来完成的话，很可能就存在多个版本的 <code>java.lang.Object</code> 类，而且这些类之间是不兼容的。通过代理模式，对于 <code>Java</code> 核心库的类的加载工作由引导类加载器来统一完成，保证了 <code>Java</code> 应用所使用的都是同一个版本的 <code>Java</code> 核心库的类，是互相兼容的。</p><p>不同的类加载器为相同名称的类创建了额外的名称空间。相同名称的类可以并存在 <code>Java</code> 虚拟机中，只需要用不同的类加载器来加载它们即可。不同类加载器加载的类之间是不兼容的，这就相当于在 <code>Java</code> 虚拟机内部创建了一个个相互隔离的 <code>Java</code> 类空间。</p><p>在<code>ClassLoader</code>类的<code>loadClass</code>方法，我们可以看到这种委派机制，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">//首先从jvm缓存查找该类</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//父类加载器不为空，委托给父类加载器进行加载</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果父类加载器为null,则委托给BootStrap加载器加载</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 若仍然没有找到则调用findclass查找该类</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其大致流程如下：</p><ol><li><p>从 <code>JVM</code> 缓存查找该类，如果该类之前被加载过，则直接从 <code>JVM</code> 缓存返回该类。</p></li><li><p>如果 <code>JVM</code> 缓存不存在该类，则看当前类加载器是否有父加载器，如果有的话则委托父类加载器进行加载，否则委托 <code>BootStrapClassloader</code> 进行加载，如果还是没有找到，则调用当前 <code>Classloader</code> 的 <code>findclass</code> 方法进行查找。</p></li><li><p>从本地<code>Classloader</code>指定路径进行查找，其中<code>findClass</code>方法在路径找到<code>Class</code>文件会加载二进制字节码到内存，然后后会调用<code>native</code>方法<code>defineClass1</code>解析字节码为<code>JVM</code>内部的<code>kclass</code>对象，然后存放到<code>Java</code>堆的方法区。</p></li><li><p>如果需要链接<code>resolve=true</code>，则当字节码加载到内存后进行链接操作，对文件格式和字节码验证，并为 <code>static</code> 字段分配空间并初始化，符号引用转为直接引用，访问控制，方法覆盖等。</p></li></ol><h2 id="加载类的过程"><a href="#加载类的过程" class="headerlink" title="加载类的过程"></a>加载类的过程</h2><p>在前面介绍类加载器的代理模式的时候，提到过类加载器会首先代理给其它类加载器来尝试加载某个类。</p><p>这就意味着真正完成类的加载工作的类加载器和启动这个加载过程的类加载器，有可能不是同一个。</p><p>真正完成类的加载工作是通过调用 <code>defineClass</code> 来实现的；而启动类的加载过程是通过调用 <code>loadClass</code> 来实现的。前者称为一个类的定义加载器（defining loader），后者称为初始加载器（initiating loader）。</p><p>在 <code>Java</code> 虚拟机判断两个类是否相同的时候，使用的是类的定义加载器。</p><p>也就是说，哪个类加载器启动类的加载过程并不重要，重要的是最终定义这个类的加载器。两种类加载器的关联之处在于：一个类的定义加载器是它引用的其它类的初始加载器。</p><p>如类 <code>com.example.Outer</code> 引用了类 <code>com.example.Inner</code> ，则由类 <code>com.example.Outer</code> 的定义加载器负责启动类 <code>com.example.Inner</code> 的加载过程。</p><p>方法 <code>loadClass()</code> 抛出的是 <code>java.lang.ClassNotFoundException</code> 异常；方法 <code>defineClass()</code> 抛出的是 <code>java.lang.NoClassDefFoundError</code> 异常。</p><p>类加载器在成功加载某个类之后，会把得到的 <code>java.lang.Class</code> 类的实例缓存起来。下次再请求加载该类的时候，类加载器会直接使用缓存的类的实例，而不会尝试再次加载。</p><p>也就是说，对于一个类加载器实例来说，相同全名的类只加载一次，即 <code>loadClass</code> 方法不会被重复调用。</p><h2 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h2><p>线程上下文类加载器（context class loader）是从 JDK 1.2 开始引入的。</p><p>类 <code>java.lang.Thread</code> 中的方法 <code>getContextClassLoader()</code> 和 <code>setContextClassLoader(ClassLoader cl)</code> 用来获取和设置线程的上下文类加载器。如果没有通过 <code>setContextClassLoader(ClassLoader cl)</code> 方法进行设置的话，线程将继承其父线程的上下文类加载器。</p><p><code>Java</code>应用运行的初始线程的上下文类加载器是系统类加载器。在线程中运行的代码可以通过此类加载器来加载类和资源。</p><p>线程上下文类加载器所解决的问题：</p><p><code>Java</code> 提供了很多服务提供者接口（Service Provider Interface，SPI），允许第三方为这些接口提供实现。常见的 SPI 有 <code>JDBC、JCE、JNDI、JAXP 和 JBI</code> 等。这些 SPI 的接口由 <code>Java</code> 核心库来提供，这些 SPI 的实现代码很可能是作为 <code>Java</code> 应用所依赖的 <code>jar</code> 包被包含进来，可以通过类路径（CLASSPATH）来找到。而问题在于，SPI 的接口是 <code>Java</code> 核心库的一部分，是由引导类加载器来加载的；SPI 实现的 <code>Java</code> 类一般是由系统类加载器来加载的。引导类加载器是无法找到 SPI 的实现类的，因为它只加载 <code>Java</code> 的核心库。它也不能代理给系统类加载器，因为它是系统类加载器的祖先类加载器。也就是说，类加载器的代理模式无法解决这个问题。</p><p>线程上下文类加载器正好解决了这个问题。如果不做任何的设置，<code>Java</code> 应用的线程的上下文类加载器默认就是系统上下文类加载器。在 SPI 接口的代码中使用线程上下文类加载器，就可以成功的加载到 SPI 实现的类。线程上下文类加载器在很多 SPI 的实现中都会用到。</p><h2 id="Class-forName"><a href="#Class-forName" class="headerlink" title="Class.forName"></a>Class.forName</h2><p><code>Class.forName</code> 是一个静态方法，同样可以用来加载类。</p><p>该方法有两种形式：<code>Class.forName(String name, boolean initialize, ClassLoader loader)</code> 和 <code>Class.forName(String className)</code> 。</p><p>第一种形式的参数 <code>name</code> 表示的是类的全名； <code>initialize</code> 表示是否初始化类；<code>loader</code> 表示加载时使用的类加载器。</p><p>第二种形式则相当于设置了参数 <code>initialize</code> 的值为 <code>true</code>，<code>loader</code> 的值为当前类的类加载器。<code>Class.forName</code> 的一个很常见的用法是在加载数据库驱动的时候。</p><p>如 <code>Class.forName(“org.apache.derby.jdbc.EmbeddedDriver”).newInstance()</code> 用来加载 <code>Apache Derby</code> 数据库的驱动。</p><h2 id="开发自己的类加载器"><a href="#开发自己的类加载器" class="headerlink" title="开发自己的类加载器"></a>开发自己的类加载器</h2><p>虽然在绝大多数情况下，系统默认提供的类加载器实现已经可以满足需求。但是在某些情况下，我们还是需要为应用开发出自己的类加载器。比如我们的应用通过网络来传输 <code>Java</code> 类的字节代码，为了保证安全性，这些字节代码经过了加密处理。这个时候我们就需要自己的类加载器来从某个网络地址上读取加密后的字节代码，接着进行解密和验证，最后定义出要在 <code>Java</code> 虚拟机中运行的类来。下面将通过两个具体的实例来说明类加载器的开发。</p><h3 id="文件系统类加载器"><a href="#文件系统类加载器" class="headerlink" title="文件系统类加载器"></a>文件系统类加载器</h3><p>我们先编写一个类加载器用来加载存储在文件系统上的 <code>Java</code> 字节代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSystemClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String rootDir;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileSystemClassLoader</span><span class="params">(String rootDir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rootDir = rootDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] classData = getClassData(name);</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassData(String className) &#123;</span><br><span class="line">        String path = classNameToPath(className);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream ins = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> bufferSize = <span class="number">4096</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[bufferSize];</span><br><span class="line">            <span class="keyword">int</span> bytesNumRead = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((bytesNumRead = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, bytesNumRead);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">classNameToPath</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rootDir + File.separatorChar</span><br><span class="line">                + className.replace(<span class="string">'.'</span>, File.separatorChar) + <span class="string">".class"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>如上所示，类 <code>FileSystemClassLoader</code> 继承自类 <code>java.lang.ClassLoader</code> 。在 <code>java.lang.ClassLoader</code> 类的常用方法中，一般来说，自己开发的类加载器只需要覆写 <code>findClass(String name)</code> 方法即可。 </p><p>如上面源码所示，<code>loadClass()</code> 封装了前面提到的代理模式的实现。该方法会首先调用 <code>findLoadedClass()</code> 方法来检查该类是否已经被加载过；如果没有加载过的话，会调用父类加载器的 <code>loadClass()</code> 方法来尝试加载该类；如果父类加载器无法加载该类的话，就调用 <code>findClass()</code> 方法来查找该类。</p><p>因此，为了保证类加载器都正确实现代理模式，在开发自己的类加载器时，最好不要覆写 <code>loadClass()</code> 方法，而是覆写 <code>findClass()</code> 方法。</p><p>类 <code>FileSystemClassLoader</code> 的 <code>findClass()</code> 方法首先根据类的全名在硬盘上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 <code>defineClass()</code> 方法来把这些字节代码转换成 <code>java.lang.Class</code> 类的实例。</p><h3 id="网络类加载器"><a href="#网络类加载器" class="headerlink" title="网络类加载器"></a>网络类加载器</h3><p>下面将通过一个网络类加载器来说明如何通过类加载器来实现组件的动态更新。</p><p>即基本的场景是：<code>Java</code> 字节代码（.class）文件存放在服务器上，客户端通过网络的方式获取字节代码并执行。当有版本更新的时候，只需要替换掉服务器上保存的文件即可。通过类加载器可以比较简单的实现这种需求。</p><p>类 <code>NetworkClassLoader</code> 负责通过网络下载 <code>Java</code> 类字节代码并定义出 <code>Java</code> 类。它的实现与 <code>FileSystemClassLoader</code> 类似。</p><p>在通过 <code>NetworkClassLoader</code> 加载了某个版本的类之后，一般有两种做法来使用它。</p><p>第一种做法是使用 <code>Java</code> 反射 API。另外一种做法是使用接口。需要注意的是，并不能直接在客户端代码中引用从服务器上下载的类，因为客户端代码的类加载器找不到这些类。使用 <code>Java</code> 反射 API 可以直接调用 Java 类的方法。而使用接口的做法则是把接口的类放在客户端中，从服务器上加载实现此接口的不同版本的类。在客户端通过相同的接口来使用这些实现类。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String rootUrl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NetworkClassLoader</span><span class="params">(String rootUrl)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.rootUrl = rootUrl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"><span class="keyword">byte</span>[] classData = getClassData(name);</span><br><span class="line"><span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] getClassData(String className) &#123;</span><br><span class="line">String path = classNameToPath(className);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">URL url = <span class="keyword">new</span> URL(path);</span><br><span class="line">InputStream ins = url.openStream();</span><br><span class="line">ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line"><span class="keyword">int</span> bufferSize = <span class="number">4096</span>;</span><br><span class="line"><span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[bufferSize];</span><br><span class="line"><span class="keyword">int</span> bytesNumRead = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((bytesNumRead = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">baos.write(buffer, <span class="number">0</span>, bytesNumRead);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">classNameToPath</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> rootUrl + <span class="string">"/"</span></span><br><span class="line">+ className.replace(<span class="string">'.'</span>, <span class="string">'/'</span>) + <span class="string">".class"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Versioned</span> </span>&#123;</span><br><span class="line"><span class="function">String <span class="title">getVersion</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICalculator</span> <span class="keyword">extends</span> <span class="title">Versioned</span> </span>&#123;</span><br><span class="line"><span class="function">String <span class="title">calculate</span><span class="params">(String expression)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String url = <span class="string">"http://localhost:8080/ClassloaderTest/classes"</span>;</span><br><span class="line">NetworkClassLoader ncl = <span class="keyword">new</span> NetworkClassLoader(url);</span><br><span class="line">String basicClassName = <span class="string">"com.example.CalculatorBasic"</span>;</span><br><span class="line">String advancedClassName = <span class="string">"com.example.CalculatorAdvanced"</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class&lt;?&gt; clazz = ncl.loadClass(basicClassName);</span><br><span class="line">ICalculator calculator = (ICalculator) clazz.newInstance();</span><br><span class="line">System.out.println(calculator.getVersion());</span><br><span class="line">clazz = ncl.loadClass(advancedClassName);</span><br><span class="line">calculator = (ICalculator) clazz.newInstance();</span><br><span class="line">System.out.println(calculator.getVersion());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时需要在服务器提供<code>CalculatorBasic</code>和<code>CalculatorAdvanced</code>的实现，它们继承<code>ICalculator</code>接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorAdvanced</span> <span class="keyword">implements</span> <span class="title">ICalculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">calculate</span><span class="params">(String expression)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Result is "</span> + expression;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"2.0"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorBasic</span> <span class="keyword">implements</span> <span class="title">ICalculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">calculate</span><span class="params">(String expression)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> expression;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"1.0"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>类加载器是 <code>Java</code> 语言的一个创新。它使得动态安装和更新软件组件成为可能。</p><p>本文详细介绍了类加载器的相关话题，包括基本概念、代理模式、线程上下文类加载器等。我们在遇到 <code>ClassNotFoundException</code> 和 <code>NoClassDefFoundError</code> 等异常的时候，应该检查抛出异常的类的类加载器和当前线程的上下文类加载器，从中可以发现问题的所在。</p><p>在开发自己的类加载器的时候，需要注意与已有的类加载器组织结构的协调。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="类加载器" scheme="https://www.sakuratears.top/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java加密算法</title>
    <link href="https://www.sakuratears.top/blog/Java%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.html"/>
    <id>https://www.sakuratears.top/blog/Java加密算法.html</id>
    <published>2020-07-21T15:41:00.000Z</published>
    <updated>2020-07-21T15:42:44.781Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近总结了一些加密算法的相关Java代码，特此整理如下，以备不时之需。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="MD5信息摘要算法"><a href="#MD5信息摘要算法" class="headerlink" title="MD5信息摘要算法"></a>MD5信息摘要算法</h2><p>此算法为不可逆加密算法，是一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值，用于确保信息传输完整一致。</p><p>后来该算法被证实存在弱点，无法防止碰撞破解，因此不适用于安全性认证，对于需要高度安全性的数据，可以采用其他加密算法。</p><p>Java相关代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MD5Utils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_ALGORITHM = <span class="string">"MD5"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认的密码字符串组合，用来将字节转换成 16 进制表示的字符,apache校验下载的文件的正确性用的就是默认的这个组合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">char</span>[] hexDigits = &#123; <span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>,</span><br><span class="line">            <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MessageDigest messagedigest = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            messagedigest = MessageDigest.getInstance(KEY_ALGORITHM);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException ex) &#123;</span><br><span class="line">            log.error(ex.getMessage(),ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成字符串的md5校验值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMD5String</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getMD5String(s.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMD5String</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        messagedigest.update(bytes);</span><br><span class="line">        <span class="keyword">return</span> bufferToHex(messagedigest.digest());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">bufferToHex</span><span class="params">(<span class="keyword">byte</span> bytes[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bufferToHex(bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">bufferToHex</span><span class="params">(<span class="keyword">byte</span> bytes[], <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        StringBuffer stringbuffer = <span class="keyword">new</span> StringBuffer(<span class="number">2</span> * n);</span><br><span class="line">        <span class="keyword">int</span> k = m + n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = m; l &lt; k; l++) &#123;</span><br><span class="line">            appendHexPair(bytes[l], stringbuffer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringbuffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">appendHexPair</span><span class="params">(<span class="keyword">byte</span> bt, StringBuffer stringbuffer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 取字节中高 4 位的数字转换, &gt;&gt;&gt; 为逻辑右移，将符号位一起右移,此处未发现两种符号有何不同</span></span><br><span class="line">        <span class="keyword">char</span> c0 = hexDigits[(bt &amp; <span class="number">0xf0</span>) &gt;&gt; <span class="number">4</span>];</span><br><span class="line">        <span class="comment">// 取字节中低 4 位的数字转换</span></span><br><span class="line">        <span class="keyword">char</span> c1 = hexDigits[bt &amp; <span class="number">0xf</span>];</span><br><span class="line">        stringbuffer.append(c0);</span><br><span class="line">        stringbuffer.append(c1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成字符串指定部分的md5校验值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMD5String</span><span class="params">(String s,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(s))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s = s.toUpperCase();</span><br><span class="line">        <span class="keyword">if</span>(end &gt; start &amp;&amp; end &gt; <span class="number">0</span> &amp;&amp; s.length() &gt;= end)&#123;</span><br><span class="line">            s = s.substring(start, end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getMD5String(s.getBytes()).toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(getMD5String(<span class="string">"123456"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SHA安全散列算法"><a href="#SHA安全散列算法" class="headerlink" title="SHA安全散列算法"></a>SHA安全散列算法</h2><p>我们这儿提到的SHA安全散列算法一般指的它的密码散列函数家族，其有5个算法，分别是SHA-1、SHA-224、SHA-256、SHA-384和SHA-512。</p><p>其加密强度依次上升，SHA加密算法也是一种不可逆加密算法。</p><p>由于目前SHA-1存在暴力破解（碰撞破解）的可能性，因此推荐使用SHA-2（SHA-224、SHA-256、SHA-384、SHA-512）进行数据加密。这4个算法函数都将讯息对应到更长的讯息摘要。</p><p>Java相关代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SHAUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_SHA_1 = <span class="string">"SHA1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_SHA_224 = <span class="string">"SHA-224"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_SHA_256 = <span class="string">"SHA-256"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_SHA_384 = <span class="string">"SHA-384"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_SHA_512 = <span class="string">"SHA-512"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认的密码字符串组合，用来将字节转换成 16 进制表示的字符,apache校验下载的文件的正确性用的就是默认的这个组合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">char</span>[] hexDigits = &#123; <span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>,</span><br><span class="line">            <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MessageDigest messagedigestSHA1 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MessageDigest messagedigestSHA224 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MessageDigest messagedigestSHA256 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MessageDigest messagedigestSHA384 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MessageDigest messagedigestSHA512 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            messagedigestSHA1 = MessageDigest.getInstance(KEY_SHA_1);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException ex) &#123;</span><br><span class="line">            log.error(ex.getMessage(),ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            messagedigestSHA224 = MessageDigest.getInstance(KEY_SHA_224);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException ex) &#123;</span><br><span class="line">            log.error(ex.getMessage(),ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            messagedigestSHA256 = MessageDigest.getInstance(KEY_SHA_256);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException ex) &#123;</span><br><span class="line">            log.error(ex.getMessage(),ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            messagedigestSHA384 = MessageDigest.getInstance(KEY_SHA_384);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException ex) &#123;</span><br><span class="line">            log.error(ex.getMessage(),ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            messagedigestSHA512 = MessageDigest.getInstance(KEY_SHA_512);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException ex) &#123;</span><br><span class="line">            log.error(ex.getMessage(),ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">bufferToHex</span><span class="params">(<span class="keyword">byte</span> bytes[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bufferToHex(bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">bufferToHex</span><span class="params">(<span class="keyword">byte</span> bytes[], <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        StringBuffer stringbuffer = <span class="keyword">new</span> StringBuffer(<span class="number">2</span> * n);</span><br><span class="line">        <span class="keyword">int</span> k = m + n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = m; l &lt; k; l++) &#123;</span><br><span class="line">            appendHexPair(bytes[l], stringbuffer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringbuffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">appendHexPair</span><span class="params">(<span class="keyword">byte</span> bt, StringBuffer stringbuffer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 取字节中高 4 位的数字转换, &gt;&gt;&gt; 为逻辑右移，将符号位一起右移,此处未发现两种符号有何不同</span></span><br><span class="line">        <span class="keyword">char</span> c0 = hexDigits[(bt &amp; <span class="number">0xf0</span>) &gt;&gt; <span class="number">4</span>];</span><br><span class="line">        <span class="comment">// 取字节中低 4 位的数字转换</span></span><br><span class="line">        <span class="keyword">char</span> c1 = hexDigits[bt &amp; <span class="number">0xf</span>];</span><br><span class="line">        stringbuffer.append(c0);</span><br><span class="line">        stringbuffer.append(c1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成字符串的sha1校验值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSHA1String</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSHA1String(s.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSHA1String</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        messagedigestSHA1.update(bytes);</span><br><span class="line">        <span class="keyword">return</span> bufferToHex(messagedigestSHA1.digest());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成字符串的sha224校验值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSHA224String</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSHA224String(s.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSHA224String</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        messagedigestSHA224.update(bytes);</span><br><span class="line">        <span class="keyword">return</span> bufferToHex(messagedigestSHA224.digest());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成字符串的sha256校验值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSHA256String</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSHA256String(s.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSHA256String</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        messagedigestSHA256.update(bytes);</span><br><span class="line">        <span class="keyword">return</span> bufferToHex(messagedigestSHA256.digest());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成字符串的sha384校验值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSHA384String</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSHA384String(s.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSHA384String</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        messagedigestSHA384.update(bytes);</span><br><span class="line">        <span class="keyword">return</span> bufferToHex(messagedigestSHA384.digest());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成字符串的sha512校验值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSHA512String</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSHA512String(s.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSHA512String</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        messagedigestSHA512.update(bytes);</span><br><span class="line">        <span class="keyword">return</span> bufferToHex(messagedigestSHA512.digest());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SHA1:"</span>+getSHA1String(<span class="string">"123456"</span>));</span><br><span class="line">        System.out.println(<span class="string">"SHA224:"</span>+getSHA224String(<span class="string">"123456"</span>));</span><br><span class="line">        System.out.println(<span class="string">"SHA256:"</span>+getSHA256String(<span class="string">"123456"</span>));</span><br><span class="line">        System.out.println(<span class="string">"SHA384:"</span>+getSHA384String(<span class="string">"123456"</span>));</span><br><span class="line">        System.out.println(<span class="string">"SHA512:"</span>+getSHA512String(<span class="string">"123456"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Hmac哈希消息认证码"><a href="#Hmac哈希消息认证码" class="headerlink" title="Hmac哈希消息认证码"></a>Hmac哈希消息认证码</h2><p>Hmac是一种基于Hash函数和密钥进行消息认证的方法，在IPSec和其他网络协议（如SSL）中有广泛应用，现在已经成为Internet安全标准。</p><p>它也是一种不可逆加密算法。</p><p>Hmac运算利用hash算法，以一个消息M和一个密钥K作为输入，生成一个定长的消息摘要作为输出。</p><p>由于存在加密密钥K，因此认证时，加密方和认证方都是需要知道密钥K的。因此需要保证密钥K不被泄露。</p><p>同时密钥K的长度也影响加密算法强度，推荐密钥K随机生成且长度大于n（hash输出值）。</p><p>Hmac根据hash运算的不同，有6种算法，分别是Hmac-SHA1、Hmac-SHA224、Hmac-SHA256、Hmac-SHA284、Hmac-SHA512和Hmac-MD5。</p><p>Java相关代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HmacUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_HMAC_SHA1 = <span class="string">"HmacSHA1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_HMAC_SHA224 = <span class="string">"HmacSHA224"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_HMAC_SHA256 = <span class="string">"HmacSHA256"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_HMAC_SHA384 = <span class="string">"HmacSHA384"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_HMAC_SHA512 = <span class="string">"HmacSHA512"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_HMAC_MD5 = <span class="string">"HmacMD5"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到指定算法的一个密钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> algorithm</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">initMacKey</span><span class="params">(String algorithm)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//得到一个 指定算法密钥的密钥生成器</span></span><br><span class="line">        KeyGenerator keyGenerator = KeyGenerator.getInstance(algorithm);</span><br><span class="line">        <span class="comment">//生成一个密钥</span></span><br><span class="line">        SecretKey secretKey = keyGenerator.generateKey();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = secretKey.getEncoded();</span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HmacSHA 加密算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptText</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">hmacSHAEncrypt</span><span class="params">(String encryptText, String encryptKey,String algorithm)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] data = encryptKey.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        SecretKey secretKey = <span class="keyword">new</span> SecretKeySpec(data, algorithm);</span><br><span class="line">        Mac mac = Mac.getInstance(algorithm);</span><br><span class="line">        mac.init(secretKey);</span><br><span class="line">        <span class="keyword">byte</span>[] text = encryptText.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes =  mac.doFinal(text);</span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HmacSHA1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptText</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">hmacSHA1Encrypt</span><span class="params">(String encryptText, String encryptKey)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hmacSHAEncrypt(encryptText,encryptKey,KEY_HMAC_SHA1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HmacSHA224</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptText</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">hmacSHA224Encrypt</span><span class="params">(String encryptText, String encryptKey)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hmacSHAEncrypt(encryptText,encryptKey,KEY_HMAC_SHA224);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HmacSHA256</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptText</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">hmacSHA256Encrypt</span><span class="params">(String encryptText, String encryptKey)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hmacSHAEncrypt(encryptText,encryptKey,KEY_HMAC_SHA256);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HmacSHA384</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptText</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">hmacSHA384Encrypt</span><span class="params">(String encryptText, String encryptKey)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hmacSHAEncrypt(encryptText,encryptKey,KEY_HMAC_SHA384);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HmacSHA512</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptText</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">hmacSHA512Encrypt</span><span class="params">(String encryptText, String encryptKey)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hmacSHAEncrypt(encryptText,encryptKey,KEY_HMAC_SHA512);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HmacMD5</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptText</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">hmacMD5Encrypt</span><span class="params">(String encryptText, String encryptKey)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hmacSHAEncrypt(encryptText,encryptKey,KEY_HMAC_MD5);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String sha1Key = initMacKey(KEY_HMAC_SHA1);</span><br><span class="line">        System.out.println(<span class="string">"HmacSHA1_Key:"</span>+sha1Key);</span><br><span class="line">        System.out.println(<span class="string">"HmacSHA1_Result:"</span>+hmacSHA1Encrypt(<span class="string">"123456"</span>,sha1Key));</span><br><span class="line"></span><br><span class="line">        String sha224Key = initMacKey(KEY_HMAC_SHA224);</span><br><span class="line">        System.out.println(<span class="string">"HmacSHA224_Key:"</span>+sha224Key);</span><br><span class="line">        System.out.println(<span class="string">"HmacSHA224_Result:"</span>+hmacSHA224Encrypt(<span class="string">"123456"</span>,sha224Key));</span><br><span class="line"></span><br><span class="line">        String sha256Key = initMacKey(KEY_HMAC_SHA256);</span><br><span class="line">        System.out.println(<span class="string">"HmacSHA256_Key:"</span>+sha256Key);</span><br><span class="line">        System.out.println(<span class="string">"HmacSHA256_Result:"</span>+hmacSHA256Encrypt(<span class="string">"123456"</span>,sha256Key));</span><br><span class="line"></span><br><span class="line">        String sha384Key = initMacKey(KEY_HMAC_SHA384);</span><br><span class="line">        System.out.println(<span class="string">"HmacSHA384_Key:"</span>+sha384Key);</span><br><span class="line">        System.out.println(<span class="string">"HmacSHA384_Result:"</span>+hmacSHA384Encrypt(<span class="string">"123456"</span>,sha384Key));</span><br><span class="line"></span><br><span class="line">        String sha512Key = initMacKey(KEY_HMAC_SHA512);</span><br><span class="line">        System.out.println(<span class="string">"HmacSHA512_Key:"</span>+sha512Key);</span><br><span class="line">        System.out.println(<span class="string">"HmacSHA512_Result:"</span>+hmacSHA512Encrypt(<span class="string">"123456"</span>,sha512Key));</span><br><span class="line"></span><br><span class="line">        String md5Key = initMacKey(KEY_HMAC_MD5);</span><br><span class="line">        System.out.println(<span class="string">"HmacMD5_Key:"</span>+md5Key);</span><br><span class="line">        System.out.println(<span class="string">"HmacMD5_Result:"</span>+hmacMD5Encrypt(<span class="string">"123456"</span>,md5Key));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DES加密算法"><a href="#DES加密算法" class="headerlink" title="DES加密算法"></a>DES加密算法</h2><p>DES全称为Data Encryption Standard，直译即数据加密标准，是一种使用密钥加密的块算法。</p><p>它是一种对称可逆加密算法。</p><p>DES的加密密钥也是需要加密方和解密方都知道，因此存在泄漏的可能性。需要保护好密钥。</p><p>同时DES被证明是可以破解的，明文+密钥=密文，这个公式只要知道任何两个，就可以推导出第三个。</p><p>在已经知道明文和对应密文的情况下，通过穷举和暴力破解是可以破解DES的。</p><p>Java相关代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DESUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_ALGORITHM = <span class="string">"DESede"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认的加密算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CIPHER_ALGORITHM = <span class="string">"DESede/CBC/PKCS5Padding"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> iv</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encrypt</span><span class="params">(String data, String key,String iv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] keyBytes = key.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        <span class="keyword">byte</span>[] ivBytes = iv.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        <span class="keyword">if</span>(keyBytes.length &lt; <span class="number">24</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Key字节长度需大于等于24"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ivBytes.length != <span class="number">8</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"IV偏移量需要为8字节"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bt = encrypt(data.getBytes(StandardCharsets.UTF_8), keyBytes,ivBytes);</span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(bt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> iv</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decrypt</span><span class="params">(String data, String key,String iv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] keyBytes = key.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        <span class="keyword">byte</span>[] ivBytes = iv.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        <span class="keyword">if</span>(keyBytes.length &lt; <span class="number">24</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Key字节长度需大于等于24"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ivBytes.length != <span class="number">8</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"IV偏移量需要为8字节"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] buf = Base64.decodeBase64(data);</span><br><span class="line">        <span class="keyword">byte</span>[] bt = decrypt(buf, keyBytes,ivBytes);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(bt, StandardCharsets.UTF_8);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DES加密数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> iv</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encrypt(<span class="keyword">byte</span>[] data, <span class="keyword">byte</span>[] key,<span class="keyword">byte</span>[] iv) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 生成一个可信任的随机数源</span></span><br><span class="line">        SecureRandom sr = <span class="keyword">new</span> SecureRandom();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从原始密钥数据创建DESKeySpec对象</span></span><br><span class="line">        DESedeKeySpec dks = <span class="keyword">new</span> DESedeKeySpec(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个密钥工厂，然后用它把DESKeySpec转换成SecretKey对象</span></span><br><span class="line">        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(KEY_ALGORITHM);</span><br><span class="line">        SecretKey secretKey = keyFactory.generateSecret(dks);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Cipher对象实际完成加密操作</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);</span><br><span class="line"></span><br><span class="line">        IvParameterSpec ips = <span class="keyword">new</span> IvParameterSpec(iv);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用密钥初始化Cipher对象</span></span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, secretKey,ips, sr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DES解密数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> iv</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decrypt(<span class="keyword">byte</span>[] data, <span class="keyword">byte</span>[] key,<span class="keyword">byte</span>[] iv) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 生成一个可信任的随机数源</span></span><br><span class="line">        SecureRandom sr = <span class="keyword">new</span> SecureRandom();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从原始密钥数据创建DESKeySpec对象</span></span><br><span class="line">        DESedeKeySpec dks = <span class="keyword">new</span> DESedeKeySpec(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个密钥工厂，然后用它把DESKeySpec转换成SecretKey对象</span></span><br><span class="line">        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(KEY_ALGORITHM);</span><br><span class="line">        SecretKey secretKey = keyFactory.generateSecret(dks);</span><br><span class="line"></span><br><span class="line">        IvParameterSpec ips = <span class="keyword">new</span> IvParameterSpec(iv);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Cipher对象实际完成解密操作</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用密钥初始化Cipher对象</span></span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, secretKey,ips, sr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String text = <span class="string">"12345611111111111111111111111"</span>;</span><br><span class="line">        String key = <span class="string">"111111111111111111111张"</span>;</span><br><span class="line">        String iv = <span class="string">"张三81"</span>;</span><br><span class="line">        String result = encrypt(text,key,iv);</span><br><span class="line">        System.out.println(<span class="string">"DES加密："</span>+ result);</span><br><span class="line">        System.out.println(<span class="string">"DES解密："</span>+decrypt(result,key,iv));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AES加密算法"><a href="#AES加密算法" class="headerlink" title="AES加密算法"></a>AES加密算法</h2><p>AES（Advanced Encryption Standard），高级加密标准，这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。</p><p>它是一种对称可逆加密算法。</p><p>AES的加密密钥也是需要加密方和解密方都知道，因此也需要保护好密钥。</p><p>在使用AES加密时，我们一般使用CBC加密模式，这种加密模式安全性好，适合传输长报文，缺点是需要初始化向量IV。</p><p>对称加密的加密模式一般有4种，优缺点如下：</p><p>对称/分组密码一般分为流加密(如OFB、CFB等)和块加密(如ECB、CBC等)。对于流加密，需要将分组密码转化为流模式工作。对于块加密(或称分组加密)，如果要加密超过块大小的数据，就需要涉及填充和链加密模式。</p><ul><li><p>ECB(Electronic Code Book电子密码本)模式</p><p>ECB模式是最早采用和最简单的模式，它将加密的数据分成若干组，每组的大小跟加密密钥长度相同，然后每组都用相同的密钥进行加密。</p><p>优点:</p><ol><li>简单；　</li><li>有利于并行计算；</li><li>误差不会被传送；</li></ol><p>缺点:　</p><ol><li>不能隐藏明文的模式；　</li><li>可能对明文进行主动攻击；　</li></ol><p>因此，此模式适于加密小消息。</p></li><li><p>CBC(Cipher Block Chaining，加密块链)模式</p><p>优点：</p><ol><li>不容易主动攻击；</li><li>安全性好于ECB；</li><li>适合传输长度长的报文,是SSL、IPSec的标准。　</li></ol><p>缺点：　</p><ol><li>不利于并行计算；　</li><li>误差传递；　</li><li>需要初始化向量IV</li></ol></li><li><p>CFB(Cipher FeedBack Mode，加密反馈)模式</p><p>优点：</p><ol><li>隐藏了明文模式;　</li><li>分组密码转化为流模式;　</li><li>可以及时加密传送小于分组的数据;　</li></ol><p>缺点:　</p><ol><li>不利于并行计算;　</li><li>误差传送：一个明文单元损坏影响多个单元;　</li><li>唯一的IV;</li></ol></li><li><p>OFB(Output FeedBack，输出反馈)模式</p><p>优点:</p><ol><li>隐藏了明文模式;　</li><li>分组密码转化为流模式;　</li><li>可以及时加密传送小于分组的数据;　</li></ol><p>缺点:　</p><ol><li>不利于并行计算;　</li><li>对明文的主动攻击是可能的;　</li><li>误差传送：一个明文单元损坏影响多个单元</li></ol></li></ul><p>Java相关代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AESUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_ALGORITHM = <span class="string">"AES"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认的加密算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CIPHER_ALGORITHM = <span class="string">"AES/CBC/PKCS5Padding"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 随机数算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RANDOM_ALGORITHM = <span class="string">"SHA1PRNG"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * IV向量长度必须为16</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IV_PARAM_LENGTH = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AES支持的密钥长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SECRET_KEY_LENGTH_128 = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SECRET_KEY_LENGTH_192 = <span class="number">192</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SECRET_KEY_LENGTH_256 = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 密钥种子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String secretKeySeed = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * IV向量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String ivParameterSeed = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AESUtils</span><span class="params">(String secretKeySeed, String ivParameterSeed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.secretKeySeed = secretKeySeed;</span><br><span class="line">        <span class="keyword">if</span> (ivParameterSeed.length() != IV_PARAM_LENGTH) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"iv向量长度必须为16"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.ivParameterSeed=ivParameterSeed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">encrypt</span><span class="params">(String content)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// AES加密</span></span><br><span class="line">        <span class="keyword">byte</span>[] encryptStr = encrypt(content, secretKeySeed,ivParameterSeed);</span><br><span class="line">        <span class="comment">// BASE64位加密</span></span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(encryptStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptStr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decrypt</span><span class="params">(String encryptStr)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// BASE64位解密</span></span><br><span class="line">        <span class="keyword">byte</span>[] decodeBase64 = Base64.decodeBase64(encryptStr);</span><br><span class="line">        <span class="comment">// AES解密</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(decrypt(decodeBase64, secretKeySeed,ivParameterSeed),StandardCharsets.UTF_8);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成加密秘钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> secretKeySeed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> SecretKeySpec <span class="title">getSecretKeySpec</span><span class="params">(<span class="keyword">final</span> String secretKeySeed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//生成指定算法密钥生成器的 KeyGenerator 对象</span></span><br><span class="line">            KeyGenerator keyGenerator = KeyGenerator.getInstance(KEY_ALGORITHM);</span><br><span class="line">            <span class="comment">// 防止linux下 随机生成key</span></span><br><span class="line">            SecureRandom secureRandom = SecureRandom.getInstance(RANDOM_ALGORITHM);</span><br><span class="line">            secureRandom.setSeed(secretKeySeed.getBytes());</span><br><span class="line">            <span class="comment">//AES 要求密钥长度为 128/192/256</span></span><br><span class="line">            keyGenerator.init(SECRET_KEY_LENGTH_128, secureRandom);</span><br><span class="line">            <span class="comment">//生成一个密钥</span></span><br><span class="line">            SecretKey secretKey = keyGenerator.generateKey();</span><br><span class="line">            <span class="comment">// 转换为AES专用密钥</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SecretKeySpec(secretKey.getEncoded(), KEY_ALGORITHM);</span><br><span class="line"><span class="comment">//            //注意：ios不支持使用 KeyGenerator、SecureRandom、SecretKey 生成</span></span><br><span class="line"><span class="comment">//            return new SecretKeySpec(secretKeySeed.getBytes(), KEY_ALGORITHM);</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            log.error(ex.getMessage(), ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成向量秘钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ivParameterSeed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IvParameterSpec <span class="title">getIvParameterSpec</span><span class="params">(<span class="keyword">final</span> String ivParameterSeed)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用CBC模式，需要一个向量iv，可增加加密算法的强度</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IvParameterSpec(ivParameterSeed.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> secretKeySeed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ivParameterSeed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encrypt(String content, String secretKeySeed,String ivParameterSeed) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建密码器</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);</span><br><span class="line">        <span class="comment">// 初始化为加密模式的密码器</span></span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, getSecretKeySpec(secretKeySeed),getIvParameterSpec(ivParameterSeed));</span><br><span class="line">        <span class="comment">// 加密</span></span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(content.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> secretKeySeed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ivParameterSeed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decrypt(<span class="keyword">byte</span>[] content, String secretKeySeed,String ivParameterSeed) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建密码器</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);</span><br><span class="line">        <span class="comment">// 初始化为加密模式的密码器</span></span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, getSecretKeySpec(secretKeySeed),getIvParameterSpec(ivParameterSeed));</span><br><span class="line">        <span class="comment">// 解密</span></span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String secretKeySeed = <span class="string">"test123456"</span>;</span><br><span class="line">        String ivParameterSeed = <span class="string">"ivPar-test-hello"</span>;</span><br><span class="line">        String message = <span class="string">"test1234567890"</span>;</span><br><span class="line">        AESUtils aesUtils = <span class="keyword">new</span> AESUtils(secretKeySeed,ivParameterSeed);</span><br><span class="line">        String a= aesUtils.encrypt(message);</span><br><span class="line">        System.out.println(<span class="string">"加密后的字符："</span> + a);</span><br><span class="line">        System.out.println(<span class="string">"解密后的字符："</span> + aesUtils.decrypt(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RSA加密算法"><a href="#RSA加密算法" class="headerlink" title="RSA加密算法"></a>RSA加密算法</h2><p>它是一种非对称可逆加密算法，其密钥由公钥和私钥组成，公钥外部暴露，用于数据加密，私钥保密，用于解密数据。</p><p>RSA公开密钥密码体制是一种使用不同的加密密钥与解密密钥，“由已知加密密钥推导出解密密钥在计算上是不可行的”密码体制。</p><p>RSA公开密钥密码体制的原理是：根据数论，寻求两个大素数比较简单，而将它们的乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。</p><p>RSA的安全性依赖于大数分解，但是否等同于大数分解一直未能得到理论上的证明，也并没有从理论上证明破译。RSA的难度与大数分解难度等价。</p><p>RSA算法的保密强度随其密钥的长度增加而增强。但是，密钥越长，其加解密所耗用的时间也越长。因此，要根据所保护信息的敏感程度与攻击者破解所要花费的代价值不值得以及系统所要求的反应时间来综合考虑。一般情况下，公钥长度最好选择1024位及以上。</p><p>由于进行的都是大数计算，使得RSA最快的情况也比DES慢上好几倍，无论是软件还是硬件实现。速度一直是RSA的缺陷。一般来说只用于少量数据加密。RSA的速度比对应同样安全级别的对称密码算法要慢1000倍左右。</p><p>由于RSA加密数据长度不超过 <code>密钥长度/8 - 11</code>，解密长度不超过 <code>密钥长度/8</code>，因此对于较长数据，一般有两种方法进行处理：一是在使用RSA加密前，先使用一些对称加密算法将数据加密，使得加密后长度在RSA允许范围内，在使用RSA加密；二是使用RSA分段加密。</p><p>下面代码提供了RSA分段加密的算法，一般情况下，由于RSA加解密速度慢，耗资源，我们在双方通信中，先使用RSA进行通信，成功后协定双方对称加密密钥（如AES密钥），而后在使用对称加密算法（如AES）进行数据传输。</p><p>Java相关代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RSAUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数字签名，密钥算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RSA_KEY_ALGORITHM = <span class="string">"RSA"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数字签名签名/验证算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SIGNATURE_ALGORITHM = <span class="string">"MD5withRSA"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * RSA密钥长度，RSA算法的默认密钥长度是1024密钥长度必须是64的倍数，在512到65536位之间</span></span><br><span class="line"><span class="comment">     * PS:值改变后 最大加密字节数、最大解密字节数会随之变化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEY_SIZE = <span class="number">2048</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * bits转换为byte单位</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BASE_SIZE = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大加密字节数，超出最大字节数需要分组加密</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ENCRYPT_BLOCK = KEY_SIZE / BASE_SIZE - <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大解密字节数，超出最大字节数需要分组解密</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_DECRYPT_BLOCK = KEY_SIZE / BASE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成密钥对</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, String&gt; <span class="title">initKey</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        KeyPairGenerator keygen = KeyPairGenerator.getInstance(RSA_KEY_ALGORITHM);</span><br><span class="line">        <span class="comment">//初始化密钥生成器</span></span><br><span class="line">        keygen.initialize(KEY_SIZE);</span><br><span class="line">        KeyPair keys = keygen.genKeyPair();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] pubKey = keys.getPublic().getEncoded();</span><br><span class="line">        String publicKeyString = Base64.encodeBase64String(pubKey);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] priKey = keys.getPrivate().getEncoded();</span><br><span class="line">        String privateKeyString = Base64.encodeBase64String(priKey);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; keyPairMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        keyPairMap.put(<span class="string">"publicKeyString"</span>, publicKeyString);</span><br><span class="line">        keyPairMap.put(<span class="string">"privateKeyString"</span>, privateKeyString);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> keyPairMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 密钥转成byte[]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decodeBase64(String key) &#123;</span><br><span class="line">        <span class="keyword">return</span> Base64.decodeBase64(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 获取公钥</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> publicKey 公钥字符串</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PublicKey <span class="title">getPublicKey</span><span class="params">(String publicKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">         KeyFactory keyFactory = KeyFactory.getInstance(RSA_KEY_ALGORITHM);</span><br><span class="line">         <span class="keyword">byte</span>[] decodedKey = Base64.decodeBase64(publicKey.getBytes());</span><br><span class="line">         X509EncodedKeySpec keySpec = <span class="keyword">new</span> X509EncodedKeySpec(decodedKey);</span><br><span class="line">         <span class="keyword">return</span> keyFactory.generatePublic(keySpec);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 获取私钥</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> privateKey 私钥字符串</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PrivateKey <span class="title">getPrivateKey</span><span class="params">(String privateKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">         KeyFactory keyFactory = KeyFactory.getInstance(RSA_KEY_ALGORITHM);</span><br><span class="line">         <span class="keyword">byte</span>[] decodedKey = Base64.decodeBase64(privateKey.getBytes());</span><br><span class="line">         PKCS8EncodedKeySpec keySpec = <span class="keyword">new</span> PKCS8EncodedKeySpec(decodedKey);</span><br><span class="line">         <span class="keyword">return</span> keyFactory.generatePrivate(keySpec);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公钥加密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data      加密前的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey 公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 加密后的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encryptByPubKey</span><span class="params">(String data, String publicKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] pubKey = RSAUtils.decodeBase64(publicKey);</span><br><span class="line">        <span class="keyword">byte</span>[] enSign = encryptByPubKey(data.getBytes(), pubKey);</span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(enSign);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公钥加密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data   待加密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pubKey 公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encryptByPubKey(<span class="keyword">byte</span>[] data, <span class="keyword">byte</span>[] pubKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        X509EncodedKeySpec x509KeySpec = <span class="keyword">new</span> X509EncodedKeySpec(pubKey);</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(RSA_KEY_ALGORITHM);</span><br><span class="line">        PublicKey publicKey1 = keyFactory.generatePublic(x509KeySpec);</span><br><span class="line">        Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, publicKey1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标识</span></span><br><span class="line">        <span class="keyword">int</span> offSet = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] resultBytes = &#123;&#125;;</span><br><span class="line">        <span class="keyword">byte</span>[] cache = &#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> inputLength = data.length;</span><br><span class="line">        <span class="keyword">while</span> (inputLength - offSet &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inputLength - offSet &gt; MAX_ENCRYPT_BLOCK) &#123;</span><br><span class="line">                cache = cipher.doFinal(data, offSet, MAX_ENCRYPT_BLOCK);</span><br><span class="line">                offSet += MAX_ENCRYPT_BLOCK;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cache = cipher.doFinal(data, offSet, inputLength - offSet);</span><br><span class="line">                offSet = inputLength;</span><br><span class="line">            &#125;</span><br><span class="line">            resultBytes = Arrays.copyOf(resultBytes, resultBytes.length + cache.length);</span><br><span class="line">            System.arraycopy(cache, <span class="number">0</span>, resultBytes, resultBytes.length - cache.length, cache.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私钥解密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data   待解密的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> priKey 私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decryptByPriKey(<span class="keyword">byte</span>[] data, <span class="keyword">byte</span>[] priKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        PKCS8EncodedKeySpec pkcs8KeySpec = <span class="keyword">new</span> PKCS8EncodedKeySpec(priKey);</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(RSA_KEY_ALGORITHM);</span><br><span class="line">        PrivateKey privateKey1 = keyFactory.generatePrivate(pkcs8KeySpec);</span><br><span class="line">        Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, privateKey1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> inputLen = data.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> offSet = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] cache;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 对数据分段解密</span></span><br><span class="line">        <span class="keyword">byte</span>[] decryptedData = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>(ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream())&#123;</span><br><span class="line">            <span class="keyword">while</span> (inputLen - offSet &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (inputLen - offSet &gt; MAX_DECRYPT_BLOCK) &#123;</span><br><span class="line">                    cache = cipher.doFinal(data, offSet, MAX_DECRYPT_BLOCK);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cache = cipher.doFinal(data, offSet, inputLen - offSet);</span><br><span class="line">                &#125;</span><br><span class="line">                out.write(cache, <span class="number">0</span>, cache.length);</span><br><span class="line">                i++;</span><br><span class="line">                offSet = i * MAX_DECRYPT_BLOCK;</span><br><span class="line">            &#125;</span><br><span class="line">            decryptedData = out.toByteArray();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            log.error(e.getMessage(),e);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> decryptedData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私钥解密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data       解密前的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey 私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 解密后的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decryptByPriKey</span><span class="params">(String data, String privateKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] priKey = RSAUtils.decodeBase64(privateKey);</span><br><span class="line">        <span class="keyword">byte</span>[] design = decryptByPriKey(Base64.decodeBase64(data), priKey);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(design);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 签名</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> signVo 待签名数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey 私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 签名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">sign</span><span class="params">(SignVo signVo, String privateKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">         PrivateKey privateKeys = getPrivateKey(privateKey);</span><br><span class="line">         String data = toSignStrMap(signVo);</span><br><span class="line">         <span class="keyword">byte</span>[] keyBytes = privateKeys.getEncoded();</span><br><span class="line">         PKCS8EncodedKeySpec keySpec = <span class="keyword">new</span> PKCS8EncodedKeySpec(keyBytes);</span><br><span class="line">         KeyFactory keyFactory = KeyFactory.getInstance(RSA_KEY_ALGORITHM);</span><br><span class="line">         PrivateKey key = keyFactory.generatePrivate(keySpec);</span><br><span class="line">         Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM);</span><br><span class="line">         signature.initSign(key);</span><br><span class="line">         signature.update(data.getBytes());</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> String(Base64.encodeBase64(signature.sign()));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 验签</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> signVo 签名实体</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> publicKey 公钥</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> sign 签名</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@return</span> 是否验签通过</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(SignVo signVo, String publicKey, String sign)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">         PublicKey publicKeys = getPublicKey(publicKey);</span><br><span class="line">         String srcData = toSignStrMap(signVo);</span><br><span class="line">         <span class="keyword">byte</span>[] keyBytes = publicKeys.getEncoded();</span><br><span class="line">         <span class="comment">// 初始化公钥</span></span><br><span class="line">         X509EncodedKeySpec keySpec = <span class="keyword">new</span> X509EncodedKeySpec(keyBytes);</span><br><span class="line">         <span class="comment">// 实例化密钥工厂</span></span><br><span class="line">         KeyFactory keyFactory = KeyFactory.getInstance(RSA_KEY_ALGORITHM);</span><br><span class="line">         <span class="comment">// 产生公钥</span></span><br><span class="line">         PublicKey key = keyFactory.generatePublic(keySpec);</span><br><span class="line">         <span class="comment">// 实例化Signature</span></span><br><span class="line">         Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM);</span><br><span class="line">         <span class="comment">// 初始化Signature</span></span><br><span class="line">         signature.initVerify(key);</span><br><span class="line">         signature.update(srcData.getBytes());</span><br><span class="line">         <span class="keyword">return</span> signature.verify(Base64.decodeBase64(sign.getBytes()));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 签名串拼接  格式：标志A&amp;标志B&amp;标志C.....   中间用 &amp; 连接</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> signVo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toSignStrMap</span><span class="params">(SignVo signVo)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(signVo.getSignA()).append(<span class="string">"&amp;"</span>).append(signVo.getSignB()).append(<span class="string">"&amp;"</span>).append(signVo.getSignC());</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Map&lt;String, String&gt; keyMap = initKey();</span><br><span class="line">            String publicKeyString = keyMap.get(<span class="string">"publicKeyString"</span>);</span><br><span class="line">            String privateKeyString = keyMap.get(<span class="string">"privateKeyString"</span>);</span><br><span class="line">            System.out.println(<span class="string">"公钥:"</span> + publicKeyString);</span><br><span class="line">            System.out.println(<span class="string">"私钥:"</span> + privateKeyString);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 待加密数据</span></span><br><span class="line">            String data = <span class="string">"&#123;\"code\":\"0000\",\"data\":&#123;\"list\":[&#123;\"address\":\"互联网创业中心\",\"amount\":120000.0,\"applicationDate\":1594174666000,\"createDate\":1594174666000,\"ecCode\":\"MC0001\",\"ecName\":\"ARJ\",\"ecOrderNumber\":\"20202070817261111\",\"orderNumber\":\"AR202007081017453500\",\"payOrderNumber\":\"\",\"phone\":\"1860000000\",\"productList\":[&#123;\"name\":\"小米18\",\"number\":2,\"pictureUrl\":\"https://dss0.bdstatic.com/-0U0bnSm1A5BphGlnYG/tam-ogel/93d9d2b0e5373b93ca5032d13866fd14_254_144.jpg\",\"price\":60000.0&#125;],\"repayDay\":\"08\",\"stageAmount\":40000.0,\"stageNumber\":3,\"status\":\"01\",\"total\":2,\"updateDate\":1594261066000,\"userId\":\"56f72c55c0cc11ea8c81fa163efd3ee0\"&#125;,&#123;\"address\":\"互联网创业中心\",\"amount\":60000.0,\"applicationDate\":1594173896000,\"createDate\":1594173896000,\"ecCode\":\"MC0001\",\"ecName\":\"ARJ\",\"ecOrderNumber\":\"20202070817260000\",\"orderNumber\":\"AR202007081004565300\",\"payOrderNumber\":\"\",\"phone\":\"137777777\",\"productList\":[&#123;\"name\":\"华为P40\",\"number\":2,\"pictureUrl\":\"https://consumer-img.huawei.com/content/dam/huawei-cbg-site/common/mkt/pdp/phones/p40-pro-plus-specs/cn/dimage.jpg\",\"price\":30000.0&#125;],\"repayDay\":\"08\",\"stageAmount\":20000.0,\"stageNumber\":3,\"status\":\"01\",\"total\":2,\"updateDate\":1594260296000,\"userId\":\"56f72c55c0cc11ea8c81fa163efd3ee0\"&#125;]&#125;,\"msg\":\"成功\",\"showMsg\":\"success\"&#125;"</span>;</span><br><span class="line">            <span class="comment">// 公钥加密</span></span><br><span class="line">            String encrypt = RSAUtils.encryptByPubKey(data, publicKeyString);</span><br><span class="line">            <span class="comment">// 私钥解密</span></span><br><span class="line">            String decrypt = RSAUtils.decryptByPriKey(encrypt, privateKeyString);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"加密前:"</span> + data);</span><br><span class="line">            System.out.println(<span class="string">"加密后:"</span> + encrypt);</span><br><span class="line">            System.out.println(<span class="string">"解密后:"</span> + decrypt);</span><br><span class="line"></span><br><span class="line">            SignVo signVo = <span class="keyword">new</span> SignVo();</span><br><span class="line">            signVo.setSignA(<span class="string">"testA"</span>);</span><br><span class="line">            signVo.setSignB(<span class="string">"testB"</span>);</span><br><span class="line">            signVo.setSignC(<span class="string">"testC"</span>);</span><br><span class="line">            String sign = RSAUtils.sign(signVo,privateKeyString);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"签名:"</span>+sign);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> result = RSAUtils.verify(signVo,publicKeyString,sign);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"验签结果:"</span>+result);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SignVo</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标志A</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String signA;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标志B</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String signB;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标志C</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String signC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DH加密算法"><a href="#DH加密算法" class="headerlink" title="DH加密算法"></a>DH加密算法</h2><p>上面我们说到非对称加密算法加密速度慢，耗资源，可以使用非对称加密算法进行通信，协商密钥后，在使用对称加密算法进行数据传输，这就是DH加密算法的核心。</p><p>其实也可以说DH加密算法是一种建立密钥的方法，而不是加密方法。</p><p>我们以甲乙双方发送数据为模型进行分析：</p><ol><li><p>甲方（消息发送方，下同）构建密钥对（公钥+私钥），甲方公布公钥给乙方（消息接收方，下同）;</p></li><li><p>乙方以甲方发送过来的公钥作为参数构造密钥对（公钥+私钥），将构造出来的公钥公布给甲方;</p></li><li><p>甲方用“甲方的私钥 + 乙方的公钥”构造本地密钥;</p></li><li><p>乙方用“乙方的私钥 + 甲方的公钥”构造本地的密钥;</p></li><li><p>这个时候，甲乙两方本地新构造出来的密钥应该一样，甲乙双方可以通过本地密钥进行数据的加密和解密;</p></li><li><p>然后就可以使用AES/DES这类对称加密算法进行数据的安全传送了。</p></li></ol><p>Java相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DHUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ALGORITHM = <span class="string">"DH"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认密钥字节数</span></span><br><span class="line"><span class="comment">     * 需要为64的倍数，且在512到1024之间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEY_SIZE = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DH加密下需要一种对称加密算法对数据加密，这里我们使用DES，也可以使用其他对称加密算法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SECRET_ALGORITHM = <span class="string">"DES"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公钥私钥Key值，便于从Map获取</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PUBLIC_KEY = <span class="string">"DHPublicKey"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PRIVATE_KEY = <span class="string">"DHPrivateKey"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化甲方密钥</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title">initKey</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(ALGORITHM);</span><br><span class="line">        keyPairGenerator.initialize(KEY_SIZE);</span><br><span class="line"></span><br><span class="line">        KeyPair keyPair = keyPairGenerator.generateKeyPair();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 甲方公钥</span></span><br><span class="line">        DHPublicKey publicKey = (DHPublicKey) keyPair.getPublic();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 甲方私钥</span></span><br><span class="line">        DHPrivateKey privateKey = (DHPrivateKey) keyPair.getPrivate();</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; keyMap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        keyMap.put(PUBLIC_KEY, publicKey);</span><br><span class="line">        keyMap.put(PRIVATE_KEY, privateKey);</span><br><span class="line">        <span class="keyword">return</span> keyMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化乙方密钥</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 甲方公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title">initKey</span><span class="params">(String key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 解析甲方公钥</span></span><br><span class="line">        <span class="keyword">byte</span>[] keyBytes = Base64.decodeBase64(key);</span><br><span class="line">        X509EncodedKeySpec x509KeySpec = <span class="keyword">new</span> X509EncodedKeySpec(keyBytes);</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(ALGORITHM);</span><br><span class="line">        PublicKey pubKey = keyFactory.generatePublic(x509KeySpec);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由甲方公钥构建乙方密钥</span></span><br><span class="line">        DHParameterSpec dhParamSpec = ((DHPublicKey) pubKey).getParams();</span><br><span class="line"></span><br><span class="line">        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(keyFactory.getAlgorithm());</span><br><span class="line">        keyPairGenerator.initialize(dhParamSpec);</span><br><span class="line"></span><br><span class="line">        KeyPair keyPair = keyPairGenerator.generateKeyPair();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 乙方公钥</span></span><br><span class="line">        DHPublicKey publicKey = (DHPublicKey) keyPair.getPublic();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 乙方私钥</span></span><br><span class="line">        DHPrivateKey privateKey = (DHPrivateKey) keyPair.getPrivate();</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; keyMap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        keyMap.put(PUBLIC_KEY, publicKey);</span><br><span class="line">        keyMap.put(PRIVATE_KEY, privateKey);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> keyMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data       待加密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey  甲方公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey 乙方私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encrypt(<span class="keyword">byte</span>[] data, String publicKey,String privateKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成本地密钥</span></span><br><span class="line">        SecretKey secretKey = getSecretKey(publicKey, privateKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数据加密</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(secretKey.getAlgorithm());</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, secretKey);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data  待加密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey 甲方公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey 乙方私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encrypt</span><span class="params">(String data, String publicKey,String privateKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = data.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        <span class="keyword">byte</span>[] result = encrypt(bytes,publicKey,privateKey);</span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data       待解密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey  乙方公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey 乙方私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decrypt(<span class="keyword">byte</span>[] data, String publicKey, String privateKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成本地密钥</span></span><br><span class="line">        SecretKey secretKey = getSecretKey(publicKey, privateKey);</span><br><span class="line">        <span class="comment">// 数据解密</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(secretKey.getAlgorithm());</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, secretKey);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 待解密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey 乙方公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey 甲方私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decrypt</span><span class="params">(String data, String publicKey, String privateKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = Base64.decodeBase64(data);</span><br><span class="line">        <span class="keyword">byte</span>[] result = decrypt(bytes,publicKey,privateKey);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(result,StandardCharsets.UTF_8);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建密钥</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey  公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey 私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> SecretKey <span class="title">getSecretKey</span><span class="params">(String publicKey, String privateKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化公钥</span></span><br><span class="line">        <span class="keyword">byte</span>[] pubKeyBytes = Base64.decodeBase64(publicKey);</span><br><span class="line"></span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(ALGORITHM);</span><br><span class="line">        X509EncodedKeySpec x509KeySpec = <span class="keyword">new</span> X509EncodedKeySpec(pubKeyBytes);</span><br><span class="line">        PublicKey pubKey = keyFactory.generatePublic(x509KeySpec);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化私钥</span></span><br><span class="line">        <span class="keyword">byte</span>[] priKeyBytes = Base64.decodeBase64(privateKey);</span><br><span class="line"></span><br><span class="line">        PKCS8EncodedKeySpec pkcs8KeySpec = <span class="keyword">new</span> PKCS8EncodedKeySpec(priKeyBytes);</span><br><span class="line">        Key priKey = keyFactory.generatePrivate(pkcs8KeySpec);</span><br><span class="line"></span><br><span class="line">        KeyAgreement keyAgree = KeyAgreement.getInstance(keyFactory.getAlgorithm());</span><br><span class="line">        keyAgree.init(priKey);</span><br><span class="line">        keyAgree.doPhase(pubKey, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成本地密钥</span></span><br><span class="line">        SecretKey secretKey = keyAgree.generateSecret(SECRET_ALGORITHM);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> secretKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取得私钥</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyMap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPrivateKey</span><span class="params">(Map&lt;String, Object&gt; keyMap)</span></span>&#123;</span><br><span class="line">        Key key = (Key) keyMap.get(PRIVATE_KEY);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(key.getEncoded());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取得公钥</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyMap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPublicKey</span><span class="params">(Map&lt;String, Object&gt; keyMap)</span></span>&#123;</span><br><span class="line">        Key key = (Key) keyMap.get(PUBLIC_KEY);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(key.getEncoded());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 生成甲方密钥对</span></span><br><span class="line">        Map&lt;String, Object&gt; aKeyMap = DHUtils.initKey();</span><br><span class="line">        String aPublicKey = DHUtils.getPublicKey(aKeyMap);</span><br><span class="line">        String aPrivateKey = DHUtils.getPrivateKey(aKeyMap);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"甲方公钥:"</span> + aPublicKey);</span><br><span class="line">        System.out.println(<span class="string">"甲方私钥:"</span> + aPrivateKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由甲方公钥产生本地密钥对</span></span><br><span class="line">        Map&lt;String, Object&gt; bKeyMap = DHUtils.initKey(aPublicKey);</span><br><span class="line">        String bPublicKey = DHUtils.getPublicKey(bKeyMap);</span><br><span class="line">        String bPrivateKey = DHUtils.getPrivateKey(bKeyMap);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"乙方公钥:"</span> + bPublicKey);</span><br><span class="line">        System.out.println(<span class="string">"乙方私钥:"</span> + bPrivateKey);</span><br><span class="line"></span><br><span class="line">        String aInput = <span class="string">"abc "</span>;</span><br><span class="line">        System.out.println(<span class="string">"原数据: "</span> + aInput);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由甲方公钥，乙方私钥构建密文</span></span><br><span class="line">        String aCode = DHUtils.encrypt(aInput, aPublicKey,bPrivateKey);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"加密："</span>+aCode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由乙方公钥，甲方私钥解密</span></span><br><span class="line">        String aDecode = DHUtils.decrypt(aCode, bPublicKey, aPrivateKey);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"解密: "</span> + aDecode);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String bInput = <span class="string">"def "</span>;</span><br><span class="line">        System.out.println(<span class="string">"原数据: "</span> + bInput);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由乙方公钥，甲方私钥构建密文</span></span><br><span class="line">        String bCode = DHUtils.encrypt(bInput, bPublicKey,aPrivateKey);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"加密："</span>+bCode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由甲方公钥，乙方私钥解密</span></span><br><span class="line">        String bDecode = DHUtils.decrypt(bCode, aPublicKey, bPrivateKey);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"解密: "</span> + bDecode);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ECC椭圆加密算法"><a href="#ECC椭圆加密算法" class="headerlink" title="ECC椭圆加密算法"></a>ECC椭圆加密算法</h2><p>椭圆加密算法（ECC）是一种公钥加密体制，其数学基础是利用椭圆曲线上的有理点构成Abel加法群上椭圆离散对数的计算困难性。</p><p>因此其也是一种非对称可逆加密算法。</p><p>相比RSA加密算法，ECC加密算法的安全性更高，有研究表明160位的椭圆密钥与1024位的RSA密钥安全性相同。</p><p>同时在私钥的加密解密速度上，ECC算法比RSA速度更快。</p><p>Java目前不支持ECC算法的加解密，只支持公私钥的生成，这儿我们引入<code>org.bouncycastle.bcprov-jdk15on</code>包，来实现Java下的ECC加密算法。</p><p>pom文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.bouncycastle/bcprov-jdk15on --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.bouncycastle&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;bcprov-jdk15on&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.66&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>Java相关代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ECCUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ALGORITHM = <span class="string">"EC"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PROVIDER = <span class="string">"BC"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TRANSFORM = <span class="string">"ECIES"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Map key值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PUBLIC_KEY = <span class="string">"publicKey"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PRIVATE_KEY = <span class="string">"privateKey"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Java目前不支持ECC加解密，只支持公私钥的生成</span></span><br><span class="line"><span class="comment">     * 这儿我们使用BouncyCastleProvider来支持ECC加密算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        Security.addProvider(<span class="keyword">new</span> BouncyCastleProvider());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成秘钥对</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> KeyPair <span class="title">getKeyPair</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(ALGORITHM, PROVIDER);</span><br><span class="line"></span><br><span class="line">        keyPairGenerator.initialize(SIZE, <span class="keyword">new</span> SecureRandom());</span><br><span class="line">        KeyPair keyPair = keyPairGenerator.generateKeyPair();</span><br><span class="line">        <span class="keyword">return</span> keyPair;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyPair</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPublicKey</span><span class="params">(KeyPair keyPair)</span></span>&#123;</span><br><span class="line">        ECPublicKey publicKey = (ECPublicKey) keyPair.getPublic();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = publicKey.getEncoded();</span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyPair</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPrivateKey</span><span class="params">(KeyPair keyPair)</span></span>&#123;</span><br><span class="line">        ECPrivateKey privateKey = (ECPrivateKey) keyPair.getPrivate();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = privateKey.getEncoded();</span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(bytes);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将Base64编码后的公钥转换成PublicKey对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pubStr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ECPublicKey <span class="title">string2PublicKey</span><span class="params">(String pubStr)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] keyBytes = Base64.decodeBase64(pubStr);</span><br><span class="line"></span><br><span class="line">        X509EncodedKeySpec keySpec = <span class="keyword">new</span> X509EncodedKeySpec(keyBytes);</span><br><span class="line"></span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(ALGORITHM,PROVIDER);</span><br><span class="line"></span><br><span class="line">        ECPublicKey publicKey = (ECPublicKey) keyFactory.generatePublic(keySpec);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> publicKey;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将Base64编码后的私钥转换成PrivateKey对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> priStr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ECPrivateKey <span class="title">string2PrivateKey</span><span class="params">(String priStr)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] keyBytes = Base64.decodeBase64(priStr);</span><br><span class="line"></span><br><span class="line">        PKCS8EncodedKeySpec keySpec = <span class="keyword">new</span> PKCS8EncodedKeySpec(keyBytes);</span><br><span class="line"></span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(ALGORITHM, PROVIDER);</span><br><span class="line"></span><br><span class="line">        ECPrivateKey privateKey = (ECPrivateKey) keyFactory.generatePrivate(keySpec);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> privateKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用公钥加密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encryptByPublicKey(<span class="keyword">byte</span>[] content,PublicKey publicKey) <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">        Cipher cipher = Cipher.getInstance(TRANSFORM,PROVIDER);</span><br><span class="line"></span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE,publicKey);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = cipher.doFinal(content);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私钥解密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decryptByPrivateKey(<span class="keyword">byte</span>[] content, PrivateKey privateKey) <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">        Cipher cipher = Cipher.getInstance(TRANSFORM,PROVIDER);</span><br><span class="line"></span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE,privateKey);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = cipher.doFinal(content);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encrypt</span><span class="params">(String content,String publicKey)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ECPublicKey pubKey = string2PublicKey(publicKey);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = content.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        <span class="keyword">byte</span>[] result = encryptByPublicKey(bytes,pubKey);</span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cipherText</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decrypt</span><span class="params">(String cipherText,String privateKey)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ECPrivateKey priKey = string2PrivateKey(privateKey);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = Base64.decodeBase64(cipherText);</span><br><span class="line">        <span class="keyword">byte</span>[] result = decryptByPrivateKey(bytes,priKey);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(result,StandardCharsets.UTF_8);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成一组密钥对</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String,String&gt; <span class="title">initKeyPairStr</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        KeyPair keyPair = ECCUtils.getKeyPair();</span><br><span class="line">        String publicKeyStr =ECCUtils.getPublicKey(keyPair);</span><br><span class="line">        String privateKeyStr = ECCUtils.getPrivateKey(keyPair);</span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(PUBLIC_KEY,publicKeyStr);</span><br><span class="line">        map.put(PRIVATE_KEY,privateKeyStr);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String text = <span class="string">"131sdfsfd张庆伟金额取"</span>;</span><br><span class="line">        Map&lt;String,String&gt; keyPair = initKeyPairStr();</span><br><span class="line">        String publicKey = keyPair.get(PUBLIC_KEY);</span><br><span class="line">        String privateKey = keyPair.get(PRIVATE_KEY);</span><br><span class="line">        System.out.println(<span class="string">"公钥："</span>+publicKey);</span><br><span class="line">        System.out.println(<span class="string">"私钥："</span>+privateKey);</span><br><span class="line">        String encrypt = encrypt(text,publicKey);</span><br><span class="line">        System.out.println(<span class="string">"加密数据："</span>+encrypt);</span><br><span class="line">        String decrypt = decrypt(encrypt,privateKey);</span><br><span class="line">        System.out.println(<span class="string">"解密数据："</span>+decrypt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是比较常用的一些加密算法，当然有一些其他的加密算法，如DSA等这儿未作涉及，有兴趣的也可以查看相关资料等。</p><p>了解一些加密算法，以便在设计系统时可以正确选择合适的数据加密算法，来保证系统更加稳定、可靠的运行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="加密算法" scheme="https://www.sakuratears.top/tags/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Mysql数据库设计命名规范</title>
    <link href="https://www.sakuratears.top/blog/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83.html"/>
    <id>https://www.sakuratears.top/blog/Mysql数据库设计命名规范.html</id>
    <published>2020-07-12T08:15:00.000Z</published>
    <updated>2020-07-12T08:18:18.814Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数据库涉及字符规范"><a href="#数据库涉及字符规范" class="headerlink" title="数据库涉及字符规范"></a>数据库涉及字符规范</h1><p>采用 <code>26</code> 个英文字母（区分大小写）和 <code>0-9</code> 这十个自然数，加上下划线<code>‘_’</code>组成，共<code>37</code>个字符。不能出现其他字符(注释除外)。</p><p><strong>注意事项：</strong></p><ol><li><p>以上命名都不得超过 <code>30</code> 个字符的系统限制。变量名的长度限制为<code>29</code>（不包括标识字符<code>@</code>）。</p></li><li><p>数据对象、变量的命名都采用英文字符，禁止使用中文命名。绝对不要在对象名的字符之间留空格。</p></li><li><p>小心保留词，要保证你的字段名没有和保留词、数据库系统或者常用访问方法冲突, 当表名或字段名乃至数据库名和保留字冲突时，在sql语句里可以用撇号（<code>`</code>）括起来。</p></li><li><p>保持字段名和类型的一致性，在命名字段并为其指定数据类型的时候一定要保证一致性。假如数据类型在一个表里是整数，那在另一个表里也要保证是整型。</p></li></ol><h1 id="数据库命名规范"><a href="#数据库命名规范" class="headerlink" title="数据库命名规范"></a>数据库命名规范</h1><p>数据库名使用小写英文以及下划线组成（公司简称+项目名）。比如:</p><p><code>baidu_oa<br>ailibaba_cloud</code></p><p>备份数据库名使用正式库名加上备份时间组成，如:</p><p><code>dbname_20150206</code></p><p>数据库创建时，显式指定字符集。</p><h1 id="数据库表命名规范"><a href="#数据库表命名规范" class="headerlink" title="数据库表命名规范"></a>数据库表命名规范</h1><p>数据表名使用小写英文以及下划线组成（项目名+表信息），并且创建数据库时，显式指定默认字符集。</p><p>比如:</p><p><code>oa_user<br>oa_workflow_steps</code></p><p>备份数据表名使用正式表名加上备份时间组成，如:</p><p><code>oa_user_20150206<br>oa_workflow_step_20150206</code></p><h1 id="字段命名规范"><a href="#字段命名规范" class="headerlink" title="字段命名规范"></a>字段命名规范</h1><p>字段名称使用单词组合完成，首字母小写，单词之间用<code>“_”</code>分隔，最好是带表名前缀，自增id最好创建与业务无关.</p><p>如<code>oa_user</code>表的字段:</p><p><code>user_id<br>user_name</code></p><p>表与表之间的相关联字段要用统一名称。</p><h1 id="索引命名规范"><a href="#索引命名规范" class="headerlink" title="索引命名规范"></a>索引命名规范</h1><p>索引名称为<code>idx_列名<em>表名缩写</em></code>，唯一索引名称为<code>uniq列名_表名缩写</code>,其中表名和关联字段名如果过长，可以取表名、关联字段名的前 5 个字母，如果表名、关联字段为多个单词组合，可以取前一个单词，外加后续其它单词的首字母作为字段名。</p><p>如:</p><p>普通索引:<code>idx_user_name_oa</code></p><p>唯一索引：<code>uqidx_user_name_oa</code></p><p><strong>注意事项：</strong></p><ul><li>单个索引长度不超过<code>64KB</code></li><li>单个表索引不超过<code>8</code>个</li></ul><h1 id="字段类型规范"><a href="#字段类型规范" class="headerlink" title="字段类型规范"></a>字段类型规范</h1><p>规则：用尽量少的存储空间来存数一个字段的数据。</p><ol><li><p><code>char(n)</code>和<code>varchar(n)</code>中括号中<code>n</code>代表字符的个数，并不代表字节个数，所以当使用了中文的时候(UTF8)意味着可以插入<code>m</code>个中文，但是实际会占用<code>m*3</code>个字节。</p></li><li><p>同时<code>char</code>和<code>varchar</code>最大的区别就在于<code>char</code>不管实际<code>value</code>都会占用<code>n</code>个字符的空间，而<code>varchar</code>只会占用实际字符应该占用的空间+1，并且实际空间+1&lt;=n。</p></li><li><p>超过<code>char</code>和<code>varchar</code>的<code>n</code>设置后，字符串会被截断。</p></li><li><p><code>char</code>的上限为<code>255</code>字节，<code>varchar</code>的上限<code>65535</code>字节，<code>text</code>的上限为<code>65535</code>。</p></li><li><p><code>char</code>在存储的时候会截断尾部的空格，<code>varchar</code>和<code>text</code>不会。</p></li><li><p><code>varchar</code>会使用<code>1-3</code>个字节来存储长度，<code>text</code>不会。</p></li></ol><table><thead><tr><th>Value</th><th>CHAR(4)</th><th>Storage Required</th><th>VARCHAR(4)</th><th>Storage Required</th></tr></thead><tbody><tr><td>‘’</td><td>‘    ‘</td><td>4 bytes</td><td>‘’</td><td>1 byte</td></tr><tr><td>‘ab’</td><td>‘ab  ‘</td><td>4 bytes</td><td>‘ab’</td><td>3 bytes</td></tr><tr><td>‘abcd’</td><td>‘abcd’</td><td>4 bytes</td><td>‘abcd’</td><td>5 bytes</td></tr><tr><td>‘abcdefgh’</td><td>‘abcd’</td><td>4 bytes</td><td>‘abcd’</td><td>5 bytes</td></tr></tbody></table><p>总体来说：</p><ul><li><code>char</code>，存定长，速度快，存在空间浪费的可能，会处理尾部空格，上限<code>255</code>。</li><li><code>varchar</code>，存变长，速度慢，不存在空间浪费，不处理尾部空格，上限<code>65535</code>，但是有存储长度实际<code>65532</code>最大可用。</li><li><code>text</code>，存变长大数据，速度慢，不存在空间浪费，不处理尾部空格，上限<code>65535</code>，会用额外空间存放数据长度，顾可以全部使用<code>65535</code>。</li></ul><p>接下来，我们说下这个场景的问题：</p><p>当<code>varchar(n)</code>后面的n非常大的时候我们是使用<code>varchar</code>好，还是<code>text</code>好呢？</p><p>这是个明显的量变引发质变的问题。我们从2个方面考虑，第一是空间，第二是性能。</p><p>首先从空间方面：</p><p>从官方文档中我们可以得知当<code>varchar</code>大于某些数值的时候，其会自动转换为<code>text</code>，大概规则如下：</p><ul><li>大于<code>varchar(255)</code>变为 <code>tinytext</code></li><li>大于<code>varchar(500)</code>变为 <code>text</code></li><li>大于<code>varchar(20000)</code>变为 <code>mediumtext</code></li></ul><p>所以对于过大的内容使用<code>varchar</code>和<code>text</code>没有太多区别。</p><p>比如能用<code>int</code>的就不用<code>char</code>或者<code>varchar</code>，能用<code>varchar(20)</code>的就不用<code>varchar(255)</code>。</p><p>时间戳字段尽量用<code>int</code>型。</p><p>尽量避免大字段<code>blob</code>，<code>text</code>，<code>longtext</code>，如强制需要大字段，不要集中存放在一个表中，分多表存放。查询语句<code>where</code>条件不要落在大字段上。</p><p>相关文档: </p><ul><li><a href="https://dev.mysql.com/doc/refman/5.6/en/column-count-limit.html" rel="external nofollow noopener noreferrer" target="_blank">行的大小限制</a></li><li><a href="https://dev.mysql.com/doc/refman/5.6/en/storage-requirements.html" rel="external nofollow noopener noreferrer" target="_blank">表数据类型的选型手册</a></li><li><a href="https://dev.mysql.com/doc/refman/5.6/en/string-type-syntax.html" rel="external nofollow noopener noreferrer" target="_blank">大对象数据类型的概述</a></li></ul><h1 id="操作规范"><a href="#操作规范" class="headerlink" title="操作规范"></a>操作规范</h1><ul><li><p>创建表时需添加表级别和列级别注释，显示指定存储引擎、默认字符集、自增开始值，<code>id</code>列无特殊要求，建议使用<code>int</code>值。</p></li><li><p>如无备注，则表中的第一个<code>id</code>字段一定是主键且为自动增长；</p></li><li><p>如无备注，则数值类型的字段请使用<code>UNSIGNED</code>属性；</p></li><li><p>如无备注，所有字段都设置<code>NOT NULL</code>，并设置默认值；</p></li><li><p>如无备注，所有的布尔值字段，如<code>is_hot</code>、<code>is_deleted</code>，都必须设置一个默认值，并设为<code>0</code>；</p></li><li><p>所有的数字类型字段，都必须设置一个默认值，并设为<code>0</code>；</p></li><li><p>针对<code>varchar</code>类型字段的程序处理，请验证用户输入，不要超出其预设的长度；</p></li><li><p>建表时将数据字典中的字段中文名和属性备注写入数据表的备注中(“PK、自动增长”不用写)；</p></li><li><p>如无说明，建表时一律采用<code>innodb</code>引擎；</p></li><li><p>尽量采用批量<code>SQL</code>语句,减少与数据库交互次数；</p></li><li><p>提交线上建表改表需求,必须详细注明涉及到的所有<code>SQL</code>语句(包括<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>)，便于DBA进行审核和优化。</p></li></ul><h1 id="数据库用户创建规范"><a href="#数据库用户创建规范" class="headerlink" title="数据库用户创建规范"></a>数据库用户创建规范</h1><p>采用<code>26</code>个英文字母（区分大小写）和<code>0-9</code>这十个自然数，加上下划线<code>‘_’</code>组成，共<code>37</code>个字符。不能出现其他字符（注释除外）。</p><p><strong>注意事项:</strong></p><ul><li>以上命名都不得超过<code>16</code>个字符的系统限制。</li><li><p>数据库用户一律采用小写，由以下几个部分组成，使用<code>人员<em>项目名</em>连接途径_用户权限</code>组成；</p><p>例如:管理平台账号，<code>d_mg_web_dml</code>，<code>d_mg_pc_web_dml</code></p></li></ul><h1 id="其他设计技巧"><a href="#其他设计技巧" class="headerlink" title="其他设计技巧"></a>其他设计技巧</h1><ol><li><p>避免使用存储过程、触发器、视图、自定义函数等，这些高级特性有性能问题，以及未知BUG较多。业务逻辑放到数据库会造成数据库的<code>DDL</code>、<code>SCALE OUT</code>、 <code>SHARDING</code>等变得更加困难。</p></li><li><p>分区表对分区键有严格要求；分区表在表变大后,执行<code>DDL</code>、<code>SHARDING</code>、单表恢复等都变得更加困难。因此禁止使用分区表,并建议业务端手动<code>SHARDING</code>。</p></li><li><p>使用常用英语（或者其他任何语言）而不要使用拼音首字母缩写。</p></li><li><p>将大字段、访问频率低的字段拆分到单独的表中存储，分离冷热数据, 有利于有效利用缓存，防止读入无用的冷数据，较少磁盘IO，同时保证热数据常驻内存提高缓存。</p></li><li><p>禁止有<code>super</code>权限的应用程序账号存在, 安全第一。<code>super</code>权限会导致<code>read only</code>失效，导致较多诡异问题而且很难追踪。</p></li><li><p>不要在MySQL数据库中存放业务逻辑, 数据库是有状态的服务，变更复杂而且速度慢，如果把业务逻辑放到数据库中，将会限制业务的快速发展。建议把业务逻辑提前，放到前端或中间逻辑层，而把数据库作为存储层，实现逻辑与存储的分离。</p></li><li><p>不建议使用<code>enum</code>,<code>set</code>,<code>blob</code>,<code>text</code>字段，如非用<code>blob</code>或<code>text</code>字段，请将<code>blob</code>或<code>text</code>内容存放到文件系统中，数据库中只存放文件系统的<code>url</code>地址，或将该类字段单独存放到一张小表中（首推第一种方法）。</p></li></ol><p>附：建表示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`manager_test`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">20</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`staff_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'操作人员id'</span>,</span><br><span class="line">  <span class="string">`staff_name`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'人员名称'</span>,</span><br><span class="line">  <span class="string">`url`</span> <span class="built_in">varchar</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'操作路径'</span>,</span><br><span class="line">  <span class="string">`method`</span> <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'操作方式'</span>,</span><br><span class="line">  <span class="string">`params`</span> <span class="built_in">varchar</span>(<span class="number">10</span>)<span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'操作参数'</span>,</span><br><span class="line">  <span class="string">`ip`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'ip'</span>,</span><br><span class="line">  <span class="string">`time`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'操作时间'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_staff_id_ct`</span> (<span class="string">`staff_id `</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">1</span><span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</span><br></pre></td></tr></table></figure><h1 id="数据库用户命名规范"><a href="#数据库用户命名规范" class="headerlink" title="数据库用户命名规范"></a>数据库用户命名规范</h1><p>用户命名规则，分为四段，每段规则如下</p><p>示例：<code>d_zq_pc_dml</code></p><ul><li><p>第一段：环境名(<code>d:develop，t:test,p:product</code>)</p></li><li><p>第二段：项目名首字母</p></li><li><p>第三段：连接源(pc:桌面终端，web:程序)</p></li><li><p>第四段：权限(<code>sel:select，dml:select，insert，update，delete</code>)</p></li></ul><p><strong>注意事项：</strong></p><p>禁止程序具有<code>file</code>、<code>super</code>权限。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="MYSQL" scheme="https://www.sakuratears.top/tags/MYSQL/"/>
    
  </entry>
  
  <entry>
    <title>Redis开发规范</title>
    <link href="https://www.sakuratears.top/blog/Redis%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83.html"/>
    <id>https://www.sakuratears.top/blog/Redis开发规范.html</id>
    <published>2020-07-12T08:13:00.000Z</published>
    <updated>2020-07-12T08:14:22.389Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="键值设计"><a href="#键值设计" class="headerlink" title="键值设计"></a>键值设计</h1><h2 id="key名设计"><a href="#key名设计" class="headerlink" title="key名设计"></a>key名设计</h2><ol><li><p>【建议】: 可读性和可管理性</p><p> 以业务名(或数据库名)为前缀(防止key冲突)，用冒号分隔，比如业务名:表名:id</p><p> <code>ugc:video:1</code></p></li><li><p>【建议】：简洁性</p><p> 保证语义的前提下，控制key的长度，当key较多时，内存占用也不容忽视，例如：</p><p> <code>user:{uid}:friends:messages:{mid}</code></p><p> 简化为</p><p> <code>u:{uid}:fr:m:{mid}</code></p></li><li><p>【强制】：不要包含特殊字符</p><p> 反例：包含空格、换行、单双引号以及其他转义字符</p></li></ol><h2 id="value设计"><a href="#value设计" class="headerlink" title="value设计"></a>value设计</h2><ol><li><p>【强制】：拒绝<code>bigkey</code>(防止网卡流量、慢查询)</p><p> <code>String</code>类型控制在10KB以内，<code>hash</code>、<code>list</code>、<code>set</code>、<code>zset</code>元素个数不要超过5000。</p><p> 反例：一个包含200万个元素的<code>list</code>。</p><p> 非字符串的<code>bigkey</code>，不要使用<code>del</code>删除，使用<code>hscan</code>、<code>sscan</code>、<code>zscan</code>方式渐进式删除，同时要注意防止<code>bigkey</code>过期时间自动删除问题(例如一个200万的<code>zset</code>设置1小时过期，会触发del操作，造成阻塞，而且该操作不会不出现在慢查询中(latency可查))，查找方法和删除方法</p></li><li><p>【推荐】：选择适合的数据类型。</p><p> 例如：实体类型(要合理控制和使用数据结构内存编码优化配置,例如<code>ziplist</code>，但也要注意节省内存和性能之间的平衡)</p><p> 反例：</p><p> <code>set user:1:name tom</code></p><p> set user:1:age 19</p><p> set user:1:favor football</p><p> 正例:</p><p> <code>hmset user:1 name tom age 19 favor football</code></p></li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li><p>【推荐】：控制key的生命周期，redis不是垃圾桶。</p><p> 建议使用<code>expire</code>设置过期时间(条件允许可以打散过期时间，防止集中过期)，不过期的数据重点关注<code>idle time</code>。</p></li></ol><h1 id="命令使用"><a href="#命令使用" class="headerlink" title="命令使用"></a>命令使用</h1><ol><li><p>【推荐】 O(N)命令关注N的数量</p><p> 例如<code>hgetall</code>、<code>lrange</code>、<code>smembers</code>、<code>zrange</code>、<code>sinter</code>等并非不能使用，但是需要明确N的值。有遍历的需求可以使用<code>hscan</code>、<code>sscan</code>、<code>zscan</code>代替。</p></li><li><p>【推荐】：禁用命令</p><p> 禁止线上使用<code>keys</code>、<code>flushall</code>、<code>flushdb</code>等，通过redis的<code>rename</code>机制禁掉命令，或者使用<code>scan</code>的方式渐进式处理。</p></li><li><p>【推荐】合理使用<code>select</code></p><p> redis的多数据库较弱，使用数字进行区分，很多客户端支持较差，同时多业务用多数据库实际还是单线程处理，会有干扰。</p></li><li><p>【推荐】使用批量操作提高效率</p><p> 原生命令：例如<code>mget</code>、<code>mset</code>。</p><p> 非原生命令：可以使用<code>pipeline</code>提高效率。</p><p> 但要注意控制一次批量操作的元素个数(例如500以内，实际也和元素字节数有关)。</p><p> 注意两者不同：</p><ul><li>原生是原子操作，<code>pipeline</code>是非原子操作。</li><li><code>pipeline</code>可以打包不同的命令，原生做不到</li><li><code>pipeline</code>需要客户端和服务端同时支持。</li></ul></li><li><p>【建议】Redis事务功能较弱，不建议过多使用</p><p> Redis的事务功能较弱(不支持回滚)，而且集群版本(自研和官方)要求一次事务操作的key必须在一个slot上(可以使用hashtag功能解决)</p></li><li><p>【建议】Redis集群版本在使用Lua上有特殊要求：</p><ul><li>所有key都应该由 KEYS 数组来传递，<code>redis.call/pcall</code> 里面调用的redis命令，key的位置，必须是KEYS array, 否则直接返回error，<code>“-ERR bad lua script for redis cluster, all the keys that the script uses should be passed using the KEYS arrayrn”</code></li><li>所有key，必须在1个slot上，否则直接返回error, <code>“-ERR eval/evalsha command keys must in same slotrn”</code></li></ul></li><li><p>【建议】必要情况下使用<code>monitor</code>命令时，要注意不要长时间使用。</p></li></ol><h1 id="客户端使用"><a href="#客户端使用" class="headerlink" title="客户端使用"></a>客户端使用</h1><ol><li><p>【推荐】 避免多个应用使用一个Redis实例</p><p> 正例：不相干的业务拆分，公共数据做服务化。</p></li><li><p>【推荐】 使用带有连接池的数据库，可以有效控制连接，同时提高效率，标准使用方式：</p></li><li><p>【建议】 高并发下建议客户端添加熔断功能(例如netflix hystrix)</p></li><li><p>【推荐】 设置合理的密码，如有必要可以使用SSL加密访问（阿里云Redis支持）</p></li><li><p>【建议】根据自身业务类型，选好<code>maxmemory-policy</code>(最大内存淘汰策略)，设置好过期时间。</p><p> 默认策略是volatile-lru，即超过最大内存后，在过期键中使用lru算法进行key的剔除，保证不过期数据不被删除，但是可能会出现OOM问题。</p><p> 其他策略如下：</p><ul><li>allkeys-lru：根据LRU算法删除键，不管数据有没有设置超时属性，直到腾出足够空间为止。</li><li>allkeys-random：随机删除所有键，直到腾出足够空间为止。</li><li>volatile-random：随机删除过期键，直到腾出足够空间为止。</li><li>volatile-ttl：根据键值对象的ttl属性，删除最近将要过期数据。如果没有，回退到noeviction策略。</li><li>noeviction：不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息<code>“(error) OOM command not allowed when used memory”</code>，此时Redis只响应读操作。</li></ul></li></ol><h1 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h1><ol><li><p>【推荐】：数据同步</p><p> redis间数据同步可以使用：redis-port</p></li><li><p>【推荐】：big key搜索</p><p> <a href="https://developer.aliyun.com/article/117042" rel="external nofollow noopener noreferrer" target="_blank">redis大key搜索工具</a></p></li><li><p>【推荐】：热点key寻找(内部实现使用monitor，所以建议短时间使用)</p><p> <a href="https://github.com/facebookarchive/redis-faina" rel="external nofollow noopener noreferrer" target="_blank">facebook的redis-faina</a></p><p> PS:阿里云Redis已经在内核层面解决热点key问题。</p></li></ol><h1 id="附录：删除bigkey"><a href="#附录：删除bigkey" class="headerlink" title="附录：删除bigkey"></a>附录：删除bigkey</h1><ul><li><p>下面操作可以使用<code>pipeline</code>加速。</p></li><li><p>redis 4.0已经支持key的异步删除。</p></li></ul><ol><li>Hash删除: hscan + hdel</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delBigHash</span><span class="params">(String host,<span class="keyword">int</span> port,String password,String bigHashKey)</span></span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(host,port);</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isNotEmpty(password))&#123;</span><br><span class="line">        jedis.auth(password);</span><br><span class="line">    &#125;</span><br><span class="line">    ScanParams scanParams = <span class="keyword">new</span> ScanParams().count(<span class="number">100</span>);</span><br><span class="line">    String cursor = <span class="string">"0"</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        ScanResult&lt;Map.Entry&lt;String,String&gt;&gt; scanResult = jedis.hscan(bigHashKey,cursor,scanParams);</span><br><span class="line">        List&lt;Map.Entry&lt;String,String&gt;&gt; entryList = scanResult.getResult();</span><br><span class="line">        <span class="keyword">if</span>(CollectionUtils.isNotEmpty(entryList))&#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : entryList) &#123;</span><br><span class="line">                jedis.hdel(bigHashKey,entry.getKey());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = scanResult.getStringCursor();</span><br><span class="line">    &#125;<span class="keyword">while</span> (!<span class="string">"0"</span>.equals(cursor));</span><br><span class="line">    <span class="comment">//删除bigHashKey</span></span><br><span class="line">    jedis.del(bigHashKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>List删除: ltrim</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delBigList</span><span class="params">(String host,<span class="keyword">int</span> port,String password,String bigListKey)</span></span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(host,port);</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isNotEmpty(password))&#123;</span><br><span class="line">        jedis.auth(password);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> llen = jedis.llen(bigListKey);</span><br><span class="line">    <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">while</span> (counter&lt;llen)&#123;</span><br><span class="line">        <span class="comment">//每次从左边截掉100个</span></span><br><span class="line">        jedis.ltrim(bigListKey,left,llen);</span><br><span class="line">        counter += left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除bigListKey</span></span><br><span class="line">    jedis.del(bigListKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>Set删除: sscan + srem</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delBigSet</span><span class="params">(String host,<span class="keyword">int</span> port,String password,String bigSetKey)</span></span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(host,port);</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isNotEmpty(password))&#123;</span><br><span class="line">        jedis.auth(password);</span><br><span class="line">    &#125;</span><br><span class="line">    ScanParams scanParams = <span class="keyword">new</span> ScanParams().count(<span class="number">100</span>);</span><br><span class="line">    String cursor = <span class="string">"0"</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        ScanResult&lt;String&gt; scanResult = jedis.sscan(bigSetKey,cursor,scanParams);</span><br><span class="line">        List&lt;String&gt; memberList = scanResult.getResult();</span><br><span class="line">        <span class="keyword">if</span>(CollectionUtils.isNotEmpty(memberList))&#123;</span><br><span class="line">            <span class="keyword">for</span> (String s : memberList) &#123;</span><br><span class="line">                jedis.srem(bigSetKey,s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = scanResult.getStringCursor();</span><br><span class="line">    &#125;<span class="keyword">while</span> (!<span class="string">"0"</span>.equals(cursor));</span><br><span class="line">    <span class="comment">//删除bigSetKey</span></span><br><span class="line">    jedis.del(bigSetKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>SortedSet删除: zscan + zrem</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delBigZset</span><span class="params">(String host,<span class="keyword">int</span> port,String password,String bigZsetKey)</span></span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(host,port);</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isNotEmpty(password))&#123;</span><br><span class="line">        jedis.auth(password);</span><br><span class="line">    &#125;</span><br><span class="line">    ScanParams scanParams = <span class="keyword">new</span> ScanParams().count(<span class="number">100</span>);</span><br><span class="line">    String cursor = <span class="string">"0"</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        ScanResult&lt;Tuple&gt; scanResult = jedis.zscan(bigZsetKey,cursor,scanParams);</span><br><span class="line">        List&lt;Tuple&gt; tupleList = scanResult.getResult();</span><br><span class="line">        <span class="keyword">if</span>(CollectionUtils.isNotEmpty(tupleList))&#123;</span><br><span class="line">            <span class="keyword">for</span> (Tuple tuple : tupleList) &#123;</span><br><span class="line">                jedis.zrem(bigZsetKey,tuple.getElement());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = scanResult.getStringCursor();</span><br><span class="line">    &#125;<span class="keyword">while</span> (!<span class="string">"0"</span>.equals(cursor));</span><br><span class="line">    <span class="comment">//删除bigZsetKey</span></span><br><span class="line">    jedis.del(bigZsetKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Redis" scheme="https://www.sakuratears.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Gson转换遇到的问题</title>
    <link href="https://www.sakuratears.top/blog/Gson%E8%BD%AC%E6%8D%A2%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98.html"/>
    <id>https://www.sakuratears.top/blog/Gson转换遇到的问题.html</id>
    <published>2020-06-20T08:25:00.000Z</published>
    <updated>2020-06-20T08:32:08.567Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天在项目中遇到了一个Gson转换数字后会变为Double类型引起的Bug，特此记录一下。</p><p>背景是这样的，我们对于前端请求，有一个公共处理Controller，并根据请求里的接口名称将其分发给其他处理类（Controller）。</p><p>因为每个处理类的请求类Req和返回Res是不同的，但是它们的响应code和原因是可以提取的，因此拿到前端数据后，我们后台会处理并返回数据。</p><p>Req如下，我们会根据前端在Header和传过来的data数据组成如下Req分发给指定apiName的Controller。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonReq</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line">    <span class="keyword">private</span> String apiName;</span><br><span class="line">    <span class="keyword">private</span> String device;</span><br><span class="line">    <span class="keyword">private</span> String platform;</span><br><span class="line">    <span class="keyword">private</span> String version;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个业务实体类TestReq，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReq</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一切都是很正常的，直到我们升级了FastJson的版本后，便出现了异常。</p><h1 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h1><p>尝试定位问题，发现是枚举值转换抛出的异常，我们有一个枚举值，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Type &#123;</span><br><span class="line">    A(<span class="string">"1"</span>, <span class="string">"A"</span>),</span><br><span class="line">    B(<span class="string">"2"</span>, <span class="string">"B"</span>);</span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">    Type(String code, String desc) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCode</span><span class="params">(String code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDesc</span><span class="params">(String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Type <span class="title">getEnum</span><span class="params">(String code)</span> </span>&#123;</span><br><span class="line">        Optional&lt;Type&gt; optional = Arrays.stream(Type.values()).filter(e -&gt; e.code.equals(code)).findFirst();</span><br><span class="line">        <span class="keyword">return</span> optional.orElse(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前端传过来的为1，我们转换传A，这样。</p><p>跟踪了一下，发现原来过来的是”1”，但是现在变成了”1.0”。因此转换异常了。</p><p>继续检查，发现前端传的数据为int类型的1（其实我们接口定义的String），如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"apiName"</span>:<span class="string">"test"</span>,<span class="attr">"version"</span>:<span class="string">"v1"</span>,<span class="attr">"data"</span>:&#123;<span class="attr">"amount"</span>:<span class="string">"3672.0"</span>,<span class="attr">"type"</span>:<span class="number">1</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>然后我们系统会将该数据转化为<code>CommonReq&lt;TestReq></code>对象。</p><p>转化的时候我们发现<code>TestReq</code>里得到的type已经是1.0了。</p><p>继续检查发现在前端数据请求过来后，使用的是Gson进行转化的，由于不知道泛型T的具体类型，因此转换逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CommonReq commonReq = GsonUtil.json2Bean(str,CommonReq.class);</span><br></pre></td></tr></table></figure><p>我自己编写了测试类，经过测试，发现Gson确实会把1转换为1.0，但针对的是该类型不明的情况，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"&#123;\"apiName\":\"test\",\"version\":\"v1\",\"data\":&#123;\"amount\":\"3672.0\",\"type\":1&#125;&#125;"</span>;</span><br><span class="line">        CommonReq commonReq = GsonUtil.json2Bean(str,CommonReq.class);</span><br><span class="line">        LinkedTreeMap linkedTreeMap = (LinkedTreeMap) commonReq.getData();</span><br><span class="line">        System.out.println(linkedTreeMap.get(<span class="string">"type"</span>));;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-623.jpg" alt="upload successful"></p><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>但我观察之前请求的日志，前端传的也是int类型的1，但转换后就是”1”，而不是”1.0”，这又是什么原因呢。</p><p>由于我们升级过一次FastJson版本，但Gson的问题和FastJson又有什么关系呢？</p><p>因此继续排查，我发现了一个特别的地方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(commonReq.getData() <span class="keyword">instanceof</span> LinkedHashMap||commonReq.getData() <span class="keyword">instanceof</span> LinkedTreeMap) &#123;</span><br><span class="line">                String jsonStr = FastJsonConvert.convertObjectToJSON(commonReq.getData());</span><br><span class="line">                commonReq.setData(apiService.convertRequest(jsonStr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其重点在于<code>FastJsonConvert.convertObjectToJSON(reqVo.getData())</code>这段代码上。</p><p>我们看上面的列子，使用Gson转换后<code>CommonReq</code> 里的data对象为<code>LinkedTreeMap</code>，不能直接强转为<code>TestReq</code>对象，因此借助了FastJson将其转换为jsonStr，然后再转回来。</p><p>这样就会不同吗？</p><p>在升级之前，我们使用的FastJson是1.2.10，升级后为1.2.70。</p><p>我们使用1.2.10的FastJson，对Gson得到的<code>LinkedTreeMap</code>进行转换输出，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.10&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"&#123;\"apiName\":\"test\",\"version\":\"v1\",\"data\":&#123;\"amount\":\"3672.0\",\"type\":1&#125;&#125;"</span>;</span><br><span class="line">        CommonReq commonReq = GsonUtil.json2Bean(str,CommonReq.class);</span><br><span class="line">        String jsonStr = FastJsonUtil.bean2Json(commonReq.getData());</span><br><span class="line">        System.out.println(jsonStr);;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-624.jpg" alt="upload successful"></p><p>可以看到type为1.</p><p>我们继续使用1.2.70版本的FastJson进行试验时，可以看到它输出了1.0.</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-625.jpg" alt="upload successful"></p><p>我们实际对FastJson进行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TestVO testVO = <span class="keyword">new</span> TestVO();</span><br><span class="line">testVO.setF(<span class="number">1.0</span>);</span><br><span class="line">String jsonStr = FastJsonUtil.bean2Json(testVO);</span><br><span class="line">System.out.println(jsonStr);</span><br></pre></td></tr></table></figure><p>在1.2.10版本下，FastJson输出了<code>{“f”:1}</code>，在1.2.70版本下，输出了<code>{“f”:1.0}</code>。</p><p>在低版本下，未指定对象类型情况下，FastJson对于小数数字末尾包含0的，都会舍去。</p><p>到这里其实问题也比较清楚了，由于Gson对于未指定类型的数字，会将其转换成Double类型，而FastJson低版本中，对于未指定的浮点数字，如果末尾为0，就会去掉，进而显示整数，而在高版本里解决了这个问题。</p><p>我们系统升级了FastJson，因而出现了问题。</p><p>但归根结底这个问题是由Gson引起的，因为Gson对于未指定类型的数字，会将其转换成Double类型，至目前原作者也没有修复这个问题。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过这个问题排查总结，我们能从中学到一点有用的东西。</p><ol><li>在一个项目中尽量使用一种Json转换工具，如Jackson、Fastjson、Gson，将它们在项目中混用既不方便维护，也加大了问题的排查难度，而且不同的Json转换工具转换出来的Json串可能相互处理起来并不友好。</li><li><p>这个问题，我们最终将Gson替换为Fastjson，从而解决了问题。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-626.jpg" alt="upload successful"></p><p>可以看到只使用FastJson，我们得到的数据不会被转换为Double。</p></li><li><p>在与客户端商定报文格式时，客户端应尽量传送的报文格式与服务端定义的类型一致。</p></li><li><p>关于如果使用Gson，如何避免出现未指定类型的整数转换为double的问题，可以参考这篇文章。</p><p><a href="https://stackoverflow.com/questions/36508323/how-can-i-prevent-gson-from-converting-integers-to-doubles" rel="external nofollow noopener noreferrer" target="_blank">how-can-i-prevent-gson-from-converting-integers-to-doubles</a></p></li></ol><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>其实客户端应该上送String类型的1而不是int类型的，但考虑但客户端需要发版，且旧版本客户端后端仍需要兼容，进而改为让服务端进行兼容改造，客户端迭代进行变更处理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="FastJson" scheme="https://www.sakuratears.top/tags/FastJson/"/>
    
      <category term="Gson" scheme="https://www.sakuratears.top/tags/Gson/"/>
    
  </entry>
  
  <entry>
    <title>【转】Java 12 特性及更新</title>
    <link href="https://www.sakuratears.top/blog/%E3%80%90%E8%BD%AC%E3%80%91Java-12-%E7%89%B9%E6%80%A7%E5%8F%8A%E6%9B%B4%E6%96%B0.html"/>
    <id>https://www.sakuratears.top/blog/【转】Java-12-特性及更新.html</id>
    <published>2020-04-29T06:46:00.000Z</published>
    <updated>2020-04-29T06:48:01.856Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://howtodoinjava.com/java12/new-features-enhancements/" rel="external nofollow noopener noreferrer" target="_blank">原文链接</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java 12(发布于2019年3月19日)是JDK的最新版本。让我们看看它为开发人员和架构师带来的新特性和改进。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Stream-API-新的方法-Collectors-teeing"><a href="#Stream-API-新的方法-Collectors-teeing" class="headerlink" title="Stream API 新的方法 Collectors.teeing()"></a>Stream API 新的方法 Collectors.teeing()</h2><p>此收集器将其输入转发给其他两个收集器，然后将它们的结果与一个函数合并。它是一个静态方法<code>Collectors::teeing</code>.</p><p><code>teeing(Collector, Collector, BiFunction)</code> 接受两个收集器和一个函数来合并它们的结果。传递给结果收集器的每个元素都由两个下游收集器处理，然后使用指定的merge函数将它们的结果合并到最终结果中。</p><p>例如，在给定的雇员列表中，如果我们想要找出拥有最高工资和最低工资的雇员，我们可以使用此收集器在单个语句中完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SalaryRange salaryRange = Stream</span><br><span class="line">            .of(<span class="number">56700</span>, <span class="number">67600</span>, <span class="number">45200</span>, <span class="number">120000</span>, <span class="number">77600</span>, <span class="number">85000</span>)</span><br><span class="line">            .collect(teeing(</span><br><span class="line">                    minBy(Integer::compareTo), </span><br><span class="line">                    maxBy(Integer::compareTo), </span><br><span class="line">                    SalaryRange::fromOptional));</span><br></pre></td></tr></table></figure><p>关于更多的关于此收集器的内容，可以查看<a href="https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/stream/Collectors.html#teeing(java.util.stream.Collector,java.util.stream.Collector,java.util.function.BiFunction" rel="external nofollow noopener noreferrer" target="_blank">Collectors.teeing()</a>)这篇文章。</p><h2 id="String-API-变化"><a href="#String-API-变化" class="headerlink" title="String API 变化"></a>String API 变化</h2><h3 id="String-indent"><a href="#String-indent" class="headerlink" title="String.indent()"></a>String.indent()</h3><p>这个缩进方法有助于更改字符串的缩进。我们可以传递一个正值，也可以传递一个负值，这取决于我们是想要添加更多的空白还是删除现有的空白。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String result = <span class="string">"foo\nbar\nbar2"</span>.indent(<span class="number">4</span>);</span><br><span class="line"> </span><br><span class="line">System.out.println(result);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//    foo</span></span><br><span class="line"><span class="comment">//    bar</span></span><br><span class="line"><span class="comment">//    bar2</span></span><br></pre></td></tr></table></figure><p>需要注意，indent()方法会自动添加新行字符(如果没有的话)。这是意料之中的，也是新方法的一个特点。</p><blockquote><p>每个空白字符都被视为单个字符。特别是制表符<code>“\t” (U+0009)</code>被认为是单个字符;它没有展开。</p></blockquote><h3 id="String-transform"><a href="#String-transform" class="headerlink" title="String.transform()"></a>String.transform()</h3><p><code>transform()</code>方法获取一个字符串，并在函数的帮助下将其转换为一个新字符串。</p><p>在给定的示例中，我们有一个名称列表。我们使用<code>transform()</code>方法执行两个操作(删除空白和将所有名称设置为大小写)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = List.of(</span><br><span class="line">                        <span class="string">"   Alex"</span>,</span><br><span class="line">                        <span class="string">"brian"</span>);</span><br><span class="line"> </span><br><span class="line">List&lt;String&gt; transformedNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (String name : names) </span><br><span class="line">&#123;</span><br><span class="line">    String transformedName = name.transform(String::strip)</span><br><span class="line">                                .transform(StringUtils::toCamelCase);</span><br><span class="line"> </span><br><span class="line">    transformedNames.add(transformedName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="String-constants"><a href="#String-constants" class="headerlink" title="String constants"></a>String constants</h3><p>从Java 12开始，String类实现了两个额外的接口<code> java.lang.constant.Constable</code>和<code>java.lang.constant.ConstantDesc</code>。</p><p><code>String</code>类还引入了另外两个低级方法<code>describeConstable()</code>和<code>resolveConstantDesc(MethodHandles.Lookup)</code>。</p><p>它们是低级api，用于库和提供字节码解析和生成功能的工具，例如Byte Buddy。</p><p>注意，<code>Constable</code>类型的值是常量，可以在<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.4" rel="external nofollow noopener noreferrer" target="_blank">JVMS 4.4</a>中描述的Java类文件的常量池中表示，它的实例可以在名义上将自己描述为<code>ConstantDesc</code>。</p><p><code>resolveConstantDesc()</code>类似于<code>describeConstable()</code>，不同之处在于这个方法返回的是<code>ConstantDesc</code>的一个实例。</p><h2 id="Files-mismatch-Path-Path"><a href="#Files-mismatch-Path-Path" class="headerlink" title="Files.mismatch(Path, Path)"></a>Files.mismatch(Path, Path)</h2><p>有时，我们希望确定两个文件是否具有相同的内容。这个API有助于比较文件的内容。</p><p><code>mismatch()</code>方法比较两个文件路径并返回一个long值。long值表示两个文件内容中<strong>第一个不匹配的字节</strong>的位置。如果文件内容相同，返回值将是“-1”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Path helloworld1 = tempDir.resolve(<span class="string">"helloworld1.txt"</span>);</span><br><span class="line"> </span><br><span class="line">Path helloworld2 = tempDir.resolve(<span class="string">"helloworld2.txt"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">long</span> diff = Files.mismatch(helloworld1, helloworld2);   <span class="comment">//returns long value</span></span><br></pre></td></tr></table></figure><h2 id="数字格式"><a href="#数字格式" class="headerlink" title="数字格式"></a>数字格式</h2><p>由用户界面或命令行工具呈现的大数字总是很难解析。使用数字的缩写形式要普遍得多。紧凑的数字表示更易于阅读，并且在不丢失原始含义的情况下，在屏幕上需要更少的空间。</p><p>例: <code>3.6 M</code> 比 <code>3,600,000</code> 容易读得多。</p><p>Java 12引入了一个<code>NumberFormat.getCompactNumberInstance(Locale, NumberFormat.Style)</code>的方便方法用于创建紧凑数字表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NumberFormat formatter = NumberFormat.getCompactNumberInstance(Locale.US,</span><br><span class="line">                                                        NumberFormat.Style.SHORT);</span><br><span class="line"> </span><br><span class="line">String formattedString = formatter.format(<span class="number">25000L</span>);      <span class="comment">//25K</span></span><br></pre></td></tr></table></figure><h2 id="Unicode-11-相关支持"><a href="#Unicode-11-相关支持" class="headerlink" title="Unicode 11 相关支持"></a>Unicode 11 相关支持</h2><p>在一个emoji表情符号在社交媒体渠道上扮演着重要角色的时代，支持最新的Unicode规范比以往任何时候都更重要。Java 12保持了同步并支持Unicode 11。</p><p>Unicode 11增加了684个字符，总共有137374个字符，还有7个新脚本，总共有146个脚本。</p><h2 id="switch-表达式扩展"><a href="#switch-表达式扩展" class="headerlink" title="switch 表达式扩展"></a>switch 表达式扩展</h2><p>这个更改扩展了switch语句，因此它既可以用作语句，也可以用作表达式。</p><p>我们可以简单地使用箭头语法，而不必为每个case块定义一个break语句。箭头语法在语义上看起来像一个lambda，它将大小写标签从表达式中分离出来。</p><p>使用新的switch表达式，我们可以直接将switch语句分配给一个变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isWeekend = <span class="keyword">switch</span> (day) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -&gt; <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> SATURDAY, SUNDAY -&gt; <span class="keyword">true</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">default</span> -&gt; <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Illegal day entry :: "</span> + day);</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">System.out.println(isWeekend);<span class="comment">//根据输入日期返回true或false</span></span><br></pre></td></tr></table></figure><blockquote><p>要使用此特性，请记住，我们必须在应用程序启动期间使用<code>-enable-preview</code>标志显式地指示JVM。</p></blockquote><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>以上就是关于Java 12 的全部内容。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java 12" scheme="https://www.sakuratears.top/tags/Java-12/"/>
    
  </entry>
  
  <entry>
    <title>【转】Java 11 特性及更新</title>
    <link href="https://www.sakuratears.top/blog/%E3%80%90%E8%BD%AC%E3%80%91Java-11-%E7%89%B9%E6%80%A7%E5%8F%8A%E6%9B%B4%E6%96%B0.html"/>
    <id>https://www.sakuratears.top/blog/【转】Java-11-特性及更新.html</id>
    <published>2020-04-23T06:46:00.000Z</published>
    <updated>2020-04-23T06:48:45.136Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://howtodoinjava.com/java11/features-enhancements/" rel="external nofollow noopener noreferrer" target="_blank">原文链接</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java 11(于2018年9月发布)包含许多重要和有用的更新。让我们看看它为开发人员和架构师带来的新特性和改进。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="HTTP-Client-API"><a href="#HTTP-Client-API" class="headerlink" title="HTTP Client API"></a>HTTP Client API</h2><p>Java长期使用HttpURLConnection类进行HTTP通信。但是随着时间的推移，需求变得越来越复杂，对应用程序的要求也越来越高。在Java 11之前，开发人员不得不求助于功能丰富的库，如<em>Apache HttpComponents</em>或<em>OkHttp</em>等。</p><p>我们看到Java 9发布版将<code>HttpClient</code>实现作为一个实验性特性包括在内。它随着时间的推移而发展，现在是Java 11的最后一个特性。现在，Java应用程序可以进行HTTP通信，而不需要任何外部依赖。</p><h3 id="如何使用HttpClient"><a href="#如何使用HttpClient" class="headerlink" title="如何使用HttpClient"></a>如何使用HttpClient</h3><p>它与<code>java.net.http</code>模块的经典HTTP通信是类似的：</p><ul><li>创建一个HttpClient实例，并根据需要配置它。</li><li>创建HttpRequest实例并填充信息。</li><li>将请求传递给客户机，执行请求并检索HttpResponse的实例。</li><li>处理HttpResponse中包含的信息。</li></ul><p>HTTP API可以处理同步和异步通信。让我们来看一个简单的例子。</p><h3 id="同步请求例子"><a href="#同步请求例子" class="headerlink" title="同步请求例子"></a>同步请求例子</h3><p>注意，Http客户端API如何使用builder模式来创建复杂对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> java.net.http.HttpClient;</span><br><span class="line"><span class="keyword">import</span> java.net.http.HttpRequest;</span><br><span class="line"><span class="keyword">import</span> java.net.http.HttpResponse;</span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"> </span><br><span class="line">HttpClient httpClient = HttpClient.newBuilder()</span><br><span class="line">                        .connectTimeout(Duration.ofSeconds(<span class="number">10</span>))</span><br><span class="line">                        .build();                                  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    String urlEndpoint = <span class="string">"https://postman-echo.com/get"</span>;</span><br><span class="line">    URI uri = URI.create(urlEndpoint + <span class="string">"?foo1=bar1&amp;foo2=bar2"</span>);</span><br><span class="line">    HttpRequest request = HttpRequest.newBuilder()</span><br><span class="line">                                    .uri(uri)</span><br><span class="line">                                    .build();                              </span><br><span class="line">    HttpResponse&lt;String&gt; response = httpClient.send(request,</span><br><span class="line">                                        HttpResponse.BodyHandlers.ofString()); </span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">System.out.println(<span class="string">"Status code: "</span> + response.statusCode());                            </span><br><span class="line">System.out.println(<span class="string">"Headers: "</span> + response.headers().allValues(<span class="string">"content-type"</span>));               </span><br><span class="line">System.out.println(<span class="string">"Body: "</span> + response.body());</span><br></pre></td></tr></table></figure><h3 id="异步请求例子"><a href="#异步请求例子" class="headerlink" title="异步请求例子"></a>异步请求例子</h3><p>如果我们不想等待响应，可以使用异步通信。我们提供回调处理程序，它在响应可用时执行。</p><p>注意使用<code>sendAsync()</code>方法发送异步请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> java.net.http.HttpClient;</span><br><span class="line"><span class="keyword">import</span> java.net.http.HttpRequest;</span><br><span class="line"><span class="keyword">import</span> java.net.http.HttpResponse;</span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.Collectors.toList;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">final</span> List&lt;URI&gt; uris = Stream.of(</span><br><span class="line">                        <span class="string">"https://www.google.com/"</span>,</span><br><span class="line">                        <span class="string">"https://www.github.com/"</span>,</span><br><span class="line">                        <span class="string">"https://www.yahoo.com/"</span></span><br><span class="line">                        ).map(URI::create).collect(toList());      </span><br><span class="line"> </span><br><span class="line">HttpClient httpClient = HttpClient.newBuilder()</span><br><span class="line">                        .connectTimeout(Duration.ofSeconds(<span class="number">10</span>))</span><br><span class="line">                        .followRedirects(HttpClient.Redirect.ALWAYS)</span><br><span class="line">                        .build();</span><br><span class="line"> </span><br><span class="line">CompletableFuture[] futures = uris.stream()</span><br><span class="line">                            .map(uri -&gt; verifyUri(httpClient, uri))</span><br><span class="line">                            .toArray(CompletableFuture[]::<span class="keyword">new</span>);     </span><br><span class="line"> </span><br><span class="line">CompletableFuture.allOf(futures).join();           </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> CompletableFuture&lt;Void&gt; <span class="title">verifyUri</span><span class="params">(HttpClient httpClient, </span></span></span><br><span class="line"><span class="function"><span class="params">                                          URI uri)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HttpRequest request = HttpRequest.newBuilder()</span><br><span class="line">                                    .timeout(Duration.ofSeconds(<span class="number">5</span>))</span><br><span class="line">                                    .uri(uri)</span><br><span class="line">                                    .build();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> httpClient.sendAsync(request,HttpResponse.BodyHandlers.ofString())</span><br><span class="line">                        .thenApply(HttpResponse::statusCode)</span><br><span class="line">                        .thenApply(statusCode -&gt; statusCode == <span class="number">200</span>)</span><br><span class="line">                        .exceptionally(ex -&gt; <span class="keyword">false</span>)</span><br><span class="line">                        .thenAccept(valid -&gt; </span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">                                System.out.println(<span class="string">"[SUCCESS] Verified "</span> + uri);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                System.out.println(<span class="string">"[FAILURE] Could not "</span> + <span class="string">"verify "</span> + uri);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);                                    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不用编译运行一个单文件项目"><a href="#不用编译运行一个单文件项目" class="headerlink" title="不用编译运行一个单文件项目"></a>不用编译运行一个单文件项目</h2><p>通常，对于我们想要执行的每个程序，我们都需要首先编译它为class文件。对于用于测试的小程序来说，这似乎是一个不必要的冗长过程。</p><p>Java 11做出了改变，现在我们可以执行包含在单个文件中的Java源代码，而不需要首先编译它。</p><p><strong>HelloWorld.java</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>要执行上面的类，直接用<code>java</code>命令运行它。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ java HelloWorld.java</span><br><span class="line"> </span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，程序不能使用除<code>java.base</code>模块之外的任何外部依赖项，并且程序只能是单文件程序。</p></blockquote><h2 id="String-API变更"><a href="#String-API变更" class="headerlink" title="String API变更"></a>String API变更</h2><h3 id="String-repeat-Integer"><a href="#String-repeat-Integer" class="headerlink" title="String.repeat(Integer)"></a>String.repeat(Integer)</h3><p>这个方法简单地重复一个字符串n次。它返回一个字符串，其值是重复N次的给定字符串的串联。</p><p>如果该字符串为空或count为零，则返回空字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String str = <span class="string">"1"</span>.repeat(<span class="number">5</span>);</span><br><span class="line"> </span><br><span class="line">        System.out.println(str);    <span class="comment">//11111</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="String-isBlank"><a href="#String-isBlank" class="headerlink" title="String.isBlank()"></a>String.isBlank()</h3><p>此方法判断字符串是否为空或者为空字符串。在此之前，我们一直在使用Apache开源包的<code>StringUtils.java</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="string">"1"</span>.isBlank();  <span class="comment">//false</span></span><br><span class="line"> </span><br><span class="line">        <span class="string">""</span>.isBlank();   <span class="comment">//true</span></span><br><span class="line"> </span><br><span class="line">        <span class="string">"    "</span>.isBlank();   <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="String-strip"><a href="#String-strip" class="headerlink" title="String.strip()"></a>String.strip()</h3><p>此方法负责删除开头和结尾空白。我们可以更具体地使用<code>String.stripLeading() </code>删除开头空白，或者使用<code>String.stripTrailing()</code>删除结尾空白。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="string">"   hi  "</span>.strip();  <span class="comment">//"hi"</span></span><br><span class="line"> </span><br><span class="line">       <span class="string">"   hi  "</span>.stripLeading();    <span class="comment">//"hi   "</span></span><br><span class="line"> </span><br><span class="line">       <span class="string">"   hi  "</span>.stripTrailing();   <span class="comment">//"   hi"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="String-lines"><a href="#String-lines" class="headerlink" title="String.lines()"></a>String.lines()</h3><p>这个方法有助于将多行文本处理为一个流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String testString = <span class="string">"hello\nworld\nis\nexecuted"</span>;</span><br><span class="line"> </span><br><span class="line">        List&lt;String&gt; lines = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">        testString.lines().forEach(line -&gt; lines.add(line));</span><br><span class="line"> </span><br><span class="line">        assertEquals(List.of(<span class="string">"hello"</span>, <span class="string">"world"</span>, <span class="string">"is"</span>, <span class="string">"executed"</span>), lines);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Collection-toArray-IntFunction"><a href="#Collection-toArray-IntFunction" class="headerlink" title="Collection.toArray(IntFunction)"></a>Collection.toArray(IntFunction)</h2><p>在Java 11之前，将集合转换为数组并不方便。Java 11使转换更加方便。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        names.add(<span class="string">"alex"</span>);</span><br><span class="line">        names.add(<span class="string">"brian"</span>);</span><br><span class="line">        names.add(<span class="string">"charles"</span>);</span><br><span class="line"> </span><br><span class="line">        String[] namesArr1 = names.toArray(<span class="keyword">new</span> String[names.size()]);       <span class="comment">//Before Java 11</span></span><br><span class="line"> </span><br><span class="line">        String[] namesArr2 = names.toArray(String[]::<span class="keyword">new</span>);                  <span class="comment">//Since Java 11</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Files-readString-和-Files-writeString"><a href="#Files-readString-和-Files-writeString" class="headerlink" title="Files.readString() 和 Files.writeString()"></a>Files.readString() 和 Files.writeString()</h2><p>使用这些重载的方法，Java 11旨在减少大量的样板代码，使文件的读写更加容易。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//Read file as string</span></span><br><span class="line">        URI txtFileUri = getClass().getClassLoader().getResource(<span class="string">"helloworld.txt"</span>).toURI();</span><br><span class="line"> </span><br><span class="line">        String content = Files.readString(Path.of(txtFileUri),Charset.defaultCharset());</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//Write string to file</span></span><br><span class="line">        Path tmpFilePath = Path.of(File.createTempFile(<span class="string">"tempFile"</span>, <span class="string">".tmp"</span>).toURI());</span><br><span class="line"> </span><br><span class="line">        Path returnedFilePath = Files.writeString(tmpFilePath,<span class="string">"Hello World!"</span>, </span><br><span class="line">                                    Charset.defaultCharset(), StandardOpenOption.WRITE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Optional-isEmpty"><a href="#Optional-isEmpty" class="headerlink" title="Optional.isEmpty()"></a>Optional.isEmpty()</h2><p>Optional是一个容器对象，它可以包含也可以不包含一个非空值。如果没有值，则认为该对象是空的。</p><p>如果存在值，则先前存在的方法<code>isPresent()</code>返回true，否则返回false。有时，它迫使我们写出不方便阅读的判断语句。</p><p><code>isEmpty()</code>方法与<code>isPresent()</code>方法相反，如果有值，则返回false，否则返回true。</p><p>所以在任何情况下我们都不需要写出相反的条件。在适当的时候使用这两种方法中的任何一种。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String currentTime = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">        assertTrue(!Optional.ofNullable(currentTime).isPresent());  <span class="comment">//It's negative condition</span></span><br><span class="line">        assertTrue(Optional.ofNullable(currentTime).isEmpty());     <span class="comment">//Write it like this</span></span><br><span class="line"> </span><br><span class="line">        currentTime = <span class="string">"12:00 PM"</span>;</span><br><span class="line"> </span><br><span class="line">        assertFalse(!Optional.ofNullable(currentTime).isPresent()); <span class="comment">//It's negative condition</span></span><br><span class="line">        assertFalse(Optional.ofNullable(currentTime).isEmpty());    <span class="comment">//Write it like this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>以上就是关于Java 11 更新的内容。</p><p>相关链接: <a href="https://docs.oracle.com/en/java/javase/11/" rel="external nofollow noopener noreferrer" target="_blank">Java 11 release doc</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java 11" scheme="https://www.sakuratears.top/tags/Java-11/"/>
    
  </entry>
  
</feed>
