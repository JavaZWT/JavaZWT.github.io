<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SakuraTears的博客</title>
  
  <subtitle>越努力越幸运</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.sakuratears.top/"/>
  <updated>2018-06-12T14:48:22.594Z</updated>
  <id>https://www.sakuratears.top/</id>
  
  <author>
    <name>SakuraTears</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java线程池</title>
    <link href="https://www.sakuratears.top/blog/Java%E7%BA%BF%E7%A8%8B%E6%B1%A020180610/"/>
    <id>https://www.sakuratears.top/blog/Java线程池20180610/</id>
    <published>2018-06-10T03:59:00.000Z</published>
    <updated>2018-06-12T14:48:22.594Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java中，创建线程的方式一般有三种方法：</p><ol><li><p>继承Thread类创建线程</p></li><li><p>实现Runnable接口创建线程</p></li><li><p>使用Callable和Future创建线程</p></li></ol><p>关于三种创建方法本文不再赘述。</p><p>可以看出，以上创建线程的方式，都缺乏对线程的管理，我们设想，如果线程在调用过程中使用了某一资源，当该资源处理缓慢或异常时，可能产生大量线程等待的情况，严重时可能造成OOM异常。</p><p>针对以上情况，应该对创建线程进行管理，这样线程池便产生了，好在在jdk1.5时，Doug Lea大神已经帮我们实现了这些功能，它们均在java.util.concurrent包下。建议大家想学习多线程，把该包下的源码理解，一定对多线程会有更深入的理解。</p><p>本文重点讲述线程池，会对以下这几个类（接口）进行重点讲解。</p><p><strong>Executor，ExecutorService，Executors，AbstractExecutorService，ThreadPoolExecutor</strong></p><h1 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h1><p>我们先来简单说下线程池的使用：</p><ol><li><p>缓存型线程池</p><p> 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。<br> Executors.newCachedThreadPool</p><p> 简单使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">cachedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Thread id="</span> + Thread.currentThread().getId() + <span class="string">";index="</span> + index);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定长线程池</p><p> 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。<br> Executors.newFixedThreadPool</p><p> 简单使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">fixedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"Thread id="</span> + Thread.currentThread().getId() + <span class="string">";index="</span> + index);</span><br><span class="line">Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>定时及周期性任务性线程池</p><p>  创建一个定长线程池，支持定时及周期性任务执行。<br>  Executors.newScheduledThreadPool</p><p> 简单使用：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">scheduledThreadPool.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Thread id="</span>+Thread.currentThread().getId()+<span class="string">";5s后,每2s执行一次"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="number">5</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><ol start="4"><li><p>单线程型线程池</p><p> 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。<br> Executors.newSingleThreadExecutor</p><p> 简单使用：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">singleThreadExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"Thread id="</span>+Thread.currentThread().getId()+<span class="string">";index="</span>+index);</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><p>自定义线程池</p><p> 创建一个自定义线程池，以优化线程池。</p><p> 根据Executors源码，可以看出：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 线程池的实现使用ThreadPoolExecutor这个类实现的。这个类全参参数有以下几个：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                         TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                         BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                         ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                         RejectedExecutionHandler handler)</span> </span>&#123;</span><br></pre></td></tr></table></figure><p> ① corePoolSize：核心线程池大小<br>    取值范围 0-Integer.MaxValue<br> ② maximumPoolSize：最大线程池大小<br>    取值范围 0-Integer.MaxValue<br> ③ keepAliveTime：线程空闲时存活时间<br> ④ unit：线程空闲时存活时间单位<br> ⑤ workQueue：工作队列类型，线程队列类型<br> 队列分类：<br> 直接提交策略：SynchronousQueue，其无法设置队列长度，所有线程均直接提交给线程池。<br> 无界队列：LinkedBlockingQueue，如果默认不设置初始长度，这个队列是无界的，可缓存大量等待线程。<br> 有界队列：ArrayBlockingQueue，必须设置初始长度，线程池满，且达到队列最大长度后执行拒绝策略。<br> ⑥ threadFactory：线程工厂<br> ⑦ handler：线程池饱和后的拒绝策略<br>     ThreadPoolExecutor定义了四种，我们也可以自己定义：<br>         ThreadPoolExecutor.AbortPolicy：拒绝该任务并抛出异常<br>         ThreadPoolExecutor.CallerRunsPolicy：直接在 execute 方法的调用线程中运行被拒绝的任务；如果执行程序已关闭，则会丢弃该任务<br>         ThreadPoolExecutor.DiscardOldestPolicy：直接丢弃正在执行的任务，并执行该任务<br>         ThreadPoolExecutor.DiscardPolicy：丢弃该任务   </p><p> 可以看出，当业务情况复杂时，Executors里提供的几种基本的线程池已经不能满足我们的要求，需要我们根据情况自定义线程池，而且可以举个例子，比如对于newCachedThreadPool创建线程池的方法，它传入的maximumPoolSize为Integer的Max值，如果业务资源异常，创建大量线程而不释放，newCachedThreadPool这种创建线程池的方法也能导致OOM异常。</p><p> 而我们声明最大线程池大小，并声明拒绝策略。如下：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService myExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line"><span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">5</span>), <span class="keyword">new</span> AbortPolicy());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">myExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Thread id="</span> + Thread.currentThread().getId() + <span class="string">";index="</span> + index);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">10000000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 可以有效防止OOM异常以及及时发现系统运行问题。</p><p> 自定义线程池也是被推荐的创建线程池的方法。</p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>下面我们主要对ThreadPoolExecutor这个类进行分析。</p><p>我们先看下它的execute方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//获取线程数量</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">//如果线程池线程数量小于核心线程数，那么试着向核心线程池添加一个线程</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">    <span class="comment">//添加成功就返回</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//添加不成功就再次拿到线程数量</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果添加失败了，或者线程池数量达到了核心线程池数量</span></span><br><span class="line">    <span class="comment">//那么判断下运行状态，然后试着向工作等待队列里添加此线程</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">//如果不是运行状态，那么试着从工作队列移除此线程</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">        <span class="comment">//成功就进行拒绝策略处理</span></span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">//如果核心线程池和队列都满了，达到CAPACITY</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//那么尝试将任务添加至非核心线程池</span></span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果添加失败，执行拒绝策略</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看下addWorker方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">//sakuratears</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">//拿下线程运行状态</span></span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">        <span class="comment">//如果程序停止或者状态不是暂停并且任务不为空并且任务队列不为空，添加失败</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">//数量大于CAPACITY或者数量大于corePoolSize（向核心线程池添加时）或者maximumPoolSize（向非核心线程池添加时），返回添加失败</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//试着计算下当前线程数量</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">            <span class="comment">//成功跳出循环</span></span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            <span class="comment">//不成功就重读ctl</span></span><br><span class="line">            c = ctl.get(); </span><br><span class="line">            <span class="comment">//如果当前状态与开始线程状态不一致</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">            <span class="comment">//重试循环</span></span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//获得锁</span></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        <span class="comment">//创建一个新的Worker</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"><span class="comment">//如果是运行状态，或者核心线程池暂停，但要将线程添加到非核心线程池中</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) </span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    <span class="comment">//添加线程</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="comment">//记录曾经有过的最大线程数</span></span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//解锁</span></span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">            <span class="comment">//启动</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">        <span class="comment">//线程启动失败，执行失败操作</span></span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多代码不一一赘述。上面代码基本是线程池的核心原理。</p><p>通俗点讲，线程池工作分为下面几步：</p><ol><li>根据传入参数，设置核心线程池数量，最大线程池数量，拒绝策略，线程工作队列</li><li>当添加一个线程时，如果线程池线程数小于核心线程数，直接开启一个新线程执行任务。</li><li>如果核心线程池满了，那么把它添加到工作队列中。</li><li>如果核心线程池和工作队列都满了，则开启非核心线程执行任务。</li><li>如果全部都满了，执行拒绝策略。</li></ol><p>以上就是对线程池的全部分析。</p><h1 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h1><p>我的个人博客：</p><p><a href="https://www.sakuratears.top">https://www.sakuratears.top</a></p><p>GitHub地址：</p><p><a href="https://github.com/javazwt" target="_blank" rel="noopener">https://github.com/javazwt</a></p><p>欢迎关注。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Java中，创建线程的方式一般有三种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;继承Thread类创建线程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>未闻花名</title>
    <link href="https://www.sakuratears.top/blog/%E6%9C%AA%E9%97%BB%E8%8A%B1%E5%90%8D20180609/"/>
    <id>https://www.sakuratears.top/blog/未闻花名20180609/</id>
    <published>2018-06-09T14:30:00.000Z</published>
    <updated>2018-06-14T06:53:45.701Z</updated>
    
    <content type="html"><![CDATA[<center>已知花意</center><br><center>未见其花</center><br><center>已见其花</center><br><center>未闻花名</center><br><center>再见其花</center><br><center>落泪千溟</center><br><center>未闻花名</center><br><center>但识花香</center><br><center>已知花名</center><br><center>花已不在</center><br><center>未闻花名</center><br><center>但识花香</center><br><center>再遇花时</center><br><center>泪已千行</center><p><br></p><blockquote><hr></blockquote><blockquote><p>某天，你无端想起一个人，她曾让你对明天有所期许，但她却完全没有出现在你的明天里。————《再见金华站》</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;已知花意&lt;/center&gt;&lt;br&gt;&lt;center&gt;未见其花&lt;/center&gt;&lt;br&gt;&lt;center&gt;已见其花&lt;/center&gt;&lt;br&gt;&lt;center&gt;未闻花名&lt;/center&gt;&lt;br&gt;&lt;center&gt;再见其花&lt;/center&gt;&lt;br&gt;&lt;center&gt;落泪千溟&lt;/c
      
    
    </summary>
    
      <category term="随笔" scheme="https://www.sakuratears.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>MarkDown语法</title>
    <link href="https://www.sakuratears.top/blog/MarkDown%E8%AF%AD%E6%B3%9520180605/"/>
    <id>https://www.sakuratears.top/blog/MarkDown语法20180605/</id>
    <published>2018-06-05T14:17:00.000Z</published>
    <updated>2018-06-12T14:48:43.114Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近自己搭建了一个博客网站，写文章时用到了markdown语法，之前虽未接触过markdown语法，但在两三天的使用过程中感觉markdown语法很棒，写法简洁，而且支持Html语言。特总结一些常用的语法如下：</p><h2 id="语法汇总"><a href="#语法汇总" class="headerlink" title="语法汇总"></a>语法汇总</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>markdown有6种标题，写法如下：</p><table><thead><tr><th>级别</th><th style="text-align:center">写法</th></tr></thead><tbody><tr><td>1级</td><td style="text-align:center"># 大标题</td></tr><tr><td>2级</td><td style="text-align:center">## 前言</td></tr><tr><td>3级</td><td style="text-align:center">### 语法汇总</td></tr><tr><td>4级</td><td style="text-align:center">#### 标题</td></tr><tr><td>5级</td><td style="text-align:center">##### 标题5</td></tr><tr><td>6级</td><td style="text-align:center">###### 标题6</td></tr></tbody></table><p><strong>注意：</strong>#号和文字之间有空格</p><h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><p>写完一段话，一般空出一行便可以分为两个段落，如果不主动空行，其便会认为为一个段落。<br>也可以在一段话的结束输入两个空格，markdown也会换行。</p><p><strong>注意：</strong>这两种换行，第一种间距大。我现在这段话分别用了空格换行和空行换行。</p><h3 id="tab键"><a href="#tab键" class="headerlink" title="tab键"></a>tab键</h3><pre><code>这是一段用了tab缩进的话。    这是用了两个tab缩进的话。这是一段很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长的话。</code></pre><p><strong>注意：</strong>当一段话过长时，这样生成的句子可能不换行，而是在下面有一个拉动条。</p><h3 id="资源引用"><a href="#资源引用" class="headerlink" title="资源引用"></a>资源引用</h3><ol><li><p>引用静态资源时，如img，png，gif等</p><p> 语法：![图片名称](图片的绝对路径或者相对路径)</p><pre><code>![upload successful](/images/pasted-10.png)</code></pre></li><li><p>引用网址时，直接贴上网址就能识别</p><p> 我的博客：<a href="https://javazwt.github.io/" target="_blank" rel="noopener">https://javazwt.github.io/</a></p></li></ol><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>语法：</p><pre><code>| Name        |      Value   | |-------------|:-----------: || sakuratears |  999999      |  </code></pre><p>效果：</p><table><thead><tr><th>Name</th><th style="text-align:center">Value</th></tr></thead><tbody><tr><td>sakuratears</td><td style="text-align:center">999999</td></tr></tbody></table><p><strong>注意：</strong>在表头下方的分隔线标记中加入 :，即可标记下方单元格内容的对齐方式，默认左对齐：</p><p>:— 代表左对齐<br>:–: 代表居中对齐<br>—: 代表右对齐</p><table><thead><tr><th style="text-align:left">left（:— ）</th><th style="text-align:center">center（:—-: ）</th><th style="text-align:right">right（ —-:）</th></tr></thead><tbody><tr><td style="text-align:left">left</td><td style="text-align:center">center</td><td style="text-align:right">right</td></tr></tbody></table><h3 id="加粗-斜体-删除线"><a href="#加粗-斜体-删除线" class="headerlink" title="加粗 斜体 删除线"></a>加粗 斜体 删除线</h3><p>加粗语法： **要加粗的字**</p><p>加粗效果： <strong>要加粗的字</strong></p><p>斜体语法：*斜体的字*</p><p>斜体效果： <em>斜体的字</em></p><p>删除线语法： ~~要删除的字~~</p><p>删除线效果： <del>要删除的字</del></p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>如果需要引用文献资料或者别的引用，可以用大于号解决：</p><p>语法：&gt;要引用的文字</p><p>效果：</p><blockquote><p>要引用的文字</p></blockquote><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><p>语法：在指定序号后面加上点（.） 并空格 </p><pre><code>1. aaa2. bbb3. ccc</code></pre><p>效果：</p><ol><li>aaa</li><li>bbb</li><li>ccc</li></ol><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><p>语法：在文字前面加上* 或者 + 或者 - 并空格</p><pre><code>* aaa* bbb* ccc</code></pre><p>效果：</p><ul><li>aaa</li><li>bbb</li><li>ccc</li></ul><p><strong>注意：</strong> 如果生成多级列表，可以这样：</p><pre><code>- 1.a    - 1.1.aa        - 1.1.1.aaa- 2.b- 3.c</code></pre><p>效果图：</p><ul><li>1.a<ul><li>1.1.aa<ul><li>1.1.1.aaa</li></ul></li></ul></li><li>2.b</li><li>3.c</li></ul><h3 id="代码支持"><a href="#代码支持" class="headerlink" title="代码支持"></a>代码支持</h3><p>语法：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//代码片段</span><br></pre></td></tr></table></figure></code></pre><p>效果：一段java代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"Hello World"</span>);</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>由于Markdown支持Html语法，故Markdown以上无法实现的可以借助Html实现，如居中实现：</p><pre><code>&lt;center&gt;这段话要居中&lt;/center&gt;</code></pre><p>效果：<center>这段话要居中</center></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近自己搭建了一个博客网站，写文章时用到了markdown语法，之前虽未接触过markdown语法，但在两三天的使用过程中感觉markdow
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="MarkDown" scheme="https://www.sakuratears.top/tags/MarkDown/"/>
    
  </entry>
  
  <entry>
    <title>Html5+JQuery页面标签的禁用问题</title>
    <link href="https://www.sakuratears.top/blog/Html5-JQuery%E9%A1%B5%E9%9D%A2%E6%A0%87%E7%AD%BE%E7%9A%84%E7%A6%81%E7%94%A8%E9%97%AE%E9%A2%9820180604/"/>
    <id>https://www.sakuratears.top/blog/Html5-JQuery页面标签的禁用问题20180604/</id>
    <published>2018-06-04T15:17:00.000Z</published>
    <updated>2018-06-12T14:48:55.221Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在做移动应用项目时遇到的问题，完成某些操作后返回到前面页面要保证前面页面的标签内容不可被编辑，修改。有如下方法：</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ol><li><p>对于input，select框，设置disabled=’disabled’。</p><p> 如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#testid1 input'</span>).attr(<span class="string">'disabled'</span>,<span class="string">'disabled'</span>);</span><br><span class="line">$(<span class="string">'#testid2 select'</span>).attr(<span class="string">'disabled'</span>,<span class="string">'disabled'</span>);</span><br></pre></td></tr></table></figure></li><li><p>对于一些点击触发事件的button，可以用unbind()移除事件方法。</p><p> 如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">".testclass3"</span>).unbind();</span><br></pre></td></tr></table></figure><p> 注：在某些情况下unbind慎用，如页面初始化时调用click事件加载其他事件属性，unbind()可能会导致初始化时无法加载。</p></li><li><p>插件禁用，有些页面可能使用某些插件，对于插件的禁用，可以设置插件的事件方法return false;</p><p> 如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#test #test4"</span>).on(<span class="string">"touchmove"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p> 这个是我们项目一个滑动插件触摸禁用的例子。</p></li><li><p>对于一些比较特殊的，如li标签，可以使用class样式进行处理。</p><p> 这是一个两个li标签切换禁用的例子。</p><p> 例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#test_li"</span>).addClass(<span class="string">'disabledTab'</span>);</span><br><span class="line">.disabledTab&#123;</span><br><span class="line">   pointer-events: none;<span class="comment">//这样鼠标或触摸就无法选中li标签</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在做移动应用项目时遇到的问题，完成某些操作后返回到前面页面要保证前面页面的标签内容不可被编辑，修改。有如下方法：&lt;/p&gt;
&lt;h2 id=&quot;方
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="JavaScript" scheme="https://www.sakuratears.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>阿里云主机环境搭建</title>
    <link href="https://www.sakuratears.top/blog/%E9%98%BF%E9%87%8C%E4%BA%91%E4%B8%BB%E6%9C%BA%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA20180604/"/>
    <id>https://www.sakuratears.top/blog/阿里云主机环境搭建20180604/</id>
    <published>2018-06-04T15:00:00.000Z</published>
    <updated>2018-06-12T14:49:09.339Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>现在很多服务都部署在云服务上，最近项目也要发布到云上，特写此文章。有需要部署云服务的小伙伴可以参考下。</p><h2 id="云主机参数"><a href="#云主机参数" class="headerlink" title="云主机参数"></a>云主机参数</h2><p>在部署云服务时，一般需要知道如下参数：</p><ol><li>云ECS主机服务器远程连接：<br> url       XXXXXXXX<br> 用户名：XXXXXXX<br> 密码：XXXXXXX<br> 超级管理员：用户名：XXXX    密码  ：XXXX    </li><li>硬件配置：<br> 实例规格：2 核 4GB<br> 网络：带宽 5Mbps<br> 操作系统：Ubuntu 16.04 64位<br> 系统盘：高效云盘（100 GB）</li></ol><h2 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h2><h3 id="远程连接工具"><a href="#远程连接工具" class="headerlink" title="远程连接工具"></a>远程连接工具</h3><ol><li>XShell连接工具  </li><li>Xftp文件上传管理工具  </li><li>两工具下载地址：<a href="https://www.netsarang.com/products/xsh_overview.html" target="_blank" rel="noopener">https://www.netsarang.com/products/xsh_overview.html</a></li><li>其他说明：由于当前Ubuntu 16.04 64位 Linux系统弃用了一些旧的远程ssh加密方式，故原先的ssh2工具不能连接，当然也可以修改linux配置文件使其支持旧的ssh加密方式，详见<a href="http://blog.csdn.net/liucky/article/details/51889112" target="_blank" rel="noopener">http://blog.csdn.net/liucky/article/details/51889112</a> 等文章。本服务器未修改也不建议修改linux配置，进而选择使用XSHell等工具连接。</li></ol><h3 id="服务器搭建工具"><a href="#服务器搭建工具" class="headerlink" title="服务器搭建工具"></a>服务器搭建工具</h3><ol><li>Linux 64位  jdk压缩包      jdk-7u79-linux-x64.tar.gz</li><li>Tomcat压缩包 For Linux 64     apache-tomcat-7.0.79.tar.gz</li><li>Linux 64位 Mysql 安装包    （在线安装可不使用）  mysql-5.7.19-linux-glibc2.12-x86_64.tar.gz</li><li>编译好的项目    demo</li><li>数据库表  demo</li></ol><h2 id="连接云主机"><a href="#连接云主机" class="headerlink" title="连接云主机"></a>连接云主机</h2><ol><li><p>连接到Linux服务器</p><p> 打开XShell，输入前面的云主机配置，连接到Linux远程服务器。如图：</p></li></ol><p><img src="/images/pasted-8.png" alt="upload successful"></p><ol start="2"><li><p>登录成功后如图</p><p> 使用 pwd 命令可查看当前路径</p><p> 目前/home   文件夹下已使xxxxxx用户拥有读、写、执行的权限</p></li></ol><p><img src="/images/pasted-9.png" alt="upload successful"></p><h2 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h2><ol><li><p>进入/home文件夹</p><p> 我们在其目录下建三个文件夹jdk,mysql,tomcat用于存放文件</p></li><li><p>创建文件夹，可以使用 mkdir  文件夹名   这种方式，也可以直接打开xftp 创建，如图：</p></li></ol><p><img src="/images/pasted-10.png" alt="upload successful"></p><ol start="3"><li><p>上传并解压</p><p> 通过Xftp将 jdk，tomcat，mysql，项目包demo，数据表全部传上去</p><p> 对于tar.gz文件进行解压</p><p> tar -xzvf jdk-7u79-linux-x64.tar.gz</p><p> 注意：项目demo要放到tomcat  webapps目录下，故建议将tomcat</p><p> 解压后再上传demo项目</p></li></ol><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><ol><li>找到jdk路径</li><li><p>同时找到 /etc/profile<br> 使用vi /etc/profile<br> 编辑该文件，设置环境变量<br> export JAVA_HOME=”/home/jdk/jdk1.7.0_79”<br> export PATH=”$PATH:$JAVA_HOME/bin”<br> export JRE_HOME=”$JAVA_HOME/jre”<br> export CLASSPATH=”.:$JAVA_HOME/lib:$JRE_HOME/lib”</p><p> 或者通过Xftp把profile文件down下来，修改好后再上传回去</p></li><li><p>弄好后要使用source /etc/profile 命令进行更新使其变量生效</p></li><li><p>同时 使用命令<br> java -version<br> java<br> javac</p><p> 正常则表示配置成功了</p></li></ol><p><img src="/images/pasted-11.png" alt="upload successful"></p><h2 id="启动Tomcat"><a href="#启动Tomcat" class="headerlink" title="启动Tomcat"></a>启动Tomcat</h2><ol><li>由于tomcat自带的startup.sh脚本看不到日志输出，因此写了个脚本startTomcat.sh脚本</li><li>进入到tomcat  bin目录下，使用命令  sh startTomcat.sh 启动tomcat，看到starup毫秒数表示启动成功。</li><li>启动后，在本地机器上访问 <a href="http://xxxxxxxxxxx:8080/" target="_blank" rel="noopener">http://xxxxxxxxxxx:8080/</a>  可以看到久违的tomcat页面</li><li><p>bin里的shutdown.sh用于停止tomcat服务，sh shutdown.sh</p></li><li><p>成功后上传项目 demo到 tomcat webapps文件夹</p></li></ol><p><img src="/images/pasted-12.png" alt="upload successful"></p><h2 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h2><p>接下来开始安装Mysql</p><ol><li>对于阿里云，我们可以采取在线安装的方式快速安装MySQL<br> 使用Linux  root用户登录，<br> 使用命令：<br> sudo apt-get install mysql-server<br> apt-get isntall mysql-client<br> sudo apt-get install libmysqlclient-dev</li><li>安装过程中会提示输入root用户密码，设置所需的root用户密码即可。</li><li><p>使用以下命令查看MySQL是否安装成功<br> sudo netstat -tap | grep mysql<br> 可以看到MySQL处于listen状态，配置成功。</p><p> 关于离线安装，暂时没弄成功，有时间在补上。</p></li></ol><h2 id="导入数据表"><a href="#导入数据表" class="headerlink" title="导入数据表"></a>导入数据表</h2><p>将数据表数据导入到MySQL数据库。<br>mysql命令<br>service mysql start 启动<br>service mysql stop  停止</p><p>service mysql restart  重启</p><ol><li><p>使用root用户登录MySQ</p><p> mysql -u root -p<br> 输入密码登录成功。</p></li><li><p>设置必要数据</p><p> 进入mysql命令行<br> 查看数据库编码还有表名大小写情况（Linux系统下MySQL表名会区分大小写）</p><p> 查看字符编码<br> mysql&gt; show variables like ‘character%’;<br> 查看表名大小写<br> mysql&gt; show Variables like ‘%table_names’;<br> 如果不是utf-8编码（右图所示为utf-8编码格式），表名默认区分大小写<br> lower_case_table_names=0<br> 则需要修改默认配置<br> cd etc/mysql/mysql.conf.d/<br> vi    mysqld.cnf<br> 加入如下配置：<br> character-set-server=utf8<br> collation-server=utf8_general_ci<br> skip-character-set-client-handshake<br> lower_case_table_names=1</p><p> 重启mysql服务</p></li><li><p>开启访问权限</p><p> 我们可以在开启外网MySQL访问权限在Windows机器上用GUI工具导入MySQL表数据<br> 开启外网权限：<br> mysql&gt; SELECT User, Host FROM mysql.user;<br> mysql&gt; update user set host = ‘%’ where user =’root’;<br> mysql&gt; flush privileges;<br> 同时将etc/mysql/mysql.conf.d/mysqld.cnf  配置文件里的<br> bind-address    = 127.0.0.1注释掉。</p></li><li><p>这样在MySQL可视化工具如Navicat上远程连接MySQL，设置utf-8编码格式后将数据表导入即可。</p></li></ol><h2 id="注意事项及其他"><a href="#注意事项及其他" class="headerlink" title="注意事项及其他"></a>注意事项及其他</h2><ol><li><p>启动tomcat及MySQL后，通过外网便可以正常访问项目。输入用户名密码后登陆。</p></li><li><p>注意事项。<br> 使用root用户时，应尽量减少敏感操作，如 rm ， mv  ，cp  -r  等命令的执行。<br> tomcat请使用tomcat用户启动，不建议使用root用户启动。<br> MySQL开启外网访问后，如果无法访问，可能是阿里云禁用了3306端口的外网访问，需要登录阿里云开启，当成功导入数据后，十分建议关闭MySQL远程访问权限。<br> 如果要设置tomcat默认端口为80，也需要登录阿里云设置。<br> 如果操作过程中出现异常破坏了Linux系统，可以登录阿里云进行系统还原。<br> 部署项目时，项目的一些配置文件如数据库连接，请求地址一定要配置正确。<br> 如果要设置tomcat默认端口为80，则需要用root启动，因为linux只有root才能启动1024以内的端口，同时需要修改tomcat  server.xml配置文件及demo访问地址。</p></li></ol><h2 id="文档PPT"><a href="#文档PPT" class="headerlink" title="文档PPT"></a>文档PPT</h2><p>简单阿里云主机搭建文档资源：<a href="https://download.csdn.net/download/javazwt/10448764" target="_blank" rel="noopener">https://download.csdn.net/download/javazwt/10448764</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;现在很多服务都部署在云服务上，最近项目也要发布到云上，特写此文章。有需要部署云服务的小伙伴可以参考下。&lt;/p&gt;
&lt;h2 id=&quot;云主机参数&quot;
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="云部署" scheme="https://www.sakuratears.top/tags/%E4%BA%91%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>短视频Test</title>
    <link href="https://www.sakuratears.top/blog/%E7%9F%AD%E8%A7%86%E9%A2%91Test20180603/"/>
    <id>https://www.sakuratears.top/blog/短视频Test20180603/</id>
    <published>2018-06-03T12:58:00.000Z</published>
    <updated>2018-06-12T14:51:53.234Z</updated>
    
    <content type="html"><![CDATA[<div><br>  <center><strong>短视频</strong></center><br>  <br><br>  <video controls="controls" autoplay="autoplay" style="width:100%;      height:auto;"><br>  <source src="/video/video0.mp4" type="video/mp4"><br>    (天涯明月刀)刀妹的视频<br>  </video><br></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div&gt;&lt;br&gt;  &lt;center&gt;&lt;strong&gt;短视频&lt;/strong&gt;&lt;/center&gt;&lt;br&gt;  &lt;br&gt;&lt;br&gt;  &lt;video controls=&quot;controls&quot; autoplay=&quot;autoplay&quot; style=&quot;width:100%;
      heig
      
    
    </summary>
    
      <category term="娱乐" scheme="https://www.sakuratears.top/categories/%E5%A8%B1%E4%B9%90/"/>
    
    
  </entry>
  
  <entry>
    <title>Java排序算法</title>
    <link href="https://www.sakuratears.top/blog/Java%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%9520180602/"/>
    <id>https://www.sakuratears.top/blog/Java排序算法20180602/</id>
    <published>2018-06-02T15:25:00.000Z</published>
    <updated>2018-06-12T14:49:22.525Z</updated>
    
    <content type="html"><![CDATA[<h2 id="排序算法分类"><a href="#排序算法分类" class="headerlink" title="排序算法分类"></a>排序算法分类</h2><p>十种常见排序算法可以分为两大类：</p><p><strong>非线性时间比较类排序：</strong>通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此称为非线性时间比较类排序。</p><p><strong>线性时间非比较类排序：</strong>不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。 </p><p>如下图：</p><p><img src="/images/pasted-5.png" alt="upload successful"></p><h2 id="排序算法复杂度及稳定性"><a href="#排序算法复杂度及稳定性" class="headerlink" title="排序算法复杂度及稳定性"></a>排序算法复杂度及稳定性</h2><p>如下图：</p><p><img src="/images/pasted-6.png" alt="upload successful"></p><p>相关概念：</p><p><strong>稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</strong></p><p><strong>不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</strong></p><p><strong>时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</strong></p><p><strong>空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。 </strong></p><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h3><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 </p><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><ol><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ol><h4 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="/images/pasted-7.gif" alt="upload successful"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p><strong>JavaScript代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> len = arr.length;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;        <span class="comment">// 相邻元素两两对比  </span></span><br><span class="line">                <span class="keyword">var</span> temp = arr[j+<span class="number">1</span>];        <span class="comment">// 元素交换  </span></span><br><span class="line">                arr[j+<span class="number">1</span>] = arr[j];  </span><br><span class="line">                arr[j] = temp;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> arr;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bubbleSort(<span class="keyword">int</span>[] a)&#123;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length-<span class="number">1</span>;i++)&#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;a.length;j++)&#123;  </span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;a[j])&#123;  </span><br><span class="line">                <span class="keyword">int</span> temp=a[i];  </span><br><span class="line">                a[i]=a[j];  </span><br><span class="line">                a[j]=temp;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> a;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简单选择排序（Selection-Sort）"><a href="#简单选择排序（Selection-Sort）" class="headerlink" title="简单选择排序（Selection Sort）"></a>简单选择排序（Selection Sort）</h3><p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p><h4 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h4><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p><ol><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n)。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n]分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>n-1趟结束，数组有序化了。</li></ol><h4 id="动图演示-1"><a href="#动图演示-1" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="/images/pasted-8.gif" alt="upload successful"></p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><p><strong>JavaScript代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">arr</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> len = arr.length;  </span><br><span class="line">    <span class="keyword">var</span> minIndex, temp;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;  </span><br><span class="line">        minIndex = i;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;     <span class="comment">// 寻找最小的数  </span></span><br><span class="line">                minIndex = j;                 <span class="comment">// 将最小数的索引保存  </span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        temp = arr[i];  </span><br><span class="line">        arr[i] = arr[minIndex];  </span><br><span class="line">        arr[minIndex] = temp;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> arr;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] simpleSelectSort(<span class="keyword">int</span>[] a)&#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length-<span class="number">1</span>;i++)&#123;  </span><br><span class="line">            <span class="keyword">int</span> min=i;  </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;a.length;j++)&#123;  </span><br><span class="line">                <span class="keyword">if</span>(a[min]&gt;a[j])&#123;  </span><br><span class="line">                    min=j;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span>(min!=i)&#123;  </span><br><span class="line">                <span class="keyword">int</span> temp=a[i];  </span><br><span class="line">                a[i]=a[min];  </span><br><span class="line">                a[min]=temp;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> a;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h4><p>表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。</p><h3 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h3><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><h4 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h4><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><ol><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ol><h4 id="动图演示-2"><a href="#动图演示-2" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="/images/pasted-9.gif" alt="upload successful"></p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><p><strong>JavaScript代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span>(<span class="params">arr</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> len = arr.length;  </span><br><span class="line">    <span class="keyword">var</span> preIndex, current;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;  </span><br><span class="line">        preIndex = i - <span class="number">1</span>;  </span><br><span class="line">        current = arr[i];  </span><br><span class="line">        <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; arr[preIndex] &gt; current) &#123;  </span><br><span class="line">            arr[preIndex + <span class="number">1</span>] = arr[preIndex];  </span><br><span class="line">            preIndex--;  </span><br><span class="line">        &#125;  </span><br><span class="line">        arr[preIndex + <span class="number">1</span>] = current;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> arr;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] straightInsertionSort(<span class="keyword">int</span>[] a)&#123;  </span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;a.length;i++)&#123;  </span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;<span class="number">0</span>;j--)&#123;  </span><br><span class="line">             <span class="keyword">if</span>(a[j]&lt;a[j-<span class="number">1</span>])&#123;  </span><br><span class="line">                 <span class="keyword">int</span> temp=a[j-<span class="number">1</span>];  </span><br><span class="line">                 a[j-<span class="number">1</span>]=a[j];  </span><br><span class="line">                 a[j]=temp;  </span><br><span class="line">             &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">                 <span class="keyword">break</span>;  </span><br><span class="line">             &#125;  </span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">return</span> a;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h4><p>插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><h3 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h3><p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</p><h4 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h4><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ol><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ol><h4 id="动图演示-3"><a href="#动图演示-3" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="/images/pasted-10.gif" alt="upload successful"></p><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><p><strong>JavaScript代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span>(<span class="params">arr</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> len = arr.length,  </span><br><span class="line">        temp,  </span><br><span class="line">        gap = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">while</span> (gap &lt; len / <span class="number">3</span>) &#123;          <span class="comment">// 动态定义间隔序列  </span></span><br><span class="line">        gap = gap * <span class="number">3</span> + <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span> (gap; gap &gt; <span class="number">0</span>; gap = <span class="built_in">Math</span>.floor(gap / <span class="number">3</span>)) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = gap; i &lt; len; i++) &#123;  </span><br><span class="line">            temp = arr[i];  </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = i-gap; j &gt; <span class="number">0</span> &amp;&amp; arr[j]&gt; temp; j-=gap) &#123;  </span><br><span class="line">                arr[j + gap] = arr[j];  </span><br><span class="line">            &#125;  </span><br><span class="line">            arr[j + gap] = temp;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> arr;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] shellsSort(<span class="keyword">int</span> a[]) &#123;  </span><br><span class="line">     <span class="keyword">int</span> d = a.length;  </span><br><span class="line">     <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  </span><br><span class="line">         d = d / <span class="number">2</span>;  </span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; d; x++) &#123;  </span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> i = x + d; i &lt; a.length; i = i + d) &#123;  </span><br><span class="line">                 <span class="keyword">int</span> temp = a[i];  </span><br><span class="line">                 <span class="keyword">int</span> j;  </span><br><span class="line">                 <span class="keyword">for</span> (j = i - d; j &gt;= <span class="number">0</span> &amp;&amp; a[j] &gt; temp; j = j - d) &#123;  </span><br><span class="line">                     a[j + d] = a[j];  </span><br><span class="line">                 &#125;  </span><br><span class="line">                 a[j + d] = temp;  </span><br><span class="line">             &#125;  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="keyword">if</span> (d == <span class="number">1</span>) &#123;  </span><br><span class="line">             <span class="keyword">break</span>;  </span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">return</span> a;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h4><p>希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版）》的合著者Robert Sedgewick提出的。</p><h3 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h3><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p><h4 id="算法描述-4"><a href="#算法描述-4" class="headerlink" title="算法描述"></a>算法描述</h4><ol><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ol><h4 id="动图演示-4"><a href="#动图演示-4" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="/images/pasted-11.gif" alt="upload successful"></p><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><p><strong>JavaScript代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>) </span>&#123;  <span class="comment">// 采用自上而下的递归方法  </span></span><br><span class="line">    <span class="keyword">var</span> len = arr.length;  </span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> arr;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">var</span> middle = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>),  </span><br><span class="line">        left = arr.slice(<span class="number">0</span>, middle),  </span><br><span class="line">        right = arr.slice(middle);  </span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left, right</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> result = [];  </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">while</span> (left.length&gt;<span class="number">0</span> &amp;&amp; right.length&gt;<span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]) &#123;  </span><br><span class="line">            result.push(left.shift());  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            result.push(right.shift());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">while</span> (left.length)  </span><br><span class="line">        result.push(left.shift());  </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">while</span> (right.length)  </span><br><span class="line">        result.push(right.shift());  </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mergeSort(<span class="keyword">int</span> a[])&#123;  </span><br><span class="line">    sort(a,<span class="number">0</span>,<span class="number">1</span>);  </span><br><span class="line">    <span class="keyword">return</span> a;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> s, <span class="keyword">int</span> len)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> size = a.length;  </span><br><span class="line">    <span class="keyword">int</span> mid = size / (len &lt;&lt; <span class="number">1</span>);  </span><br><span class="line">    <span class="keyword">int</span> c = size &amp; ((len &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>);  </span><br><span class="line">    <span class="comment">//　-------归并到只剩一个有序集合的时候结束算法-------//  </span></span><br><span class="line">    <span class="keyword">if</span> (mid == <span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    <span class="comment">//　------进行一趟归并排序-------//  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mid; ++i) &#123;  </span><br><span class="line">        s = i * <span class="number">2</span> * len;  </span><br><span class="line">        merge(a, s, s + len, (len &lt;&lt; <span class="number">1</span>) + s - <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//　-------将剩下的数和倒数一个有序集合归并-------//  </span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>)  </span><br><span class="line">        merge(a, size - c - <span class="number">2</span> * len, size - c, size - <span class="number">1</span>);  </span><br><span class="line">    <span class="comment">//　-------递归执行下一趟归并排序------//  </span></span><br><span class="line">    sort(a, <span class="number">0</span>, <span class="number">2</span> * len);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> s, <span class="keyword">int</span> m, <span class="keyword">int</span> t)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[t - s + <span class="number">1</span>];  </span><br><span class="line">    <span class="keyword">int</span> i = s, j = m, k = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (i &lt; m &amp;&amp; j &lt;= t) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt;= a[j]) &#123;  </span><br><span class="line">            tmp[k] = a[i];  </span><br><span class="line">            k++;  </span><br><span class="line">            i++;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            tmp[k] = a[j];  </span><br><span class="line">            j++;  </span><br><span class="line">            k++;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">while</span> (i &lt; m) &#123;  </span><br><span class="line">        tmp[k] = a[i];  </span><br><span class="line">        i++;  </span><br><span class="line">        k++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">while</span> (j &lt;= t) &#123;  </span><br><span class="line">        tmp[k] = a[j];  </span><br><span class="line">        j++;  </span><br><span class="line">        k++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    System.arraycopy(tmp, <span class="number">0</span>, a, s, tmp.length);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h4><p>归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。</p><h3 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h3><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><h4 id="算法描述-5"><a href="#算法描述-5" class="headerlink" title="算法描述"></a>算法描述</h4><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ol><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ol><h4 id="动图演示-5"><a href="#动图演示-5" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="/images/pasted-12.gif" alt="upload successful"></p><h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><p><strong>JavaScript代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr, left, right</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> len = arr.length,  </span><br><span class="line">        partitionIndex,  </span><br><span class="line">        left = <span class="keyword">typeof</span> left != <span class="string">'number'</span> ? <span class="number">0</span> : left,  </span><br><span class="line">        right = <span class="keyword">typeof</span> right != <span class="string">'number'</span> ? len - <span class="number">1</span> : right;  </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;  </span><br><span class="line">        partitionIndex = partition(arr, left, right);  </span><br><span class="line">        quickSort(arr, left, partitionIndex<span class="number">-1</span>);  </span><br><span class="line">        quickSort(arr, partitionIndex+<span class="number">1</span>, right);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> arr;  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">arr, left ,right</span>) </span>&#123;     <span class="comment">// 分区操作  </span></span><br><span class="line">    <span class="keyword">var</span> pivot = left,                      <span class="comment">// 设定基准值（pivot）  </span></span><br><span class="line">        index = pivot + <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = index; i &lt;= right; i++) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[pivot]) &#123;  </span><br><span class="line">            swap(arr, i, index);  </span><br><span class="line">            index++;  </span><br><span class="line">        &#125;         </span><br><span class="line">    &#125;  </span><br><span class="line">    swap(arr, pivot, index - <span class="number">1</span>);  </span><br><span class="line">    <span class="keyword">return</span> index<span class="number">-1</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr, i, j</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> temp = arr[i];  </span><br><span class="line">    arr[i] = arr[j];  </span><br><span class="line">    arr[j] = temp;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] quickSort(<span class="keyword">int</span> a[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)&#123;  </span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;  </span><br><span class="line">        <span class="keyword">int</span> privotLoc=partition(a,low,high);<span class="comment">//将表一分为二  </span></span><br><span class="line">        quickSort(a,low,privotLoc-<span class="number">1</span>);  </span><br><span class="line">        quickSort(a,privotLoc+<span class="number">1</span>,high);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> a;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> privotKey=a[low];<span class="comment">//基准元素  </span></span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)&#123;     <span class="comment">//从表的两端交替向中间扫描  </span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;a[high]&gt;=privotKey)&#123;   <span class="comment">//从high 所指位置向前搜索，至多到low+1 位置。将比基准元素小的交换到低端  </span></span><br><span class="line">            --high;                             <span class="comment">//从右找比基准元素少的  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        a[low]=a[high];                         <span class="comment">//如果比基准元素小，交换位置  </span></span><br><span class="line">        a[high]=privotKey;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;a[low]&lt;=privotKey)&#123;  </span><br><span class="line">            ++low;                              <span class="comment">//从右找比基准元素大的  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        a[high]=a[low];                          <span class="comment">//如果比基准元素大，交换位置  </span></span><br><span class="line">        a[low]=privotKey;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> low;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h3><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><h4 id="算法描述-6"><a href="#算法描述-6" class="headerlink" title="算法描述"></a>算法描述</h4><ol><li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li><li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li></ol><h4 id="动图演示-6"><a href="#动图演示-6" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="/images/pasted-13.gif" alt="upload successful"></p><h4 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h4><p><strong>JavaScript代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> len;    <span class="comment">// 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量  </span></span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildMaxHeap</span>(<span class="params">arr</span>) </span>&#123;   <span class="comment">// 建立大顶堆  </span></span><br><span class="line">    len = arr.length;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="built_in">Math</span>.floor(len/<span class="number">2</span>); i &gt;= <span class="number">0</span>; i--) &#123;  </span><br><span class="line">        heapify(arr, i);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapify</span>(<span class="params">arr, i</span>) </span>&#123;     <span class="comment">// 堆调整  </span></span><br><span class="line">    <span class="keyword">var</span> left = <span class="number">2</span> * i + <span class="number">1</span>,  </span><br><span class="line">        right = <span class="number">2</span> * i + <span class="number">2</span>,  </span><br><span class="line">        largest = i;  </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;  </span><br><span class="line">        largest = left;  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;  </span><br><span class="line">        largest = right;  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;  </span><br><span class="line">        swap(arr, i, largest);  </span><br><span class="line">        heapify(arr, largest);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr, i, j</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> temp = arr[i];  </span><br><span class="line">    arr[i] = arr[j];  </span><br><span class="line">    arr[j] = temp;  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapSort</span>(<span class="params">arr</span>) </span>&#123;  </span><br><span class="line">    buildMaxHeap(arr);  </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;  </span><br><span class="line">        swap(arr, <span class="number">0</span>, i);  </span><br><span class="line">        len--;  </span><br><span class="line">        heapify(arr, <span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> arr;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] heapSort(<span class="keyword">int</span> a[])&#123;  </span><br><span class="line">     buildMaxHeapTree(a);  </span><br><span class="line">     sort(a);  </span><br><span class="line">     <span class="keyword">return</span> a;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildMaxHeapTree</span><span class="params">(<span class="keyword">int</span> a[])</span></span>&#123;  </span><br><span class="line">     <span class="comment">//没有子节点的才需要创建最大堆，从最后一个的父节点开始  </span></span><br><span class="line">     <span class="keyword">int</span> startIndex=getParentIndex(a.length-<span class="number">1</span>);  </span><br><span class="line">     <span class="comment">//从尾端开始创建最大堆，每次都是正确的堆  </span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=startIndex;i&gt;=<span class="number">0</span>;i--)&#123;  </span><br><span class="line">         maxHeap(a,a.length,i);  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maxHeap</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> heapSize, <span class="keyword">int</span> index)</span> </span>&#123;  </span><br><span class="line">     <span class="comment">//当前点与左右子节点比较  </span></span><br><span class="line">     <span class="keyword">int</span> left = getChildLeftIndex(index);  </span><br><span class="line">     <span class="keyword">int</span> right = getChildRightIndex(index);  </span><br><span class="line">  </span><br><span class="line">     <span class="keyword">int</span> largest = index;  </span><br><span class="line">     <span class="keyword">if</span> (left &lt; heapSize &amp;&amp; data[index] &lt; data[left]) &#123;  </span><br><span class="line">         largest = left;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">if</span> (right &lt; heapSize &amp;&amp; data[largest] &lt; data[right]) &#123;  </span><br><span class="line">         largest = right;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="comment">//得到最大值后可能需要交换，如果交换了，其子节点可能就不是最大堆了，需要重新调整  </span></span><br><span class="line">     <span class="keyword">if</span> (largest != index) &#123;  </span><br><span class="line">         <span class="keyword">int</span> temp = data[index];  </span><br><span class="line">         data[index] = data[largest];  </span><br><span class="line">         data[largest] = temp;  </span><br><span class="line">         maxHeap(data, heapSize, largest);  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getParentIndex</span><span class="params">(<span class="keyword">int</span> current)</span></span>&#123;  </span><br><span class="line">     <span class="keyword">return</span> (current-<span class="number">1</span>)&gt;&gt;<span class="number">2</span>;  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildLeftIndex</span><span class="params">(<span class="keyword">int</span> current)</span></span>&#123;  </span><br><span class="line">     <span class="keyword">return</span>(current&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildRightIndex</span><span class="params">(<span class="keyword">int</span> current)</span></span>&#123;  </span><br><span class="line">     <span class="keyword">return</span>(current&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] data)</span></span>&#123;  </span><br><span class="line">     <span class="comment">//末尾与头交换，交换后调整最大堆  </span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=data.length-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--)&#123;  </span><br><span class="line">         <span class="keyword">int</span> temp=data[<span class="number">0</span>];  </span><br><span class="line">         data[<span class="number">0</span>]=data[i];  </span><br><span class="line">         data[i]=temp;  </span><br><span class="line">         maxHeap(data,i,<span class="number">0</span>);  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="计数排序（Counting-Sort）"><a href="#计数排序（Counting-Sort）" class="headerlink" title="计数排序（Counting Sort）"></a>计数排序（Counting Sort）</h3><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><h4 id="算法描述-7"><a href="#算法描述-7" class="headerlink" title="算法描述"></a>算法描述</h4><ol><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li></ol><h4 id="动图演示-7"><a href="#动图演示-7" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="/images/pasted-14.gif" alt="upload successful"></p><h4 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h4><p><strong>JavaScript代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countingSort</span>(<span class="params">arr, maxValue</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> bucket = <span class="keyword">new</span> <span class="built_in">Array</span>(maxValue + <span class="number">1</span>),  </span><br><span class="line">        sortedIndex = <span class="number">0</span>;  </span><br><span class="line">        arrLen = arr.length,  </span><br><span class="line">        bucketLen = maxValue + <span class="number">1</span>;  </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arrLen; i++) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (!bucket[arr[i]]) &#123;  </span><br><span class="line">            bucket[arr[i]] = <span class="number">0</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        bucket[arr[i]]++;  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; bucketLen; j++) &#123;  </span><br><span class="line">        <span class="keyword">while</span>(bucket[j] &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">            arr[sortedIndex++] = j;  </span><br><span class="line">            bucket[j]--;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> arr;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] countSort(<span class="keyword">int</span>[]a)&#123;  </span><br><span class="line">    <span class="keyword">int</span> b[] = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];  </span><br><span class="line">    <span class="keyword">int</span> max = a[<span class="number">0</span>],min = a[<span class="number">0</span>];  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i:a)&#123;  </span><br><span class="line">        <span class="keyword">if</span>(i&gt;max)&#123;  </span><br><span class="line">            max=i;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(i&lt;min)&#123;  </span><br><span class="line">            min=i;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;<span class="comment">//这里k的大小是要排序的数组中，元素大小的极值差+1  </span></span><br><span class="line">    <span class="keyword">int</span> k=max-min+<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">int</span> c[]=<span class="keyword">new</span> <span class="keyword">int</span>[k];  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;++i)&#123;  </span><br><span class="line">        c[a[i]-min]+=<span class="number">1</span>;<span class="comment">//优化过的地方，减小了数组c的大小  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;c.length;++i)&#123;  </span><br><span class="line">        c[i]=c[i]+c[i-<span class="number">1</span>];  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=a.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;--i)&#123;  </span><br><span class="line">        b[--c[a[i]-min]]=a[i];<span class="comment">//按存取的方式取出c的元素  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> b;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h4><p>计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。</p><h3 id="桶排序（Bucket-Sort）"><a href="#桶排序（Bucket-Sort）" class="headerlink" title="桶排序（Bucket Sort）"></a>桶排序（Bucket Sort）</h3><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p><h4 id="算法描述-8"><a href="#算法描述-8" class="headerlink" title="算法描述"></a>算法描述</h4><ol><li>设置一个定量的数组当作空桶；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>对每个不是空的桶进行排序；</li><li>从不是空的桶里把排好序的数据拼接起来。 </li></ol><h4 id="图片演示"><a href="#图片演示" class="headerlink" title="图片演示"></a>图片演示</h4><p><img src="/images/pasted-15.png" alt="upload successful"></p><h4 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h4><p><strong>JavaScript代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bucketSort</span>(<span class="params">arr, bucketSize</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (arr.length === <span class="number">0</span>) &#123;  </span><br><span class="line">      <span class="keyword">return</span> arr;  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">var</span> i;  </span><br><span class="line">    <span class="keyword">var</span> minValue = arr[<span class="number">0</span>];  </span><br><span class="line">    <span class="keyword">var</span> maxValue = arr[<span class="number">0</span>];  </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;  </span><br><span class="line">      <span class="keyword">if</span> (arr[i] &lt; minValue) &#123;  </span><br><span class="line">          minValue = arr[i];                <span class="comment">// 输入数据的最小值  </span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; maxValue) &#123;  </span><br><span class="line">          maxValue = arr[i];                <span class="comment">// 输入数据的最大值  </span></span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 桶的初始化  </span></span><br><span class="line">    <span class="keyword">var</span> DEFAULT_BUCKET_SIZE = <span class="number">5</span>;            <span class="comment">// 设置桶的默认数量为5  </span></span><br><span class="line">    bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;  </span><br><span class="line">    <span class="keyword">var</span> bucketCount = <span class="built_in">Math</span>.floor((maxValue - minValue) / bucketSize) + <span class="number">1</span>;    </span><br><span class="line">    <span class="keyword">var</span> buckets = <span class="keyword">new</span> <span class="built_in">Array</span>(bucketCount);  </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; buckets.length; i++) &#123;  </span><br><span class="line">        buckets[i] = [];  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 利用映射函数将数据分配到各个桶中  </span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;  </span><br><span class="line">        buckets[<span class="built_in">Math</span>.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    arr.length = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; buckets.length; i++) &#123;  </span><br><span class="line">        insertionSort(buckets[i]);                      <span class="comment">// 对每个桶进行排序，这里使用了插入排序  </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; buckets[i].length; j++) &#123;  </span><br><span class="line">            arr.push(buckets[i][j]);                       </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> arr;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">basket</span><span class="params">(<span class="keyword">int</span> data[])</span><span class="comment">//data为待排序数组  </span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> n = data.length;  </span><br><span class="line">    <span class="keyword">int</span> bask[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][n];  </span><br><span class="line">    <span class="keyword">int</span> index[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];  </span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;  </span><br><span class="line">        max = max &gt; (Integer.toString(data[i]).length()) ? max : (Integer.toString(data[i]).length());  </span><br><span class="line">    &#125;  </span><br><span class="line">    String str;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = max - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;  </span><br><span class="line">            str = <span class="string">""</span>;  </span><br><span class="line">            <span class="keyword">if</span> (Integer.toString(data[j]).length() &lt; max) &#123;  </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; max - Integer.toString(data[j]).length(); k++)  </span><br><span class="line">                    str += <span class="string">"0"</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            str += Integer.toString(data[j]);  </span><br><span class="line">            bask[str.charAt(i) - <span class="string">'0'</span>][index[str.charAt(i) - <span class="string">'0'</span>]++] = data[j];  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; index[j]; k++) &#123;  </span><br><span class="line">                data[pos++] = bask[j][k];  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">10</span>; x++) index[x] = <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析-5"><a href="#算法分析-5" class="headerlink" title="算法分析"></a>算法分析</h4><p>桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 </p><h3 id="基数排序（Radix-Sort）"><a href="#基数排序（Radix-Sort）" class="headerlink" title="基数排序（Radix Sort）"></a>基数排序（Radix Sort）</h3><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p><h4 id="算法描述-9"><a href="#算法描述-9" class="headerlink" title="算法描述"></a>算法描述</h4><ol><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li></ol><h4 id="动图演示-8"><a href="#动图演示-8" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="/images/pasted-16.gif" alt="upload successful"></p><h4 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h4><p><strong>JavaScript代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = [];  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">radixSort</span>(<span class="params">arr, maxDigit</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> mod = <span class="number">10</span>;  </span><br><span class="line">    <span class="keyword">var</span> dev = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; maxDigit; i++, dev *= <span class="number">10</span>, mod *= <span class="number">10</span>) &#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;  </span><br><span class="line">            <span class="keyword">var</span> bucket = <span class="built_in">parseInt</span>((arr[j] % mod) / dev);  </span><br><span class="line">            <span class="keyword">if</span>(counter[bucket]==<span class="literal">null</span>) &#123;  </span><br><span class="line">                counter[bucket] = [];  </span><br><span class="line">            &#125;  </span><br><span class="line">            counter[bucket].push(arr[j]);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">var</span> pos = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; counter.length; j++) &#123;  </span><br><span class="line">            <span class="keyword">var</span> value = <span class="literal">null</span>;  </span><br><span class="line">            <span class="keyword">if</span>(counter[j]!=<span class="literal">null</span>) &#123;  </span><br><span class="line">                <span class="keyword">while</span> ((value = counter[j].shift()) != <span class="literal">null</span>) &#123;  </span><br><span class="line">                      arr[pos++] = value;  </span><br><span class="line">                &#125;  </span><br><span class="line">          &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> arr;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] number, <span class="keyword">int</span> d)</span> <span class="comment">//d表示最大的数有多少位  </span></span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">1</span>; <span class="comment">//控制键值排序依据在哪一位  </span></span><br><span class="line">        <span class="keyword">int</span>[][] temp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][number.length]; <span class="comment">//数组的第一维表示可能的余数0-9  </span></span><br><span class="line">        <span class="keyword">int</span>[] order = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">//数组orderp[i]用来表示该位是i的数的个数  </span></span><br><span class="line">        <span class="keyword">while</span> (m &lt;= d) &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number.length; i++) &#123;  </span><br><span class="line">                <span class="keyword">int</span> lsd = ((number[i] / n) % <span class="number">10</span>);  </span><br><span class="line">                temp[lsd][order[lsd]] = number[i];  </span><br><span class="line">                order[lsd]++;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (order[i] != <span class="number">0</span>)  </span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; order[i]; j++) &#123;  </span><br><span class="line">                        number[k] = temp[i][j];  </span><br><span class="line">                        k++;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                order[i] = <span class="number">0</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            n *= <span class="number">10</span>;  </span><br><span class="line">            k = <span class="number">0</span>;  </span><br><span class="line">            m++;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析-6"><a href="#算法分析-6" class="headerlink" title="算法分析"></a>算法分析</h4><p>基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。</p><p>基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n&gt;&gt;k，因此额外空间需要大概n个左右。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>新建Test类，测试十种排序算法时间消耗。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line"><span class="comment">//        int arrayLength=10;  </span></span><br><span class="line"><span class="comment">//        int range=100;  </span></span><br><span class="line">        <span class="keyword">int</span> arrayLength=<span class="number">100000</span>;  </span><br><span class="line">        <span class="keyword">int</span> range=<span class="number">100000</span>;  </span><br><span class="line">        <span class="comment">//生成一个指定长度数据的int数组  </span></span><br><span class="line">        <span class="keyword">int</span>[] a=<span class="keyword">new</span> <span class="keyword">int</span>[arrayLength];  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arrayLength;i++)&#123;  </span><br><span class="line">            a[i]=(<span class="keyword">int</span>)(Math.random()*range);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//创建十个数组用于测试，否则会冲突  </span></span><br><span class="line">        <span class="keyword">int</span>[] a1= a.clone();  </span><br><span class="line">        <span class="keyword">int</span>[] a2= a.clone();  </span><br><span class="line">        <span class="keyword">int</span>[] a3= a.clone();  </span><br><span class="line">        <span class="keyword">int</span>[] a4= a.clone();  </span><br><span class="line">        <span class="keyword">int</span>[] a5= a.clone();  </span><br><span class="line">        <span class="keyword">int</span>[] a6= a.clone();  </span><br><span class="line">        <span class="keyword">int</span>[] a7= a.clone();  </span><br><span class="line">        <span class="keyword">int</span>[] a8= a.clone();  </span><br><span class="line">        <span class="keyword">int</span>[] a9= a.clone();  </span><br><span class="line">        <span class="keyword">int</span>[] a10= a.clone();  </span><br><span class="line">        System.out.println(a1.toString());  </span><br><span class="line">        System.out.println(a2.toString());  </span><br><span class="line">        System.out.println(a3.toString());  </span><br><span class="line">        System.out.println(a4.toString());  </span><br><span class="line">        System.out.println(a5.toString());  </span><br><span class="line">        System.out.println(a6.toString());  </span><br><span class="line">        System.out.println(a7.toString());  </span><br><span class="line">        System.out.println(a8.toString());  </span><br><span class="line">        System.out.println(a9.toString());  </span><br><span class="line">        System.out.println(a10.toString());  </span><br><span class="line">  </span><br><span class="line">        System.gc();  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//直接插入排序法  </span></span><br><span class="line">        <span class="keyword">long</span> starta1=System.currentTimeMillis();  </span><br><span class="line">        a1= StraightInsertionSort.straightInsertionSort(a1);  </span><br><span class="line">        <span class="keyword">long</span> enda1=System.currentTimeMillis();  </span><br><span class="line">        System.out.println(<span class="string">"插入排序法耗时："</span>+(enda1-starta1)+<span class="string">"ms"</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//冒泡排序法  </span></span><br><span class="line">        <span class="keyword">long</span> starta2=System.currentTimeMillis();  </span><br><span class="line">        a2= BubbleSort.bubbleSort(a2);  </span><br><span class="line">        <span class="keyword">long</span> enda2=System.currentTimeMillis();  </span><br><span class="line">        System.out.println(<span class="string">"冒泡排序法耗时："</span>+(enda2-starta2)+<span class="string">"ms"</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//直接(简单)选择排序法  </span></span><br><span class="line">        <span class="keyword">long</span> starta3=System.currentTimeMillis();  </span><br><span class="line">        a3= SimpleSelectionSort.simpleSelectSort(a3);  </span><br><span class="line">        <span class="keyword">long</span> enda3=System.currentTimeMillis();  </span><br><span class="line">        System.out.println(<span class="string">"直接选择排序法耗时："</span>+(enda3-starta3)+<span class="string">"ms"</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//堆排序  </span></span><br><span class="line">        <span class="keyword">long</span> starta4=System.currentTimeMillis();  </span><br><span class="line">        a4= HeapSort.heapSort(a4);  </span><br><span class="line">        <span class="keyword">long</span> enda4=System.currentTimeMillis();  </span><br><span class="line">        System.out.println(<span class="string">"堆排序法耗时："</span>+(enda4-starta4)+<span class="string">"ms"</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//归并排序  </span></span><br><span class="line">        <span class="keyword">long</span> starta5=System.currentTimeMillis();  </span><br><span class="line">        a5= MergeSort.mergeSort(a5);  </span><br><span class="line">        <span class="keyword">long</span> enda5=System.currentTimeMillis();  </span><br><span class="line">        System.out.println(<span class="string">"归并排序法耗时："</span>+(enda5-starta5)+<span class="string">"ms"</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//快速排序算法  </span></span><br><span class="line">        <span class="keyword">long</span> starta6=System.currentTimeMillis();  </span><br><span class="line">        a6= QuickSort.quickSort(a6,<span class="number">0</span>,a6.length-<span class="number">1</span>);  </span><br><span class="line">        <span class="keyword">long</span> enda6=System.currentTimeMillis();  </span><br><span class="line">        System.out.println(<span class="string">"快速排序耗时："</span>+(enda6-starta6)+<span class="string">"ms"</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//计数排序算法  </span></span><br><span class="line">        <span class="keyword">long</span> starta7=System.currentTimeMillis();  </span><br><span class="line">        a7= CountingSort.countSort(a7);  </span><br><span class="line">        <span class="keyword">long</span> enda7=System.currentTimeMillis();  </span><br><span class="line">        System.out.println(<span class="string">"计数排序耗时："</span>+(enda7-starta7)+<span class="string">"ms"</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//希尔排序算法  </span></span><br><span class="line">        <span class="keyword">long</span> starta8=System.currentTimeMillis();  </span><br><span class="line">        a8= ShellsSort.shellsSort(a8);  </span><br><span class="line">        <span class="keyword">long</span> enda8=System.currentTimeMillis();  </span><br><span class="line">        System.out.println(<span class="string">"希尔排序耗时："</span>+(enda8-starta8)+<span class="string">"ms"</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//桶排序算法  </span></span><br><span class="line">        <span class="keyword">long</span> starta9=System.currentTimeMillis();  </span><br><span class="line">        a9= BucketSort.basket(a9);  </span><br><span class="line">        <span class="keyword">long</span> enda9=System.currentTimeMillis();  </span><br><span class="line">        System.out.println(<span class="string">"桶排序耗时："</span>+(enda9-starta9)+<span class="string">"ms"</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//基数排序算法  </span></span><br><span class="line">        <span class="keyword">long</span> starta10=System.currentTimeMillis();  </span><br><span class="line">        a10= RadixSort.sort(a10,<span class="number">6</span>);  </span><br><span class="line">        <span class="keyword">long</span> enda10=System.currentTimeMillis();  </span><br><span class="line">        System.out.println(<span class="string">"基数排序耗时："</span>+(enda10-starta10)+<span class="string">"ms"</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//        ArrayHelper.printLine(a1);  </span></span><br><span class="line"><span class="comment">//        System.out.println();  </span></span><br><span class="line"><span class="comment">//        ArrayHelper.printLine(a2);  </span></span><br><span class="line"><span class="comment">//        System.out.println();  </span></span><br><span class="line"><span class="comment">//        ArrayHelper.printLine(a3);  </span></span><br><span class="line"><span class="comment">//        System.out.println();  </span></span><br><span class="line"><span class="comment">//        ArrayHelper.printLine(a4);  </span></span><br><span class="line"><span class="comment">//        System.out.println();  </span></span><br><span class="line"><span class="comment">//        ArrayHelper.printLine(a5);  </span></span><br><span class="line"><span class="comment">//        System.out.println();  </span></span><br><span class="line"><span class="comment">//        ArrayHelper.printLine(a6);  </span></span><br><span class="line"><span class="comment">//        System.out.println();  </span></span><br><span class="line"><span class="comment">//        ArrayHelper.printLine(a7);  </span></span><br><span class="line"><span class="comment">//        System.out.println();  </span></span><br><span class="line"><span class="comment">//        ArrayHelper.printLine(a8);  </span></span><br><span class="line"><span class="comment">//        System.out.println();  </span></span><br><span class="line"><span class="comment">//        ArrayHelper.printLine(a9);  </span></span><br><span class="line"><span class="comment">//        System.out.println();  </span></span><br><span class="line"><span class="comment">//        ArrayHelper.printLine(a10);  </span></span><br><span class="line">  </span><br><span class="line">        System.gc();  </span><br><span class="line">  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/images/pasted-17.png" alt="upload successful"></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li><p>本文为转载，十种算法的Java实现方式及测试为原创。</p></li><li><p>本文转载自：<a href="https://www.cnblogs.com/onepixel/articles/7674659.html" target="_blank" rel="noopener">https://www.cnblogs.com/onepixel/articles/7674659.html</a></p></li><li><p>文中涉及到的Java代码地址：<a href="https://github.com/JavaZWT/sort" target="_blank" rel="noopener">https://github.com/JavaZWT/sort</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;排序算法分类&quot;&gt;&lt;a href=&quot;#排序算法分类&quot; class=&quot;headerlink&quot; title=&quot;排序算法分类&quot;&gt;&lt;/a&gt;排序算法分类&lt;/h2&gt;&lt;p&gt;十种常见排序算法可以分为两大类：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非线性时间比较类排序：&lt;/strong&gt;通过
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="JavaScript" scheme="https://www.sakuratears.top/tags/JavaScript/"/>
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式之代理模式</title>
    <link href="https://www.sakuratears.top/blog/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F20180602/"/>
    <id>https://www.sakuratears.top/blog/Java设计模式之代理模式20180602/</id>
    <published>2018-06-02T11:20:00.000Z</published>
    <updated>2018-06-12T14:49:38.423Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>代理模式：即通过代理对象访问目标对象，实现目标对象的方法。这样做的好处是：可以在目标对象实现的基础上，增强额外的功能操作，实现对目标功能的扩展。</p><p>这涉及到一个编程思想：不要随意去修改别人已经写好的代码或者方法（有坑）。如果需要修改，可以通过代理模式实现。</p><h2 id="写法实现"><a href="#写法实现" class="headerlink" title="写法实现"></a>写法实现</h2><p>代理模式通常有三种实现写法：<strong>静态代理、动态代理、Cglib代理</strong>。</p><p>我们依次说下这三种代理模式：</p><p>我们现有 AnimalsDao接口和其实现AnimalsDaoImpl实现类，有两个方法，run和eat。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AnimalsDao</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//提供两个方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalsDaoImpl</span> <span class="keyword">implements</span> <span class="title">AnimalsDao</span></span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"run"</span>);  </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"eat"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们想在run或者eat方法里之前做一些操作。</p><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxy</span> <span class="keyword">implements</span> <span class="title">AnimalsDao</span></span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"StaticProxy---------&gt;"</span>);  </span><br><span class="line">        dao.run();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"StaticProxy---------&gt;"</span>);  </span><br><span class="line">        dao.eat();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> AnimalsDao dao;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaticProxy</span><span class="params">(AnimalsDao dao)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.dao=dao;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>静态代理通过实现目标对象接口，然后调用相同方法来实现代理。这种方式的缺点显而易见，当目标对象接口方法变动时，直接影响到代理类，需要对代理类进行修改，十分不方便。而且如果目标对象接口方法较多时，代理类也十分臃肿，不便维护。</p><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//要代理的对象  </span></span><br><span class="line">    <span class="keyword">private</span> Object obj;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxy</span><span class="params">(Object obj)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.obj=obj;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObjProxyIntance</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(obj.getClass().getClassLoader(),  </span><br><span class="line">                obj.getClass().getInterfaces(),  </span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;  </span><br><span class="line">                <span class="comment">//执行目标对象方法  </span></span><br><span class="line">                System.out.println(<span class="string">"DynamicProxy---------&gt;"</span>);  </span><br><span class="line">                <span class="keyword">return</span> method.invoke(obj,args);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>动态代理模式主要借助JDK代理对象API  java.lang.reflect.Proxy来实现的，所以也称作JDK代理。我们看一下JDK这个类，其中重要的一个方法如下：</p><p><img src="/images/pasted-3.png" alt="upload successful"></p><p>这个方法的三个参数：</p><p>ClassLoader loader  目标对象类加载器</p><p>Class&lt;?&gt;[] interfaces  目标对象接口类型</p><p>InvocationHandler h  事物处理，在这里面可以实现自己想要的逻辑</p><p>根据以上，可以看出动态代理实现要求目标对象必须有实现接口。代理类不必实现接口。</p><h3 id="Cglib代理"><a href="#Cglib代理" class="headerlink" title="Cglib代理"></a>Cglib代理</h3><p>要实现Cglib代理，必须引入cglib.jar 包，由于Spring-core包中已经包含了cglib功能，且大部分Java项目均引入了spring 相关jar包，这边使用spring的cglib来讲解。（他俩实现方式都是一样的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//目标对象  </span></span><br><span class="line">    <span class="keyword">private</span> Object obj;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CglibProxy</span><span class="params">(Object obj)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.obj=obj;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//给目标对象创建一个代理对象  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="comment">//1.工具类  </span></span><br><span class="line">        Enhancer en = <span class="keyword">new</span> Enhancer();  </span><br><span class="line">        <span class="comment">//2.设置父类  </span></span><br><span class="line">        en.setSuperclass(obj.getClass());  </span><br><span class="line">        <span class="comment">//3.设置回调函数  </span></span><br><span class="line">        en.setCallback(<span class="keyword">this</span>);  </span><br><span class="line">        <span class="comment">//4.创建子类(代理对象)  </span></span><br><span class="line">        <span class="keyword">return</span> en.create();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"CglibProxy---------&gt;"</span>);  </span><br><span class="line">        <span class="keyword">return</span> method.invoke(obj,objects);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>可以看出，Cglib代理模式实现不需要目标对象一定实现接口，故目标对象如果没有实现接口，可以使用cglib代理模式。其实Spring的代理模式也是这么实现的。</p><h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><p>Spring的代理模式：如果容器目标对象有接口，使用JDK动态代理，如果没有接口，使用cglib动态代理。</p><p><img src="/images/pasted-4.png" alt="upload successful"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><p><a href="https://www.cnblogs.com/cenyu/p/6289209.html" target="_blank" rel="noopener">https://www.cnblogs.com/cenyu/p/6289209.html</a></p></li><li><p>Spring 4.0 源代码</p></li></ol><h2 id="GitHub代码地址"><a href="#GitHub代码地址" class="headerlink" title="GitHub代码地址"></a>GitHub代码地址</h2><p><a href="https://github.com/JavaZWT/designPatterns" target="_blank" rel="noopener">https://github.com/JavaZWT/designPatterns</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;代理模式：即通过代理对象访问目标对象，实现目标对象的方法。这样做的好处是：可以在目标对象实现的基础上，增强额外的功能操作，实现对目标功能的扩
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式之工厂模式</title>
    <link href="https://www.sakuratears.top/blog/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F20180602/"/>
    <id>https://www.sakuratears.top/blog/Java设计模式之工厂模式20180602/</id>
    <published>2018-06-02T09:45:00.000Z</published>
    <updated>2018-06-12T14:49:54.330Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>工厂模式，顾名思义，即用来实例化一个个对象的模式。把相同类别的对象用工厂模式代替new生成，提高代码质量和系统扩展性。</p><h2 id="写法分类"><a href="#写法分类" class="headerlink" title="写法分类"></a>写法分类</h2><p>   工厂模式的写法通常分为四类，简单工厂、多方法工厂、普通工厂、抽象工厂。<br>   在分别说明他们之前，我们先创建几个对象。<br>   抽象的Animals类，Plants类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animals</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//动物的描述  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">desc</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>及Animals的三个基本实现，Tiger类、Bird类、Fish类，Plants的实现Tree类。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tiger</span> <span class="keyword">extends</span>  <span class="title">Animals</span></span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">desc</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"这是一只老虎"</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"这是一只老虎"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">extends</span>  <span class="title">Animals</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">desc</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"这是一只鸟"</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"这是一只鸟"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fish</span> <span class="keyword">extends</span> <span class="title">Animals</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">desc</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"这是一条鱼"</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"这是一条鱼"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Plants</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//植物的描述  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">desc</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tree</span> <span class="keyword">extends</span> <span class="title">Plants</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">desc</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"这是一棵树"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   下面来说说这四种工厂模式。</p><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalsFactory</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String Tiger=<span class="string">"Tiger"</span>;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String Bird=<span class="string">"Bird"</span>;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String Fish=<span class="string">"Fish"</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Animals <span class="title">getAnimal</span><span class="params">(String name)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">switch</span> (name)&#123;  </span><br><span class="line">            <span class="keyword">case</span> Tiger:  </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Tiger();  </span><br><span class="line">            <span class="keyword">case</span> Bird:  </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Bird();  </span><br><span class="line">            <span class="keyword">case</span> Fish:  </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Fish();  </span><br><span class="line">            <span class="keyword">default</span>:  </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调用：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animals a=AnimalsFactory.getAnimal(<span class="string">"Tiger"</span>);  </span><br><span class="line">a.desc();</span><br></pre></td></tr></table></figure></p><p><strong>说明：</strong>简单工厂模式易于理解，但扩展性差，如我想在增加一种动物，则还需要修改逻辑内容。而且如果设置额外入参，对参数的管理也较为不便。</p><h3 id="多方法工厂模式"><a href="#多方法工厂模式" class="headerlink" title="多方法工厂模式"></a>多方法工厂模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalsFactory</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Animals <span class="title">getTiger</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tiger();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Animals <span class="title">getBird</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Bird();  </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Animals <span class="title">getFish</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Fish();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调用：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animals b= AnimalsFactory.getFish();  </span><br><span class="line">b.desc();</span><br></pre></td></tr></table></figure></p><p>说明：这种模式使用方便，容错率高，且可适应不同需求，如我现在想创建一个羽毛为蓝色的小鸟，明显多方法工厂模式比简单工厂模式实现简单。</p><h3 id="普通工厂模式"><a href="#普通工厂模式" class="headerlink" title="普通工厂模式"></a>普通工厂模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PlantsFactory</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Plants <span class="title">getPlant</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeFactory</span> <span class="keyword">extends</span> <span class="title">PlantsFactory</span></span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Plants <span class="title">getPlant</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tree();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调用：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PlantsFactory p=<span class="keyword">new</span> TreeFactory();  </span><br><span class="line">p.getPlant().desc();</span><br></pre></td></tr></table></figure></p><p><strong>说明：</strong>这种工厂模式划分成两层：抽象工厂层+具体的工厂子类层。 当我们不需要Tree，或者需要其他时，都可以新增或删除一个类实现，这种工厂模式看着很简洁明了易于理解。</p><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="keyword">static</span>&#123;  </span><br><span class="line">        <span class="comment">// do something  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="comment">//do something  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> T <span class="title">getT</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BirdFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span>&lt;<span class="title">Animals</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Animals <span class="title">getT</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Bird();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span>&lt;<span class="title">Plants</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Plants <span class="title">getT</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tree();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调用：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AbstractFactory factory= <span class="keyword">new</span> TreeFactory();  </span><br><span class="line">Tree t=(Tree)factory.getT();  </span><br><span class="line">t.desc();</span><br></pre></td></tr></table></figure></p><p><strong>说明：</strong>可以看出，这种方法把工厂本身也抽象了，如果对于两个或多个简单工厂模式，相似点较多，比如PlantsFactory和AnimalsFactory，作为生物，它们也有相似之处，dosomething部分的代码。其实抽象工厂模式跟普通工厂模式的区别就在于把工厂也抽象了一层。</p><h2 id="工厂模式实例"><a href="#工厂模式实例" class="headerlink" title="工厂模式实例"></a>工厂模式实例</h2><ol><li>Spring Bean对象的创建   抽象工厂模式的使用</li></ol><p><img src="/images/pasted-1.png" alt="upload successful"></p><ol start="2"><li>线程池 Executors  多方法工厂模式的使用</li></ol><p><img src="/images/pasted-2.png" alt="upload successful"></p><p>其他：Spring框架中大量使用了工厂模式，单例模式等设计模式，有时间阅读些源代码，对技术能力的提升有很大帮助。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><p><a href="https://blog.csdn.net/zxt0601/article/details/52798423" target="_blank">https://blog.csdn.net/zxt0601/article/details/52798423</a></p></li><li><p>Spring 4.0 源码</p></li><li><p>JDK8源码</p></li></ol><h2 id="GitHub代码地址"><a href="#GitHub代码地址" class="headerlink" title="GitHub代码地址"></a>GitHub代码地址</h2><p><a href="https://github.com/JavaZWT/designPatterns" target="_blank">https://github.com/JavaZWT/designPatterns</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;工厂模式，顾名思义，即用来实例化一个个对象的模式。把相同类别的对象用工厂模式代替new生成，提高代码质量和系统扩展性。&lt;/p&gt;
&lt;h2 id
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式之单例模式</title>
    <link href="https://www.sakuratears.top/blog/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F20180602/"/>
    <id>https://www.sakuratears.top/blog/Java设计模式之单例模式20180602/</id>
    <published>2018-06-02T04:00:00.000Z</published>
    <updated>2018-06-12T14:50:07.926Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>单例模式，顾名思义，即只产生唯一实例的设计模式。一个类只有一个实例,即一个类只有一个对象实例。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p><strong>1. 减少系统开销及资源消耗。</strong></p><p><strong>2. 设置全局访问点，优化共享资源的使用。</strong></p><p>注：对于以上优点，我们可以拿Java配置读取举例，对于固定的配置文件，我们完全可以设计一个单例类，读取配置文件，而避免每次都读取文件造成的系统开销，同时也优化了配置文件的使用。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol><li>Servlet</li><li>开源框架Spring中的默认bean配置模式</li><li>数据库连接池</li><li>项目中对于配置文件的处理<br>等等</li></ol><h2 id="写法分类"><a href="#写法分类" class="headerlink" title="写法分类"></a>写法分类</h2><h3 id="懒汉式单例模式（非线程安全）"><a href="#懒汉式单例模式（非线程安全）" class="headerlink" title="懒汉式单例模式（非线程安全）"></a>懒汉式单例模式（非线程安全）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_Singleton_01</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Demo_Singleton_01 instance=<span class="keyword">null</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Demo_Singleton_01</span><span class="params">()</span></span>&#123;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Demo_Singleton_01 <span class="title">getInstance</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;  </span><br><span class="line">            instance=<span class="keyword">new</span> Demo_Singleton_01();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>这种写法不常用，虽然实现了懒加载（lazy-loading），但未考虑线程安全问题，不适用于多线程情况。</p><h3 id="懒汉式单例模式（线程安全）"><a href="#懒汉式单例模式（线程安全）" class="headerlink" title="懒汉式单例模式（线程安全）"></a>懒汉式单例模式（线程安全）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_Singleton_02</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Demo_Singleton_02 instance=<span class="keyword">null</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Demo_Singleton_02 <span class="title">getInstance</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;  </span><br><span class="line">            instance=<span class="keyword">new</span> Demo_Singleton_02();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Demo_Singleton_02</span><span class="params">()</span></span>&#123;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>相对于demo1，这种写法实现了懒加载（lazy-loading），也考虑到线程安全问题，可适用于多线程情况。</p><h3 id="饿汉式单例模式"><a href="#饿汉式单例模式" class="headerlink" title="饿汉式单例模式"></a>饿汉式单例模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_Singleton_03</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Demo_Singleton_03 instance=<span class="keyword">new</span> Demo_Singleton_03();  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Demo_Singleton_03</span><span class="params">()</span></span>&#123;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Demo_Singleton_03 <span class="title">getInstance</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>饿汉式单例模式的明显缺点是无法实现懒加载，在类被创建后就创建了唯一实例。</p><h3 id="饿汉式单例模式（变种）"><a href="#饿汉式单例模式（变种）" class="headerlink" title="饿汉式单例模式（变种）"></a>饿汉式单例模式（变种）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_Singleton_04</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Demo_Singleton_04 instance=<span class="keyword">null</span>;  </span><br><span class="line">    <span class="keyword">static</span>&#123;  </span><br><span class="line">        instance=<span class="keyword">new</span> Demo_Singleton_04();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Demo_Singleton_04</span><span class="params">()</span></span>&#123;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Demo_Singleton_04 <span class="title">getInstance</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>可以看到这种方法和demo3的性质是一样的，只不过改为了静态块加载唯一实例。</p><h3 id="静态内部类模式"><a href="#静态内部类模式" class="headerlink" title="静态内部类模式"></a>静态内部类模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_Singleton_05</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Demo_Singleton_05 instance=<span class="keyword">new</span> Demo_Singleton_05();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Demo_Singleton_05</span><span class="params">()</span></span>&#123;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Demo_Singleton_05 <span class="title">getInstance</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> Singleton.instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>这种方法既可以实现懒加载，也能保证线程安全。</p><h3 id="双重锁单例模式"><a href="#双重锁单例模式" class="headerlink" title="双重锁单例模式"></a>双重锁单例模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_Singleton_06</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Demo_Singleton_06 instance=<span class="keyword">null</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Demo_Singleton_06</span><span class="params">()</span></span>&#123;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Demo_Singleton_06 <span class="title">getInstance</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;  </span><br><span class="line">            <span class="keyword">synchronized</span>(Demo_Singleton_06.class)&#123;  </span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;  </span><br><span class="line">                    instance=<span class="keyword">new</span> Demo_Singleton_06();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>可以看出，双重锁单例模式只有在第一次创建对象的时候才同步，因为创建对象后就没必要了，（实例唯一）相比懒汉式，效率明显提高，相比饿汉式，不用在类加载的时候就创建实例，而是等到什么时候想调用的时候在创建实例。线程安全，效率高。</p><h3 id="枚举法"><a href="#枚举法" class="headerlink" title="枚举法"></a>枚举法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Demo_Singleton_07 &#123;  </span><br><span class="line">    instance;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>枚举法代码十分直观，线程安全，但是无法实现懒加载。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://blog.csdn.net/goodlixueyong/article/details/51935526" target="_blank">https://blog.csdn.net/goodlixueyong/article/details/51935526</a></li><li><a href="https://www.cnblogs.com/Ycheng/p/7169381.html" target="_blank">https://www.cnblogs.com/Ycheng/p/7169381.html</a></li></ol><h2 id="GitHub代码地址"><a href="#GitHub代码地址" class="headerlink" title="GitHub代码地址"></a>GitHub代码地址</h2><p><a href="https://github.com/JavaZWT/designPatterns" target="_blank">https://github.com/JavaZWT/designPatterns</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;单例模式，顾名思义，即只产生唯一实例的设计模式。一个类只有一个实例,即一个类只有一个对象实例。&lt;/p&gt;
&lt;h2 id=&quot;优点&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://www.sakuratears.top/blog/hello-world20180531/"/>
    <id>https://www.sakuratears.top/blog/hello-world20180531/</id>
    <published>2018-05-31T15:15:00.000Z</published>
    <updated>2018-06-12T14:50:23.299Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
</feed>
