<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SakuraTears的博客</title>
  
  <subtitle>越努力越幸运</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.sakuratears.top/"/>
  <updated>2018-11-17T12:24:37.875Z</updated>
  <id>https://www.sakuratears.top/</id>
  
  <author>
    <name>SakuraTears</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>代码的优雅</title>
    <link href="https://www.sakuratears.top/blog/%E4%BB%A3%E7%A0%81%E7%9A%84%E4%BC%98%E9%9B%8520181117/"/>
    <id>https://www.sakuratears.top/blog/代码的优雅20181117/</id>
    <published>2018-11-17T11:30:00.000Z</published>
    <updated>2018-11-17T12:24:37.875Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>很早之前就想写这么一篇文章，苦于准备不足和时间有限吧，进度一拖再拖。</p><p>来到新公司差不多3个多月了，让我感到或者说受益比较大的可以说就是公司的代码风格吧。</p><p>估计也是由于有架构师的缘故，大家的代码质量感觉都比较高。</p><p>扯远了……</p><p>今天结合实际聊一下关于如何让代码变得规范、优雅吧。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="遵守规范"><a href="#遵守规范" class="headerlink" title="遵守规范"></a>遵守规范</h2><p>这一点或许可以说很笼统，目前大家除了遵守公司制定的一些规范，针对于Java我还比较建议的是阅读下阿里的《阿里巴巴Java开发手册》，H5前端的可以看看Github 上的这个规范<a href="http://alloyteam.github.io/CodeGuide/" target="_blank" rel="noopener">http://alloyteam.github.io/CodeGuide/</a> ，也是蛮不错的。</p><h2 id="必要的封装"><a href="#必要的封装" class="headerlink" title="必要的封装"></a>必要的封装</h2><p>当有一些重复，或者有共性的代码时，我们可以对它们进行包装。小到一些特殊的判断，大到常用的设计模式。</p><p>如下面的代码，实现相同的功能，明显第二种要好些。</p><p><img src="/images/pasted-142.png" alt="upload successful"></p><p><img src="/images/pasted-143.png" alt="upload successful"></p><p>这些必要的封装不仅可以减少一些额外的工作量，还能提高代码可阅读性。</p><p>一些工具包，如apache.commons 已经封装了一些通用校验，我们是可以直接拿来使用的。</p><h2 id="学会占位符的使用"><a href="#学会占位符的使用" class="headerlink" title="学会占位符的使用"></a>学会占位符的使用</h2><p>这一点打印日志比较常见到。如下：</p><p><img src="/images/pasted-144.png" alt="upload successful"></p><p>可以看到两者的输出是一样的，但是第一种是方便我们进行程序源码阅读的。</p><p>除了String.format里的%s占位符，log4j里的{}占位符也可以实现这种作用。</p><h2 id="枚举和常量的使用"><a href="#枚举和常量的使用" class="headerlink" title="枚举和常量的使用"></a>枚举和常量的使用</h2><p>正确使用一些枚举和常量可以提高代码的阅读性。</p><p>比如我们创建一个水果枚举。</p><p><img src="/images/pasted-145.png" alt="upload successful"></p><p><img src="/images/pasted-146.png" alt="upload successful"></p><p>进行某些方法，这些方法更容易被阅读和维护。</p><h2 id="异常的正确使用"><a href="#异常的正确使用" class="headerlink" title="异常的正确使用"></a>异常的正确使用</h2><p>或许你对异常不感冒，觉得有异常还要try catch是一件很费劲的事情，也影响代码美观，怎么会使代码优雅呢？</p><p>我们可以举个例子看一下异常的一种好玩的用法。</p><p>比如有一个业务逻辑，需要通过分布式接口获取其它数据，比如分三步：</p><p><img src="/images/pasted-147.png" alt="upload successful"></p><p><img src="/images/pasted-148.png" alt="upload successful"></p><p><img src="/images/pasted-149.png" alt="upload successful"></p><p>这种情况下每个Res我们需要判断成功，才能获取数据。</p><p><img src="/images/pasted-150.png" alt="upload successful"></p><p>即retCode为0000时。其它为失败。</p><p>这时候我们可以创建异常类。用于对retCode和retInfo进行接收。</p><p><img src="/images/pasted-151.png" alt="upload successful"></p><p>如果上面步骤中获取失败，直接上抛。</p><p><img src="/images/pasted-152.png" alt="upload successful"></p><p>最后可以使用try catch统一处理返回。</p><p><img src="/images/pasted-153.png" alt="upload successful"></p><p>还有一些异常的用法，在这里就不一一说明了。</p><h2 id="必要时尝试使用多线程"><a href="#必要时尝试使用多线程" class="headerlink" title="必要时尝试使用多线程"></a>必要时尝试使用多线程</h2><p>可以在必要时使用多线程来提高程序运行效率。</p><p>对于上面的例子，查询可用余额，查询提现次数，查询银行卡信息相互之间是不影响的（他们的结果只取决于userId或者customerId的值）。我们可以使用Future获取结果，减少程序运行时间。</p><p><img src="/images/pasted-154.png" alt="upload successful"></p><p>使用多线程分别去请求获取结果，最后在进行处理。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>规范的代码不仅自己赏心悦目，别人看后也有所启发，养成编写良好代码的习惯，对自己、对别人都是有所帮助的。</p><p>其实最重要的还是多学、多练、多思考吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;很早之前就想写这么一篇文章，苦于准备不足和时间有限吧，进度一拖再拖。&lt;/p&gt;
&lt;p&gt;来到新公司差不多3个多月了，让我感到或者说受益比较大的可
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>和朋友的一次关于数组问题讨论</title>
    <link href="https://www.sakuratears.top/blog/%E5%92%8C%E6%9C%8B%E5%8F%8B%E7%9A%84%E4%B8%80%E6%AC%A1%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98%E8%AE%A8%E8%AE%BA20181107/"/>
    <id>https://www.sakuratears.top/blog/和朋友的一次数组问题讨论20181107/</id>
    <published>2018-11-07T14:18:00.000Z</published>
    <updated>2018-11-07T14:56:53.109Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前两天下班和一朋友一起，被问到如下问题：<strong>如何移除一个数组中某些符合条件（或不符合条件）的元素形成新的数组，要求数组长度也应该变化</strong>（这是我后面加的）。</p><p>这两天研究下了这个问题，感觉比较有意思，也从中学到了一些其它该注意的东西。</p><p>特此来分享一下。</p><p>如有问题欢迎批评指正。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>对于上面的问题，最简单也最应该想到的一个应该是借助List这个工具类。</p><p>是的，我写下大致如下代码：</p><h2 id="（1）使用List帮助类实现-借助remove方法"><a href="#（1）使用List帮助类实现-借助remove方法" class="headerlink" title="（1）使用List帮助类实现,借助remove方法"></a>（1）使用List帮助类实现,借助remove方法</h2><p>优点：代码简洁，便于理解，不易出错</p><p>缺点：数组和List转换耗时，效率不算太高，使用List remove方法时应注意线程安全问题，如果是基本数据类型，需要转换为包装类，拆箱装箱也是影响效率的一个因素。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 过滤形成新的数组（转换为List，通过List里面remove(安全的)移除元素）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceArray</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> predicate</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] getArray1(T[] sourceArray,Predicate&lt;T&gt; predicate,Class&lt;T&gt; type)&#123;</span><br><span class="line">    <span class="comment">//asList生成的是一个List的内部类，无法调用add remove delete方法会抛出异常</span></span><br><span class="line">    List&lt;T&gt; sourceList= <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(sourceArray));</span><br><span class="line">    <span class="comment">//使用Java8 函数式接口，移除不符合条件的元素</span></span><br><span class="line">    sourceList.removeIf(predicate);</span><br><span class="line">    <span class="keyword">return</span> sourceList.toArray((T[]) Array.newInstance(type,<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注： Predicate<t> predicate 相当于一个判断条件（lambda表达式，Java8语法），具体的问题也可以写明，就是那种for list 在加上 if 条件判断的，这儿我就不啰嗦了。Java 8里面对于集合类，新增了 removeIf方法，我们可以看下它，其实就是我们上面说的那个。</t></p><p><img src="/images/pasted-140.png" alt="upload successful"></p><p>关于这种写法，有需要注意的几点：</p><ol><li><p>for-each，for, iterator 这三种对于List的循环，for，iterator是可以遍历并进行remove操作的，但是for-each是不可以的。有兴趣的可以研究研究，这不是我们的重点。</p></li><li><p>看到我上面使用的泛型T，其实使用Object[]也是可以的，要注意一个问题，泛型T是不能包含int,long等基本数据类型的，使用的话只能转化为它们的包装类。</p></li><li><p>Object[]是没有限制的，但是Object[]转换为Integer[]或者int[]或者其他不能直接转换，如下写法是错误的，会出现问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object [] objects=<span class="keyword">new</span> Object[<span class="number">10</span>];</span><br><span class="line">Integer [] a=(Integer[])objects;</span><br></pre></td></tr></table></figure></li></ol><p>正确的转换方法应该循环里面的元素，并对它们强转添加进数组；或者使用下面的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object [] objects=<span class="keyword">new</span> Object[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//Integer [] a=(Integer[])objects;</span></span><br><span class="line">Integer [] a=(Integer[])Array.newInstance(Integer.class,objects.length);</span><br></pre></td></tr></table></figure></p><ol start="4"><li>当我们把数组转换成List的时候，为了不想循环遍历添加，可能会想到使用Arrays.asList(T t) 这个方法，这个方法生成的List是一个Arrays里面的一个内部类ArrayList。</li></ol><p><img src="/images/pasted-141.png" alt="upload successful"></p><p>看下这个内部类你会发现它没有对remove、add等方法的实现，也就是继承自AbstractList。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是执行它们时会抛出异常，如果想使用remove方法，应该把它转为具体实现，如ArrayList。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;T&gt; sourceList= <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(sourceArray));</span><br></pre></td></tr></table></figure><p>为什么它要使用内部类处理这个方法呢？也是比较有趣的，我这儿还没做深入研究，有时间研究下。</p><h2 id="2-使用两次循环实现。"><a href="#2-使用两次循环实现。" class="headerlink" title="(2)使用两次循环实现。"></a>(2)使用两次循环实现。</h2><p>原理是第一次数组循环查找符合条件（或不符合条件）的个数count，后面在创建一个指定长度（原数组总长度-count）的数组，然后在遍历循环一遍原数组，将符合条件（或不符合条件）的元素添加进新的数组。</p><p>优点：简单直接，易于理解，基本数据类型数组的处理应该比List方法有优势。</p><p>缺点：两次循环应该比较耗时，对于长Array应该显现的明显。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 过滤形成新的数组（两次循环查找符合条件的，移动过去）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceArray</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> predicate</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] getArray2(T[] sourceArray,Predicate&lt;T&gt; predicate,Class&lt;T&gt; type)&#123;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (T t:sourceArray)&#123;</span><br><span class="line">        <span class="keyword">if</span>(predicate.test(t))&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//都不符合条件</span></span><br><span class="line">    <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(sourceArray,sourceArray.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//都符合条件</span></span><br><span class="line">    <span class="keyword">if</span>(count==sourceArray.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> (T[]) Array.newInstance(type,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T [] targetArray=(T[]) Array.newInstance(type,sourceArray.length-count);</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (T t:sourceArray)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!predicate.test(t))&#123;</span><br><span class="line">           targetArray[index]=t;</span><br><span class="line">           index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> targetArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：还有一种情况，如果过滤的数据（符合条件或者不符合条件的）出现次数较低，我们是不是可以考虑一次拿出一整段进行处理。当然，如果频率较高，比如在一堆自然数中取偶数，明显奇数偶数出现频率相近，都为50%，那么我们可能用上面这种方法效率也很好。</p><h2 id="3-预先设置等长数组，而后截取得到目标数组"><a href="#3-预先设置等长数组，而后截取得到目标数组" class="headerlink" title="(3)预先设置等长数组，而后截取得到目标数组"></a>(3)预先设置等长数组，而后截取得到目标数组</h2><p>对比上一种方法，这是一种空间换时间的做法。</p><p>开始时创建一个和原数组相同大小的数组，遍历后把元素放进去，最后将数组截短。<br>这种方法仅仅循环一次。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对比第二种方法，这属于空间换时间的做法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceArray</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> predicate</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] getArray3(T[] sourceArray,Predicate&lt;T&gt; predicate,Class&lt;T&gt; type)&#123;</span><br><span class="line">    <span class="comment">//直接创建一个空的一样长的数组</span></span><br><span class="line">    T[] tempArray=(T[]) Array.newInstance(type,sourceArray.length);</span><br><span class="line">    <span class="comment">//不符合条件的数量</span></span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (T t:sourceArray)&#123;</span><br><span class="line">        <span class="comment">//拿到不符合过滤条件的，一个个赋值给新数组</span></span><br><span class="line">        <span class="keyword">if</span>(!predicate.test(t))&#123;</span><br><span class="line">            tempArray[count]=t;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后这个数组长度&lt;=原数组长度</span></span><br><span class="line">    <span class="comment">//特殊处理下</span></span><br><span class="line">    <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> (T[]) Array.newInstance(type,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(tempArray,count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-借助List的toArray方法"><a href="#4-借助List的toArray方法" class="headerlink" title="(4)借助List的toArray方法"></a>(4)借助List的toArray方法</h2><p>借助List实现循环一次把符合条件的放到里面，再把List强转成数组。也是不错的实现方法。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 借助list拿到符合条件的，在强转成数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceArray</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> predicate</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] getArray4(T[] sourceArray,Predicate&lt;T&gt; predicate,Class&lt;T&gt; type)&#123;</span><br><span class="line">    <span class="comment">//记录符合条件的元素下标</span></span><br><span class="line">    List&lt;T&gt; targetList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (T t:sourceArray)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!predicate.test(t))&#123;</span><br><span class="line">            targetList.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> targetList.toArray((T[]) Array.newInstance(type,<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论上面哪种方法，其底层都使用了System.arraycopy方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 数组复制核心方法</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> src 原数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> srcPos 原数组要复制的起始位置下标</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> dest 目标数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> destPos 目标数组的起始位置下标</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> length 要复制的长度</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos,Object dest, <span class="keyword">int</span> destPos,<span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="5-Java8串行处理方式"><a href="#5-Java8串行处理方式" class="headerlink" title="(5)Java8串行处理方式"></a>(5)Java8串行处理方式</h2><p>Java8中使用Stream操作集合工具类来对其进行处理。分为串行和并行两种方式。先来看看串行。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java8 串行流语法(收集符合条件的)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceArray</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> predicate</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] getArray5(T[] sourceArray,Predicate&lt;T&gt; predicate,Class&lt;T&gt; type)&#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(sourceArray).sequential().</span><br><span class="line">            filter(predicate).</span><br><span class="line">            collect(Collectors.toList()).</span><br><span class="line">            toArray((T[]) Array.newInstance(type,<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其底层也是元素的循环遍历。</p><h2 id="（6）Java8并行处理方式"><a href="#（6）Java8并行处理方式" class="headerlink" title="（6）Java8并行处理方式"></a>（6）Java8并行处理方式</h2><p>我们应该知道，无论方法怎样，至少应该遍历数组一次以判断该元素是否符合条件。当数据量较大时，这儿会成为方法运行时间的瓶颈，由于List家族中ArrayList是有序的，我们可以使用多线程对它进行分割，每段进行遍历筛选结果，最后再把结果合起来。</p><p>并行流就是利用分支/合并框架实现的，使用了多线程。当数组数据量较大时效率是明显的。</p><p>Java8的相关API已经封装好，我们可以直接使用。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java8 并行流语法(收集符合条件的)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceArray</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> predicate</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] getArray6(T[] sourceArray,Predicate&lt;T&gt; predicate,Class&lt;T&gt; type)&#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(sourceArray).parallel().</span><br><span class="line">            filter(predicate).</span><br><span class="line">            collect(Collectors.toList()).</span><br><span class="line">            toArray((T[]) Array.newInstance(type,<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-自己动手，丰衣足食"><a href="#7-自己动手，丰衣足食" class="headerlink" title="(7)自己动手，丰衣足食"></a>(7)自己动手，丰衣足食</h2><p>我们其实是可以借助多线程自己实现一个相似工具类的。</p><p>可以使用分支/合并框架自己实现一个多线程的处理。</p><p>关于这一块，我有一篇文章 <a href="https://www.sakuratears.top/blog/%E4%B8%80%E9%81%93Java%E8%AF%95%E9%A2%98%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%8320181013/">一道Java试题引发的思考</a><br>中有具体例子及测试。</p><p>大家可以看下，数据量大的情况下并行效率还是比较明显的。</p><p>我这儿对这个例子就不在验证了。</p><p><strong>注意</strong>：使用并行流（或者说多线程）要注意的点。</p><p>首先是数据量，数据量的主要意义就在于单线程处理的耗时（处理数据的时间）已经超过了多线程耗时（数据处理时间+拆分数据时间+合并结果时间），这一点是比较难把控的。其次一点是要确定这些数据可以使用多线程处理，不会产生意外的情况，比如我们这个问题，我想删除两个数相差1的所有元素，剩下的元素生成一个新的数组，多线程显然不易解决这种问题，或者解决起来较复杂。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>测试的话今天就省了，（3）、（4）、（5）都是不错的写法，（6）话具体问题具体分析，（7）的话有想法的可以试试，（1），（2）不推荐。</p><p>因为数据量大小，数据类型都对方法有些影响。</p><p>比如较短的原数组，基本数据类型，（3）方法效率很快的，对比（4）、（5）是没有数据拆箱操作的。换成长数组，引用数据类型，（6）可能效率就高了。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>开始写这篇文章的时候脑子不好使，根本没想到Java8的Stream，失误。我甚至一开始想的都是些可能不安全（（1）方法），或者比较繁琐（（2）方法）的方法，过了一天晾了晾脑子就好使多了。</p><p>在处理时，因为数组底层操作都是基于System.arraycopy嘛，我想到是不是循环一次记录符合条件（不符合条件）的元素下标（可用List记录），然后建立一个目标数组，使用System.arraycopy一段一段的将数据copy进去。</p><p>无奈才疏学浅，想了半天使用System.arraycopy时的两个起始位置，copy长度始终弄错了，仔细想了下，估计这种方法效率也不怎么高。</p><p>哈哈，于是就没写。</p><p>大家有什么好的、耳目一新的方法也可以说出来交流交流。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前两天下班和一朋友一起，被问到如下问题：&lt;strong&gt;如何移除一个数组中某些符合条件（或不符合条件）的元素形成新的数组，要求数组长度也应该
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ简介</title>
    <link href="https://www.sakuratears.top/blog/RocketMQ%E7%AE%80%E4%BB%8B20181103/"/>
    <id>https://www.sakuratears.top/blog/RocketMQ简介20181103/</id>
    <published>2018-11-03T14:16:00.000Z</published>
    <updated>2018-11-07T15:05:02.894Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>为什么要学习RocketMQ？</p></blockquote><p>RocketMQ是一个队列模型的的消息中间件，具有高性能、高可靠、高实时、分布式等特点。</p><p>其主要特点如下：</p><ol><li>生产者、消费者、队列都可以分布式。</li><li>能够保证严格的消息顺序。</li><li>提供丰富的消息拉取模式。</li><li>高效的订阅者水平扩展能力。</li><li>实时的消息订阅机制。</li><li>亿级消息堆积能力。</li><li>较少的依赖。</li></ol><p>RocketMQ的基本原理就是生产者（Producer）向一些队列轮流发送消息，队列集合称为Topic，消费者（Consumer）如果做广播消费，则一个消费者实例消费这个Topic对应的所有队列，如果做集群消费，则多个消费者实例平均消费这个topic对应的队列集合。</p><p>消息中间件收发消息的典型模型如下图：</p><p><img src="/images/pasted-137.png" alt="upload successful"></p><p>好吧，我承认前言太官方了。我们来看下正文关于RocketMQ的一些特点吧。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="RocketMQ术语。"><a href="#RocketMQ术语。" class="headerlink" title="RocketMQ术语。"></a>RocketMQ术语。</h2><p>先介绍RocketMQ的几个术语。</p><ol><li><p>Producer</p><p> 消息生产者，生产者的作用就是将消息发送到Broker（MQ），生产者本身既可以产生消息。也可以对外提供接口，由外部应用来调用接口，再由生产者将收到的消息发送到 Broker（MQ）。</p></li><li><p>Producer Group</p><p> 生产者组，一般来说多个发送同一类消息的生产者称之为一个生产者组。</p></li><li><p>Consumer</p><p> 消息消费者，消费 Broker（MQ） 上的消息的应用程序就是消费者，消息的处理取决于业务。</p></li><li><p>Consumer Group</p><p> 消费者组，和生产者类似，消费同一类消息的多个 consumer 实例组成一个消费者组。</p></li><li><p>Topic</p><p> Topic 是一种消息的逻辑分类，比如说你有支付订单类的消息，也有奖品抽取类的消息，那么就需要进行分类，一个是支付订单 Topic 存放支付订单相关的消息，一个是奖品抽取 Topic 存储抽取奖品结果相关的消息。</p></li><li><p>Message</p><p> Message 是消息的载体。一个 Message 必须指定 topic。Message 还有一个可选的 tag 设置，以便消费者可以基于 tag 进行过滤消息。也可以添加额外的键值对等。</p></li><li><p>Tag</p><p> 标签可以被认为是对 Topic 进一步细化。一般在相同业务模块中通过引入标签来标记不同用途的消息。</p></li><li><p>Broker</p><p> Broker 是 RocketMQ系统的主要角色。Broker 接收来自生产者的消息，储存以及为消费者拉取消息的请求做好准备。</p></li><li><p>Name Server</p><p> Name Server 为 producer 和 consumer 提供路由信息。</p></li></ol><p>对于上面的几个概念的理解，可以从一封邮件的发送入手，认为发信人是Producer，收信人为Consumer，Message，Topic和Tag分别指信的内容，信的分类规则等，Broker就相当于邮局了。</p><h2 id="RocketMQ集群架构"><a href="#RocketMQ集群架构" class="headerlink" title="RocketMQ集群架构"></a>RocketMQ集群架构</h2><p>再来看一下RocketMQ常用的物理部署结构。（生产环境常用的RocketMQ集群架构）</p><p><img src="/images/pasted-138.png" alt="upload successful"></p><p><img src="/images/pasted-139.png" alt="upload successful"></p><p>RocketMQ的集群特点如下：</p><ol><li><p>Name Server是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。</p></li><li><p>Broker部署相对复杂，Broker分为Master与Slave，一个Master可以对应多个Slave，但是一个Slave只能对应一个Master，Master与Slave的对应关系通过指定相同的BrokerName，不同的BrokerId来定义，BrokerId为0表示Master，非0表示Slave。Master也可以部署多个。每个Broker与Name Server集群中的所有节点建立长连接，定时注册Topic信息到所有Name Server。</p></li><li><p>Producer与Name Server集群中的其中一个节点（随机选择）建立长连接，定期从Name Server取Topic路由信息，并向提供Topic服务的Master建立长连接，且定时向Master发送心跳。Producer完全无状态，可集群部署。要注意Producer并不能和 Broker Slave建立连接。</p></li><li><p>Consumer与Name Server集群中的其中一个节点（随机选择）建立长连接，定期从Name Server取Topic路由信息，并向提供Topic服务的Master、Slave建立长连接，且定时向Master、Slave发送心跳。Consumer既可以从Master订阅消息，也可以从Slave订阅消息，订阅规则由Broker配置决定。</p></li><li><p>Broker Master和 Broker Slave之间会进行数据同步，即Data Sync。</p></li></ol><p><strong>数据复制主要有两种</strong>：</p><p>①<strong>同步复制 SYNC_MASTER</strong></p><pre><code>master 和 slave 都写成功后返回成功状态。好处是如果master出故障，slave上有全部备份，容易恢复。缺点是增大延迟，降低吞吐量。</code></pre><p>②<strong>异步复制 ASYNC_MASTER</strong></p><pre><code>只要 master 写成功就返回成功状态。好处是低延迟、高吞吐，缺点是如果 master 出故障，数据没有写入 slave，就会有丢失。</code></pre><p>master或者 slave在返回处理成功消息时，需要将数据持久化（写入磁盘）。称之为MQ的刷盘。</p><p><strong>刷盘策略也有两种</strong>：</p><p>①<strong>同步刷盘 SYNC_FLUSH</strong></p><pre><code>返回成功状态时，消息已经被写入磁盘。消息写入内存后，立即通知刷盘线程，刷盘完成后，返回消息写成功的状态。</code></pre><p>②<strong>异步刷盘 ASYNC_FLUSH</strong></p><pre><code>返回成功状态时，消息只是被写入内存，写操作返回快，吞吐量达，当内存里的消息积累到一定程度时，统一出发写磁盘动作，快速写入。</code></pre><h2 id="RocketMQ部署模式"><a href="#RocketMQ部署模式" class="headerlink" title="RocketMQ部署模式"></a>RocketMQ部署模式</h2><p>根据上面的描述，我们也大致可以知道RocketMQ通常有3种部署模式。</p><ol><li><p><strong>单master部署</strong></p><p> 简单来说就是环境上就一台RocketMQ，一般自己开发研究学习会用这种模式。这种部署明显的缺点就是MQ宕机后系统就会挂掉。所以不用于测试或生产环境。</p></li><li><p><strong>多master部署</strong></p><p> 就是环境上有多台RocketMQ，都充当master的角色。这种方式部署，如果有一台MQ挂掉或者重启，并不会对整个应用系统造成影响。但是该节点MQ宕机期间，未消费的MQ消息是无法被消费的，只有等该节点故障排除后才能恢复正常。如果无法恢复，则会造成RocketMQ消息的永久丢失。</p><p> 这种方式，如果是使用的异步刷盘，则故障发生并恢复正常后可能丢失部分消息（写入内存没来得及写入磁盘的消息）；如果同步刷盘，则不会出现此情况，但同步刷盘会对MQ的响应速度造成一些影响。</p></li><li><p><strong>多master 多slave部署</strong></p><p> 根据刷盘策略和数据复制策略。我们知道这种部署方式基本有四种组合策略。同步复制同步刷盘明显是效率最差但最安全的，异步复制异步刷盘明显是效率最好但最不安全的。</p><p> 一般情况下，我们比较常用的是<strong>异步刷盘+同步复制</strong>的模式。这样即使master 宕机，同步复制的slave也能保证把消息写入磁盘。同时使用异步刷盘策略，因为写入磁盘本身是应用系统中耗时的一个操作，先写入内存，随后写入磁盘，可以保证MQ的响应速度。</p></li></ol><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>这一篇文章简单介绍了RocketMQ的一些性质和特点，了解这些特点，才能更好的掌握RocketMQ，后面我们会搭建一个RocketMQ服务进行下学习，并对我们的调用代码做些优化，封装为自己的一个小小工具类。</p><p>回答下最开始的问题，因为我们公司用到了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;为什么要学习RocketMQ？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;RocketMQ是一个队列模型的的消息中
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring Transaction 注解不生效bug引发的思考</title>
    <link href="https://www.sakuratears.top/blog/%E4%B8%80%E4%B8%AASpring-Transaction-%E6%B3%A8%E8%A7%A3%E4%B8%8D%E7%94%9F%E6%95%88bug%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%8320181103/"/>
    <id>https://www.sakuratears.top/blog/一个Spring-Transaction-注解不生效bug引发的思考20181103/</id>
    <published>2018-11-03T02:32:00.000Z</published>
    <updated>2018-11-03T03:37:39.946Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>某日，在项目测试代码过程中，发现一个问题，<strong>对于一个方法A（无事务），调用B方法（有事务），当A，B方法在同一个类中的时候，在B方法上的事务注解是不生效的！</strong></p><p>同事说将B方法写到新的Service类中就可以解决，遂试之，确实得以解决。但不解其原理，问同事、查资料均感觉不如意。故分析了下Spring 事务的部分源码。有所见解，特此记录。</p><p>下图就是我描述的这种情况，B事务不生效的问题。</p><p>1.测试类</p><p><img src="/images/pasted-93.png" alt="upload successful"></p><p>2.实现类</p><p><img src="/images/pasted-94.png" alt="upload successful"></p><p>我们经过测试可以发现，当insert方法有事务、但被该实现类内部方法doInsert调用后，即使insert方法出现异常，该方法的数据库操作也不会回滚。</p><p>3.数据没有回滚，已经入库</p><p><img src="/images/pasted-95.png" alt="upload successful"></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>要理解研究这种情况，我们先来简单说下Spring 的注解方式的事务实现机制。</p><blockquote><p>事务的一些基础我在一篇文章中有介绍 <a href="https://www.sakuratears.top/blog/Spring-Transactional%E6%B3%A8%E8%A7%A320181013/">https://www.sakuratears.top/blog/Spring-Transactional%E6%B3%A8%E8%A7%A320181013/</a>  不懂得可以先大致看看。</p></blockquote><h2 id="Spring注解方式的事务实现机制"><a href="#Spring注解方式的事务实现机制" class="headerlink" title="Spring注解方式的事务实现机制"></a>Spring注解方式的事务实现机制</h2><p>在应用系统调用声明@Transactional 的目标方法时，Spring Framework 默认使用 AOP 代理，在代码运行时生成一个代理对象，根据@Transactional 的属性配置信息，这个代理对象决定该声明@Transactional 的目标方法是否由拦截器 TransactionInterceptor 来使用拦截，在 TransactionInterceptor 拦截时，会在在目标方法开始执行之前创建并加入事务，并执行目标方法的逻辑, 最后根据执行情况是否出现异常，利用抽象事务管理器AbstractPlatformTransactionManager 操作数据源 DataSource 提交或回滚事务, 如图。</p><p><img src="/images/pasted-96.png" alt="upload successful"></p><p>Spring AOP 代理有 CglibAopProxy 和 JdkDynamicAopProxy 两种，上图以 CglibAopProxy 为例，对于 CglibAopProxy，需要调用其内部类的 DynamicAdvisedInterceptor 的 intercept 方法。对于 JdkDynamicAopProxy，需要调用其 invoke 方法。当然我们也可以使用AspectJ的方式实现AOP代理，这儿不做过多介绍。</p><p>事务管理的框架是由抽象事务管理器 AbstractPlatformTransactionManager 来提供的，而具体的底层事务处理实现，由 PlatformTransactionManager 的具体实现类来实现，如事务管理器 DataSourceTransactionManager。不同的事务管理器管理不同的数据资源 DataSource，比如 DataSourceTransactionManager 管理 JDBC 的 Connection。</p><p>PlatformTransactionManager，AbstractPlatformTransactionManager 及具体实现类关系图如下。</p><p><img src="/images/pasted-97.png" alt="upload successful"></p><h2 id="一次正常事务调试"><a href="#一次正常事务调试" class="headerlink" title="一次正常事务调试"></a>一次正常事务调试</h2><p>出现问题，debug是比较好的解决方法。我们大致跟下SpringTransaction的使用过程。先从正确流程入手吧。<br>如下：直接将事务注解加在doInsert方法上，明显，这种情况下出现异常事务会回滚。我们debug下事务大致的回滚过程。</p><p><img src="/images/pasted-98.png" alt="upload successful"></p><p>DefaultAopProxyFactory里的createAopProxy方法可以拿到看到该方法具体使用的哪种代理。</p><p><img src="/images/pasted-99.png" alt="upload successful"></p><p>可以看到我们这个类使用了Cglib代理。<br>使用了Cglib代理，上面讲到 对于 CglibAopProxy，需要调用其内部类的 DynamicAdvisedInterceptor 的 intercept 方法。我们继续断点跟踪下。</p><p><img src="/images/pasted-100.png" alt="upload successful"></p><p>一步步进行，如事务图所示，进入了TransactionInterceptor的invoke方法，并执行invokeWithinTransaction方法。</p><p><img src="/images/pasted-101.png" alt="upload successful"></p><p>继续跟踪。来到了<strong>TransactionAspectSupport</strong>，这是spring事务处理的关键类，谨记。</p><p><img src="/images/pasted-102.png" alt="upload successful"></p><p><img src="/images/pasted-103.png" alt="upload successful"></p><p>会进行事务的创建，createTransactionIfNecessary  getTransaction方法会开启一个事务。</p><p><img src="/images/pasted-104.png" alt="upload successful"></p><p>根据上面debug看到的事务管理器是DataSourceTransactionManager， 执行getTransaction会调用它的doBeigin方法。</p><p><img src="/images/pasted-105.png" alt="upload successful"></p><p><img src="/images/pasted-106.png" alt="upload successful"></p><p>可以看到把自动提交设置成了false，并且暂时保存了原来的自动提交属性状态。</p><p><img src="/images/pasted-107.png" alt="upload successful"></p><p>而后可以看到他将当前事务信息绑定在了ThreadLocal里了。</p><p><img src="/images/pasted-108.png" alt="upload successful"></p><p>执行我们添加事务注解的方法，抛出了异常被捕获。</p><p><img src="/images/pasted-109.png" alt="upload successful"></p><p>执行completeTransactionAfterThrowing方法，我们的异常正好是这个异常（或者其父类）。</p><p><img src="/images/pasted-110.png" alt="upload successful"></p><p>然后执行回滚操作，最终到达下图所示方法（DataSourceTransactionManager的doRollback）</p><p><img src="/images/pasted-111.png" alt="upload successful"></p><p>回滚具体代码不在介绍，我们可以看到在回滚时它把原来数据库的自动提交属性改了过来。</p><p><img src="/images/pasted-112.png" alt="upload successful"></p><p>最后他会把本次事务状态清除，相当于保存上一次的事务状态。</p><p><img src="/images/pasted-113.png" alt="upload successful"></p><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><ol><li><p><strong>在spring启动时获取事务注解时我们可以看到下图</strong>。</p><p> <img src="/images/pasted-114.png" alt="upload successful"></p><p> <strong>这个说明Spring AOP 事务注解只能作用于public 方法。</strong></p></li><li><p><strong>关于事务回滚rollbackFor条件的问题，我们可以看到下图</strong>。</p><p> <img src="/images/pasted-115.png" alt="upload successful"></p><p> 当我们事务注解配置具体的回滚条件，如rollbackFor = Exception.class，只要是Exception.class或者其子类，都可以实现事务回滚。它会通过RuleBasedTransactionAttribute.class这个类去校验抛出的异常是否符合条件。进而判断是否需要回滚。</p><p> 但是当我们不声明rollbackFor 条件时，这儿应该注意一点。它会使用默认的条件，而不是不处理异常。主要由DefaultTransactionAttribute.class 里的rollbackOn方法实现。我们看下这个方法，可以发现，他只会处理RuntimeException和Error。也就是说，如果我们一个方法有事务，但抛出了非RuntimeException（如检查时异常等），且事务没有声明rollbackFor回滚条件，那么，它是不会触发事务回滚的。这一点要注意。</p><p> <img src="/images/pasted-116.png" alt="upload successful"></p><p> 上图调用RuleBasedTransactionAttribute.class的方法，回滚规则为空，使用父类rollbackOn方法。</p><p> <img src="/images/pasted-117.png" alt="upload successful"></p><p> <img src="/images/pasted-118.png" alt="upload successful"></p><p> 通过调试可以轻松看到这一情况，这儿不在做过多赘述。</p></li></ol><h2 id="异常事务调试"><a href="#异常事务调试" class="headerlink" title="异常事务调试"></a>异常事务调试</h2><p>我们来看下事务不成功的情况。就是题目开始的问题。</p><p>Spring刚启动时，会扫描需要进行代理的类，生成代理对象，在AdvisedSupport.class类中，把类中的方法缓存起来。</p><p><img src="/images/pasted-119.png" alt="upload successful"></p><p>首先查询该方法是不是需要拦截（是不是有事务注解）</p><p><img src="/images/pasted-120.png" alt="upload successful"></p><p><img src="/images/pasted-121.png" alt="upload successful"></p><p>在TransactionAttributeSourcePointcut.class 类里的matches方法，查询事务注解情况。</p><p><img src="/images/pasted-122.png" alt="upload successful"></p><p>查到了就缓存起来了。</p><p>当doInset方法进入时，同样的逻辑。也会缓存起来，但是cached是值为null。</p><p><img src="/images/pasted-123.png" alt="upload successful"></p><p><img src="/images/pasted-124.png" alt="upload successful"></p><p>该类的其他方法也会被缓存，没有事务注解的都放为null。</p><p>开始执行doInsert方法时，进入CglibAopProxy的intercept方法。</p><p><img src="/images/pasted-125.png" alt="upload successful"></p><p>可以看到尝试拿缓存，但缓存的值为空。</p><p><img src="/images/pasted-126.png" alt="upload successful"></p><p>尝试获取一下，显然也是没有值的。所以这时候认为不需要进行事务。事务链为空。</p><p><img src="/images/pasted-127.png" alt="upload successful"></p><p>就直接执行了方法doInsert。并不会开启事务。（不为空的话会创建一个CglibMethodInvocation并开启事务执行方法，如上面开始的情况）。</p><p><strong>当生成一个动态代理对象后，对这个对象引用中方法的调用就是对代理的调用，而这个代理能够代理所有跟特定方法调用相关的拦截器。不过，一旦调用最终抵达了目标对象 （此处为TransactionalTestImpl类的引用），任何对自身的调用例如insert将对this引用进行调用而非代理。这一点意义重大， 它意味着自我调用将不会导致和方法调用关联的通知得到执行的机会。</strong></p><p>如果需要insert的事务生效，一种典型的方法就将方法insert放到新的类中，这便很好理解了。因为新的类会生成新的动态代理对象，调用源从而获得通知。</p><p><strong>如果我非要在本类中实现通知呢？</strong></p><p>那我们就需要直接获取代理对象调用insert方法了。如下图。</p><p><img src="/images/pasted-128.png" alt="upload successful"></p><p>要实现这个功能，需要开启Spring AspectJ支持，我使用的Springboot，启动类上加入如下注解，并引入如下依赖。</p><p><img src="/images/pasted-129.png" alt="upload successful"></p><p><img src="/images/pasted-130.png" alt="upload successful"></p><p>这个pom文件你进去可以看到就是引用了AspectJ 的相关jar包。</p><p><img src="/images/pasted-131.png" alt="upload successful"></p><p>这个时候我们在测试一下，就会发现事务生效了。</p><p>在CglibAopProxy中可以看到如下代码，可以明白开启后它把代理对象绑定到ThreadLocal上等待insert方法执行的通知。</p><p><img src="/images/pasted-132.png" alt="upload successful"></p><p><img src="/images/pasted-133.png" alt="upload successful"></p><p><img src="/images/pasted-134.png" alt="upload successful"></p><p>当然，如果这两个方法上都存在事务，它也会进行判断处理，也就是事务的传播属性，他们主要通过<strong>AbstractPlatformTransactionManager</strong>这个类（这个类也很重要）的getTransaction方法和handleExistingTransaction方法来进行事务传播属性的处理。这儿不做过多讲解，自己看看逻辑处理即可。</p><p>getTransaction部分代码：</p><p><img src="/images/pasted-135.png" alt="upload successful"></p><p>handleExistingTransaction部分代码：</p><p><img src="/images/pasted-136.png" alt="upload successful"></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>总的来说，通过一个问题，我们大致看了下Spring Transactional注解的实现过程。并分析了产生这种问题的原因，通过有效的手段来进行验证。还是蛮不错的一次体验。</p><p>下面总结下：</p><p>A：<strong>在Spring中，一个类中无事务注解的方法A调用有事务注解的方法B，默认情况下B出现异常事务是不会进行回滚的</strong>。</p><p>解决方法：</p><ol><li><p><strong>将B写到一个新的方法中</strong>。（原理上是生成不同类的动态代理对象，实际中比较常用的一种手段，但需要管理一个新的类）</p></li><li><p><strong>如果业务（情形等）允许，可以将事务移动到A上，或者B的事务不动，给A也加一个事务</strong>。（根据具体情况讨论，有时候效果很好，有时候不适宜，使用此种方法可能影响程序效率或者产生莫名其妙的bug，慎用）</p></li><li><p><strong>启用增强型事务，引入AspectJ</strong>。（不太常用的一种手段，但如果项目中本来已经引入了AspectJ并且开启了增强型事务管理，何乐而不为呢？）</p></li></ol><p>B：<strong>研究过程中发现的其他应该注意的坑</strong>。</p><ol><li><p><strong>事务注解应当作用在public方法上，需要注意</strong>。</p></li><li><p><strong>如果不设置事务回滚条件（rollbackFor参数为空），它能捕获RuntimeException及其子类 和 Error及其子类 出现的异常情况并回滚，其他异常是无法捕获并回滚的。如IOException（检查型异常）等</strong>。</p></li><li><p><strong>事务的传播属性的几个应该了解，不能乱用，虽然我们可能就用到过或者就用到了Propagation.REQUIRED ，但不代表其它不会用到</strong>。</p></li></ol><p>C：<strong>本次研究学习我们应该理解掌握的</strong>。</p><ol><li><p>Spring事务的处理过程。（Spring AOP的体现，应用反射和动态代理）</p></li><li><p>事务的一些性质。（事务的传播属性、事务的四大特性等）</p></li><li><p>其它一些需要学习的地方。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;某日，在项目测试代码过程中，发现一个问题，&lt;strong&gt;对于一个方法A（无事务），调用B方法（有事务），当A，B方法在同一个类中的时候，在
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="Spring" scheme="https://www.sakuratears.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>如何以并发方式在同一个流上执行多种操作</title>
    <link href="https://www.sakuratears.top/blog/%E5%A6%82%E4%BD%95%E4%BB%A5%E5%B9%B6%E5%8F%91%E6%96%B9%E5%BC%8F%E5%9C%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E6%B5%81%E4%B8%8A%E6%89%A7%E8%A1%8C%E5%A4%9A%E7%A7%8D%E6%93%8D%E4%BD%9C20181027/"/>
    <id>https://www.sakuratears.top/blog/如何以并发方式在同一个流上执行多种操作20181027/</id>
    <published>2018-10-27T09:41:00.000Z</published>
    <updated>2018-10-27T10:04:32.184Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java 8中，流有一个非常大的局限性，使用时，对它操作一次仅能得到一个处理结果。当流进行终端操作后，如果你在试图遍历它，就会出现异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalStateException: stream has already been operated upon or closed</span><br></pre></td></tr></table></figure><p>虽然流就是如此设计的，但是我们有时候就希望可以通过流获取多个结果。或者说，你希望一次性向流中传入多个Lambda表达式。 为了达到这一目标，我们应该需要一个fork类型的方法，对每个复制的流应用不同的函数。理想情况下，这些操作也应该支持并行去拿到运算结果。</p><p>这一特性在Java 8中是没有的，不过我们可以利用一个通用API，即Spliterator，尤其是它的延迟绑定能力，结合BlockingQueues和Futures来实现这一特性。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="复制流"><a href="#复制流" class="headerlink" title="复制流"></a>复制流</h2><p>要达到此效果，我们首先应该创建一个StreamForker，它会对原始的流进行封装，在此基础上在执行各种操作。我们来看下代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamForker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Stream&lt;T&gt; stream;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, Function&lt;Stream&lt;T&gt;,?&gt;&gt; forks=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StreamForker</span><span class="params">(Stream&lt;T&gt; stream)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.stream = stream;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> StreamForker&lt;T&gt; <span class="title">fork</span><span class="params">(Object key,Function&lt;Stream&lt;T&gt;,?&gt; f)</span></span>&#123;</span><br><span class="line"><span class="comment">//使用一个键对流上的函数进行索引</span></span><br><span class="line">forks.put(key,f);</span><br><span class="line"><span class="comment">//返回this从而保证多次顺畅的调用fork方法</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Results <span class="title">getResults</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//TODO</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>fork</strong>方法接受两个参数。</p><p><strong>Function:</strong>对流进行处理，转变成这些操作结果的类型。</p><p><strong>key:</strong> 通过它拿到结果，这些结果被放到内部的一个Map中。</p><p>fork方法需要返回自身，这样可以复制多个操作构成流水线。</p><p>如图：</p><p><img src="/images/pasted-91.png" alt="upload successful"></p><p>上图不难理解。</p><p>而由fork方法添加的操作如何执行呢，就是通过getResults方法的调用触发，该方法返回一个Results接口的实现。接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Results</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">R <span class="title">get</span><span class="params">(Object key)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现Results接口"><a href="#实现Results接口" class="headerlink" title="实现Results接口"></a>实现Results接口</h2><p>我们使用ForkingStreamConsumer实现Results接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Results <span class="title">getResults</span><span class="params">()</span></span>&#123;</span><br><span class="line">ForkingStreamConsumer&lt;T&gt; consumer=build();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">stream.sequential().forEach(consumer);</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">consumer.finish();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> consumer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ForkingStreamConsumer同时实现了Results和Consumer接口。其主要任务就是来处理流元素，将他们分发到多个BlockingQuenes中处理，BlockingQuenes的数量和通过fork方法提交的操作数是一致的。这里的getResults的实现，流应该是顺序处理的，否则，forEach后元素的顺序就会变化。finish方法用来表明队列中没有更多要处理的元素了。build方法主要用于创建ForkingStreamConsumer。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ForkingStreamConsumer&lt;T&gt; <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//创建由队列组成的列表，每一个队列对应一个操作</span></span><br><span class="line">List&lt;BlockingQueue&lt;T&gt;&gt; queues=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//建立用于标识操作的键与包含操作结果的Future之间的映射关系</span></span><br><span class="line">Map&lt;Object,Future&lt;?&gt;&gt; actions=   </span><br><span class="line">forks.entrySet().stream().reduce(</span><br><span class="line"><span class="keyword">new</span> HashMap&lt;Object,Future&lt;?&gt;&gt;(),</span><br><span class="line">(map,e)-&gt;&#123;</span><br><span class="line">map.put(e.getKey(),getOperationResult(queues,e.getValue()));</span><br><span class="line"><span class="keyword">return</span> map;</span><br><span class="line">&#125;,</span><br><span class="line">(m1,m2)-&gt;&#123;</span><br><span class="line">m1.putAll(m2);</span><br><span class="line"><span class="keyword">return</span> m1;</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ForkingStreamConsumer&lt;&gt;(queues,actions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们先创建了BlockingQuenes列表。接着创建了一个Map，Map的键就是用来标识不同操作的键，值包含着Future里。最终BlockingQuenes和Map会被传递给ForkingStreamConsumer的构造函数。每个Future通过关键方法getOperationResult创建。</p><p>来看看getOperationResult的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Future&lt;?&gt; getOperationResult(List&lt;BlockingQueue&lt;T&gt;&gt; queues,Function&lt;Stream&lt;T&gt;,?&gt; f)&#123;</span><br><span class="line"><span class="comment">//创建一个队列，并将其添加到队列的列表中</span></span><br><span class="line">BlockingQueue&lt;T&gt; queue=<span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;();</span><br><span class="line">queues.add(queue);</span><br><span class="line"><span class="comment">//创建一个Spliterator，遍历队列中的元素</span></span><br><span class="line">Spliterator&lt;T&gt; spliterator=<span class="keyword">new</span> BlockingQueueSpliterator&lt;&gt;(queue);</span><br><span class="line"><span class="comment">//创建一个流，将Spliterator作为数据源</span></span><br><span class="line">Stream&lt;T&gt; source= StreamSupport.stream(spliterator,<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//创建一个Future对象，以异步方式计算在流上执行特定函数的结果</span></span><br><span class="line"><span class="keyword">return</span> CompletableFuture.supplyAsync(()-&gt;f.apply(source));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法创建一个新的BlockingQuene，并将其添加到队列列表。队列会被传递给一个新的BlockingQueueSpliterator对象，后者是一个延迟绑定的Spliterator。然后我们创建一个顺序流对Spliterator进行遍历，最终创建一个Future收集结果。</p><h2 id="开发ForkingStreamConsumer"><a href="#开发ForkingStreamConsumer" class="headerlink" title="开发ForkingStreamConsumer"></a>开发ForkingStreamConsumer</h2><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkingStreamConsumer</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt;,<span class="title">Results</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object END_OF_STREAM=<span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;BlockingQueue&lt;T&gt;&gt; queues;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, Future&lt;?&gt;&gt; actions;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ForkingStreamConsumer</span><span class="params">(List&lt;BlockingQueue&lt;T&gt;&gt; queues, Map&lt;Object, Future&lt;?&gt;&gt; actions)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.queues = queues;</span><br><span class="line"><span class="keyword">this</span>.actions = actions;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">R <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ((Future&lt;R&gt;)actions.get(key)).get();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line"><span class="comment">//将流中遍历的元素添加到所有的队列中</span></span><br><span class="line">queues.forEach(q-&gt;q.add(t));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//将最后一个元素添加到队列中，表明该流已经结束</span></span><br><span class="line">accept((T)END_OF_STREAM);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类同时实现了Consumer接口和Results接口。</p><p>Consumer接口要求实现accept方法，每当ForkingStreamConsumer接受流中的一个元素，它就会将元素添加到所有BlockingQuenes中当所有元素都添加到所有队列后，finish方法将最后一个元素添加到所有队列。处理时碰上这个元素表明后面没有元素要处理了。</p><p>Results接口需要实现get方法。一旦处理结束，get方法会获取Map中由键索引的Future，解析到结果后返回。</p><p>每有一个操作，就会对应一个BlockingQueueSpliterator。我们来看下BlockingQueueSpliterator的实现。</p><h2 id="开发BlockingQueueSpliterator"><a href="#开发BlockingQueueSpliterator" class="headerlink" title="开发BlockingQueueSpliterator"></a>开发BlockingQueueSpliterator</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueSpliterator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Spliterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;T&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BlockingQueueSpliterator</span><span class="params">(BlockingQueue&lt;T&gt; q)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.q = q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">T t;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">t=q.take();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t!=ForkingStreamConsumer.END_OF_STREAM)&#123;</span><br><span class="line">action.accept(t);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Spliterator&lt;T&gt; <span class="title">trySplit</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">estimateSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到该Spliterator未定义任何切割流的策略，仅仅利用了流的延迟绑定能力。也没有实现trySplit方法。由于我们的操作数是不确定的，故estimateSize不能提供任何有意义的数字，返回0.也没有体现Spliterator的特性，故characteristics返回0.</p><p>仅仅实现了tryAdvance方法，它从BlockingQueue中取得原始流元素，进一步传给Consumer对象。当返回true时表明还有元素要处理，直到发现最后一个元素时终止。</p><p>以上基本上是在一个流上执行多种操作的代码。</p><p>我们下面来检测一下正确性。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>编写测试类。如下数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//生成1到1000的数组</span></span><br><span class="line">List&lt;Integer&gt; list1=IntStream.rangeClosed(<span class="number">1</span>,<span class="number">1000</span>).filter(n-&gt;n%<span class="number">2</span>==<span class="number">0</span>).boxed().collect(Collectors.toList());</span><br><span class="line">List&lt;Integer&gt; list2=IntStream.rangeClosed(<span class="number">1</span>,<span class="number">1000</span>).filter(n-&gt;n%<span class="number">5</span>==<span class="number">0</span>).boxed().collect(Collectors.toList());</span><br><span class="line"><span class="comment">//同时对list1数据求和，统计list1数据数量，统计list1和list2相同元素，统计list1和list2相同元素的最大值和最小值</span></span><br><span class="line">Results results=<span class="keyword">new</span> StreamForker&lt;Integer&gt;(list1.stream())</span><br><span class="line">.fork(<span class="string">"sum"</span>,s-&gt;s.mapToInt(Integer::intValue).sum())</span><br><span class="line">.fork(<span class="string">"count"</span>,s-&gt;s.count())</span><br><span class="line">.fork(<span class="string">"list3"</span>,s-&gt;s.flatMap(i-&gt;list2.stream().filter(j-&gt;i.equals(j))).collect(Collectors.toList()))</span><br><span class="line">.fork(<span class="string">"max"</span>,s-&gt;s.flatMap(i-&gt;list2.stream().filter(j-&gt;i.equals(j))).max(Comparator.naturalOrder()))</span><br><span class="line">.fork(<span class="string">"min"</span>,s-&gt;s.flatMap(i-&gt;list2.stream().filter(j-&gt;i.equals(j))).min(Comparator.naturalOrder()))</span><br><span class="line">.getResults();</span><br><span class="line">System.out.println(<span class="string">"sum="</span>+results.get(<span class="string">"sum"</span>));</span><br><span class="line">System.out.println(<span class="string">"count="</span>+results.get(<span class="string">"count"</span>));</span><br><span class="line">System.out.println(<span class="string">"max="</span>+((Optional) results.get(<span class="string">"max"</span>)).get());</span><br><span class="line">System.out.println(<span class="string">"min="</span>+((Optional)results.get(<span class="string">"min"</span>)).get());</span><br><span class="line">    ((List&lt;Integer&gt;)results.get(<span class="string">"list3"</span>)).stream().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="/images/pasted-92.png" alt="upload successful"></p><p>可以看到，使用了一个流，通过我们实现的方法进行了多次终端操作返回正确结果。</p><h1 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h1><p>这是我们用一个流实现多种终端操作的方式，当然这并不意味着会比普通的写法效率高，如果对于上述问题，我们可以分个构建若干个流进行一一实现。</p><p>这种一个流进行多个终端操作的情况使用，一定是生成流比较耗费资源性能时才会用到，比如操作一个较大文件时生成的字符流，我们想统计字数，检查某些单词出现的次数，统计行数等等操作，重复生成流显然是耗费资源的。这种情况可以考虑使用这种一个流进行多个终端操作的实现。</p><p>当然，具体到具体问题优化，建议认真分析两者的资源消耗。这是比较稳妥的做法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Java 8中，流有一个非常大的局限性，使用时，对它操作一次仅能得到一个处理结果。当流进行终端操作后，如果你在试图遍历它，就会出现异常。&lt;/
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>封装一个属于自己的Redis API</title>
    <link href="https://www.sakuratears.top/blog/%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84Redis-API20181027/"/>
    <id>https://www.sakuratears.top/blog/封装一个属于自己的Redis-API20181027/</id>
    <published>2018-10-27T09:15:00.000Z</published>
    <updated>2018-10-27T09:37:30.435Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Redis作为一款强大的key-value型数据库，其应用是十分广泛的。在Java语言中，常用来与Redis数据库建立连接用到的是Jedis Pool连接池。</p><p>今天我们来简单了解下它们然后实现一个可移植的操作Redis的API。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="知识准备"><a href="#知识准备" class="headerlink" title="知识准备"></a>知识准备</h2><p>我们知道Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。并提供了一系列的命令操作这些数据类型。</p><p>Jedis相当于对这些操作进行了代码封装，及提供了一些其它常用操作。</p><p>我们先来了解下Jedis的连接池配置参数。</p><p>commons-pool2 有一个配置类GenericObjectPoolConfig里面的通用参数设置如下：</p><table><thead><tr><th>参数</th><th>说明</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td>maxTotal</td><td>说明一个pool最多可以有多少个Jedis实例</td><td>8</td><td>-1表示不限制</td></tr><tr><td>maxIdle</td><td>一个pool最多可以有多少个空闲的Jedis实例</td><td>8</td><td></td></tr><tr><td>minIdle</td><td>一个pool最少有多少个空闲的Jedis实例</td><td>0</td></tr></tbody></table><p>可以看到它继承BaseObjectPoolConfig。我们可以看到BaseObjectPoolConfig的参数如下。</p><p><img src="/images/pasted-88.png" alt="upload successful"></p><p>部分参数意义如下：</p><table><thead><tr><th>参数</th><th>说明</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td>lifo</td><td>pool中的idle列表是双端队列，设定是否last in first out</td><td>true</td><td></td></tr><tr><td>maxWaitMillis</td><td>当active数量为max时,等待的时长</td><td>-1L(代表一直等)</td><td>配合blockWhenExhausted使用</td></tr><tr><td>blockWhenExhausted</td><td>当active数量为max时，是否阻塞等待一段时间</td><td>true</td><td></td></tr><tr><td>testOnCreate</td><td>创建实例时有效性检测</td><td>false</td><td></td></tr><tr><td>testOnReturn</td><td>归还实例时有效性检测</td><td>false</td><td></td></tr><tr><td>testOnBorrow</td><td>借出实例时有效性检测</td><td>false</td></tr></tbody></table><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>首先Redis连接池属性我们应当放置在配置文件里，解析并获得，连接池最好设计成单例的，每次不用在初始化过多连接资源。同时Redis有单机模式和集群模式区分，这两种模式我们也应该区分开来。单机模式下，可以选择多个database，集群模式下只能选择database0.集群模式下，如果redis地址过多，我们如何分开呢？</p><p>我们可以考虑如下样式：<br>address =127.0.0.1:6379;127.0.0.1:6380</p><p>每个redis地址用分号分隔，解析配置时把每个解析到并建立连接。</p><p>当然，最后完成JedisPool的创建后，我们应该编写工具类对一些常用操作方法进行封装，便于我们使用。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>我们根据上述思路，构造了如下图所示的小项目。</p><p><img src="/images/pasted-89.png" alt="upload successful"></p><p>其中：</p><p><strong>RedisException</strong>是用来统一处理程序过程中的异常的类。</p><p><strong>JedisFactory</strong>可以认为是一个JedisPool工厂，用来提供单机模式的连接池或者集群模式的连接池。</p><p><strong>RedisConfiguration</strong>是与配置文件对应的配置类，用于存放配置的数据。</p><p><strong>RedisConstants</strong>用来放置一些项目中用到的常量。</p><p><strong>RedisUtil</strong>工具类接口，提供了多种操作Redis的方法。</p><p><strong>RedisSingleUtil</strong>工具接口的单机模式实现。</p><p><strong>RedisClusterUtil</strong>工具接口的集群模式实现。</p><p><strong>redis-config.properties</strong> Redis的配置文件存放</p><p>JedisFactory和RedisUtill为主要类。我们看下他们的具体实现。</p><p>JedisFactory的主要代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> JedisPool jedisPool;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> JedisCluster jedisCluster;</span><br><span class="line">   <span class="keyword">private</span> RedisConfiguration redisConfig;</span><br><span class="line">   <span class="keyword">private</span> Pattern addRessPattern = Pattern.compile(<span class="string">"^.+[:]\\d&#123;1,5&#125;\\s*(;.+[:]\\d&#123;1,5&#125;\\s*)*[;]?\\s*$"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">JedisFactory</span><span class="params">(<span class="keyword">final</span> RedisConfiguration redisConfiguration)</span></span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.redisConfig=redisConfiguration;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> JedisPool <span class="title">getJedisPool</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(jedisPool==<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (JedisFactory.class)&#123;</span><br><span class="line">               <span class="keyword">if</span>(jedisPool==<span class="keyword">null</span>)&#123;</span><br><span class="line">                   init();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> jedisPool;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> JedisCluster <span class="title">getJedisCluster</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(jedisCluster==<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (JedisFactory.class)&#123;</span><br><span class="line">               <span class="keyword">if</span>(jedisCluster==<span class="keyword">null</span>)&#123;</span><br><span class="line">                   init();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> jedisCluster;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">       logger.info(<span class="string">"JedisFactory init start..."</span>);</span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(StringUtils.isNotBlank(redisConfig.getLocalPropertiesPath()))&#123;</span><br><span class="line">               fillData();</span><br><span class="line">           &#125;</span><br><span class="line">           logger.info(<span class="string">"redis config is: &#123;&#125;."</span>, redisConfig.toString());</span><br><span class="line">           Set&lt;HostAndPort&gt; hostAndPortSet = <span class="keyword">this</span>.parseHostAndPort(redisConfig.getAddress());</span><br><span class="line"></span><br><span class="line">           GenericObjectPoolConfig genericObjectPoolConfig = <span class="keyword">new</span> GenericObjectPoolConfig();</span><br><span class="line">           genericObjectPoolConfig.setMaxWaitMillis(redisConfig.getMaxWaitMillis());</span><br><span class="line">           genericObjectPoolConfig.setMaxTotal(redisConfig.getMaxTotal());</span><br><span class="line">           genericObjectPoolConfig.setMinIdle(redisConfig.getMinIdle());</span><br><span class="line">           genericObjectPoolConfig.setMaxIdle(redisConfig.getMaxIdle());</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span>(redisConfig.getMode()== RedisConstants.REDIS_MODE_SINGLE)&#123;</span><br><span class="line">               HostAndPort hostAndPort=(HostAndPort)hostAndPortSet.toArray()[<span class="number">0</span>];</span><br><span class="line">               jedisPool=<span class="keyword">new</span> JedisPool(genericObjectPoolConfig, hostAndPort.getHost(), hostAndPort.getPort(), redisConfig.getTimeout(), <span class="keyword">null</span>,redisConfig.getDatabase());</span><br><span class="line">               logger.info(<span class="string">"jedisPool init is finished"</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">if</span>(redisConfig.getDatabase()!=<span class="number">0</span>)&#123;</span><br><span class="line">                   logger.warn(<span class="string">"当前配置的database为："</span>+redisConfig.getDatabase()+<span class="string">",集群模式下不能选择database，只能使用database0"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               jedisCluster = <span class="keyword">new</span> JedisCluster(hostAndPortSet, redisConfig.getTimeout(), redisConfig.getMaxRedirections(), genericObjectPoolConfig);</span><br><span class="line">               logger.info(<span class="string">"jedisCluster init is finished"</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RedisException(ex);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fillData</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">       Properties localProperties = PropertiesUtils.loadLocalProperties(redisConfig.getLocalPropertiesPath());</span><br><span class="line"></span><br><span class="line">       String address=localProperties.getProperty(<span class="string">"address"</span>, <span class="string">""</span>);</span><br><span class="line">       <span class="keyword">if</span> (StringUtils.isBlank(address)) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RedisException(<span class="string">"error:redis config address is blank!"</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 设置初始值</span></span><br><span class="line">       <span class="keyword">long</span> maxWaitMillis=Long.parseLong(localProperties.getProperty(<span class="string">"maxWaitMillis"</span>, String.valueOf(GenericObjectPoolConfig.DEFAULT_MAX_WAIT_MILLIS)));</span><br><span class="line">       <span class="keyword">int</span> maxTotal=Integer.parseInt(localProperties.getProperty(<span class="string">"maxTotal"</span>, String.valueOf(GenericObjectPoolConfig.DEFAULT_MAX_TOTAL)));</span><br><span class="line">       <span class="keyword">int</span> minIdle=Integer.parseInt(localProperties.getProperty(<span class="string">"minIdle"</span>, String.valueOf(GenericObjectPoolConfig.DEFAULT_MIN_IDLE)));</span><br><span class="line">       <span class="keyword">int</span> maxIdle=Integer.parseInt(localProperties.getProperty(<span class="string">"maxIdle"</span>, String.valueOf(GenericObjectPoolConfig.DEFAULT_MAX_IDLE)));</span><br><span class="line">       <span class="keyword">int</span> timeout=Integer.parseInt((localProperties.getProperty(<span class="string">"timeout"</span>, <span class="string">"2000"</span>)));</span><br><span class="line">       <span class="keyword">int</span> maxRedirections=Integer.parseInt((localProperties.getProperty(<span class="string">"maxRedirections"</span>, <span class="string">"6"</span>)));</span><br><span class="line">       <span class="keyword">int</span> database=Integer.parseInt((localProperties.getProperty(<span class="string">"database"</span>, <span class="string">"0"</span>)));</span><br><span class="line">       <span class="comment">//1单机模式，2集群模式</span></span><br><span class="line">       <span class="keyword">int</span> mode=Integer.parseInt((localProperties.getProperty(<span class="string">"mode"</span>, String.valueOf(RedisConstants.REDIS_MODE_SINGLE))));</span><br><span class="line"></span><br><span class="line">       redisConfig.setAddress(address);</span><br><span class="line">       redisConfig.setMaxWaitMillis(maxWaitMillis);</span><br><span class="line">       redisConfig.setMaxTotal(maxTotal);</span><br><span class="line">       redisConfig.setMinIdle(minIdle);</span><br><span class="line">       redisConfig.setMaxIdle(maxIdle);</span><br><span class="line">       redisConfig.setTimeout(timeout);</span><br><span class="line">       redisConfig.setMaxRedirections(maxRedirections);</span><br><span class="line">       redisConfig.setDatabase(database);</span><br><span class="line">       redisConfig.setMode(mode);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//部分代码略</span></span><br></pre></td></tr></table></figure></p><p>对于RedisUtil接口，应有两个实现，单机和集群的，这里为了简化代码，只简单列举了一个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RedisUtil</span> </span>&#123;</span><br><span class="line"><span class="function">String <span class="title">setString</span><span class="params">(String key, String value)</span></span>;</span><br><span class="line">    <span class="comment">//部分代码略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单机模式的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisSingleUtil</span> <span class="keyword">implements</span> <span class="title">RedisUtil</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">setString</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">this</span>.getResource();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> jedis.set(key, value);</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.closeResource(jedis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//部分代码略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>集群模式的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisClusterUtil</span> <span class="keyword">implements</span> <span class="title">RedisUtil</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">setString</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        JedisCluster cluster=getResource();</span><br><span class="line">        <span class="keyword">return</span> getResource().set(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//部分代码略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他方法及实现不在赘述，有兴趣的可以在</p><p><a href="https://github.com/javazwt/framework-base" target="_blank" rel="noopener">https://github.com/javazwt/framework-base</a> 上查看相关代码。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTest</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> RedisSingleUtil redisSingleUtil=<span class="keyword">new</span> RedisSingleUtil();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    redisSingleUtil.setString(<span class="string">"str"</span>,<span class="string">"123"</span>);</span><br><span class="line">        redisSingleUtil.getString(<span class="string">"str"</span>);  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以检测我们的正确性。</p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>经过封装后，我们可以把该工具类使用在任何项目上，提高开发效率，降低项目耦合性，同时对Redis有了更深入的认知。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Redis作为一款强大的key-value型数据库，其应用是十分广泛的。在Java语言中，常用来与Redis数据库建立连接用到的是Jedis
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>封装构建基于ES的Java API包</title>
    <link href="https://www.sakuratears.top/blog/%E5%B0%81%E8%A3%85%E6%9E%84%E5%BB%BA%E5%9F%BA%E4%BA%8EES%E7%9A%84Java-API%E5%8C%8520181027/"/>
    <id>https://www.sakuratears.top/blog/封装构建基于ES的Java-API包20181027/</id>
    <published>2018-10-27T08:39:00.000Z</published>
    <updated>2018-10-27T09:13:04.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前些日子，elastic公司成功上市了。旗下有一款优秀的开源搜索引擎ElasticSearch。</p><p><strong>ElasticSearch</strong>是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。</p><p>好了，扯远了，回归正题。今天我们使用Java对它的一些API进行封装，以使其API更具备灵活性。</p><p>完成对其简单的使用是比较简单的，我们今天把我们的一些调用代码封装，以便可以在各个项目中自由使用。这才是我们的根本目的。</p><p>今天，我们来构建一个工具包类。</p><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>安装ElasticSearch，主要就是为了测试我们的代码，对于有现成环境的，如开发环境，测试环境上的ElasticSearch，这一步可以忽略。</p><ol><li><p>首先请安装ElasticSearch，这里就不介绍了，我这里是安装的ElasticSearch最新版，6.4.0版本。<a href="https://www.elastic.co/downloads/elasticsearch" target="_blank" rel="noopener">https://www.elastic.co/downloads/elasticsearch</a> 。安装成功后可以将其添加到环境变量中，然后启动。启动成功浏览器访问<a href="http://localhost:9200/" target="_blank" rel="noopener">http://localhost:9200/</a> 会看到json信息。</p></li><li><p>安装Kibana，Kibana是ElasticSearch的可视化工具，可以方便的查看ElasticSearch及其运行状态。<a href="https://www.elastic.co/products/kibana" target="_blank" rel="noopener">https://www.elastic.co/products/kibana</a> 。我安装的也是最新版本，6.4.0. 安装成功后加入环境变量，然后启动，访问<a href="http://localhost:5601/" target="_blank" rel="noopener">http://localhost:5601/</a> 可以看到Kibana界面。</p></li><li><p>JDK版本为1.8</p></li></ol><p>以上都为准备工作。</p><h1 id="架构构建"><a href="#架构构建" class="headerlink" title="架构构建"></a>架构构建</h1><p>org.elasticsearch.client.transport jar包已经有相关关于ES API的操作。</p><p>我们把它封装为专用jar包，建议使用Maven构建。如下：</p><h2 id="Maven项目"><a href="#Maven项目" class="headerlink" title="Maven项目"></a>Maven项目</h2><p>首先，我们先建一个名叫 framework-es的Maven项目。如下。</p><p>建好各个package。</p><p><strong>exception</strong>里面定义我们的异常。</p><p><strong>factory</strong>里面用来生成esclient。</p><p><strong>util</strong>里面放一些工具类。</p><p><strong>vo</strong>里面可以放查询对象等。</p><p><strong>property</strong>为配置文件。</p><p><strong>test</strong>里面存放测试类。</p><p>各个package的名字可以自己定义，描述清目的即可。如下图。</p><p><img src="/images/pasted-85.png" alt="upload successful"></p><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p>添加依赖，我的pom.xml依赖如下。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>transport<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.31<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>我的思路是构建一个单例的ESClient，用于与ES建立连接，以后增删改查等逻辑均使用此Client，保证资源的高效利用。这个也应当支持ES集群，有多个ES服务端也应当支持。而且地址应为可配置的。</p><p>话不多说，上代码，主要代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElasticSearchClientFactory</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(ElasticSearchClientFactory.class);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> TransportClient esClient;</span><br><span class="line"><span class="comment">//ES配置</span></span><br><span class="line"><span class="keyword">private</span> ElasticSearchConfiguration esConfig;</span><br><span class="line"><span class="comment">//校验多个ES地址的正则</span></span><br><span class="line"><span class="keyword">private</span> Pattern addRessPattern = Pattern.compile(<span class="string">"^.+[:]\\d&#123;1,5&#125;\\s*(;.+[:]\\d&#123;1,5&#125;\\s*)*[;]?\\s*$"</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ElasticSearchClientFactory</span><span class="params">(<span class="keyword">final</span> ElasticSearchConfiguration elasticSearchConfiguration)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.esConfig=elasticSearchConfiguration;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 获取一个单例的ESClient</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Client <span class="title">getEsClient</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(esClient==<span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (ElasticSearchClientFactory.class)&#123;</span><br><span class="line"><span class="keyword">if</span>(esClient==<span class="keyword">null</span>)&#123;</span><br><span class="line">logger.info(<span class="string">"ElasticSearchClientFactory init start..."</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(StringUtils.isNotBlank(esConfig.getLocalPropertiesPath()))&#123;</span><br><span class="line"><span class="comment">//获取ES配置信息</span></span><br><span class="line">fillData();</span><br><span class="line">&#125;</span><br><span class="line">logger.info(<span class="string">"ESConfig is:&#123;&#125;"</span>,esConfig.toString());</span><br><span class="line"><span class="comment">//多个ES地址解析</span></span><br><span class="line">List&lt;HostAndPort&gt; hostAndPortList = <span class="keyword">this</span>.parseHostAndPortList(esConfig.getAddress());</span><br><span class="line">TransportAddress [] transportAddress=<span class="keyword">new</span> TransportAddress[hostAndPortList.size()];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hostAndPortList.size(); i++) &#123;</span><br><span class="line">transportAddress[i] = <span class="keyword">new</span> TransportAddress(InetAddress.getByName(hostAndPortList.get(i).getIp()),hostAndPortList.get(i).getPort());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//节点名</span></span><br><span class="line">String nodeName=esConfig.getNodeName()+ UUID.randomUUID();</span><br><span class="line">String clusterName=esConfig.getClusterName();</span><br><span class="line">Settings.Builder settingsBuilder = Settings.builder();</span><br><span class="line">settingsBuilder.put(<span class="string">"node.name"</span>, nodeName);</span><br><span class="line"><span class="keyword">if</span>(StringUtils.isNotBlank(clusterName))&#123;</span><br><span class="line">settingsBuilder.put(<span class="string">"cluster.name"</span>, clusterName);</span><br><span class="line">&#125;</span><br><span class="line">settingsBuilder.put(<span class="string">"client.transport.sniff"</span>, <span class="keyword">true</span>);</span><br><span class="line">Settings settings = settingsBuilder.build();</span><br><span class="line">TransportClient client = <span class="keyword">new</span> PreBuiltTransportClient(settings);</span><br><span class="line"><span class="comment">//创建ESClient</span></span><br><span class="line">esClient = client.addTransportAddresses(transportAddress);</span><br><span class="line">logger.info(<span class="string">"EalsticSearchClientFactory init is finished"</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">logger.error(<span class="string">"EalsticSearchClientFactory create failed"</span>,e);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ElasticSearchException(<span class="string">"EalsticSearchClientFactory create faile"</span>,e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> esClient;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//其他代码略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码用于生成一个单例的ESClient类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElasticSearchConstants</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String DEFAULT_PROPERTIES_PATH=<span class="string">"property/es-config.properties"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时默认配置文件为property/es-config.properties<br>可手动进行配置，且支持多个地址，地址写法为 127.0.0.1:9200;127.0.0.2:9300</p><p>这样，中间应使用;分割。</p><p>我们对外提供一个工具类，供使用者进行对数据的操作。如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElasticSearchUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(ElasticSearchUtil.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SerializerFeature[] featuresWithNullValue=&#123;SerializerFeature.WriteMapNullValue, SerializerFeature.WriteNullBooleanAsFalse,</span><br><span class="line">            SerializerFeature.WriteNullListAsEmpty, SerializerFeature.WriteNullNumberAsZero, SerializerFeature.WriteNullStringAsEmpty&#125;;</span><br><span class="line">    <span class="keyword">private</span> ElasticSearchClientFactory elasticSearchClientFactory;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setElasticSearchClientFactory</span><span class="params">(ElasticSearchClientFactory elasticSearchClientFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elasticSearchClientFactory = elasticSearchClientFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ElasticSearchUtil</span><span class="params">(ElasticSearchClientFactory elasticSearchClientFactory)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elasticSearchClientFactory=elasticSearchClientFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ElasticSearchUtil</span><span class="params">(String localPropertiesPath)</span></span>&#123;</span><br><span class="line">        ElasticSearchConfiguration esConfig=<span class="keyword">new</span> ElasticSearchConfiguration();</span><br><span class="line">        esConfig.setLocalPropertiesPath(localPropertiesPath);</span><br><span class="line">        <span class="keyword">this</span>.elasticSearchClientFactory=<span class="keyword">new</span> ElasticSearchClientFactory(esConfig);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ElasticSearchUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ElasticSearchConfiguration esConfig = <span class="keyword">new</span> ElasticSearchConfiguration();</span><br><span class="line">        esConfig.setLocalPropertiesPath(ElasticSearchConstants.DEFAULT_PROPERTIES_PATH);</span><br><span class="line">        <span class="keyword">this</span>.elasticSearchClientFactory = <span class="keyword">new</span> ElasticSearchClientFactory(esConfig);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ElasticSearchUtil</span><span class="params">(ElasticSearchConfiguration esConfig)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elasticSearchClientFactory = <span class="keyword">new</span> ElasticSearchClientFactory(esConfig);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Client <span class="title">getEsClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> elasticSearchClientFactory.getEsClient();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isOnlyCreate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jsonString</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span>  <span class="keyword">boolean</span> <span class="title">createDocument</span><span class="params">(String index,String type,String id,<span class="keyword">boolean</span> isOnlyCreate,String jsonString)</span></span>&#123;</span><br><span class="line">        IndexResponse indexResponse;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isBlank(id))&#123;</span><br><span class="line">            indexResponse=elasticSearchClientFactory.getEsClient().prepareIndex(index,type).setCreate(isOnlyCreate).setSource(jsonString, XContentType.JSON).get();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            indexResponse=elasticSearchClientFactory.getEsClient().prepareIndex(index,type,id).setCreate(isOnlyCreate).setSource(jsonString,XContentType.JSON).get();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(logger.isDebugEnabled())&#123;</span><br><span class="line">            String _index=indexResponse.getIndex();</span><br><span class="line">            String _type=indexResponse.getType();</span><br><span class="line">            String _id=indexResponse.getId();</span><br><span class="line">            <span class="keyword">long</span> _version = indexResponse.getVersion();</span><br><span class="line">            <span class="keyword">boolean</span> created = RestStatus.CREATED.equals(indexResponse.status());</span><br><span class="line">            logger.debug(String.format(<span class="string">"createDocument index:%s,type:%s,id:%s,version:%s,created:%s"</span>, _index, _type, _id, _version, created));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> RestStatus.CREATED.equals(indexResponse.status());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他代码略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建好客户端后，我们可以用它执行增删改查，我们在封装一个ESUtil类，用于执行该系列操作，暴露一些特定增删改查接口。如上代码。</p><p>注：其他代码略。</p><p>这样，完成代码后，工程项目如下图所示。</p><p><img src="/images/pasted-86.png" alt="upload successful"></p><p><strong>ElasticSearchException</strong> 为自定义异常类。</p><p><strong>ElasticSearchClientFactory</strong>为主要方法，用来构建一个单例的ESClient</p><p><strong>ElasticSearchConfiguration</strong>为ES配置类</p><p><strong>ElasticSearchConstants</strong>为常量类，里面存放配置文件的路径</p><p><strong>HostAndPort</strong>为地址和端口的一个辅助Bean</p><p><strong>ElasticSearchUtil</strong>为主要方法，用于对外提供服务（CRUD）</p><p><strong>DocumentVo</strong>为辅助Bean</p><p><strong>es-config.properties</strong>为配置文件</p><p>当我们把项目打包成jar包时，配置文件可以不用打包，这样引入其他项目后，在其他项目里配置配置文件即可。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>若ES的安装路径D:\Program Files\elasticsearch-6.4.0\bin成功配置到环境变量后，在命令行输入elasticsearch便可启动服务。</p><p>若Kibana的安装路径D:\Program Files\kibana-6.4.0-windows-x86_64成功配置到环境变量后，在命令行输入kibana便可启动服务。</p><p>访问<a href="http://127.0.0.1:5601/" target="_blank" rel="noopener">http://127.0.0.1:5601/</a> 看到可视化界面。</p><p>编写测试类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ESTest</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ElasticSearchUtil esUtil=<span class="keyword">new</span> ElasticSearchUtil();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String index=<span class="string">"user_index"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String type=<span class="string">"user_type"</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">JSONObject js=<span class="keyword">new</span> JSONObject();</span><br><span class="line">js.put(<span class="string">"1"</span>,<span class="string">"2"</span>);</span><br><span class="line">esUtil.insertDocument(index,type,<span class="string">"123"</span>,js);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看Kibana界面可以看到我们的数据被添加进来了。</p><p><img src="/images/pasted-87.png" alt="upload successful"></p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>关于ElasticSearch及Kibana的具体使用我们以后再讲。</p><p>我们平时开发中，也可以创建类似的工具包，提高代码使用率，实现软件的高内聚低耦合，同时也是提高自己。</p><p>部分未展示代码请见我的GitHub地址: <a href="https://github.com/javazwt/" target="_blank" rel="noopener">https://github.com/javazwt/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前些日子，elastic公司成功上市了。旗下有一款优秀的开源搜索引擎ElasticSearch。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Elasti
      
    
    </summary>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java8 Spliterator接口</title>
    <link href="https://www.sakuratears.top/blog/Java8-Spliterator%E6%8E%A5%E5%8F%A320181027/"/>
    <id>https://www.sakuratears.top/blog/Java8-Spliterator接口20181027/</id>
    <published>2018-10-27T08:17:00.000Z</published>
    <updated>2018-10-27T08:37:13.932Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Spliterator 是Java8中加入的一个新接口，是“可分迭代器”（splitable iterator）的意思。它也是用来遍历数据源中的元素的，但它是为并行执行而设计的。</p><p>其接口主要代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Public <span class="class"><span class="keyword">interface</span> <span class="title">Spliterator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"><span class="function">Boolean <span class="title">tryAdvance</span><span class="params">(Consumer &lt;? <span class="keyword">super</span> T&gt;)</span> action</span>;</span><br><span class="line"><span class="function">Spliterator&lt;T&gt; <span class="title">trySplit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Long <span class="title">estimateSize</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Int <span class="title">characteristics</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>T </strong>是Spliterator要遍历的元素类型。</p><p><strong>tryAdvance</strong> 方法的行为类似于普通的Iterator，因为它会按顺序一个一个使用Spliterator中的元素，并且如果还有其他元素要遍历就返回true。</p><p><strong>trySplit</strong> 是专为Spliterator接口而设计的，因为它可以把一些元素划出去分给第二个Spliterator，让他们两个并行处理。</p><p><strong>estimateSize</strong>方法估计还剩多少元素需要遍历，因为即使不那么精确，快速算出来的值也有助于让拆分均匀点。</p><blockquote><p>注：将Stream流拆分成多个部分的算法是个递归过程，第一步第一个Spliterator调用trySplit，生成两个Spliterator，第二步这两个Spliterator调用trySplit，生成4个Spliterator，直到调用Spliterator的trySplit 方法后返回null，表示这部分Spliterator不能在分割。</p></blockquote><p>这个拆分过程也受Spliterator本身特性的影响，而特性是通过<strong>characteristics</strong>方法声明的。</p><p>我们来简单看一下它的特性的常用值。</p><table><thead><tr><th>特性</th><th>含义</th></tr></thead><tbody><tr><td>ORDERED</td><td>按元素的既定顺序遍历和划分</td></tr><tr><td>DISTINCT</td><td>对于任一遍历过的元素x，y,x.equals(y)返回false</td></tr><tr><td>SORTED</td><td>遍历元素按照一个预定义顺序排序</td></tr><tr><td>SIZED</td><td>Spliterator由一个已知大小的数据源建立，estimateSize会返回准确值</td></tr><tr><td>NONNULL</td><td>保证遍历元素不会为空</td></tr><tr><td>IMMUTABLE</td><td>Spliterator的数据源不能被修改，（不能 添加、删除、修改任何元素）</td></tr><tr><td>CONCURRENT</td><td>Spliterator的数据源可以被其他线程同时修改而无需同步</td></tr><tr><td>SUBSIZED</td><td>该Spliterator和从它拆分出来的Spliterator都是SIZED的</td></tr></tbody></table><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>为什么我们需要了解这个类，有的时候甚至要实现这个类呢？</p><p>我们来看一个例子。</p><p>对于下面一个String，我想统计下单词数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String WORD=<span class="string">"Hello World Happy EveryDay Good good study day day up let us study Spliterator"</span>;</span><br></pre></td></tr></table></figure><p>我们需要创建一个counter来累计流中字符，以及在counter中把它们结合起来的逻辑，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCounter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> counter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> lastSpace;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WordCounter</span><span class="params">(<span class="keyword">int</span> counter, <span class="keyword">boolean</span> lastSpace)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.counter = counter;</span><br><span class="line">        <span class="keyword">this</span>.lastSpace = lastSpace;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历一个个的Character</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WordCounter <span class="title">accumulate</span><span class="params">(Character c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Character.isWhitespace(c))&#123;</span><br><span class="line">            <span class="keyword">return</span> lastSpace ? <span class="keyword">this</span> : <span class="keyword">new</span> WordCounter(counter,<span class="keyword">true</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//上一个字符是空格，而当前遍历的字符不是空格时，将单词计数器加一</span></span><br><span class="line">            <span class="keyword">return</span> lastSpace ? <span class="keyword">new</span> WordCounter(counter+<span class="number">1</span>,<span class="keyword">false</span>):<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//合并两个WordCounter，将其计数器加起来</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WordCounter <span class="title">combine</span><span class="params">(WordCounter wordCounter)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WordCounter(counter+wordCounter.counter,wordCounter.lastSpace);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCounter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候，我们在书写一个规约Character流统计单词个数就很简单了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countWords</span><span class="params">(Stream&lt;Character&gt; stream)</span></span>&#123;</span><br><span class="line">WordCounter wordCounter=stream.reduce(<span class="keyword">new</span> WordCounter(<span class="number">0</span>,<span class="keyword">true</span>),WordCounter::accumulate,WordCounter::combine);</span><br><span class="line"><span class="keyword">return</span> wordCounter.getCounter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Character&gt; stream= IntStream.range(<span class="number">0</span>,WORD.length()).mapToObj(WORD::charAt);</span><br><span class="line">System.out.println(countWords(stream));</span><br></pre></td></tr></table></figure><p>输出14。结果是正确的。</p><p>现在我们让他在并行流上进行工作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Character&gt; stream= IntStream.range(<span class="number">0</span>,WORD.length()).mapToObj(WORD::charAt).parallel();</span><br></pre></td></tr></table></figure><p>结果输出26。显然这是不正确的。一脸懵逼。</p><p>为什么会出现这种情况呢？</p><p>因为在并行流进行Spliterator分割时，把一个单词拆分成两部分了，导致结果变大。这显然不是我们想看到的。</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>我们要处理这种情况，就要指定分割原则，不要让程序把整个单词切开。</p><p>因此我们需要编写自己的Spliterator才能让上述问题在并行流下工作。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCounterSpliterator</span> <span class="keyword">implements</span> <span class="title">Spliterator</span>&lt;<span class="title">Character</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String string;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> currentChar=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WordCounterSpliterator</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.string = string;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Character&gt; action)</span> </span>&#123;</span><br><span class="line"><span class="comment">//处理当前字符</span></span><br><span class="line">action.accept(string.charAt(currentChar++));</span><br><span class="line"><span class="comment">//如果还有字符要处理，返回true</span></span><br><span class="line"><span class="keyword">return</span> currentChar&lt;string.length();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Spliterator&lt;Character&gt; <span class="title">trySplit</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> currentSize=string.length()-currentChar;</span><br><span class="line"><span class="comment">//返回null表示要处理的String已经足够小</span></span><br><span class="line"><span class="keyword">if</span>(currentSize&lt;<span class="number">10</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将试探拆分位置设定到要解析的文字中间</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> splitPos=currentSize/<span class="number">2</span>+currentChar;splitPos&lt;string.length();splitPos++)&#123;</span><br><span class="line"><span class="comment">//如果是空格就开始拆分，不是空格将拆分位置前进直到下一个空格</span></span><br><span class="line"><span class="keyword">if</span>(Character.isWhitespace(string.charAt(splitPos)))&#123;</span><br><span class="line"><span class="comment">//创建一个新的WordCounterSpliterator来解析String从开始到拆分位置的部分</span></span><br><span class="line">Spliterator&lt;Character&gt; spliterator=</span><br><span class="line"><span class="keyword">new</span> WordCounterSpliterator(string.substring(currentChar,splitPos));</span><br><span class="line"><span class="comment">//将这个WordCounterSpliterator的起始位置设为拆分位置</span></span><br><span class="line">currentChar=splitPos;</span><br><span class="line"><span class="keyword">return</span> spliterator;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">estimateSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> string.length()-currentChar;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ORDERED+SIZED+SUBSIZED+NONNULL+IMMUTABLE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>tryAdvance</strong>方法把String中当前位置的Character传给了Consumer，并让位置加一。作为参数传递的内部类Consumer，在遍历流时将要处理的Character传递给要执行的函数。如果新的指针位置小于String总长度，说明没有遍历完，返回true继续遍历。</p><p><strong>trySplit</strong>方法，首先我们设置了一个拆分下限——10个Character，实际应用中我们应尽量提高这个长度避免生成太多的任务。如果长度小于这个数，就返回空无需继续拆分。否则就把试探拆分位置放到要解析的String块中间，但不能直接使用此位置，应该看看是不是空格，如果是就拆分，如果不是，就向前找，找到空格进行拆分，避免把一个单词拆成两份。</p><p><strong>estimatedSize</strong>方法返回的是这个Spliterator解析的String的总长度和当前遍历位置的差值。</p><p><strong>characteristic</strong>方法告诉这个框架是ORDERED（String的每个Character的默认顺序），SIZED（estimatedSize方法返回值是精确的），SUBSIZED（trySplit分出来的Spliterator大小也是固定的），NONNULL（String里面的Character不可能为null），IMMUTABLE（String本身就不可变化）。</p><p>下面我们测试一下我们的WordCounterSpliterator 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Spliterator&lt;Character&gt; spliterator=<span class="keyword">new</span> WordCounterSpliterator(WORD);</span><br><span class="line">Stream&lt;Character&gt; stream= StreamSupport.stream(spliterator,<span class="keyword">true</span>);</span><br><span class="line">System.out.println(countWords(stream));</span><br></pre></td></tr></table></figure><p>可以看到输出结果为14.</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>可以看到，并行流不是所有情况都适用的，有些情况要定制自己的Spliterator才能使并行流正常工作。这个例子或许运行效率并行比不上串行，但是在大数据下，比如分析一个文本文件中的单词数量，就能明显看到并行带来的速度优势了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Spliterator 是Java8中加入的一个新接口，是“可分迭代器”（splitable iterator）的意思。它也是用来遍历数据源
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>和前同事闲聊小记</title>
    <link href="https://www.sakuratears.top/blog/%E5%92%8C%E5%89%8D%E5%90%8C%E4%BA%8B%E9%97%B2%E8%81%8A%E5%B0%8F%E8%AE%B020181027/"/>
    <id>https://www.sakuratears.top/blog/和前同事闲聊小记20181027/</id>
    <published>2018-10-27T08:02:09.000Z</published>
    <updated>2018-10-27T08:15:50.350Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是一篇技术问题讨论文章~~~</p><p>最近和前同事（朋友）聊天，帮他分析了这么一个需求，蛮有意思的，特来分享下其代码。</p><p>和他聊了很久，算是大致上听懂了他的需求，总结下他的需求：</p><p><strong>假设有若干方法（任务）(A,B,C,D,E…….)，对于每个方法（任务），同一时间只能有一个用户（线程）访问，现一些用户需要执行若干任务（如用户1执行（ABC），用户2执行（BEF），用户3执行（ACEF）….），对每个用户，用户的任务不要求执行顺序，如何尽可能的提高程序运行的效率。</strong></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>其实这之中比较重要的一点是每个方法同一时间只允许一个用户访问，我们如果给每个方法加上synchronized关键字呢？我从这方面入手没有想到太好的方法。我用了一种方法，就是从队列入手，对每个方法，可以设置一个等待队列，如果有任务正在执行该方法，则将其他的访问该方法的线程挂起，当然，对于每个用户，应该开多个线程去异步执行各个方法。</p><p>于是我想到了定长线程池，允许一个线程执行，其他线程进入后会放到等待队列中。对于方法，每有一个方法（任务），就创建一个定长线程池。应当在初始化时就将数据设置好。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>以下是我的一些实现代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoTask</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,ExecutorService&gt; poolMap=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//获取指定class的public方法</span></span><br><span class="line">        Method[] methods=ThingsMethod.class.getDeclaredMethods();</span><br><span class="line">        <span class="comment">//有多少个方法就创建多少个线程池,一个方法指定一个定长线程池</span></span><br><span class="line">        <span class="keyword">for</span>(Method method:methods)&#123;</span><br><span class="line">            ExecutorService pool= Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">            poolMap.put(method.getName(),pool);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//list里面假设是要执行的任务，变化的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTask</span><span class="params">(List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(String taskStr:list)&#123;</span><br><span class="line">            <span class="keyword">final</span> String id=<span class="string">"Thread"</span>+Thread.currentThread().getId();</span><br><span class="line">            <span class="keyword">switch</span> (taskStr)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"A"</span>:</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        executeMethod(<span class="string">"doSomethingA"</span>,id);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> <span class="string">"B"</span>:</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        executeMethod(<span class="string">"doSomethingB"</span>,id);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"C"</span>:</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        executeMethod(<span class="string">"doSomethingC"</span>,id);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"D"</span>:</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        executeMethod(<span class="string">"doSomethingD"</span>,id);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeMethod</span><span class="params">(String methodName,String id)</span></span>&#123;</span><br><span class="line">        poolMap.get(methodName).execute(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Method method=ThingsMethod.class.getMethod(methodName,String.class);</span><br><span class="line">                method.invoke(ThingsMethod.class.newInstance(),id);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThingsMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doSomethingA</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span>+id+<span class="string">"做A事情开始-----&gt;"</span>);</span><br><span class="line">        <span class="comment">//假设做A事情花费1s</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span>+id+<span class="string">"做A事情结束-----&gt;"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doSomethingB</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span>+id+<span class="string">"做B事情开始-----&gt;"</span>);</span><br><span class="line">        <span class="comment">//假设做B事情花费3s</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span>+id+<span class="string">"做B事情结束-----&gt;"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doSomethingC</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span>+id+<span class="string">"做C事情开始-----&gt;"</span>);</span><br><span class="line">        <span class="comment">//假设做C事情花费2s</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span>+id+<span class="string">"做C事情结束-----&gt;"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doSomethingD</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span>+id+<span class="string">"做D事情开始-----&gt;"</span>);</span><br><span class="line">        <span class="comment">//假设做D事情花费5s</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span>+id+<span class="string">"做D事情结束-----&gt;"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写测试类对其进行测试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//随机假设我们的任务是这样的</span></span><br><span class="line">        List&lt;String&gt; s=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        String [] strings=<span class="keyword">new</span> String[]&#123;<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>,<span class="string">"D"</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> l=(<span class="keyword">int</span>)Math.ceil(Math.random()*strings.length);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)&#123;</span><br><span class="line">            s.add(strings[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取结果</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.print(<span class="string">"Thread"</span>+Thread.currentThread().getId()+<span class="string">"随机生成的任务--》"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            System.out.print(s.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        DoTask doTask=<span class="keyword">new</span> DoTask();</span><br><span class="line">        doTask.doTask(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyTest test = <span class="keyword">new</span> MyTest();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(test);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(test);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(test);</span><br><span class="line">        Thread t4 = <span class="keyword">new</span> Thread(test);</span><br><span class="line">        Thread t5 = <span class="keyword">new</span> Thread(test);</span><br><span class="line">        Thread t6 = <span class="keyword">new</span> Thread(test);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line">        t5.start();</span><br><span class="line">        t6.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Thread11随机生成的任务--》A</span><br><span class="line"></span><br><span class="line">Thread13随机生成的任务--》A</span><br><span class="line"></span><br><span class="line">Thread15随机生成的任务--》AB</span><br><span class="line"></span><br><span class="line">Thread14随机生成的任务--》ABCD</span><br><span class="line"></span><br><span class="line">Thread12随机生成的任务--》ABCD</span><br><span class="line"></span><br><span class="line">Thread16随机生成的任务--》A</span><br><span class="line">线程Thread16做A事情开始-----&gt;</span><br><span class="line">线程Thread14做C事情开始-----&gt;</span><br><span class="line">线程Thread12做B事情开始-----&gt;</span><br><span class="line">线程Thread12做D事情开始-----&gt;</span><br><span class="line">线程Thread16做A事情结束-----&gt;</span><br><span class="line">线程Thread13做A事情开始-----&gt;</span><br><span class="line">线程Thread14做C事情结束-----&gt;</span><br><span class="line">线程Thread12做C事情开始-----&gt;</span><br><span class="line">线程Thread13做A事情结束-----&gt;</span><br><span class="line">线程Thread12做A事情开始-----&gt;</span><br><span class="line">线程Thread12做B事情结束-----&gt;</span><br><span class="line">线程Thread14做B事情开始-----&gt;</span><br><span class="line">线程Thread12做A事情结束-----&gt;</span><br><span class="line">线程Thread14做A事情开始-----&gt;</span><br><span class="line">线程Thread12做C事情结束-----&gt;</span><br><span class="line">线程Thread14做A事情结束-----&gt;</span><br><span class="line">线程Thread11做A事情开始-----&gt;</span><br><span class="line">线程Thread12做D事情结束-----&gt;</span><br><span class="line">线程Thread14做D事情开始-----&gt;</span><br><span class="line">线程Thread11做A事情结束-----&gt;</span><br><span class="line">线程Thread15做A事情开始-----&gt;</span><br><span class="line">线程Thread14做B事情结束-----&gt;</span><br><span class="line">线程Thread15做B事情开始-----&gt;</span><br><span class="line">线程Thread15做A事情结束-----&gt;</span><br><span class="line">线程Thread15做B事情结束-----&gt;</span><br><span class="line">线程Thread14做D事情结束-----&gt;</span><br></pre></td></tr></table></figure><p>可以看到运行结果是正确的。</p><h1 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h1><p>我还想到一种就是对各个方法（任务）添加synchronized关键字，这些方法对用户共享，这样每当有用户请求时，开线程池执行各个方法。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoTask</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThingsMethod method=<span class="keyword">new</span> ThingsMethod();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTask</span><span class="params">(List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(String taskStr:list)&#123;</span><br><span class="line">ExecutorService executor= Executors.newCachedThreadPool();            </span><br><span class="line">                executor.execute(()-&gt;&#123;                </span><br><span class="line"><span class="keyword">final</span> String id=<span class="string">"Thread"</span>+Thread.currentThread().getId();</span><br><span class="line">doSomething(taskStr,id,method);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(String taskStr,String id,ThingsMethod method)</span></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (taskStr)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"A"</span>:</span><br><span class="line">method.doSomethingA(id);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"B"</span>:</span><br><span class="line">method.doSomethingA(id);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"C"</span>:</span><br><span class="line">method.doSomethingA(id);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"D"</span>:</span><br><span class="line">method.doSomethingA(id);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThingsMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">doSomethingA</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span>+id+<span class="string">"做A事情开始-----&gt;"</span>);</span><br><span class="line">        <span class="comment">//假设做A事情花费1s</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span>+id+<span class="string">"做A事情结束-----&gt;"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">doSomethingB</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span>+id+<span class="string">"做B事情开始-----&gt;"</span>);</span><br><span class="line">        <span class="comment">//假设做B事情花费3s</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span>+id+<span class="string">"做B事情结束-----&gt;"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">doSomethingC</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span>+id+<span class="string">"做C事情开始-----&gt;"</span>);</span><br><span class="line">        <span class="comment">//假设做C事情花费2s</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span>+id+<span class="string">"做C事情结束-----&gt;"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">doSomethingD</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span>+id+<span class="string">"做D事情开始-----&gt;"</span>);</span><br><span class="line">        <span class="comment">//假设做D事情花费5s</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"线程"</span>+id+<span class="string">"做D事情结束-----&gt;"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于在主线程上开启了多线程，所以这种方法观看日志比较不方便。这种方法的正确性也还没来得及验证。</p><p>如果大家有什么好的其他想法也可以讨论交流。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这是一篇技术问题讨论文章~~~&lt;/p&gt;
&lt;p&gt;最近和前同事（朋友）聊天，帮他分析了这么一个需求，蛮有意思的，特来分享下其代码。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java8 Stream API简介</title>
    <link href="https://www.sakuratears.top/blog/Java8-Stream-API%E7%AE%80%E4%BB%8B20181027/"/>
    <id>https://www.sakuratears.top/blog/Java8-Stream-API简介20181027/</id>
    <published>2018-10-27T07:28:00.000Z</published>
    <updated>2018-10-27T07:58:39.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天来简单讲下Java8新增的Stream API。</p><p>Stream是Java8新增的对于集合框架操作的一个类，我们也称之为流操作。使用Stream，可以简化很多重复代码，使用并行流时有时还能提高程序运行效率。我们来看下。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>要把一个集合，List、Set或其他集合类转换为一个流，需要调用stream方法（转换为串行流）或者parallelStream方法（转换为并行流）。</p><p>Stream的常用方法如下表格介绍：</p><table><thead><tr><th>常用方法</th><th>说明</th><th>参数</th><th>举例</th></tr></thead><tbody><tr><td>filter(Predicate&lt;? super T&gt; predicate)</td><td>过滤，返回一个匹配给定布尔表达式的数据流</td><td>一个返回值为boolean的lambda表达式</td><td>例1</td></tr><tr><td>map(Function&lt;? super T, ? extends R&gt; mapper)</td><td>匹配，对流的每个元素都应用给定的函数以获得新流</td><td>任一符合条件的lambda表达式</td><td>例2</td></tr><tr><td>mapToInt(ToIntFunction&lt;? super T&gt; mapper)</td><td>将流数据转换为IntStream流</td><td>流元素转为int的lambda表达式</td><td>例3</td></tr><tr><td>mapToLong(ToLongFunction&lt;? super T&gt; mapper)</td><td>将流数据转换为LongStream流</td><td>流元素转为long的lambda表达式</td><td>略</td></tr><tr><td>mapToDouble(ToDoubleFunction&lt;? super T&gt; mapper)</td><td>将流数据转换为DoubleStream流</td><td>流元素转为Double的lambda表达式</td><td>略</td></tr><tr><td>flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt; mapper)</td><td>返回一个对流的每个元素都应用给定的函数的新流。这个入参lambda包含有过滤流，此方法类似于平常的双重循环</td><td>一个包含过滤流的lambda表达式</td><td>例4</td></tr><tr><td>flatMapToInt(Function&lt;? super T, ? extends IntStream&gt; mapper)</td><td>参考mapToInt</td><td>参考mapToInt</td><td>略</td></tr><tr><td>flatMapToLong(Function&lt;? super T, ? extends LongStream&gt; mapper)</td><td>参考mapToLong</td><td>参考mapToLong</td><td>略</td></tr><tr><td>flatMapToDouble(Function&lt;? super T, ? extends DoubleStream&gt; mapper)</td><td>参考mapToDouble</td><td>参考mapToDouble</td><td>略</td></tr><tr><td>distinct()</td><td>去除流中的重复元素</td><td>无参数</td><td>例5</td></tr><tr><td>sorted()</td><td>对流中元素进行排序，使用自然顺序。</td><td>无参数</td><td>例6</td></tr><tr><td>sorted(Comparator&lt;? super T&gt; comparator)</td><td>对流中的元素进行排序，按照指定的规则</td><td>流中元素的比较规则</td><td>例7</td></tr><tr><td>peek(Consumer&lt;? super T&gt; action)</td><td>截断流后进行某些操作</td><td>指定的操作，无返回值lambda</td><td>例8</td></tr><tr><td>limit(long maxSize)</td><td>获取流中的前n个元素的流</td><td>限定值</td><td>例9</td></tr><tr><td>skip(long n)</td><td>获取从n开始后面元素的流，不包括n，如果n超出流长度，返回一个空流</td><td>起始长度</td><td>例10</td></tr><tr><td>forEach(Consumer&lt;? super T&gt; action)</td><td>循环流中的每个元素，执行指定的lambda表达式</td><td>无返回值的lambda表达式</td><td>例11</td></tr><tr><td>forEachOrdered(Consumer&lt;? super T&gt; action)</td><td>按照默认顺序循环流中的元素，执行指定的lambda表达式</td><td>无返回值的lambda表达式</td><td>略</td></tr><tr><td>toArray()</td><td>返回流中元素组成的数组</td><td>无参数</td><td>例12</td></tr><tr><td>toArray(IntFunction&lt;A[]&gt; generator)</td><td>将流中元素转换为指定类型的数组，数组类型必须是流元素的本身或者超类</td><td>略</td><td>略</td></tr><tr><td>reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</td><td>归约，将流中的元素按照指定表达式归并。</td><td>起始值（默认值），指定归约公式</td><td>例13</td></tr><tr><td>reduce(BinaryOperator&lt;T&gt; accumulator)</td><td>同上，不同的是这个没有设置起始值，故结果可能为空，返回的是Optional对象</td><td>指定的归约公式</td><td>略</td></tr><tr><td>reduce(U identity,BiFunction&lt;U,? super T,U&gt; accumulator,BinaryOperator&lt;U&gt; combiner)</td><td>归约全参方法，可以指定初始值，归约方法，归约方式</td><td>略</td><td>例14</td></tr><tr><td>collect(Collector&lt;? super T, A, R&gt; collector)</td><td>收集器，比较常用的是toList，将流元素变为集合</td><td>略</td><td>略</td></tr><tr><td>collect(Supplier&lt;R&gt; supplier,BiConsumer&lt;R, ? super T&gt; accumulator,BiConsumer&lt;R, R&gt; combiner)</td><td>收集器，可以指定收集规则，收集方法等</td><td>略</td><td>略</td></tr><tr><td>min(Comparator&lt;? super T&gt; comparator)</td><td>根据指定规则获取流中最小值</td><td>排序规则lambda表达式</td><td>例15</td></tr><tr><td>max(Comparator&lt;? super T&gt; comparator)</td><td>根据指定规则获取流中最大值</td><td>排序规则lambda表达式</td><td>例15</td></tr><tr><td>count()</td><td>统计流中元素数量</td><td>无参数</td><td>例16</td></tr><tr><td>anyMatch(Predicate&lt;? super T&gt; predicate)</td><td>查找流中是否有元素符合条件，一旦查到，就返回true</td><td>条件的lambda表达式</td><td>例17</td></tr><tr><td>allMatch(Predicate&lt;? super T&gt; predicate)</td><td>查找流中的元素是否全部匹配指定表达式，全部符合才返回true</td><td>条件的lambda表达式</td><td>例18</td></tr><tr><td>noneMatch(Predicate&lt;? super T&gt; predicate)</td><td>查找流中的元素是否全部不匹配指定表达式，全部不匹配才返回true</td><td>条件的lambda表达式</td><td>略</td></tr><tr><td>findFirst()</td><td>查找流的第一个元素，如果流为空，返回空（Optional的空）</td><td>无参数</td><td>略</td></tr><tr><td>findAny()</td><td>随便从流中拿一个元素，如果流为空，返回空（Optional的空）</td><td>无参数</td><td>略</td></tr><tr><td>empty()</td><td>静态方法，返回一个空流</td><td>略</td><td>例19</td></tr><tr><td>of(T t)</td><td>静态方法，生成一个元素的流</td><td>略</td><td>例19</td></tr><tr><td>of(T… values)</td><td>静态方法，生成若干元素的流</td><td>略</td><td>例19</td></tr><tr><td>iterate(final T seed, final UnaryOperator&lt;T&gt; f)</td><td>静态方法，生成一个有规律的流</td><td>起始值，指定的lambda表达式</td><td>例19</td></tr><tr><td>generate(Supplier&lt;T&gt; s)</td><td>静态方法，生成指定规则的数据流，流数据的生成完全取决于lambda表达式</td><td>生成流数据的lambda表达式</td><td>例19</td></tr><tr><td>concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</td><td>静态方法，将两个数据流合并，两个流的类型须一致</td><td>两个数据流</td><td>例19</td></tr></tbody></table><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>举例：假设有一个1-100的List集合list1,50-150的List集合list2.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例1：需要一个1-100的偶数List集合。</span></span><br><span class="line">list1.stream().filter(n-&gt;n%<span class="number">2</span>==<span class="number">0</span>).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//例2：获取list1各元素加上100，再取基数的List集合。</span></span><br><span class="line">list1.stream().map(n-&gt;n+<span class="number">100</span>).map(n-&gt;n%<span class="number">2</span>!=<span class="number">0</span>).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//例3：将list1的流转换为IntStream。</span></span><br><span class="line">list1.stream().mapToInt(n-&gt;n.intValue());</span><br><span class="line"><span class="comment">//例4：list1和list2的交集集合。</span></span><br><span class="line">list1.stream().flatMap(i-&gt;list2.stream().map(j-&gt;i==j)).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//例5：list1和list2的并集集合。</span></span><br><span class="line">list1.addAll(list2);</span><br><span class="line">list1.stream().distinct();</span><br><span class="line"><span class="comment">//例6：对list1进行排序。</span></span><br><span class="line">list1.stream().sorted().collect(Collectors.toList());</span><br><span class="line"><span class="comment">//例7：对list1进行倒序排序。</span></span><br><span class="line">list1.stream().sorted(Comparator.reverseOrder()).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//例8：截断查看流的每一步得到的流元素。</span></span><br><span class="line">list1.stream().map(n-&gt;n+<span class="number">100</span>).peek(System.out::println).map(n-&gt;n%<span class="number">2</span>!=<span class="number">0</span>).peek(System.out::println).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//例9：取list1的前10个元素。</span></span><br><span class="line">list1.stream().limit(<span class="number">10</span>).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//例10：取list1的后10个元素。</span></span><br><span class="line">list1.stream().skip(list1.size()-<span class="number">10</span>).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//例11：输出list1的各个元素。</span></span><br><span class="line">list1.stream().forEach(System.out::println);</span><br><span class="line"><span class="comment">//例12：将list1元素转为数组。</span></span><br><span class="line">list1.stream().toArray();</span><br><span class="line"><span class="comment">//例13：对list1元素求和，对list2元素求差。</span></span><br><span class="line">list1.stream().reduce(<span class="number">0</span>,(a,b)-&gt;a+b);</span><br><span class="line">list2.stream().reduce(<span class="number">0</span>,(a,b)-&gt;a-b);</span><br><span class="line"><span class="comment">//例14：对list1按照最大值到最小值求和。</span></span><br><span class="line">list1.stream().reduce(<span class="number">0</span>,(a,b)-&gt;a+b, BinaryOperator.maxBy(Comparator.naturalOrder()));</span><br><span class="line"><span class="comment">//例15：取list1的最大最小值</span></span><br><span class="line">list1.stream().max(Comparator.naturalOrder());</span><br><span class="line">list1.stream().min(Comparator.naturalOrder());</span><br><span class="line"><span class="comment">//例16：求list1的元素个数</span></span><br><span class="line">list1.stream().count();</span><br><span class="line"><span class="comment">//例17：查询list1中有没有17的倍数（除了17）。</span></span><br><span class="line">list1.stream().anyMatch(n-&gt;n!=<span class="number">17</span>&amp;&amp;n%<span class="number">17</span>==<span class="number">0</span>);</span><br><span class="line"><span class="comment">//例18：查询list1中所有元素是不是都是2的倍数。</span></span><br><span class="line">list1.stream().allMatch(n-&gt;n%<span class="number">2</span>==<span class="number">0</span>);</span><br><span class="line"><span class="comment">//例19：</span></span><br><span class="line">Stream.empty();<span class="comment">//空流</span></span><br><span class="line">Stream.of(<span class="number">1</span>);<span class="comment">//生成一个元素的流</span></span><br><span class="line">Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);<span class="comment">//生成若干元素的流</span></span><br><span class="line">Stream.iterate(<span class="number">1</span>,n-&gt;<span class="number">2</span>*n);<span class="comment">//生成指定规则的数据流</span></span><br><span class="line">Stream.generate(()-&gt;Math.random());<span class="comment">//生成指定规则的数据流</span></span><br><span class="line">Stream.concat(list1.stream(),list2.stream());<span class="comment">//将两个数据流合并</span></span><br></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>Java8 Stream API的一些常用方法基本如上，Stream API为操作集合类提供了更方便快捷的方式，值得我们掌握。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天来简单讲下Java8新增的Stream API。&lt;/p&gt;
&lt;p&gt;Stream是Java8新增的对于集合框架操作的一个类，我们也称之为流操
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>你该相信什么</title>
    <link href="https://www.sakuratears.top/blog/%E4%BD%A0%E8%AF%A5%E7%9B%B8%E4%BF%A1%E4%BB%80%E4%B9%8820181027/"/>
    <id>https://www.sakuratears.top/blog/你该相信什么20181027/</id>
    <published>2018-10-27T07:25:00.000Z</published>
    <updated>2018-11-11T14:13:23.131Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/show3.jpg" alt="upload successful"><br><a id="more"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>写这篇文章，或是怀念过去的自己，或是憧憬自己未来。可是啊，无论如何，要活好当下。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>工作总的来说差不多四年了，或许已从职场菜鸟变化为职场老手了。</p><p>可是，岁月的变迁确无法掩饰我这颗浮躁的心，哎，想想自己，确实很浮躁啊。</p><p>曾经，想静心，于是开始练字，练了很长一段时间，可是后面确不知不觉的放弃了，至今剩下的字帖和钢笔仍静静地躺在我的桌子上。</p><p>后来，心血来潮搭建了属于自己的博客，然后创建了微信公众号，平时写些文章来总结自己和工作，我希望自己可以坚持下去，也相信自己可以坚持下去。</p><p>世上大多数人是平凡的，可是，要有一颗不甘平凡的心。</p><p>最怕一生碌碌无为，还安慰平凡难能可贵。</p><p>任何事都不应成为懒惰的借口。</p><p>不诉困苦于环境，不寄期望于运气，不服挫折于命运。</p><p>还记得那个年少的自己吗？或许他变了，可是他还在，他一直陪着你。</p><p>相信自己。做自己的英雄。</p><p>努力吧，骚年！</p><p>加油！</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>好了，喝饱鸡汤了。</p><p>努力去“搬砖”吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/show3.jpg&quot; alt=&quot;upload successful&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="https://www.sakuratears.top/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="思维" scheme="https://www.sakuratears.top/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Java8 接口</title>
    <link href="https://www.sakuratears.top/blog/Java8-%E6%8E%A5%E5%8F%A320181014/"/>
    <id>https://www.sakuratears.top/blog/Java8-接口20181014/</id>
    <published>2018-10-14T03:35:00.000Z</published>
    <updated>2018-10-14T03:56:00.987Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java 8已经推出相当长一段时间了，其中，接口部分有一些变化。我们来研究下它。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>我们知道，对于一个接口，如果我们声明好后，如果再想对其增加新的方法是困难的，因为我们要改变所有其实现类，也就是每个实现类都要对其新方法进行实现。如下图：</p><p><img src="/images/pasted-82.png" alt="upload successful"></p><p>这显然是不现实的，如果我们直接把方法写在实现类里，接口中没有此方法，就破坏了我们的多态性。</p><p>对于某些已经发布的应用，无论哪种做法都是比较繁重且不被推荐的。</p><h1 id="接口默认实现"><a href="#接口默认实现" class="headerlink" title="接口默认实现"></a>接口默认实现</h1><p>还好，Java大神们已经意识到了这个问题，于是在Java8中，引入了对接口的<strong>默认方法</strong>实现。</p><p>什么是默认方法实现呢？</p><p>简单来说，就是允许接口定义默认方法，在接口中需要有方法体的具体实现，实现类默认继承该方法（如果不重写默认方法的话）。同时为区分默认方法，默认方法在接口中采用default关键字标明。如下图：</p><p><img src="/images/pasted-83.png" alt="upload successful"></p><p>这样，如果我们新增一个接口方法（对于已经发布的接口），可以使用默认实现，就不会出现我们上述的问题。</p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>你一定会说，这和抽象类有什么区别呢？</p><p>当然还是有区别的，Java8以后，接口和抽象类的几点总结如下：</p><p><img src="/images/pasted-84.png" alt="upload successful"></p><h1 id="新的问题"><a href="#新的问题" class="headerlink" title="新的问题"></a>新的问题</h1><p>接口引入了默认方法后，就会有新的问题，好在Java已经替我们解决了，我们来看下。</p><h2 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Interface A"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Interface B"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span>, <span class="title">B</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> C().doSomething();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：输出 Interface B</p><h2 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">A</span>, <span class="title">B</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> C().doSomething();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：输出 Interface B</p><h2 id="情况三"><a href="#情况三" class="headerlink" title="情况三"></a>情况三</h2><p>如果D是这样呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Class D"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：输出Class D</p><p>如果D不对doSomething提供实现（D为抽象的类），则C需要为doSomething提供实现。</p><h2 id="情况四"><a href="#情况四" class="headerlink" title="情况四"></a>情况四</h2><p>如果B接口不在继承A接口。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Interface A"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Interface B"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们C类必须为doSomething提供实现，当然我们可以具体制定使用哪个接口的doSomething方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span>, <span class="title">B</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">B.<span class="keyword">super</span>.doSomething();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="情况五"><a href="#情况五" class="headerlink" title="情况五"></a>情况五</h2><p>如果两个函数不一样但差距很小呢？如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">long</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span>, <span class="title">B</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> C().doSomething();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在IDEA里我们可以看到，类C是无法编译的，这是不被允许的。</p><h2 id="情况六"><a href="#情况六" class="headerlink" title="情况六"></a>情况六</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Interface A"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">B</span>,<span class="title">C</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> D().doSomething();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果Interface A</p><p>因为只有A声明了一个默认方法，这个接口是D的父接口，故输出Interface A。如果B也提供了一个默认方法，签名和A一致，那么编译器会选择B的默认方法，如果B添加一个相同签名的抽象方法，则D需要为其提供实现，如果B,C都有相同签名的默认方法doSomething，则会出现冲突，需要我们为doSomething提供实现或者指定使用B，C中的哪个方法。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>解决问题的三条规则：</p><p>如果一个类使用相同的函数签名从多个地方（比如另一个类或者接口）继承了方法，通过三条规则可进行判断。</p><ol><li><p><strong>类中的方法优先级最高。类或者父类中声明的方法优先级高于任何声明为默认方法的优先级。</strong></p></li><li><p><strong>如果无法依据第一条判断，那么子接口的优先级更高：函数签名相同时，优先选择拥有最具体实现的默认方法的接口，及如果B继承了A，那么B就比A更加具体。</strong></p></li><li><p><strong>最后，如果还是无法判断，继承了多个接口的类必须通过显式覆盖和调用期望的方法，显式地选择使用哪一个默认方法的实现。</strong></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Java 8已经推出相当长一段时间了，其中，接口部分有一些变化。我们来研究下它。&lt;/p&gt;
&lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot;
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Callable原理分析</title>
    <link href="https://www.sakuratears.top/blog/Callable%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%9020181014/"/>
    <id>https://www.sakuratears.top/blog/Callable原理分析20181014/</id>
    <published>2018-10-14T03:21:00.000Z</published>
    <updated>2018-10-14T03:34:37.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天我们来分析实现多线程的一种方式，实现Callable接口。这种方式有种特殊的地方，就是可以拿到线程返回值。具体怎么实现的呢？我们来研究下。</p><h1 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h1><p>我们先举个简单的栗子来看下Callable接口吧。<br>要首先明白，线程池提交实现Callable接口的线程后会返回一个Future对象，这个对象里包含程序的运行结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException,TimeoutException</span>&#123;</span><br><span class="line">        <span class="comment">//创建一个线程池</span></span><br><span class="line">        ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">        Future&lt;String&gt; future = executor.submit(()-&gt; &#123;</span><br><span class="line">                <span class="comment">//System.out.println("CallableTest");</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"CallableTest"</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们可以通过future.get()拿到结果”CallableTest”。<br>我们也可以设置指定时间后拿到结果，如指定6s后拿到结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(future.get(<span class="number">4</span>,TimeUnit.SECONDS));</span><br></pre></td></tr></table></figure><p>可以看到也拿到了返回结果，如果我们设置4s拿到结果，小于程序运行时间5s，可以看到它抛出了超时异常。java.util.concurrent.TimeoutException。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>是不是很神奇？</p><p>我们来研究下Callable接口获取返回值的原理。</p><p>我们先来看看ExecutorService的submit方法，它接受一个Callable对象，返回一个Future对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br></pre></td></tr></table></figure><p>及它的实现。AbstractExecutorService的submit方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(callable);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br></pre></td></tr></table></figure><p>ThreadPoolExecutor的execute是对其实现。</p><p><img src="/images/pasted-80.png" alt="upload successful"></p><p>可以看到创建了一个FutureTask对象并执行。</p><p>FutureTask对象实现了Runable接口，我们来看下它。</p><p><img src="/images/pasted-81.png" alt="upload successful"></p><p>看一下它的run方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                     <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            <span class="keyword">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//拿到结果设置ran为true</span></span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="comment">//异常设置结果为空ran为false并设置异常</span></span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">                ran = <span class="keyword">false</span>;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//ran为true时放入结果</span></span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">        <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">        runner = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">        <span class="comment">// leaked interrupts</span></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="comment">//会一直挂起知道处理业务的线程完成，唤醒等待线程</span></span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们调用get方法时，他先查询线程状态，如果未完成，就调用awaitDone方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">     <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     <span class="comment">//如果设置了超时时间就获取截止时间</span></span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">     WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">     /循环监视线程的状态</span><br><span class="line">     <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">         <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">             removeWaiter(q);</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">int</span> s = state;</span><br><span class="line">         <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">             <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                 q.thread = <span class="keyword">null</span>;</span><br><span class="line">             <span class="keyword">return</span> s;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet</span></span><br><span class="line">             Thread.yield();</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</span><br><span class="line">             q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">             queued = UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,</span><br><span class="line">                                                  q.next = waiters, q);</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">             nanos = deadline - System.nanoTime();</span><br><span class="line">             <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                 removeWaiter(q);</span><br><span class="line">                 <span class="keyword">return</span> state;</span><br><span class="line">             &#125;</span><br><span class="line">             LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>带有超时时间的get，到达时间后，会判断线程状态，如果未完成，抛出超时异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING &amp;&amp;</span><br><span class="line">        (s = awaitDone(<span class="keyword">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>因此，带有返回值得异步线程基本上可以这样理解。</p><p>由于有返回值，如果未设置等待时间，会等线程执行完成后返回，基本类似同步。其原理是线程运行后，如果未完成，会放入等待队列。直到线程状态变化（完成或者异常等）。如果设置了等待时间，则到时间后无论线程状态是否完成都会返回线程状态。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天我们来分析实现多线程的一种方式，实现Callable接口。这种方式有种特殊的地方，就是可以拿到线程返回值。具体怎么实现的呢？我们来研究下
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>一道Java试题引发的思考</title>
    <link href="https://www.sakuratears.top/blog/%E4%B8%80%E9%81%93Java%E8%AF%95%E9%A2%98%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%8320181013/"/>
    <id>https://www.sakuratears.top/blog/一道Java试题引发的思考20181013/</id>
    <published>2018-10-13T15:47:00.000Z</published>
    <updated>2018-10-13T16:09:33.701Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>无意中看到了自己入门Java时的一本Java基础书，看到了其中一个小结的习题，颇为简单。<br>求一个数组所有数据的和。</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>那时入门Java，看到以前自己在书上写下的for循环。大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">sum</span><span class="params">(<span class="keyword">int</span> [] numbers)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> result=<span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.length;i++)&#123;</span><br><span class="line">        result+=numbers[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现已入行Java颇有时日，遂想到当n逐渐变大时，其执行效率会逐渐降低的。</p><p>近日对多线程有些许研究，故想到可以将数据平均分为2份，3份或者多份，每份进行和值，最后相加得到结果。也是一个不错的想法。</p><p>好在Java里有这么一个框架，名字叫<strong>分支/合并框架</strong>。我们来配合例子研究下。</p><h1 id="分支-合并框架"><a href="#分支-合并框架" class="headerlink" title="分支/合并框架"></a>分支/合并框架</h1><p><strong>分支/合并框架的目的是以递归的方式将可以并行的任务分为更小的任务，然后将每个子任务的结果合并起来生成整体的结果。它是ExecutorService接口的一个实现，它把子任务分配给线程池（ForkJoinPool）中的工作线程</strong>。那我们如何来定义任务和子任务呢？</p><p>要把任务提交到ForkJoinPool，必须创建<strong>RecursiveTask&lt; R &gt;的一个子类</strong>，其中R是并行化任务产生的结果类型。它其中有唯一一个抽象方法<strong>compute</strong>，用来定义将任务拆分成子任务的逻辑，以及无法再拆分或不方便拆分时，生成单个子任务结果的逻辑。</p><p>伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(任务足够小或者不可分)&#123;</span><br><span class="line">    顺序执行该任务</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">将任务分为两个子任务</span><br><span class="line">递归调用本方法，拆分每个子任务，等待所有子任务完成</span><br><span class="line">合并每个子任务结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那如何定义一个任务是否可以在拆分呢？</p><p>一般来说没有明确的标准决定一个任务是否可以在拆分，但是有几种试探方法可以帮助我们做出决定，分支/合并框架采用了一种称为<strong>工作窃取</strong>的技术来解决这个问题。每个线程的子任务都保存在一个双向链式队列里，每完成一个任务，就从队列头部获取一个任务，<strong>如果有线程先执行完成，它不会“闲”下来，而是去未完成的队列尾部“窃取”一个任务进行完成</strong>，直至所有子任务完成返回结果。</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>我们用分支/合并框架对数组数据进行并行求和。</p><p>代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinSumCalculator</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//要求和的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] numbers;</span><br><span class="line">    <span class="comment">//子任务处理的数组的起始位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="comment">//子任务处理的数组的终止位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不再将任务划分的子任务数组大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> THRESHOLD=<span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinSumCalculator</span><span class="params">(<span class="keyword">int</span>[] numbers)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(numbers,<span class="number">0</span>,numbers.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ForkJoinSumCalculator</span><span class="params">(<span class="keyword">int</span>[] numbers,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.numbers=numbers;</span><br><span class="line">        <span class="keyword">this</span>.start=start;</span><br><span class="line">        <span class="keyword">this</span>.end=end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length=end-start;</span><br><span class="line">        <span class="comment">//小于等于阈值，计算结果</span></span><br><span class="line">        <span class="keyword">if</span>(length&lt;=THRESHOLD)&#123;</span><br><span class="line">            <span class="keyword">return</span> computeSequentially();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建一个子任务来为数组的前一半求和</span></span><br><span class="line">        ForkJoinSumCalculator leftTask=<span class="keyword">new</span> ForkJoinSumCalculator(numbers,start,start+length/<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//利用另一个ForkJoinPool线程异步执行新创建的子任务</span></span><br><span class="line">        leftTask.fork();</span><br><span class="line">        <span class="comment">//创建一个任务为数组的后一半求和</span></span><br><span class="line">        ForkJoinSumCalculator rightTask=<span class="keyword">new</span> ForkJoinSumCalculator(numbers,start+length/<span class="number">2</span>,end);</span><br><span class="line">        <span class="comment">//同步执行第二个子任务，有可能允许进一步递归划分</span></span><br><span class="line">        Long rightResult=rightTask.compute();</span><br><span class="line">        <span class="comment">//读取第一个子任务的结果，没有完成就等待</span></span><br><span class="line">        Long leftResult=leftTask.join();</span><br><span class="line">        <span class="comment">//合并结果</span></span><br><span class="line">        <span class="keyword">return</span> rightResult+leftResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子任务数组求和</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">computeSequentially</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;end;i++)&#123;</span><br><span class="line">            sum+=numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们在编写一个方法并行对数组求和就很简单了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">forkJoinSum</span><span class="params">(<span class="keyword">int</span> [] numbers)</span></span>&#123;</span><br><span class="line">    ForkJoinTask&lt;Long&gt; task=<span class="keyword">new</span> ForkJoinSumCalculator(numbers);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool().invoke(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以写一个测试方法，测试这两种方法的执行效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//构建一个数组</span></span><br><span class="line">     <span class="keyword">int</span> [] numbers=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100000000</span>];</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.length;i++)&#123;</span><br><span class="line">         numbers[i]=(<span class="keyword">int</span>)(Math.random() * Integer.MAX_VALUE);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//分支/合并框架计算执行速度</span></span><br><span class="line">     <span class="keyword">long</span> fastest=Long.MAX_VALUE;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">         <span class="keyword">long</span> start=System.nanoTime();</span><br><span class="line">         forkJoinSum(numbers);</span><br><span class="line">         <span class="keyword">long</span> duration=(System.nanoTime()-start);</span><br><span class="line">         <span class="keyword">if</span>(duration&lt;fastest)&#123;</span><br><span class="line">             fastest=duration;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println(<span class="string">"分支/合并最快执行速度为"</span>+fastest+<span class="string">"ns"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="comment">//普通方法计算执行速度</span></span><br><span class="line">     <span class="keyword">long</span> fastest1=Long.MAX_VALUE;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">         <span class="keyword">long</span> start=System.nanoTime();</span><br><span class="line">         sum(numbers);</span><br><span class="line">         <span class="keyword">long</span> duration=(System.nanoTime()-start);</span><br><span class="line">         <span class="keyword">if</span>(duration&lt;fastest1)&#123;</span><br><span class="line">             fastest1=duration;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println(<span class="string">"普通算法最快执行速度为"</span>+fastest1+<span class="string">"ns"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">分支/合并最快执行速度为<span class="number">25894038</span>ns</span><br><span class="line">普通算法最快执行速度为<span class="number">38811709</span>ns</span><br></pre></td></tr></table></figure><p>可以看到速度是有明显提升的。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="源数据问题"><a href="#源数据问题" class="headerlink" title="源数据问题"></a>源数据问题</h2><p><strong>这个计算的数组之所以随机，是因为我之前测试了1-n的和计算，发现for循环居然比分支/合并框架快！！我加大了n值也是如此，所以对于这种比较特殊的计算，Java虚拟机或者编译器对它们的计算做了优化，因此用这些数据测试时，可能得不到我们想要的结果，这也是并发处理比较难的地方。有的时候我们多线程处理的代码可能还没有单线程快，或者快是快了，但结果错了。</strong></p><h2 id="拥抱Java8"><a href="#拥抱Java8" class="headerlink" title="拥抱Java8"></a>拥抱Java8</h2><p>看到上面我们为了求个和冒着出错的风险写了一个sum类，是不是心里退却了？不过啊，Java 8已经给我们提供了类似的功能啦。</p><p>它就是全新的Stream API，这个我们有时间在介绍。先看看Stream API对于这个是如何求和的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arrays.stream(numbers).sum();</span><br><span class="line">Arrays.stream(numbers).parallel().sum();</span><br></pre></td></tr></table></figure><p>是不是很简单？？</p><p>第一个为串行求和，即单线程，第二个为并行求和。</p><p>我们来测试下他们的效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Stream API 串行方法计算执行速度</span></span><br><span class="line">        <span class="keyword">long</span> fastest2=Long.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">long</span> start=System.nanoTime();</span><br><span class="line">            <span class="comment">//sum(numbers);</span></span><br><span class="line">            Arrays.stream(numbers).sum();</span><br><span class="line">            <span class="keyword">long</span> duration=(System.nanoTime()-start);</span><br><span class="line">            <span class="keyword">if</span>(duration&lt;fastest2)&#123;</span><br><span class="line">                fastest2=duration;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Stream API 串行 最快执行速度为"</span>+fastest2+<span class="string">"ns"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Stream API 并行方法计算执行速度</span></span><br><span class="line">        <span class="keyword">long</span> fastest3=Long.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">long</span> start=System.nanoTime();</span><br><span class="line">            <span class="comment">//sum(numbers);</span></span><br><span class="line">            Arrays.stream(numbers).parallel().sum();</span><br><span class="line">            <span class="keyword">long</span> duration=(System.nanoTime()-start);</span><br><span class="line">            <span class="keyword">if</span>(duration&lt;fastest3)&#123;</span><br><span class="line">                fastest3=duration;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Stream API 并行 最快执行速度为"</span>+fastest3+<span class="string">"ns"</span>);</span><br></pre></td></tr></table></figure><p>输出如下结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">分支/合并最快执行速度为<span class="number">25316712</span>ns</span><br><span class="line">普通算法最快执行速度为<span class="number">38812671</span>ns</span><br><span class="line">Stream API 串行 最快执行速度为<span class="number">36572646</span>ns</span><br><span class="line">Stream API 并行 最快执行速度为<span class="number">24291637</span>ns</span><br></pre></td></tr></table></figure><p>可以看到，并行情况下时间与刚才写的分支/合并框架相近。</p><p>其实：<strong>并行流背后使用的基础框架就是分支/合并框架。</strong></p><p>这只是最简单的求和例子，遇到实际问题，可能使用Stream流比普通实现简单快速，因此，Stream是值得我们学习的。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>学习就是不断思考不断进步的过程，有的时候看看自己之前写的代码，应该少一些“我去，写的什么玩意，原来？”之类的抱怨，多一些深入的思考及优化。</p><p>相关代码均已上传Github ： <a href="https://github.com/JavaZWT/framework-base" target="_blank" rel="noopener">https://github.com/JavaZWT/framework-base</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;无意中看到了自己入门Java时的一本Java基础书，看到了其中一个小结的习题，颇为简单。&lt;br&gt;求一个数组所有数据的和。&lt;/p&gt;
&lt;h1 i
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Spring Transactional注解</title>
    <link href="https://www.sakuratears.top/blog/Spring-Transactional%E6%B3%A8%E8%A7%A320181013/"/>
    <id>https://www.sakuratears.top/blog/Spring-Transactional注解20181013/</id>
    <published>2018-10-13T15:16:00.000Z</published>
    <updated>2018-10-13T15:45:49.549Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用@Transactional 注解有一段时间了，今天来对它进行下总结。</p><p>再说这个之前先说下事务。</p><p><strong>事务的基本要素（ACID）</strong></p><ol><li><p><strong>原子性（Atomicity）：</strong>事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。</p></li><li><p><strong>一致性（Consistency）：</strong>事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。</p></li><li><p><strong>隔离性（Isolation）：</strong>同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。</p></li><li><p><strong>持久性（Durability）：</strong>事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。</p></li></ol><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>Transactional注解的主要参数如下：</p><p><img src="/images/pasted-71.png" alt="upload successful"></p><p>下面来简单介绍下它的参数：</p><p><strong>value：一般用来配置指定的事务管理器。</strong></p><p><strong>propagation：事务的传播属性，有七种。见枚举Propagation，默认REQUIRED。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//支持当前事务，如果不存在就创建一个</span></span><br><span class="line">REQUIRED(TransactionDefinition.PROPAGATION_REQUIRED),</span><br><span class="line"><span class="comment">//支持当前事务，如果不存在就以非事务的方式运行</span></span><br><span class="line">SUPPORTS(TransactionDefinition.PROPAGATION_SUPPORTS),</span><br><span class="line"><span class="comment">//支持当前事务，不存在就抛出异常</span></span><br><span class="line">MANDATORY(TransactionDefinition.PROPAGATION_MANDATORY),</span><br><span class="line"><span class="comment">//创建一个新事务，如果当前有事务就暂停当前事务</span></span><br><span class="line">REQUIRES_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW),</span><br><span class="line"><span class="comment">//以非事务方式运行，如果当前有事务就暂停当前事务</span></span><br><span class="line">NOT_SUPPORTED(TransactionDefinition.PROPAGATION_NOT_SUPPORTED),</span><br><span class="line"><span class="comment">//以非事务的方式运行，如果当前有事务就抛出异常</span></span><br><span class="line">NEVER(TransactionDefinition.PROPAGATION_NEVER),</span><br><span class="line"><span class="comment">//如果当前有事务，就加入当前事务。</span></span><br><span class="line">NESTED(TransactionDefinition.PROPAGATION_NESTED);</span><br></pre></td></tr></table></figure><p><strong>isolation：隔离级别。事务的隔离级别有4种。我们看一下Isolation枚举类。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用默认的隔离级别，取决于底层数据库的默认隔离级别</span></span><br><span class="line">DEFAULT(TransactionDefinition.ISOLATION_DEFAULT),</span><br><span class="line"><span class="comment">//读未提交，这种隔离级别最低，会出现脏读，不可重复读，虚读（幻读）等情况。一般不用。</span></span><br><span class="line">READ_UNCOMMITTED(TransactionDefinition.ISOLATION_READ_UNCOMMITTED),</span><br><span class="line"><span class="comment">//读已提交，这种隔离级别可以防止脏读的产生，但是无法避免不可重复读和虚读（幻读）的出现。</span></span><br><span class="line">READ_COMMITTED(TransactionDefinition.ISOLATION_READ_COMMITTED),</span><br><span class="line"><span class="comment">//可重复读，这种隔离级别可以防止脏读、不可重复读的出现，但是无法避免虚读（幻读）的产生。</span></span><br><span class="line">REPEATABLE_READ(TransactionDefinition.ISOLATION_REPEATABLE_READ),</span><br><span class="line"><span class="comment">//串行化，这种隔离级别最高，可以避免脏读、不可重复读和虚读（幻读）的产生。</span></span><br><span class="line">SERIALIZABLE(TransactionDefinition.ISOLATION_SERIALIZABLE);</span><br></pre></td></tr></table></figure><p><strong>隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。</strong></p><p><strong>Mysql默认隔离级别为可重复读。</strong></p><p><strong>关于事务的并发问题</strong></p><ol><li><p><strong>脏读：</strong>事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</p></li><li><p><strong>不可重复读：</strong>事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。</p></li><li><p><strong>幻读：</strong>系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</p></li></ol><p>小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。</p><p><strong>timeout : 事务的超时时间，默认为-1，即事务直到完成都不会超时。</strong></p><p><strong>readOnly：是否只读，一般用来标识。拥有这个标识，写入操作不一定会失败，取决于数据库系统。</strong></p><p><strong>rollbackFor：事务回滚条件。参数为继承Throwable的class类。</strong></p><p><strong>rollbackForClassName：事务回滚条件。可以接受String数组。</strong></p><p><strong>noRollbackFor： 事务不会回滚条件。</strong></p><p><strong>noRollbackForClassName：事务不会回滚条件。</strong></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>Spring的Transaction注解是如何实现并生效的呢？我们来探究下。</p><ol><li><p>我们首先来看看SpringTransactionAnnotationParser这个类，这个是解析transaction注解的类。<br><img src="/images/pasted-72.png" alt="upload successful"><br>调用AnnotationUtils类的getAnnotation方法拿到注解信息。<br><img src="/images/pasted-73.png" alt="upload successful"></p></li><li><p>可以看到AnnotationTransactionAttributeSource这个类调用了parseTransactionAnnotation方法。<br><img src="/images/pasted-74.png" alt="upload successful"><br><img src="/images/pasted-75.png" alt="upload successful"></p></li><li><p>我们来看下AbstractFallbackTransactionAttributeSource这个类的computeTransactionAttribute方法。调用了上图的findTransactionAttribute方法。<br><img src="/images/pasted-76.png" alt="upload successful"><br><img src="/images/pasted-77.png" alt="upload successful"><br>getTransactionAttribute方法，由于获取注解信息耗时，故spring先从缓存里获取注解事务信息，查不到在用程序获取。</p></li><li><p>TransactionAspectSupport这个类的createTransactionIfNecessary方法，调用getTransactionAttribute方法。<br><img src="/images/pasted-78.png" alt="upload successful"></p></li><li><p>我们可以看到AbstractTransactionAspect.aj文件使用了createTransactionIfNecessary方法。<br><img src="/images/pasted-79.png" alt="upload successful"><br>这个应用了aspectj。<br>Before指在事务开始之前获取注解信息。<br>After throwing 指当方法抛出异常后的执行动作。这里一般会进行回滚操作。<br>After returning指当方法返回前的执行动作。这里一般会提交事务。<br>After 指当事务完成后的动作。这里会清空当前事务注解信息。</p></li></ol><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>事务的隔离级别和传播属性都是我们应该掌握和学习的，对于Spring的@Transactional 注解，我们不但要会使用，而且应该深入去理解它的实现原理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;使用@Transactional 注解有一段时间了，今天来对它进行下总结。&lt;/p&gt;
&lt;p&gt;再说这个之前先说下事务。&lt;/p&gt;
&lt;p&gt;&lt;stro
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>一道面试题引发的思考（递归）</title>
    <link href="https://www.sakuratears.top/blog/%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%8320181003/"/>
    <id>https://www.sakuratears.top/blog/一道面试题引发的思考20181003/</id>
    <published>2018-10-03T00:43:00.000Z</published>
    <updated>2018-10-03T03:31:00.830Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>某日，去某互联网公司面试，被问到了如下一道面试题：</p><p><strong>题目很简单，有一队人，已知第一个人8岁，后一个人比前一个人大两岁，以此类推，问第8个人多少岁？第N个人多少岁。</strong></p><p>我拿过笔和纸，不假思索的写下了如下答案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getAge(n-<span class="number">1</span>)+<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>面试官又问我还有什么需要注意的吗？我说要注意参数不能小于1.</p><p>显然，面试官不是很满意，又问我如果N很大会怎么样？</p><p>我想了想，说，会出现OOM异常吧，或者超了int的范围。</p><p>感觉他还是不满意。</p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>自那过去一段时间，我自认为答得没有问题，也答到了点上（只可惜面试没过~O(∩_∩)O哈哈~）。</p><p>最近又想到了这个问题，决定研究研究。</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>我用自己的方法，进行了数据测试。当然我把为了测试效果明显，我加大了测试值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">System.out.println(getAge(<span class="number">1000000</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果使我惊讶，不是OOM异常，而是堆栈异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.StackOverflowError</span><br></pre></td></tr></table></figure><p>后面我了解到，递归调用，可以假想成一个函数调用另一个函数，而每个函数相当于占用一个栈帧，这些栈帧以先进后出的方式排列起来形成栈。如下图：</p><p><img src="/images/pasted-68.png" alt="upload successful"></p><p>这样，函数会追寻到栈顶，拿到getAge(1)的值后逐渐返回。如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getAge(<span class="number">1</span>)=<span class="number">8</span></span><br><span class="line">getAge(<span class="number">2</span>)=getAge(<span class="number">1</span>)+<span class="number">2</span>=<span class="number">10</span></span><br><span class="line">getAge(<span class="number">3</span>)=getAge(<span class="number">2</span>)+<span class="number">2</span>=<span class="number">12</span></span><br><span class="line">getAge(<span class="number">4</span>)=getAge(<span class="number">3</span>)+<span class="number">2</span>=<span class="number">14</span></span><br></pre></td></tr></table></figure><p>可以知道，如果堆栈深度不够的话，就会出现异常。</p><p>我们上图所示的异常就是这个原因。</p><h1 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h1><h2 id="改进一"><a href="#改进一" class="headerlink" title="改进一"></a>改进一</h2><p>在研究这个问题时，我发现了一种递归，尾递归。</p><p>如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getAge1</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> result)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getAge1(n-<span class="number">1</span>,result+<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种递归我们可以看到，带了一个参数result，当他运行到n==1时，直接返回了result，不用在一层层回退进行计算。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  getAge(<span class="number">4</span>,<span class="number">8</span>)</span><br><span class="line">= getAge(<span class="number">3</span>,<span class="number">8</span>+<span class="number">2</span>)</span><br><span class="line">= getAge(<span class="number">2</span>,<span class="number">8</span>+<span class="number">2</span>+<span class="number">2</span>)</span><br><span class="line">= getAge(<span class="number">1</span>,<span class="number">8</span>+<span class="number">2</span>+<span class="number">2</span>+<span class="number">2</span>)</span><br><span class="line">= <span class="number">14</span></span><br></pre></td></tr></table></figure><p>一些编译器发现这些函数可以在一个栈帧里进行完成，就会复用栈帧，优化代码。</p><p>可惜的是，到目前为止，JAVA在HotSpot（Oracle的JVM）上使用时，并不支持尾递归优化。<br>据说IBM的JVM支持尾递归优化，有兴趣的童鞋可以试下。</p><p>所以这种方案的测试结果肯定也是StackOverflowError啦。</p><h2 id="改进二"><a href="#改进二" class="headerlink" title="改进二"></a>改进二</h2><p>循环解决:</p><p>那时脑子笨，现在想想，这道题用循环也是可以解决的，且不用担心堆栈溢出问题。如下：</p><p>While循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getAge2</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> result,<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        result+=step;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>For循环:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getAge3</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> firstValue,<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;end;i++)&#123;</span><br><span class="line">        firstValue+=step;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> firstValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>且速度也提高了不少。</p><h2 id="改进三"><a href="#改进三" class="headerlink" title="改进三"></a>改进三</h2><p>这么有规律的数据，当然乘法就可以解决，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getAge4</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> firstValue,<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> firstValue+(end-start)*step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上例子没有对入参做校验处理，结合实际场景，其实需要处理的，在此略掉了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>JDK源码中很少有递归，因为递归不能被优化，当数据过大时，很容易出现堆栈溢出，我们也应该慎用，基本能有递归解决的问题也可以用循环解决。</p><p>可以看出，对于一个问题，实现的方案可能不止一种。</p><p>看到自己想了及总结了多种方法，感觉很诧异，面试时却只想到了递归一种，而且实现很不好。还是自己基础不够扎实，应该多学多看多练。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>上面都说要多学多看多练啦…..</p><p>这是我测试IBM JDK对于尾递归（getAge1方法）的结果。</p><p><img src="/images/pasted-69.png" alt="upload successful"></p><p><img src="/images/pasted-70.png" alt="upload successful"></p><p>说明IBM JDK确实对尾递归有优化，我又测试了getAge方法（普通递归），结果和Oracle JDK一样，抛出 java.lang.StackOverflowError 异常。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;某日，去某互联网公司面试，被问到了如下一道面试题：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题目很简单，有一队人，已知第一个人8岁，后一个人比前一个人
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>基于注解的通用数据验证</title>
    <link href="https://www.sakuratears.top/blog/%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E9%80%9A%E7%94%A8%E6%95%B0%E6%8D%AE%E9%AA%8C%E8%AF%8120180924/"/>
    <id>https://www.sakuratears.top/blog/基于注解的通用数据验证20180924/</id>
    <published>2018-09-24T04:31:00.000Z</published>
    <updated>2018-09-24T05:11:29.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在项目开发交互过程中，难免会遇到一些数据校验。以校验客户端发送数据的合法性，对于一些非空校验，我们也许可以使用@NonNull，@NotNull 等注解，可是对于一些常规的，如手机号，身份证等等的校验，我们就还要判断处理每个请求的参数的合法性。</p><p>但是合法性的判断是难以避免的，我们是否可以精简工作量、提高工作效率呢。</p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>我们或许应该从@NonNull @NotNull等其他注解那里受到些启发。</p><p>我们或许可以结合正则表达式及注解对某些通用数据进行验证。</p><p>注解可以设置参数，我们可以设置参数为校验规则，通过枚举列举出来，同时也应该允许用户自定义正则等校验。</p><p>我们知道，注解有三种类型</p><p>RetentionPolicy.SOURCE</p><p>RetentionPolicy.CLASS</p><p>RetentionPolicy.RUNTIME。</p><p>SOURCE主要用于编译之前，编译过程中会被丢弃如@Override注解。</p><p>CLASS主要用于编译，运行时会被丢弃。</p><p>RUNTIME在源码，编译，运行时始终会存在。</p><p>可以利用反射，拿到具有特定注解的bean，并处理。所以我们定义的注解应该是RUNTIME类型。同时声明注作用范围为FIELD及PARAMETER。</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据验证注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD,ElementType.PARAMETER&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DataValid &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否可以为空</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">nullable</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供几种常用的正则验证</span></span><br><span class="line"><span class="function">RegexType <span class="title">regexType</span><span class="params">()</span> <span class="keyword">default</span> RegexType.NONE</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义正则验证</span></span><br><span class="line"><span class="function">String <span class="title">regexExpression</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数或者字段描述</span></span><br><span class="line"><span class="function">String <span class="title">description</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义如上注解，nullable用来校验参数是否可空，默认不可以为空，false。</p><p>同时提供几种通用的正则校验，用枚举列出，如手机号码校验，身份证信息校验等等。</p><p>同时如果没有规定的正则表达式，可以让用户自定义自己的正则表达式。</p><p>另增加描述字段，用来说明这个paramer的用途。</p><h2 id="定义常用正则枚举"><a href="#定义常用正则枚举" class="headerlink" title="定义常用正则枚举"></a>定义常用正则枚举</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正则类型枚举</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RegexType &#123;</span><br><span class="line"></span><br><span class="line">NONE,</span><br><span class="line">SPECIALCHAR,</span><br><span class="line">CHINESE,</span><br><span class="line">EMAIL,</span><br><span class="line">IP, </span><br><span class="line">NUMBER,</span><br><span class="line">NUMBERORNIL,</span><br><span class="line">PHONENUMBER,</span><br><span class="line">ID;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>列出几种常用枚举。非空，特殊字符，中文，邮箱，IP，数字等等</p><h2 id="枚举规则"><a href="#枚举规则" class="headerlink" title="枚举规则"></a>枚举规则</h2><p>定义了枚举，要定义它们的具体对应的方法，以便后续调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 常用正则表达式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegexUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否是正确的IP地址</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ip</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean true,通过，false，没通过</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isIp</span><span class="params">(String ip)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == ip || <span class="string">""</span>.equals(ip))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">String regex = <span class="string">"^(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|[1-9])\\."</span></span><br><span class="line">+ <span class="string">"(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\."</span></span><br><span class="line">+ <span class="string">"(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\."</span></span><br><span class="line">+ <span class="string">"(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)$"</span>;</span><br><span class="line"><span class="keyword">return</span> ip.matches(regex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否是正确的邮箱地址</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> email</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean true,通过，false，没通过</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isEmail</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == email || <span class="string">""</span>.equals(email))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">String regex = <span class="string">"\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*"</span>;</span><br><span class="line"><span class="keyword">return</span> email.matches(regex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否含有中文，仅适合中国汉字，不包括标点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> text</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean true,通过，false，没通过</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isChinese</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == text || <span class="string">""</span>.equals(text))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">Pattern p = Pattern.compile(<span class="string">"[\u4e00-\u9fa5]"</span>);</span><br><span class="line">Matcher m = p.matcher(text);</span><br><span class="line"><span class="keyword">return</span> m.find();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否正整数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> number</span></span><br><span class="line"><span class="comment"> *            数字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean true,通过，false，没通过</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String number)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == number || <span class="string">""</span>.equals(number))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">String regex = <span class="string">"[0-9]*"</span>;</span><br><span class="line"><span class="keyword">return</span> number.matches(regex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否正整数(可以为空)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> number</span></span><br><span class="line"><span class="comment"> *            数字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean true,通过，false，没通过</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNumberOrNil</span><span class="params">(String number)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">null</span> == number) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">""</span>.equals(number.trim())) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">String regex = <span class="string">"[0-9]*"</span>;</span><br><span class="line"><span class="keyword">return</span> number.matches(regex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断几位小数(正数)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> decimal</span></span><br><span class="line"><span class="comment"> *            数字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> count</span></span><br><span class="line"><span class="comment"> *            小数位数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean true,通过，false，没通过</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isDecimal</span><span class="params">(String decimal, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == decimal || <span class="string">""</span>.equals(decimal))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">String regex = <span class="string">"^(-)?(([1-9]&#123;1&#125;\\d*)|([0]&#123;1&#125;))(\\.(\\d)&#123;"</span> + count</span><br><span class="line">+ <span class="string">"&#125;)?$"</span>;</span><br><span class="line"><span class="keyword">return</span> decimal.matches(regex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否是手机号码</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> phoneNumber</span></span><br><span class="line"><span class="comment"> *            手机号码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean true,通过，false，没通过</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPhoneNumber</span><span class="params">(String phoneNumber)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == phoneNumber || <span class="string">""</span>.equals(phoneNumber))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">String regex = <span class="string">"^1[3|4|5|6|7|8|9][0-9]\\d&#123;8&#125;$"</span>;</span><br><span class="line"><span class="keyword">return</span> phoneNumber.matches(regex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断身份证号格式正确性</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ID</span></span><br><span class="line"><span class="comment"> *        身份证号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean true,通过，false，没通过</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isID</span><span class="params">(String ID)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == ID || <span class="string">""</span>.equals(ID))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">String regex = <span class="string">"^(\\d&#123;14&#125;[0-9a-zA-Z])|(\\d&#123;17&#125;[0-9a-zA-Z])$"</span>;</span><br><span class="line"><span class="keyword">return</span> ID.matches(regex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否含有特殊字符</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> text</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean true,通过，false，没通过</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasSpecialChar</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == text || <span class="string">""</span>.equals(text))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (text.replaceAll(<span class="string">"[a-z]*[A-Z]*\\d*-*_*\\s*"</span>, <span class="string">""</span>).length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 如果不包含特殊字符</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适应CJK（中日韩）字符集，部分中日韩的字是一样的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isChinese2</span><span class="params">(String strName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span>[] ch = strName.toCharArray();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ch.length; i++) &#123;</span><br><span class="line"><span class="keyword">char</span> c = ch[i];</span><br><span class="line"><span class="keyword">if</span> (isChinese(c)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isChinese</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">Character.UnicodeBlock ub = Character.UnicodeBlock.of(c);</span><br><span class="line"><span class="keyword">if</span> (ub == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS</span><br><span class="line">|| ub == Character.UnicodeBlock.CJK_COMPATIBILITY_IDEOGRAPHS</span><br><span class="line">|| ub == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A</span><br><span class="line">|| ub == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS_EXTENSION_B</span><br><span class="line">|| ub == Character.UnicodeBlock.CJK_SYMBOLS_AND_PUNCTUATION</span><br><span class="line">|| ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS</span><br><span class="line">|| ub == Character.UnicodeBlock.GENERAL_PUNCTUATION) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现及调用"><a href="#实现及调用" class="headerlink" title="实现及调用"></a>实现及调用</h2><p>基本数据都定义及处理好了，我们应该建立注解与方法之间的关联，RUNTIME类型的注解在程序运行时也会被保留，我们可以利用反射，拿到具体注解参数信息，进行相关处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解解析Service</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidateService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*private static DataValid dataValid;*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ValidateService</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析入口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">valid</span><span class="params">(Object object)</span> <span class="keyword">throws</span>  Exception</span>&#123;</span><br><span class="line"><span class="comment">//获取object的类型</span></span><br><span class="line">Class&lt;? extends Object&gt; clazz=object.getClass();</span><br><span class="line"><span class="comment">//获取该类型声明的成员</span></span><br><span class="line">Field[] fields=clazz.getDeclaredFields();</span><br><span class="line"><span class="comment">//遍历属性</span></span><br><span class="line"><span class="keyword">for</span>(Field field:fields)&#123;</span><br><span class="line"><span class="comment">//对于private私有化的成员变量，通过setAccessible来修改器访问权限</span></span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">validate(field,object);</span><br><span class="line"><span class="comment">//重新设置会私有权限</span></span><br><span class="line">field.setAccessible(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">(Field field,Object object)</span> <span class="keyword">throws</span>  Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">String  description = <span class="keyword">null</span>;</span><br><span class="line">Object        value = <span class="keyword">null</span>;</span><br><span class="line">DataValid dataValid = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取对象的成员的注解信息</span></span><br><span class="line">dataValid=field.getAnnotation(DataValid.class);</span><br><span class="line">value=field.get(object);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dataValid==<span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">description=dataValid.description().equals(<span class="string">""</span>)?field.getName():dataValid.description();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************注解解析工作开始******************/</span></span><br><span class="line"><span class="keyword">if</span>(!dataValid.nullable() &amp;&amp; dataValid.regexType() != RegexType.NUMBERORNIL)&#123;</span><br><span class="line"><span class="keyword">if</span>(value==<span class="keyword">null</span>|| StringUtils.isBlank(value.toString()))&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception(description+<span class="string">"不能为空"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dataValid.regexType()!=RegexType.NONE)&#123;</span><br><span class="line"><span class="keyword">switch</span> (dataValid.regexType()) &#123;</span><br><span class="line"><span class="keyword">case</span> NONE:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SPECIALCHAR:</span><br><span class="line"><span class="keyword">if</span>(RegexUtils.hasSpecialChar(value.toString()))&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception(description+<span class="string">"不能含有特殊字符"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CHINESE:</span><br><span class="line"><span class="keyword">if</span>(RegexUtils.isChinese2(value.toString()))&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception(description+<span class="string">"不能含有中文字符"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> EMAIL:</span><br><span class="line"><span class="keyword">if</span>(!RegexUtils.isEmail(value.toString()))&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception(description+<span class="string">"邮箱地址格式不正确"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> IP:</span><br><span class="line"><span class="keyword">if</span>(!RegexUtils.isIp(value.toString()))&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception(description+<span class="string">"IP地址格式不正确"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> NUMBER:</span><br><span class="line"><span class="keyword">if</span>(!RegexUtils.isNumber(value.toString()))&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception(description+<span class="string">"不是数字"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> NUMBERORNIL:</span><br><span class="line"><span class="keyword">if</span>(value == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!RegexUtils.isNumberOrNil(value.toString()))&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception(description+<span class="string">"格式不正确"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> PHONENUMBER:</span><br><span class="line"><span class="keyword">if</span>(!RegexUtils.isPhoneNumber(value.toString()))&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"手机号格式不正确"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> ID:</span><br><span class="line"><span class="keyword">if</span>(!RegexUtils.isID(value.toString()))&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"身份证号格式不正确"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!dataValid.regexExpression().equals(<span class="string">""</span>))&#123;</span><br><span class="line"><span class="keyword">if</span>(value.toString().matches(dataValid.regexExpression()))&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception(description+<span class="string">"格式不正确"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*************注解解析工作结束******************/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码。</p><p>当然，到具体业务层，应该调用这个Service的valid方法去校验参数。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>可以看到，经过这样，我们可以把一些常用的校验通过这种方式封装，大大简化代码量，使业务层更注重业务。</p><p>这种也可以添加自己的通用类型，灵活性很强。</p><p>这个小小的简单工具最主要的就是利用了Java的反射机制。</p><p>以上。</p><p>今天就到这里啦，中秋节快乐～～</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在项目开发交互过程中，难免会遇到一些数据校验。以校验客户端发送数据的合法性，对于一些非空校验，我们也许可以使用@NonNull，@NotNu
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JDK里那些有趣的代码（1）</title>
    <link href="https://www.sakuratears.top/blog/JDK%E9%87%8C%E9%82%A3%E4%BA%9B%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%881%EF%BC%8920180916/"/>
    <id>https://www.sakuratears.top/blog/JDK里那些有趣的代码（1）20180916/</id>
    <published>2018-09-16T15:34:00.000Z</published>
    <updated>2018-09-16T16:19:25.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天我们来看一下JDK里一些好玩的代码。我们来分析下。</p><p>在Integer源码里，我们可以看到这样一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> [] sizeTable = &#123; <span class="number">9</span>, <span class="number">99</span>, <span class="number">999</span>, <span class="number">9999</span>, <span class="number">99999</span>, <span class="number">999999</span>, <span class="number">9999999</span>,<span class="number">99999999</span>, <span class="number">999999999</span>, Integer.MAX_VALUE &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Requires positive x</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">stringSize1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; ; i++)</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= sizeTable[i])</span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是在干啥？？？</p><p>我们仔细读下，其实就会发现他其实是计算传入的int型x的位数，要求x为正数。</p><p>嗯，不难理解。</p><p>他为什么要这么写呢？</p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>对于我们来讲，当拿到一个int型正整数，如何用程序算出它的位数呢？</p><p>一般不假思索的可能想到String的length方法计算。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">myStringSize1</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> String.valueOf(x).length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯，代码量很少。。。。。。</p><p>还有吗？</p><p>对，还可以用除法，除以10，计算位数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">myStringSize2</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> num=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">while</span>(x&gt;<span class="number">10</span>)&#123;</span><br><span class="line">        x=x/<span class="number">10</span>;</span><br><span class="line">        num++;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯。。。。不错不错～</p><p>当然能用除法解决的基本上也可以用乘法解决，int的最大位数为10位，所以可以乘以10，判断大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Requires positive x</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">stringSize2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">11</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; p)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        p = <span class="number">10</span>*p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好吧，目前我就想到了除JDK以外的这三种方法。</p><p>我们测试一下我们的代码正确性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> [] x=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">5</span>,<span class="number">10</span>,<span class="number">333</span>,<span class="number">6666</span>,<span class="number">77777</span>,<span class="number">123456</span>,<span class="number">1234567</span>,<span class="number">87654321</span>,<span class="number">999999999</span>,<span class="number">1111111111</span>,Integer.MAX_VALUE&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;x.length;i++)&#123;</span><br><span class="line">       <span class="keyword">int</span> a1=Test.stringSize1(x[i]);</span><br><span class="line">       <span class="keyword">int</span> a2=Test.stringSize2(x[i]);</span><br><span class="line">       <span class="keyword">int</span> a3=Test.myStringSize1(x[i]);</span><br><span class="line">       <span class="keyword">int</span> a4=Test.myStringSize2(x[i]);</span><br><span class="line">       System.out.println(a1+<span class="string">"---"</span>+a2+<span class="string">"---"</span>+a3+<span class="string">"---"</span>+a4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/images/pasted-65.png" alt="upload successful"></p><p>结果还是木有问题哒。</p><h1 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h1><p><strong>JDK的这种写法有什么好处呢？？？</strong></p><p>可以看到，JDK的方法把一部分数据计算变成了数据比较，相当于优化吧。</p><p>那它的执行效率怎么样呢？</p><p>我们写的方法的效率又如何呢？</p><p>我们来测试下吧！</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>我们可以制造一个随机的定长int数组，看看它们执行耗时，同时统计若干组数据，进行比较。</p><p>话不多说，直接写代码并记录到Excel里供分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>  Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;Long&gt;&gt; rowList= Lists.newArrayList();</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; titleList=Lists.newArrayList();</span><br><span class="line">        titleList.add(<span class="string">"JDK方法"</span>);</span><br><span class="line">        titleList.add(<span class="string">"乘法"</span>);</span><br><span class="line">        titleList.add(<span class="string">"String方法"</span>);</span><br><span class="line">        titleList.add(<span class="string">"除法"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>;s&lt;<span class="number">50</span>;s++)&#123;</span><br><span class="line"></span><br><span class="line">            List&lt;Long&gt; cellList=Lists.newArrayList();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> [] xArrays=<span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">10000</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;xArrays.length;i++)&#123;</span><br><span class="line">                xArrays[i]=<span class="number">1</span> + (<span class="keyword">int</span>)(Math.random()*Integer.MAX_VALUE);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//System.out.println("当前S值为"+s);</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> start1=System.nanoTime();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;xArrays.length;i++) &#123;</span><br><span class="line">                stringSize1(xArrays[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> end1=System.nanoTime();</span><br><span class="line">            <span class="keyword">long</span> time1=(end1-start1)/<span class="number">1000</span>;</span><br><span class="line">            System.out.println(<span class="string">"JDK方法耗时---》"</span>+time1+<span class="string">"ms"</span>);</span><br><span class="line">            cellList.add(time1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> start4=System.nanoTime();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;xArrays.length;i++) &#123;</span><br><span class="line">                stringSize2(xArrays[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> end4=System.nanoTime();</span><br><span class="line">            <span class="keyword">long</span> time4=(end4-start4)/<span class="number">1000</span>;</span><br><span class="line">            System.out.println(<span class="string">"乘法耗时---》"</span>+time4+<span class="string">"ms"</span>);</span><br><span class="line">            cellList.add(time4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> start2=System.nanoTime();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;xArrays.length;i++) &#123;</span><br><span class="line">                myStringSize1(xArrays[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> end2=System.nanoTime();</span><br><span class="line">            <span class="keyword">long</span> time2=(end2-start2)/<span class="number">1000</span>;</span><br><span class="line">            System.out.println(<span class="string">"String方法耗时---》"</span>+time2+<span class="string">"ms"</span>);</span><br><span class="line">            cellList.add(time2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> start3=System.nanoTime();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;xArrays.length;i++) &#123;</span><br><span class="line">                myStringSize2(xArrays[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> end3=System.nanoTime();</span><br><span class="line">            <span class="keyword">long</span> time3=(end3-start3)/<span class="number">1000</span>;</span><br><span class="line">            System.out.println(<span class="string">"除法耗时---》"</span>+time3+<span class="string">"ms"</span>);</span><br><span class="line">            cellList.add(time3);</span><br><span class="line"></span><br><span class="line">            rowList.add(cellList);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        WriteExcelUtil.writeExecl(titleList,rowList,<span class="string">"/Users/zhangwentong/Desktop/workbook.xlsx"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我记录了50组数据，每组里面每个计算位数的方法执行10000次，得到如下结果。</p><p><img src="/images/pasted-66.png" alt="upload successful"></p><p>把它绘制成折线图。</p><p><img src="/images/pasted-67.png" alt="upload successful"></p><p>可以看到，String的length方法效率是最差的。。。。</p><p>我们其实看一下String.valueOf(x).length()这个源码，就知道为什么这么慢了。</p><p>然后除法也稍微逊色一点。。。</p><p>乘法和JDK的效率都可以说不错。。。。。但JDK方法其实要好一点。。。。</p><p>而且开始创建的sizeTable是占据较少空间，但却降低了CPU的计算次数（乘法需要每次乘以十在比较计算）。</p><p>当然，因为int的位数只有10位，可以写一个sizeTable，当数据量大时，比如long，最大19位，写一个19个数的sizeTable？ 一堆9？？？</p><p>哈哈，我们可以看看Long里面的计算位数的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Requires positive x</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">stringSize</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> p = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">19</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; p)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        p = <span class="number">10</span>*p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">19</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>人家当然用的乘法啦。。。。。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>我们可以看到，我们最容易想到的String.length方法确是效率最低的。。。。</p><p>JDK源码里一些方法会被大量调用，当然要做到最好的优化啦。。。</p><p>多读些源码，深入思考，多加练习，有助于提升自己。</p><p>今天就到这儿吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天我们来看一下JDK里一些好玩的代码。我们来分析下。&lt;/p&gt;
&lt;p&gt;在Integer源码里，我们可以看到这样一段代码：&lt;/p&gt;
&lt;figu
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>（转）线上某应用的FULLGC分析</title>
    <link href="https://www.sakuratears.top/blog/%E8%BD%AC-%E7%BA%BF%E4%B8%8A%E6%9F%90%E5%BA%94%E7%94%A8%E7%9A%84FULLGC%E5%88%86%E6%9E%9020180831/"/>
    <id>https://www.sakuratears.top/blog/转-线上某应用的FULLGC分析20180831/</id>
    <published>2018-08-31T13:28:00.000Z</published>
    <updated>2018-08-31T13:35:47.260Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接：<a href="http://jm.taobao.org/2016/03/23/3782/" target="_blank" rel="noopener">http://jm.taobao.org/2016/03/23/3782/</a></p></blockquote><p>这2天，排除线上某应用启动内存变化频繁的问题时，额外发现了一个fullgc的问题，分享给大家。</p><p>过程如下：抽了台线上机器，想看下这段时间机器的gc情况，发现里面有好几个FullGc的日志：</p><pre><code>T23:23:02.009+0800: 21860.015: [Full GC 21860.015: [CMS: 2361237K-&amp;gt;1111804K(4718592K), 4.9917540 secs] 2532961K-&amp;gt;1111804K(5190464K), [CMS Perm : 17397K-&amp;gt;17240K(131072K)], 4.9918770 secs] [Times: user=4.96 sys=0.03, real=4.99 secs]</code></pre><p>JVM参数设置如下：</p><pre><code>-XX:+UseCMSInitiatingOccupancyOnly-XX:CMSInitiatingOccupancyFraction=60</code></pre><p>参数的意思是：在旧区到60％的时候，会触发一次cmsgc，应该出现如下日志：</p><pre><code>T20:10:37.803+0800: 3246087.559: [CMS-concurrent-mark-start]T20:10:38.463+0800: 3246088.220: [CMS-concurrent-mark: 0.661/0.661 secs] [Times: user=3.17 sys=0.56, real=0.66 secs]T20:10:38.463+0800: 3246088.220: [CMS-concurrent-preclean-start]T20:10:38.552+0800: 3246088.309: [CMS-concurrent-preclean: 0.069/0.089 secs] [Times: user=0.14 sys=0.04, real=0.09 secs]_&lt;/span&gt;T20:10:38.552+0800: 3246088.309: [CMS-concurrent-abortable-preclean-start]</code></pre><p>而现在日志里面都是old区到2.3G（50%）的时候，就会触发一次FullGc，而且gc日志里面没有一次正常的cmsgc，现在是什么原因在半路截胡了？</p><p>开始怀疑JVM参数是否设置生效，通过jinfo进行查看：</p><pre><code>jinfo -flag UseCMSInitiatingOccupancyOnly 20195jinfo -flag CMSInitiatingOccupancyFraction 20195</code></pre><p>一切正常。</p><p>出现Fullgc，当时我想可能的原因有以下几个情况：</p><ol><li>cmsgc失败导致（GC日志中没有相关cmsgc失败的日志）</li><li>JMAP -histo：现场（人为执行肯定不是）</li><li>大对象分配时，空间不够导致（当时还剩下50%内存，并且如果大对象分配，gc日志里面是会有如下WARN的）</li><li>内存碎片导致？（由于系统会经常分配一些大数组，这个会加剧碎片化）</li></ol><p>第四点是最可能的原因了。于是，接下来怎么验证是否是它导致的呢？加上PrintGCReason，先打印出fullgc的原因,</p><p>命令如下：</p><pre><code>/java/bin/jinfo -flag +PrintGCReason</code></pre><p>第二天，查看日志，如下：</p><pre><code>GC Cause: Heap Inspection Initiated GC T16:16:01.880+0800: 687439.886: [Full GC 687439.886: [CMS: 2362138K-&amp;gt;1180717K(4718592K), 5.6573690 secs] 2700275K-&amp;gt;1180717K(5190464K), [C MS Perm : 17531K-&amp;gt;17488K(131072K)], 5.6574950 secs] [Times: user=5.59 sys=0.06, real=5.65 secs]</code></pre><p>GC原因：堆检查启动GC，FullGc的原因是这个，看不明白，咨询过后，说这个很可能是因为JAMP -hist继：活导致的FullGc。</p><p>那如果是这样，就有可能是有脚本或者定时任务，也可能是什么其他东西，去执行了这个命令，反正据我了解的cs没有做这事。接下来就是找这个“凶手”了，这事情没做过，没啥头绪，看进程也看不出什么，想grep所有脚本，懒癌又发作了，还是先去群里咨询下有啥简单又省力的办法吧，一下搞定：</p><pre><code>[ ~]$ crontab -l */1 * * * * /home/bin/config-monitor.sh &amp;gt;&amp;gt; /home/logs/config-monitor.log 2&amp;gt;&amp;amp;1 [logs]$ cat /home/bin/config-monitor.sh |grep &quot;jmap&quot; jmaplog=&quot;/home/jmap.log&quot;; if (count == 3) { / run jmap print &quot;run jmap command : /java/bin/jmap -histo:live &quot;pid&quot; |head -n 20&quot;; system(&quot;/java/bin/jmap -histo:live &quot;pid&quot; |head -n 20&quot;)&amp;gt;jmaplog; print &quot;#######Server has recovered after running jmap######&quot;;</code></pre><p>有个定时任务跑一个叫config-monitor.sh的脚本，里面做的事情，基本就是监视内存各个区的比例，超过一定比例，就通过jamp -histo：现场触发下fullgc，防止溢出===》这个定时任务是cs以前遗留下来的，一直没发现，后续就是评估是否去掉这个定时任务，整个过程告一段落。</p><p>总结：</p><ol><li>问题可能出现的原因，要尽快动手去验证，不要只停留在思考的层面;</li><li>出现fullgc的时候，可以通过加上PrintGCReason，查看具体GC原因。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;http://jm.taobao.org/2016/03/23/3782/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://jm.taobao.org/2016/03/23/3782/&lt;/a
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>（转）为什么 String hashCode 方法选择数字31作为乘子</title>
    <link href="https://www.sakuratears.top/blog/%E4%B8%BA%E4%BB%80%E4%B9%88-String-hashCode-%E6%96%B9%E6%B3%95%E9%80%89%E6%8B%A9%E6%95%B0%E5%AD%9731%E4%BD%9C%E4%B8%BA%E4%B9%98%E5%AD%9020180829/"/>
    <id>https://www.sakuratears.top/blog/为什么-String-hashCode-方法选择数字31作为乘子20180829/</id>
    <published>2018-08-29T12:47:00.000Z</published>
    <updated>2018-08-29T13:24:10.269Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址：<a href="https://segmentfault.com/a/1190000010799123" target="_blank" rel="noopener">https://segmentfault.com/a/1190000010799123</a></p></blockquote><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>某天，我在写代码的时候，无意中点开了 String hashCode 方法。然后大致看了一下 hashCode 的实现，发现并不是很复杂。但是我从源码中发现了一个奇怪的数字，也就是本文的主角31。这个数字居然不是用常量声明的，所以没法从字面意思上推断这个数字的用途。后来带着疑问和好奇心，到网上去找资料查询一下。在看完资料后，默默的感叹了一句，原来是这样啊。那么到底是哪样呢？在接下来章节里，请大家带着好奇心和我揭开数字31的用途之谜。</p><h1 id="选择数字31的原因"><a href="#选择数字31的原因" class="headerlink" title="选择数字31的原因"></a>选择数字31的原因</h1><p>在详细说明 String hashCode 方法选择数字31的作为乘子的原因之前，我们先来看看 String hashCode 方法是怎样实现的，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码就是 String hashCode 方法的实现，是不是很简单。实际上 hashCode 方法核心的计算逻辑只有三行，也就是代码中的 for 循环。我们可以由上面的 for 循环推导出一个计算公式，hashCode 方法注释中已经给出。如下：</p><blockquote><p>s[0]<em>31^(n-1) + s<a href="https://stackoverflow.com/questions/299304/why-does-javas-hashcode-in-string-use-31-as-a-multiplier" target="_blank" rel="noopener">1</a></em>31^(n-2) + … + s[n-1]</p></blockquote><p>这里说明一下，上面的 s 数组即源码中的 val 数组，是 String 内部维护的一个 char 类型数组。这里我来简单推导一下这个公式：</p><pre><code>假设 n=3    i=0 -&gt; h = 31 * 0 + val[0]    i=1 -&gt; h = 31 * (31 * 0 + val[0]) + val[1]    i=2 -&gt; h = 31 * (31 * (31 * 0 + val[0]) + val[1]) + val[2]           h = 31*31*31*0 + 31*31*val[0] + 31*val[1] + val[2]           h = 31^(n-1)*val[0] + 31^(n-2)*val[1] + val[2]</code></pre><p>上面的公式包括公式的推导并不是本文的重点，大家了解了解即可。接下来来说说本文的重点，即选择31的理由。从网上的资料来看，一般有如下两个原因：</p><p><strong>第一</strong>、31是一个不大不小的质数，是作为 hashCode 乘子的优选质数之一。另外一些相近的质数，比如37、41、43等等，也都是不错的选择。那么为啥偏偏选中了31呢？请看第二个原因。</p><p><strong>第二</strong>、31可以被 JVM 优化，<span style="color:red"><strong>31 * i = (i &lt;&lt; 5) - i</strong></span>。</p><p>上面两个原因中，第一个需要解释一下，第二个比较简单，就不说了。下面我来解释第一个理由。一般在设计哈希算法时，会选择一个特殊的质数。至于为啥选择质数，我想应该是可以降低哈希算法的冲突率。至于原因，这个就要问数学家了，我几乎可以忽略的数学水平解释不了这个原因。上面说到，31是一个不大不小的质数，是优选乘子。那为啥同是质数的2和101（或者更大的质数）就不是优选乘子呢，分析如下。</p><p>这里先分析质数2。首先，假设 <span style="color:red"><strong>n = 6</strong></span>，然后把质数2和 n 带入上面的计算公式。并仅计算公式中次数最高的那一项，结果是<span style="color:red"><strong>2^5 = 32</strong></span>，是不是很小。所以这里可以断定，当字符串长度不是很长时，用质数2做为乘子算出的哈希值，数值不会很大。也就是说，哈希值会分布在一个较小的数值区间内，分布性不佳，最终可能会导致冲突率上升。</p><p>上面说了，质数2做为乘子会导致哈希值分布在一个较小区间内，那么如果用一个较大的大质数101会产生什么样的结果呢？根据上面的分析，我想大家应该可以猜出结果了。就是不用再担心哈希值会分布在一个小的区间内了，因为<span style="color:red"><strong>101^5 = 10,510,100,501</strong></span>。但是要注意的是，这个计算结果太大了。如果用 int 类型表示哈希值，结果会溢出，最终导致数值信息丢失。尽管数值信息丢失并不一定会导致冲突率上升，但是我们暂且先认为质数101（或者更大的质数）也不是很好的选择。最后，我们再来看看质数31的计算结果： <span style="color:red"><strong>31^5 = 28629151</strong></span>，结果值相对于<span style="color:red"><strong>32</strong></span>和<span style="color:red"><strong>10,510,100,501</strong></span>来说。是不是很nice，不大不小。</p><p>上面用了比较简陋的数学手段证明了数字31是一个不大不小的质数，是作为 hashCode 乘子的优选质数之一。接下来我会用详细的实验来验证上面的结论，不过在验证前，我们先看看 Stack Overflow 上关于这个问题的讨论，<a href="https://stackoverflow.com/questions/299304/why-does-javas-hashcode-in-string-use-31-as-a-multiplier" target="_blank" rel="noopener">Why does Java’s hashCode() in String use 31 as a multiplier?</a>。其中排名第一的答案引用了《Effective Java》中的一段话，这里也引用一下：</p><blockquote><p>The value 31 was chosen because it is an odd prime. If it were even and the multiplication overflowed, information would be lost, as multiplication by 2 is equivalent to shifting. The advantage of using a prime is less clear, but it is traditional. A nice property of 31 is that the multiplication can be replaced by a shift and a subtraction for better performance: <span style="color:red">31 * i == (i &lt;&lt; 5) - i</span>. Modern VMs do this sort of optimization automatically.</p></blockquote><p>简单翻译一下：</p><blockquote><p>选择数字31是因为它是一个奇质数，如果选择一个偶数会在乘法运算中产生溢出，导致数值信息丢失，因为乘二相当于移位运算。选择质数的优势并不是特别的明显，但这是一个传统。同时，数字31有一个很好的特性，即乘法运算可以被移位和减法运算取代，来获取更好的性能：<span style="color:red">31 * i == (i &lt;&lt; 5) - i</span>，现代的 Java 虚拟机可以自动的完成这个优化。</p></blockquote><p>排名第二的答案设这样说的：</p><blockquote><p>As Goodrich and Tamassia point out, If you take over 50,000 English words (formed as the union of the word lists provided in two variants of Unix), using the constants 31, 33, 37, 39, and 41 will produce less than 7 collisions in each case. Knowing this, it should come as no surprise that many Java implementations choose one of these constants.</p></blockquote><p>这段话也翻译一下：</p><blockquote><p>正如 Goodrich 和 Tamassia 指出的那样，如果你对超过 50,000 个英文单词（由两个不同版本的 Unix 字典合并而成）进行 hash code 运算，并使用常数 31, 33, 37, 39 和 41 作为乘子，每个常数算出的哈希值冲突数都小于7个，所以在上面几个常数中，常数 31 被 Java 实现所选用也就不足为奇了。</p></blockquote><p>上面的两个答案完美的解释了 Java 源码中选用数字 31 的原因。接下来，我将针对第二个答案就行验证，请大家继续往下看。</p><h1 id="实验及数据可视化"><a href="#实验及数据可视化" class="headerlink" title="实验及数据可视化"></a>实验及数据可视化</h1><p>本节，我将使用不同的数字作为乘子，对超过23万个英文单词进行哈希运算，并计算哈希算法的冲突率。同时，我也将针对不同乘子算出的哈希值分布情况进行可视化处理，让大家可以直观的看到数据分布情况。本次实验所使用的数据是 Unix/Linux 平台中的英文字典文件，文件路径为 /usr/share/dict/words。</p><h2 id="哈希值冲突率计算"><a href="#哈希值冲突率计算" class="headerlink" title="哈希值冲突率计算"></a>哈希值冲突率计算</h2><p>计算哈希算法冲突率并不难，比如可以一次性将所有单词的 hash code 算出，并放入 Set 中去除重复值。之后拿单词数减去 set.size() 即可得出冲突数，有了冲突数，冲突率就可以算出来了。当然，如果使用 JDK8 提供的流式计算 API，则可更方便算出，代码片段如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">hashCode</span><span class="params">(String str, Integer multiplier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        hash = multiplier * hash + str.charAt(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算 hash code 冲突率，顺便分析一下 hash code 最大值和最小值，并输出</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> multiplier</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hashs</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">calculateConflictRate</span><span class="params">(Integer multiplier, List&lt;Integer&gt; hashs)</span> </span>&#123;</span><br><span class="line">    Comparator&lt;Integer&gt; cp = (x, y) -&gt; x &gt; y ? <span class="number">1</span> : (x &lt; y ? -<span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> maxHash = hashs.stream().max(cp).get();</span><br><span class="line">    <span class="keyword">int</span> minHash = hashs.stream().min(cp).get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算冲突数及冲突率</span></span><br><span class="line">    <span class="keyword">int</span> uniqueHashNum = (<span class="keyword">int</span>) hashs.stream().distinct().count();</span><br><span class="line">    <span class="keyword">int</span> conflictNum = hashs.size() - uniqueHashNum;</span><br><span class="line">    <span class="keyword">double</span> conflictRate = (conflictNum * <span class="number">1.0</span>) / hashs.size();</span><br><span class="line"></span><br><span class="line">    System.out.println(String.format(<span class="string">"multiplier=%4d, minHash=%11d, maxHash=%10d, conflictNum=%6d, conflictRate=%.4f%%"</span>,</span><br><span class="line">                multiplier, minHash, maxHash, conflictNum, conflictRate * <span class="number">100</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/images/pasted-59.png" alt="upload successful"></p><p>从上图可以看出，使用较小的质数做为乘子时，冲突率会很高。尤其是质数2，冲突率达到了 55.14%。同时我们注意观察质数2作为乘子时，哈希值的分布情况。可以看得出来，哈希值分布并不是很广，仅仅分布在了整个哈希空间的正半轴部分，即 0 ~ 2^31-1。而负半轴 -2^31 ~ -1，则无分布。这也证明了我们上面断言，即质数2作为乘子时，对于短字符串，生成的哈希值分布性不佳。然后再来看看我们之前所说的 31、37、41 这三个不大不小的质数，表现都不错，冲突数都低于7个。而质数 101 和 199 表现的也很不错，冲突率很低，这也说明哈希值溢出并不一定会导致冲突率上升。但是这两个家伙一言不合就溢出，我们认为他们不是哈希算法的优选乘子。最后我们再来看看 32 和 36 这两个偶数的表现，结果并不好，尤其是 32，冲突率超过了了50%。尽管 36 表现的要好一点，不过和 31，37相比，冲突率还是比较高的。当然并非所有的偶数作为乘子时，冲突率都会比较高，大家有兴趣可以自己验证。</p><h2 id="哈希值分布可视化"><a href="#哈希值分布可视化" class="headerlink" title="哈希值分布可视化"></a>哈希值分布可视化</h2><p>上一节分析了不同数字作为乘子时的冲突率情况，这一节来分析一下不同数字作为乘子时，哈希值的分布情况。在详细分析之前，我先说说哈希值可视化的过程。我原本是打算将所有的哈希值用一维散点图进行可视化，但是后来找了一圈，也没找到合适的画图工具。加之后来想了想，一维散点图可能不合适做哈希值可视化，因为这里有超过23万个哈希值。也就意味着会在图上显示超过23万个散点，如果不出意外的话，这23万个散点会聚集的很密，有可能会变成一个大黑块，就失去了可视化的意义了。所以这里选择了另一种可视化效果更好的图表，也就是 excel 中的平滑曲线的二维散点图（下面简称散点曲线图）。当然这里同样没有把23万散点都显示在图表上，太多了。所以在实际绘图过程中，我将哈希空间等分成了64个子区间，并统计每个区间内的哈希值数量。最后将分区编号做为X轴，哈希值数量为Y轴，就绘制出了我想要的二维散点曲线图了。这里举个例子说明一下吧，以第0分区为例。第0分区数值区间是[-2147483648, -2080374784)，我们统计落在该数值区间内哈希值的数量，得到 <span style="color:red">&lt;分区编号, 哈希值数量&gt;</span> 数值对，这样就可以绘图了。分区代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将整个哈希空间等分成64份，统计每个空间内的哈希值数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hashs</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Integer, Integer&gt; <span class="title">partition</span><span class="params">(List&lt;Integer&gt; hashs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// step = 2^32 / 64 = 2^26</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> step = <span class="number">67108864</span>;</span><br><span class="line">    List&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Map&lt;Integer, Integer&gt; statistics = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = Integer.MIN_VALUE; i &lt;= Integer.MAX_VALUE; i += step) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> min = i;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> max = min + step;</span><br><span class="line">        <span class="keyword">int</span> num = (<span class="keyword">int</span>) hashs.parallelStream()</span><br><span class="line">                .filter(x -&gt; x &gt;= min &amp;&amp; x &lt; max).count();</span><br><span class="line"></span><br><span class="line">        statistics.put(start++, num);</span><br><span class="line">        nums.add(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了防止计算出错，这里验证一下</span></span><br><span class="line">    <span class="keyword">int</span> hashNum = nums.stream().reduce((x, y) -&gt; x + y).get();</span><br><span class="line">    <span class="keyword">assert</span> hashNum == hashs.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> statistics;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本文中的哈希值是用整形表示的，整形的数值区间是<span style="color:red"> [-2147483648, 2147483647]</span>，区间大小为 <span style="color:red">2^32</span>。所以这里可以将区间等分成64个子区间，每个自子区间大小为 <span style="color:red">2^26</span>。详细的分区对照表如下：</p><table><thead><tr><th>分区编号</th><th>分区下限</th><th>分区上限</th><th>分区编号</th><th>分区下限</th><th>分区上限</th></tr></thead><tbody><tr><td>0</td><td>-2147483648</td><td>-2080374784</td><td>32</td><td>0</td><td>67108864</td></tr><tr><td>1</td><td>-2080374784</td><td>-2013265920</td><td>33</td><td>67108864</td><td>134217728</td></tr><tr><td>2</td><td>-2013265920</td><td>-1946157056</td><td>34</td><td>134217728</td><td>201326592</td></tr><tr><td>3</td><td>-1946157056</td><td>-1879048192</td><td>35</td><td>201326592</td><td>268435456</td></tr><tr><td>4</td><td>-1879048192</td><td>-1811939328</td><td>36</td><td>268435456</td><td>335544320</td></tr><tr><td>5</td><td>-1811939328</td><td>-1744830464</td><td>37</td><td>335544320</td><td>402653184</td></tr><tr><td>6</td><td>-1744830464</td><td>-1677721600</td><td>38</td><td>402653184</td><td>469762048</td></tr><tr><td>7</td><td>-1677721600</td><td>-1610612736</td><td>39</td><td>469762048</td><td>536870912</td></tr><tr><td>8</td><td>-1610612736</td><td>-1543503872</td><td>40</td><td>536870912</td><td>603979776</td></tr><tr><td>9</td><td>-1543503872</td><td>-1476395008</td><td>41</td><td>603979776</td><td>671088640</td></tr><tr><td>10</td><td>-1476395008</td><td>-1409286144</td><td>42</td><td>671088640</td><td>738197504</td></tr><tr><td>11</td><td>-1409286144</td><td>-1342177280</td><td>43</td><td>738197504</td><td>805306368</td></tr><tr><td>12</td><td>-1342177280</td><td>-1275068416</td><td>44</td><td>805306368</td><td>872415232</td></tr><tr><td>13</td><td>-1275068416</td><td>-1207959552</td><td>45</td><td>872415232</td><td>939524096</td></tr><tr><td>14</td><td>-1207959552</td><td>-1140850688</td><td>46</td><td>939524096</td><td>1006632960</td></tr><tr><td>15</td><td>-1140850688</td><td>-1073741824</td><td>47</td><td>1006632960</td><td>1073741824</td></tr><tr><td>16</td><td>-1073741824</td><td>-1006632960</td><td>48</td><td>1073741824</td><td>1140850688</td></tr><tr><td>17</td><td>-1006632960</td><td>-939524096</td><td>49</td><td>1140850688</td><td>1207959552</td></tr><tr><td>18</td><td>-939524096</td><td>-872415232</td><td>50</td><td>1207959552</td><td>1275068416</td></tr><tr><td>19</td><td>-872415232</td><td>-805306368</td><td>51</td><td>1275068416</td><td>1342177280</td></tr><tr><td>20</td><td>-805306368</td><td>-738197504</td><td>52</td><td>1342177280</td><td>1409286144</td></tr><tr><td>21</td><td>-738197504</td><td>-671088640</td><td>53</td><td>1409286144</td><td>1476395008</td></tr><tr><td>22</td><td>-671088640</td><td>-603979776</td><td>54</td><td>1476395008</td><td>1543503872</td></tr><tr><td>23</td><td>-603979776</td><td>-536870912</td><td>55</td><td>1543503872</td><td>1610612736</td></tr><tr><td>24</td><td>-536870912</td><td>-469762048</td><td>56</td><td>1610612736</td><td>1677721600</td></tr><tr><td>25</td><td>-469762048</td><td>-402653184</td><td>57</td><td>1677721600</td><td>1744830464</td></tr><tr><td>26</td><td>-402653184</td><td>-335544320</td><td>58</td><td>1744830464</td><td>1811939328</td></tr><tr><td>27</td><td>-335544320</td><td>-268435456</td><td>59</td><td>1811939328</td><td>1879048192</td></tr><tr><td>28</td><td>-268435456</td><td>-201326592</td><td>60</td><td>1879048192</td><td>1946157056</td></tr><tr><td>29</td><td>-201326592</td><td>-134217728</td><td>61</td><td>1946157056</td><td>2013265920</td></tr><tr><td>30</td><td>-134217728</td><td>-67108864</td><td>62</td><td>2013265920</td><td>2080374784</td></tr><tr><td>31</td><td>-67108864</td><td>0</td><td>63</td><td>2080374784</td><td>2147483648</td></tr></tbody></table><p>接下来，让我们对照上面的分区表，对数字2、3、17、31、101的散点曲线图进行简单的分析。先从数字2开始，数字2对于的散点曲线图如下：</p><p><img src="/images/pasted-60.png" alt="upload successful"></p><p>上面的图还是很一幕了然的，乘子2算出的哈希值几乎全部落在第32分区，也就是 <span style="color:red">[0, 67108864)</span>数值区间内，落在其他区间内的哈希值数量几乎可以忽略不计。这也就不难解释为什么数字2作为乘子时，算出哈希值的冲突率如此之高的原因了。所以这样的哈希算法要它有何用啊，拖出去斩了吧。接下来看看数字3作为乘子时的表现：</p><p><img src="/images/pasted-61.png" alt="upload successful"></p><p>3作为乘子时，算出的哈希值分布情况和2很像，只不过稍微好了那么一点点。从图中可以看出绝大部分的哈希值最终都落在了第32分区里，哈希值的分布性很差。这个也没啥用，拖出去枪毙5分钟吧。在看看数字17的情况怎么样：</p><p><img src="/images/pasted-62.png" alt="upload successful"></p><p>数字17作为乘子时的表现，明显比上面两个数字好点了。虽然哈希值在第32分区和第34分区有一定的聚集，但是相比较上面2和3，情况明显好好了很多。除此之外，17作为乘子算出的哈希值在其他区也均有分布，且较为均匀，还算是一个不错的乘子吧。</p><p><img src="/images/pasted-63.png" alt="upload successful"></p><p>接下来来看看我们本文的主角31了，31作为乘子算出的哈希值在第33分区有一定的小聚集。不过相比于数字17，主角31的表现又好了一些。首先是哈希值的聚集程度没有17那么严重，其次哈希值在其他区分布的情况也要好于17。总之，选31，准没错啊。</p><p><img src="/images/pasted-64.png" alt="upload successful"></p><p>最后再来看看大质数101的表现，不难看出，质数101作为乘子时，算出的哈希值分布情况要好于主角31，有点喧宾夺主的意思。不过不可否认的是，质数101的作为乘子时，哈希值的分布性确实更加均匀。所以如果不在意质数101容易导致数据信息丢失问题，或许其是一个更好的选择。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>经过上面的分析与实践，我想大家应该明白了 String hashCode 方法中选择使用数字31作为乘子的原因了。</p><p>本文为转载，原文地址：<a href="https://segmentfault.com/a/1190000010799123" target="_blank" rel="noopener">https://segmentfault.com/a/1190000010799123</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;https://segmentfault.com/a/1190000010799123&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://segmentfault.com/a/1190000
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
</feed>
