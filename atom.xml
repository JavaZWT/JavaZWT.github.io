<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SakuraTears的博客</title>
  
  <subtitle>越努力越幸运</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.sakuratears.top/"/>
  <updated>2018-08-13T15:18:12.919Z</updated>
  <id>https://www.sakuratears.top/</id>
  
  <author>
    <name>SakuraTears</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>StringBuffer和StringBuilder</title>
    <link href="https://www.sakuratears.top/blog/StringBuffer%E5%92%8CStringBuilder20180813/"/>
    <id>https://www.sakuratears.top/blog/StringBuffer和StringBuilder20180813/</id>
    <published>2018-08-13T14:41:00.000Z</published>
    <updated>2018-08-13T15:18:12.919Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们知道，对于一般大量频繁的String操作，我们不建议也不应该直接用String进行相加操作，而我们应借助StringBuffer或者StringBuilder来实现。</p><p>StringBuffer是线程安全的，而StringBuilder是线程不安全的。</p><p>由此看来，StringBuilder对String的操作快，不安全，适合单线程；StringBuilder对String的操作较StringBuilder慢，安全，适合多线程和单线程。</p><p>我们今天分析一下二者的源码。</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="class定义"><a href="#class定义" class="headerlink" title="class定义"></a>class定义</h2><p>两者的class定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//StringBuffer</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuffer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractStringBuilder</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">CharSequence</span></span></span><br><span class="line"><span class="class"></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//StringBuilder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilder</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractStringBuilder</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">CharSequence</span></span></span><br><span class="line"><span class="class"></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>二者的UML图如下：</p><p><img src="/images/pasted-50.png" alt="upload successful"></p><p><img src="/images/pasted-51.png" alt="upload successful"></p><p>可以看到二者均继承AbstractStringBuilder类，且都实现了Serializable和CharSequence接口。即二者分别是AbstractStringBuilder类的安全和不安全的一种实现。</p><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p>我们先来分析下StringBuffer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(capacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(str.length() + <span class="number">16</span>);</span><br><span class="line">    append(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，当我们new StringBuffer时，如果什么也不传，默认赋予16数组长度，如果传入一个String，则长度为String.length()+16。</p><h2 id="append方法"><a href="#append方法" class="headerlink" title="append方法"></a>append方法</h2><p>在看一下append方法。关键字synchronized 对该方法进行了加锁，保证安全，toStringCache 赋值为空。然后调用AbstractStringBuilder的append方法。</p><p>StringBuffer append方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>AbstractStringBuilder里的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> appendNull();</span><br><span class="line">    <span class="keyword">int</span> len = str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">    count += len;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> AbstractStringBuilder <span class="title">appendNull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = count;</span><br><span class="line">    ensureCapacityInternal(c + <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">char</span>[] value = <span class="keyword">this</span>.value;</span><br><span class="line">    value[c++] = <span class="string">'n'</span>;</span><br><span class="line">    value[c++] = <span class="string">'u'</span>;</span><br><span class="line">    value[c++] = <span class="string">'l'</span>;</span><br><span class="line">    value[c++] = <span class="string">'l'</span>;</span><br><span class="line">    count = c;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        value = Arrays.copyOf(value,</span><br><span class="line">                newCapacity(minimumCapacity));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>String里的getChars方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getChars</span><span class="params">(<span class="keyword">int</span> srcBegin, <span class="keyword">int</span> srcEnd, <span class="keyword">char</span> dst[], <span class="keyword">int</span> dstBegin)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (srcBegin &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(srcBegin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (srcEnd &gt; value.length) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(srcEnd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (srcBegin &gt; srcEnd) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(srcEnd - srcBegin);</span><br><span class="line">    &#125;</span><br><span class="line">    System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这段代码的理解。追加一个Str时，如果是null，则调用appendNull方法，在后面直接加一个null字符串。如果不为空，拿到字符串长度，进行容量扩容为当前容量+str的长度，调用String的getChars方法，将字符串数组加在后面，这最后是个char数组。</p><p><img src="/images/pasted-52.png" alt="upload successful"></p><p>通过上图可以看到 AbstractStringBuilder是基于char数组实现的，count用于统计当前长度。</p><h2 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h2><p>我们看一下toString方法。可以发现他把字符串数组先放到了缓存数组，然后在返回一个String。当StringBuffer变化时，如append，则直接把toStringCache 赋值为空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (toStringCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">        toStringCache = Arrays.copyOfRange(value, <span class="number">0</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(toStringCache, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="insert方法"><a href="#insert方法" class="headerlink" title="insert方法"></a>insert方法</h2><p>我们再来分析一下StringBuffer的insert，由于重载方法较多，我们只分析insert String的代码。</p><p>StringBuffer insert方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset, String str)</span> </span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.insert(offset, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>AbstractStringBuilder里的insert方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset, String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((offset &lt; <span class="number">0</span>) || (offset &gt; length()))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset);</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>)</span><br><span class="line">        str = <span class="string">"null"</span>;</span><br><span class="line">    <span class="keyword">int</span> len = str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    System.arraycopy(value, offset, value, offset + len, count - offset);</span><br><span class="line">    str.getChars(value, offset);</span><br><span class="line">    count += len;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到与append大致相同，就是调用System.arraycopy的时候插入的位置发生了变化。</p><h2 id="其他方法（delete，replace等）"><a href="#其他方法（delete，replace等）" class="headerlink" title="其他方法（delete，replace等）"></a>其他方法（delete，replace等）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//StringBuffer</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">delete</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">       toStringCache = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">super</span>.delete(start, end);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//AbstractStringBuilder</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">delete</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (start &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(start);</span><br><span class="line">       <span class="keyword">if</span> (end &gt; count)</span><br><span class="line">           end = count;</span><br><span class="line">       <span class="keyword">if</span> (start &gt; end)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException();</span><br><span class="line">       <span class="keyword">int</span> len = end - start;</span><br><span class="line">       <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           System.arraycopy(value, start+len, value, start, count-end);</span><br><span class="line">           count -= len;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//StringBuffer</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">replace</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, String str)</span> </span>&#123;</span><br><span class="line">       toStringCache = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">super</span>.replace(start, end, str);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//AbstractStringBuilder</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">replace</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, String str)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (start &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(start);</span><br><span class="line">       <span class="keyword">if</span> (start &gt; count)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(<span class="string">"start &gt; length()"</span>);</span><br><span class="line">       <span class="keyword">if</span> (start &gt; end)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(<span class="string">"start &gt; end"</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (end &gt; count)</span><br><span class="line">           end = count;</span><br><span class="line">       <span class="keyword">int</span> len = str.length();</span><br><span class="line">       <span class="keyword">int</span> newCount = count + len - (end - start);</span><br><span class="line">       ensureCapacityInternal(newCount);</span><br><span class="line"></span><br><span class="line">       System.arraycopy(value, end, value, start + len, count - end);</span><br><span class="line">       str.getChars(value, start);</span><br><span class="line">       count = newCount;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可以看到他们均使用了System.arraycopy方法。这儿不再一一赘述。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>我们再看一下StringBuilder的源码。发现它与StringBuffer差别很小。</strong></p><p><strong>不同点：</strong></p><ol><li><p>增删改操作上没有synchronized关键字。</p></li><li><p>没有private transient char[] toStringCache;的定义。</p></li></ol><p>第一点正好验证了StringBuilder不是线程安全的，第二点StringBuffer中toStringCache的引入是为了在多线程并发下读取写入数据起到一定的缓存缓冲作用。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>我们可以看到，无论StringBuilder还是StringBuffer，都是AbstractStringBuilder的实现类。</p><p>AbstractStringBuilder对字符串的操作，实质是将它存储在一个char数组中，这样减小了内存开销。我们知道，如果使用String连加，会创造大量String对象，GC来不及回收，导致OOM异常或内存开销增大。StringBuffer和StringBuilder对String的操作完美的解决了这个问题，且相当于提供了操作字符串更加直观的方法（如insert，delete，append等）。这是值得我们借鉴和学习的。</p><p>以上就是StringBuffer和StringBuilder的源码分析。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我们知道，对于一般大量频繁的String操作，我们不建议也不应该直接用String进行相加操作，而我们应借助StringBuffer或者St
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Integer源码解析</title>
    <link href="https://www.sakuratears.top/blog/Integer%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%9020180811/"/>
    <id>https://www.sakuratears.top/blog/Integer源码解析20180811/</id>
    <published>2018-08-11T06:56:00.000Z</published>
    <updated>2018-08-11T07:36:07.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天我们来分析一下Integer源码。</p><p>Integer是八种包装类里面的比较常用的一种。那在使用时有什么注意及学习的地方呢？</p><p>让我们一起来看一下</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>Integer是包java.lang下的一个类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Integer</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">//code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其被定义成final类型，继承Number类实现Comparable接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Native</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>   MIN_VALUE = <span class="number">0x80000000</span>;</span><br><span class="line"><span class="meta">@Native</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>   MAX_VALUE = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;Integer&gt;  TYPE = (Class&lt;Integer&gt;) Class.getPrimitiveClass(<span class="string">"int"</span>);</span><br></pre></td></tr></table></figure><p>可以看出，其定义了Integer的最大值为2^31-1，最小值为-2^31。Integer的基本数据类型为int。</p><p>我们来看一下Integer的toString方法，是比较有趣的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == Integer.MIN_VALUE)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"-2147483648"</span>;</span><br><span class="line">    <span class="keyword">int</span> size = (i &lt; <span class="number">0</span>) ? stringSize(-i) + <span class="number">1</span> : stringSize(i);</span><br><span class="line">    <span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[size];</span><br><span class="line">    getChars(i, size, buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法中使用到了stringSize函数，就是求这个Integer数的长度，我们来看看他是如何实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> [] sizeTable = &#123; <span class="number">9</span>, <span class="number">99</span>, <span class="number">999</span>, <span class="number">9999</span>, <span class="number">99999</span>, <span class="number">999999</span>, <span class="number">9999999</span>,</span><br><span class="line">                                  <span class="number">99999999</span>, <span class="number">999999999</span>, Integer.MAX_VALUE &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Requires positive x</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">stringSize</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; ; i++)</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= sizeTable[i])</span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这段代码在计算Integer数长度时，构建了一个一维数组，然后拿x与数组每个值进行比较。而未使用我们经常说的除法或乘法计算长度。我们可以看下源码里的注释。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// I use the "invariant division by multiplication" trick to</span></span><br><span class="line"><span class="comment">// accelerate Integer.toString.  In particular we want to</span></span><br><span class="line"><span class="comment">// avoid division by 10.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The "trick" has roughly the same performance characteristics</span></span><br><span class="line"><span class="comment">// as the "classic" Integer.toString code on a non-JIT VM.</span></span><br><span class="line"><span class="comment">// The trick avoids .rem and .div calls but has a longer code</span></span><br><span class="line"><span class="comment">// path and is thus dominated by dispatch overhead.  In the</span></span><br><span class="line"><span class="comment">// JIT case the dispatch overhead doesn't exist and the</span></span><br><span class="line"><span class="comment">// "trick" is considerably faster than the classic code.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// TODO-<span class="doctag">FIXME:</span> convert (x * 52429) into the equiv shift-add</span></span><br><span class="line"><span class="comment">// sequence.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// RE:  Division by Invariant Integers using Multiplication</span></span><br><span class="line"><span class="comment">//      T Gralund, P Montgomery</span></span><br><span class="line"><span class="comment">//      ACM PLDI 1994</span></span><br></pre></td></tr></table></figure><p>我们知道计算机在计算除法效率要比加减乘法低。所以为了避免除法，提高计算效率，采用此种方法。</p><p>正好我们可以看看Long的toString方法里的stringSize方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Requires positive x</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">stringSize</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> p = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">19</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; p)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        p = <span class="number">10</span>*p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">19</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到使用了乘法。你或许会问为什么没有像Integer那样构建一个数组去比较？额，如果要构造数组，那要构造一个19位的数组，里面有1-19位的数，代码写起来很多很臃肿吧，而且构造好的数组会长期放在内存中，我们知道，在实际应用中，Integer的使用频率要比Long高多了，长期让Long里面的一个数组占据内存空间也不太合理。以上是我个人见解。</p><p>我们再来看一下parseInt方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s, <span class="keyword">int</span> radix)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> NumberFormatException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * WARNING: This method may be invoked early during VM initialization</span></span><br><span class="line"><span class="comment">     * before IntegerCache is initialized. Care must be taken to not use</span></span><br><span class="line"><span class="comment">     * the valueOf method.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NumberFormatException(<span class="string">"null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (radix &lt; Character.MIN_RADIX) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NumberFormatException(<span class="string">"radix "</span> + radix +</span><br><span class="line">                                        <span class="string">" less than Character.MIN_RADIX"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (radix &gt; Character.MAX_RADIX) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NumberFormatException(<span class="string">"radix "</span> + radix +</span><br><span class="line">                                        <span class="string">" greater than Character.MAX_RADIX"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> negative = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, len = s.length();</span><br><span class="line">    <span class="keyword">int</span> limit = -Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> multmin;</span><br><span class="line">    <span class="keyword">int</span> digit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> firstChar = s.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (firstChar &lt; <span class="string">'0'</span>) &#123; <span class="comment">// Possible leading "+" or "-"</span></span><br><span class="line">            <span class="keyword">if</span> (firstChar == <span class="string">'-'</span>) &#123;</span><br><span class="line">                negative = <span class="keyword">true</span>;</span><br><span class="line">                limit = Integer.MIN_VALUE;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstChar != <span class="string">'+'</span>)</span><br><span class="line">                <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (len == <span class="number">1</span>) <span class="comment">// Cannot have lone "+" or "-"</span></span><br><span class="line">                <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        multmin = limit / radix;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">            <span class="comment">// Accumulating negatively avoids surprises near MAX_VALUE</span></span><br><span class="line">            digit = Character.digit(s.charAt(i++),radix);</span><br><span class="line">            <span class="keyword">if</span> (digit &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (result &lt; multmin) &#123;</span><br><span class="line">                <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">            &#125;</span><br><span class="line">            result *= radix;</span><br><span class="line">            <span class="keyword">if</span> (result &lt; limit + digit) &#123;</span><br><span class="line">                <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">            &#125;</span><br><span class="line">            result -= digit;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> negative ? result : -result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到此方法首先进行异常处理，然后判断传入String是否有正负号，然后截取位数，使用乘法，用减法得到int值，然后判断正负并返回结果。</p><p>我们再来看下Integer的内部类IntegerCache。</p><p>这儿可以说是一个坑，也是比较有意思的地方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很容易理解这段代码，初始化Integer后，IntegerCache会缓存[-128,127]之间的数据，这个区间的上限可以配置，取决于java.lang.Integer.IntegerCache.high这个属性，这个属性在VM参数里为-XX:AutoBoxCacheMax=2000进行设置调整或者VM里设置-Djava.lang.Integer.IntegerCache.high=2000。所以Integer在初始化完成后会缓存[-128,max]之间的数据。</p><p>并且我们可以看到valueOf方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到valueOf方法，在cache范围内，返回的是缓存的值，是相同的对象，不在cache范围内，才会新建Integer。</p><p>由于有了Integer缓存，我们可以测试以下代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Integer a=<span class="number">1</span>;</span><br><span class="line">Integer b=<span class="number">1</span>;</span><br><span class="line">Integer c=<span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">Integer d=<span class="number">1000</span>;</span><br><span class="line">Integer e=<span class="number">1000</span>;</span><br><span class="line">System.out.println(a==b);</span><br><span class="line">System.out.println(b==c);</span><br><span class="line">System.out.println(d==e);</span><br></pre></td></tr></table></figure><p>可以看到结果为true,false,false。</p><p>这样，我们在比较Integer时，如果仅仅比较值相等，建议使用equals方法比较。</p><p>我们可以看下Integer的equals方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">        <span class="keyword">return</span> value == ((Integer)obj).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到它会先判断类型是否符合，然后进行拆箱比较操作。</p><p>同样，在Long，Byte，Short，我们也可以看到缓存，其缓存数据长度均是-128到127。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Long</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LongCache</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="title">LongCache</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> Long cache[] = <span class="keyword">new</span> Long[-(-<span class="number">128</span>) + <span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">       <span class="keyword">static</span> &#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">               cache[i] = <span class="keyword">new</span> Long(i - <span class="number">128</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//Byte</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteCache</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="title">ByteCache</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> Byte cache[] = <span class="keyword">new</span> Byte[-(-<span class="number">128</span>) + <span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">       <span class="keyword">static</span> &#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">               cache[i] = <span class="keyword">new</span> Byte((<span class="keyword">byte</span>)(i - <span class="number">128</span>));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//Short</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ShortCache</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="title">ShortCache</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> Short cache[] = <span class="keyword">new</span> Short[-(-<span class="number">128</span>) + <span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">       <span class="keyword">static</span> &#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">               cache[i] = <span class="keyword">new</span> Short((<span class="keyword">short</span>)(i - <span class="number">128</span>));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>关于缓存的意义：在该范围内数据比较常用，添加缓存提高性能。不用每次都新建，浪费系统资源。</p><p>同时根据Integer的hashCode方法，我们可以看到，Integer的hashCode返回本身的int值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.hashCode(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>以上就是Integer的源码分析，可以看到，对于偏底层的一些调用频繁的类，Java都做了很多方面的优化。包括从性能及内存开销等诸多方面。是值得我们学习和理解的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天我们来分析一下Integer源码。&lt;/p&gt;
&lt;p&gt;Integer是八种包装类里面的比较常用的一种。那在使用时有什么注意及学习的地方呢？&lt;
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 数据结构之链表</title>
    <link href="https://www.sakuratears.top/blog/Java-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A820180805/"/>
    <id>https://www.sakuratears.top/blog/Java-数据结构之链表20180805/</id>
    <published>2018-08-05T08:18:00.000Z</published>
    <updated>2018-08-06T12:41:23.329Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 </p><p>由于链表不必按照顺序存储，故在插入数据时可以达到O(1)的复杂度，但是查找的时候就需要遍历，时间复杂度为O(n)。</p><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p>链表根据实现方式一般有三种分类：单向链表、循环链表、双向链表。</p><h2 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h2><p>单向链表指的是链表中的元素的指向只能指向链表中的下一个元素或者为空，元素之间不能相互指向。也就是一种线性链表。</p><p><strong>图示：</strong></p><p><img src="/images/pasted-47.png" alt="upload successful"></p><h3 id="普通单向链表"><a href="#普通单向链表" class="headerlink" title="普通单向链表"></a>普通单向链表</h3><p>用Java代码实现一普通的单向链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;<span class="comment">//链表节点的个数</span></span><br><span class="line">    <span class="keyword">private</span> Node head;<span class="comment">//头节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SingleLinkList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        head = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//链表的每个节点类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Object data;<span class="comment">//每个节点的数据</span></span><br><span class="line">        <span class="keyword">private</span> Node next;<span class="comment">//每个节点指向下一个节点的连接</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Object data)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在链表头添加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">addHead</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        Node newHead = <span class="keyword">new</span> Node(obj);</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            head = newHead;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            newHead.next = head;</span><br><span class="line">            head = newHead;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在链表头删除元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deleteHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Object obj = head.data;</span><br><span class="line">        head = head.next;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//查找指定元素，找到了返回节点Node，找不到返回null</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">find</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        Node current = head;</span><br><span class="line">        <span class="keyword">int</span> tempSize = size;</span><br><span class="line">        <span class="keyword">while</span>(tempSize &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obj.equals(current.data))&#123;</span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            tempSize--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//删除指定的元素，删除成功返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(Object value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node current = head;</span><br><span class="line">        Node previous = head;</span><br><span class="line">        <span class="keyword">while</span>(current.data != value)&#123;</span><br><span class="line">            <span class="keyword">if</span>(current.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                previous = current;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果删除的节点是第一个节点</span></span><br><span class="line">        <span class="keyword">if</span>(current == head)&#123;</span><br><span class="line">            head = current.next;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//删除的节点不是第一个节点</span></span><br><span class="line">            previous.next = current.next;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断链表是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (size == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//显示节点信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span>(size &gt;<span class="number">0</span>)&#123;</span><br><span class="line">            Node node = head;</span><br><span class="line">            <span class="keyword">int</span> tempSize = size;</span><br><span class="line">            <span class="keyword">if</span>(tempSize == <span class="number">1</span>)&#123;<span class="comment">//当前链表只有一个节点</span></span><br><span class="line">                sb.append(<span class="string">"["</span>+node.data+<span class="string">"]"</span>);</span><br><span class="line">                <span class="keyword">return</span> sb.toString();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(tempSize&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(node.equals(head))&#123;</span><br><span class="line">                    sb.append(<span class="string">"["</span>+node.data+<span class="string">"-&gt;"</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(node.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                sb.append(node.data+<span class="string">"]"</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sb.append(node.data+<span class="string">"-&gt;"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.next;</span><br><span class="line">                tempSize--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果链表一个节点都没有，直接打印[]</span></span><br><span class="line">        sb.append(<span class="string">"[]"</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>栈具有先进后出的原则，所以单向链表可以用来实现栈。Java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackSingleLinkList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackSingleLink</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SingleLinkList link;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StackSingleLink</span><span class="params">()</span></span>&#123;</span><br><span class="line">        link = <span class="keyword">new</span> SingleLinkList();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//添加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        link.addHead(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//移除栈顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Object obj = link.deleteHead();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> link.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//打印栈内元素信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> link.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看出，如果对链表的最后一个元素进行操作，需要遍历到链表尾部，在进行操作，十分消耗资源。</p><h3 id="双端链表"><a href="#双端链表" class="headerlink" title="双端链表"></a>双端链表</h3><p>还有一种单向链表称为<strong>双端链表</strong>。这种链表有一个特点，即在链表内添加了对链表尾部的引用。这使得链表可以方便的操作尾部元素。</p><p>Java代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoublePointLinkList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node head;<span class="comment">//头节点</span></span><br><span class="line">    <span class="keyword">private</span> Node tail;<span class="comment">//尾节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;<span class="comment">//节点的个数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Object data;</span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Object data)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoublePointLinkList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        head = <span class="keyword">null</span>;</span><br><span class="line">        tail = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//链表头新增节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addHead</span><span class="params">(Object data)</span></span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(data);</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;<span class="comment">//如果链表为空，那么头节点和尾节点都是该新增节点</span></span><br><span class="line">            head = node;</span><br><span class="line">            tail = node;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            node.next = head;</span><br><span class="line">            head = node;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//链表尾新增节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTail</span><span class="params">(Object data)</span></span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(data);</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;<span class="comment">//如果链表为空，那么头节点和尾节点都是该新增节点</span></span><br><span class="line">            head = node;</span><br><span class="line">            tail = node;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            tail.next = node;</span><br><span class="line">            tail = node;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//删除头部节点，成功返回true，失败返回false</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;<span class="comment">//当前链表节点数为0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="keyword">null</span>)&#123;<span class="comment">//当前链表节点数为1</span></span><br><span class="line">            head = <span class="keyword">null</span>;</span><br><span class="line">            tail = <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (size ==<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获得链表的节点个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//显示节点信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span>(size &gt;<span class="number">0</span>)&#123;</span><br><span class="line">            Node node = head;</span><br><span class="line">            <span class="keyword">int</span> tempSize = size;</span><br><span class="line">            <span class="keyword">if</span>(tempSize == <span class="number">1</span>)&#123;<span class="comment">//当前链表只有一个节点</span></span><br><span class="line">                sb.append(<span class="string">"["</span>+node.data+<span class="string">"]"</span>);</span><br><span class="line">                <span class="keyword">return</span> sb.toString();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(tempSize&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(node.equals(head))&#123;</span><br><span class="line">                    sb.append(<span class="string">"["</span>+node.data+<span class="string">"-&gt;"</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(node.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                sb.append(node.data+<span class="string">"]"</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sb.append(node.data+<span class="string">"-&gt;"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.next;</span><br><span class="line">                tempSize--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果链表一个节点都没有，直接打印[]</span></span><br><span class="line">        sb.append(<span class="string">"[]"</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双端链表可以用来实现队列，相关实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueLinkList</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> DoublePointLinkList dp;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">QueueLinkList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        dp = <span class="keyword">new</span> DoublePointLinkList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Object data)</span></span>&#123;</span><br><span class="line">        dp.addTail(data);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>&#123;</span><br><span class="line">        dp.deleteHead();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dp.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dp.getSize();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dp.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有序链表"><a href="#有序链表" class="headerlink" title="有序链表"></a>有序链表</h3><p>上面所说的单链表数据都是无序的，我们可以构建一个有序的单向链表。即有序链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderLinkList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderLinkList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    size=<span class="number">0</span>;</span><br><span class="line">        head = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//插入节点，并按照从小打到的顺序排列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(value);</span><br><span class="line">        Node pre = <span class="keyword">null</span>;</span><br><span class="line">        Node current = head;</span><br><span class="line">        <span class="keyword">while</span>(current != <span class="keyword">null</span> &amp;&amp; value &gt; current.data)&#123;</span><br><span class="line">            pre = current;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre == <span class="keyword">null</span>)&#123;</span><br><span class="line">            head = node;</span><br><span class="line">            head.next = current;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre.next = node;</span><br><span class="line">            node.next = current;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//删除头节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">        head = head.next;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (size ==<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">    StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        Node current = head;</span><br><span class="line">        <span class="keyword">while</span>(current != <span class="keyword">null</span>)&#123;</span><br><span class="line">            sb.append(current.data+<span class="string">" "</span>);</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于有序链表，可以看出，插入或删除某一项最多需要O(n)的时间复杂度（遍历），但如果我们每次只删除最小值，且对插入没有过高要求的话，有序链表是一个不错的选择，比如优先级队列就可以利用有序链表实现。</p><p>比如我们插入int数并以最小值为优先级，每次取最小的int值的队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueOrderLinkList</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> OrderLinkList dp;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">QueueOrderLinkList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        dp = <span class="keyword">new</span> OrderLinkList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        dp.insert(data);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>&#123;</span><br><span class="line">        dp.deleteHead();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dp.getSize();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dp.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dp.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单向链表的用途可以说是十分广泛的。</p><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>双向链表即是这样一个有序的结点序列，每个链表元素既有指向下一个元素的指针，又有指向前一个元素的指针，其中每个结点都有两种指针，即left和right。left指针指向左边结点，right指针指向右边结点。所以双向链表是可以从两个方向进行遍历的。</p><p><strong>图示：</strong></p><p><img src="/images/pasted-48.png" alt="upload successful"></p><p>双向链表的Java实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleWayLinkList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node head;<span class="comment">//表示链表头</span></span><br><span class="line">    <span class="keyword">private</span> Node tail;<span class="comment">//表示链表尾</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;<span class="comment">//表示链表的节点个数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Object data;</span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line">        <span class="keyword">private</span> Node prev;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Object data)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoubleWayLinkList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        head = <span class="keyword">null</span>;</span><br><span class="line">        tail = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在链表头增加节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addHead</span><span class="params">(Object value)</span></span>&#123;</span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            head = newNode;</span><br><span class="line">            tail = newNode;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            head.prev = newNode;</span><br><span class="line">            newNode.next = head;</span><br><span class="line">            head = newNode;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在链表尾增加节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTail</span><span class="params">(Object value)</span></span>&#123;</span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            head = newNode;</span><br><span class="line">            tail = newNode;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            newNode.prev = tail;</span><br><span class="line">            tail.next = newNode;</span><br><span class="line">            tail = newNode;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//删除链表头</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">deleteHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="keyword">if</span>(size != <span class="number">0</span>)&#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            head.prev = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//删除链表尾</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">deleteTail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node temp = tail;</span><br><span class="line">        <span class="keyword">if</span>(size != <span class="number">0</span>)&#123;</span><br><span class="line">            tail = tail.prev;</span><br><span class="line">            tail.next = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获得链表的节点个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断链表是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (size == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//显示节点信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">    StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span>(size &gt;<span class="number">0</span>)&#123;</span><br><span class="line">            Node node = head;</span><br><span class="line">            <span class="keyword">int</span> tempSize = size;</span><br><span class="line">            <span class="keyword">if</span>(tempSize == <span class="number">1</span>)&#123;<span class="comment">//当前链表只有一个节点</span></span><br><span class="line">                sb.append(<span class="string">"["</span>+node.data+<span class="string">"]"</span>);</span><br><span class="line">                <span class="keyword">return</span> sb.toString();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(tempSize&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(node.equals(head))&#123;</span><br><span class="line">                sb.append(<span class="string">"["</span>+node.data+<span class="string">"-&gt;"</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(node.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                sb.append(node.data+<span class="string">"]"</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sb.append(node.data+<span class="string">"-&gt;"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.next;</span><br><span class="line">                tempSize--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果链表一个节点都没有，直接打印[]</span></span><br><span class="line">        sb.append(<span class="string">"[]"</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用双向链表可以构建双端队列。在这儿就不上代码了，和之前的队列构造类似。</p><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>循环链表指的是在单向链表和双向链表的基础上，将两种链表的最后一个结点指向第一个结点从而实现循环。</p><p><strong>图示：</strong></p><p><img src="/images/pasted-49.png" alt="upload successful"></p><p>循环链表的Java实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleLinkList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">// 链表的每个节点类</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Object data;<span class="comment">// 每个节点的数据</span></span><br><span class="line"><span class="keyword">private</span> Node&lt;T&gt; next;<span class="comment">// 每个节点指向下一个节点的连接</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.data = data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node&lt;T&gt; head, tail;</span><br><span class="line">Node&lt;T&gt; p;</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CircleLinkList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.head = <span class="keyword">null</span>;</span><br><span class="line">tail = head;</span><br><span class="line">p = head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加节点</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">Node node = <span class="keyword">new</span> Node&lt;T&gt;(data);</span><br><span class="line"><span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">head = node;</span><br><span class="line">tail = head;</span><br><span class="line">p = head;</span><br><span class="line">size++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">node.next = head;</span><br><span class="line">head = node;</span><br><span class="line">tail.next = head;</span><br><span class="line">p = head;</span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 得到数据</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">p = head;</span><br><span class="line"><span class="keyword">while</span> (i != index &amp;&amp; p != tail) &#123;</span><br><span class="line">i++;</span><br><span class="line">p = p.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (T) p.data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head != <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，使用循环链表可以实现循环队列。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>链表作为数据结构的一部分，应用是十分广泛的，我们上面说明了几种链表在不同情况下的应用，链表是我们应当学会掌握和使用的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>一款基于JQuery和bootstrap的单页面WebApp框架</title>
    <link href="https://www.sakuratears.top/blog/%E4%B8%80%E6%AC%BE%E5%9F%BA%E4%BA%8EJQuery%E5%92%8Cbootstrap%E7%9A%84%E5%8D%95%E9%A1%B5%E9%9D%A2WebApp%E6%A1%86%E6%9E%B620180730/"/>
    <id>https://www.sakuratears.top/blog/一款基于JQuery和bootstrap的单页面WebApp框架20180730/</id>
    <published>2018-07-30T08:25:00.000Z</published>
    <updated>2018-07-30T10:42:44.936Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>现在React.js，Vue.js等MVVM框架逐渐火了起来，今天，先暂时不说这些。</p><p>我在之前呆过一家公司，他们前端封装了一套基于JQuery和bootstrap的单页面WebApp框架，虽然技术栈方面可能比较落后了，且是基于CSS，Html，JavaScript分层的。与现在的模块化开发有些不同。但是它的一些封装思想是值得我们学习的。</p><p>而且这个框架，让我这个前端小白（我是后端开发）对前端JS产生了很大兴趣，特此写下这篇文章来分析和纪念这个框架。</p><p>框架主页：<a href="https://github.com/JavaZWT/JQueryApp" target="_blank" rel="noopener">https://github.com/JavaZWT/JQueryApp</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><p>这款框架也是基于Node.js搭建的，主要是用了gulp，还包含了css,html,js压缩，js校验等包。其环境启动包依赖如下图：</p><p><img src="/images/pasted-30.png" alt="upload successful"></p><p>在项目的package.json里可以看到。</p><p><strong>关于为什么引用这些插件的说明：</strong></p><ol><li>js，img，png等的压缩，可大幅度减小生成的资源包体积，在生成APK后用户当然是希望安装包要小越好。如果gulp到服务器WebRoot目录下，当用户访问项目资源时，体积小的静态资源更能减小用户流量开支，提高系统响应速度，增强用户体验。</li><li>创建一个前端webserver服务器，相当于提供了一个前端APK环境（可以这么理解），大部分bug在浏览器上就可以复现和解决，减少了打包到apk里的繁琐流程，提高开发效率。</li></ol><p>根据以上介绍，大家应该知道node_modules,gulpfile.js,package.json,package-lock.json都不会被打到前台资源包中。</p><p>package.json里的依赖，都可以通过npm install （同级目录执行）的方式安装，安装后就会生成node_modules文件夹。</p><p><strong>安装启动前端环境主要有以下三个步骤。</strong></p><ol><li><p>npm install -g gulp</p><p> 安装全局gulp，使gulp可以在任何目录下使用，和java环境变量差不多。</p></li><li><p>npm install  </p><p> 安装环境依赖，需要到有package.json的文件夹下执行。</p></li><li><p>gulp</p><p> 启动前端webserver</p></li></ol><h2 id="gulpfile-js"><a href="#gulpfile-js" class="headerlink" title="gulpfile.js"></a>gulpfile.js</h2><p>再来说下gulpfile.js</p><p>光有插件也不行啊，这个文件就是把插件们拿来用的。</p><p>关于这个js，我们简单说下配置及使用。</p><ol><li><p>参数配置envConfig</p><p> env：启动模式，有三种，DEV，DEBUG，PRO。DEV和DEBUG模式下不会压缩js和图片，节省时间，便于调试。</p><p> distPath: 生成的前端资源文件路径，有的gulpfile.js里面没有它，其他是分开的，那个可以生成发布在webapp目录下的资源文件。</p><p> <img src="/images/pasted-45.png" alt="upload successful"></p></li><li><p>webserverConfig</p><p> 服务器启动配置参数</p><p> port ：默认打开的端口号</p><p> open：默认代开的文件名</p><p> host：默认打开的地址，不配置的话默认localhost</p><p> livereload:即时刷新，主要用来检测文件变化。</p><p> <img src="/images/pasted-46.png" alt="upload successful"></p></li></ol><h2 id="项目架构图"><a href="#项目架构图" class="headerlink" title="项目架构图"></a>项目架构图</h2><p><img src="/images/pasted-31.png" alt="upload successful"></p><h2 id="架构说明："><a href="#架构说明：" class="headerlink" title="架构说明："></a>架构说明：</h2><ol><li><p>public</p><p> 前端项目文件夹。</p></li><li><p>css</p><p> 用于存放页面css样式的文件夹，理论上里面的文件都会被放入生成的前端资源包。</p></li><li><p>html</p><p> 用于放置前端页面的文件夹，理论上里面的文件都会被放入生成的前端资源包。</p></li><li><p>js</p><p> 用于放置前端js的文件夹，理论上里面的文件都会被放入生成的前端资源包。</p></li><li><p>node_modules</p><p> npm install 后生成的文件夹，是前端资源包的打包环境及在Web浏览器上查看及debug App提供支持。</p></li><li><p>resources</p><p> 用于放置前端静态资源的文件夹，如图片，字体，静态json等，理论上里面的文件都会被放入前端资源包。</p></li><li><p>gulpfile.js</p><p> 构建前端环境，生成前端资源包的主要文件。</p></li><li><p>index.html</p><p> 前端主要页面，所有资源理论上都会被按需加载进来。</p></li><li><p>package-lock.json</p><p> npm install 之后生成的文件，存放着一些npm之后的包的信息。</p></li><li><p>package.json</p><p>构建前端环境，生成前端资源包的主要文件，里面放置着构建环境及生成资源包所需的依赖。</p></li></ol><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>分析这个框架，我们先从index.html入手，单页面的操作实现主要是将目标html移到这个index.html里实现的。</p><p><img src="/images/pasted-32.png" alt="upload successful"></p><p>可以看下index.html里面的几个主要id，如上图。</p><p>index.html引入了相关js及css。</p><p><img src="/images/pasted-33.png" alt="upload successful"></p><p><img src="/images/pasted-34.png" alt="upload successful"></p><p>我们看下api.js和app.js</p><p>项目启动后会调用到此方法，详见index.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadViewport</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="keyword">var</span> path;</span><br><span class="line"> <span class="keyword">if</span>(location.hash.indexOf(<span class="string">"?"</span>)&gt;<span class="number">-1</span>)&#123;</span><br><span class="line"> path = location.hash.substr(<span class="number">0</span>,location.hash.indexOf(<span class="string">"?"</span>));</span><br><span class="line"> &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> path = location.hash;</span><br><span class="line"> &#125;</span><br><span class="line"> path = (path || <span class="string">'#'</span> + api.route.default.path).slice(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//如果没有配置路径则不做操作</span></span><br><span class="line">     <span class="keyword">if</span>(!api.route[path])&#123;</span><br><span class="line">         api.globalLoading.hide();</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">'[APP] 没有查询到路径:'</span>+ path + <span class="string">',不进行加载'</span>);</span><br><span class="line">     &#125;<span class="keyword">else</span> <span class="keyword">if</span>(api.curr.clean)&#123;</span><br><span class="line">         <span class="keyword">switch</span>(api.curr.clean.length)&#123;</span><br><span class="line">             <span class="keyword">case</span> <span class="number">0</span>:<span class="comment">//如果不包含参数 则认为这是一个同步 直接执行完成后 加载页面</span></span><br><span class="line">                 api.curr.clean();</span><br><span class="line">                 load();</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> <span class="number">1</span>:<span class="comment">//如果只接收一个参数,则传入回调函数 等待页面完成后自行处理</span></span><br><span class="line">                 api.curr.clean(load);</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> <span class="number">2</span>:<span class="comment">//如果接收两个参数 则分别是 要跳转页面的hash,回调函数</span></span><br><span class="line">                 api.curr.clean(path,load);</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">default</span>:<span class="comment">//如果接收大于2个参数 则只传入三个 分别是 要跳转页面的hash,要跳转页面的配置在route中的数据,回调函数</span></span><br><span class="line">                 api.curr.clean(path,api.route[path],load);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         load();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         api.globalLoading.show();</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">'[APP] 开始加载页面['</span>+path+<span class="string">']'</span>);</span><br><span class="line">         api.loadPath(path,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">             <span class="built_in">console</span>.log(<span class="string">'[APP] 加载页面&lt;p&gt;['</span>+path+<span class="string">']&lt;/p&gt;完成'</span>);</span><br><span class="line"></span><br><span class="line">             api.plugins.header(data,path);</span><br><span class="line"></span><br><span class="line">             <span class="comment">//如果页面没有设置 则默认隐藏全局loading</span></span><br><span class="line">             <span class="keyword">if</span>(!data || !data.selfHideLoading) api.globalLoading.hide();</span><br><span class="line">         &#125;);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> api.loadViewport = loadViewport;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 当浏览器的hash发生变化时进行页面的加载</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="built_in">window</span>.onhashchange = loadViewport;</span><br></pre></td></tr></table></figure><p><strong>其原理就是利用location.hash的？后半段，进行地址跳转，加载在route里配置的相关html及js，加载之前移除原来的html和js，以实现页面跳转。</strong></p><h1 id="方法及使用"><a href="#方法及使用" class="headerlink" title="方法及使用"></a>方法及使用</h1><h2 id="api-js"><a href="#api-js" class="headerlink" title="api.js"></a>api.js</h2><p><strong>1、route,modal</strong></p><p><img src="/images/pasted-35.png" alt="upload successful"></p><p>新增一个页面，可以添加在route里，新增一个模态框，可以添加在modal里。</p><p><strong>2、api.globalLoading</strong></p><p>全局loading，有两个方法:</p><p>api.globalLoading.show();</p><p>api.globalLoading.hide();</p><p>一般应用在ajax发送前后，当需要等待操作处理时，也可以直接调用。</p><p><img src="/images/pasted-36.png" alt="upload successful"></p><p><strong>3、api.globalShadow</strong></p><p>全局shadow，是一个z-index为2000的透明遮罩层。</p><p>有两个方法：</p><p>api.globalShadow.hide();</p><p>api.globalShadow.show();</p><p>一般调用模态框时会被加载，自己写一些插件集成在里面时可以自己控制处理下。</p><p><strong>4、api.modal.exec</strong></p><p>调用模态框时会使用此方法，由于模态框和页面不太一样，模态框关闭后再打开可以保证数据不用重新加载。</p><p><img src="/images/pasted-37.png" alt="upload successful"></p><p><strong>5、api.loadJS</strong></p><p>框架中加载js用到的方法，分为串行加载和并行加载，各有利弊。</p><p><img src="/images/pasted-38.png" alt="upload successful"></p><p><strong>6、api.loadModal</strong></p><p>modal加载方法，刚才提到的那个是这一个的进一步封装，这里面的方法显示了modal是如何被加载的，这里应注意，modal默认只会被加载一次。</p><p><img src="/images/pasted-39.png" alt="upload successful"></p><p><strong>7、api.loadPath</strong></p><p>页面跳转实现的主要方法，这个方法制定跳转path后，会在route里寻找，若没有此页面，则不会跳转。</p><p><img src="/images/pasted-40.png" alt="upload successful"></p><p><strong>8、loadViewport</strong></p><p>刚才提到了，这个可以控制页面hash路由跳转。也是页面跳转的主要方法。</p><h2 id="app-js"><a href="#app-js" class="headerlink" title="app.js"></a>app.js</h2><p><strong>1、app.alert</strong></p><p>消息提示框方法，只有一个确认键。</p><p><img src="/images/pasted-41.png" alt="upload successful"></p><p><strong>2、app.confirm</strong></p><p>消息提示框，有确认和取消两个按钮。</p><p><img src="/images/pasted-42.png" alt="upload successful"></p><p><strong>3、app.ajax</strong></p><p>基于JQuery ajax后自己封装的一套ajax，增加里请求头签名等等。</p><p><img src="/images/pasted-43.png" alt="upload successful"></p><h2 id="cordova-js"><a href="#cordova-js" class="headerlink" title="cordova.js"></a>cordova.js</h2><p>自己封装的一个cordova工具，根据设备类型不同（Android，iOS）调用不同的cordova插件。</p><h2 id="GlobalValue-js"><a href="#GlobalValue-js" class="headerlink" title="GlobalValue.js"></a>GlobalValue.js</h2><p>全局变量控制插件，通过sessionStorage存储变量。</p><p><img src="/images/pasted-44.png" alt="upload successful"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>还有很多部分没有介绍到，但框架的关键部分都介绍了，要想清楚明白，可以自己在框架上写个页面或者完善个插件来试试。加深对它的理解。</p><p>虽然在现在前端框架日新月异的今天，虚拟dom流行的今天，感觉这个框架已经过时了，但是思想永不过时，框架设计上的一些思想还是值得我们学习和借鉴的。</p><p>关于这个框架有什么问题欢迎留言，也可以直接在GitHub上提问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;现在React.js，Vue.js等MVVM框架逐渐火了起来，今天，先暂时不说这些。&lt;/p&gt;
&lt;p&gt;我在之前呆过一家公司，他们前端封装了一套
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="JavaScript" scheme="https://www.sakuratears.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Java Stack类简介</title>
    <link href="https://www.sakuratears.top/blog/Java-Stack%E7%B1%BB%E7%AE%80%E4%BB%8B20180726/"/>
    <id>https://www.sakuratears.top/blog/Java-Stack类简介20180726/</id>
    <published>2018-07-26T09:45:00.000Z</published>
    <updated>2018-07-28T16:19:43.234Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>栈（Stack）是限定只能在一段进行插入和删除操作的线性表。</p><p>进行插入和删除操作的一端称为“栈顶”（top），另一端称为“栈底”（bottom）。</p><p>栈的插入操作称为“入栈”(push)，栈的删除 操作称为“出栈”（pop）。</p><p>栈具有后进先出（LIFO），先进后出(FILO)的特性。</p><h1 id="Stack类"><a href="#Stack类" class="headerlink" title="Stack类"></a>Stack类</h1><p>Java工具包下的Stack类继承于Vector，由此可见Stack底层是由数组实现的。</p><p><strong>Stack和Collection的关系如下图：</strong></p><p><img src="/images/pasted-29.png" alt="upload successful"></p><p>我们来看下Stack的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将一个元素压入栈顶</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">push</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">        addElement(item);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取出栈顶的一个元素，并删除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        E       obj;</span><br><span class="line">        <span class="keyword">int</span>     len = size();</span><br><span class="line"></span><br><span class="line">        obj = peek();</span><br><span class="line">        removeElementAt(len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取出栈顶元素，不删除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>     len = size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        <span class="keyword">return</span> elementAt(len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断栈是不是空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找元素在栈的位置，没有返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = lastIndexOf(o);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> size() - i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1224463164541339165L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据源码，可以发现Stack的方法调用了Vector类的方法，实现了线程安全。</p><p>我们主要看一下Vector里的下面三个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加一个元素</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addElement</span><span class="params">(E obj)</span> </span>&#123;</span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="comment">//确认容量，不够会扩容</span></span><br><span class="line">       ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">       elementData[elementCount++] = obj;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//移除指定位置的元素</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">removeElementAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="keyword">if</span> (index &gt;= elementCount) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">" &gt;= "</span> +</span><br><span class="line">                                                    elementCount);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> j = elementCount - index - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index, j);</span><br><span class="line">       &#125;</span><br><span class="line">       elementCount--;</span><br><span class="line">       <span class="comment">//赋空，便于垃圾回收</span></span><br><span class="line">       elementData[elementCount] = <span class="keyword">null</span>; </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//找出在指定位置的元素</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">elementAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (index &gt;= elementCount) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">" &gt;= "</span> + elementCount);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> elementData(index);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>关联方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityHelper</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       如果长度超了就扩容</span><br><span class="line">       <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">           grow(minCapacity);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//扩容方法</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">       <span class="comment">//新的容量定义：如果有容量增量且大于0，取增量，否则执行2倍扩容</span></span><br><span class="line">       <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                        capacityIncrement : oldCapacity);</span><br><span class="line">       <span class="comment">//扩容后容量比传入容量还小，就取传入容量。</span></span><br><span class="line">       <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           newCapacity = minCapacity;</span><br><span class="line">       <span class="comment">//新容量比数组最大长度还大</span></span><br><span class="line">       <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">       <span class="comment">//计算容量</span></span><br><span class="line">           newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">       elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//计算容量</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) </span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">       <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">           Integer.MAX_VALUE :</span><br><span class="line">           MAX_ARRAY_SIZE;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>我们如何用数组实现自己的一个stack呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line"><span class="comment">//栈元素组</span></span><br><span class="line"><span class="keyword">private</span> Object[] members;</span><br><span class="line">    <span class="comment">//指针</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">//自定义初始栈长度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">(<span class="keyword">int</span> initCapacity)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(initCapacity&lt;=<span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.members=<span class="keyword">new</span> Object[initCapacity];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//默认栈长度为10</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.members=<span class="keyword">new</span> Object[<span class="number">10</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//元素入栈</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">ensureCapacity(size+<span class="number">1</span>);</span><br><span class="line">members[size++]=o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//元素出栈</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(size&lt;=<span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> members[--size];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查看栈顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">peek</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(size&lt;=<span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> members[size-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//确认容量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line"><span class="comment">//size+1比数组长度要长，扩容</span></span><br><span class="line"><span class="keyword">if</span>(minCapacity-members.length&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> oldCapacity = members.length;</span><br><span class="line">        Object oldMembers=members;</span><br><span class="line">        <span class="comment">//扩容到二倍</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = <span class="number">2</span> * oldCapacity ;</span><br><span class="line">        <span class="comment">//扩容后还不够或者超过int最大值，就直接赋值size+1</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        members=<span class="keyword">new</span> Object[newCapacity];</span><br><span class="line">        <span class="comment">//拷贝数组</span></span><br><span class="line">        System.arraycopy(oldMembers, <span class="number">0</span>, members, <span class="number">0</span>, size);</span><br><span class="line">        oldMembers=<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码就是一个简易的Stack的实现方式。</p><p>代码见： <a href="https://github.com/JavaZWT/sakuratears" target="_blank" rel="noopener">https://github.com/JavaZWT/sakuratears</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Stack类在编程过程中用到的不是很多，但是计算机栈内存机制遵循先进后出原则，学习Stack类，可以帮助我们加深对程序及数据结构的理解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;栈（Stack）是限定只能在一段进行插入和删除操作的线性表。&lt;/p&gt;
&lt;p&gt;进行插入和删除操作的一端称为“栈顶”（top），另一端称为“栈底
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java正则表达式使用</title>
    <link href="https://www.sakuratears.top/blog/Java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BD%BF%E7%94%A820180721/"/>
    <id>https://www.sakuratears.top/blog/Java正则表达式使用20180721/</id>
    <published>2018-07-21T08:52:00.000Z</published>
    <updated>2018-07-21T12:00:16.335Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>1.什么是正则表达式？</p><p>正则表达式是一种可以用于模式匹配和替换的强有力的工具。</p><p>2.为什么要使用正则表达式？有什么优点缺点？</p><p>正则表达式在参数校验、参数匹配方面可以发挥重大作用。</p><p>优点：更少的代码，更高的效率。</p><p>缺点：需要一定时间的学习及记忆，不然理解晦涩。</p><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="符号及其含义"><a href="#符号及其含义" class="headerlink" title="符号及其含义"></a>符号及其含义</h2><p>下表是正则表达式的所有符号及含义。</p><table><tr><td colspan="2" style="color:red;"><center><strong>常用的符号</strong></center></td></tr><tr><td style="color:red;"><strong>.</strong></td><td>表示任意字符</td></tr><tr><td style="color:red;"><strong>\s</strong></td><td>空格字符(空格键, tab, 换行, 换页, 回车)</td></tr><tr><td style="color:red;"><strong>\S</strong></td><td>非空格字符([^\s])</td></tr><tr><td style="color:red;"><strong>\d</strong></td> <td>一个数字，(相当于[0-9] )</td></tr><tr><td style="color:red;"><strong>\D</strong></td><td>一个非数字的字符，(相当于[^0-9] )</td></tr><tr><td style="color:red;"><strong>\w</strong></td><td>一个单词字符(word character) (相当于 [a-zA-Z_0-9] )</td></tr><tr><td style="color:red;"><strong>\W</strong></td><td>一个非单词的字符，[^\w]</td></tr><tr><td style="color:red;"><strong>^</strong></td><td>一行的开始</td></tr><tr><td style="color:red;"><strong>$</strong></td><td>一行的结尾</td></tr><tr><td style="color:red;"><strong>\b</strong></td><td>一个单词的边界</td> </tr><tr><td style="color:red;"><strong>\B</strong></td><td>一个非单词的边界</td></tr><tr><td style="color:red;"><strong>\G</strong></td><td>前一个匹配的结束</td> </tr><tr><td style="color:red;"><strong>[]</strong></td><td>匹配方括号内的一个字符<br>例如:[abc] 表示字符 a，b，c 中的任意一个(与 a|b|c 相同) <br>[a-zA-Z]表示从a到z或A到Z当中的任意一个字符</td></tr><tr><td colspan="2" style="color:red;"><center><strong>表示次数的符号</strong></center></td></tr><tr><td style="color:red;"><strong>*</strong></td><td>重复零次或更多次<br>例如:a* 匹配零个或者多个 a</td></tr><tr><td style="color:red;"><strong>+</strong></td><td>重复一次或更多次<br>例如:a+ 匹配一个或者多个 a</td></tr><tr><td style="color:red;"><strong>?</strong></td><td>重复零次或一次<br>例如:a? 匹配零个或一个 a</td></tr><tr><td style="color:red;"><strong>{n}</strong></td><td>重复n次<br>例如:a{4}匹配4个a</td> </tr><tr><td style="color:red;"><strong>{n,}</strong></td><td>重复 n 次或更多次<br>例如:a{4,} 匹配至少 4 个 a</td></tr><tr><td style="color:red;"><strong>{n,m}</strong></td><td>重复n到m次<br>例如:a{4,10} 匹配 4~10 个 a</td></tr></table><h2 id="正则表达式实例"><a href="#正则表达式实例" class="headerlink" title="正则表达式实例"></a>正则表达式实例</h2><p>java 正则表达式通过 java.util.regex 包下的 Pattern 类与 Matcher 类实现:</p><p>正则表达式使用总共分三步:</p><ol><li>构造一个模式.<br> Pattern p=Pattern.compile(“[a-z]*”); </li><li>建造一个匹配器<br> Matcher m = p.matcher(str); </li><li>进行判断，得到结果<br> boolean b = m.matches();</li></ol><p>Matcher 类提供三个匹配操作方法,三个方法均返回 boolean 类型,当匹配到 时返回 true,没匹配到则返回 false</p><ol><li><p>m.matches()</p><p> matches()对整个字符串进行匹配,只有整个字符串都匹配了才返回 true</p></li><li><p>m.lookingAt() </p><p> lookingAt()对前面的字符串进行匹配,只有匹配到的字符串在最前面才返 回 true</p></li><li><p>m.find()</p><p> find()对字符串进行匹配,匹配到的字符串可以在任何位置</p></li></ol><p>Matcher 类的其他方法:</p><ol><li><p>int groupcount() </p><p> 返回此匹配器模式中的捕获组数。</p></li><li><p>String replaceAll(String replacement)</p><p> 用给定的 replacement 全部替代匹配的 部分</p></li><li><p>String repalceFirst(String replacement) </p><p> 用给定的 replacement 替代第一次匹 配的部分</p></li><li><p>appendReplacement(StringBuffer sb,String replacement) </p><p> 根 据 模 式 用 replacement 替换相应内容,并将匹配的结果添加到 sb 当前位置之后 </p></li><li><p>StringBuffer appendTail(StringBuffer sb) </p><p> 将输入序列中匹配之后的末尾字串 添加到 sb 当前位置之后.</p></li><li><p>group(n)</p><p> 0 代表永远都是匹配整个表达式的字符串的那部分 n&lt;&gt;0 时代表 第 n 组匹配的部分</p></li></ol><h2 id="正则表达式的用法"><a href="#正则表达式的用法" class="headerlink" title="正则表达式的用法"></a>正则表达式的用法</h2><ol><li><p>字符匹配</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Pattern p = Pattern.compile(expression); <span class="comment">// 正则表达式 </span></span><br><span class="line">Matcher m = p.matcher(str); <span class="comment">// 操作的字符串</span></span><br><span class="line"><span class="keyword">boolean</span> b = m.matches(); <span class="comment">//返回是否匹配的结果 </span></span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure></li><li><p>分割字符串</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Pattern pattern = Pattern.compile(expression); <span class="comment">//正则表达式</span></span><br><span class="line">String[] strs = pattern.split(str); <span class="comment">//操作字符串 得到返回的字符串数组</span></span><br></pre></td></tr></table></figure></li><li><p>替换字符串</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pattern p = Pattern.compile(expression); <span class="comment">// 正则表达式 </span></span><br><span class="line">   Matcher m = p.matcher(text); <span class="comment">// 操作的字符串</span></span><br><span class="line">String s = m.replaceAll(str); <span class="comment">//替换后的字符串</span></span><br></pre></td></tr></table></figure></li><li><p>查找替换指定字符串</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Pattern p = Pattern.compile(expression); <span class="comment">// 正则表达式 </span></span><br><span class="line">   Matcher m = p.matcher(text); <span class="comment">// 操作的字符串 </span></span><br><span class="line">   StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (m.find()) &#123;</span><br><span class="line">m.appendReplacement(sb, str);</span><br><span class="line">i++; <span class="comment">//字符串出现次数</span></span><br><span class="line">&#125;</span><br><span class="line">m.appendTail(sb);<span class="comment">//从截取点将后面的字符串接上 </span></span><br><span class="line">   String s = sb.toString();</span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><p>查找输出字符串</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Pattern p = Pattern.compile(expression); <span class="comment">// 正则表达式 </span></span><br><span class="line">   Matcher m = p.matcher(text); <span class="comment">// 操作的字符串</span></span><br><span class="line"><span class="keyword">while</span> (m.find()) &#123;</span><br><span class="line"><span class="comment">//m.start() 返回匹配到的子字符串在字符串中的索引位置. </span></span><br><span class="line">   <span class="comment">//m.end()返回匹配到的子字符串的最后一个字符在字符串中的索引位置.</span></span><br><span class="line">   <span class="comment">//m.group()返回匹配到的子字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="常用的正则表达式"><a href="#常用的正则表达式" class="headerlink" title="常用的正则表达式"></a>常用的正则表达式</h2><ol><li><p>手机号码校验</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPhone</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">Pattern p = Pattern.compile(<span class="string">"^[1][3,5,7,8]+\\d&#123;9&#125;"</span>); <span class="comment">//正则表达式</span></span><br><span class="line">Matcher m = p.matcher(str); <span class="comment">//操作的字符串</span></span><br><span class="line"><span class="keyword">return</span> m.matches();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>邮箱地址校验</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isEmail</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">Pattern p = Pattern.compile(<span class="string">"^[a-zA-Z0-9_.-]+@[a-zA-Z0-9-]+(\\.[a-zA-Z0-9-]+)*\\.[a-zA-Z0-9]&#123;2,6&#125;$"</span>); <span class="comment">//正则表达式</span></span><br><span class="line">Matcher m = p.matcher(str); <span class="comment">//操作的字符串</span></span><br><span class="line"><span class="keyword">return</span> m.matches();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>IP地址校验</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isIPv4</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">Pattern p = Pattern.compile(<span class="string">"\\d&#123;1,3&#125;+\\.\\d&#123;1,3&#125;+\\.\\d&#123;1,3&#125;+\\.\\d&#123;1,3&#125;"</span>); <span class="comment">//正则表达式</span></span><br><span class="line">Matcher m = p.matcher(str); <span class="comment">//操作的字符串</span></span><br><span class="line"><span class="keyword">return</span> m.matches();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>是不是汉字</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isChinese</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">Pattern p = Pattern.compile(<span class="string">"^[\\u4e00-\\u9fa5]+$"</span>); <span class="comment">//正则表达式</span></span><br><span class="line">Matcher m = p.matcher(str); <span class="comment">//操作的字符串</span></span><br><span class="line"><span class="keyword">return</span> m.matches();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><p>QQ号校验</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isQQ</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">Pattern p = Pattern.compile(<span class="string">"[1-9][0-9]&#123;4,13&#125;"</span>); <span class="comment">//正则表达式</span></span><br><span class="line">Matcher m = p.matcher(str); <span class="comment">//操作的字符串</span></span><br><span class="line"><span class="keyword">return</span> m.matches();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>身份证号校验</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isIDNumber</span><span class="params">(String IDNumber)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (IDNumber == <span class="keyword">null</span> || <span class="string">""</span>.equals(IDNumber)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义判别用户身份证号的正则表达式（15位或者18位，最后一位可以为字母）</span></span><br><span class="line">    String regularExpression = <span class="string">"(^[1-9]\\d&#123;5&#125;(18|19|20)\\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\\d&#123;3&#125;[0-9Xx]$)|"</span> +</span><br><span class="line">            <span class="string">"(^[1-9]\\d&#123;5&#125;\\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\\d&#123;3&#125;$)"</span>; </span><br><span class="line">    <span class="keyword">boolean</span> matches = IDNumber.matches(regularExpression);</span><br><span class="line">    <span class="comment">//详细校验略</span></span><br><span class="line">    <span class="keyword">return</span> matches;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="7"><li><p>邮编校验</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMail</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">Pattern p = Pattern.compile(<span class="string">"[1-9]\\d&#123;5&#125;(?!\\d)"</span>); <span class="comment">//正则表达式</span></span><br><span class="line">Matcher m = p.matcher(str); <span class="comment">//操作的字符串</span></span><br><span class="line"><span class="keyword">return</span> m.matches();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="8"><li><p>其他</p><p> 其他常用校验不在一一说明。</p><p> 可以通过  <a href="https://github.com/JavaZWT/sakuratears" target="_blank" rel="noopener">https://github.com/JavaZWT/sakuratears</a>  获取。</p></li></ol><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>如果我们能够熟练掌握正则表达式，一定会对我们的开发提供很大的帮助。</p><p>正则表达式整体上相对于代码来说是比较晦涩的，用好它需要一定的功力及学习能力。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;1.什么是正则表达式？&lt;/p&gt;
&lt;p&gt;正则表达式是一种可以用于模式匹配和替换的强有力的工具。&lt;/p&gt;
&lt;p&gt;2.为什么要使用正则表达式？有什
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>搭建自己的Hexo博客（2）</title>
    <link href="https://www.sakuratears.top/blog/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2%EF%BC%882%EF%BC%8920180717/"/>
    <id>https://www.sakuratears.top/blog/搭建自己的Hexo博客（2）20180717/</id>
    <published>2018-07-17T13:21:00.000Z</published>
    <updated>2018-07-17T14:22:33.751Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>关于之前的部分请参考我的《搭建自己的Hexo博客（1）》这篇文章。</p><h1 id="创建Github账户"><a href="#创建Github账户" class="headerlink" title="创建Github账户"></a>创建Github账户</h1><p>我们把博客发布到Github上。</p><p>首先申请Github账号：<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a></p><p>新建一个Repository</p><p><img src="/images/pasted-22.png" alt="upload successful"></p><p>红框内为项目名称，应写成 yourname.github.io 这种形式。</p><p>如我注册的用户名是JavaZWT，则项目名应写为 JavaZWT.github.io</p><p>新建好后，我们开始发布我们的博客。</p><h1 id="博客发布"><a href="#博客发布" class="headerlink" title="博客发布"></a>博客发布</h1><p>进入到原来的blog文件夹。</p><p>我们要记住以下指令：</p><p>博客本地调试启动：hexo s</p><p>博客部署文件生成：hexo g</p><p>博客发布：hexo d</p><p>博客部署文件夹清空： hexo clean</p><p>hexo g 后，要发布的博客文件会生成在public文件夹下。</p><p>hexo d 会把这个文件夹下的文件deploy到Github上。</p><p>_config.yml配置文件里，指明自己的Github地址上新建的yourname.github.io的项目。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span> </span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="string">git@github.com:JavaZWT/JavaZWT.github.io.git</span></span><br></pre></td></tr></table></figure><p>正常的发布流程：</p><ol><li>新写了一篇博文</li><li>通过hexo s本地调试通过后</li><li>hexo clean 清空public文件夹及db文件</li><li>hexo g 重新生成部署文件</li><li>hexo d 发布到Github</li></ol><p>当我们发布成功后，通过 <a href="https://yourname.github.io/" target="_blank" rel="noopener">https://yourname.github.io/</a> 便可以在外网访问自己的blog啦。</p><h1 id="添加域名"><a href="#添加域名" class="headerlink" title="添加域名"></a>添加域名</h1><p>成功访问之后，我们觉得这个网址不好，想换个自己喜欢的域名怎么办？</p><p>这里我使用了阿里云申请了域名。</p><p>首先登陆阿里云，没有账号请注册申请。</p><p>找到域名与网站（万网）菜单。</p><p><img src="/images/pasted-23.png" alt="upload successful"></p><p>找到自己喜欢的域名进行购买。</p><p>得到域名后，我们需要配置域名解析。把域名指向我们的博客。</p><p>在域名解析列表里我们新增两条记录，如下图红框部分。</p><p>其中记录值可以写 <a href="https://yourname.github.io/" target="_blank" rel="noopener">https://yourname.github.io/</a></p><p>相当于把这个域名指向了<a href="https://yourname.github.io/这个域名。" target="_blank" rel="noopener">https://yourname.github.io/这个域名。</a></p><p>或者我们可以查到 <a href="https://yourname.github.io/" target="_blank" rel="noopener">https://yourname.github.io/</a>  这个域名的IP，直接将新的域名指向这个IP即可。</p><p><img src="/images/pasted-24.png" alt="upload successful"></p><p>配置好后等一段时间，我们访问新的域名，就可以跳转到我们的博客啦。</p><h1 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h1><h2 id="添加音乐播放功能"><a href="#添加音乐播放功能" class="headerlink" title="添加音乐播放功能"></a>添加音乐播放功能</h2><p>找到 /themes/next/layout/_custom/sidebar.swig 文件</p><p>登陆网易云音乐，对于一首歌，生成外链播放器。</p><p><img src="/images/pasted-25.png" alt="upload successful"></p><p><img src="/images/pasted-26.png" alt="upload successful"></p><p>将上述代码复制到sidebar.swig文件里。</p><p>生成如下图所示效果。</p><p><img src="/images/pasted-27.png" alt="upload successful"></p><h2 id="添加博客编写功能"><a href="#添加博客编写功能" class="headerlink" title="添加博客编写功能"></a>添加博客编写功能</h2><p>写博客时是不是很不方便？</p><p>我们安装hexo-admin插件吧。这个插件可以是写博客更快捷方便。</p><p>npm install hexo-admin –save</p><p>安装好后，启动调试博客 hexo s</p><p>输入 <a href="http://localhost:4000/admin/" target="_blank" rel="noopener">http://localhost:4000/admin/</a></p><p>是不是看到进入了博客管理菜单？</p><p>通过这个插件可以方便的管理和书写博客。</p><p><img src="/images/pasted-28.png" alt="upload successful"></p><h2 id="压缩博客"><a href="#压缩博客" class="headerlink" title="压缩博客"></a>压缩博客</h2><p>博客里有一些图片或者css，js过大怎么办，这样会导致博客加载缓慢。</p><p>我们在发布博客时可以先对其进行压缩。</p><p>在blog目录下新建gulpfile.js</p><p>有如下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> minifycss = <span class="built_in">require</span>(<span class="string">'gulp-minify-css'</span>);</span><br><span class="line"><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);</span><br><span class="line"><span class="keyword">var</span> htmlmin = <span class="built_in">require</span>(<span class="string">'gulp-htmlmin'</span>);</span><br><span class="line"><span class="keyword">var</span> htmlclean = <span class="built_in">require</span>(<span class="string">'gulp-htmlclean'</span>);</span><br><span class="line"><span class="keyword">var</span> imagemin = <span class="built_in">require</span>(<span class="string">'gulp-imagemin'</span>);</span><br><span class="line"><span class="comment">// 压缩 public 目录 css</span></span><br><span class="line">gulp.task(<span class="string">'minify-css'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.css'</span>)</span><br><span class="line">        .pipe(minifycss())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 压缩 public 目录 html</span></span><br><span class="line">gulp.task(<span class="string">'minify-html'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.html'</span>)</span><br><span class="line">        .pipe(htmlclean())</span><br><span class="line">        .pipe(htmlmin(&#123;</span><br><span class="line">            removeComments: <span class="literal">true</span>,</span><br><span class="line">            minifyJS: <span class="literal">true</span>,</span><br><span class="line">            minifyCSS: <span class="literal">true</span>,</span><br><span class="line">            minifyURLs: <span class="literal">true</span>,</span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./public'</span>))</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 压缩 public/js 目录 js</span></span><br><span class="line">gulp.task(<span class="string">'minify-js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.js'</span>)</span><br><span class="line">        .pipe(uglify())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 压缩 public/images 目录 images</span></span><br><span class="line">gulp.task(<span class="string">'images'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src([<span class="string">'./public/**/*.png'</span>, <span class="string">'./public/**/*.jpg'</span>, <span class="string">'./public/**/*.gif'</span>, <span class="string">'./public/**/*.svg'</span>])</span><br><span class="line">        .pipe(imagemin(&#123;</span><br><span class="line">            progressive: <span class="literal">false</span></span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 执行 gulp 命令时执行的任务</span></span><br><span class="line">gulp.task(<span class="string">'default'</span>, [</span><br><span class="line">    <span class="string">'minify-html'</span>, <span class="string">'minify-css'</span>, <span class="string">'minify-js'</span>, <span class="string">'images'</span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>同时在package.json里添加这几个包。</p><pre><code>&quot;gulp-minify-css&quot;: &quot;^1.2.4&quot;,&quot;gulp-uglify&quot;: &quot;^3.0.0&quot;,&quot;gulp-htmlmin&quot;: &quot;^4.0.0&quot;,&quot;gulp-htmlclean&quot;: &quot;^2.7.22&quot;,&quot;gulp&quot;: &quot;^3.9.1&quot;,&quot;gulp-imagemin&quot;: &quot;^4.1.0&quot;,</code></pre><p>添加完后执行 npm install。</p><p>或者直接一个个的 npm install 包名 –save 也是可以的。</p><p>弄好后，在hexo g 指令后进行 压缩操作，执行 gulp 命令，可对public文件夹下的资源进行压缩。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>一个博客的基本搭建到这里基本就结束了，如果想提高性能及速度，可以自己申请个服务器，或者使用CDN进行加速，基本都涉及到一定的费用。</p><p>博客还有一些比较小的美化的地方就不一一说明，大家可以自己尝试，自己动手，把自己的博客搭建的更漂亮。</p><p>毕竟，搭建博客这件事我们应本着学习，兴趣，快乐的本质去出发，自己摸索自己研究一些比较好玩的东西，这样才是做这件事的意义。</p><p>附上我的博客地址：</p><p><a href="https://www.sakuratears.top/">https://www.sakuratears.top/</a></p><p>大家可以参考下，有什么问题可以随时联系我，一定会为大家解答。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;关于之前的部分请参考我的《搭建自己的Hexo博客（1）》这篇文章。&lt;/p&gt;
&lt;h1 id=&quot;创建Github账户&quot;&gt;&lt;a href=&quot;#创建
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="blog" scheme="https://www.sakuratears.top/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>搭建自己的Hexo博客（1）</title>
    <link href="https://www.sakuratears.top/blog/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Hexo%E5%8D%9A%E5%AE%A220180715/"/>
    <id>https://www.sakuratears.top/blog/搭建自己的Hexo博客20180715/</id>
    <published>2018-07-15T06:29:00.000Z</published>
    <updated>2018-07-16T10:50:55.693Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我的Hexo博客很早就建好了，但一直没时间把搭建博客的步骤和经验好好总结。今天，我把在搭建博客中注意到的点及经验总结下来。一方面与大家分享，另一方面也加深自己的记忆，总结经验。</p><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><h2 id="安装Node-js及npm"><a href="#安装Node-js及npm" class="headerlink" title="安装Node.js及npm"></a>安装Node.js及npm</h2><p>要搭建Hexo博客，首先需要安装Node.js环境，去Node.js官网下载Node并安装。</p><p>NodeJs官网：<a href="https://nodejs.org/" target="_blank" rel="noopener">https://nodejs.org/</a></p><p>在命令行界面输入node -v 查询版本号。</p><p>输入npm -v 可查询npm版本号。</p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>使用npm指令安装hexo</p><p>npm install hexo-cli -g</p><p>安装成功后输入hexo -v可查询hexo版本信息</p><h2 id="博客初始化"><a href="#博客初始化" class="headerlink" title="博客初始化"></a>博客初始化</h2><p>安装好hexo后，我们找到一个自己文件夹，通过指令进入该文件夹。</p><p>使用指令：</p><p>①hexo init blog</p><p>②cd blog</p><p>③npm install</p><p>④hexo s</p><p>会看到命令行输出如下信息</p><p><img src="/images/pasted-21.png" alt="upload successful"></p><p>打开浏览器，输入地址便可以看到blog搭建成功了。</p><h2 id="美化博客"><a href="#美化博客" class="headerlink" title="美化博客"></a>美化博客</h2><p>虽然blog搭建好了，但是总感觉不是很好看。</p><p>推荐一款hexo主题Next，其有很多种blog主题供我们选择。</p><h3 id="安装Next主题"><a href="#安装Next主题" class="headerlink" title="安装Next主题"></a>安装Next主题</h3><p>首先cd到刚刚建好的blog目录下，执行命令：</p><p>git clone <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a> themes/next</p><p>如果没有安装git，那么安装下吧。</p><p>请去git官网下载git：    <a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a></p><p>如果命令执行成功，在blog下的themes包下，我们可以看到next文件夹，那就是刚刚下好的next主题啦。themes包下那个landscape包，就是hexo自带的默认主题。</p><p>如果不成功，那么我们可以直接下载next主题，<a href="https://github.com/iissnan/hexo-theme-next/releases，下载source" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next/releases，下载source</a> code，然后把文件解压，重命名为next放到themes包下就可以了啦。</p><p>完成后，在blog包下，有个_config.yml文件，打开它，里面配置为theme: next即可加载next主题。</p><h3 id="Hexo的-config-yml文件"><a href="#Hexo的-config-yml文件" class="headerlink" title="Hexo的_config.yml文件"></a>Hexo的_config.yml文件</h3><p>上文提到的这个配置文件是Hexo的核心配置文件，我们来说下这个文件吧</p><p>请先对yml语法有一定了解，本文不做说明。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Hexo Configuration</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/configuration.html</span></span><br><span class="line"><span class="comment">## Source: https://github.com/hexojs/hexo/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">SakuraTears的博客</span>             <span class="string">//博客的标题</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">越努力越幸运</span><span class="string">//博客简介</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">越努力越幸运</span><span class="string">//博客描述</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">'Java,努力,随笔,学习,SakuraTears,博客,生活'</span>  <span class="string">//博客关键字</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">SakuraTears</span><span class="string">//博客作者</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-Hans</span><span class="string">//博客语言</span></span><br><span class="line"><span class="attr">timezone:</span><span class="string">//时区</span></span><br><span class="line"><span class="attr">avatar:</span> <span class="string">/uploads/avatar.jpg</span><span class="string">//头像</span></span><br><span class="line"><span class="comment">#google_analytics: your-analytics-id//谷歌统计，开启的话请输入自己的id</span></span><br><span class="line"><span class="comment">#baidu_analytics: your-analytics-id//百度统计，开启的话请输入自己的id</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></span><br><span class="line"><span class="attr">url:</span> <span class="attr">https://www.sakuratears.top</span>       <span class="string">//自己的网站地址</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span><span class="string">//根目录</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">blog/:title:year:month:day/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Directory</span></span><br><span class="line"><span class="attr">source_dir:</span> <span class="string">source</span><span class="string">//源码位置，请默认</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public</span><span class="string">//生成的文件位置，请默认</span></span><br><span class="line"><span class="attr">tag_dir:</span> <span class="string">tags</span><span class="string">//标签文件位置，请默认</span></span><br><span class="line"><span class="attr">archive_dir:</span> <span class="string">archives</span><span class="string">//归档文件位置，请默认</span></span><br><span class="line"><span class="attr">category_dir:</span> <span class="string">categories</span><span class="string">//分类文件位置，请默认</span></span><br><span class="line"><span class="attr">code_dir:</span> <span class="string">downloads/code</span></span><br><span class="line"><span class="attr">i18n_dir:</span> <span class="string">:lang</span></span><br><span class="line"><span class="attr">skip_render:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Writing</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:title.md</span> <span class="comment"># File name of new posts  //新文章默认名字</span></span><br><span class="line"><span class="attr">default_layout:</span> <span class="string">post</span><span class="string">//默认样式</span></span><br><span class="line"><span class="attr">titlecase:</span> <span class="literal">false</span> <span class="comment"># Transform title into titlecase</span></span><br><span class="line"><span class="attr">external_link:</span> <span class="literal">true</span> <span class="comment"># Open external links in new tab</span></span><br><span class="line"><span class="attr">filename_case:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">render_drafts:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">relative_link:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">future:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">highlight:</span><span class="string">//高亮</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span><span class="string">//启用</span></span><br><span class="line"><span class="attr">  line_number:</span> <span class="literal">true</span><span class="string">//linenumber启用</span></span><br><span class="line"><span class="attr">  auto_detect:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  tab_replace:</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># Home page setting</span></span><br><span class="line"><span class="comment"># path: Root path for your blogs index page. (default = '')</span></span><br><span class="line"><span class="comment"># per_page: Posts displayed per page. (0 = disable pagination)</span></span><br><span class="line"><span class="comment"># order_by: Posts order. (Order by date descending by default)</span></span><br><span class="line"><span class="attr">index_generator:</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">''</span></span><br><span class="line"><span class="attr">  per_page:</span> <span class="number">3</span>           <span class="string">//每页三篇文章</span></span><br><span class="line"><span class="attr">  order_by:</span> <span class="bullet">-date</span><span class="string">//按日期排序</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># Category &amp; Tag</span></span><br><span class="line"><span class="attr">default_category:</span> <span class="string">uncategorized</span><span class="string">//按默认策略分类</span></span><br><span class="line"><span class="attr">category_map:</span></span><br><span class="line"><span class="attr">tag_map:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Date / Time format</span></span><br><span class="line"><span class="comment">## Hexo uses Moment.js to parse and display date</span></span><br><span class="line"><span class="comment">## You can customize the date format as defined in</span></span><br><span class="line"><span class="comment">## http://momentjs.com/docs/#/displaying/format/</span></span><br><span class="line"><span class="attr">date_format:</span> <span class="string">YYYY-MM-DD</span><span class="string">//日期时间格式</span></span><br><span class="line"><span class="attr">time_format:</span> <span class="attr">HH:mm:ss</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pagination</span></span><br><span class="line"><span class="comment">## Set per_page to 0 to disable pagination</span></span><br><span class="line"><span class="attr">per_page:</span> <span class="number">10</span><span class="string">//归档每页10篇文章</span></span><br><span class="line"><span class="attr">pagination_dir:</span> <span class="string">page</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="attr">plugins:</span> <span class="string">hexo-generate-feed</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span><span class="string">//hexo主题</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># hexo-admin authentification</span></span><br><span class="line"><span class="attr">admin:</span></span><br><span class="line"><span class="attr">  username:</span> <span class="string">sakuratears</span></span><br><span class="line"><span class="attr">  password_hash:</span> <span class="string">$2a$10$HhGu7w5fYH6e7wmb2tXta.FvJvGWlzosdUgImJxGhxU0K3YAkXIkm</span></span><br><span class="line"><span class="attr">  secret:</span> <span class="string">what's</span> <span class="string">your</span> <span class="string">name?</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Live2D//live2D插件，后面介绍</span></span><br><span class="line"><span class="comment">## https://github.com/xiazeyu/live2d-widget.js</span></span><br><span class="line"><span class="comment">## https://l2dwidget.js.org/docs/class/src/index.js~L2Dwidget.html#instance-method-init</span></span><br><span class="line"><span class="attr">live2d:</span></span><br><span class="line"><span class="attr">  model:</span></span><br><span class="line"><span class="attr">    scale:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">    hHeadPos:</span> <span class="number">0.5</span></span><br><span class="line"><span class="attr">    vHeadPos:</span> <span class="number">0.618</span></span><br><span class="line"><span class="attr">  display:</span></span><br><span class="line"><span class="attr">    superSample:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">    width:</span> <span class="number">150</span></span><br><span class="line"><span class="attr">    height:</span> <span class="number">300</span></span><br><span class="line"><span class="attr">    position:</span> <span class="string">right</span></span><br><span class="line"><span class="attr">    hOffset:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">    vOffset:</span> <span class="bullet">-20</span></span><br><span class="line"><span class="attr">  mobile:</span></span><br><span class="line"><span class="attr">    show:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    scale:</span> <span class="number">0.1</span></span><br><span class="line"><span class="attr">    motion:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  react:</span></span><br><span class="line"><span class="attr">    opacityDefault:</span> <span class="number">0.7</span></span><br><span class="line"><span class="attr">    opacityOnHover:</span> <span class="number">0.2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##local_search//搜索插件</span></span><br><span class="line"><span class="attr">search:</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">search.xml</span></span><br><span class="line"><span class="attr">  field:</span> <span class="string">post</span></span><br><span class="line"><span class="attr">  format:</span> <span class="string">html</span></span><br><span class="line"><span class="attr">  limit:</span> <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Deployment//部署</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span> </span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="string">git@github.com:JavaZWT/JavaZWT.github.io.git</span></span><br></pre></td></tr></table></figure><h3 id="Next主题的-config-yml文件"><a href="#Next主题的-config-yml文件" class="headerlink" title="Next主题的_config.yml文件"></a>Next主题的_config.yml文件</h3><p>在next包下，也有一个_config.yml文件，这个文件是配置next主题的，也简单介绍下。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span>     <span class="string">//next主题菜单</span></span><br><span class="line"><span class="attr">  home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line"><span class="attr">  about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">user</span></span><br><span class="line"><span class="attr">  tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">  categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line"><span class="attr">  archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line"><span class="attr">  commonweal:</span> <span class="string">/404/</span> <span class="string">||</span> <span class="string">heartbeat</span></span><br><span class="line"><span class="attr">  support:</span> <span class="string">/support/</span> <span class="string">||</span> <span class="string">support</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">scheme:</span> <span class="string">Pisces</span>  <span class="string">//主题类型</span></span><br></pre></td></tr></table></figure><p>我选的Pisces主题。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">social:</span>   <span class="string">//社交信息</span></span><br><span class="line"><span class="attr">  GitHub:</span> <span class="attr">https://github.com/JavaZWT</span> <span class="string">||</span> <span class="string">github</span></span><br><span class="line"><span class="attr">  Email:</span> <span class="attr">mailto:971258230@qq.com</span> <span class="string">||</span> <span class="string">envelope</span></span><br><span class="line"><span class="attr">  QQ:</span> <span class="attr">http://wpa.qq.com/msgrd?v=3&amp;uin=971258230&amp;site=qq&amp;menu=yes</span> <span class="string">||</span> <span class="string">qq</span></span><br><span class="line"><span class="attr">  CSDN:</span> <span class="attr">https://blog.csdn.net/JavaZWT</span> <span class="string">||</span> <span class="string">copyright</span></span><br></pre></td></tr></table></figure><p>上面都是一些基本配置，下面我们对blog进行更多的美化。</p><h3 id="添加动态旋转头像"><a href="#添加动态旋转头像" class="headerlink" title="添加动态旋转头像"></a>添加动态旋转头像</h3><p>打开/themes/next/source/css/_common/components/sidebar/sidebar-author.styl文件</p><p>将代码替换为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.site-author-image</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">padding</span>: $site-author-image-padding;</span><br><span class="line">  <span class="attribute">max-width</span>: $site-author-image-width;</span><br><span class="line">  <span class="attribute">height</span>: $site-author-image-height;</span><br><span class="line">  <span class="attribute">border</span>: $site-author-image-border-width solid $site-author-image-border-color;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">60%</span>;</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">2.5s</span> all;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.site-author-image</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(360deg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.site-author-name</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: $site-author-name-margin;</span><br><span class="line">  <span class="attribute">text-align</span>: $site-author-name-align;</span><br><span class="line">  <span class="attribute">color</span>: $site-author-name-color;</span><br><span class="line">  <span class="attribute">font-weight</span>: $site-author-name-weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.site-description</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: $site-description-margin-top;</span><br><span class="line">  <span class="attribute">text-align</span>: $site-description-align;</span><br><span class="line">  <span class="attribute">font-size</span>: $site-description-font-size;</span><br><span class="line">  <span class="attribute">color</span>: $site-description-color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后重新发布，可以看到头像可以旋转啦。</p><h3 id="添加本地搜索插件"><a href="#添加本地搜索插件" class="headerlink" title="添加本地搜索插件"></a>添加本地搜索插件</h3><p>安装hexo-generator-searchdb：</p><p>npm install hexo-generator-searchdb –save</p><p>同时在hexo的_config.yml里配置如下参数：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##local_search</span></span><br><span class="line"><span class="attr">search:</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">search.xml</span></span><br><span class="line"><span class="attr">  field:</span> <span class="string">post</span></span><br><span class="line"><span class="attr">  format:</span> <span class="string">html</span></span><br><span class="line"><span class="attr">  limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure><p>Next的_config.yml配置如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># if auto, trigger search by changing input</span></span><br><span class="line">  <span class="comment"># if manual, trigger search by pressing enter key or search button</span></span><br><span class="line"><span class="attr">  trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># show top n results per article, show all results by setting to -1</span></span><br><span class="line"><span class="attr">  top_n_per_article:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>重新发布，可以看到新增了搜索功能。</p><h3 id="更换背景图片"><a href="#更换背景图片" class="headerlink" title="更换背景图片"></a>更换背景图片</h3><p>找到 /themes/next/source/css/_custom/custom.styl文件</p><p>加入如下代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>:<span class="built_in">url</span>(<span class="string">"/images/background.jpg"</span>);</span><br><span class="line">    background-attachment: fixed; // 不随屏幕滚动而滚动</span><br><span class="line">    background-repeat: no-repeat; // 如果背景图不够屏幕大小则重复铺，改为no-repeat则表示不重复铺</span><br><span class="line">    background-size: 100%; // 等比例铺满屏幕</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main-inner</span> &#123; </span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0.8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新发布，可以看到背景图片变化了。</p><h3 id="添加live2D功能"><a href="#添加live2D功能" class="headerlink" title="添加live2D功能"></a>添加live2D功能</h3><p>安装live2D插件hexo-helper-live2d</p><p>npm install hexo-helper-live2d –save</p><p>Hexo的 _config.yml文件里配置如下参数</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">live2d:</span></span><br><span class="line"><span class="attr">  model:</span></span><br><span class="line"><span class="attr">    scale:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">    hHeadPos:</span> <span class="number">0.5</span></span><br><span class="line"><span class="attr">    vHeadPos:</span> <span class="number">0.618</span></span><br><span class="line"><span class="attr">  display:</span></span><br><span class="line"><span class="attr">    superSample:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">    width:</span> <span class="number">150</span></span><br><span class="line"><span class="attr">    height:</span> <span class="number">300</span></span><br><span class="line"><span class="attr">    position:</span> <span class="string">right</span></span><br><span class="line"><span class="attr">    hOffset:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">    vOffset:</span> <span class="bullet">-20</span></span><br><span class="line"><span class="attr">  mobile:</span></span><br><span class="line"><span class="attr">    show:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    scale:</span> <span class="number">0.1</span></span><br><span class="line"><span class="attr">    motion:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  react:</span></span><br><span class="line"><span class="attr">    opacityDefault:</span> <span class="number">0.7</span></span><br><span class="line"><span class="attr">    opacityOnHover:</span> <span class="number">0.2</span></span><br></pre></td></tr></table></figure><p>重新发布，便看到萌萌的二次元人物出现啦。</p><h3 id="添加评论插件"><a href="#添加评论插件" class="headerlink" title="添加评论插件"></a>添加评论插件</h3><p>这里用的Valine评论插件，Valine插件需要leancloud支持，请先注册leancloud，注册成功拿到id和key。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">valine:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  appid:</span> <span class="string">//你的id</span></span><br><span class="line"><span class="attr">  appkey:</span> <span class="string">//你的key</span></span><br><span class="line"><span class="attr">  notify:</span> <span class="literal">false</span> <span class="comment"># mail notifier , https://github.com/xCss/Valine/wiki</span></span><br><span class="line"><span class="attr">  verify:</span> <span class="literal">false</span> <span class="comment"># Verification code</span></span><br><span class="line"><span class="attr">  placeholder:</span> <span class="string">(*^_^*)看了这么多，可能你有话想说</span> <span class="comment"># comment box placeholder</span></span><br><span class="line"><span class="attr">  avatar:</span> <span class="string">mm</span> <span class="comment"># gravatar style</span></span><br><span class="line"><span class="attr">  guest_info:</span> <span class="string">nick,mail,link</span> <span class="comment"># custom comment header</span></span><br><span class="line"><span class="attr">  pageSize:</span> <span class="number">10</span> <span class="comment"># pagination size</span></span><br></pre></td></tr></table></figure><p>配置成功后，重新发布便能看到文章可以评论啦。</p><h3 id="开启访客统计"><a href="#开启访客统计" class="headerlink" title="开启访客统计"></a>开启访客统计</h3><p>当我们注册好leancloud后。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">leancloud_visitors:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  app_id:</span> <span class="string">//你的id</span></span><br><span class="line"><span class="attr">  app_key:</span> <span class="string">//你的key</span></span><br></pre></td></tr></table></figure><p>找到代码，填入自己的id和key。</p><p>重新发布，在页面上可以看到博客的访客数量。</p><h3 id="开启字数统计"><a href="#开启字数统计" class="headerlink" title="开启字数统计"></a>开启字数统计</h3><p>安装字数统计插件：hexo-wordcount</p><p>npm install hexo-wordcount –save</p><p>Next配置文件如下参数开启：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_wordcount:</span></span><br><span class="line"><span class="attr">  item_text:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  wordcount:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  min2read:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  totalcount:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  separated_meta:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>重新发布便拥有了字数统计功能。</p><h1 id="续"><a href="#续" class="headerlink" title="续"></a>续</h1><p>文章还没写完，后面会继续更新。</p><p>欢迎大家关注我的博客</p><p><a href="https://www.sakuratears.top/">https://www.sakuratears.top/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我的Hexo博客很早就建好了，但一直没时间把搭建博客的步骤和经验好好总结。今天，我把在搭建博客中注意到的点及经验总结下来。一方面与大家分享，
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="blog" scheme="https://www.sakuratears.top/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>Java通过反射获取class信息</title>
    <link href="https://www.sakuratears.top/blog/Java%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96class%E4%BF%A1%E6%81%AF20180714/"/>
    <id>https://www.sakuratears.top/blog/Java通过反射获取class信息20180714/</id>
    <published>2018-07-14T07:11:00.000Z</published>
    <updated>2018-07-14T08:06:52.341Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为反射机制。</p><p>我们知道，Java语言不是动态语言，但是他却有非常突出的动态相关机制，反射机制。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>我们可以通过反射机制获取一个class的相关信息。</p><p><strong>1. 利用Javassist获取class信息</strong></p><p>Javassist是一个动态类库，可以用来检查、”动态”修改以及创建 Java类。其功能与jdk自带的反射功能类似，但比反射功能更强大。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getClassInfoByJavassist</span><span class="params">(Class clazz)</span> </span>&#123;</span><br><span class="line">       ClassPool classPool = ClassPool.getDefault();</span><br><span class="line">        classPool.insertClassPath(<span class="keyword">new</span> ClassClassPath(clazz));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"class--&gt;"</span>+clazz.getName());</span><br><span class="line">        CtClass ctClass = classPool.get(clazz.getName());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取常量信息</span></span><br><span class="line">        CtField[] fields=ctClass.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;fields.length;i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">"object="</span>+fields[i].getName()+<span class="string">"--&gt;value="</span>+fields[i].getConstantValue()+<span class="string">"--&gt;type="</span>+fields[i].getType().getName());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取方法信息</span></span><br><span class="line">            CtMethod[] ctMethods = ctClass.getMethods();</span><br><span class="line">            <span class="keyword">for</span> (CtMethod ctMethod : ctMethods) &#123;</span><br><span class="line">            <span class="comment">//排除equals，hash，toString等方法</span></span><br><span class="line">                <span class="keyword">if</span> (!clazz.getName().equals(ctMethod.getDeclaringClass().getName())) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                MethodInfo methodInfo = ctMethod.getMethodInfo();</span><br><span class="line">                CodeAttribute codeAttribute = methodInfo.getCodeAttribute();</span><br><span class="line">                LocalVariableAttribute attr = (LocalVariableAttribute) codeAttribute.getAttribute(LocalVariableAttribute.tag);</span><br><span class="line">                <span class="keyword">if</span> (attr == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// exception</span></span><br><span class="line">                &#125;</span><br><span class="line">                String[] paramNames = <span class="keyword">new</span> String[ctMethod.getParameterTypes().length];</span><br><span class="line">                TreeMap&lt;Integer, String&gt; sortMap = <span class="keyword">new</span> TreeMap&lt;Integer, String&gt;();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; attr.tableLength(); i++) </span><br><span class="line">                    sortMap.put(attr.index(i), attr.variableName(i));</span><br><span class="line">                <span class="keyword">int</span> pos = Modifier.isStatic(ctMethod.getModifiers()) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">                paramNames = Arrays.copyOfRange(sortMap.values().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]), pos, paramNames.length + pos);</span><br><span class="line">                CtClass[] types=ctMethod.getParameterTypes();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;paramNames.length;i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"class="</span>+clazz.getSimpleName()+<span class="string">"--&gt;method="</span>+ctMethod.getName()+<span class="string">"--&gt;isStatic="</span>+Modifier.isStatic(ctMethod.getModifiers())+<span class="string">"--&gt;paramsType="</span>+types[i].getName()+<span class="string">"--&gt;paramsName="</span>+paramNames[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        &#125;         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们新建一个Demo.class</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getName</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">String s=<span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">return</span> str+s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">doSomething</span><span class="params">(String str,<span class="keyword">double</span> a,Map&lt;String, String&gt; map,List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line"><span class="comment">//doSomething</span></span><br><span class="line">Integer i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String s=<span class="string">"1234"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">s=<span class="string">"5678"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方法 getClassInfoByJavassist(Demo.class)，输出class信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>--&gt;<span class="title">com</span>.<span class="title">zwt</span>.<span class="title">reflect</span>.<span class="title">Demo</span></span></span><br><span class="line"><span class="class"><span class="title">object</span></span>=NUM--&gt;value=<span class="number">1</span>--&gt;type=<span class="keyword">int</span></span><br><span class="line">object=s--&gt;value=<span class="keyword">null</span>--&gt;type=java.lang.String</span><br><span class="line"><span class="class"><span class="keyword">class</span></span>=Demo--&gt;method=getName--&gt;isStatic=<span class="keyword">true</span>--&gt;paramsType=java.lang.String--&gt;paramsName=str</span><br><span class="line"><span class="class"><span class="keyword">class</span></span>=Demo--&gt;method=doSomething--&gt;isStatic=<span class="keyword">false</span>--&gt;paramsType=java.lang.String--&gt;paramsName=str</span><br><span class="line"><span class="class"><span class="keyword">class</span></span>=Demo--&gt;method=doSomething--&gt;isStatic=<span class="keyword">false</span>--&gt;paramsType=<span class="keyword">double</span>--&gt;paramsName=a</span><br><span class="line"><span class="class"><span class="keyword">class</span></span>=Demo--&gt;method=doSomething--&gt;isStatic=<span class="keyword">false</span>--&gt;paramsType=java.util.Map--&gt;paramsName=map</span><br><span class="line"><span class="class"><span class="keyword">class</span></span>=Demo--&gt;method=doSomething--&gt;isStatic=<span class="keyword">false</span>--&gt;paramsType=java.util.List--&gt;paramsName=list</span><br></pre></td></tr></table></figure><p><strong>2. 通过spring里的LocalVariableTableParameterNameDiscoverer获取paramsName，使用jdk自带reflect反射类获取class其他信息</strong></p><p>在jdk1.8以下java版本中，根据jdk自带reflect包，可以拿到大部分class信息，唯一拿不到的是参数name，我们可以借助spring包里的LocalVariableTableParameterNameDiscoverer去获取paramsName。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getClassInfoBySpringAndReflect</span><span class="params">(Class clazz)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">LocalVariableTableParameterNameDiscoverer u = </span><br><span class="line"><span class="keyword">new</span> LocalVariableTableParameterNameDiscoverer();</span><br><span class="line">Method[] methods =clazz.getDeclaredMethods();</span><br><span class="line">Field[] fields=clazz.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;fields.length;i++) &#123;</span><br><span class="line">        <span class="comment">//设置成可以access的，否则get(clazz)报错，无法读取private属性</span></span><br><span class="line">        fields[i].setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        System.out.println(<span class="string">"object="</span>+fields[i].getName()+<span class="string">"--&gt;value="</span>+fields[i].get(clazz)+<span class="string">"--&gt;type="</span>+fields[i].getType().getName());</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">for</span>(Method method:methods) &#123;</span><br><span class="line"><span class="comment">//使用spring LocalVariableTableParameterNameDiscoverer 获取paramsName</span></span><br><span class="line">String[] params = u.getParameterNames(method);</span><br><span class="line">Class&lt;?&gt; [] classType=method.getParameterTypes();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; params.length; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"class="</span>+clazz.getSimpleName()+<span class="string">"--&gt;method="</span>+method.getName()+<span class="string">"--&gt;isStatic="</span>+Modifier.isStatic(method.getModifiers())+<span class="string">"--&gt;paramsType="</span>+classType[i].getName()+<span class="string">"--&gt;paramsName="</span>+params[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用getClassInfoBySpringAndReflect(Demo.class)，也可以拿到class信息。</p><p><strong>3.使用jdk1.8及以上java版本获取class信息</strong></p><p> 若jdk版本较高，完全可以不用借助第三方jar包而获取class信息。</p><p> jdk1.8以上，添加了Parameter类，可以获取参数paramsName.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getClassInfoByJava8AndReflect</span><span class="params">(Class clazz)</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        Method[] methods = clazz.getDeclaredMethods();</span><br><span class="line">Field[] fields=clazz.getDeclaredFields();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;fields.length;i++) &#123;</span><br><span class="line">    <span class="comment">//设置成可以access的，否则get(clazz)报错，无法读取private属性</span></span><br><span class="line">    fields[i].setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        System.out.println(<span class="string">"object="</span>+fields[i].getName()+<span class="string">"--&gt;value="</span>+fields[i].get(clazz)+<span class="string">"--&gt;type="</span>+fields[i].getType().getName());</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        <span class="comment">//使用jdk1.8Parameter获取paramsNames</span></span><br><span class="line">            Parameter[] params = method.getParameters();</span><br><span class="line">Class&lt;?&gt; [] classType=method.getParameterTypes();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; params.length; i++) &#123;</span><br><span class="line">               System.out.println(<span class="string">"class="</span>+clazz.getSimpleName()+<span class="string">"--&gt;method="</span>+method.getName()+<span class="string">"--&gt;isStatic="</span>+Modifier.isStatic(method.getModifiers())+<span class="string">"--&gt;paramsType="</span>+classType[i].getName()+<span class="string">"--&gt;paramsName="</span>+params[i]);</span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>调用getClassInfoByJava8AndReflect(Demo.class)，获取class信息。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p> <strong>反射优点：</strong></p><p> 合理的使用反射机制可以有效降低代码冗余及代码量。并且可以让应用程序实现一些几乎不可能做到的事情。反射属于Java语言里比较高级的一个特性。</p><p> <strong>反射缺点：</strong></p><p> 如果不合理的使用反射，可能降低系统性能。</p><p> 而且非常重要的一点，我们看如上代码，有一句fields[i].setAccessible(true);<br> 这是在设置私有属性可以访问，显然，这破坏了代码的抽象性，而且可能导致安全问题的产生。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>数据传输安全性保证</title>
    <link href="https://www.sakuratears.top/blog/%E6%B5%85%E8%B0%88HTTP%E4%B8%8EHTTPS20180707/"/>
    <id>https://www.sakuratears.top/blog/浅谈HTTP与HTTPS20180707/</id>
    <published>2018-07-07T07:49:00.000Z</published>
    <updated>2018-07-07T09:42:05.828Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>数据传输过程中，安全性十分重要，尤其是对于一些敏感的用户信息，其安全性保证更应当被重视。</p><p>现代软件开发中，无论是基于敏捷式的软件开发，或者基于前后端分离的软件开发，都离不开提供对外接口，而请求这些接口数据的安全性应当得到保证。</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>保证传输数据的安全性，主要有以下方法：</p><ol><li><p><strong>数据加密</strong></p><p> 数据加密一直是保密数据的重要部分，常见的加密算法有可逆加密算法和不可逆加密算法，可逆加密算法又分为对称加密算法和非对称加密算法。</p><p> 比如一个系统的登陆操作，客户输入用户名登陆，如果不进行任何保障措施，用户名和密码明文传输，被不法分子截获数据后，显然是不安全的。如果我们这时对密码进行不可逆加密，如md5，对用户名进行可逆加密，如des，这时候在截获数据时，得到的将是一串密文，显然，即使要破解，也需要相当时间。</p><p> 但这样，有一个明显问题，就是接口吞吐量下降，明显，加密情况下，由于需要解密数据，接口的响应速度会下降。</p><p> 可能，对于一些非重要数据，我们这样牺牲系统性能换取来的安全可能有些过了。</p></li><li><p><strong>数据签名</strong></p><p>  数据签名又是什么呢？它和数据加密的区别呢？</p><p> 数据签名，相当于对传输的数据，进行一些不可逆加密算法后，如md5，生成一段签名字符串sign。</p><p> 比如上述列子中，登陆操作中如果还要传输IP，地点等等数据，这些数据明显没那么重要，这时可以对全部传输数据进行签名，生成sign，将其传入后端，后端用同样算法及密钥计算比较sign，如果一致认为数据正确，直接拿到IP，地点等数据（不用解密，相对于解密各个信息，理论上所有信息计算签名要节省时间），不一致则认为被修改过，返回错误信息。</p></li><li><p><strong>session，token机制</strong></p><p>  session（cookie）和token机制的出现是为了校验用户状态的。</p><p> 比如不法分子知道了我们的后台接口，恶意伪造大量数据攻击，即使这些数据不正确，而服务器每次都需要校验这些数据的正确性，显然带来大量性能消耗。</p><p> 我们当然可以进行一些优化操作，如对于同一个IP，短时间大量请求则封掉该IP一段时间，但这不是太合理的。</p><p> 设想，如果用户登陆后，保存状态，只有登陆的用户可以访问这些接口，每次请求到来，均先校验用户登陆状态，对于session，如果没有sessionid或者sessionid错误或者过期则直接返回登陆界面。对于token，与session同理，没有token或者token错误或者过期的直接返回登陆页面。</p><p> 这样，我们开始校验token或者session，就可以拒绝大量伪造请求。</p></li><li><p><strong>Https（数字证书机制）</strong></p><p>   上面，无论数据加密还是签名，我们发现最重要的就是加密方法和加密密钥。</p><p> 对于两台服务器交互，可能不用太担心，但是如果是webapp或者原生app，不法分子反编译前端代码后，就有可能拿到加密方法和加密key，怎么办呢？</p><p> 这就属于Https要解决的事情，下篇文章会介绍https，这儿先简单说下：</p><p> 在加密算法中，有一种叫做非对称加密的算法，有公钥和私钥组成，他有个特点：公钥加密的数据，只有私钥能解密；私钥加密的数据，只有公钥能解密。</p><p> https就是需要让客户端与服务器端安全地协商出一个对称加密算法。剩下的就是通信时双方使用这个对称加密算法进行加密解密。</p><p> ①客户端启动，发送请求到服务端，服务端通过非对称加密算法（如RSA）生成公钥pubkey1和私钥prikey1。</p><p> ②服务端将公钥pubkey1发给客户端，客户端用自己的非对称加密算法也生成一套公钥pubkey2和私钥prikey2，并将公钥pubkey2通过pubkey1加密后返回服务端。</p><p> ③服务端用私钥prikey1解密后拿到pubkey2，并将确定好的未来交互的对称加密算法和密钥通过pubkey2加密，返回客户端。</p><p> ④客户端用私钥pubkey2解密数据，拿到服务器给定的加密算法和密钥，双方开始用其数据通信。</p><p> 这样仍有一个问题，如何证明公钥pubkey1加密的这串数字是客户端来的，即证明他就是他。。。</p><p> 这就是https的数字证书，相当于网络中心的部分，证明他就是他。数字证书就是来干这个的。</p></li><li><p><strong>其他</strong></p><p>安全性保证还有其他可以自己操作的方法。</p><p>如对于两台稳定的服务器交互，直接进行IP校验或许比token，session机制更好更方便。及一些其他的操作，如同一IP短时间大量错误报文，可以将其暂时拉入黑名单。等等。</p></li></ol><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>数据安全一直是数据交互的永恒话题，保证数据安全，肯定是需要消耗一定的系统性能的。如何选择合适的安全保证机制，是每一个软件开发工程师应该了解和掌握的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;数据传输过程中，安全性十分重要，尤其是对于一些敏感的用户信息，其安全性保证更应当被重视。&lt;/p&gt;
&lt;p&gt;现代软件开发中，无论是基于敏捷式的软
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>UTF-8和GBK等编码格式转换问题</title>
    <link href="https://www.sakuratears.top/blog/UTF-8%E5%92%8CGBK%E7%AD%89%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%9820180621/"/>
    <id>https://www.sakuratears.top/blog/UTF-8和GBK等编码格式转换问题20180621/</id>
    <published>2018-06-21T14:08:00.000Z</published>
    <updated>2018-07-03T06:43:17.032Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在开发过程中，我们可能会遇到Java各种编码格式之间的转换问题。下面我们来研究下UTF-8和GBK等编码格式之间的相互转化。</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>在进行编码转换时，我们用<strong>ISO-8859-1</strong>编码来接受和保存数据，并转换为相应编码。</p><p>为什么采用<strong>ISO-8859-1</strong>编码作为中间转存方案呢？</p><p>下面我们通过程序验证：</p><ol><li><p>通过ISO-8859-1转存：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String str1,String encode)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"字符串："</span>+str1);</span><br><span class="line">  <span class="comment">//将str转为原编码字节流</span></span><br><span class="line">  <span class="keyword">byte</span>[] byteArray1=str1.getBytes(encode);</span><br><span class="line">  System.out.println(byteArray1.length);</span><br><span class="line">  <span class="comment">//转换为一个ISO-8859-1的字符串</span></span><br><span class="line">  String str2=<span class="keyword">new</span> String(byteArray1,<span class="string">"ISO-8859-1"</span>);</span><br><span class="line">  System.out.println(<span class="string">"转成ISO-8859-1："</span>+str2);</span><br><span class="line">  <span class="comment">//转回为byte数组</span></span><br><span class="line">  <span class="keyword">byte</span>[] byteArray2=str2.getBytes(<span class="string">"ISO-8859-1"</span>);  </span><br><span class="line">  System.out.println(byteArray2.length);</span><br><span class="line">  <span class="comment">//重新用目标编码格式编码</span></span><br><span class="line">  String str3=<span class="keyword">new</span> String(byteArray2,encode);</span><br><span class="line">  System.out.println(<span class="string">"字符串："</span>+str3);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">String str1=<span class="string">"你好"</span>;</span><br><span class="line">String str2=<span class="string">"你好呀"</span>;</span><br><span class="line">test(str1,<span class="string">"UTF-8"</span>);</span><br><span class="line">test(str2,<span class="string">"UTF-8"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><pre><code>运行结果：    字符串：你好    6    转成ISO-8859-1：ä½ å¥½    6    字符串：你好    字符串：你好呀    9    转成ISO-8859-1：ä½ å¥½å    9    字符串：你好呀</code></pre><ol start="2"><li><p>通过GBK转存：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String str1,String encode)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"字符串："</span>+str1);</span><br><span class="line">  <span class="comment">//将str转为原编码字节流</span></span><br><span class="line">  <span class="keyword">byte</span>[] byteArray1=str1.getBytes(encode);</span><br><span class="line">  System.out.println(byteArray1.length);</span><br><span class="line">  <span class="comment">//转换为一个GBK的字符串</span></span><br><span class="line">  String str2=<span class="keyword">new</span> String(byteArray1,<span class="string">"GBK"</span>);</span><br><span class="line">  System.out.println(<span class="string">"转成GBK："</span>+str2);</span><br><span class="line">  <span class="comment">//转回为byte数组</span></span><br><span class="line">  <span class="keyword">byte</span>[] byteArray2=str2.getBytes(<span class="string">"GBK"</span>);  </span><br><span class="line">  System.out.println(byteArray2.length);</span><br><span class="line">  <span class="comment">//重新用目标编码格式编码</span></span><br><span class="line">  String str3=<span class="keyword">new</span> String(byteArray2,encode);</span><br><span class="line">  System.out.println(<span class="string">"字符串："</span>+str3);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">String str1=<span class="string">"你好"</span>;</span><br><span class="line">String str2=<span class="string">"你好呀"</span>;</span><br><span class="line">test(str1,<span class="string">"UTF-8"</span>);</span><br><span class="line">test(str2,<span class="string">"UTF-8"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行结果：</p><pre><code>字符串：你好6转成GBK：浣犲ソ6字符串：你好字符串：你好呀9转成GBK：浣犲ソ鍛�9字符串：你好�?</code></pre></li></ol><p>可以看到，当用GBK暂存UTF-8编码字符串时，字符串汉字出现了乱码。</p><p>为什么会这样？</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>我们新增一个方法，将byte数组打印出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printHex</span><span class="params">(<span class="keyword">byte</span>[] byteArray)</span> </span>&#123;</span><br><span class="line">  StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">byte</span> b : byteArray) &#123;</span><br><span class="line">    sb.append(Integer.toHexString((b &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0xF</span>));</span><br><span class="line">    sb.append(Integer.toHexString(b &amp; <span class="number">0xF</span>));</span><br><span class="line">    sb.append(<span class="string">" "</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(sb.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样上面两个的运行结果分别如下：<br>ISO-8859-1:</p><pre><code>字符串：你好e4 bd a0 e5 a5 bd 转成ISO-8859-1：ä½ å¥½e4 bd a0 e5 a5 bd 字符串：你好字符串：你好呀e4 bd a0 e5 a5 bd e5 91 80 转成ISO-8859-1：ä½ å¥½åe4 bd a0 e5 a5 bd e5 91 80 字符串：你好呀</code></pre><p>GBK:</p><pre><code>字符串：你好e4 bd a0 e5 a5 bd 转成GBK：浣犲ソe4 bd a0 e5 a5 bd 字符串：你好字符串：你好呀e4 bd a0 e5 a5 bd e5 91 80 转成GBK：浣犲ソ鍛�e4 bd a0 e5 a5 bd e5 91 3f 字符串：你好�?</code></pre><p>可以看到，UTF-8转换为GBK在转换回来时，最后的80变成了3f，为什么会这样？</p><p>我们使用”你好呀” 三个字来分析，它的UTF-8 的字节流为：</p><p>[e4 bd a0] [e5 a5 bd] [e5 91 80]</p><p>我们按照三个字节一组分组，用GBK处理，因为GBK是双字节编码，如下按照两两一组进行分组：</p><p>[e4 bd] [a0 e5] [a5 bd] [e5 91] [80 ?]</p><p>不够了，怎么办？它把 0x8d当做一个未知字符，用一个半角Ascii字符的 “？” 代替，变成了：</p><p>[e4 bd] [a0 e5] [a5 bd] [e5 91] \3f</p><p>数据被破坏了。</p><p>为什么 ISO-8859-1 没问题呢？</p><p>因为 ISO-8859-1 是单字节编码，因此它的分组方案是：</p><p>[e4] [bd] [a0] [e5] [a5] [bd] [e5] [91] [80]</p><p>因此中间不做任何操作，因此数据没有变化。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>你也许会问到，比如将“你好呀”三个字先由UTF-8转为ISO-8859-1，再由ISO-8859-1转为GBK，结果也是乱码啊，不是和下面的代码一样么，性质上？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String isoFont = <span class="keyword">new</span> String(chinese.getBytes(<span class="string">"UTF-8"</span>),<span class="string">"ISO-8859-1"</span>);</span><br><span class="line">String gbkFont = <span class="keyword">new</span> String(isoFont.getBytes(<span class="string">"ISO-8859-1"</span>),<span class="string">"GBK"</span>);</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String gbkFont = <span class="keyword">new</span> String(chinese.getBytes(<span class="string">"UTF-8"</span>),<span class="string">"GBK"</span>);</span><br></pre></td></tr></table></figure><p>两者的性质确实是一样的。</p><p>那与上面说的不矛盾吗？</p><p>不矛盾。上面的代码，第一步你指定了字符串编码格式为UTF-8，第二步你将其转换为GBK，肯定会乱码。可以认为你拿一个UTF-8的字符串去转GBK字符串，其实在程序里这种写法本身是错误的！</p><p>我们来看下面一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">String chinese = <span class="string">"你好呀"</span>;</span><br><span class="line"><span class="comment">//GBK 测试</span></span><br><span class="line">String gbkChinese = <span class="keyword">new</span> String(chinese.getBytes(<span class="string">"GBK"</span>),<span class="string">"ISO-8859-1"</span>);</span><br><span class="line">System.out.println(gbkChinese);</span><br><span class="line">printHex(gbkChinese.getBytes(<span class="string">"ISO-8859-1"</span>));</span><br><span class="line">String gbkTest = <span class="keyword">new</span> String(gbkChinese.getBytes(<span class="string">"ISO-8859-1"</span>),<span class="string">"GBK"</span>);</span><br><span class="line">System.out.println(gbkTest);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//UTF-8测试</span></span><br><span class="line">String utf8Chinese = <span class="keyword">new</span> String(chinese.getBytes(<span class="string">"UTF-8"</span>),<span class="string">"ISO-8859-1"</span>);</span><br><span class="line">System.out.println(utf8Chinese);</span><br><span class="line">printHex(utf8Chinese.getBytes(<span class="string">"ISO-8859-1"</span>));</span><br><span class="line">String utfTest = <span class="keyword">new</span> String(utf8Chinese.getBytes(<span class="string">"ISO-8859-1"</span>),<span class="string">"UTF-8"</span>);</span><br><span class="line">System.out.println(utfTest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><pre><code>ÄãºÃÑ½c4 e3 ba c3 d1 bd 你好呀ä½ å¥½åe4 bd a0 e5 a5 bd e5 91 80 你好呀</code></pre><p>可以看到，</p><p>GBK分组 ：[c4 e3]–&gt;你 [ba c3]–&gt;好 [d1 bd]–&gt;呀</p><p>UTF-8分组：[e4 bd a0]–&gt;你 [e5 a5 bd]–&gt;好 [e5 91 80]–&gt;呀</p><p>字符串“你好呀”在GBK编码和UTF-8编码里生成的byte数据流是不一样的。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>所以如何正确将两种编码格式数据进行转换？</p><p><strong>注意：这儿的转换指的是这样，比如一个GBK编码文件，里面有“你好呀”字符串，写入到UTF-8编码文件里仍然是“你好呀”。</strong></p><p>我们新建一个GBK编码文件，里面有你好呀，三个字符，同时将三个字用UTF-8，写入到另一个文件里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">String line = readInFile(<span class="string">"/Users/zhangwentong/junrongdai/gbk.txt"</span>, <span class="string">"GBK"</span>);</span><br><span class="line">System.out.println(line);</span><br><span class="line">writeInFile(<span class="string">"/Users/zhangwentong/junrongdai/utf8.txt"</span>, line, <span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readInFile</span><span class="params">(String fileName, String charset)</span> </span>&#123;</span><br><span class="line">File gbkfile = <span class="keyword">new</span> File(fileName);</span><br><span class="line">String line = <span class="string">""</span>;</span><br><span class="line">FileInputStream gbkIO = <span class="keyword">null</span>;</span><br><span class="line">InputStreamReader gbkISR = <span class="keyword">null</span>;</span><br><span class="line">BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">gbkIO = <span class="keyword">new</span> FileInputStream(gbkfile);</span><br><span class="line">gbkISR = <span class="keyword">new</span> InputStreamReader(gbkIO, charset);</span><br><span class="line">br = <span class="keyword">new</span> BufferedReader(gbkISR);</span><br><span class="line">String rline = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">while</span> ((rline = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">line += rline;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(br!=<span class="keyword">null</span>) fos.close();</span><br><span class="line">                    <span class="keyword">if</span>(gbkISR!=<span class="keyword">null</span>) gbkISR.close();</span><br><span class="line">                    <span class="keyword">if</span>(gbkIO!=<span class="keyword">null</span>) gbkIO.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> line;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeInFile</span><span class="params">(String fileName, String content, String charset)</span> </span>&#123;</span><br><span class="line">File f = <span class="keyword">new</span> File(fileName);</span><br><span class="line">FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!f.exists()) &#123;</span><br><span class="line">f.createNewFile();</span><br><span class="line">&#125;</span><br><span class="line">fos = <span class="keyword">new</span> FileOutputStream(f);</span><br><span class="line">fos.write(content.getBytes(charset));</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (fos != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">fos.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以测试下上段代码，GBK文字被转为了UTF-8文字。反过来一个UTF-8文件写入到GBK也是可以实现的。</p><p><strong>所以，在读取和写入文字时，指定文字的编码格式，再进行读取和写入操作，便不会有乱码的产生。否则读取和写入时会按照执行操作的class文件的编码格式进行写入和读取。</strong></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>欢迎光临我的博客</p><p><a href="https://www.sakuratears.top">https://www.sakuratears.top</a></p><p>我的GitHub地址</p><p><a href="https://github.com/javazwt" target="_blank" rel="noopener">https://github.com/javazwt</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在开发过程中，我们可能会遇到Java各种编码格式之间的转换问题。下面我们来研究下UTF-8和GBK等编码格式之间的相互转化。&lt;/p&gt;
&lt;h1
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>HashMap实现原理</title>
    <link href="https://www.sakuratears.top/blog/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%8620180616/"/>
    <id>https://www.sakuratears.top/blog/HashMap实现原理20180616/</id>
    <published>2018-06-16T05:17:00.000Z</published>
    <updated>2018-06-21T14:06:45.233Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天我们来聊聊HashMap。</p><p>Java集合类里的HashMap，实现Map接口，是个非线程安全的类。HashMap允许key和value有null值，且循环遍历为无序的，HashMap底层主要是通过数组+链表实现的，同时JDK8引入红黑树优化，提高HashMap的性能。</p><p>要了解HashMap，我们可以从几方面下手。</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>我们先来看下HashMap的两个参数：</p><pre><code>initialCapacity：初始容量，默认16loadFactor：负载因子，默认0.75</code></pre><p>现在我们执行了下面一段代码，根据代码来分析HashMap：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"0"</span>,<span class="string">"0"</span>);</span><br></pre></td></tr></table></figure><p>创建一个HashMap，其会初始化以下数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure><ol><li><strong>DEFAULT_INITIAL_CAPACITY</strong>: 初始容量，也就是默认会创建 16 个箱子，箱子的个数不能太多或太少。如果太少，很容易触发扩容，如果太多，遍历哈希表会比较慢。</li><li><strong>MAXIMUM_CAPACITY</strong>: 哈希表最大容量，一般情况下只要内存够用，哈希表不会出现问题。</li><li><strong>DEFAULT_LOAD_FACTOR</strong>: 默认的负载因子。因此初始情况下，当键值对的数量大于 16 * 0.75 = 12 时，就会触发扩容。</li><li><strong>TREEIFY_THRESHOLD</strong>: 如果哈希函数不合理，即使扩容也无法减少箱子中链表的长度，因此处理方案是当链表太长时，转换成红黑树。这个值表示当某个箱子中，链表长度大于 8 时，有可能会转化成树。</li><li><strong>UNTREEIFY_THRESHOLD</strong>: 在哈希表扩容时，如果发现链表长度小于 6，则会由树重新退化为链表。</li><li><strong>MIN_TREEIFY_CAPACITY</strong>: 在转变成树之前，还会有一次判断，只有键值对数量大于 64 才会发生转换。这是为了避免在哈希表建立初期，多个键值对恰好被放入了同一个链表中而导致不必要的转化。</li></ol><p>根据HashMap源码，可以看到源码中有两个static final class  Node &lt; K,V &gt; 和 TreeNode &lt; K,V &gt;分别为链表和红黑树链表。</p><p>本文不对红黑树链表的实现做过多分析。</p><p><strong>我们来看下HashMap的put方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//put方法，调用putVal方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//HashMap放值方法</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//构建一个链表数组tab，链表p，长度n，索引i</span></span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">       <span class="comment">//把table的值赋给tab，如果tab是空或者长度为0</span></span><br><span class="line">       <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">       <span class="comment">//调用resize方法，并获得tab长度</span></span><br><span class="line">           n = (tab = resize()).length;</span><br><span class="line">       <span class="comment">//计算索引并获得tab索引下的值，如果为空直接将值添加</span></span><br><span class="line">       <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">           tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           Node&lt;K,V&gt; e; K k;</span><br><span class="line">           <span class="comment">//如果key值相同，直接替换value值</span></span><br><span class="line">           <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">               ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">               e = p;</span><br><span class="line">           <span class="comment">//如果key不相同，判断p是不是TreeNode，是的话就执行红黑树放入值操作</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">               e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                   <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="comment">//如果key上没值就放入普通链表</span></span><br><span class="line">                       p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                       <span class="comment">//如果链表长度超了8</span></span><br><span class="line">                       <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                       <span class="comment">//尝试将链表转化为红黑树（不一定会转化）</span></span><br><span class="line">                           treeifyBin(tab, hash);</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//如果key上有值就覆盖掉value</span></span><br><span class="line">                   <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                       ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   p = e;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//如果节点value不为空，即key上有值，把这个值返回去</span></span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                   e.value = value;</span><br><span class="line">               afterNodeAccess(e);</span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//记录改变次数（fast-fail机制）</span></span><br><span class="line">       ++modCount;</span><br><span class="line">       <span class="comment">//如果长度超过当前，就进行扩容操作</span></span><br><span class="line">       <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">           resize();</span><br><span class="line">       afterNodeInsertion(evict);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>我们再来看下，resize方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line"><span class="comment">//获取旧的tab</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">//旧的容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">//旧的阀值</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//如果容量超了MAXIMUM_CAPACITY，最大阀值定为Integer.MAX_VALUE</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果新容量赋值后小于MAXIMUM_CAPACITY并且旧容量不小于初始值</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果定义了初始容量</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">    <span class="comment">//否则为初始化，所有均为默认值</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//为新的阀值赋值</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>HashMap的get方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//调用getNode方法</span></span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取HashMap Value值</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//先判断链表第一个值是不是结果</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">//否则循环链表找值</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>我们看一下hash获取方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码的意思是：如果Key值为null，返回0；如果Key值不为空，返回原hash值和原hash值无符号右移16位的值按位异或的结果。可以看到当key=null时，hash为0.</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol><li><p><strong>为什么HashMap的初始长度默认16，负载因子默认0.75，且长度建议取2的倍数？</strong></p><p>&ensp;&ensp;&ensp;&ensp; 通过以上的代码我们可以知道这两个值主要影响的threshold的大小，这个值的数值是当前桶数组需不需要扩容的边界大小，我们都知道桶数组如果扩容，会申请内存空间，然后把原桶中的元素复制进新的桶数组中，这是一个比较耗时的过程。既然这样，那为何不把这两个值都设置大一些呢，threshold是两个数的乘积，设置的大些不就减小了扩容次数吗？<br> &ensp;&ensp;&ensp;&ensp; 原因是这样的，如果桶初始化桶数组设置太大，就会浪费内存空间，16是一个折中的大小，既不会像1，2，3那样放几个元素就扩容，也不会像几千几万那样可以只会利用一点点空间从而造成大量的浪费。<br> &ensp;&ensp;&ensp;&ensp; 加载因子设置为0.75而不是1，是因为设置过大，桶中键值对碰撞的几率就会越大，同一个桶位置可能会存放好几个value值，这样就会增加搜索的时间，性能下降，设置过小也不合适，如果是0.1，那么10个桶，threshold为1，你放两个键值对就要扩容，太浪费空间了。<br> &ensp;&ensp;&ensp;&ensp; HashMap为了存取高效，要尽量较少碰撞，就是要尽量把数据分配均匀，每个链表长度大致相同，这个实现就在把数据存到哪个链表中的算法；这个算法实际就是取模，hash%length，计算机中直接求余效率不如位移运算，源码中做了优化hash&amp;(length-1)，hash%length==hash&amp;(length-1)的前提是length是2的n次方；为什么这样能均匀分布减少碰撞呢？<br>&ensp;&ensp;&ensp;&ensp; 2的n次方实际就是1后面n个0，2的n次方-1  实际就是n个1；例如长度为9时候，3&amp;(9-1)=0  2&amp;(9-1)=0 ，都在0上，碰撞了；例如长度为8时候，3&amp;(8-1)=3  2&amp;(8-1)=2 ，不同位置上，不碰撞；</p></li><li><p><strong>HashMap的fast-fail机制？</strong></p><p> &ensp;&ensp;&ensp;&ensp; 在put方法里，我们注意到一个参数，modCount，每当HashMap改变，modCount都会改变,在HashMap的remove，clear等对HashMap的变动操作中，都可以看到对此参数的操作，同时我们还能看到如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br></pre></td></tr></table></figure><p> &ensp;&ensp;&ensp;&ensp; 这就是HashMap的fast-fail机制，HashMap会记录Map的改变次数，如果多个线程操作HashMap，会导致modCount和expectedModCount不一致，就会抛出ConcurrentModificationException异常，说明你的代码里有多线程对HashMap的操作，这是不被允许的，这样也可以快速检索程序错误，但是我们不能指望HashMap的fast-fail机制来检索错误，我们更应该在编码中注意HashMap是线程不安全的，多线程情况可以考虑ConcurrentHashMap,Hashtable或者使用Collections.synchronizedMap(map)等操作。</p></li></ol><h1 id="深度分析"><a href="#深度分析" class="headerlink" title="深度分析"></a>深度分析</h1><ol><li><p><strong>关于hash桶索引计算函数 i=(n-1)&amp;hash 好处。</strong></p><p> &ensp;&ensp;&ensp;&ensp; 观察HashMap将元素放入tab操作如下图，n在1处被赋值为tab.length，在2处，有一个关键算法，i=(n-1)&amp;hash,i为tab下标，这样做有什么好处呢？</p><p> <strong>（1）保证不会发生数组越界</strong></p><p> &ensp;&ensp;&ensp;&ensp; 首先我们要知道的是，在HashMap，数组的长度按规定是2的幂。因此，数组的长度的二进制形式是：10000…000, 1后面有偶数个0。 那么，length - 1 的二进制形式就是01111…111, 0后面有偶数个1。最高位是0, 和hash值相“与”，结果值一定不会比数组的长度值大，因此也就不会发生数组越界。</p><p> <strong>（2）保证元素尽可能的均匀分布</strong></p><p> &ensp;&ensp;&ensp;&ensp; 由上边的分析可知，length若是一个偶数，length - 1一定是一个奇数。假设现在数组的长度length为16，减去1后length - 1就是15，15对应的二进制是：1111。现在假设有两个元素需要插入，一个哈希值是8，二进制是1000，一个哈希值是9，二进制是1001。和1111“与”运算后，结果分别是1000和1001，它们被分配在了数组的不同位置，这样，哈希的分布非常均匀。那么，如果数组长度是奇数呢？减去1后length - 1就是偶数了，偶数对应的二进制最低位一定是 0，例如14二进制1110。对上面两个数子分别“与”运算，得到1000和1000。结果都是一样的值。那么，哈希值8和9的元素都被存储在数组同一个index位置的链表中。在操作的时候，链表中的元素越多，效率越低，因为要不停的对链表循环比较。</p><p> <img src="/images/pasted-14.png" alt="upload successful"></p></li><li><p><strong>关于”扰动函数”，(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16) ？</strong></p><p> &ensp;&ensp;&ensp;&ensp; 在对数据进行hash计算时，可以看到，不仅仅是取了数据的hashCode，而是将hashCode和hashCode无符号右移16位的值进行异或运算。</p><p><img src="/images/pasted-16.png" alt="upload successful"></p><p>&ensp;&ensp;&ensp;&ensp; 我们知道，key.hashCode返回一个int值，这个值一般比hash桶数组长度要大，比如一个长度为16的hash桶，放入String abc (hashCode为96354)，直接进行桶索引计算，i=(n-1)&amp;hashCode 可以得出(15&amp;96354)=2,索引值为2，如果是abcd，计算（15&amp;2987074）=2，索引值也为2。</p><p> <img src="/images/pasted-18.png" alt="upload successful"></p><p> &ensp;&ensp;&ensp;&ensp; 可以看出，即使hashCode散列再离散，计算索引值时低位才是主要影响原因，而特征较大的高位（96354和2987074高位特征较大）根本不参与运算，这样hash冲突也会较高。而右移16位（32位的一半，int最大32位），正好为32位一半，这样可以把前16位认为高位，后16位认为低位，然后进行异或操作，高16位的信息被变相保存了下来，增大了随机性。</p><p> <img src="/images/pasted-19.png" alt="upload successful"></p><p> &ensp;&ensp;&ensp;&ensp; 可以看出这样操作后abc的下标为3（二进制11），abcd的下标为15（二进制1111）。</p><p> &ensp;&ensp;&ensp;&ensp; Peter Lawrey有一篇关于hash冲突率比较的文章《An introduction to optimising a hashing strategy》，大家可以看看。</p><p> &ensp;&ensp;&ensp;&ensp; <a href="https://www.javacodegeeks.com/2015/09/an-introduction-to-optimising-a-hashing-strategy.html" target="_blank" rel="noopener">https://www.javacodegeeks.com/2015/09/an-introduction-to-optimising-a-hashing-strategy.html</a></p><p> <img src="/images/pasted-20.png" alt="upload successful"></p></li><li><p><strong>为什么引入负载因子这个概念？</strong></p><p> &ensp;&ensp;&ensp;&ensp; 负载因子的引入，可以来说是时间复杂度和空间复杂度的折中。（大数据统计下）负载因子越低，一般认为空间开销越大，查询时间开销越低（hash碰撞低），大量hash数组，少量链表；负载因子越高，一般认为空间开销越低，查询时间开销越高（hash碰撞高），少量hash桶数组，大量链表。负载因子的引入恰可以增加HashMap不同场景使用的灵活性。</p></li></ol><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>欢迎光临我的博客</p><p><a href="https://www.sakuratears.top">https://www.sakuratears.top</a></p><p>我的GitHub地址</p><p><a href="https://github.com/javazwt" target="_blank" rel="noopener">https://github.com/javazwt</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天我们来聊聊HashMap。&lt;/p&gt;
&lt;p&gt;Java集合类里的HashMap，实现Map接口，是个非线程安全的类。HashMap允许key
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java线程池</title>
    <link href="https://www.sakuratears.top/blog/Java%E7%BA%BF%E7%A8%8B%E6%B1%A020180610/"/>
    <id>https://www.sakuratears.top/blog/Java线程池20180610/</id>
    <published>2018-06-10T03:59:00.000Z</published>
    <updated>2018-06-12T14:48:22.594Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java中，创建线程的方式一般有三种方法：</p><ol><li><p>继承Thread类创建线程</p></li><li><p>实现Runnable接口创建线程</p></li><li><p>使用Callable和Future创建线程</p></li></ol><p>关于三种创建方法本文不再赘述。</p><p>可以看出，以上创建线程的方式，都缺乏对线程的管理，我们设想，如果线程在调用过程中使用了某一资源，当该资源处理缓慢或异常时，可能产生大量线程等待的情况，严重时可能造成OOM异常。</p><p>针对以上情况，应该对创建线程进行管理，这样线程池便产生了，好在在jdk1.5时，Doug Lea大神已经帮我们实现了这些功能，它们均在java.util.concurrent包下。建议大家想学习多线程，把该包下的源码理解，一定对多线程会有更深入的理解。</p><p>本文重点讲述线程池，会对以下这几个类（接口）进行重点讲解。</p><p><strong>Executor，ExecutorService，Executors，AbstractExecutorService，ThreadPoolExecutor</strong></p><h1 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h1><p>我们先来简单说下线程池的使用：</p><ol><li><p>缓存型线程池</p><p> 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。<br> Executors.newCachedThreadPool</p><p> 简单使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">cachedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Thread id="</span> + Thread.currentThread().getId() + <span class="string">";index="</span> + index);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定长线程池</p><p> 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。<br> Executors.newFixedThreadPool</p><p> 简单使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">fixedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"Thread id="</span> + Thread.currentThread().getId() + <span class="string">";index="</span> + index);</span><br><span class="line">Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>定时及周期性任务性线程池</p><p>  创建一个定长线程池，支持定时及周期性任务执行。<br>  Executors.newScheduledThreadPool</p><p> 简单使用：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">scheduledThreadPool.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Thread id="</span>+Thread.currentThread().getId()+<span class="string">";5s后,每2s执行一次"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="number">5</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><ol start="4"><li><p>单线程型线程池</p><p> 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。<br> Executors.newSingleThreadExecutor</p><p> 简单使用：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">singleThreadExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"Thread id="</span>+Thread.currentThread().getId()+<span class="string">";index="</span>+index);</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><p>自定义线程池</p><p> 创建一个自定义线程池，以优化线程池。</p><p> 根据Executors源码，可以看出：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 线程池的实现使用ThreadPoolExecutor这个类实现的。这个类全参参数有以下几个：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                         TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                         BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                         ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                         RejectedExecutionHandler handler)</span> </span>&#123;</span><br></pre></td></tr></table></figure><p> ① corePoolSize：核心线程池大小<br>    取值范围 0-Integer.MaxValue<br> ② maximumPoolSize：最大线程池大小<br>    取值范围 0-Integer.MaxValue<br> ③ keepAliveTime：线程空闲时存活时间<br> ④ unit：线程空闲时存活时间单位<br> ⑤ workQueue：工作队列类型，线程队列类型<br> 队列分类：<br> 直接提交策略：SynchronousQueue，其无法设置队列长度，所有线程均直接提交给线程池。<br> 无界队列：LinkedBlockingQueue，如果默认不设置初始长度，这个队列是无界的，可缓存大量等待线程。<br> 有界队列：ArrayBlockingQueue，必须设置初始长度，线程池满，且达到队列最大长度后执行拒绝策略。<br> ⑥ threadFactory：线程工厂<br> ⑦ handler：线程池饱和后的拒绝策略<br>     ThreadPoolExecutor定义了四种，我们也可以自己定义：<br>         ThreadPoolExecutor.AbortPolicy：拒绝该任务并抛出异常<br>         ThreadPoolExecutor.CallerRunsPolicy：直接在 execute 方法的调用线程中运行被拒绝的任务；如果执行程序已关闭，则会丢弃该任务<br>         ThreadPoolExecutor.DiscardOldestPolicy：直接丢弃正在执行的任务，并执行该任务<br>         ThreadPoolExecutor.DiscardPolicy：丢弃该任务   </p><p> 可以看出，当业务情况复杂时，Executors里提供的几种基本的线程池已经不能满足我们的要求，需要我们根据情况自定义线程池，而且可以举个例子，比如对于newCachedThreadPool创建线程池的方法，它传入的maximumPoolSize为Integer的Max值，如果业务资源异常，创建大量线程而不释放，newCachedThreadPool这种创建线程池的方法也能导致OOM异常。</p><p> 而我们声明最大线程池大小，并声明拒绝策略。如下：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService myExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line"><span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">5</span>), <span class="keyword">new</span> AbortPolicy());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">myExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Thread id="</span> + Thread.currentThread().getId() + <span class="string">";index="</span> + index);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">10000000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 可以有效防止OOM异常以及及时发现系统运行问题。</p><p> 自定义线程池也是被推荐的创建线程池的方法。</p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>下面我们主要对ThreadPoolExecutor这个类进行分析。</p><p>我们先看下它的execute方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//获取线程数量</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">//如果线程池线程数量小于核心线程数，那么试着向核心线程池添加一个线程</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">    <span class="comment">//添加成功就返回</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//添加不成功就再次拿到线程数量</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果添加失败了，或者线程池数量达到了核心线程池数量</span></span><br><span class="line">    <span class="comment">//那么判断下运行状态，然后试着向工作等待队列里添加此线程</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">//如果不是运行状态，那么试着从工作队列移除此线程</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">        <span class="comment">//成功就进行拒绝策略处理</span></span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">//如果核心线程池和队列都满了，达到CAPACITY</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//那么尝试将任务添加至非核心线程池</span></span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果添加失败，执行拒绝策略</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看下addWorker方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">//sakuratears</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">//拿下线程运行状态</span></span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">        <span class="comment">//如果程序停止或者状态不是暂停并且任务不为空并且任务队列不为空，添加失败</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">//数量大于CAPACITY或者数量大于corePoolSize（向核心线程池添加时）或者maximumPoolSize（向非核心线程池添加时），返回添加失败</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//试着计算下当前线程数量</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">            <span class="comment">//成功跳出循环</span></span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            <span class="comment">//不成功就重读ctl</span></span><br><span class="line">            c = ctl.get(); </span><br><span class="line">            <span class="comment">//如果当前状态与开始线程状态不一致</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">            <span class="comment">//重试循环</span></span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//获得锁</span></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        <span class="comment">//创建一个新的Worker</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"><span class="comment">//如果是运行状态，或者核心线程池暂停，但要将线程添加到非核心线程池中</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) </span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    <span class="comment">//添加线程</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="comment">//记录曾经有过的最大线程数</span></span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//解锁</span></span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">            <span class="comment">//启动</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">        <span class="comment">//线程启动失败，执行失败操作</span></span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多代码不一一赘述。上面代码基本是线程池的核心原理。</p><p>通俗点讲，线程池工作分为下面几步：</p><ol><li>根据传入参数，设置核心线程池数量，最大线程池数量，拒绝策略，线程工作队列</li><li>当添加一个线程时，如果线程池线程数小于核心线程数，直接开启一个新线程执行任务。</li><li>如果核心线程池满了，那么把它添加到工作队列中。</li><li>如果核心线程池和工作队列都满了，则开启非核心线程执行任务。</li><li>如果全部都满了，执行拒绝策略。</li></ol><p>以上就是对线程池的全部分析。</p><h1 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h1><p>我的个人博客：</p><p><a href="https://www.sakuratears.top">https://www.sakuratears.top</a></p><p>GitHub地址：</p><p><a href="https://github.com/javazwt" target="_blank" rel="noopener">https://github.com/javazwt</a></p><p>欢迎关注。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Java中，创建线程的方式一般有三种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;继承Thread类创建线程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>未闻花名</title>
    <link href="https://www.sakuratears.top/blog/%E6%9C%AA%E9%97%BB%E8%8A%B1%E5%90%8D20180609/"/>
    <id>https://www.sakuratears.top/blog/未闻花名20180609/</id>
    <published>2018-06-09T14:30:00.000Z</published>
    <updated>2018-06-14T15:14:58.801Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/show1.jpg" alt="upload successful"><br><a id="more"></a></p><blockquote><hr></blockquote><center>已知花意</center><br><center>未见其花</center><br><center>已见其花</center><br><center>未闻花名</center><br><center>再见其花</center><br><center>落泪千溟</center><br><center>未闻花名</center><br><center>但识花香</center><br><center>已知花名</center><br><center>花已不在</center><br><center>未闻花名</center><br><center>但识花香</center><br><center>再遇花时</center><br><center>泪已千行</center><p><br></p><blockquote><hr></blockquote><blockquote><p>某天，你无端想起一个人，她曾让你对明天有所期许，但她却完全没有出现在你的明天里。————《再见金华站》</p></blockquote><blockquote><hr></blockquote><center>浮生若梦</center><br><center>似梦非梦</center><br><center>爱你如初</center><br><center>惜你如命</center><blockquote><hr></blockquote><blockquote><p>不离开，这辈子，下辈子，下下辈子都不离开你。</p></blockquote><blockquote><hr></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/show1.jpg&quot; alt=&quot;upload successful&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://www.sakuratears.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>MarkDown语法</title>
    <link href="https://www.sakuratears.top/blog/MarkDown%E8%AF%AD%E6%B3%9520180605/"/>
    <id>https://www.sakuratears.top/blog/MarkDown语法20180605/</id>
    <published>2018-06-05T14:17:00.000Z</published>
    <updated>2018-06-12T14:48:43.114Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近自己搭建了一个博客网站，写文章时用到了markdown语法，之前虽未接触过markdown语法，但在两三天的使用过程中感觉markdown语法很棒，写法简洁，而且支持Html语言。特总结一些常用的语法如下：</p><h2 id="语法汇总"><a href="#语法汇总" class="headerlink" title="语法汇总"></a>语法汇总</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>markdown有6种标题，写法如下：</p><table><thead><tr><th>级别</th><th style="text-align:center">写法</th></tr></thead><tbody><tr><td>1级</td><td style="text-align:center"># 大标题</td></tr><tr><td>2级</td><td style="text-align:center">## 前言</td></tr><tr><td>3级</td><td style="text-align:center">### 语法汇总</td></tr><tr><td>4级</td><td style="text-align:center">#### 标题</td></tr><tr><td>5级</td><td style="text-align:center">##### 标题5</td></tr><tr><td>6级</td><td style="text-align:center">###### 标题6</td></tr></tbody></table><p><strong>注意：</strong>#号和文字之间有空格</p><h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><p>写完一段话，一般空出一行便可以分为两个段落，如果不主动空行，其便会认为为一个段落。<br>也可以在一段话的结束输入两个空格，markdown也会换行。</p><p><strong>注意：</strong>这两种换行，第一种间距大。我现在这段话分别用了空格换行和空行换行。</p><h3 id="tab键"><a href="#tab键" class="headerlink" title="tab键"></a>tab键</h3><pre><code>这是一段用了tab缩进的话。    这是用了两个tab缩进的话。这是一段很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长的话。</code></pre><p><strong>注意：</strong>当一段话过长时，这样生成的句子可能不换行，而是在下面有一个拉动条。</p><h3 id="资源引用"><a href="#资源引用" class="headerlink" title="资源引用"></a>资源引用</h3><ol><li><p>引用静态资源时，如img，png，gif等</p><p> 语法：![图片名称](图片的绝对路径或者相对路径)</p><pre><code>![upload successful](/images/pasted-10.png)</code></pre></li><li><p>引用网址时，直接贴上网址就能识别</p><p> 我的博客：<a href="https://javazwt.github.io/" target="_blank" rel="noopener">https://javazwt.github.io/</a></p></li></ol><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>语法：</p><pre><code>| Name        |      Value   | |-------------|:-----------: || sakuratears |  999999      |  </code></pre><p>效果：</p><table><thead><tr><th>Name</th><th style="text-align:center">Value</th></tr></thead><tbody><tr><td>sakuratears</td><td style="text-align:center">999999</td></tr></tbody></table><p><strong>注意：</strong>在表头下方的分隔线标记中加入 :，即可标记下方单元格内容的对齐方式，默认左对齐：</p><p>:— 代表左对齐<br>:–: 代表居中对齐<br>—: 代表右对齐</p><table><thead><tr><th style="text-align:left">left（:— ）</th><th style="text-align:center">center（:—-: ）</th><th style="text-align:right">right（ —-:）</th></tr></thead><tbody><tr><td style="text-align:left">left</td><td style="text-align:center">center</td><td style="text-align:right">right</td></tr></tbody></table><h3 id="加粗-斜体-删除线"><a href="#加粗-斜体-删除线" class="headerlink" title="加粗 斜体 删除线"></a>加粗 斜体 删除线</h3><p>加粗语法： **要加粗的字**</p><p>加粗效果： <strong>要加粗的字</strong></p><p>斜体语法：*斜体的字*</p><p>斜体效果： <em>斜体的字</em></p><p>删除线语法： ~~要删除的字~~</p><p>删除线效果： <del>要删除的字</del></p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>如果需要引用文献资料或者别的引用，可以用大于号解决：</p><p>语法：&gt;要引用的文字</p><p>效果：</p><blockquote><p>要引用的文字</p></blockquote><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><p>语法：在指定序号后面加上点（.） 并空格 </p><pre><code>1. aaa2. bbb3. ccc</code></pre><p>效果：</p><ol><li>aaa</li><li>bbb</li><li>ccc</li></ol><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><p>语法：在文字前面加上* 或者 + 或者 - 并空格</p><pre><code>* aaa* bbb* ccc</code></pre><p>效果：</p><ul><li>aaa</li><li>bbb</li><li>ccc</li></ul><p><strong>注意：</strong> 如果生成多级列表，可以这样：</p><pre><code>- 1.a    - 1.1.aa        - 1.1.1.aaa- 2.b- 3.c</code></pre><p>效果图：</p><ul><li>1.a<ul><li>1.1.aa<ul><li>1.1.1.aaa</li></ul></li></ul></li><li>2.b</li><li>3.c</li></ul><h3 id="代码支持"><a href="#代码支持" class="headerlink" title="代码支持"></a>代码支持</h3><p>语法：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//代码片段</span><br></pre></td></tr></table></figure></code></pre><p>效果：一段java代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"Hello World"</span>);</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>由于Markdown支持Html语法，故Markdown以上无法实现的可以借助Html实现，如居中实现：</p><pre><code>&lt;center&gt;这段话要居中&lt;/center&gt;</code></pre><p>效果：<center>这段话要居中</center></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近自己搭建了一个博客网站，写文章时用到了markdown语法，之前虽未接触过markdown语法，但在两三天的使用过程中感觉markdow
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="MarkDown" scheme="https://www.sakuratears.top/tags/MarkDown/"/>
    
  </entry>
  
  <entry>
    <title>Html5+JQuery页面标签的禁用问题</title>
    <link href="https://www.sakuratears.top/blog/Html5-JQuery%E9%A1%B5%E9%9D%A2%E6%A0%87%E7%AD%BE%E7%9A%84%E7%A6%81%E7%94%A8%E9%97%AE%E9%A2%9820180604/"/>
    <id>https://www.sakuratears.top/blog/Html5-JQuery页面标签的禁用问题20180604/</id>
    <published>2018-06-04T15:17:00.000Z</published>
    <updated>2018-06-12T14:48:55.221Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在做移动应用项目时遇到的问题，完成某些操作后返回到前面页面要保证前面页面的标签内容不可被编辑，修改。有如下方法：</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ol><li><p>对于input，select框，设置disabled=’disabled’。</p><p> 如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#testid1 input'</span>).attr(<span class="string">'disabled'</span>,<span class="string">'disabled'</span>);</span><br><span class="line">$(<span class="string">'#testid2 select'</span>).attr(<span class="string">'disabled'</span>,<span class="string">'disabled'</span>);</span><br></pre></td></tr></table></figure></li><li><p>对于一些点击触发事件的button，可以用unbind()移除事件方法。</p><p> 如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">".testclass3"</span>).unbind();</span><br></pre></td></tr></table></figure><p> 注：在某些情况下unbind慎用，如页面初始化时调用click事件加载其他事件属性，unbind()可能会导致初始化时无法加载。</p></li><li><p>插件禁用，有些页面可能使用某些插件，对于插件的禁用，可以设置插件的事件方法return false;</p><p> 如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#test #test4"</span>).on(<span class="string">"touchmove"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p> 这个是我们项目一个滑动插件触摸禁用的例子。</p></li><li><p>对于一些比较特殊的，如li标签，可以使用class样式进行处理。</p><p> 这是一个两个li标签切换禁用的例子。</p><p> 例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#test_li"</span>).addClass(<span class="string">'disabledTab'</span>);</span><br><span class="line">.disabledTab&#123;</span><br><span class="line">   pointer-events: none;<span class="comment">//这样鼠标或触摸就无法选中li标签</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在做移动应用项目时遇到的问题，完成某些操作后返回到前面页面要保证前面页面的标签内容不可被编辑，修改。有如下方法：&lt;/p&gt;
&lt;h2 id=&quot;方
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="JavaScript" scheme="https://www.sakuratears.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>阿里云主机环境搭建</title>
    <link href="https://www.sakuratears.top/blog/%E9%98%BF%E9%87%8C%E4%BA%91%E4%B8%BB%E6%9C%BA%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA20180604/"/>
    <id>https://www.sakuratears.top/blog/阿里云主机环境搭建20180604/</id>
    <published>2018-06-04T15:00:00.000Z</published>
    <updated>2018-06-12T14:49:09.339Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>现在很多服务都部署在云服务上，最近项目也要发布到云上，特写此文章。有需要部署云服务的小伙伴可以参考下。</p><h2 id="云主机参数"><a href="#云主机参数" class="headerlink" title="云主机参数"></a>云主机参数</h2><p>在部署云服务时，一般需要知道如下参数：</p><ol><li>云ECS主机服务器远程连接：<br> url       XXXXXXXX<br> 用户名：XXXXXXX<br> 密码：XXXXXXX<br> 超级管理员：用户名：XXXX    密码  ：XXXX    </li><li>硬件配置：<br> 实例规格：2 核 4GB<br> 网络：带宽 5Mbps<br> 操作系统：Ubuntu 16.04 64位<br> 系统盘：高效云盘（100 GB）</li></ol><h2 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h2><h3 id="远程连接工具"><a href="#远程连接工具" class="headerlink" title="远程连接工具"></a>远程连接工具</h3><ol><li>XShell连接工具  </li><li>Xftp文件上传管理工具  </li><li>两工具下载地址：<a href="https://www.netsarang.com/products/xsh_overview.html" target="_blank" rel="noopener">https://www.netsarang.com/products/xsh_overview.html</a></li><li>其他说明：由于当前Ubuntu 16.04 64位 Linux系统弃用了一些旧的远程ssh加密方式，故原先的ssh2工具不能连接，当然也可以修改linux配置文件使其支持旧的ssh加密方式，详见<a href="http://blog.csdn.net/liucky/article/details/51889112" target="_blank" rel="noopener">http://blog.csdn.net/liucky/article/details/51889112</a> 等文章。本服务器未修改也不建议修改linux配置，进而选择使用XSHell等工具连接。</li></ol><h3 id="服务器搭建工具"><a href="#服务器搭建工具" class="headerlink" title="服务器搭建工具"></a>服务器搭建工具</h3><ol><li>Linux 64位  jdk压缩包      jdk-7u79-linux-x64.tar.gz</li><li>Tomcat压缩包 For Linux 64     apache-tomcat-7.0.79.tar.gz</li><li>Linux 64位 Mysql 安装包    （在线安装可不使用）  mysql-5.7.19-linux-glibc2.12-x86_64.tar.gz</li><li>编译好的项目    demo</li><li>数据库表  demo</li></ol><h2 id="连接云主机"><a href="#连接云主机" class="headerlink" title="连接云主机"></a>连接云主机</h2><ol><li><p>连接到Linux服务器</p><p> 打开XShell，输入前面的云主机配置，连接到Linux远程服务器。如图：</p></li></ol><p><img src="/images/pasted-8.png" alt="upload successful"></p><ol start="2"><li><p>登录成功后如图</p><p> 使用 pwd 命令可查看当前路径</p><p> 目前/home   文件夹下已使xxxxxx用户拥有读、写、执行的权限</p></li></ol><p><img src="/images/pasted-9.png" alt="upload successful"></p><h2 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h2><ol><li><p>进入/home文件夹</p><p> 我们在其目录下建三个文件夹jdk,mysql,tomcat用于存放文件</p></li><li><p>创建文件夹，可以使用 mkdir  文件夹名   这种方式，也可以直接打开xftp 创建，如图：</p></li></ol><p><img src="/images/pasted-10.png" alt="upload successful"></p><ol start="3"><li><p>上传并解压</p><p> 通过Xftp将 jdk，tomcat，mysql，项目包demo，数据表全部传上去</p><p> 对于tar.gz文件进行解压</p><p> tar -xzvf jdk-7u79-linux-x64.tar.gz</p><p> 注意：项目demo要放到tomcat  webapps目录下，故建议将tomcat</p><p> 解压后再上传demo项目</p></li></ol><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><ol><li>找到jdk路径</li><li><p>同时找到 /etc/profile<br> 使用vi /etc/profile<br> 编辑该文件，设置环境变量<br> export JAVA_HOME=”/home/jdk/jdk1.7.0_79”<br> export PATH=”$PATH:$JAVA_HOME/bin”<br> export JRE_HOME=”$JAVA_HOME/jre”<br> export CLASSPATH=”.:$JAVA_HOME/lib:$JRE_HOME/lib”</p><p> 或者通过Xftp把profile文件down下来，修改好后再上传回去</p></li><li><p>弄好后要使用source /etc/profile 命令进行更新使其变量生效</p></li><li><p>同时 使用命令<br> java -version<br> java<br> javac</p><p> 正常则表示配置成功了</p></li></ol><p><img src="/images/pasted-11.png" alt="upload successful"></p><h2 id="启动Tomcat"><a href="#启动Tomcat" class="headerlink" title="启动Tomcat"></a>启动Tomcat</h2><ol><li>由于tomcat自带的startup.sh脚本看不到日志输出，因此写了个脚本startTomcat.sh脚本</li><li>进入到tomcat  bin目录下，使用命令  sh startTomcat.sh 启动tomcat，看到starup毫秒数表示启动成功。</li><li>启动后，在本地机器上访问 <a href="http://xxxxxxxxxxx:8080/" target="_blank" rel="noopener">http://xxxxxxxxxxx:8080/</a>  可以看到久违的tomcat页面</li><li><p>bin里的shutdown.sh用于停止tomcat服务，sh shutdown.sh</p></li><li><p>成功后上传项目 demo到 tomcat webapps文件夹</p></li></ol><p><img src="/images/pasted-12.png" alt="upload successful"></p><h2 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h2><p>接下来开始安装Mysql</p><ol><li>对于阿里云，我们可以采取在线安装的方式快速安装MySQL<br> 使用Linux  root用户登录，<br> 使用命令：<br> sudo apt-get install mysql-server<br> apt-get isntall mysql-client<br> sudo apt-get install libmysqlclient-dev</li><li>安装过程中会提示输入root用户密码，设置所需的root用户密码即可。</li><li><p>使用以下命令查看MySQL是否安装成功<br> sudo netstat -tap | grep mysql<br> 可以看到MySQL处于listen状态，配置成功。</p><p> 关于离线安装，暂时没弄成功，有时间在补上。</p></li></ol><h2 id="导入数据表"><a href="#导入数据表" class="headerlink" title="导入数据表"></a>导入数据表</h2><p>将数据表数据导入到MySQL数据库。<br>mysql命令<br>service mysql start 启动<br>service mysql stop  停止</p><p>service mysql restart  重启</p><ol><li><p>使用root用户登录MySQ</p><p> mysql -u root -p<br> 输入密码登录成功。</p></li><li><p>设置必要数据</p><p> 进入mysql命令行<br> 查看数据库编码还有表名大小写情况（Linux系统下MySQL表名会区分大小写）</p><p> 查看字符编码<br> mysql&gt; show variables like ‘character%’;<br> 查看表名大小写<br> mysql&gt; show Variables like ‘%table_names’;<br> 如果不是utf-8编码（右图所示为utf-8编码格式），表名默认区分大小写<br> lower_case_table_names=0<br> 则需要修改默认配置<br> cd etc/mysql/mysql.conf.d/<br> vi    mysqld.cnf<br> 加入如下配置：<br> character-set-server=utf8<br> collation-server=utf8_general_ci<br> skip-character-set-client-handshake<br> lower_case_table_names=1</p><p> 重启mysql服务</p></li><li><p>开启访问权限</p><p> 我们可以在开启外网MySQL访问权限在Windows机器上用GUI工具导入MySQL表数据<br> 开启外网权限：<br> mysql&gt; SELECT User, Host FROM mysql.user;<br> mysql&gt; update user set host = ‘%’ where user =’root’;<br> mysql&gt; flush privileges;<br> 同时将etc/mysql/mysql.conf.d/mysqld.cnf  配置文件里的<br> bind-address    = 127.0.0.1注释掉。</p></li><li><p>这样在MySQL可视化工具如Navicat上远程连接MySQL，设置utf-8编码格式后将数据表导入即可。</p></li></ol><h2 id="注意事项及其他"><a href="#注意事项及其他" class="headerlink" title="注意事项及其他"></a>注意事项及其他</h2><ol><li><p>启动tomcat及MySQL后，通过外网便可以正常访问项目。输入用户名密码后登陆。</p></li><li><p>注意事项。<br> 使用root用户时，应尽量减少敏感操作，如 rm ， mv  ，cp  -r  等命令的执行。<br> tomcat请使用tomcat用户启动，不建议使用root用户启动。<br> MySQL开启外网访问后，如果无法访问，可能是阿里云禁用了3306端口的外网访问，需要登录阿里云开启，当成功导入数据后，十分建议关闭MySQL远程访问权限。<br> 如果要设置tomcat默认端口为80，也需要登录阿里云设置。<br> 如果操作过程中出现异常破坏了Linux系统，可以登录阿里云进行系统还原。<br> 部署项目时，项目的一些配置文件如数据库连接，请求地址一定要配置正确。<br> 如果要设置tomcat默认端口为80，则需要用root启动，因为linux只有root才能启动1024以内的端口，同时需要修改tomcat  server.xml配置文件及demo访问地址。</p></li></ol><h2 id="文档PPT"><a href="#文档PPT" class="headerlink" title="文档PPT"></a>文档PPT</h2><p>简单阿里云主机搭建文档资源：<a href="https://download.csdn.net/download/javazwt/10448764" target="_blank" rel="noopener">https://download.csdn.net/download/javazwt/10448764</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;现在很多服务都部署在云服务上，最近项目也要发布到云上，特写此文章。有需要部署云服务的小伙伴可以参考下。&lt;/p&gt;
&lt;h2 id=&quot;云主机参数&quot;
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="云部署" scheme="https://www.sakuratears.top/tags/%E4%BA%91%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>Java排序算法</title>
    <link href="https://www.sakuratears.top/blog/Java%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%9520180602/"/>
    <id>https://www.sakuratears.top/blog/Java排序算法20180602/</id>
    <published>2018-06-02T15:25:00.000Z</published>
    <updated>2018-06-12T14:49:22.525Z</updated>
    
    <content type="html"><![CDATA[<h2 id="排序算法分类"><a href="#排序算法分类" class="headerlink" title="排序算法分类"></a>排序算法分类</h2><p>十种常见排序算法可以分为两大类：</p><p><strong>非线性时间比较类排序：</strong>通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此称为非线性时间比较类排序。</p><p><strong>线性时间非比较类排序：</strong>不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。 </p><p>如下图：</p><p><img src="/images/pasted-5.png" alt="upload successful"></p><h2 id="排序算法复杂度及稳定性"><a href="#排序算法复杂度及稳定性" class="headerlink" title="排序算法复杂度及稳定性"></a>排序算法复杂度及稳定性</h2><p>如下图：</p><p><img src="/images/pasted-6.png" alt="upload successful"></p><p>相关概念：</p><p><strong>稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</strong></p><p><strong>不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</strong></p><p><strong>时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</strong></p><p><strong>空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。 </strong></p><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h3><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 </p><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><ol><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ol><h4 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="/images/pasted-7.gif" alt="upload successful"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p><strong>JavaScript代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> len = arr.length;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;        <span class="comment">// 相邻元素两两对比  </span></span><br><span class="line">                <span class="keyword">var</span> temp = arr[j+<span class="number">1</span>];        <span class="comment">// 元素交换  </span></span><br><span class="line">                arr[j+<span class="number">1</span>] = arr[j];  </span><br><span class="line">                arr[j] = temp;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> arr;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bubbleSort(<span class="keyword">int</span>[] a)&#123;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length-<span class="number">1</span>;i++)&#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;a.length;j++)&#123;  </span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;a[j])&#123;  </span><br><span class="line">                <span class="keyword">int</span> temp=a[i];  </span><br><span class="line">                a[i]=a[j];  </span><br><span class="line">                a[j]=temp;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> a;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简单选择排序（Selection-Sort）"><a href="#简单选择排序（Selection-Sort）" class="headerlink" title="简单选择排序（Selection Sort）"></a>简单选择排序（Selection Sort）</h3><p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p><h4 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h4><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p><ol><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n)。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n]分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>n-1趟结束，数组有序化了。</li></ol><h4 id="动图演示-1"><a href="#动图演示-1" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="/images/pasted-8.gif" alt="upload successful"></p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><p><strong>JavaScript代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">arr</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> len = arr.length;  </span><br><span class="line">    <span class="keyword">var</span> minIndex, temp;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;  </span><br><span class="line">        minIndex = i;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;     <span class="comment">// 寻找最小的数  </span></span><br><span class="line">                minIndex = j;                 <span class="comment">// 将最小数的索引保存  </span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        temp = arr[i];  </span><br><span class="line">        arr[i] = arr[minIndex];  </span><br><span class="line">        arr[minIndex] = temp;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> arr;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] simpleSelectSort(<span class="keyword">int</span>[] a)&#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length-<span class="number">1</span>;i++)&#123;  </span><br><span class="line">            <span class="keyword">int</span> min=i;  </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;a.length;j++)&#123;  </span><br><span class="line">                <span class="keyword">if</span>(a[min]&gt;a[j])&#123;  </span><br><span class="line">                    min=j;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span>(min!=i)&#123;  </span><br><span class="line">                <span class="keyword">int</span> temp=a[i];  </span><br><span class="line">                a[i]=a[min];  </span><br><span class="line">                a[min]=temp;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> a;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h4><p>表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。</p><h3 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h3><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><h4 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h4><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><ol><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ol><h4 id="动图演示-2"><a href="#动图演示-2" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="/images/pasted-9.gif" alt="upload successful"></p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><p><strong>JavaScript代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span>(<span class="params">arr</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> len = arr.length;  </span><br><span class="line">    <span class="keyword">var</span> preIndex, current;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;  </span><br><span class="line">        preIndex = i - <span class="number">1</span>;  </span><br><span class="line">        current = arr[i];  </span><br><span class="line">        <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; arr[preIndex] &gt; current) &#123;  </span><br><span class="line">            arr[preIndex + <span class="number">1</span>] = arr[preIndex];  </span><br><span class="line">            preIndex--;  </span><br><span class="line">        &#125;  </span><br><span class="line">        arr[preIndex + <span class="number">1</span>] = current;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> arr;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] straightInsertionSort(<span class="keyword">int</span>[] a)&#123;  </span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;a.length;i++)&#123;  </span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;<span class="number">0</span>;j--)&#123;  </span><br><span class="line">             <span class="keyword">if</span>(a[j]&lt;a[j-<span class="number">1</span>])&#123;  </span><br><span class="line">                 <span class="keyword">int</span> temp=a[j-<span class="number">1</span>];  </span><br><span class="line">                 a[j-<span class="number">1</span>]=a[j];  </span><br><span class="line">                 a[j]=temp;  </span><br><span class="line">             &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">                 <span class="keyword">break</span>;  </span><br><span class="line">             &#125;  </span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">return</span> a;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h4><p>插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><h3 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h3><p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</p><h4 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h4><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ol><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ol><h4 id="动图演示-3"><a href="#动图演示-3" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="/images/pasted-10.gif" alt="upload successful"></p><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><p><strong>JavaScript代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span>(<span class="params">arr</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> len = arr.length,  </span><br><span class="line">        temp,  </span><br><span class="line">        gap = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">while</span> (gap &lt; len / <span class="number">3</span>) &#123;          <span class="comment">// 动态定义间隔序列  </span></span><br><span class="line">        gap = gap * <span class="number">3</span> + <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span> (gap; gap &gt; <span class="number">0</span>; gap = <span class="built_in">Math</span>.floor(gap / <span class="number">3</span>)) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = gap; i &lt; len; i++) &#123;  </span><br><span class="line">            temp = arr[i];  </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = i-gap; j &gt; <span class="number">0</span> &amp;&amp; arr[j]&gt; temp; j-=gap) &#123;  </span><br><span class="line">                arr[j + gap] = arr[j];  </span><br><span class="line">            &#125;  </span><br><span class="line">            arr[j + gap] = temp;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> arr;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] shellsSort(<span class="keyword">int</span> a[]) &#123;  </span><br><span class="line">     <span class="keyword">int</span> d = a.length;  </span><br><span class="line">     <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  </span><br><span class="line">         d = d / <span class="number">2</span>;  </span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; d; x++) &#123;  </span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> i = x + d; i &lt; a.length; i = i + d) &#123;  </span><br><span class="line">                 <span class="keyword">int</span> temp = a[i];  </span><br><span class="line">                 <span class="keyword">int</span> j;  </span><br><span class="line">                 <span class="keyword">for</span> (j = i - d; j &gt;= <span class="number">0</span> &amp;&amp; a[j] &gt; temp; j = j - d) &#123;  </span><br><span class="line">                     a[j + d] = a[j];  </span><br><span class="line">                 &#125;  </span><br><span class="line">                 a[j + d] = temp;  </span><br><span class="line">             &#125;  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="keyword">if</span> (d == <span class="number">1</span>) &#123;  </span><br><span class="line">             <span class="keyword">break</span>;  </span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">return</span> a;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h4><p>希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版）》的合著者Robert Sedgewick提出的。</p><h3 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h3><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p><h4 id="算法描述-4"><a href="#算法描述-4" class="headerlink" title="算法描述"></a>算法描述</h4><ol><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ol><h4 id="动图演示-4"><a href="#动图演示-4" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="/images/pasted-11.gif" alt="upload successful"></p><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><p><strong>JavaScript代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>) </span>&#123;  <span class="comment">// 采用自上而下的递归方法  </span></span><br><span class="line">    <span class="keyword">var</span> len = arr.length;  </span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> arr;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">var</span> middle = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>),  </span><br><span class="line">        left = arr.slice(<span class="number">0</span>, middle),  </span><br><span class="line">        right = arr.slice(middle);  </span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left, right</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> result = [];  </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">while</span> (left.length&gt;<span class="number">0</span> &amp;&amp; right.length&gt;<span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]) &#123;  </span><br><span class="line">            result.push(left.shift());  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            result.push(right.shift());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">while</span> (left.length)  </span><br><span class="line">        result.push(left.shift());  </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">while</span> (right.length)  </span><br><span class="line">        result.push(right.shift());  </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mergeSort(<span class="keyword">int</span> a[])&#123;  </span><br><span class="line">    sort(a,<span class="number">0</span>,<span class="number">1</span>);  </span><br><span class="line">    <span class="keyword">return</span> a;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> s, <span class="keyword">int</span> len)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> size = a.length;  </span><br><span class="line">    <span class="keyword">int</span> mid = size / (len &lt;&lt; <span class="number">1</span>);  </span><br><span class="line">    <span class="keyword">int</span> c = size &amp; ((len &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>);  </span><br><span class="line">    <span class="comment">//　-------归并到只剩一个有序集合的时候结束算法-------//  </span></span><br><span class="line">    <span class="keyword">if</span> (mid == <span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    <span class="comment">//　------进行一趟归并排序-------//  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mid; ++i) &#123;  </span><br><span class="line">        s = i * <span class="number">2</span> * len;  </span><br><span class="line">        merge(a, s, s + len, (len &lt;&lt; <span class="number">1</span>) + s - <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//　-------将剩下的数和倒数一个有序集合归并-------//  </span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>)  </span><br><span class="line">        merge(a, size - c - <span class="number">2</span> * len, size - c, size - <span class="number">1</span>);  </span><br><span class="line">    <span class="comment">//　-------递归执行下一趟归并排序------//  </span></span><br><span class="line">    sort(a, <span class="number">0</span>, <span class="number">2</span> * len);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> s, <span class="keyword">int</span> m, <span class="keyword">int</span> t)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[t - s + <span class="number">1</span>];  </span><br><span class="line">    <span class="keyword">int</span> i = s, j = m, k = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (i &lt; m &amp;&amp; j &lt;= t) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt;= a[j]) &#123;  </span><br><span class="line">            tmp[k] = a[i];  </span><br><span class="line">            k++;  </span><br><span class="line">            i++;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            tmp[k] = a[j];  </span><br><span class="line">            j++;  </span><br><span class="line">            k++;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">while</span> (i &lt; m) &#123;  </span><br><span class="line">        tmp[k] = a[i];  </span><br><span class="line">        i++;  </span><br><span class="line">        k++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">while</span> (j &lt;= t) &#123;  </span><br><span class="line">        tmp[k] = a[j];  </span><br><span class="line">        j++;  </span><br><span class="line">        k++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    System.arraycopy(tmp, <span class="number">0</span>, a, s, tmp.length);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h4><p>归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。</p><h3 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h3><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><h4 id="算法描述-5"><a href="#算法描述-5" class="headerlink" title="算法描述"></a>算法描述</h4><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ol><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ol><h4 id="动图演示-5"><a href="#动图演示-5" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="/images/pasted-12.gif" alt="upload successful"></p><h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><p><strong>JavaScript代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr, left, right</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> len = arr.length,  </span><br><span class="line">        partitionIndex,  </span><br><span class="line">        left = <span class="keyword">typeof</span> left != <span class="string">'number'</span> ? <span class="number">0</span> : left,  </span><br><span class="line">        right = <span class="keyword">typeof</span> right != <span class="string">'number'</span> ? len - <span class="number">1</span> : right;  </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;  </span><br><span class="line">        partitionIndex = partition(arr, left, right);  </span><br><span class="line">        quickSort(arr, left, partitionIndex<span class="number">-1</span>);  </span><br><span class="line">        quickSort(arr, partitionIndex+<span class="number">1</span>, right);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> arr;  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">arr, left ,right</span>) </span>&#123;     <span class="comment">// 分区操作  </span></span><br><span class="line">    <span class="keyword">var</span> pivot = left,                      <span class="comment">// 设定基准值（pivot）  </span></span><br><span class="line">        index = pivot + <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = index; i &lt;= right; i++) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[pivot]) &#123;  </span><br><span class="line">            swap(arr, i, index);  </span><br><span class="line">            index++;  </span><br><span class="line">        &#125;         </span><br><span class="line">    &#125;  </span><br><span class="line">    swap(arr, pivot, index - <span class="number">1</span>);  </span><br><span class="line">    <span class="keyword">return</span> index<span class="number">-1</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr, i, j</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> temp = arr[i];  </span><br><span class="line">    arr[i] = arr[j];  </span><br><span class="line">    arr[j] = temp;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] quickSort(<span class="keyword">int</span> a[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)&#123;  </span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;  </span><br><span class="line">        <span class="keyword">int</span> privotLoc=partition(a,low,high);<span class="comment">//将表一分为二  </span></span><br><span class="line">        quickSort(a,low,privotLoc-<span class="number">1</span>);  </span><br><span class="line">        quickSort(a,privotLoc+<span class="number">1</span>,high);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> a;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> privotKey=a[low];<span class="comment">//基准元素  </span></span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)&#123;     <span class="comment">//从表的两端交替向中间扫描  </span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;a[high]&gt;=privotKey)&#123;   <span class="comment">//从high 所指位置向前搜索，至多到low+1 位置。将比基准元素小的交换到低端  </span></span><br><span class="line">            --high;                             <span class="comment">//从右找比基准元素少的  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        a[low]=a[high];                         <span class="comment">//如果比基准元素小，交换位置  </span></span><br><span class="line">        a[high]=privotKey;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;a[low]&lt;=privotKey)&#123;  </span><br><span class="line">            ++low;                              <span class="comment">//从右找比基准元素大的  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        a[high]=a[low];                          <span class="comment">//如果比基准元素大，交换位置  </span></span><br><span class="line">        a[low]=privotKey;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> low;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h3><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><h4 id="算法描述-6"><a href="#算法描述-6" class="headerlink" title="算法描述"></a>算法描述</h4><ol><li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li><li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li></ol><h4 id="动图演示-6"><a href="#动图演示-6" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="/images/pasted-13.gif" alt="upload successful"></p><h4 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h4><p><strong>JavaScript代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> len;    <span class="comment">// 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量  </span></span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildMaxHeap</span>(<span class="params">arr</span>) </span>&#123;   <span class="comment">// 建立大顶堆  </span></span><br><span class="line">    len = arr.length;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="built_in">Math</span>.floor(len/<span class="number">2</span>); i &gt;= <span class="number">0</span>; i--) &#123;  </span><br><span class="line">        heapify(arr, i);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapify</span>(<span class="params">arr, i</span>) </span>&#123;     <span class="comment">// 堆调整  </span></span><br><span class="line">    <span class="keyword">var</span> left = <span class="number">2</span> * i + <span class="number">1</span>,  </span><br><span class="line">        right = <span class="number">2</span> * i + <span class="number">2</span>,  </span><br><span class="line">        largest = i;  </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;  </span><br><span class="line">        largest = left;  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;  </span><br><span class="line">        largest = right;  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;  </span><br><span class="line">        swap(arr, i, largest);  </span><br><span class="line">        heapify(arr, largest);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr, i, j</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> temp = arr[i];  </span><br><span class="line">    arr[i] = arr[j];  </span><br><span class="line">    arr[j] = temp;  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapSort</span>(<span class="params">arr</span>) </span>&#123;  </span><br><span class="line">    buildMaxHeap(arr);  </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;  </span><br><span class="line">        swap(arr, <span class="number">0</span>, i);  </span><br><span class="line">        len--;  </span><br><span class="line">        heapify(arr, <span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> arr;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] heapSort(<span class="keyword">int</span> a[])&#123;  </span><br><span class="line">     buildMaxHeapTree(a);  </span><br><span class="line">     sort(a);  </span><br><span class="line">     <span class="keyword">return</span> a;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildMaxHeapTree</span><span class="params">(<span class="keyword">int</span> a[])</span></span>&#123;  </span><br><span class="line">     <span class="comment">//没有子节点的才需要创建最大堆，从最后一个的父节点开始  </span></span><br><span class="line">     <span class="keyword">int</span> startIndex=getParentIndex(a.length-<span class="number">1</span>);  </span><br><span class="line">     <span class="comment">//从尾端开始创建最大堆，每次都是正确的堆  </span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=startIndex;i&gt;=<span class="number">0</span>;i--)&#123;  </span><br><span class="line">         maxHeap(a,a.length,i);  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maxHeap</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> heapSize, <span class="keyword">int</span> index)</span> </span>&#123;  </span><br><span class="line">     <span class="comment">//当前点与左右子节点比较  </span></span><br><span class="line">     <span class="keyword">int</span> left = getChildLeftIndex(index);  </span><br><span class="line">     <span class="keyword">int</span> right = getChildRightIndex(index);  </span><br><span class="line">  </span><br><span class="line">     <span class="keyword">int</span> largest = index;  </span><br><span class="line">     <span class="keyword">if</span> (left &lt; heapSize &amp;&amp; data[index] &lt; data[left]) &#123;  </span><br><span class="line">         largest = left;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">if</span> (right &lt; heapSize &amp;&amp; data[largest] &lt; data[right]) &#123;  </span><br><span class="line">         largest = right;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="comment">//得到最大值后可能需要交换，如果交换了，其子节点可能就不是最大堆了，需要重新调整  </span></span><br><span class="line">     <span class="keyword">if</span> (largest != index) &#123;  </span><br><span class="line">         <span class="keyword">int</span> temp = data[index];  </span><br><span class="line">         data[index] = data[largest];  </span><br><span class="line">         data[largest] = temp;  </span><br><span class="line">         maxHeap(data, heapSize, largest);  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getParentIndex</span><span class="params">(<span class="keyword">int</span> current)</span></span>&#123;  </span><br><span class="line">     <span class="keyword">return</span> (current-<span class="number">1</span>)&gt;&gt;<span class="number">2</span>;  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildLeftIndex</span><span class="params">(<span class="keyword">int</span> current)</span></span>&#123;  </span><br><span class="line">     <span class="keyword">return</span>(current&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildRightIndex</span><span class="params">(<span class="keyword">int</span> current)</span></span>&#123;  </span><br><span class="line">     <span class="keyword">return</span>(current&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>;  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] data)</span></span>&#123;  </span><br><span class="line">     <span class="comment">//末尾与头交换，交换后调整最大堆  </span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=data.length-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--)&#123;  </span><br><span class="line">         <span class="keyword">int</span> temp=data[<span class="number">0</span>];  </span><br><span class="line">         data[<span class="number">0</span>]=data[i];  </span><br><span class="line">         data[i]=temp;  </span><br><span class="line">         maxHeap(data,i,<span class="number">0</span>);  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="计数排序（Counting-Sort）"><a href="#计数排序（Counting-Sort）" class="headerlink" title="计数排序（Counting Sort）"></a>计数排序（Counting Sort）</h3><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><h4 id="算法描述-7"><a href="#算法描述-7" class="headerlink" title="算法描述"></a>算法描述</h4><ol><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li></ol><h4 id="动图演示-7"><a href="#动图演示-7" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="/images/pasted-14.gif" alt="upload successful"></p><h4 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h4><p><strong>JavaScript代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countingSort</span>(<span class="params">arr, maxValue</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> bucket = <span class="keyword">new</span> <span class="built_in">Array</span>(maxValue + <span class="number">1</span>),  </span><br><span class="line">        sortedIndex = <span class="number">0</span>;  </span><br><span class="line">        arrLen = arr.length,  </span><br><span class="line">        bucketLen = maxValue + <span class="number">1</span>;  </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arrLen; i++) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (!bucket[arr[i]]) &#123;  </span><br><span class="line">            bucket[arr[i]] = <span class="number">0</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        bucket[arr[i]]++;  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; bucketLen; j++) &#123;  </span><br><span class="line">        <span class="keyword">while</span>(bucket[j] &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">            arr[sortedIndex++] = j;  </span><br><span class="line">            bucket[j]--;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> arr;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] countSort(<span class="keyword">int</span>[]a)&#123;  </span><br><span class="line">    <span class="keyword">int</span> b[] = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];  </span><br><span class="line">    <span class="keyword">int</span> max = a[<span class="number">0</span>],min = a[<span class="number">0</span>];  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i:a)&#123;  </span><br><span class="line">        <span class="keyword">if</span>(i&gt;max)&#123;  </span><br><span class="line">            max=i;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(i&lt;min)&#123;  </span><br><span class="line">            min=i;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;<span class="comment">//这里k的大小是要排序的数组中，元素大小的极值差+1  </span></span><br><span class="line">    <span class="keyword">int</span> k=max-min+<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">int</span> c[]=<span class="keyword">new</span> <span class="keyword">int</span>[k];  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;++i)&#123;  </span><br><span class="line">        c[a[i]-min]+=<span class="number">1</span>;<span class="comment">//优化过的地方，减小了数组c的大小  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;c.length;++i)&#123;  </span><br><span class="line">        c[i]=c[i]+c[i-<span class="number">1</span>];  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=a.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;--i)&#123;  </span><br><span class="line">        b[--c[a[i]-min]]=a[i];<span class="comment">//按存取的方式取出c的元素  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> b;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h4><p>计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。</p><h3 id="桶排序（Bucket-Sort）"><a href="#桶排序（Bucket-Sort）" class="headerlink" title="桶排序（Bucket Sort）"></a>桶排序（Bucket Sort）</h3><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p><h4 id="算法描述-8"><a href="#算法描述-8" class="headerlink" title="算法描述"></a>算法描述</h4><ol><li>设置一个定量的数组当作空桶；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>对每个不是空的桶进行排序；</li><li>从不是空的桶里把排好序的数据拼接起来。 </li></ol><h4 id="图片演示"><a href="#图片演示" class="headerlink" title="图片演示"></a>图片演示</h4><p><img src="/images/pasted-15.png" alt="upload successful"></p><h4 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h4><p><strong>JavaScript代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bucketSort</span>(<span class="params">arr, bucketSize</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (arr.length === <span class="number">0</span>) &#123;  </span><br><span class="line">      <span class="keyword">return</span> arr;  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">var</span> i;  </span><br><span class="line">    <span class="keyword">var</span> minValue = arr[<span class="number">0</span>];  </span><br><span class="line">    <span class="keyword">var</span> maxValue = arr[<span class="number">0</span>];  </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;  </span><br><span class="line">      <span class="keyword">if</span> (arr[i] &lt; minValue) &#123;  </span><br><span class="line">          minValue = arr[i];                <span class="comment">// 输入数据的最小值  </span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; maxValue) &#123;  </span><br><span class="line">          maxValue = arr[i];                <span class="comment">// 输入数据的最大值  </span></span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 桶的初始化  </span></span><br><span class="line">    <span class="keyword">var</span> DEFAULT_BUCKET_SIZE = <span class="number">5</span>;            <span class="comment">// 设置桶的默认数量为5  </span></span><br><span class="line">    bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;  </span><br><span class="line">    <span class="keyword">var</span> bucketCount = <span class="built_in">Math</span>.floor((maxValue - minValue) / bucketSize) + <span class="number">1</span>;    </span><br><span class="line">    <span class="keyword">var</span> buckets = <span class="keyword">new</span> <span class="built_in">Array</span>(bucketCount);  </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; buckets.length; i++) &#123;  </span><br><span class="line">        buckets[i] = [];  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 利用映射函数将数据分配到各个桶中  </span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;  </span><br><span class="line">        buckets[<span class="built_in">Math</span>.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    arr.length = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; buckets.length; i++) &#123;  </span><br><span class="line">        insertionSort(buckets[i]);                      <span class="comment">// 对每个桶进行排序，这里使用了插入排序  </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; buckets[i].length; j++) &#123;  </span><br><span class="line">            arr.push(buckets[i][j]);                       </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> arr;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">basket</span><span class="params">(<span class="keyword">int</span> data[])</span><span class="comment">//data为待排序数组  </span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> n = data.length;  </span><br><span class="line">    <span class="keyword">int</span> bask[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][n];  </span><br><span class="line">    <span class="keyword">int</span> index[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];  </span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;  </span><br><span class="line">        max = max &gt; (Integer.toString(data[i]).length()) ? max : (Integer.toString(data[i]).length());  </span><br><span class="line">    &#125;  </span><br><span class="line">    String str;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = max - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;  </span><br><span class="line">            str = <span class="string">""</span>;  </span><br><span class="line">            <span class="keyword">if</span> (Integer.toString(data[j]).length() &lt; max) &#123;  </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; max - Integer.toString(data[j]).length(); k++)  </span><br><span class="line">                    str += <span class="string">"0"</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            str += Integer.toString(data[j]);  </span><br><span class="line">            bask[str.charAt(i) - <span class="string">'0'</span>][index[str.charAt(i) - <span class="string">'0'</span>]++] = data[j];  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; index[j]; k++) &#123;  </span><br><span class="line">                data[pos++] = bask[j][k];  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">10</span>; x++) index[x] = <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析-5"><a href="#算法分析-5" class="headerlink" title="算法分析"></a>算法分析</h4><p>桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 </p><h3 id="基数排序（Radix-Sort）"><a href="#基数排序（Radix-Sort）" class="headerlink" title="基数排序（Radix Sort）"></a>基数排序（Radix Sort）</h3><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p><h4 id="算法描述-9"><a href="#算法描述-9" class="headerlink" title="算法描述"></a>算法描述</h4><ol><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li></ol><h4 id="动图演示-8"><a href="#动图演示-8" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="/images/pasted-16.gif" alt="upload successful"></p><h4 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h4><p><strong>JavaScript代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = [];  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">radixSort</span>(<span class="params">arr, maxDigit</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> mod = <span class="number">10</span>;  </span><br><span class="line">    <span class="keyword">var</span> dev = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; maxDigit; i++, dev *= <span class="number">10</span>, mod *= <span class="number">10</span>) &#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;  </span><br><span class="line">            <span class="keyword">var</span> bucket = <span class="built_in">parseInt</span>((arr[j] % mod) / dev);  </span><br><span class="line">            <span class="keyword">if</span>(counter[bucket]==<span class="literal">null</span>) &#123;  </span><br><span class="line">                counter[bucket] = [];  </span><br><span class="line">            &#125;  </span><br><span class="line">            counter[bucket].push(arr[j]);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">var</span> pos = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; counter.length; j++) &#123;  </span><br><span class="line">            <span class="keyword">var</span> value = <span class="literal">null</span>;  </span><br><span class="line">            <span class="keyword">if</span>(counter[j]!=<span class="literal">null</span>) &#123;  </span><br><span class="line">                <span class="keyword">while</span> ((value = counter[j].shift()) != <span class="literal">null</span>) &#123;  </span><br><span class="line">                      arr[pos++] = value;  </span><br><span class="line">                &#125;  </span><br><span class="line">          &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> arr;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] number, <span class="keyword">int</span> d)</span> <span class="comment">//d表示最大的数有多少位  </span></span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">1</span>; <span class="comment">//控制键值排序依据在哪一位  </span></span><br><span class="line">        <span class="keyword">int</span>[][] temp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][number.length]; <span class="comment">//数组的第一维表示可能的余数0-9  </span></span><br><span class="line">        <span class="keyword">int</span>[] order = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">//数组orderp[i]用来表示该位是i的数的个数  </span></span><br><span class="line">        <span class="keyword">while</span> (m &lt;= d) &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number.length; i++) &#123;  </span><br><span class="line">                <span class="keyword">int</span> lsd = ((number[i] / n) % <span class="number">10</span>);  </span><br><span class="line">                temp[lsd][order[lsd]] = number[i];  </span><br><span class="line">                order[lsd]++;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (order[i] != <span class="number">0</span>)  </span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; order[i]; j++) &#123;  </span><br><span class="line">                        number[k] = temp[i][j];  </span><br><span class="line">                        k++;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                order[i] = <span class="number">0</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            n *= <span class="number">10</span>;  </span><br><span class="line">            k = <span class="number">0</span>;  </span><br><span class="line">            m++;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析-6"><a href="#算法分析-6" class="headerlink" title="算法分析"></a>算法分析</h4><p>基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。</p><p>基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n&gt;&gt;k，因此额外空间需要大概n个左右。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>新建Test类，测试十种排序算法时间消耗。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line"><span class="comment">//        int arrayLength=10;  </span></span><br><span class="line"><span class="comment">//        int range=100;  </span></span><br><span class="line">        <span class="keyword">int</span> arrayLength=<span class="number">100000</span>;  </span><br><span class="line">        <span class="keyword">int</span> range=<span class="number">100000</span>;  </span><br><span class="line">        <span class="comment">//生成一个指定长度数据的int数组  </span></span><br><span class="line">        <span class="keyword">int</span>[] a=<span class="keyword">new</span> <span class="keyword">int</span>[arrayLength];  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arrayLength;i++)&#123;  </span><br><span class="line">            a[i]=(<span class="keyword">int</span>)(Math.random()*range);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//创建十个数组用于测试，否则会冲突  </span></span><br><span class="line">        <span class="keyword">int</span>[] a1= a.clone();  </span><br><span class="line">        <span class="keyword">int</span>[] a2= a.clone();  </span><br><span class="line">        <span class="keyword">int</span>[] a3= a.clone();  </span><br><span class="line">        <span class="keyword">int</span>[] a4= a.clone();  </span><br><span class="line">        <span class="keyword">int</span>[] a5= a.clone();  </span><br><span class="line">        <span class="keyword">int</span>[] a6= a.clone();  </span><br><span class="line">        <span class="keyword">int</span>[] a7= a.clone();  </span><br><span class="line">        <span class="keyword">int</span>[] a8= a.clone();  </span><br><span class="line">        <span class="keyword">int</span>[] a9= a.clone();  </span><br><span class="line">        <span class="keyword">int</span>[] a10= a.clone();  </span><br><span class="line">        System.out.println(a1.toString());  </span><br><span class="line">        System.out.println(a2.toString());  </span><br><span class="line">        System.out.println(a3.toString());  </span><br><span class="line">        System.out.println(a4.toString());  </span><br><span class="line">        System.out.println(a5.toString());  </span><br><span class="line">        System.out.println(a6.toString());  </span><br><span class="line">        System.out.println(a7.toString());  </span><br><span class="line">        System.out.println(a8.toString());  </span><br><span class="line">        System.out.println(a9.toString());  </span><br><span class="line">        System.out.println(a10.toString());  </span><br><span class="line">  </span><br><span class="line">        System.gc();  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//直接插入排序法  </span></span><br><span class="line">        <span class="keyword">long</span> starta1=System.currentTimeMillis();  </span><br><span class="line">        a1= StraightInsertionSort.straightInsertionSort(a1);  </span><br><span class="line">        <span class="keyword">long</span> enda1=System.currentTimeMillis();  </span><br><span class="line">        System.out.println(<span class="string">"插入排序法耗时："</span>+(enda1-starta1)+<span class="string">"ms"</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//冒泡排序法  </span></span><br><span class="line">        <span class="keyword">long</span> starta2=System.currentTimeMillis();  </span><br><span class="line">        a2= BubbleSort.bubbleSort(a2);  </span><br><span class="line">        <span class="keyword">long</span> enda2=System.currentTimeMillis();  </span><br><span class="line">        System.out.println(<span class="string">"冒泡排序法耗时："</span>+(enda2-starta2)+<span class="string">"ms"</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//直接(简单)选择排序法  </span></span><br><span class="line">        <span class="keyword">long</span> starta3=System.currentTimeMillis();  </span><br><span class="line">        a3= SimpleSelectionSort.simpleSelectSort(a3);  </span><br><span class="line">        <span class="keyword">long</span> enda3=System.currentTimeMillis();  </span><br><span class="line">        System.out.println(<span class="string">"直接选择排序法耗时："</span>+(enda3-starta3)+<span class="string">"ms"</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//堆排序  </span></span><br><span class="line">        <span class="keyword">long</span> starta4=System.currentTimeMillis();  </span><br><span class="line">        a4= HeapSort.heapSort(a4);  </span><br><span class="line">        <span class="keyword">long</span> enda4=System.currentTimeMillis();  </span><br><span class="line">        System.out.println(<span class="string">"堆排序法耗时："</span>+(enda4-starta4)+<span class="string">"ms"</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//归并排序  </span></span><br><span class="line">        <span class="keyword">long</span> starta5=System.currentTimeMillis();  </span><br><span class="line">        a5= MergeSort.mergeSort(a5);  </span><br><span class="line">        <span class="keyword">long</span> enda5=System.currentTimeMillis();  </span><br><span class="line">        System.out.println(<span class="string">"归并排序法耗时："</span>+(enda5-starta5)+<span class="string">"ms"</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//快速排序算法  </span></span><br><span class="line">        <span class="keyword">long</span> starta6=System.currentTimeMillis();  </span><br><span class="line">        a6= QuickSort.quickSort(a6,<span class="number">0</span>,a6.length-<span class="number">1</span>);  </span><br><span class="line">        <span class="keyword">long</span> enda6=System.currentTimeMillis();  </span><br><span class="line">        System.out.println(<span class="string">"快速排序耗时："</span>+(enda6-starta6)+<span class="string">"ms"</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//计数排序算法  </span></span><br><span class="line">        <span class="keyword">long</span> starta7=System.currentTimeMillis();  </span><br><span class="line">        a7= CountingSort.countSort(a7);  </span><br><span class="line">        <span class="keyword">long</span> enda7=System.currentTimeMillis();  </span><br><span class="line">        System.out.println(<span class="string">"计数排序耗时："</span>+(enda7-starta7)+<span class="string">"ms"</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//希尔排序算法  </span></span><br><span class="line">        <span class="keyword">long</span> starta8=System.currentTimeMillis();  </span><br><span class="line">        a8= ShellsSort.shellsSort(a8);  </span><br><span class="line">        <span class="keyword">long</span> enda8=System.currentTimeMillis();  </span><br><span class="line">        System.out.println(<span class="string">"希尔排序耗时："</span>+(enda8-starta8)+<span class="string">"ms"</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//桶排序算法  </span></span><br><span class="line">        <span class="keyword">long</span> starta9=System.currentTimeMillis();  </span><br><span class="line">        a9= BucketSort.basket(a9);  </span><br><span class="line">        <span class="keyword">long</span> enda9=System.currentTimeMillis();  </span><br><span class="line">        System.out.println(<span class="string">"桶排序耗时："</span>+(enda9-starta9)+<span class="string">"ms"</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//基数排序算法  </span></span><br><span class="line">        <span class="keyword">long</span> starta10=System.currentTimeMillis();  </span><br><span class="line">        a10= RadixSort.sort(a10,<span class="number">6</span>);  </span><br><span class="line">        <span class="keyword">long</span> enda10=System.currentTimeMillis();  </span><br><span class="line">        System.out.println(<span class="string">"基数排序耗时："</span>+(enda10-starta10)+<span class="string">"ms"</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//        ArrayHelper.printLine(a1);  </span></span><br><span class="line"><span class="comment">//        System.out.println();  </span></span><br><span class="line"><span class="comment">//        ArrayHelper.printLine(a2);  </span></span><br><span class="line"><span class="comment">//        System.out.println();  </span></span><br><span class="line"><span class="comment">//        ArrayHelper.printLine(a3);  </span></span><br><span class="line"><span class="comment">//        System.out.println();  </span></span><br><span class="line"><span class="comment">//        ArrayHelper.printLine(a4);  </span></span><br><span class="line"><span class="comment">//        System.out.println();  </span></span><br><span class="line"><span class="comment">//        ArrayHelper.printLine(a5);  </span></span><br><span class="line"><span class="comment">//        System.out.println();  </span></span><br><span class="line"><span class="comment">//        ArrayHelper.printLine(a6);  </span></span><br><span class="line"><span class="comment">//        System.out.println();  </span></span><br><span class="line"><span class="comment">//        ArrayHelper.printLine(a7);  </span></span><br><span class="line"><span class="comment">//        System.out.println();  </span></span><br><span class="line"><span class="comment">//        ArrayHelper.printLine(a8);  </span></span><br><span class="line"><span class="comment">//        System.out.println();  </span></span><br><span class="line"><span class="comment">//        ArrayHelper.printLine(a9);  </span></span><br><span class="line"><span class="comment">//        System.out.println();  </span></span><br><span class="line"><span class="comment">//        ArrayHelper.printLine(a10);  </span></span><br><span class="line">  </span><br><span class="line">        System.gc();  </span><br><span class="line">  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/images/pasted-17.png" alt="upload successful"></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li><p>本文为转载，十种算法的Java实现方式及测试为原创。</p></li><li><p>本文转载自：<a href="https://www.cnblogs.com/onepixel/articles/7674659.html" target="_blank" rel="noopener">https://www.cnblogs.com/onepixel/articles/7674659.html</a></p></li><li><p>文中涉及到的Java代码地址：<a href="https://github.com/JavaZWT/sort" target="_blank" rel="noopener">https://github.com/JavaZWT/sort</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;排序算法分类&quot;&gt;&lt;a href=&quot;#排序算法分类&quot; class=&quot;headerlink&quot; title=&quot;排序算法分类&quot;&gt;&lt;/a&gt;排序算法分类&lt;/h2&gt;&lt;p&gt;十种常见排序算法可以分为两大类：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非线性时间比较类排序：&lt;/strong&gt;通过
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="JavaScript" scheme="https://www.sakuratears.top/tags/JavaScript/"/>
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式之代理模式</title>
    <link href="https://www.sakuratears.top/blog/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F20180602/"/>
    <id>https://www.sakuratears.top/blog/Java设计模式之代理模式20180602/</id>
    <published>2018-06-02T11:20:00.000Z</published>
    <updated>2018-06-12T14:49:38.423Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>代理模式：即通过代理对象访问目标对象，实现目标对象的方法。这样做的好处是：可以在目标对象实现的基础上，增强额外的功能操作，实现对目标功能的扩展。</p><p>这涉及到一个编程思想：不要随意去修改别人已经写好的代码或者方法（有坑）。如果需要修改，可以通过代理模式实现。</p><h2 id="写法实现"><a href="#写法实现" class="headerlink" title="写法实现"></a>写法实现</h2><p>代理模式通常有三种实现写法：<strong>静态代理、动态代理、Cglib代理</strong>。</p><p>我们依次说下这三种代理模式：</p><p>我们现有 AnimalsDao接口和其实现AnimalsDaoImpl实现类，有两个方法，run和eat。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AnimalsDao</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//提供两个方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalsDaoImpl</span> <span class="keyword">implements</span> <span class="title">AnimalsDao</span></span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"run"</span>);  </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"eat"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们想在run或者eat方法里之前做一些操作。</p><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxy</span> <span class="keyword">implements</span> <span class="title">AnimalsDao</span></span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"StaticProxy---------&gt;"</span>);  </span><br><span class="line">        dao.run();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"StaticProxy---------&gt;"</span>);  </span><br><span class="line">        dao.eat();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> AnimalsDao dao;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaticProxy</span><span class="params">(AnimalsDao dao)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.dao=dao;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>静态代理通过实现目标对象接口，然后调用相同方法来实现代理。这种方式的缺点显而易见，当目标对象接口方法变动时，直接影响到代理类，需要对代理类进行修改，十分不方便。而且如果目标对象接口方法较多时，代理类也十分臃肿，不便维护。</p><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//要代理的对象  </span></span><br><span class="line">    <span class="keyword">private</span> Object obj;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxy</span><span class="params">(Object obj)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.obj=obj;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObjProxyIntance</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(obj.getClass().getClassLoader(),  </span><br><span class="line">                obj.getClass().getInterfaces(),  </span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;  </span><br><span class="line">                <span class="comment">//执行目标对象方法  </span></span><br><span class="line">                System.out.println(<span class="string">"DynamicProxy---------&gt;"</span>);  </span><br><span class="line">                <span class="keyword">return</span> method.invoke(obj,args);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>动态代理模式主要借助JDK代理对象API  java.lang.reflect.Proxy来实现的，所以也称作JDK代理。我们看一下JDK这个类，其中重要的一个方法如下：</p><p><img src="/images/pasted-3.png" alt="upload successful"></p><p>这个方法的三个参数：</p><p>ClassLoader loader  目标对象类加载器</p><p>Class&lt;?&gt;[] interfaces  目标对象接口类型</p><p>InvocationHandler h  事物处理，在这里面可以实现自己想要的逻辑</p><p>根据以上，可以看出动态代理实现要求目标对象必须有实现接口。代理类不必实现接口。</p><h3 id="Cglib代理"><a href="#Cglib代理" class="headerlink" title="Cglib代理"></a>Cglib代理</h3><p>要实现Cglib代理，必须引入cglib.jar 包，由于Spring-core包中已经包含了cglib功能，且大部分Java项目均引入了spring 相关jar包，这边使用spring的cglib来讲解。（他俩实现方式都是一样的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//目标对象  </span></span><br><span class="line">    <span class="keyword">private</span> Object obj;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CglibProxy</span><span class="params">(Object obj)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.obj=obj;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//给目标对象创建一个代理对象  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="comment">//1.工具类  </span></span><br><span class="line">        Enhancer en = <span class="keyword">new</span> Enhancer();  </span><br><span class="line">        <span class="comment">//2.设置父类  </span></span><br><span class="line">        en.setSuperclass(obj.getClass());  </span><br><span class="line">        <span class="comment">//3.设置回调函数  </span></span><br><span class="line">        en.setCallback(<span class="keyword">this</span>);  </span><br><span class="line">        <span class="comment">//4.创建子类(代理对象)  </span></span><br><span class="line">        <span class="keyword">return</span> en.create();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"CglibProxy---------&gt;"</span>);  </span><br><span class="line">        <span class="keyword">return</span> method.invoke(obj,objects);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>可以看出，Cglib代理模式实现不需要目标对象一定实现接口，故目标对象如果没有实现接口，可以使用cglib代理模式。其实Spring的代理模式也是这么实现的。</p><h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><p>Spring的代理模式：如果容器目标对象有接口，使用JDK动态代理，如果没有接口，使用cglib动态代理。</p><p><img src="/images/pasted-4.png" alt="upload successful"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><p><a href="https://www.cnblogs.com/cenyu/p/6289209.html" target="_blank" rel="noopener">https://www.cnblogs.com/cenyu/p/6289209.html</a></p></li><li><p>Spring 4.0 源代码</p></li></ol><h2 id="GitHub代码地址"><a href="#GitHub代码地址" class="headerlink" title="GitHub代码地址"></a>GitHub代码地址</h2><p><a href="https://github.com/JavaZWT/designPatterns" target="_blank" rel="noopener">https://github.com/JavaZWT/designPatterns</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;代理模式：即通过代理对象访问目标对象，实现目标对象的方法。这样做的好处是：可以在目标对象实现的基础上，增强额外的功能操作，实现对目标功能的扩
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式之工厂模式</title>
    <link href="https://www.sakuratears.top/blog/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F20180602/"/>
    <id>https://www.sakuratears.top/blog/Java设计模式之工厂模式20180602/</id>
    <published>2018-06-02T09:45:00.000Z</published>
    <updated>2018-06-12T14:49:54.330Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>工厂模式，顾名思义，即用来实例化一个个对象的模式。把相同类别的对象用工厂模式代替new生成，提高代码质量和系统扩展性。</p><h2 id="写法分类"><a href="#写法分类" class="headerlink" title="写法分类"></a>写法分类</h2><p>   工厂模式的写法通常分为四类，简单工厂、多方法工厂、普通工厂、抽象工厂。<br>   在分别说明他们之前，我们先创建几个对象。<br>   抽象的Animals类，Plants类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animals</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//动物的描述  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">desc</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>及Animals的三个基本实现，Tiger类、Bird类、Fish类，Plants的实现Tree类。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tiger</span> <span class="keyword">extends</span>  <span class="title">Animals</span></span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">desc</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"这是一只老虎"</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"这是一只老虎"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">extends</span>  <span class="title">Animals</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">desc</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"这是一只鸟"</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"这是一只鸟"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fish</span> <span class="keyword">extends</span> <span class="title">Animals</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">desc</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"这是一条鱼"</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"这是一条鱼"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Plants</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//植物的描述  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">desc</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tree</span> <span class="keyword">extends</span> <span class="title">Plants</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">desc</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"这是一棵树"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   下面来说说这四种工厂模式。</p><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalsFactory</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String Tiger=<span class="string">"Tiger"</span>;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String Bird=<span class="string">"Bird"</span>;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String Fish=<span class="string">"Fish"</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Animals <span class="title">getAnimal</span><span class="params">(String name)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">switch</span> (name)&#123;  </span><br><span class="line">            <span class="keyword">case</span> Tiger:  </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Tiger();  </span><br><span class="line">            <span class="keyword">case</span> Bird:  </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Bird();  </span><br><span class="line">            <span class="keyword">case</span> Fish:  </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Fish();  </span><br><span class="line">            <span class="keyword">default</span>:  </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调用：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animals a=AnimalsFactory.getAnimal(<span class="string">"Tiger"</span>);  </span><br><span class="line">a.desc();</span><br></pre></td></tr></table></figure></p><p><strong>说明：</strong>简单工厂模式易于理解，但扩展性差，如我想在增加一种动物，则还需要修改逻辑内容。而且如果设置额外入参，对参数的管理也较为不便。</p><h3 id="多方法工厂模式"><a href="#多方法工厂模式" class="headerlink" title="多方法工厂模式"></a>多方法工厂模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalsFactory</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Animals <span class="title">getTiger</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tiger();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Animals <span class="title">getBird</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Bird();  </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Animals <span class="title">getFish</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Fish();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调用：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animals b= AnimalsFactory.getFish();  </span><br><span class="line">b.desc();</span><br></pre></td></tr></table></figure></p><p>说明：这种模式使用方便，容错率高，且可适应不同需求，如我现在想创建一个羽毛为蓝色的小鸟，明显多方法工厂模式比简单工厂模式实现简单。</p><h3 id="普通工厂模式"><a href="#普通工厂模式" class="headerlink" title="普通工厂模式"></a>普通工厂模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PlantsFactory</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Plants <span class="title">getPlant</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeFactory</span> <span class="keyword">extends</span> <span class="title">PlantsFactory</span></span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Plants <span class="title">getPlant</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tree();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调用：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PlantsFactory p=<span class="keyword">new</span> TreeFactory();  </span><br><span class="line">p.getPlant().desc();</span><br></pre></td></tr></table></figure></p><p><strong>说明：</strong>这种工厂模式划分成两层：抽象工厂层+具体的工厂子类层。 当我们不需要Tree，或者需要其他时，都可以新增或删除一个类实现，这种工厂模式看着很简洁明了易于理解。</p><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="keyword">static</span>&#123;  </span><br><span class="line">        <span class="comment">// do something  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="comment">//do something  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> T <span class="title">getT</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BirdFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span>&lt;<span class="title">Animals</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Animals <span class="title">getT</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Bird();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span>&lt;<span class="title">Plants</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Plants <span class="title">getT</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tree();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调用：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AbstractFactory factory= <span class="keyword">new</span> TreeFactory();  </span><br><span class="line">Tree t=(Tree)factory.getT();  </span><br><span class="line">t.desc();</span><br></pre></td></tr></table></figure></p><p><strong>说明：</strong>可以看出，这种方法把工厂本身也抽象了，如果对于两个或多个简单工厂模式，相似点较多，比如PlantsFactory和AnimalsFactory，作为生物，它们也有相似之处，dosomething部分的代码。其实抽象工厂模式跟普通工厂模式的区别就在于把工厂也抽象了一层。</p><h2 id="工厂模式实例"><a href="#工厂模式实例" class="headerlink" title="工厂模式实例"></a>工厂模式实例</h2><ol><li>Spring Bean对象的创建   抽象工厂模式的使用</li></ol><p><img src="/images/pasted-1.png" alt="upload successful"></p><ol start="2"><li>线程池 Executors  多方法工厂模式的使用</li></ol><p><img src="/images/pasted-2.png" alt="upload successful"></p><p>其他：Spring框架中大量使用了工厂模式，单例模式等设计模式，有时间阅读些源代码，对技术能力的提升有很大帮助。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><p><a href="https://blog.csdn.net/zxt0601/article/details/52798423" target="_blank">https://blog.csdn.net/zxt0601/article/details/52798423</a></p></li><li><p>Spring 4.0 源码</p></li><li><p>JDK8源码</p></li></ol><h2 id="GitHub代码地址"><a href="#GitHub代码地址" class="headerlink" title="GitHub代码地址"></a>GitHub代码地址</h2><p><a href="https://github.com/JavaZWT/designPatterns" target="_blank">https://github.com/JavaZWT/designPatterns</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;工厂模式，顾名思义，即用来实例化一个个对象的模式。把相同类别的对象用工厂模式代替new生成，提高代码质量和系统扩展性。&lt;/p&gt;
&lt;h2 id
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
</feed>
