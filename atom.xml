<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SakuraTears的博客</title>
  
  <subtitle>越努力越幸运</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.sakuratears.top/"/>
  <updated>2019-07-21T02:34:35.371Z</updated>
  <id>https://www.sakuratears.top/</id>
  
  <author>
    <name>SakuraTears</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis功能文档（转）</title>
    <link href="https://www.sakuratears.top/blog/Redis%E5%8A%9F%E8%83%BD%E6%96%87%E6%A1%A3%EF%BC%88%E8%BD%AC%EF%BC%89.html"/>
    <id>https://www.sakuratears.top/blog/Redis功能文档（转）.html</id>
    <published>2019-07-21T01:59:52.000Z</published>
    <updated>2019-07-21T02:34:35.371Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文转载自 <a href="http://redisdoc.com/topic/index.html" rel="external nofollow noopener noreferrer" target="_blank">Redis命令参考-功能文档</a></p><h1 id="功能文档"><a href="#功能文档" class="headerlink" title="功能文档"></a>功能文档</h1><h2 id="Redis-集群规范"><a href="#Redis-集群规范" class="headerlink" title="Redis 集群规范"></a>Redis 集群规范</h2><h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>这个文档是正在开发中的 Redis 集群功能的规范（specification）文档， 文档分为两个部分：</p><ul><li>第一部分介绍目前已经在 unstable 分支中实现了的那些功能。</li><li>第二部分介绍目前仍未实现的那些功能。</li></ul><p>文档各个部分的内容可能会随着集群功能的设计修改而发生改变， 其中， 未实现功能发生修改的几率比已实现功能发生修改的几率要高。</p><p>这个规范包含了编写客户端库（client library）所需的全部知识， 不过请注意， 这里列出的一部分细节可能会在未来发生变化。</p><h4 id="什么是-Redis-集群？"><a href="#什么是-Redis-集群？" class="headerlink" title="什么是 Redis 集群？"></a>什么是 Redis 集群？</h4><p>Redis 集群是一个分布式（distributed）、容错（fault-tolerant）的 Redis 实现， 集群可以使用的功能是普通单机 Redis 所能使用的功能的一个子集（subset）。</p><p>Redis 集群中不存在中心（central）节点或者代理（proxy）节点， 集群的其中一个主要设计目标是达到线性可扩展性（linear scalability）。</p><p>Redis 集群为了保证一致性（consistency）而牺牲了一部分容错性： 系统会在保证对网络断线（net split）和节点失效（node failure）具有有限（limited）抵抗力的前提下， 尽可能地保持数据的一致性。</p><p><strong>Note</strong></p><pre><code>集群将节点失效视为网络断线的其中一种特殊情况。</code></pre><p>集群的容错功能是通过使用主节点（master）和从节点（slave）两种角色（role）的节点（node）来实现的：</p><ul><li>主节点和从节点使用完全相同的服务器实现， 它们的功能（functionally）也完全一样， 但从节点通常仅用于替换失效的主节点。</li><li>不过， 如果不需要保证“先写入，后读取”操作的一致性（read-after-write consistency）， 那么可以使用从节点来执行只读查询。</li></ul><h4 id="Redis-集群实现的功能子集"><a href="#Redis-集群实现的功能子集" class="headerlink" title="Redis 集群实现的功能子集"></a>Redis 集群实现的功能子集</h4><p>Redis 集群实现了单机 Redis 中， 所有处理单个数据库键的命令。</p><p>针对多个数据库键的复杂计算操作， 比如集合的并集操作、合集操作没有被实现， 那些理论上需要使用多个节点的多个数据库键才能完成的命令也没有被实现。</p><p>在将来， 用户也许可以通过 MIGRATE COPY 命令， 在集群的计算节点（computation node）中执行针对多个数据库键的只读操作， 但集群本身不会去实现那些需要将多个数据库键在多个节点中移来移去的复杂多键命令。</p><p>Redis 集群不像单机 Redis 那样支持多数据库功能， 集群只使用默认的 0 号数据库， 并且不能使用 SELECT index 命令。</p><h4 id="Redis-集群协议中的客户端和服务器"><a href="#Redis-集群协议中的客户端和服务器" class="headerlink" title="Redis 集群协议中的客户端和服务器"></a>Redis 集群协议中的客户端和服务器</h4><p>Redis 集群中的节点有以下责任：</p><ul><li>持有键值对数据。</li><li>记录集群的状态，包括键到正确节点的映射（mapping keys to right nodes）。</li><li>自动发现其他节点，识别工作不正常的节点，并在有需要时，在从节点中选举出新的主节点。</li></ul><p>为了执行以上列出的任务， 集群中的每个节点都与其他节点建立起了“集群连接（cluster bus）”， 该连接是一个 TCP 连接， 使用二进制协议进行通讯。</p><p>节点之间使用 Gossip 协议 来进行以下工作：</p><ul><li>传播（propagate）关于集群的信息，以此来发现新的节点。</li><li>向其他节点发送 PING 数据包，以此来检查目标节点是否正常运作。</li><li>在特定事件发生时，发送集群信息。</li></ul><p>除此之外， 集群连接还用于在集群中发布或订阅信息。</p><p>因为集群节点不能代理（proxy）命令请求， 所以客户端应该在节点返回 -MOVED 或者 -ASK 转向（redirection）错误时， 自行将命令请求转发至其他节点。</p><p>因为客户端可以自由地向集群中的任何一个节点发送命令请求， 并可以在有需要时， 根据转向错误所提供的信息， 将命令转发至正确的节点， 所以在理论上来说， 客户端是无须保存集群状态信息的。</p><p>不过， 如果客户端可以将键和节点之间的映射信息保存起来， 可以有效地减少可能出现的转向次数， 籍此提升命令执行的效率。</p><h4 id="键分布模型"><a href="#键分布模型" class="headerlink" title="键分布模型"></a>键分布模型</h4><p>Redis 集群的键空间被分割为 16384 个槽（slot）， 集群的最大节点数量也是 16384 个。</p><p><strong>Note</strong></p><pre><code>推荐的最大节点数量为 1000 个左右。</code></pre><p>每个主节点都负责处理 16384 个哈希槽的其中一部分。</p><p>当我们说一个集群处于“稳定”（stable）状态时， 指的是集群没有在执行重配置（reconfiguration）操作， 每个哈希槽都只由一个节点进行处理。</p><p><strong>Note</strong></p><pre><code>重配置指的是将某个/某些槽从一个节点移动到另一个节点。</code></pre><p><strong>Note</strong></p><pre><code>一个主节点可以有任意多个从节点， 这些从节点用于在主节点发生网络断线或者节点失效时， 对主节点进行替换。</code></pre><p>以下是负责将键映射到槽的算法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HASH_SLOT = CRC16(key) mod 16384</span><br></pre></td></tr></table></figure></p><p>以下是该算法所使用的参数：</p><ul><li>算法的名称: XMODEM (又称 ZMODEM 或者 CRC-16/ACORN)</li><li>结果的长度: 16 位</li><li>多项数（poly）: 1021 (也即是 x16 + x12 + x5 + 1)</li><li>初始化值: 0000</li><li>反射输入字节（Reflect Input byte）: False</li><li>发射输出 CRC （Reflect Output CRC）: False</li><li>用于 CRC 输出值的异或常量（Xor constant to output CRC）: 0000</li><li>该算法对于输入 “123456789” 的输出: 31C3</li></ul><p>附录 A 中给出了集群所使用的 CRC16 算法的实现。</p><p>CRC16 算法所产生的 16 位输出中的 14 位会被用到。</p><p>在我们的测试中， CRC16 算法可以很好地将各种不同类型的键平稳地分布到 16384 个槽里面。</p><h4 id="集群节点属性"><a href="#集群节点属性" class="headerlink" title="集群节点属性"></a>集群节点属性</h4><p>每个节点在集群中都有一个独一无二的 ID ， 该 ID 是一个十六进制表示的 160 位随机数， 在节点第一次启动时由 /dev/urandom 生成。</p><p>节点会将它的 ID 保存到配置文件， 只要这个配置文件不被删除， 节点就会一直沿用这个 ID 。</p><p>节点 ID 用于标识集群中的每个节点。 一个节点可以改变它的 IP 和端口号， 而不改变节点 ID 。 集群可以自动识别出 IP/端口号的变化， 并将这一信息通过 Gossip 协议广播给其他节点知道。</p><p>以下是每个节点都有的关联信息， 并且节点会将这些信息发送给其他节点：</p><ul><li>节点所使用的 IP 地址和 TCP 端口号。</li><li>节点的标志（flags）。</li><li>节点负责处理的哈希槽。</li><li>节点最近一次使用集群连接发送 PING 数据包（packet）的时间。</li><li>节点最近一次在回复中接收到 PONG 数据包的时间。</li><li>集群将该节点标记为下线的时间。</li><li>该节点的从节点数量。</li><li>如果该节点是从节点的话，那么它会记录主节点的节点 ID 。 如果这是一个主节点的话，那么主节点 ID 这一栏的值为 0000000 。</li></ul><p>以上信息的其中一部分可以通过向集群中的任意节点（主节点或者从节点都可以）发送 CLUSTER NODES 命令来获得。</p><p>以下是一个向集群中的主节点发送 CLUSTER NODES 命令的例子， 该集群由三个节点组成：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli cluster nodes</span><br><span class="line">d1861060fe6a534d42d8a19aeb36600e18785e04 :0 myself - 0 1318428930 connected 0-1364</span><br><span class="line">3886e65cc906bfd9b1f7e7bde468726a052d1dae 127.0.0.1:6380 master - 1318428930 1318428931 connected 1365-2729</span><br><span class="line">d289c575dcbc4bdd2931585fd4339089e461a27d 127.0.0.1:6381 master - 1318428931 1318428931 connected 2730-4095</span><br></pre></td></tr></table></figure></p><p>在上面列出的三行信息中， 从左到右的各个域分别是： 节点 ID ， IP 地址和端口号， 标志（flag）， 最后发送 PING 的时间， 最后接收 PONG 的时间， 连接状态， 节点负责处理的槽。</p><h4 id="节点握手（已实现）"><a href="#节点握手（已实现）" class="headerlink" title="节点握手（已实现）"></a>节点握手（已实现）</h4><p>节点总是应答（accept）来自集群连接端口的连接请求， 并对接收到的 PING 数据包进行回复， 即使这个 PING 数据包来自不可信的节点。</p><p>然而， 除了 PING 之外， 节点会拒绝其他所有并非来自集群节点的数据包。</p><p>要让一个节点承认另一个节点同属于一个集群， 只有以下两种方法：</p><ul><li>一个节点可以通过向另一个节点发送 MEET 信息， 来强制让接收信息的节点承认发送信息的节点为集群中的一份子。 一个节点仅在管理员显式地向它发送 CLUSTER MEET ip port 命令时， 才会向另一个节点发送 MEET 信息。</li><li>另外， 如果一个可信节点向另一个节点传播第三者节点的信息， 那么接收信息的那个节点也会将第三者节点识别为集群中的一份子。 也即是说， 如果 A 认识 B ， B 认识 C ， 并且 B 向 A 传播关于 C 的信息， 那么 A 也会将 C 识别为集群中的一份子， 并尝试连接 C 。</li></ul><p>这意味着如果我们将一个/一些新节点添加到一个集群中， 那么这个/这些新节点最终会和集群中已有的其他所有节点连接起来。</p><p>这说明只要管理员使用 CLUSTER MEET 命令显式地指定了可信关系， 集群就可以自动发现其他节点。</p><p>这种节点识别机制通过防止不同的 Redis 集群因为 IP 地址变更或者其他网络事件的发生而产生意料之外的联合（mix）， 从而使得集群更具健壮性。</p><p>当节点的网络连接断开时， 它会主动连接其他已知的节点。</p><h4 id="MOVED-转向"><a href="#MOVED-转向" class="headerlink" title="MOVED 转向"></a>MOVED 转向</h4><p>一个 Redis 客户端可以向集群中的任意节点（包括从节点）发送命令请求。 节点会对命令请求进行分析， 如果该命令是集群可以执行的命令， 那么节点会查找这个命令所要处理的键所在的槽。</p><p>如果要查找的哈希槽正好就由接收到命令的节点负责处理， 那么节点就直接执行这个命令。</p><p>另一方面， 如果所查找的槽不是由该节点处理的话， 节点将查看自身内部所保存的哈希槽到节点 ID 的映射记录， 并向客户端回复一个 MOVED 错误。</p><p>以下是一个 MOVED 错误的例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET x</span><br><span class="line"></span><br><span class="line">-MOVED 3999 127.0.0.1:6381</span><br></pre></td></tr></table></figure></p><p>错误信息包含键 x 所属的哈希槽 3999 ， 以及负责处理这个槽的节点的 IP 和端口号 127.0.0.1:6381 。 客户端需要根据这个 IP 和端口号， 向所属的节点重新发送一次 GET key 命令请求。</p><p>注意， 即使客户端在重新发送 GET key 命令之前， 等待了非常久的时间， 以至于集群又再次更改了配置， 使得节点 127.0.0.1:6381 已经不再处理槽 3999 ， 那么当客户端向节点 127.0.0.1:6381 发送 GET key 命令的时候， 节点将再次向客户端返回 MOVED 错误， 指示现在负责处理槽 3999 的节点。</p><p>虽然我们用 ID 来标识集群中的节点， 但是为了让客户端的转向操作尽可能地简单， 节点在 MOVED 错误中直接返回目标节点的 IP 和端口号， 而不是目标节点的 ID 。</p><p>虽然不是必须的， 但一个客户端应该记录（memorize）下“槽 3999 由节点 127.0.0.1:6381 负责处理“这一信息， 这样当再次有命令需要对槽 3999 执行时， 客户端就可以加快寻找正确节点的速度。</p><p>注意， 当集群处于稳定状态时， 所有客户端最终都会保存有一个哈希槽至节点的映射记录（map of hash slots to nodes）， 使得集群非常高效： 客户端可以直接向正确的节点发送命令请求， 无须转向、代理或者其他任何可能发生单点故障（single point failure）的实体（entiy）。</p><p>除了 MOVED 转向错误之外， 一个客户端还应该可以处理稍后介绍的 ASK 转向错误。</p><h4 id="集群在线重配置（live-reconfiguration）"><a href="#集群在线重配置（live-reconfiguration）" class="headerlink" title="集群在线重配置（live reconfiguration）"></a>集群在线重配置（live reconfiguration）</h4><p>Redis 集群支持在集群运行的过程中添加或者移除节点。</p><p>实际上， 节点的添加操作和节点的删除操作可以抽象成同一个操作， 那就是， 将哈希槽从一个节点移动到另一个节点：</p><ul><li>添加一个新节点到集群， 等于将其他已存在节点的槽移动到一个空白的新节点里面。</li><li>从集群中移除一个节点， 等于将被移除节点的所有槽移动到集群的其他节点上面去。</li></ul><p>因此， 实现 Redis 集群在线重配置的核心就是将槽从一个节点移动到另一个节点的能力。 因为一个哈希槽实际上就是一些键的集合， 所以 Redis 集群在重哈希（rehash）时真正要做的， 就是将一些键从一个节点移动到另一个节点。</p><p>要理解 Redis 集群如何将槽从一个节点移动到另一个节点， 我们需要对 CLUSTER 命令的各个子命令进行介绍， 这些命理负责管理集群节点的槽转换表（slots translation table）。</p><p>以下是 CLUSTER 命令可用的子命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER ADDSLOTS slot1 [slot2] ... [slotN]</span><br><span class="line">CLUSTER DELSLOTS slot1 [slot2] ... [slotN]</span><br><span class="line">CLUSTER SETSLOT slot NODE node</span><br><span class="line">CLUSTER SETSLOT slot MIGRATING node</span><br><span class="line">CLUSTER SETSLOT slot IMPORTING node</span><br></pre></td></tr></table></figure></p><p>最开头的两条命令 ADDSLOTS 和 DELSLOTS 分别用于向节点指派（assign）或者移除节点， 当槽被指派或者移除之后， 节点会将这一信息通过 Gossip 协议传播到整个集群。 ADDSLOTS 命令通常在新创建集群时， 作为一种快速地将各个槽指派给各个节点的手段来使用。</p><p>CLUSTER SETSLOT slot NODE node 子命令可以将指定的槽 slot 指派给节点 node 。</p><p>至于 CLUSTER SETSLOT slot MIGRATING node 命令和 CLUSTER SETSLOT slot IMPORTING node 命令， 前者用于将给定节点 node 中的槽 slot 迁移出节点， 而后者用于将给定槽 slot 导入到节点 node ：</p><ul><li><p>当一个槽被设置为 MIGRATING 状态时， 原来持有这个槽的节点仍然会继续接受关于这个槽的命令请求， 但只有命令所处理的键仍然存在于节点时， 节点才会处理这个命令请求。</p><p>  如果命令所使用的键不存在与该节点， 那么节点将向客户端返回一个 -ASK 转向（redirection）错误， 告知客户端， 要将命令请求发送到槽的迁移目标节点。</p></li><li><p>当一个槽被设置为 IMPORTING 状态时， 节点仅在接收到 ASKING 命令之后， 才会接受关于这个槽的命令请求。</p><p>  如果客户端没有向节点发送 ASKING 命令， 那么节点会使用 -MOVED 转向错误将命令请求转向至真正负责处理这个槽的节点。</p></li></ul><p>上面关于 MIGRATING 和 IMPORTING 的说明有些难懂， 让我们用一个实际的实例来说明一下。</p><p>假设现在， 我们有 A 和 B 两个节点， 并且我们想将槽 8 从节点 A 移动到节点 B ， 于是我们：</p><ul><li>向节点 B 发送命令 CLUSTER SETSLOT 8 IMPORTING A</li><li>向节点 A 发送命令 CLUSTER SETSLOT 8 MIGRATING B</li></ul><p>每当客户端向其他节点发送关于哈希槽 8 的命令请求时， 这些节点都会向客户端返回指向节点 A 的转向信息：</p><ul><li>如果命令要处理的键已经存在于槽 8 里面， 那么这个命令将由节点 A 处理。</li><li>如果命令要处理的键未存在于槽 8 里面（比如说，要向槽添加一个新的键）， 那么这个命令由节点 B 处理。</li></ul><p>这种机制将使得节点 A 不再创建关于槽 8 的任何新键。</p><p>与此同时， 一个特殊的客户端 redis-trib 以及 Redis 集群配置程序（configuration utility）会将节点 A 中槽 8 里面的键移动到节点 B 。</p><p>键的移动操作由以下两个命令执行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER GETKEYSINSLOT slot count</span><br></pre></td></tr></table></figure></p><p>上面的命令会让节点返回 count 个 slot 槽中的键， 对于命令所返回的每个键， redis-trib 都会向节点 A 发送一条 MIGRATE host port key destination-db timeout [COPY] [REPLACE] 命令， 该命令会将所指定的键原子地（atomic）从节点 A 移动到节点 B （在移动键期间，两个节点都会处于阻塞状态，以免出现竞争条件）。</p><p>以下为 MIGRATE host port key destination-db timeout [COPY] [REPLACE] 命令的运作原理：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MIGRATE target_host target_port key target_database id timeout</span><br></pre></td></tr></table></figure></p><p>执行 MIGRATE host port key destination-db timeout [COPY] [REPLACE] 命令的节点会连接到 target 节点， 并将序列化后的 key 数据发送给 target ， 一旦 target 返回 OK ， 节点就将自己的 key 从数据库中删除。</p><p>从一个外部客户端的视角来看， 在某个时间点上， 键 key 要么存在于节点 A ， 要么存在于节点 B ， 但不会同时存在于节点 A 和节点 B 。</p><p>因为 Redis 集群只使用 0 号数据库， 所以当 MIGRATE host port key destination-db timeout [COPY] [REPLACE] 命令被用于执行集群操作时， target_database 的值总是 0 。</p><p>target_database 参数的存在是为了让 MIGRATE host port key destination-db timeout [COPY] [REPLACE] 命令成为一个通用命令， 从而可以作用于集群以外的其他功能。</p><p>我们对 MIGRATE host port key destination-db timeout [COPY] [REPLACE] 命令做了优化， 使得它即使在传输包含多个元素的列表键这样的复杂数据时， 也可以保持高效。</p><p>不过， 尽管 MIGRATE host port key destination-db timeout [COPY] [REPLACE] 非常高效， 对一个键非常多、并且键的数据量非常大的集群来说， 集群重配置还是会占用大量的时间， 可能会导致集群没办法适应那些对于响应时间有严格要求的应用程序。</p><h4 id="ASK-转向"><a href="#ASK-转向" class="headerlink" title="ASK 转向"></a>ASK 转向</h4><p>在之前介绍 MOVED 转向的时候， 我们说除了 MOVED 转向之外， 还有另一种 ASK 转向。</p><p>当节点需要让一个客户端长期地（permanently）将针对某个槽的命令请求发送至另一个节点时， 节点向客户端返回 MOVED 转向。</p><p>另一方面， 当节点需要让客户端仅仅在下一个命令请求中转向至另一个节点时， 节点向客户端返回 ASK 转向。</p><p>比如说， 在我们上一节列举的槽 8 的例子中， 因为槽 8 所包含的各个键分散在节点 A 和节点 B 中， 所以当客户端在节点 A 中没找到某个键时， 它应该转向到节点 B 中去寻找， 但是这种转向应该仅仅影响一次命令查询， 而不是让客户端每次都直接去查找节点 B ： 在节点 A 所持有的属于槽 8 的键没有全部被迁移到节点 B 之前， 客户端应该先访问节点 A ， 然后再访问节点 B 。</p><p>因为这种转向只针对 16384 个槽中的其中一个槽， 所以转向对集群造成的性能损耗属于可接受的范围。</p><p>因为上述原因， 如果我们要在查找节点 A 之后， 继续查找节点 B ， 那么客户端在向节点 B 发送命令请求之前， 应该先发送一个 ASKING 命令， 否则这个针对带有 IMPORTING 状态的槽的命令请求将被节点 B 拒绝执行。</p><p>接收到客户端 ASKING 命令的节点将为客户端设置一个一次性的标志（flag）， 使得客户端可以执行一次针对 IMPORTING 状态的槽的命令请求。</p><p>从客户端的角度来看， ASK 转向的完整语义（semantics）如下：</p><ul><li>如果客户端接收到 ASK 转向， 那么将命令请求的发送对象调整为转向所指定的节点。</li><li>先发送一个 ASKING 命令，然后再发送真正的命令请求。</li><li>不必更新客户端所记录的槽 8 至节点的映射： 槽 8 应该仍然映射到节点 A ， 而不是节点 B 。</li></ul><p>一旦节点 A 针对槽 8 的迁移工作完成， 节点 A 在再次收到针对槽 8 的命令请求时， 就会向客户端返回 MOVED 转向， 将关于槽 8 的命令请求长期地转向到节点 B 。</p><p>注意， 即使客户端出现 Bug ， 过早地将槽 8 映射到了节点 B 上面， 但只要这个客户端不发送 ASKING 命令， 客户端发送命令请求的时候就会遇上 MOVED 错误， 并将它转向回节点 A 。</p><h4 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h4><h5 id="节点失效检测"><a href="#节点失效检测" class="headerlink" title="节点失效检测"></a>节点失效检测</h5><p>以下是节点失效检查的实现方法：</p><ul><li><p>当一个节点向另一个节点发送 PING 命令， 但是目标节点未能在给定的时限内返回 PING 命令的回复时， 那么发送命令的节点会将目标节点标记为 PFAIL （possible failure，可能已失效）。</p><p>等待 PING 命令回复的时限称为“节点超时时限（node timeout）”， 是一个节点选项（node-wise setting）。</p></li><li><p>每次当节点对其他节点发送 PING 命令的时候， 它都会随机地广播三个它所知道的节点的信息， 这些信息里面的其中一项就是说明节点是否已经被标记为 PFAIL 或者 FAIL 。</p></li><li><p>当节点接收到其他节点发来的信息时， 它会记下那些被其他节点标记为失效的节点。 这称为失效报告（failure report）。</p></li><li><p>如果节点已经将某个节点标记为 PFAIL ， 并且根据节点所收到的失效报告显式， 集群中的大部分其他主节点也认为那个节点进入了失效状态， 那么节点会将那个失效节点的状态标记为 FAIL 。</p></li><li><p>一旦某个节点被标记为 FAIL ， 关于这个节点已失效的信息就会被广播到整个集群， 所有接收到这条信息的节点都会将失效节点标记为 FAIL 。</p></li></ul><p>简单来说， 一个节点要将另一个节点标记为失效， 必须先询问其他节点的意见， 并且得到大部分主节点的同意才行。</p><p>因为过期的失效报告会被移除， 所以主节点要将某个节点标记为 FAIL 的话， 必须以最近接收到的失效报告作为根据。</p><p>在以下两种情况中， 节点的 FAIL 状态会被移除：</p><ul><li><p>如果被标记为 FAIL 的是从节点， 那么当这个节点重新上线时， FAIL 标记就会被移除。</p><p>保持（retaning）从节点的 FAIL 状态是没有意义的， 因为它不处理任何槽， 一个从节点是否处于 FAIL 状态， 决定了这个从节点在有需要时能否被提升为主节点。</p></li><li><p>如果一个主节点被打上 FAIL 标记之后， 经过了节点超时时限的四倍时间， 再加上十秒钟之后， 针对这个主节点的槽的故障转移操作仍未完成， 并且这个主节点已经重新上线的话， 那么移除对这个节点的 FAIL 标记。</p></li></ul><p>在第二种情况中， 如果故障转移未能顺利完成， 并且主节点重新上线， 那么集群就继续使用原来的主节点， 从而免去管理员介入的必要。</p><h5 id="集群状态检测（已部分实现）"><a href="#集群状态检测（已部分实现）" class="headerlink" title="集群状态检测（已部分实现）"></a>集群状态检测（已部分实现）</h5><p>每当集群发生配置变化时（可能是哈希槽更新，也可能是某个节点进入失效状态）， 集群中的每个节点都会对它所知道的节点进行扫描（scan）。</p><p>一旦配置处理完毕， 集群会进入以下两种状态的其中一种：</p><ul><li>FAIL ： 集群不能正常工作。 当集群中有某个节点进入失效状态时， 集群不能处理任何命令请求， 对于每个命令请求， 集群节点都返回错误回复。</li><li>OK ： 集群可以正常工作， 负责处理全部 16384 个槽的节点中， 没有一个节点被标记为 FAIL 状态。</li></ul><p>这说明即使集群中只有一部分哈希槽不能正常使用， 整个集群也会停止处理任何命令。</p><p>不过节点从出现问题到被标记为 FAIL 状态的这段时间里， 集群仍然会正常运作， 所以集群在某些时候， 仍然有可能只能处理针对 16384 个槽的其中一个子集的命令请求。</p><p>以下是集群进入 FAIL 状态的两种情况：</p><ol><li>至少有一个哈希槽不可用，因为负责处理这个槽的节点进入了 FAIL 状态。</li><li>集群中的大部分主节点都进入下线状态。当大部分主节点都进入 PFAIL 状态时，集群也会进入 FAIL 状态。</li></ol><p>第二个检查是必须的， 因为要将一个节点从 PFAIL 状态改变为 FAIL 状态， 必须要有大部分主节点进行投票表决， 但是， 当集群中的大部分主节点都进入失效状态时， 单凭一个两个节点是没有办法将一个节点标记为 FAIL 状态的。</p><p>因此， 有了第二个检查条件， 只要集群中的大部分主节点进入了下线状态， 那么集群就可以在不请求这些主节点的意见下， 将某个节点判断为 FAIL 状态， 从而让整个集群停止处理命令请求。</p><h5 id="从节点选举"><a href="#从节点选举" class="headerlink" title="从节点选举"></a>从节点选举</h5><p>一旦某个主节点进入 FAIL 状态， 如果这个主节点有一个或多个从节点存在， 那么其中一个从节点会被升级为新的主节点， 而其他从节点则会开始对这个新的主节点进行复制。</p><p>新的主节点由已下线主节点属下的所有从节点中自行选举产生， 以下是选举的条件：</p><ul><li>这个节点是已下线主节点的从节点。</li><li>已下线主节点负责处理的槽数量非空。</li><li>从节点的数据被认为是可靠的， 也即是， 主从节点之间的复制连接（replication link）的断线时长不能超过节点超时时限（node timeout）乘以 REDIS_CLUSTER_SLAVE_VALIDITY_MULT 常量得出的积。</li></ul><p>如果一个从节点满足了以上的所有条件， 那么这个从节点将向集群中的其他主节点发送授权请求， 询问它们， 是否允许自己（从节点）升级为新的主节点。</p><p>如果发送授权请求的从节点满足以下属性， 那么主节点将向从节点返回 FAILOVER_AUTH_GRANTED 授权， 同意从节点的升级要求：</p><ul><li>发送授权请求的是一个从节点， 并且它所属的主节点处于 FAIL 状态。</li><li>在已下线主节点的所有从节点中， 这个从节点的节点 ID 在排序中是最小的。</li><li>这个从节点处于正常的运行状态： 它没有被标记为 FAIL 状态， 也没有被标记为 PFAIL 状态。</li></ul><p>一旦某个从节点在给定的时限内得到大部分主节点的授权， 它就会开始执行以下故障转移操作：</p><ul><li>通过 PONG 数据包（packet）告知其他节点， 这个节点现在是主节点了。</li><li>通过 PONG 数据包告知其他节点， 这个节点是一个已升级的从节点（promoted slave）。</li><li>接管（claiming）所有由已下线主节点负责处理的哈希槽。</li><li>显式地向所有节点广播一个 PONG 数据包， 加速其他节点识别这个节点的进度， 而不是等待定时的 PING / PONG 数据包。</li></ul><p>所有其他节点都会根据新的主节点对配置进行相应的更新，特别地：</p><ul><li>所有被新的主节点接管的槽会被更新。</li><li>已下线主节点的所有从节点会察觉到 PROMOTED 标志， 并开始对新的主节点进行复制。</li><li>如果已下线的主节点重新回到上线状态， 那么它会察觉到 PROMOTED 标志， 并将自身调整为现任主节点的从节点。</li></ul><p>在集群的生命周期中， 如果一个带有 PROMOTED 标识的主节点因为某些原因转变成了从节点， 那么该节点将丢失它所带有的 PROMOTED 标识。</p><h4 id="发布-订阅（已实现，但仍然需要改善）"><a href="#发布-订阅（已实现，但仍然需要改善）" class="headerlink" title="发布/订阅（已实现，但仍然需要改善）"></a>发布/订阅（已实现，但仍然需要改善）</h4><p>在一个 Redis 集群中， 客户端可以订阅任意一个节点， 也可以向任意一个节点发送信息， 节点会对客户端所发送的信息进行转发。</p><p>在目前的实现中， 节点会将接收到的信息广播至集群中的其他所有节点， 在将来的实现中， 可能会使用 bloom filter 或者其他算法来优化这一操作。</p><h4 id="附录-A：-CRC16-算法的-ANSI-实现参考"><a href="#附录-A：-CRC16-算法的-ANSI-实现参考" class="headerlink" title="附录 A： CRC16 算法的 ANSI 实现参考"></a>附录 A： CRC16 算法的 ANSI 实现参考</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright 2001-2010 Georges Menie (www.menie.org)</span></span><br><span class="line"><span class="comment"> * Copyright 2010 Salvatore Sanfilippo (adapted to Redis coding style)</span></span><br><span class="line"><span class="comment"> * All rights reserved.</span></span><br><span class="line"><span class="comment"> * Redistribution and use in source and binary forms, with or without</span></span><br><span class="line"><span class="comment"> * modification, are permitted provided that the following conditions are met:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     * Redistributions of source code must retain the above copyright</span></span><br><span class="line"><span class="comment"> *       notice, this list of conditions and the following disclaimer.</span></span><br><span class="line"><span class="comment"> *     * Redistributions in binary form must reproduce the above copyright</span></span><br><span class="line"><span class="comment"> *       notice, this list of conditions and the following disclaimer in the</span></span><br><span class="line"><span class="comment"> *       documentation and/or other materials provided with the distribution.</span></span><br><span class="line"><span class="comment"> *     * Neither the name of the University of California, Berkeley nor the</span></span><br><span class="line"><span class="comment"> *       names of its contributors may be used to endorse or promote products</span></span><br><span class="line"><span class="comment"> *       derived from this software without specific prior written permission.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY</span></span><br><span class="line"><span class="comment"> * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED</span></span><br><span class="line"><span class="comment"> * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span></span><br><span class="line"><span class="comment"> * DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY</span></span><br><span class="line"><span class="comment"> * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES</span></span><br><span class="line"><span class="comment"> * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;</span></span><br><span class="line"><span class="comment"> * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND</span></span><br><span class="line"><span class="comment"> * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span></span><br><span class="line"><span class="comment"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS</span></span><br><span class="line"><span class="comment"> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* CRC16 implementation acording to CCITT standards.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note by @antirez: this is actually the XMODEM CRC 16 algorithm, using the</span></span><br><span class="line"><span class="comment"> * following parameters:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Name                       : "XMODEM", also known as "ZMODEM", "CRC-16/ACORN"</span></span><br><span class="line"><span class="comment"> * Width                      : 16 bit</span></span><br><span class="line"><span class="comment"> * Poly                       : 1021 (That is actually x^16 + x^12 + x^5 + 1)</span></span><br><span class="line"><span class="comment"> * Initialization             : 0000</span></span><br><span class="line"><span class="comment"> * Reflect Input byte         : False</span></span><br><span class="line"><span class="comment"> * Reflect Output CRC         : False</span></span><br><span class="line"><span class="comment"> * Xor constant to output CRC : 0000</span></span><br><span class="line"><span class="comment"> * Output for "123456789"     : 31C3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint16_t</span> crc16tab[<span class="number">256</span>]= &#123;</span><br><span class="line">    <span class="number">0x0000</span>,<span class="number">0x1021</span>,<span class="number">0x2042</span>,<span class="number">0x3063</span>,<span class="number">0x4084</span>,<span class="number">0x50a5</span>,<span class="number">0x60c6</span>,<span class="number">0x70e7</span>,</span><br><span class="line">    <span class="number">0x8108</span>,<span class="number">0x9129</span>,<span class="number">0xa14a</span>,<span class="number">0xb16b</span>,<span class="number">0xc18c</span>,<span class="number">0xd1ad</span>,<span class="number">0xe1ce</span>,<span class="number">0xf1ef</span>,</span><br><span class="line">    <span class="number">0x1231</span>,<span class="number">0x0210</span>,<span class="number">0x3273</span>,<span class="number">0x2252</span>,<span class="number">0x52b5</span>,<span class="number">0x4294</span>,<span class="number">0x72f7</span>,<span class="number">0x62d6</span>,</span><br><span class="line">    <span class="number">0x9339</span>,<span class="number">0x8318</span>,<span class="number">0xb37b</span>,<span class="number">0xa35a</span>,<span class="number">0xd3bd</span>,<span class="number">0xc39c</span>,<span class="number">0xf3ff</span>,<span class="number">0xe3de</span>,</span><br><span class="line">    <span class="number">0x2462</span>,<span class="number">0x3443</span>,<span class="number">0x0420</span>,<span class="number">0x1401</span>,<span class="number">0x64e6</span>,<span class="number">0x74c7</span>,<span class="number">0x44a4</span>,<span class="number">0x5485</span>,</span><br><span class="line">    <span class="number">0xa56a</span>,<span class="number">0xb54b</span>,<span class="number">0x8528</span>,<span class="number">0x9509</span>,<span class="number">0xe5ee</span>,<span class="number">0xf5cf</span>,<span class="number">0xc5ac</span>,<span class="number">0xd58d</span>,</span><br><span class="line">    <span class="number">0x3653</span>,<span class="number">0x2672</span>,<span class="number">0x1611</span>,<span class="number">0x0630</span>,<span class="number">0x76d7</span>,<span class="number">0x66f6</span>,<span class="number">0x5695</span>,<span class="number">0x46b4</span>,</span><br><span class="line">    <span class="number">0xb75b</span>,<span class="number">0xa77a</span>,<span class="number">0x9719</span>,<span class="number">0x8738</span>,<span class="number">0xf7df</span>,<span class="number">0xe7fe</span>,<span class="number">0xd79d</span>,<span class="number">0xc7bc</span>,</span><br><span class="line">    <span class="number">0x48c4</span>,<span class="number">0x58e5</span>,<span class="number">0x6886</span>,<span class="number">0x78a7</span>,<span class="number">0x0840</span>,<span class="number">0x1861</span>,<span class="number">0x2802</span>,<span class="number">0x3823</span>,</span><br><span class="line">    <span class="number">0xc9cc</span>,<span class="number">0xd9ed</span>,<span class="number">0xe98e</span>,<span class="number">0xf9af</span>,<span class="number">0x8948</span>,<span class="number">0x9969</span>,<span class="number">0xa90a</span>,<span class="number">0xb92b</span>,</span><br><span class="line">    <span class="number">0x5af5</span>,<span class="number">0x4ad4</span>,<span class="number">0x7ab7</span>,<span class="number">0x6a96</span>,<span class="number">0x1a71</span>,<span class="number">0x0a50</span>,<span class="number">0x3a33</span>,<span class="number">0x2a12</span>,</span><br><span class="line">    <span class="number">0xdbfd</span>,<span class="number">0xcbdc</span>,<span class="number">0xfbbf</span>,<span class="number">0xeb9e</span>,<span class="number">0x9b79</span>,<span class="number">0x8b58</span>,<span class="number">0xbb3b</span>,<span class="number">0xab1a</span>,</span><br><span class="line">    <span class="number">0x6ca6</span>,<span class="number">0x7c87</span>,<span class="number">0x4ce4</span>,<span class="number">0x5cc5</span>,<span class="number">0x2c22</span>,<span class="number">0x3c03</span>,<span class="number">0x0c60</span>,<span class="number">0x1c41</span>,</span><br><span class="line">    <span class="number">0xedae</span>,<span class="number">0xfd8f</span>,<span class="number">0xcdec</span>,<span class="number">0xddcd</span>,<span class="number">0xad2a</span>,<span class="number">0xbd0b</span>,<span class="number">0x8d68</span>,<span class="number">0x9d49</span>,</span><br><span class="line">    <span class="number">0x7e97</span>,<span class="number">0x6eb6</span>,<span class="number">0x5ed5</span>,<span class="number">0x4ef4</span>,<span class="number">0x3e13</span>,<span class="number">0x2e32</span>,<span class="number">0x1e51</span>,<span class="number">0x0e70</span>,</span><br><span class="line">    <span class="number">0xff9f</span>,<span class="number">0xefbe</span>,<span class="number">0xdfdd</span>,<span class="number">0xcffc</span>,<span class="number">0xbf1b</span>,<span class="number">0xaf3a</span>,<span class="number">0x9f59</span>,<span class="number">0x8f78</span>,</span><br><span class="line">    <span class="number">0x9188</span>,<span class="number">0x81a9</span>,<span class="number">0xb1ca</span>,<span class="number">0xa1eb</span>,<span class="number">0xd10c</span>,<span class="number">0xc12d</span>,<span class="number">0xf14e</span>,<span class="number">0xe16f</span>,</span><br><span class="line">    <span class="number">0x1080</span>,<span class="number">0x00a1</span>,<span class="number">0x30c2</span>,<span class="number">0x20e3</span>,<span class="number">0x5004</span>,<span class="number">0x4025</span>,<span class="number">0x7046</span>,<span class="number">0x6067</span>,</span><br><span class="line">    <span class="number">0x83b9</span>,<span class="number">0x9398</span>,<span class="number">0xa3fb</span>,<span class="number">0xb3da</span>,<span class="number">0xc33d</span>,<span class="number">0xd31c</span>,<span class="number">0xe37f</span>,<span class="number">0xf35e</span>,</span><br><span class="line">    <span class="number">0x02b1</span>,<span class="number">0x1290</span>,<span class="number">0x22f3</span>,<span class="number">0x32d2</span>,<span class="number">0x4235</span>,<span class="number">0x5214</span>,<span class="number">0x6277</span>,<span class="number">0x7256</span>,</span><br><span class="line">    <span class="number">0xb5ea</span>,<span class="number">0xa5cb</span>,<span class="number">0x95a8</span>,<span class="number">0x8589</span>,<span class="number">0xf56e</span>,<span class="number">0xe54f</span>,<span class="number">0xd52c</span>,<span class="number">0xc50d</span>,</span><br><span class="line">    <span class="number">0x34e2</span>,<span class="number">0x24c3</span>,<span class="number">0x14a0</span>,<span class="number">0x0481</span>,<span class="number">0x7466</span>,<span class="number">0x6447</span>,<span class="number">0x5424</span>,<span class="number">0x4405</span>,</span><br><span class="line">    <span class="number">0xa7db</span>,<span class="number">0xb7fa</span>,<span class="number">0x8799</span>,<span class="number">0x97b8</span>,<span class="number">0xe75f</span>,<span class="number">0xf77e</span>,<span class="number">0xc71d</span>,<span class="number">0xd73c</span>,</span><br><span class="line">    <span class="number">0x26d3</span>,<span class="number">0x36f2</span>,<span class="number">0x0691</span>,<span class="number">0x16b0</span>,<span class="number">0x6657</span>,<span class="number">0x7676</span>,<span class="number">0x4615</span>,<span class="number">0x5634</span>,</span><br><span class="line">    <span class="number">0xd94c</span>,<span class="number">0xc96d</span>,<span class="number">0xf90e</span>,<span class="number">0xe92f</span>,<span class="number">0x99c8</span>,<span class="number">0x89e9</span>,<span class="number">0xb98a</span>,<span class="number">0xa9ab</span>,</span><br><span class="line">    <span class="number">0x5844</span>,<span class="number">0x4865</span>,<span class="number">0x7806</span>,<span class="number">0x6827</span>,<span class="number">0x18c0</span>,<span class="number">0x08e1</span>,<span class="number">0x3882</span>,<span class="number">0x28a3</span>,</span><br><span class="line">    <span class="number">0xcb7d</span>,<span class="number">0xdb5c</span>,<span class="number">0xeb3f</span>,<span class="number">0xfb1e</span>,<span class="number">0x8bf9</span>,<span class="number">0x9bd8</span>,<span class="number">0xabbb</span>,<span class="number">0xbb9a</span>,</span><br><span class="line">    <span class="number">0x4a75</span>,<span class="number">0x5a54</span>,<span class="number">0x6a37</span>,<span class="number">0x7a16</span>,<span class="number">0x0af1</span>,<span class="number">0x1ad0</span>,<span class="number">0x2ab3</span>,<span class="number">0x3a92</span>,</span><br><span class="line">    <span class="number">0xfd2e</span>,<span class="number">0xed0f</span>,<span class="number">0xdd6c</span>,<span class="number">0xcd4d</span>,<span class="number">0xbdaa</span>,<span class="number">0xad8b</span>,<span class="number">0x9de8</span>,<span class="number">0x8dc9</span>,</span><br><span class="line">    <span class="number">0x7c26</span>,<span class="number">0x6c07</span>,<span class="number">0x5c64</span>,<span class="number">0x4c45</span>,<span class="number">0x3ca2</span>,<span class="number">0x2c83</span>,<span class="number">0x1ce0</span>,<span class="number">0x0cc1</span>,</span><br><span class="line">    <span class="number">0xef1f</span>,<span class="number">0xff3e</span>,<span class="number">0xcf5d</span>,<span class="number">0xdf7c</span>,<span class="number">0xaf9b</span>,<span class="number">0xbfba</span>,<span class="number">0x8fd9</span>,<span class="number">0x9ff8</span>,</span><br><span class="line">    <span class="number">0x6e17</span>,<span class="number">0x7e36</span>,<span class="number">0x4e55</span>,<span class="number">0x5e74</span>,<span class="number">0x2e93</span>,<span class="number">0x3eb2</span>,<span class="number">0x0ed1</span>,<span class="number">0x1ef0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint16_t</span> crc16(<span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> len) &#123;</span><br><span class="line">    <span class="keyword">int</span> counter;</span><br><span class="line">    <span class="keyword">uint16_t</span> crc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (counter = <span class="number">0</span>; counter &lt; len; counter++)</span><br><span class="line">            crc = (crc&lt;&lt;<span class="number">8</span>) ^ crc16tab[((crc&gt;&gt;<span class="number">8</span>) ^ *buf++)&amp;<span class="number">0x00FF</span>];</span><br><span class="line">    <span class="keyword">return</span> crc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="持久化（persistence）"><a href="#持久化（persistence）" class="headerlink" title="持久化（persistence）"></a>持久化（persistence）</h2><p>这篇文章提供了 Redis 持久化的技术性描述， 推荐所有 Redis 用户阅读。</p><p>要更广泛地了解 Redis 持久化， 以及这种持久化所保证的耐久性（durability）， 请参考文章 Redis persistence demystified （中文）。</p><h3 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h3><p>Redis 提供了多种不同级别的持久化方式：</p><ul><li>RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）。</li><li>AOF 持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。 AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写（rewrite），使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小。</li><li>Redis 还可以同时使用 AOF 持久化和 RDB 持久化。 在这种情况下， 当 Redis 重启时， 它会优先使用 AOF 文件来还原数据集， 因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。</li><li>你甚至可以关闭持久化功能，让数据只在服务器运行时存在。</li></ul><p>了解 RDB 持久化和 AOF 持久化之间的异同是非常重要的， 以下几个小节将详细地介绍这这两种持久化功能， 并对它们的相同和不同之处进行说明。</p><h3 id="RDB-的优点"><a href="#RDB-的优点" class="headerlink" title="RDB 的优点"></a>RDB 的优点</h3><ul><li>RDB 是一个非常紧凑（compact）的文件，它保存了 Redis 在某个时间点上的数据集。 这种文件非常适合用于进行备份： 比如说，你可以在最近的 24 小时内，每小时备份一次 RDB 文件，并且在每个月的每一天，也备份一个 RDB 文件。 这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。</li><li>RDB 非常适用于灾难恢复（disaster recovery）：它只有一个文件，并且内容都非常紧凑，可以（在加密后）将它传送到别的数据中心，或者亚马逊 S3 中。</li><li>RDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。</li><li>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</li></ul><h3 id="RDB-的缺点"><a href="#RDB-的缺点" class="headerlink" title="RDB 的缺点"></a>RDB 的缺点</h3><ul><li>如果你需要尽量避免在服务器故障时丢失数据，那么 RDB 不适合你。 虽然 Redis 允许你设置不同的保存点（save point）来控制保存 RDB 文件的频率， 但是， 因为RDB 文件需要保存整个数据集的状态， 所以它并不是一个轻松的操作。 因此你可能会至少 5 分钟才保存一次 RDB 文件。 在这种情况下， 一旦发生故障停机， 你就可能会丢失好几分钟的数据。</li><li>每次保存 RDB 的时候，Redis 都要 fork() 出一个子进程，并由子进程来进行实际的持久化工作。 在数据集比较庞大时， fork() 可能会非常耗时，造成服务器在某某毫秒内停止处理客户端； 如果数据集非常巨大，并且 CPU 时间非常紧张的话，那么这种停止时间甚至可能会长达整整一秒。 虽然 AOF 重写也需要进行 fork() ，但无论 AOF 重写的执行间隔有多长，数据的耐久性都不会有任何损失。</li></ul><h3 id="AOF-的优点"><a href="#AOF-的优点" class="headerlink" title="AOF 的优点"></a>AOF 的优点</h3><ul><li>使用 AOF 持久化会让 Redis 变得非常耐久（much more durable）：你可以设置不同的 fsync 策略，比如无 fsync ，每秒钟一次 fsync ，或者每次执行写入命令时 fsync 。 AOF 的默认策略为每秒钟 fsync 一次，在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据（ fsync 会在后台线程执行，所以主线程可以继续努力地处理命令请求）。</li><li>AOF 文件是一个只进行追加操作的日志文件（append only log）， 因此对 AOF 文件的写入不需要进行 seek ， 即使日志因为某些原因而包含了未写入完整的命令（比如写入时磁盘已满，写入中途停机，等等）， redis-check-aof 工具也可以轻易地修复这种问题。</li><li>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。</li><li>AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单： 举个例子， 如果你不小心执行了 FLUSHALL 命令， 但只要 AOF 文件未被重写， 那么只要停止服务器， 移除 AOF 文件末尾的 FLUSHALL 命令， 并重启 Redis ， 就可以将数据集恢复到 FLUSHALL 执行之前的状态。</li></ul><h3 id="AOF-的缺点"><a href="#AOF-的缺点" class="headerlink" title="AOF 的缺点"></a>AOF 的缺点</h3><ul><li>对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。</li><li>根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）。</li><li>AOF 在过去曾经发生过这样的 bug ： 因为个别命令的原因，导致 AOF 文件在重新载入时，无法将数据集恢复成保存时的原样。 （举个例子，阻塞命令 BRPOPLPUSH source destination timeout 就曾经引起过这样的 bug 。） 测试套件里为这种情况添加了测试： 它们会自动生成随机的、复杂的数据集， 并通过重新载入这些数据来确保一切正常。 虽然这种 bug 在 AOF 文件中并不常见， 但是对比来说， RDB 几乎是不可能出现这种 bug 的。</li></ul><h3 id="RDB-和-AOF-，我应该用哪一个？"><a href="#RDB-和-AOF-，我应该用哪一个？" class="headerlink" title="RDB 和 AOF ，我应该用哪一个？"></a>RDB 和 AOF ，我应该用哪一个？</h3><p>一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。</p><p>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。</p><p>有很多用户都只使用 AOF 持久化， 但我们并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快， 除此之外， 使用 RDB 还可以避免之前提到的 AOF 程序的 bug 。</p><p><strong>Note</strong></p><pre><code>因为以上提到的种种原因， 未来可能会将 AOF 和 RDB 整合成单个持久化模型。 （这是一个长期计划。）</code></pre><p>接下来的几个小节将介绍 RDB 和 AOF 的更多细节。</p><h3 id="RDB-快照"><a href="#RDB-快照" class="headerlink" title="RDB 快照"></a>RDB 快照</h3><p>在默认情况下， Redis 将数据库快照保存在名字为 dump.rdb 的二进制文件中。</p><p>你可以对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动保存一次数据集。</p><p>你也可以通过调用 SAVE 或者 BGSAVE ， 手动让 Redis 进行数据集保存操作。</p><p>比如说， 以下设置会让 Redis 在满足“ 60 秒内有至少有 1000 个键被改动”这一条件时， 自动保存一次数据集：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save 60 1000</span><br></pre></td></tr></table></figure></p><p>这种持久化方式被称为快照（snapshot）。</p><h3 id="快照的运作方式"><a href="#快照的运作方式" class="headerlink" title="快照的运作方式"></a>快照的运作方式</h3><p>当 Redis 需要保存 dump.rdb 文件时， 服务器执行以下操作：</p><ol><li>Redis 调用 fork() ，同时拥有父进程和子进程。</li><li>子进程将数据集写入到一个临时 RDB 文件中。</li><li>当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。</li></ol><p>这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益。</p><h3 id="只进行追加操作的文件（append-only-file，AOF）"><a href="#只进行追加操作的文件（append-only-file，AOF）" class="headerlink" title="只进行追加操作的文件（append-only file，AOF）"></a>只进行追加操作的文件（append-only file，AOF）</h3><p>快照功能并不是非常耐久（durable）： 如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、且仍未保存到快照中的那些数据。</p><p>尽管对于某些程序来说， 数据的耐久性并不是最重要的考虑因素， 但是对于那些追求完全耐久能力（full durability）的程序来说， 快照功能就不太适用了。</p><p>从 1.1 版本开始， Redis 增加了一种完全耐久的持久化方式： AOF 持久化。</p><p>你可以通过修改配置文件来打开 AOF 功能：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure></p><p>从现在开始， 每当 Redis 执行一个改变数据集的命令时（比如 SET key value [EX seconds] [PX milliseconds] [NX|XX]）， 这个命令就会被追加到 AOF 文件的末尾。</p><p>这样的话， 当 Redis 重新启时， 程序就可以通过重新执行 AOF 文件中的命令来达到重建数据集的目的。</p><h3 id="AOF-重写"><a href="#AOF-重写" class="headerlink" title="AOF 重写"></a>AOF 重写</h3><p>因为 AOF 的运作方式是不断地将命令追加到文件的末尾， 所以随着写入命令的不断增加， AOF 文件的体积也会变得越来越大。</p><p>举个例子， 如果你对一个计数器调用了 100 次 INCR key ， 那么仅仅是为了保存这个计数器的当前值， AOF 文件就需要使用 100 条记录（entry）。</p><p>然而在实际上， 只使用一条 SET key value [EX seconds] [PX milliseconds] [NX|XX] 命令已经足以保存计数器的当前值了， 其余 99 条记录实际上都是多余的。</p><p>为了处理这种情况， Redis 支持一种有趣的特性： 可以在不打断服务客户端的情况下， 对 AOF 文件进行重建（rebuild）。</p><p>执行 BGREWRITEAOF 命令， Redis 将生成一个新的 AOF 文件， 这个文件包含重建当前数据集所需的最少命令。</p><p>Redis 2.2 需要自己手动执行 BGREWRITEAOF 命令； Redis 2.4 则可以自动触发 AOF 重写， 具体信息请查看 2.4 的示例配置文件。</p><h3 id="AOF-的耐久性如何？"><a href="#AOF-的耐久性如何？" class="headerlink" title="AOF 的耐久性如何？"></a>AOF 的耐久性如何？</h3><p>你可以配置 Redis 多久才将数据 fsync 到磁盘一次。</p><p>有三个选项：</p><ul><li>每次有新命令追加到 AOF 文件时就执行一次 fsync ：非常慢，也非常安全。</li><li>每秒 fsync 一次：足够快（和使用 RDB 持久化差不多），并且在故障时只会丢失 1 秒钟的数据。</li><li>从不 fsync ：将数据交给操作系统来处理。更快，也更不安全的选择。</li></ul><p>推荐（并且也是默认）的措施为每秒 fsync 一次， 这种 fsync 策略可以兼顾速度和安全性。</p><p>总是 fsync 的策略在实际使用中非常慢， 即使在 Redis 2.0 对相关的程序进行了改进之后仍是如此 —— 频繁调用 fsync 注定了这种策略不可能快得起来。</p><h3 id="如果-AOF-文件出错了，怎么办？"><a href="#如果-AOF-文件出错了，怎么办？" class="headerlink" title="如果 AOF 文件出错了，怎么办？"></a>如果 AOF 文件出错了，怎么办？</h3><p>服务器可能在程序正在对 AOF 文件进行写入时停机， 如果停机造成了 AOF 文件出错（corrupt）， 那么 Redis 在重启时会拒绝载入这个 AOF 文件， 从而确保数据的一致性不会被破坏。</p><p>当发生这种情况时， 可以用以下方法来修复出错的 AOF 文件：</p><ol><li>为现有的 AOF 文件创建一个备份。</li><li><p>使用 Redis 附带的 redis-check-aof 程序，对原来的 AOF 文件进行修复。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-check-aof --fix</span><br></pre></td></tr></table></figure></li><li><p>（可选）使用 diff -u 对比修复后的 AOF 文件和原始 AOF 文件的备份，查看两个文件之间的不同之处。</p></li><li>重启 Redis 服务器，等待服务器载入修复后的 AOF 文件，并进行数据恢复。</li></ol><h3 id="AOF-的运作方式"><a href="#AOF-的运作方式" class="headerlink" title="AOF 的运作方式"></a>AOF 的运作方式</h3><p>AOF 重写和 RDB 创建快照一样，都巧妙地利用了写时复制机制。</p><p>以下是 AOF 重写的执行步骤：</p><ol><li>Redis 执行 fork() ，现在同时拥有父进程和子进程。</li><li>子进程开始将新 AOF 文件的内容写入到临时文件。</li><li>对于所有新执行的写入命令，父进程一边将它们累积到一个内存缓存中，一边将这些改动追加到现有 AOF 文件的末尾： 这样即使在重写的中途发生停机，现有的 AOF 文件也还是安全的。</li><li>当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据追加到新 AOF 文件的末尾。</li><li>搞定！现在 Redis 原子地用新文件替换旧文件，之后所有命令都会直接追加到新 AOF 文件的末尾。</li></ol><h3 id="怎么从-RDB-持久化切换到-AOF-持久化"><a href="#怎么从-RDB-持久化切换到-AOF-持久化" class="headerlink" title="怎么从 RDB 持久化切换到 AOF 持久化"></a>怎么从 RDB 持久化切换到 AOF 持久化</h3><p>在 Redis 2.2 或以上版本，可以在不重启的情况下，从 RDB 切换到 AOF ：</p><ol><li>为最新的 dump.rdb 文件创建一个备份。</li><li>将备份放到一个安全的地方。</li><li><p>执行以下两条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli&gt; CONFIG SET appendonly yes</span><br><span class="line"></span><br><span class="line">redis-cli&gt; CONFIG SET save <span class="string">""</span></span><br></pre></td></tr></table></figure></li><li><p>确保命令执行之后，数据库的键的数量没有改变。</p></li><li>确保写命令会被正确地追加到 AOF 文件的末尾。</li></ol><p>步骤 3 执行的第一条命令开启了 AOF 功能： Redis 会阻塞直到初始 AOF 文件创建完成为止， 之后 Redis 会继续处理命令请求， 并开始将写入命令追加到 AOF 文件末尾。</p><p>步骤 3 执行的第二条命令用于关闭 RDB 功能。 这一步是可选的， 如果你愿意的话， 也可以同时使用 RDB 和 AOF 这两种持久化功能。</p><p><strong>Note</strong></p><pre><code>别忘了在 redis.conf 中打开 AOF 功能！ 否则的话， 服务器重启之后， 之前通过 CONFIG SET 设置的配置就会被遗忘， 程序会按原来的配置来启动服务器。</code></pre><h3 id="RDB-和-AOF-之间的相互作用"><a href="#RDB-和-AOF-之间的相互作用" class="headerlink" title="RDB 和 AOF 之间的相互作用"></a>RDB 和 AOF 之间的相互作用</h3><p>在版本号大于等于 2.4 的 Redis 中， BGSAVE 执行的过程中， 不可以执行 BGREWRITEAOF 。 反过来说， 在 BGREWRITEAOF 执行的过程中， 也不可以执行 BGSAVE 。</p><p>这可以防止两个 Redis 后台进程同时对磁盘进行大量的 I/O 操作。</p><p>如果 BGSAVE 正在执行， 并且用户显示地调用 BGREWRITEAOF 命令， 那么服务器将向用户回复一个 OK 状态， 并告知用户， BGREWRITEAOF 已经被预定执行： 一旦 BGSAVE 执行完毕， BGREWRITEAOF 就会正式开始。</p><p>当 Redis 启动时， 如果 RDB 持久化和 AOF 持久化都被打开了， 那么程序会优先使用 AOF 文件来恢复数据集， 因为 AOF 文件所保存的数据通常是最完整的。</p><h3 id="备份-Redis-数据"><a href="#备份-Redis-数据" class="headerlink" title="备份 Redis 数据"></a>备份 Redis 数据</h3><p>在阅读这个小节前， 先将下面这句话铭记于心： 一定要备份你的数据库！</p><p>磁盘故障， 节点失效， 诸如此类的问题都可能让你的数据消失不见， 不进行备份是非常危险的。</p><p>Redis 对于数据备份是非常友好的， 因为你可以在服务器运行的时候对 RDB 文件进行复制： RDB 文件一旦被创建， 就不会进行任何修改。 当服务器要创建一个新的 RDB 文件时， 它先将文件的内容保存在一个临时文件里面， 当临时文件写入完毕时， 程序才使用 rename(2) 原子地用临时文件替换原来的 RDB 文件。</p><p>这也就是说， 无论何时， 复制 RDB 文件都是绝对安全的。</p><p>以下是我们的建议：</p><ul><li>创建一个定期任务（cron job）， 每小时将一个 RDB 文件备份到一个文件夹， 并且每天将一个 RDB 文件备份到另一个文件夹。</li><li>确保快照的备份都带有相应的日期和时间信息， 每次执行定期任务脚本时， 使用 find 命令来删除过期的快照： 比如说， 你可以保留最近 48 小时内的每小时快照， 还可以保留最近一两个月的每日快照。</li><li>至少每天一次， 将 RDB 备份到你的数据中心之外， 或者至少是备份到你运行 Redis 服务器的物理机器之外。</li></ul><h3 id="容灾备份"><a href="#容灾备份" class="headerlink" title="容灾备份"></a>容灾备份</h3><p>Redis 的容灾备份基本上就是对数据进行备份， 并将这些备份传送到多个不同的外部数据中心。</p><p>容灾备份可以在 Redis 运行并产生快照的主数据中心发生严重的问题时， 仍然让数据处于安全状态。</p><p>因为很多 Redis 用户都是创业者， 他们没有大把大把的钱可以浪费， 所以下面介绍的都是一些实用又便宜的容灾备份方法：</p><ul><li>Amazon S3 ，以及其他类似 S3 的服务，是一个构建灾难备份系统的好地方。 最简单的方法就是将你的每小时或者每日 RDB 备份加密并传送到 S3 。 对数据的加密可以通过 gpg -c 命令来完成（对称加密模式）。 记得把你的密码放到几个不同的、安全的地方去（比如你可以把密码复制给你组织里最重要的人物）。 同时使用多个储存服务来保存数据文件，可以提升数据的安全性。</li><li>传送快照可以使用 SCP 来完成（SSH 的组件）。 以下是简单并且安全的传送方法： 买一个离你的数据中心非常远的 VPS ， 装上 SSH ， 创建一个无口令的 SSH 客户端 key ， 并将这个 key 添加到 VPS 的 authorized_keys 文件中， 这样就可以向这个 VPS 传送快照备份文件了。 为了达到最好的数据安全性，至少要从两个不同的提供商那里各购买一个 VPS 来进行数据容灾备份。</li></ul><p>需要注意的是， 这类容灾系统如果没有小心地进行处理的话， 是很容易失效的。</p><p>最低限度下， 你应该在文件传送完毕之后， 检查所传送备份文件的体积和原始快照文件的体积是否相同。 如果你使用的是 VPS ， 那么还可以通过比对文件的 SHA1 校验和来确认文件是否传送完整。</p><p>另外， 你还需要一个独立的警报系统， 让它在负责传送备份文件的传送器（transfer）失灵时通知你。</p><h2 id="发布与订阅（pub-sub）"><a href="#发布与订阅（pub-sub）" class="headerlink" title="发布与订阅（pub/sub）"></a>发布与订阅（pub/sub）</h2><p>SUBSCRIBE channel [channel …] 、 UNSUBSCRIBE [channel [channel …]] 和 PUBLISH channel message 三个命令实现了发布与订阅信息泛型（Publish/Subscribe messaging paradigm）， 在这个实现中， 发送者（发送信息的客户端）不是将信息直接发送给特定的接收者（接收信息的客户端）， 而是将信息发送给频道（channel）， 然后由频道将信息转发给所有对这个频道感兴趣的订阅者。</p><p>发送者无须知道任何关于订阅者的信息， 而订阅者也无须知道是那个客户端给它发送信息， 它只要关注自己感兴趣的频道即可。</p><p>对发布者和订阅者进行解构（decoupling）， 可以极大地提高系统的扩展性（scalability）， 并得到一个更动态的网络拓扑（network topology）。</p><p>比如说， 要订阅频道 foo 和 bar ， 客户端可以使用频道名字作为参数来调用 SUBSCRIBE channel [channel …] 命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SUBSCRIBE foo bar</span><br></pre></td></tr></table></figure></p><p>当有客户端发送信息到这些频道时， Redis 会将传入的信息推送到所有订阅这些频道的客户端里面。</p><p>正在订阅频道的客户端不应该发送除 SUBSCRIBE channel [channel …] 和 UNSUBSCRIBE [channel [channel …]] 之外的其他命令。 其中， SUBSCRIBE channel [channel …] 可以用于订阅更多频道， 而 UNSUBSCRIBE [channel [channel …]] 则可以用于退订已订阅的一个或多个频道。</p><p>SUBSCRIBE channel [channel …] 和 UNSUBSCRIBE [channel [channel …]] 的执行结果会以信息的形式返回， 客户端可以通过分析所接收信息的第一个元素， 从而判断所收到的内容是一条真正的信息， 还是 SUBSCRIBE channel [channel …] 或 UNSUBSCRIBE [channel [channel …]] 命令的操作结果。</p><h3 id="信息的格式"><a href="#信息的格式" class="headerlink" title="信息的格式"></a>信息的格式</h3><p>频道转发的每条信息都是一条带有三个元素的多条批量回复（multi-bulk reply）。</p><p>信息的第一个元素标识了信息的类型：</p><ul><li>subscribe ： 表示当前客户端成功地订阅了信息第二个元素所指示的频道。 而信息的第三个元素则记录了目前客户端已订阅频道的总数。</li><li>unsubscribe ： 表示当前客户端成功地退订了信息第二个元素所指示的频道。 信息的第三个元素记录了客户端目前仍在订阅的频道数量。 当客户端订阅的频道数量降为 0 时， 客户端不再订阅任何频道， 它可以像往常一样， 执行任何 Redis 命令。</li><li>message ： 表示这条信息是由某个客户端执行 PUBLISH channel message 命令所发送的， 真正的信息。 信息的第二个元素是信息来源的频道， 而第三个元素则是信息的内容。</li></ul><p>举个例子， 如果客户端执行以下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SUBSCRIBE first second</span><br></pre></td></tr></table></figure></p><p>那么它将收到以下回复：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1) <span class="string">"subscribe"</span></span><br><span class="line">2) <span class="string">"first"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">4) <span class="string">"subscribe"</span></span><br><span class="line">5) <span class="string">"second"</span></span><br><span class="line">6) (<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure></p><p>如果在这时， 另一个客户端执行以下 PUBLISH channel message 命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; PUBLISH second Hello</span><br></pre></td></tr></table></figure></p><p>那么之前订阅了 second 频道的客户端将收到以下信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1) <span class="string">"message"</span></span><br><span class="line">2) <span class="string">"second"</span></span><br><span class="line">3) <span class="string">"hello"</span></span><br></pre></td></tr></table></figure></p><p>当订阅者决定退订所有频道时， 它可以执行一个无参数的 UNSUBSCRIBE [channel [channel …]] 命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; UNSUBSCRIBE</span><br></pre></td></tr></table></figure></p><p>这个命令将接到以下回复：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1) <span class="string">"unsubscribe"</span></span><br><span class="line">2) <span class="string">"second"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">1) <span class="string">"unsubscribe"</span></span><br><span class="line">2) <span class="string">"first"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure></p><h3 id="订阅模式"><a href="#订阅模式" class="headerlink" title="订阅模式"></a>订阅模式</h3><p>Redis 的发布与订阅实现支持模式匹配（pattern matching）： 客户端可以订阅一个带 * 号的模式， 如果某个/某些频道的名字和这个模式匹配， 那么当有信息发送给这个/这些频道的时候， 客户端也会收到这个/这些频道的信息。</p><p>比如说，执行命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; PSUBSCRIBE news.*</span><br></pre></td></tr></table></figure></p><p>的客户端将收到来自 news.art.figurative 、 news.music.jazz 等频道的信息。</p><p>客户端订阅的模式里面可以包含多个 glob 风格的通配符， 比如 * 、 ? 和 […] ， 等等。</p><p>执行命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; PUNSUBSCRIBE news.*</span><br></pre></td></tr></table></figure></p><p>将退订 news.* 模式， 其他已订阅的模式不会被影响。</p><p>通过订阅模式接收到的信息， 和通过订阅频道接收到的信息， 这两者的格式不太一样：</p><ul><li>通过订阅模式而接收到的信息的类型为 pmessage ： 这代表有某个客户端通过 PUBLISH channel message 向某个频道发送了信息， 而这个频道刚好匹配了当前客户端所订阅的某个模式。 信息的第二个元素记录了被匹配的模式， 第三个元素记录了被匹配的频道的名字， 最后一个元素则记录了信息的实际内容。</li></ul><p>客户端处理 PSUBSCRIBE pattern [pattern …] 和 PUNSUBSCRIBE [pattern [pattern …]] 返回值的方式， 和客户端处理 SUBSCRIBE channel [channel …] 和 UNSUBSCRIBE [channel [channel …]] 的方式类似： 通过对信息的第一个元素进行分析， 客户端可以判断接收到的信息是一个真正的信息， 还是 PSUBSCRIBE pattern [pattern …] 或 PUNSUBSCRIBE [pattern [pattern …]] 命令的返回值。</p><h3 id="通过频道和模式接收同一条信息"><a href="#通过频道和模式接收同一条信息" class="headerlink" title="通过频道和模式接收同一条信息"></a>通过频道和模式接收同一条信息</h3><p>如果客户端订阅的多个模式匹配了同一个频道， 或者客户端同时订阅了某个频道、以及匹配这个频道的某个模式， 那么它可能会多次接收到同一条信息。</p><p>举个例子， 如果客户端执行了以下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SUBSCRIBE foo</span><br><span class="line">PSUBSCRIBE f*</span><br></pre></td></tr></table></figure></p><p>那么当有信息发送到频道 foo 时， 客户端将收到两条信息： 一条来自频道 foo ，信息类型为 message ； 另一条来自模式 f* ，信息类型为 pmessage 。</p><h3 id="订阅总数"><a href="#订阅总数" class="headerlink" title="订阅总数"></a>订阅总数</h3><p>在执行 SUBSCRIBE channel [channel …] 、 UNSUBSCRIBE [channel [channel …]] 、 PSUBSCRIBE pattern [pattern …] 和 PUNSUBSCRIBE [pattern [pattern …]] 命令时， 返回结果的最后一个元素是客户端目前仍在订阅的频道和模式总数。</p><p>当客户端退订所有频道和模式， 也即是这个总数值下降为 0 的时候， 客户端将退出订阅与发布状态。</p><h3 id="编程示例"><a href="#编程示例" class="headerlink" title="编程示例"></a>编程示例</h3><p>Pieter Noordhuis 提供了一个使用 EventMachine 和 Redis 编写的 高性能多用户网页聊天软件 ， 这个软件很好地展示了发布与订阅功能的用法。</p><h3 id="客户端库实现提示"><a href="#客户端库实现提示" class="headerlink" title="客户端库实现提示"></a>客户端库实现提示</h3><p>因为所有接收到的信息都会包含一个信息来源：</p><ul><li>当信息来自频道时，来源是某个频道；</li><li>当信息来自模式时，来源是某个模式。</li></ul><p>因此， 客户端可以用一个哈希表， 将特定来源和处理该来源的回调函数关联起来。 当有新信息到达时， 程序就可以根据信息的来源， 在 O(1) 复杂度内， 将信息交给正确的回调函数来处理。</p><h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><p>Redis 的 Sentinel 系统用于管理多个 Redis 服务器（instance）， 该系统执行以下三个任务：</p><ul><li>监控（Monitoring）： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。</li><li>提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</li><li>自动故障迁移（Automatic failover）： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。</li></ul><p>Redis Sentinel 是一个分布式系统， 你可以在一个架构中运行多个 Sentinel 进程（progress）， 这些进程使用流言协议（gossip protocols)来接收关于主服务器是否下线的信息， 并使用投票协议（agreement protocols）来决定是否执行自动故障迁移， 以及选择哪个从服务器作为新的主服务器。</p><p>虽然 Redis Sentinel 释出为一个单独的可执行文件 redis-sentinel ， 但实际上它只是一个运行在特殊模式下的 Redis 服务器， 你可以在启动一个普通 Redis 服务器时通过给定 –sentinel 选项来启动 Redis Sentinel 。</p><p><strong>Warning</strong></p><pre><code>Redis Sentinel 目前仍在开发中， 这个文档的内容可能随着 Sentinel 实现的修改而变更。Redis Sentinel 兼容 Redis 2.4.16 或以上版本， 推荐使用 Redis 2.8.0 或以上的版本。</code></pre><h3 id="获取-Sentinel"><a href="#获取-Sentinel" class="headerlink" title="获取 Sentinel"></a>获取 Sentinel</h3><p>目前 Sentinel 系统是 Redis 的 unstable 分支的一部分， 你必须到 Redis 项目的 Github 页面 克隆一份 unstable 分值， 然后通过编译来获得 Sentinel 系统。</p><p>Sentinel 程序可以在编译后的 src 文档中发现， 它是一个命名为 redis-sentinel 的程序。</p><p>你也可以通过下一节介绍的方法， 让 redis-server 程序运行在 Sentinel 模式之下。</p><p>另外， 一个新版本的 Sentinel 已经包含在了 Redis 2.8.0 版本的释出文件中。</p><h3 id="启动-Sentinel"><a href="#启动-Sentinel" class="headerlink" title="启动 Sentinel"></a>启动 Sentinel</h3><p>对于 redis-sentinel 程序， 你可以用以下命令来启动 Sentinel 系统：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel /path/to/sentinel.conf</span><br></pre></td></tr></table></figure></p><p>对于 redis-server 程序， 你可以用以下命令来启动一个运行在 Sentinel 模式下的 Redis 服务器：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /path/to/sentinel.conf --sentinel</span><br></pre></td></tr></table></figure></p><p>两种方法都可以启动一个 Sentinel 实例。</p><p>启动 Sentinel 实例必须指定相应的配置文件， 系统会使用配置文件来保存 Sentinel 的当前状态， 并在 Sentinel 重启时通过载入配置文件来进行状态还原。</p><p>如果启动 Sentinel 时没有指定相应的配置文件， 或者指定的配置文件不可写（not writable）， 那么 Sentinel 会拒绝启动。</p><h3 id="配置-Sentinel"><a href="#配置-Sentinel" class="headerlink" title="配置 Sentinel"></a>配置 Sentinel</h3><p>Redis 源码中包含了一个名为 sentinel.conf 的文件， 这个文件是一个带有详细注释的 Sentinel 配置文件示例。</p><p>运行一个 Sentinel 所需的最少配置如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 60000</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"></span><br><span class="line">sentinel monitor resque 192.168.1.3 6380 4</span><br><span class="line">sentinel down-after-milliseconds resque 10000</span><br><span class="line">sentinel failover-timeout resque 180000</span><br><span class="line">sentinel parallel-syncs resque 5</span><br></pre></td></tr></table></figure></p><p>第一行配置指示 Sentinel 去监视一个名为 mymaster 的主服务器， 这个主服务器的 IP 地址为 127.0.0.1 ， 端口号为 6379 ， 而将这个主服务器判断为失效至少需要 2 个 Sentinel 同意 （只要同意 Sentinel 的数量不达标，自动故障迁移就不会执行）。</p><p>不过要注意， 无论你设置要多少个 Sentinel 同意才能判断一个服务器失效， 一个 Sentinel 都需要获得系统中多数（majority） Sentinel 的支持， 才能发起一次自动故障迁移， 并预留一个给定的配置纪元 （configuration Epoch ，一个配置纪元就是一个新主服务器配置的版本号）。</p><p>换句话说， 在只有少数（minority） Sentinel 进程正常运作的情况下， Sentinel 是不能执行自动故障迁移的。</p><p>其他选项的基本格式如下：</p><pre><code>sentinel &lt;选项的名字&gt; &lt;主服务器的名字&gt; &lt;选项的值&gt;</code></pre><p>各个选项的功能如下：</p><ul><li><p>down-after-milliseconds 选项指定了 Sentinel 认为服务器已经断线所需的毫秒数。</p><p>  如果服务器在给定的毫秒数之内， 没有返回 Sentinel 发送的 PING 命令的回复， 或者返回一个错误， 那么 Sentinel 将这个服务器标记为主观下线（subjectively down，简称 SDOWN ）。</p><p>  不过只有一个 Sentinel 将服务器标记为主观下线并不一定会引起服务器的自动故障迁移： 只有在足够数量的 Sentinel 都将一个服务器标记为主观下线之后， 服务器才会被标记为客观下线（objectively down， 简称 ODOWN ）， 这时自动故障迁移才会执行。</p><p>  将服务器标记为客观下线所需的 Sentinel 数量由对主服务器的配置决定。</p></li><li><p>parallel-syncs 选项指定了在执行故障转移时， 最多可以有多少个从服务器同时对新的主服务器进行同步， 这个数字越小， 完成故障转移所需的时间就越长。</p><p>  如果从服务器被设置为允许使用过期数据集（参见对 redis.conf 文件中对 slave-serve-stale-data 选项的说明）， 那么你可能不希望所有从服务器都在同一时间向新的主服务器发送同步请求， 因为尽管复制过程的绝大部分步骤都不会阻塞从服务器， 但从服务器在载入主服务器发来的 RDB 文件时， 仍然会造成从服务器在一段时间内不能处理命令请求： 如果全部从服务器一起对新的主服务器进行同步， 那么就可能会造成所有从服务器在短时间内全部不可用的情况出现。</p><p>  你可以通过将这个值设为 1 来保证每次只有一个从服务器处于不能处理命令请求的状态。</p></li></ul><p>本文档剩余的内容将对 Sentinel 系统的其他选项进行介绍， 示例配置文件 sentinel.conf 也对相关的选项进行了完整的注释。</p><h3 id="主观下线和客观下线"><a href="#主观下线和客观下线" class="headerlink" title="主观下线和客观下线"></a>主观下线和客观下线</h3><p>前面说过， Redis 的 Sentinel 中关于下线（down）有两个不同的概念：</p><ul><li>主观下线（Subjectively Down， 简称 SDOWN）指的是单个 Sentinel 实例对服务器做出的下线判断。</li><li>客观下线（Objectively Down， 简称 ODOWN）指的是多个 Sentinel 实例在对同一个服务器做出 SDOWN 判断， 并且通过 SENTINEL is-master-down-by-addr 命令互相交流之后， 得出的服务器下线判断。 （一个 Sentinel 可以通过向另一个 Sentinel 发送 SENTINEL is-master-down-by-addr 命令来询问对方是否认为给定的服务器已下线。）</li></ul><p>如果一个服务器没有在 master-down-after-milliseconds 选项所指定的时间内， 对向它发送 PING 命令的 Sentinel 返回一个有效回复（valid reply）， 那么 Sentinel 就会将这个服务器标记为主观下线。</p><p>服务器对 PING 命令的有效回复可以是以下三种回复的其中一种：</p><ul><li>返回 +PONG 。</li><li>返回 -LOADING 错误。</li><li>返回 -MASTERDOWN 错误。</li></ul><p>如果服务器返回除以上三种回复之外的其他回复， 又或者在指定时间内没有回复 PING 命令， 那么 Sentinel 认为服务器返回的回复无效（non-valid）。</p><p>注意， 一个服务器必须在 master-down-after-milliseconds 毫秒内， 一直返回无效回复才会被 Sentinel 标记为主观下线。</p><p>举个例子， 如果 master-down-after-milliseconds 选项的值为 30000 毫秒（30 秒）， 那么只要服务器能在每 29 秒之内返回至少一次有效回复， 这个服务器就仍然会被认为是处于正常状态的。</p><p>从主观下线状态切换到客观下线状态并没有使用严格的法定人数算法（strong quorum algorithm）， 而是使用了流言协议： 如果 Sentinel 在给定的时间范围内， 从其他 Sentinel 那里接收到了足够数量的主服务器下线报告， 那么 Sentinel 就会将主服务器的状态从主观下线改变为客观下线。 如果之后其他 Sentinel 不再报告主服务器已下线， 那么客观下线状态就会被移除。</p><p>客观下线条件只适用于主服务器： 对于任何其他类型的 Redis 实例， Sentinel 在将它们判断为下线前不需要进行协商， 所以从服务器或者其他 Sentinel 永远不会达到客观下线条件。</p><p>只要一个 Sentinel 发现某个主服务器进入了客观下线状态， 这个 Sentinel 就可能会被其他 Sentinel 推选出， 并对失效的主服务器执行自动故障迁移操作。</p><h3 id="每个-Sentinel-都需要定期执行的任务"><a href="#每个-Sentinel-都需要定期执行的任务" class="headerlink" title="每个 Sentinel 都需要定期执行的任务"></a>每个 Sentinel 都需要定期执行的任务</h3><ul><li>每个 Sentinel 以每秒钟一次的频率向它所知的主服务器、从服务器以及其他 Sentinel 实例发送一个 PING 命令。</li><li>如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 那么这个实例会被 Sentinel 标记为主观下线。 一个有效回复可以是： +PONG 、 -LOADING 或者 -MASTERDOWN 。</li><li>如果一个主服务器被标记为主观下线， 那么正在监视这个主服务器的所有 Sentinel 要以每秒一次的频率确认主服务器的确进入了主观下线状态。</li><li>如果一个主服务器被标记为主观下线， 并且有足够数量的 Sentinel （至少要达到配置文件指定的数量）在指定的时间范围内同意这一判断， 那么这个主服务器被标记为客观下线。</li><li>在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率向它已知的所有主服务器和从服务器发送 INFO [section] 命令。 当一个主服务器被 Sentinel 标记为客观下线时， Sentinel 向下线主服务器的所有从服务器发送 INFO [section] 命令的频率会从 10 秒一次改为每秒一次。</li><li>当没有足够数量的 Sentinel 同意主服务器已经下线， 主服务器的客观下线状态就会被移除。 当主服务器重新向 Sentinel 的 PING 命令返回有效回复时， 主服务器的主管下线状态就会被移除。</li></ul><h3 id="自动发现-Sentinel-和从服务器"><a href="#自动发现-Sentinel-和从服务器" class="headerlink" title="自动发现 Sentinel 和从服务器"></a>自动发现 Sentinel 和从服务器</h3><p>一个 Sentinel 可以与其他多个 Sentinel 进行连接， 各个 Sentinel 之间可以互相检查对方的可用性， 并进行信息交换。</p><p>你无须为运行的每个 Sentinel 分别设置其他 Sentinel 的地址， 因为 Sentinel 可以通过发布与订阅功能来自动发现正在监视相同主服务器的其他 Sentinel ， 这一功能是通过向频道 <strong>sentinel</strong>:hello 发送信息来实现的。</p><p>与此类似， 你也不必手动列出主服务器属下的所有从服务器， 因为 Sentinel 可以通过询问主服务器来获得所有从服务器的信息。</p><ul><li>每个 Sentinel 会以每两秒一次的频率， 通过发布与订阅功能， 向被它监视的所有主服务器和从服务器的 <strong>sentinel</strong>:hello 频道发送一条信息， 信息中包含了 Sentinel 的 IP 地址、端口号和运行 ID （runid）。</li><li>每个 Sentinel 都订阅了被它监视的所有主服务器和从服务器的 <strong>sentinel</strong>:hello 频道， 查找之前未出现过的 sentinel （looking for unknown sentinels）。 当一个 Sentinel 发现一个新的 Sentinel 时， 它会将新的 Sentinel 添加到一个列表中， 这个列表保存了 Sentinel 已知的， 监视同一个主服务器的所有其他 Sentinel 。</li><li>Sentinel 发送的信息中还包括完整的主服务器当前配置（configuration）。 如果一个 Sentinel 包含的主服务器配置比另一个 Sentinel 发送的配置要旧， 那么这个 Sentinel 会立即升级到新配置上。</li><li>在将一个新 Sentinel 添加到监视主服务器的列表上面之前， Sentinel 会先检查列表中是否已经包含了和要添加的 Sentinel 拥有相同运行 ID 或者相同地址（包括 IP 地址和端口号）的 Sentinel ， 如果是的话， Sentinel 会先移除列表中已有的那些拥有相同运行 ID 或者相同地址的 Sentinel ， 然后再添加新 Sentinel 。</li></ul><h3 id="Sentinel-API"><a href="#Sentinel-API" class="headerlink" title="Sentinel API"></a>Sentinel API</h3><p>在默认情况下， Sentinel 使用 TCP 端口 26379 （普通 Redis 服务器使用的是 6379 ）。</p><p>Sentinel 接受 Redis 协议格式的命令请求， 所以你可以使用 redis-cli 或者任何其他 Redis 客户端来与 Sentinel 进行通讯。</p><p>有两种方式可以和 Sentinel 进行通讯：</p><ul><li>第一种方法是通过直接发送命令来查询被监视 Redis 服务器的当前状态， 以及 Sentinel 所知道的关于其他 Sentinel 的信息， 诸如此类。</li><li>另一种方法是使用发布与订阅功能， 通过接收 Sentinel 发送的通知： 当执行故障转移操作， 或者某个被监视的服务器被判断为主观下线或者客观下线时， Sentinel 就会发送相应的信息。</li></ul><h3 id="Sentinel-命令"><a href="#Sentinel-命令" class="headerlink" title="Sentinel 命令"></a>Sentinel 命令</h3><p>以下列出的是 Sentinel 接受的命令：</p><ul><li>PING ：返回 PONG 。</li><li>SENTINEL masters ：列出所有被监视的主服务器，以及这些主服务器的当前状态。</li><li>SENTINEL slaves \<master name\=""> ：列出给定主服务器的所有从服务器，以及这些从服务器的当前状态。</master></li><li>SENTINEL get-master-addr-by-name \<master name\=""> ： 返回给定名字的主服务器的 IP 地址和端口号。 如果这个主服务器正在执行故障转移操作， 或者针对这个主服务器的故障转移操作已经完成， 那么这个命令返回新的主服务器的 IP 地址和端口号。</master></li><li>SENTINEL reset \&lt;pattern> ： 重置所有名字和给定模式 pattern 相匹配的主服务器。 pattern 参数是一个 Glob 风格的模式。 重置操作清除主服务器目前的所有状态， 包括正在执行中的故障转移， 并移除目前已经发现和关联的， 主服务器的所有从服务器和 Sentinel 。</li><li>SENTINEL failover \<master name\=""> ： 当主服务器失效时， 在不询问其他 Sentinel 意见的情况下， 强制开始一次自动故障迁移 （不过发起故障转移的 Sentinel 会向其他 Sentinel 发送一个新的配置，其他 Sentinel 会根据这个配置进行相应的更新）。</master></li></ul><h3 id="发布与订阅信息"><a href="#发布与订阅信息" class="headerlink" title="发布与订阅信息"></a>发布与订阅信息</h3><p>客户端可以将 Sentinel 看作是一个只提供了订阅功能的 Redis 服务器： 你不可以使用 PUBLISH channel message 命令向这个服务器发送信息， 但你可以用 SUBSCRIBE channel [channel …] 命令或者 PSUBSCRIBE pattern [pattern …] 命令， 通过订阅给定的频道来获取相应的事件提醒。</p><p>一个频道能够接收和这个频道的名字相同的事件。 比如说， 名为 +sdown 的频道就可以接收所有实例进入主观下线（SDOWN）状态的事件。</p><p>通过执行 PSUBSCRIBE * 命令可以接收所有事件信息。</p><p>以下列出的是客户端可以通过订阅来获得的频道和信息的格式： 第一个英文单词是频道/事件的名字， 其余的是数据的格式。</p><p>注意， 当格式中包含 instance details 字样时， 表示频道所返回的信息中包含了以下用于识别目标实例的内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;instance-type&gt; &lt;name&gt; &lt;ip&gt; &lt;port&gt; @ &lt;master-name&gt; &lt;master-ip&gt; &lt;master-port&gt;</span><br></pre></td></tr></table></figure></p><p>@ 字符之后的内容用于指定主服务器， 这些内容是可选的， 它们仅在 @ 字符之前的内容指定的实例不是主服务器时使用。</p><ul><li>+reset-master \<instance details\=""> ：主服务器已被重置。</instance></li><li>+slave \<instance details\=""> ：一个新的从服务器已经被 Sentinel 识别并关联。</instance></li><li>+failover-state-reconf-slaves \<instance details\=""> ：故障转移状态切换到了 reconf-slaves 状态。</instance></li><li>+failover-detected \<instance details\=""> ：另一个 Sentinel 开始了一次故障转移操作，或者一个从服务器转换成了主服务器。</instance></li><li>+slave-reconf-sent \<instance details\=""> ：领头（leader）的 Sentinel 向实例发送了 SLAVEOF host port 命令，为实例设置新的主服务器。</instance></li><li>+slave-reconf-inprog \<instance details\=""> ：实例正在将自己设置为指定主服务器的从服务器，但相应的同步过程仍未完成。</instance></li><li>+slave-reconf-done \<instance details\=""> ：从服务器已经成功完成对新主服务器的同步。</instance></li><li>-dup-sentinel \<instance details\=""> ：对给定主服务器进行监视的一个或多个 Sentinel 已经因为重复出现而被移除 —— 当 Sentinel 实例重启的时候，就会出现这种情况。</instance></li><li>+sentinel \<instance details\=""> ：一个监视给定主服务器的新 Sentinel 已经被识别并添加。</instance></li><li>+sdown \<instance details\=""> ：给定的实例现在处于主观下线状态。</instance></li><li>-sdown \<instance details\=""> ：给定的实例已经不再处于主观下线状态。</instance></li><li>+odown \<instance details\=""> ：给定的实例现在处于客观下线状态。</instance></li><li>-odown \<instance details\=""> ：给定的实例已经不再处于客观下线状态。</instance></li><li>+new-epoch \<instance details\=""> ：当前的纪元（epoch）已经被更新。</instance></li><li>+try-failover \<instance details\=""> ：一个新的故障迁移操作正在执行中，等待被大多数 Sentinel 选中（waiting to be elected by the majority）。</instance></li><li>+elected-leader \<instance details\=""> ：赢得指定纪元的选举，可以进行故障迁移操作了。</instance></li><li>+failover-state-select-slave \<instance details\=""> ：故障转移操作现在处于 select-slave 状态 —— Sentinel 正在寻找可以升级为主服务器的从服务器。</instance></li><li>no-good-slave \<instance details\=""> ：Sentinel 操作未能找到适合进行升级的从服务器。Sentinel 会在一段时间之后再次尝试寻找合适的从服务器来进行升级，又或者直接放弃执行故障转移操作。</instance></li><li>selected-slave \<instance details\=""> ：Sentinel 顺利找到适合进行升级的从服务器。</instance></li><li>failover-state-send-slaveof-noone \<instance details\=""> ：Sentinel 正在将指定的从服务器升级为主服务器，等待升级功能完成。</instance></li><li>failover-end-for-timeout \<instance details\=""> ：故障转移因为超时而中止，不过最终所有从服务器都会开始复制新的主服务器（slaves will eventually be configured to replicate with the new master anyway）。</instance></li><li>failover-end \<instance details\=""> ：故障转移操作顺利完成。所有从服务器都开始复制新的主服务器了。</instance></li><li>+switch-master \<master name\=""> \&lt;oldip> \&lt;oldport> \&lt;newip> \&lt;newport> ：配置变更，主服务器的 IP 和地址已经改变。 这是绝大多数外部用户都关心的信息。</master></li><li>+tilt ：进入 tilt 模式。</li><li>-tilt ：退出 tilt 模式。</li></ul><h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><p>一次故障转移操作由以下步骤组成：</p><ul><li>发现主服务器已经进入客观下线状态。</li><li>对我们的当前纪元进行自增（详情请参考 Raft leader election ）， 并尝试在这个纪元中当选。</li><li>如果当选失败， 那么在设定的故障迁移超时时间的两倍之后， 重新尝试当选。 如果当选成功， 那么执行以下步骤。</li><li>选出一个从服务器，并将它升级为主服务器。</li><li>向被选中的从服务器发送 SLAVEOF NO ONE 命令，让它转变为主服务器。</li><li>通过发布与订阅功能， 将更新后的配置传播给所有其他 Sentinel ， 其他 Sentinel 对它们自己的配置进行更新。</li><li>向已下线主服务器的从服务器发送 SLAVEOF host port 命令， 让它们去复制新的主服务器。</li><li>当所有从服务器都已经开始复制新的主服务器时， 领头 Sentinel 终止这次故障迁移操作。</li></ul><p><strong>Note</strong></p><pre><code>每当一个 Redis 实例被重新配置（reconfigured） —— 无论是被设置成主服务器、从服务器、又或者被设置成其他主服务器的从服务器 —— Sentinel 都会向被重新配置的实例发送一个 CONFIG REWRITE 命令， 从而确保这些配置会持久化在硬盘里。</code></pre><p>Sentinel 使用以下规则来选择新的主服务器：</p><ul><li>在失效主服务器属下的从服务器当中， 那些被标记为主观下线、已断线、或者最后一次回复 PING 命令的时间大于五秒钟的从服务器都会被淘汰。</li><li>在失效主服务器属下的从服务器当中， 那些与失效主服务器连接断开的时长超过 down-after 选项指定的时长十倍的从服务器都会被淘汰。</li><li>在经历了以上两轮淘汰之后剩下来的从服务器中， 我们选出复制偏移量（replication offset）最大的那个从服务器作为新的主服务器； 如果复制偏移量不可用， 或者从服务器的复制偏移量相同， 那么带有最小运行 ID 的那个从服务器成为新的主服务器。</li></ul><h3 id="Sentinel-自动故障迁移的一致性特质"><a href="#Sentinel-自动故障迁移的一致性特质" class="headerlink" title="Sentinel 自动故障迁移的一致性特质"></a>Sentinel 自动故障迁移的一致性特质</h3><p>Sentinel 自动故障迁移使用 Raft 算法来选举领头（leader） Sentinel ， 从而确保在一个给定的纪元（epoch）里， 只有一个领头产生。</p><p>这表示在同一个纪元中， 不会有两个 Sentinel 同时被选中为领头， 并且各个 Sentinel 在同一个纪元中只会对一个领头进行投票。</p><p>更高的配置纪元总是优于较低的纪元， 因此每个 Sentinel 都会主动使用更新的纪元来代替自己的配置。</p><p>简单来说， 我们可以将 Sentinel 配置看作是一个带有版本号的状态。 一个状态会以最后写入者胜出（last-write-wins）的方式（也即是，最新的配置总是胜出）传播至所有其他 Sentinel 。</p><p>举个例子， 当出现网络分割（network partitions）时， 一个 Sentinel 可能会包含了较旧的配置， 而当这个 Sentinel 接到其他 Sentinel 发来的版本更新的配置时， Sentinel 就会对自己的配置进行更新。</p><p>如果要在网络分割出现的情况下仍然保持一致性， 那么应该使用 min-slaves-to-write 选项， 让主服务器在连接的从实例少于给定数量时停止执行写操作， 与此同时， 应该在每个运行 Redis 主服务器或从服务器的机器上运行 Redis Sentinel 进程。</p><h3 id="Sentinel-状态的持久化"><a href="#Sentinel-状态的持久化" class="headerlink" title="Sentinel 状态的持久化"></a>Sentinel 状态的持久化</h3><p>Sentinel 的状态会被持久化在 Sentinel 配置文件里面。</p><p>每当 Sentinel 接收到一个新的配置， 或者当领头 Sentinel 为主服务器创建一个新的配置时， 这个配置会与配置纪元一起被保存到磁盘里面。</p><p>这意味着停止和重启 Sentinel 进程都是安全的。</p><h3 id="Sentinel-在非故障迁移的情况下对实例进行重新配置"><a href="#Sentinel-在非故障迁移的情况下对实例进行重新配置" class="headerlink" title="Sentinel 在非故障迁移的情况下对实例进行重新配置"></a>Sentinel 在非故障迁移的情况下对实例进行重新配置</h3><p>即使没有自动故障迁移操作在进行， Sentinel 总会尝试将当前的配置设置到被监视的实例上面。 特别是：</p><ul><li>根据当前的配置， 如果一个从服务器被宣告为主服务器， 那么它会代替原有的主服务器， 成为新的主服务器， 并且成为原有主服务器的所有从服务器的复制对象。</li><li>那些连接了错误主服务器的从服务器会被重新配置， 使得这些从服务器会去复制正确的主服务器。<br>不过， 在以上这些条件满足之后， Sentinel 在对实例进行重新配置之前仍然会等待一段足够长的时间， 确保可以接收到其他 Sentinel 发来的配置更新， 从而避免自身因为保存了过期的配置而对实例进行了不必要的重新配置。</li></ul><h3 id="TILT-模式"><a href="#TILT-模式" class="headerlink" title="TILT 模式"></a>TILT 模式</h3><p>Redis Sentinel 严重依赖计算机的时间功能： 比如说， 为了判断一个实例是否可用， Sentinel 会记录这个实例最后一次相应 PING 命令的时间， 并将这个时间和当前时间进行对比， 从而知道这个实例有多长时间没有和 Sentinel 进行任何成功通讯。</p><p>不过， 一旦计算机的时间功能出现故障， 或者计算机非常忙碌， 又或者进程因为某些原因而被阻塞时， Sentinel 可能也会跟着出现故障。</p><p>TILT 模式是一种特殊的保护模式： 当 Sentinel 发现系统有些不对劲时， Sentinel 就会进入 TILT 模式。</p><p>因为 Sentinel 的时间中断器默认每秒执行 10 次， 所以我们预期时间中断器的两次执行之间的间隔为 100 毫秒左右。 Sentinel 的做法是， 记录上一次时间中断器执行时的时间， 并将它和这一次时间中断器执行的时间进行对比：</p><ul><li>如果两次调用时间之间的差距为负值， 或者非常大（超过 2 秒钟）， 那么 Sentinel 进入 TILT 模式。</li><li>如果 Sentinel 已经进入 TILT 模式， 那么 Sentinel 延迟退出 TILT 模式的时间。</li></ul><p>当 Sentinel 进入 TILT 模式时， 它仍然会继续监视所有目标， 但是：</p><ul><li>它不再执行任何操作，比如故障转移。</li><li>当有实例向这个 Sentinel 发送 SENTINEL is-master-down-by-addr 命令时， Sentinel 返回负值： 因为这个 Sentinel 所进行的下线判断已经不再准确。</li></ul><p>如果 TILT 可以正常维持 30 秒钟， 那么 Sentinel 退出 TILT 模式。</p><h3 id="处理-BUSY-状态"><a href="#处理-BUSY-状态" class="headerlink" title="处理 -BUSY 状态"></a>处理 -BUSY 状态</h3><p><strong>Warning</strong></p><pre><code>该功能尚未实现</code></pre><p>当 Lua 脚本的运行时间超过指定时限时， Redis 就会返回 -BUSY 错误。</p><p>当出现这种情况时， Sentinel 在尝试执行故障转移操作之前， 会先向服务器发送一个 SCRIPT KILL 命令， 如果服务器正在执行的是一个只读脚本的话， 那么这个脚本就会被杀死， 服务器就会回到正常状态。</p><h3 id="Sentinel-的客户端实现"><a href="#Sentinel-的客户端实现" class="headerlink" title="Sentinel 的客户端实现"></a>Sentinel 的客户端实现</h3><p>关于 Sentinel 客户端的实现信息可以参考 Sentinel 客户端指引手册 。</p><h2 id="集群教程"><a href="#集群教程" class="headerlink" title="集群教程"></a>集群教程</h2><p>本文档是 Redis 集群的入门教程， 从用户的角度介绍了设置、测试和操作集群的方法。</p><p>本教程不包含晦涩难懂的分布式概念， 也没有像 Redis 集群规范 那样包含 Redis 集群的实现细节， 如果你打算深入地学习 Redis 集群的部署方法， 那么推荐你在阅读完这个教程之后， 再去看一看集群规范。</p><p>Redis 集群目前仍处于 Alpha 测试版本， 如果在使用过程中发现任何问题， 请到 Redis 的邮件列表 发贴， 或者到 Redis 的 Github 页面 报告错误。</p><h3 id="集群简介"><a href="#集群简介" class="headerlink" title="集群简介"></a>集群简介</h3><p>Redis 集群是一个可以在多个 Redis 节点之间进行数据共享的设施（installation）。</p><p>Redis 集群不支持那些需要同时处理多个键的 Redis 命令， 因为执行这些命令需要在多个 Redis 节点之间移动数据， 并且在高负载的情况下， 这些命令将降低 Redis 集群的性能， 并导致不可预测的行为。</p><p>Redis 集群通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。</p><p>Redis 集群提供了以下两个好处：</p><ul><li>将数据自动切分（split）到多个节点的能力。</li><li>当集群中的一部分节点失效或者无法进行通讯时， 仍然可以继续处理命令请求的能力。</li></ul><h3 id="Redis-集群数据共享。"><a href="#Redis-集群数据共享。" class="headerlink" title="Redis 集群数据共享。"></a>Redis 集群数据共享。</h3><p>Redis 集群使用数据分片（sharding）而非一致性哈希（consistency hashing）来实现： 一个 Redis 集群包含 16384 个哈希槽（hash slot）， 数据库中的每个键都属于这 16384 个哈希槽的其中一个， 集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。</p><p>集群中的每个节点负责处理一部分哈希槽。 举个例子， 一个集群可以有三个哈希槽， 其中：</p><ul><li>节点 A 负责处理 0 号至 5500 号哈希槽。</li><li>节点 B 负责处理 5501 号至 11000 号哈希槽。</li><li>节点 C 负责处理 11001 号至 16384 号哈希槽。</li></ul><p>这种将哈希槽分布到不同节点的做法使得用户可以很容易地向集群中添加或者删除节点。 比如说：</p><ul><li>如果用户将新节点 D 添加到集群中， 那么集群只需要将节点 A 、B 、 C 中的某些槽移动到节点 D 就可以了。</li><li>与此类似， 如果用户要从集群中移除节点 A ， 那么集群只需要将节点 A 中的所有哈希槽移动到节点 B 和节点 C ， 然后再移除空白（不包含任何哈希槽）的节点 A 就可以了。</li></ul><p>因为将一个哈希槽从一个节点移动到另一个节点不会造成节点阻塞， 所以无论是添加新节点还是移除已存在节点， 又或者改变某个节点包含的哈希槽数量， 都不会造成集群下线。</p><h3 id="Redis-集群中的主从复制"><a href="#Redis-集群中的主从复制" class="headerlink" title="Redis 集群中的主从复制"></a>Redis 集群中的主从复制</h3><p>为了使得集群在一部分节点下线或者无法与集群的大多数（majority）节点进行通讯的情况下， 仍然可以正常运作， Redis 集群对节点使用了主从复制功能： 集群中的每个节点都有 1 个至 N 个复制品（replica）， 其中一个复制品为主节点（master）， 而其余的 N-1 个复制品为从节点（slave）。</p><p>在之前列举的节点 A 、B 、C 的例子中， 如果节点 B 下线了， 那么集群将无法正常运行， 因为集群找不到节点来处理 5501 号至 11000 号的哈希槽。</p><p>另一方面， 假如在创建集群的时候（或者至少在节点 B 下线之前）， 我们为主节点 B 添加了从节点 B1 ， 那么当主节点 B 下线的时候， 集群就会将 B1 设置为新的主节点， 并让它代替下线的主节点 B ， 继续处理 5501 号至 11000 号的哈希槽， 这样集群就不会因为主节点 B 的下线而无法正常运作了。</p><p>不过如果节点 B 和 B1 都下线的话， Redis 集群还是会停止运作。</p><h3 id="Redis-集群的一致性保证（guarantee）"><a href="#Redis-集群的一致性保证（guarantee）" class="headerlink" title="Redis 集群的一致性保证（guarantee）"></a>Redis 集群的一致性保证（guarantee）</h3><p>Redis 集群不保证数据的强一致性（strong consistency）： 在特定条件下， Redis 集群可能会丢失已经被执行过的写命令。</p><p>使用异步复制（asynchronous replication）是 Redis 集群可能会丢失写命令的其中一个原因。 考虑以下这个写命令的例子：</p><ul><li>客户端向主节点 B 发送一条写命令。</li><li>主节点 B 执行写命令，并向客户端返回命令回复。</li><li>主节点 B 将刚刚执行的写命令复制给它的从节点 B1 、 B2 和 B3 。</li></ul><p>如你所见， 主节点对命令的复制工作发生在返回命令回复之后， 因为如果每次处理命令请求都需要等待复制操作完成的话， 那么主节点处理命令请求的速度将极大地降低 —— 我们必须在性能和一致性之间做出权衡。</p><p><strong>Note</strong></p><pre><code>如果真的有必要的话， Redis 集群可能会在将来提供同步地（synchronou）执行写命令的方法。</code></pre><p>Redis 集群另外一种可能会丢失命令的情况是， 集群出现网络分裂（network partition）， 并且一个客户端与至少包括一个主节点在内的少数（minority）实例被孤立。</p><p>举个例子， 假设集群包含 A 、 B 、 C 、 A1 、 B1 、 C1 六个节点， 其中 A 、B 、C 为主节点， 而 A1 、B1 、C1 分别为三个主节点的从节点， 另外还有一个客户端 Z1 。</p><p>假设集群中发生网络分裂， 那么集群可能会分裂为两方， 大多数（majority）的一方包含节点 A 、C 、A1 、B1 和 C1 ， 而少数（minority）的一方则包含节点 B 和客户端 Z1 。</p><p>在网络分裂期间， 主节点 B 仍然会接受 Z1 发送的写命令：</p><ul><li>如果网络分裂出现的时间很短， 那么集群会继续正常运行；</li><li>但是， 如果网络分裂出现的时间足够长， 使得大多数一方将从节点 B1 设置为新的主节点， 并使用 B1 来代替原来的主节点 B ， 那么 Z1 发送给主节点 B 的写命令将丢失。</li></ul><p>注意， 在网络分裂出现期间， 客户端 Z1 可以向主节点 B 发送写命令的最大时间是有限制的， 这一时间限制称为节点超时时间（node timeout）， 是 Redis 集群的一个重要的配置选项：</p><ul><li>对于大多数一方来说， 如果一个主节点未能在节点超时时间所设定的时限内重新联系上集群， 那么集群会将这个主节点视为下线， 并使用从节点来代替这个主节点继续工作。</li><li>对于少数一方， 如果一个主节点未能在节点超时时间所设定的时限内重新联系上集群， 那么它将停止处理写命令， 并向客户端报告错误。</li></ul><h3 id="创建并使用-Redis-集群"><a href="#创建并使用-Redis-集群" class="headerlink" title="创建并使用 Redis 集群"></a>创建并使用 Redis 集群</h3><p>Redis 集群由多个运行在集群模式（cluster mode）下的 Redis 实例组成， 实例的集群模式需要通过配置来开启， 开启集群模式的实例将可以使用集群特有的功能和命令。</p><p>以下是一个包含了最少选项的集群配置文件示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">port 7000</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes.conf</span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure><p>文件中的 cluster-enabled 选项用于开实例的集群模式， 而 cluster-conf-file 选项则设定了保存节点配置文件的路径， 默认值为 nodes.conf 。</p><p>节点配置文件无须人为修改， 它由 Redis 集群在启动时创建， 并在有需要时自动进行更新。</p><p>要让集群正常运作至少需要三个主节点， 不过在刚开始试用集群功能时， 强烈建议使用六个节点： 其中三个为主节点， 而其余三个则是各个主节点的从节点。</p><p>首先， 让我们进入一个新目录， 并创建六个以端口号为名字的子目录， 稍后我们在将每个目录中运行一个 Redis 实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir cluster-test</span><br><span class="line"><span class="built_in">cd</span> cluster-test</span><br><span class="line">mkdir 7000 7001 7002 7003 7004 7005</span><br></pre></td></tr></table></figure><p>在文件夹 7000 至 7005 中， 各创建一个 redis.conf 文件， 文件的内容可以使用上面的示例配置文件， 但记得将配置中的端口号从 7000 改为与文件夹名字相同的号码。</p><p>现在， 从 Redis Github 页面 的 unstable 分支中取出最新的 Redis 源码， 编译出可执行文件 redis-server ， 并将文件复制到 cluster-test 文件夹， 然后使用类似以下命令， 在每个标签页中打开一个实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> 7000</span><br><span class="line">../redis-server ./redis.conf</span><br></pre></td></tr></table></figure><p>实例打印的日志显示， 因为 nodes.conf 文件不存在， 所以每个节点都为它自身指定了一个新的 ID ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[82462] 26 Nov 11:56:55.329 * No cluster configuration found, I<span class="string">'m 97a3a64667477371c4479320d683e4c8db5858b1</span></span><br></pre></td></tr></table></figure><p>实例会一直使用同一个 ID ， 从而在集群中保持一个独一无二（unique）的名字。</p><p>每个节点都使用 ID 而不是 IP 或者端口号来记录其他节点， 因为 IP 地址和端口号都可能会改变， 而这个独一无二的标识符（identifier）则会在节点的整个生命周期中一直保持不变。</p><p>我们将这个标识符称为节点 ID。</p><h3 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h3><p>现在我们已经有了六个正在运行中的 Redis 实例， 接下来我们需要使用这些实例来创建集群， 并为每个节点编写配置文件。</p><p>通过使用 Redis 集群命令行工具 redis-trib ， 编写节点配置文件的工作可以非常容易地完成： redis-trib 位于 Redis 源码的 src 文件夹中， 它是一个 Ruby 程序， 这个程序通过向实例发送特殊命令来完成创建新集群， 检查集群， 或者对集群进行重新分片（reshared）等工作。</p><p>我们需要执行以下命令来创建集群：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 \</span><br><span class="line">127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005</span><br></pre></td></tr></table></figure><p>命令的意义如下：</p><ul><li>给定 redis-trib.rb 程序的命令是 create ， 这表示我们希望创建一个新的集群。</li><li>选项 –replicas 1 表示我们希望为集群中的每个主节点创建一个从节点。</li><li>之后跟着的其他参数则是实例的地址列表， 我们希望程序使用这些地址所指示的实例来创建新集群。</li></ul><p>简单来说， 以上命令的意思就是让 redis-trib 程序创建一个包含三个主节点和三个从节点的集群。</p><p>接着， redis-trib 会打印出一份预想中的配置给你看， 如果你觉得没问题的话， 就可以输入 yes ， redis-trib 就会将这份配置应用到集群当中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Creating cluster</span><br><span class="line">Connecting to node 127.0.0.1:7000: OK</span><br><span class="line">Connecting to node 127.0.0.1:7001: OK</span><br><span class="line">Connecting to node 127.0.0.1:7002: OK</span><br><span class="line">Connecting to node 127.0.0.1:7003: OK</span><br><span class="line">Connecting to node 127.0.0.1:7004: OK</span><br><span class="line">Connecting to node 127.0.0.1:7005: OK</span><br><span class="line">&gt;&gt;&gt; Performing <span class="built_in">hash</span> slots allocation on 6 nodes...</span><br><span class="line">Using 3 masters:</span><br><span class="line">127.0.0.1:7000</span><br><span class="line">127.0.0.1:7001</span><br><span class="line">127.0.0.1:7002</span><br><span class="line">127.0.0.1:7000 replica <span class="comment">#1 is 127.0.0.1:7003</span></span><br><span class="line">127.0.0.1:7001 replica <span class="comment">#1 is 127.0.0.1:7004</span></span><br><span class="line">127.0.0.1:7002 replica <span class="comment">#1 is 127.0.0.1:7005</span></span><br><span class="line">M: 9991306f0e50640a5684f1958fd754b38fa034c9 127.0.0.1:7000</span><br><span class="line">slots:0-5460 (5461 slots) master</span><br><span class="line">M: e68e52cee0550f558b03b342f2f0354d2b8a083b 127.0.0.1:7001</span><br><span class="line">slots:5461-10921 (5461 slots) master</span><br><span class="line">M: 393c6df5eb4b4cec323f0e4ca961c8b256e3460a 127.0.0.1:7002</span><br><span class="line">slots:10922-16383 (5462 slots) master</span><br><span class="line">S: 48b728dbcedff6bf056231eb44990b7d1c35c3e0 127.0.0.1:7003</span><br><span class="line">S: 345ede084ac784a5c030a0387f8aaa9edfc59af3 127.0.0.1:7004</span><br><span class="line">S: 3375be2ccc321932e8853234ffa87ee9fde973ff 127.0.0.1:7005</span><br><span class="line">Can I <span class="built_in">set</span> the above configuration? (<span class="built_in">type</span> <span class="string">'yes'</span> to accept): yes</span><br></pre></td></tr></table></figure><p>输入 yes 并按下回车确认之后， 集群就会将配置应用到各个节点， 并连接起（join）各个节点 —— 也即是， 让各个节点开始互相通讯：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Nodes configuration updated</span><br><span class="line">&gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster</span><br><span class="line">Waiting <span class="keyword">for</span> the cluster to join...</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7000)</span><br><span class="line">M: 9991306f0e50640a5684f1958fd754b38fa034c9 127.0.0.1:7000</span><br><span class="line">slots:0-5460 (5461 slots) master</span><br><span class="line">M: e68e52cee0550f558b03b342f2f0354d2b8a083b 127.0.0.1:7001</span><br><span class="line">slots:5461-10921 (5461 slots) master</span><br><span class="line">M: 393c6df5eb4b4cec323f0e4ca961c8b256e3460a 127.0.0.1:7002</span><br><span class="line">slots:10922-16383 (5462 slots) master</span><br><span class="line">M: 48b728dbcedff6bf056231eb44990b7d1c35c3e0 127.0.0.1:7003</span><br><span class="line">slots: (0 slots) master</span><br><span class="line">M: 345ede084ac784a5c030a0387f8aaa9edfc59af3 127.0.0.1:7004</span><br><span class="line">slots: (0 slots) master</span><br><span class="line">M: 3375be2ccc321932e8853234ffa87ee9fde973ff 127.0.0.1:7005</span><br><span class="line">slots: (0 slots) master</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br></pre></td></tr></table></figure><p>如果一切正常的话， redis-trib 将输出以下信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure><p>这表示集群中的 16384 个槽都有至少一个主节点在处理， 集群运作正常。</p><h3 id="集群的客户端"><a href="#集群的客户端" class="headerlink" title="集群的客户端"></a>集群的客户端</h3><p>Redis 集群现阶段的一个问题是客户端实现很少。 以下是一些我知道的实现：</p><ul><li>redis-rb-cluster 是我（@antirez）编写的 Ruby 实现， 用于作为其他实现的参考。 该实现是对 redis-rb 的一个简单包装， 高效地实现了与集群进行通讯所需的最少语义（semantic）。</li><li>redis-py-cluster 看上去是 redis-rb-cluster 的一个 Python 版本， 这个项目有一段时间没有更新了（最后一次提交是在六个月之前）， 不过可以将这个项目用作学习集群的起点。</li><li>流行的 Predis 曾经对早期的 Redis 集群有过一定的支持， 但我不确定它对集群的支持是否完整， 也不清楚它是否和最新版本的 Redis 集群兼容 （因为新版的 Redis 集群将槽的数量从 4k 改为 16k 了）。</li><li>Redis unstable 分支中的 redis-cli 程序实现了非常基本的集群支持， 可以使用命令 redis-cli -c 来启动。</li></ul><p>测试 Redis 集群比较简单的办法就是使用 redis-rb-cluster 或者 redis-cli ， 接下来我们将使用 redis-cli 为例来进行演示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -c -p 7000</span><br><span class="line">redis 127.0.0.1:7000&gt; <span class="built_in">set</span> foo bar</span><br><span class="line">-&gt; Redirected to slot [12182] located at 127.0.0.1:7002</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:7002&gt; <span class="built_in">set</span> hello world</span><br><span class="line">-&gt; Redirected to slot [866] located at 127.0.0.1:7000</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:7000&gt; get foo</span><br><span class="line">-&gt; Redirected to slot [12182] located at 127.0.0.1:7002</span><br><span class="line"><span class="string">"bar"</span></span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:7000&gt; get hello</span><br><span class="line">-&gt; Redirected to slot [866] located at 127.0.0.1:7000</span><br><span class="line"><span class="string">"world"</span></span><br></pre></td></tr></table></figure><p>redis-cli 对集群的支持是非常基本的， 所以它总是依靠 Redis 集群节点来将它转向（redirect）至正确的节点。</p><p>一个真正的（serious）集群客户端应该做得比这更好： 它应该用缓存记录起哈希槽与节点地址之间的映射（map）， 从而直接将命令发送到正确的节点上面。</p><p>这种映射只会在集群的配置出现某些修改时变化， 比如说， 在一次故障转移（failover）之后， 或者系统管理员通过添加节点或移除节点来修改了集群的布局（layout）之后， 诸如此类。</p><h3 id="使用-redis-rb-cluster-编写一个示例应用"><a href="#使用-redis-rb-cluster-编写一个示例应用" class="headerlink" title="使用 redis-rb-cluster 编写一个示例应用"></a>使用 redis-rb-cluster 编写一个示例应用</h3><p>在展示如何使用集群进行故障转移、重新分片等操作之前， 我们需要创建一个示例应用， 了解一些与 Redis 集群客户端进行交互的基本方法。</p><p>在运行示例应用的过程中， 我们会尝试让节点进入失效状态， 又或者开始一次重新分片， 以此来观察 Redis 集群在真实世界运行时的表现， 并且为了让这个示例尽可能地有用， 我们会让这个应用向集群进行写操作。</p><p>本节将通过两个示例应用来展示 redis-rb-cluster 的基本用法， 以下是本节的第一个示例应用， 它是一个名为 example.rb 的文件， 包含在redis-rb-cluster 项目里面：</p><figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'./cluster'</span></span><br><span class="line"></span><br><span class="line">startup_nodes = [</span><br><span class="line">    &#123;<span class="symbol">:host</span> =&gt; <span class="string">"127.0.0.1"</span>, <span class="symbol">:port</span> =&gt; <span class="number">7000</span>&#125;,</span><br><span class="line">    &#123;<span class="symbol">:host</span> =&gt; <span class="string">"127.0.0.1"</span>, <span class="symbol">:port</span> =&gt; <span class="number">7001</span>&#125;</span><br><span class="line">]</span><br><span class="line">rc = RedisCluster.new(startup_nodes,<span class="number">32</span>,<span class="symbol">:timeout</span> =&gt; <span class="number">0</span>.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">last = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> last</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        last = rc.get(<span class="string">"__last__"</span>)</span><br><span class="line">        last = <span class="number">0</span> <span class="keyword">if</span> !last</span><br><span class="line">    <span class="keyword">rescue</span> =&gt; e</span><br><span class="line">        puts <span class="string">"error <span class="subst">#&#123;e.to_s&#125;</span>"</span></span><br><span class="line">        sleep <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">((last.to_i+<span class="number">1</span>)..<span class="number">1000000000</span>).each&#123;<span class="params">|x|</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        rc.set(<span class="string">"foo<span class="subst">#&#123;x&#125;</span>"</span>,x)</span><br><span class="line">        puts rc.get(<span class="string">"foo<span class="subst">#&#123;x&#125;</span>"</span>)</span><br><span class="line">        rc.set(<span class="string">"__last__"</span>,x)</span><br><span class="line">    <span class="keyword">rescue</span> =&gt; e</span><br><span class="line">        puts <span class="string">"error <span class="subst">#&#123;e.to_s&#125;</span>"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    sleep <span class="number">0</span>.<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个应用所做的工作非常简单： 它不断地以 foo<number> 为键， number 为值， 使用 SET key value [EX seconds] [PX milliseconds] [NX|XX] 命令向数据库设置键值对。</number></p><p>如果我们执行这个应用的话， 应用将按顺序执行以下命令：</p><ul><li>SET foo0 0</li><li>SET foo1 1</li><li>SET foo2 2</li><li>诸如此类。。。</li></ul><p>代码中的每个集群操作都使用一个 begin 和 rescue 代码块（block）包裹着， 因为我们希望在代码出错时， 将错误打印到终端上面， 而不希望应用因为异常（exception）而退出。</p><p>代码的第七行是代码中第一个有趣的地方， 它创建了一个 Redis 集群对象， 其中创建对象所使用的参数及其意义如下：</p><ul><li>第一个参数是记录了启动节点的 startup_nodes 列表， 列表中包含了两个集群节点的地址。</li><li>第二个参数指定了对于集群中的各个不同的节点， Redis 集群对象可以获得（take）的最大连接数 （maximum number of connections this object is allowed to take）。</li><li>第三个参数 timeout 指定了一个命令在执行多久之后， 才会被看作是执行失败。</li></ul><p>记住， 启动列表中并不需要包含所有集群节点的地址， 但这些地址中至少要有一个是有效的（reachable）： 一旦 redis-rb-cluster 成功连接上集群中的某个节点时， 集群节点列表就会被自动更新， 任何真正的（serious）的集群客户端都应该这样做。</p><p>现在， 程序创建的 Redis 集群对象实例被保存到 rc 变量里面， 我们可以将这个对象当作普通 Redis 对象实例来使用。</p><p>在十一至十九行， 我们先尝试阅读计数器中的值， 如果计数器不存在的话， 我们才将计数器初始化为 0 ： 通过将计数值保存到 Redis 的计数器里面， 我们可以在示例重启之后， 仍然继续之前的执行过程， 而不必每次重启之后都从 foo0 开始重新设置键值对。</p><p>为了让程序在集群下线的情况下， 仍然不断地尝试读取计数器的值， 我们将读取操作包含在了一个 while 循环里面， 一般的应用程序并不需要如此小心。</p><p>二十一至三十行是程序的主循环， 这个循环负责设置键值对， 并在设置出错时打印错误信息。</p><p>程序在主循环的末尾添加了一个 sleep 调用， 让写操作的执行速度变慢， 帮助执行示例的人更容易看清程序的输出。</p><p>执行 example.rb 程序将产生以下输出：</p><figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ruby ./example.rb</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这个程序并不是十分有趣， 稍后我们就会看到一个更有趣的集群应用示例， 不过在此之前， 让我们先使用这个示例来演示集群的重新分片操作。</p><h3 id="对集群进行重新分片"><a href="#对集群进行重新分片" class="headerlink" title="对集群进行重新分片"></a>对集群进行重新分片</h3><p>现在， 让我们来试试对集群进行重新分片操作。</p><p>在执行重新分片的过程中， 请让你的 example.rb 程序处于运行状态， 这样你就会看到， 重新分片并不会对正在运行的集群程序产生任何影响， 你也可以考虑将 example.rb 中的 sleep 调用删掉， 从而让重新分片操作在近乎真实的写负载下执行。</p><p>重新分片操作基本上就是将某些节点上的哈希槽移动到另外一些节点上面， 和创建集群一样， 重新分片也可以使用 redis-trib 程序来执行。</p><p>执行以下命令可以开始一次重新分片操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-trib.rb reshard 127.0.0.1:7000</span><br></pre></td></tr></table></figure><p>你只需要指定集群中其中一个节点的地址， redis-trib 就会自动找到集群中的其他节点。</p><p>目前 redis-trib 只能在管理员的协助下完成重新分片的工作， 要让 redis-trib 自动将哈希槽从一个节点移动到另一个节点， 目前来说还做不到 （不过实现这个功能并不难）。</p><p>执行 redis-trib 的第一步就是设定你打算移动的哈希槽的数量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-trib.rb reshard 127.0.0.1:7000</span><br><span class="line">Connecting to node 127.0.0.1:7000: OK</span><br><span class="line">Connecting to node 127.0.0.1:7002: OK</span><br><span class="line">Connecting to node 127.0.0.1:7005: OK</span><br><span class="line">Connecting to node 127.0.0.1:7001: OK</span><br><span class="line">Connecting to node 127.0.0.1:7003: OK</span><br><span class="line">Connecting to node 127.0.0.1:7004: OK</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7000)</span><br><span class="line">M: 9991306f0e50640a5684f1958fd754b38fa034c9 127.0.0.1:7000</span><br><span class="line">slots:0-5460 (5461 slots) master</span><br><span class="line">M: 393c6df5eb4b4cec323f0e4ca961c8b256e3460a 127.0.0.1:7002</span><br><span class="line">slots:10922-16383 (5462 slots) master</span><br><span class="line">S: 3375be2ccc321932e8853234ffa87ee9fde973ff 127.0.0.1:7005</span><br><span class="line">slots: (0 slots) slave</span><br><span class="line">M: e68e52cee0550f558b03b342f2f0354d2b8a083b 127.0.0.1:7001</span><br><span class="line">slots:5461-10921 (5461 slots) master</span><br><span class="line">S: 48b728dbcedff6bf056231eb44990b7d1c35c3e0 127.0.0.1:7003</span><br><span class="line">slots: (0 slots) slave</span><br><span class="line">S: 345ede084ac784a5c030a0387f8aaa9edfc59af3 127.0.0.1:7004</span><br><span class="line">slots: (0 slots) slave</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br><span class="line">How many slots <span class="keyword">do</span> you want to move (from 1 to 16384)? 1000</span><br></pre></td></tr></table></figure><p>我们将打算移动的槽数量设置为 1000 个， 如果 example.rb 程序一直运行着的话， 现在 1000 个槽里面应该有不少键了。</p><p>除了移动的哈希槽数量之外， redis-trib 还需要知道重新分片的目标（target node）， 也即是， 负责接收这 1000 个哈希槽的节点。</p><p>指定目标需要使用节点的 ID ， 而不是 IP 地址和端口。 比如说， 我们打算使用集群的第一个主节点来作为目标， 它的 IP 地址和端口是 127.0.0.1:7000 ， 而节点 ID 则是 9991306f0e50640a5684f1958fd754b38fa034c9 ， 那么我们应该向 redis-trib 提供节点的 ID ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-trib.rb reshard 127.0.0.1:7000</span><br><span class="line">...</span><br><span class="line">What is the receiving node ID? 9991306f0e50640a5684f1958fd754b38fa034c9</span><br></pre></td></tr></table></figure><p><strong>Note</strong></p><pre><code>redis-trib 会打印出集群中所有节点的 ID ， 并且我们也可以通过执行以下命令来获得节点的运行 ID ：</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-cli -p 7000 cluster nodes | grep myself</span><br><span class="line">9991306f0e50640a5684f1958fd754b38fa034c9 :0 myself,master - 0 0 0 connected 0-5460</span><br></pre></td></tr></table></figure><p>接着， redis-trib 会向你询问重新分片的源节点（source node）， 也即是， 要从哪个节点中取出 1000 个哈希槽， 并将这些槽移动到目标节点上面。</p><p>如果我们不打算从特定的节点上取出指定数量的哈希槽， 那么可以向 redis-trib 输入 all ， 这样的话， 集群中的所有主节点都会成为源节点， redis-trib 将从各个源节点中各取出一部分哈希槽， 凑够 1000 个， 然后移动到目标节点上面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-trib.rb reshard 127.0.0.1:7000</span><br><span class="line">...</span><br><span class="line">Please enter all the <span class="built_in">source</span> node IDs.</span><br><span class="line">Type <span class="string">'all'</span> to use all the nodes as <span class="built_in">source</span> nodes <span class="keyword">for</span> the <span class="built_in">hash</span> slots.</span><br><span class="line">Type <span class="string">'done'</span> once you entered all the <span class="built_in">source</span> nodes IDs.</span><br><span class="line">Source node <span class="comment">#1:all</span></span><br></pre></td></tr></table></figure><p>输入 all 并按下回车之后， redis-trib 将打印出哈希槽的移动计划， 如果你觉得没问题的话， 就可以输入 yes 并再次按下回车：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-trib.rb reshard 127.0.0.1:7000</span><br><span class="line">...</span><br><span class="line">Moving slot 11421 from 393c6df5eb4b4cec323f0e4ca961c8b256e3460a</span><br><span class="line">Moving slot 11422 from 393c6df5eb4b4cec323f0e4ca961c8b256e3460a</span><br><span class="line">Moving slot 5461 from e68e52cee0550f558b03b342f2f0354d2b8a083b</span><br><span class="line">Moving slot 5469 from e68e52cee0550f558b03b342f2f0354d2b8a083b</span><br><span class="line">...</span><br><span class="line">Moving slot 5959 from e68e52cee0550f558b03b342f2f0354d2b8a083b</span><br><span class="line">Do you want to proceed with the proposed reshard plan (yes/no)? yes</span><br></pre></td></tr></table></figure><p>输入 yes 并使用按下回车之后， redis-trib 就会正式开始执行重新分片操作， 将指定的哈希槽从源节点一个个地移动到目标节点上面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-trib.rb reshard 127.0.0.1:7000</span><br><span class="line">...</span><br><span class="line">Moving slot 5934 from 127.0.0.1:7001 to 127.0.0.1:7000:</span><br><span class="line">Moving slot 5935 from 127.0.0.1:7001 to 127.0.0.1:7000:</span><br><span class="line">Moving slot 5936 from 127.0.0.1:7001 to 127.0.0.1:7000:</span><br><span class="line">Moving slot 5937 from 127.0.0.1:7001 to 127.0.0.1:7000:</span><br><span class="line">...</span><br><span class="line">Moving slot 5959 from 127.0.0.1:7001 to 127.0.0.1:7000:</span><br></pre></td></tr></table></figure><p>在重新分片的过程中， example.rb 应该可以继续正常运行， 不会出现任何问题。</p><p>在重新分片操作执行完毕之后， 可以使用以下命令来检查集群是否正常：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-trib.rb check 127.0.0.1:7000</span><br><span class="line">Connecting to node 127.0.0.1:7000: OK</span><br><span class="line">Connecting to node 127.0.0.1:7002: OK</span><br><span class="line">Connecting to node 127.0.0.1:7005: OK</span><br><span class="line">Connecting to node 127.0.0.1:7001: OK</span><br><span class="line">Connecting to node 127.0.0.1:7003: OK</span><br><span class="line">Connecting to node 127.0.0.1:7004: OK</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7000)</span><br><span class="line">M: 9991306f0e50640a5684f1958fd754b38fa034c9 127.0.0.1:7000</span><br><span class="line">slots:0-5959,10922-11422 (6461 slots) master</span><br><span class="line">M: 393c6df5eb4b4cec323f0e4ca961c8b256e3460a 127.0.0.1:7002</span><br><span class="line">slots:11423-16383 (4961 slots) master</span><br><span class="line">S: 3375be2ccc321932e8853234ffa87ee9fde973ff 127.0.0.1:7005</span><br><span class="line">slots: (0 slots) slave</span><br><span class="line">M: e68e52cee0550f558b03b342f2f0354d2b8a083b 127.0.0.1:7001</span><br><span class="line">slots:5960-10921 (4962 slots) master</span><br><span class="line">S: 48b728dbcedff6bf056231eb44990b7d1c35c3e0 127.0.0.1:7003</span><br><span class="line">slots: (0 slots) slave</span><br><span class="line">S: 345ede084ac784a5c030a0387f8aaa9edfc59af3 127.0.0.1:7004</span><br><span class="line">slots: (0 slots) slave</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure><p>根据检查结果显示， 集群运作正常。</p><p>需要注意的就是， 在三个主节点中， 节点 127.0.0.1:7000 包含了 6461 个哈希槽， 而节点 127.0.0.1:7001 和节点 127.0.0.1:7002 都只包含了 4961 个哈希槽， 因为后两者都将自己的 500 个哈希槽移动到了节点 127.0.0.1:7000 。</p><h3 id="一个更有趣的示例应用"><a href="#一个更有趣的示例应用" class="headerlink" title="一个更有趣的示例应用"></a>一个更有趣的示例应用</h3><p>我们在前面使用的示例程序 example.rb 并不是十分有趣， 因为它只是不断地对集群进行写入， 但并不检查写入结果是否正确。 比如说， 集群可能会错误地将 example.rb 发送的所有 SET key value [EX seconds] [PX milliseconds] [NX|XX] 命令都改成了 SET foo 42 ， 但因为 example.rb 并不检查写入后的值， 所以它不会意识到集群实际上写入的值是错误的。</p><p>因为这个原因， redis-rb-cluster 项目包含了一个名为 consistency-test.rb 的示例应用， 这个应用比起 example.rb 有趣得多： 它创建了多个计数器（默认为 1000 个）， 并通过发送 INCR key 命令来增加这些计数器的值。</p><p>在增加计数器值的同时， consistency-test.rb 还执行以下操作：</p><ul><li>每次使用 INCR key 命令更新一个计数器时， 应用会记录下计数器执行 INCR key 命令之后应该有的值。 举个例子， 如果计数器的起始值为 0 ， 而这次是程序第 50 次向它发送 INCR key 命令， 那么计数器的值应该是 50 。</li><li>在每次发送 INCR key 命令之前， 程序会随机从集群中读取一个计数器的值， 并将它与自己记录的值进行对比， 看两个值是否相同。</li></ul><p>换句话说， 这个程序是一个一致性检查器（consistency checker）： 如果集群在执行 INCR key 命令的过程中， 丢失了某条 INCR key 命令， 又或者多执行了某条客户端没有确认到的 INCR key 命令， 那么检查器将察觉到这一点 —— 在前一种情况中， consistency-test.rb 记录的计数器值将比集群记录的计数器值要大； 而在后一种情况中， consistency-test.rb 记录的计数器值将比集群记录的计数器值要小。</p><p>运行 consistency-test 程序将产生类似以下的输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ruby consistency-test.rb</span><br><span class="line">925 R (0 err) | 925 W (0 err) |</span><br><span class="line">5030 R (0 err) | 5030 W (0 err) |</span><br><span class="line">9261 R (0 err) | 9261 W (0 err) |</span><br><span class="line">13517 R (0 err) | 13517 W (0 err) |</span><br><span class="line">17780 R (0 err) | 17780 W (0 err) |</span><br><span class="line">22025 R (0 err) | 22025 W (0 err) |</span><br><span class="line">25818 R (0 err) | 25818 W (0 err) |</span><br></pre></td></tr></table></figure><p>每行输出都打印了程序执行的读取次数和写入次数， 以及执行操作的过程中因为集群不可用而产生的错误数。</p><p>如果程序察觉了不一致的情况出现， 它将在输出行的末尾显式不一致的详细情况。</p><p>比如说， 如果我们在 consistency-test.rb 运行的过程中， 手动修改某个计数器的值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ redis 127.0.0.1:7000&gt; <span class="built_in">set</span> key_217 0</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>那么 consistency-test.rb 将向我们报告不一致情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">in</span> the other tab I see...)</span><br><span class="line"></span><br><span class="line">94774 R (0 err) | 94774 W (0 err) |</span><br><span class="line">98821 R (0 err) | 98821 W (0 err) |</span><br><span class="line">102886 R (0 err) | 102886 W (0 err) | 114 lost |</span><br><span class="line">107046 R (0 err) | 107046 W (0 err) | 114 lost |</span><br></pre></td></tr></table></figure><p>在我们修改计数器值的时候， 计数器的正确值是 114 （执行了 114 次 INCR key 命令）， 因为我们将计数器的值设成了 0 ， 所以 consistency-test.rb 会向我们报告说丢失了 114 个 INCR key 命令。</p><p>因为这个示例程序具有一致性检查功能， 所以我们用它来测试 Redis 集群的故障转移操作。</p><h3 id="故障转移测试"><a href="#故障转移测试" class="headerlink" title="故障转移测试"></a>故障转移测试</h3><p><strong>Note</strong></p><pre><code>在执行本节操作的过程中， 请一直运行 consistency-test 程序。</code></pre><p>要触发一次故障转移， 最简单的办法就是令集群中的某个主节点进入下线状态。</p><p>首先用以下命令列出集群中的所有主节点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -p 7000 cluster nodes | grep master</span><br><span class="line">3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 127.0.0.1:7001 master - 0 1385482984082 0 connected 5960-10921</span><br><span class="line">2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 master - 0 1385482983582 0 connected 11423-16383</span><br><span class="line">97a3a64667477371c4479320d683e4c8db5858b1 :0 myself,master - 0 0 0 connected 0-5959 10922-11422</span><br></pre></td></tr></table></figure><p>通过命令输出， 我们知道端口号为 7000 、 7001 和 7002 的节点都是主节点， 然后我们可以通过向端口号为 7002 的主节点发送 DEBUG SEGFAULT 命令， 让这个主节点崩溃：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -p 7002 debug segfault</span><br><span class="line">Error: Server closed the connection</span><br></pre></td></tr></table></figure><p>现在， 切换到运行着 consistency-test 的标签页， 可以看到， consistency-test 在 7002 下线之后的一段时间里将产生大量的错误警告信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">18849 R (0 err) | 18849 W (0 err) |</span><br><span class="line">23151 R (0 err) | 23151 W (0 err) |</span><br><span class="line">27302 R (0 err) | 27302 W (0 err) |</span><br><span class="line"></span><br><span class="line">... many error warnings here ...</span><br><span class="line"></span><br><span class="line">29659 R (578 err) | 29660 W (577 err) |</span><br><span class="line">33749 R (578 err) | 33750 W (577 err) |</span><br><span class="line">37918 R (578 err) | 37919 W (577 err) |</span><br><span class="line">42077 R (578 err) | 42078 W (577 err) |</span><br></pre></td></tr></table></figure><p>从 consistency-test 的这段输出可以看到， 集群在执行故障转移期间， 总共丢失了 578 个读命令和 577 个写命令， 但是并没有产生任何数据不一致。</p><p>这听上去可能有点奇怪， 因为在教程的开头我们提到过， Redis 使用的是异步复制， 在执行故障转移期间， 集群可能会丢失写命令。</p><p>但是在实际上， 丢失命令的情况并不常见， 因为 Redis 几乎是同时执行将命令回复发送给客户端， 以及将命令复制给从节点这两个操作， 所以实际上造成命令丢失的时间窗口是非常小的。</p><p>不过， 尽管出现的几率不高， 但丢失命令的情况还是有可能会出现的， 所以我们对 Redis 集群不能提供强一致性的这一描述仍然是正确的。</p><p>现在， 让我们使用 cluster nodes 命令， 查看集群在执行故障转移操作之后， 主从节点的布局情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -p 7000 cluster nodes</span><br><span class="line">3fc783611028b1707fd65345e763befb36454d73 127.0.0.1:7004 slave 3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 0 1385503418521 0 connected</span><br><span class="line">a211e242fc6b22a9427fed61285e85892fa04e08 127.0.0.1:7003 slave 97a3a64667477371c4479320d683e4c8db5858b1 0 1385503419023 0 connected</span><br><span class="line">97a3a64667477371c4479320d683e4c8db5858b1 :0 myself,master - 0 0 0 connected 0-5959 10922-11422</span><br><span class="line">3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7005 master - 0 1385503419023 3 connected 11423-16383</span><br><span class="line">3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 127.0.0.1:7001 master - 0 1385503417005 0 connected 5960-10921</span><br><span class="line">2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385503418016 3 connected</span><br></pre></td></tr></table></figure><p>我重启了之前下线的 127.0.0.1:7002 节点， 该节点已经从原来的主节点变成了从节点， 而现在集群中的三个主节点分别是 127.0.0.1:7000 、 127.0.0.1:7001 和 127.0.0.1:7005 ， 其中 127.0.0.1:7005 就是因为 127.0.0.1:7002 下线而变成主节点的。</p><p>cluster nodes 命令的输出有点儿复杂， 它的每一行都是由以下信息组成的：</p><ul><li>节点 ID ：例如 3fc783611028b1707fd65345e763befb36454d73 。</li><li>ip:port ：节点的 IP 地址和端口号， 例如 127.0.0.1:7000 ， 其中 :0 表示的是客户端当前连接的 IP 地址和端口号。</li><li>flags ：节点的角色（例如 master 、 slave 、 myself ）以及状态（例如 fail ，等等）。</li><li>如果节点是一个从节点的话， 那么跟在 flags 之后的将是主节点的节点 ID ： 例如 127.0.0.1:7002 的主节点的节点 ID 就是 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 。</li><li>集群最近一次向节点发送 PING 命令之后， 过去了多长时间还没接到回复。</li><li>节点最近一次返回 PONG 回复的时间。</li><li>节点的配置纪元（configuration epoch）：详细信息请参考 Redis 集群规范 。</li><li>本节点的网络连接情况：例如 connected 。</li><li>节点目前包含的槽：例如 127.0.0.1:7001 目前包含号码为 5960 至 10921 的哈希槽。</li></ul><h3 id="添加新节点到集群"><a href="#添加新节点到集群" class="headerlink" title="添加新节点到集群"></a>添加新节点到集群</h3><p>根据新添加节点的种类， 我们需要用两种方法来将新节点添加到集群里面：</p><ul><li>如果要添加的新节点是一个主节点， 那么我们需要创建一个空节点（empty node）， 然后将某些哈希桶移动到这个空节点里面。</li><li>另一方面， 如果要添加的新节点是一个从节点， 那么我们需要将这个新节点设置为集群中某个节点的复制品（replica）。</li></ul><p>本节将对以上两种情况进行介绍， 首先介绍主节点的添加方法， 然后再介绍从节点的添加方法。</p><p>无论添加的是那种节点， 第一步要做的总是添加一个空节点。</p><p>我们可以继续使用之前启动 127.0.0.1:7000 、 127.0.0.1:7001 等节点的方法， 创建一个端口号为 7006 的新节点， 使用的配置文件也和之前一样， 只是记得要将配置中的端口号改为 7000 。</p><p>以下是启动端口号为 7006 的新节点的详细步骤：</p><ol><li>在终端里创建一个新的标签页。</li><li>进入 cluster-test 文件夹。</li><li>创建并进入 7006 文件夹。</li><li>将 redis.conf 文件复制到 7006 文件夹里面，然后将配置中的端口号选项改为 7006 。</li><li>使用命令 ../../redis-server redis.conf 启动节点。</li></ol><p>如果一切正常， 那么节点应该会正确地启动。</p><p>接下来， 执行以下命令， 将这个新节点添加到集群里面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-trib.rb add-node 127.0.0.1:7006 127.0.0.1:7000</span><br></pre></td></tr></table></figure><p>命令中的 add-node 表示我们要让 redis-trib 将一个节点添加到集群里面， add-node 之后跟着的是新节点的 IP 地址和端口号， 再之后跟着的是集群中任意一个已存在节点的 IP 地址和端口号， 这里我们使用的是 127.0.0.1:7000 。</p><p>通过 cluster nodes 命令， 我们可以确认新节点 127.0.0.1:7006 已经被添加到集群里面了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:7006&gt; cluster nodes</span><br><span class="line">3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 127.0.0.1:7001 master - 0 1385543178575 0 connected 5960-10921</span><br><span class="line">3fc783611028b1707fd65345e763befb36454d73 127.0.0.1:7004 slave 3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 0 1385543179583 0 connected</span><br><span class="line">f093c80dde814da99c5cf72a7dd01590792b783b :0 myself,master - 0 0 0 connected</span><br><span class="line">2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385543178072 3 connected</span><br><span class="line">a211e242fc6b22a9427fed61285e85892fa04e08 127.0.0.1:7003 slave 97a3a64667477371c4479320d683e4c8db5858b1 0 1385543178575 0 connected</span><br><span class="line">97a3a64667477371c4479320d683e4c8db5858b1 127.0.0.1:7000 master - 0 1385543179080 0 connected 0-5959 10922-11422</span><br><span class="line">3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7005 master - 0 1385543177568 3 connected 11423-16383</span><br></pre></td></tr></table></figure><p>新节点现在已经连接上了集群， 成为集群的一份子， 并且可以对客户端的命令请求进行转向了， 但是和其他主节点相比， 新节点还有两点区别：</p><ul><li>新节点没有包含任何数据， 因为它没有包含任何哈希桶。</li><li>尽管新节点没有包含任何哈希桶， 但它仍然是一个主节点， 所以在集群需要将某个从节点升级为新的主节点时， 这个新节点不会被选中。</li></ul><p>接下来， 只要使用 redis-trib 程序， 将集群中的某些哈希桶移动到新节点里面， 新节点就会成为真正的主节点了。</p><p>因为使用 redis-trib 移动哈希桶的方法在前面已经介绍过， 所以这里就不再重复介绍了。</p><p>现在， 让我们来看看， 将一个新节点转变为某个主节点的复制品（也即是从节点）的方法。</p><p>举个例子， 如果我们打算让新节点成为 127.0.0.1:7005 的从节点， 那么我们只要用客户端连接上新节点， 然后执行以下命令就可以了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:7006&gt; cluster replicate 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e</span><br></pre></td></tr></table></figure><p>其中命令提供的 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 就是主节点 127.0.0.1:7005 的节点 ID 。</p><p>执行 cluster replicate 命令之后， 我们可以使用以下命令来确认 127.0.0.1:7006 已经成为了 ID 为 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 的节点的从节点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -p 7000 cluster nodes | grep slave | grep 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e</span><br><span class="line">f093c80dde814da99c5cf72a7dd01590792b783b 127.0.0.1:7006 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385543617702 3 connected</span><br><span class="line">2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385543617198 3 connected</span><br></pre></td></tr></table></figure><p>3c3a0c… 现在有两个从节点， 一个从节点的端口号为 7002 ， 而另一个从节点的端口号为 7006 。</p><h3 id="移除一个节点"><a href="#移除一个节点" class="headerlink" title="移除一个节点"></a>移除一个节点</h3><p>未完待续。</p><h2 id="键空间通知（keyspace-notification）"><a href="#键空间通知（keyspace-notification）" class="headerlink" title="键空间通知（keyspace notification）"></a>键空间通知（keyspace notification）</h2><h3 id="功能概览"><a href="#功能概览" class="headerlink" title="功能概览"></a>功能概览</h3><p>键空间通知使得客户端可以通过订阅频道或模式， 来接收那些以某种方式改动了 Redis 数据集的事件。</p><p>以下是一些键空间通知发送的事件的例子：</p><ul><li>所有修改键的命令。</li><li>所有接收到 LPUSH key value [value …] 命令的键。</li><li>0 号数据库中所有已过期的键。</li></ul><p>事件通过 Redis 的订阅与发布功能（pub/sub）来进行分发， 因此所有支持订阅与发布功能的客户端都可以在无须做任何修改的情况下， 直接使用键空间通知功能。</p><p>因为 Redis 目前的订阅与发布功能采取的是发送即忘（fire and forget）策略， 所以如果你的程序需要可靠事件通知（reliable notification of events）， 那么目前的键空间通知可能并不适合你： 当订阅事件的客户端断线时， 它会丢失所有在断线期间分发给它的事件。</p><p>未来将会支持更可靠的事件分发， 这种支持可能会通过让订阅与发布功能本身变得更可靠来实现， 也可能会在 Lua 脚本中对消息（message）的订阅与发布进行监听， 从而实现类似将事件推入到列表这样的操作。</p><h3 id="事件的类型"><a href="#事件的类型" class="headerlink" title="事件的类型"></a>事件的类型</h3><p>对于每个修改数据库的操作，键空间通知都会发送两种不同类型的事件。</p><p>比如说，对 0 号数据库的键 mykey 执行 DEL key [key …] 命令时， 系统将分发两条消息， 相当于执行以下两个 PUBLISH channel message 命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH __keyspace@0__:mykey del</span><br><span class="line">PUBLISH __keyevent@0__:del mykey</span><br></pre></td></tr></table></figure></p><p>订阅第一个频道 __keyspace@0__:mykey 可以接收 0 号数据库中所有修改键 mykey 的事件， 而订阅第二个频道 __keyevent@0__:del 则可以接收 0 号数据库中所有执行 del 命令的键。</p><p>以 keyspace 为前缀的频道被称为键空间通知（key-space notification）， 而以 keyevent 为前缀的频道则被称为键事件通知（key-event notification）。</p><p>当 del mykey 命令执行时：</p><ul><li>键空间频道的订阅者将接收到被执行的事件的名字，在这个例子中，就是 del 。</li><li>键事件频道的订阅者将接收到被执行事件的键的名字，在这个例子中，就是 mykey 。</li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>因为开启键空间通知功能需要消耗一些 CPU ， 所以在默认配置下， 该功能处于关闭状态。</p><p>可以通过修改 redis.conf 文件， 或者直接使用 CONFIG SET 命令来开启或关闭键空间通知功能：</p><ul><li>当 notify-keyspace-events 选项的参数为空字符串时，功能关闭。</li><li>另一方面，当参数不是空字符串时，功能开启。</li></ul><p>notify-keyspace-events 的参数可以是以下字符的任意组合， 它指定了服务器该发送哪些类型的通知：</p><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">发送的通知</th></tr></thead><tbody><tr><td style="text-align:left">K</td><td style="text-align:left">键空间通知，所有通知以 __keyspace@\&lt;db>__ 为前缀</td></tr><tr><td style="text-align:left">E</td><td style="text-align:left">键事件通知，所有通知以 __keyevent@\&lt;db>__ 为前缀</td></tr><tr><td style="text-align:left">g</td><td style="text-align:left">DEL 、 EXPIRE 、 RENAME 等类型无关的通用命令的通知</td></tr><tr><td style="text-align:left">$</td><td style="text-align:left">字符串命令的通知</td></tr><tr><td style="text-align:left">l</td><td style="text-align:left">列表命令的通知</td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">集合命令的通知</td></tr><tr><td style="text-align:left">h</td><td style="text-align:left">哈希命令的通知</td></tr><tr><td style="text-align:left">z</td><td style="text-align:left">有序集合命令的通知</td></tr><tr><td style="text-align:left">x</td><td style="text-align:left">过期事件：每当有过期键被删除时发送</td></tr><tr><td style="text-align:left">e</td><td style="text-align:left">驱逐(evict)事件：每当有键因为 maxmemory 政策而被删除时发送</td></tr><tr><td style="text-align:left">A</td><td style="text-align:left">参数 g$lshzxe 的别名</td></tr></tbody></table><p>输入的参数中至少要有一个 K 或者 E ， 否则的话， 不管其余的参数是什么， 都不会有任何通知被分发。</p><p>举个例子， 如果只想订阅键空间中和列表相关的通知， 那么参数就应该设为 Kl ， 诸如此类。</p><p>将参数设为字符串 “AKE” 表示发送所有类型的通知。</p><h3 id="命令产生的通知"><a href="#命令产生的通知" class="headerlink" title="命令产生的通知"></a>命令产生的通知</h3><p>以下列表记录了不同命令所产生的不同通知：</p><ul><li>DEL key [key …] 命令为每个被删除的键产生一个 del 通知。</li><li>RENAME key newkey 产生两个通知：为来源键（source key）产生一个 rename_from 通知，并为目标键（destination key）产生一个 rename_to 通知。</li><li>EXPIRE key seconds 和 EXPIREAT key timestamp 在键被正确设置过期时间时产生一个 expire 通知。当 EXPIREAT key timestamp 设置的时间已经过期，或者 EXPIRE key seconds 传入的时间为负数值时，键被删除，并产生一个 del 通知。</li><li>SORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern …]] [ASC | DESC] [ALPHA] [STORE destination] 在命令带有 STORE 参数时产生一个 sortstore 事件。如果 STORE 指示的用于保存排序结果的键已经存在，那么程序还会发送一个 del 事件。</li><li>SET key value [EX seconds] [PX milliseconds] [NX|XX] 以及它的所有变种（SETEX key seconds value 、 SETNX key value 和 GETSET key value）都产生 set 通知。其中 SETEX key seconds value 还会产生 expire 通知。</li><li>MSET key value [key value …] 为每个键产生一个 set 通知。</li><li>SETRANGE key offset value 产生一个 setrange 通知。</li><li>INCR key 、 DECR key 、 INCRBY key increment 和 DECRBY key decrement 都产生 incrby 通知。</li><li>INCRBYFLOAT key increment 产生 incrbyfloat 通知。</li><li>APPEND key value 产生 append 通知。</li><li>LPUSH key value [value …] 和 LPUSHX key value 都产生单个 lpush 通知，即使有多个输入元素时，也是如此。</li><li>RPUSH key value [value …] 和 RPUSHX key value 都产生单个 rpush 通知，即使有多个输入元素时，也是如此。</li><li>RPOP key 产生 rpop 通知。如果被弹出的元素是列表的最后一个元素，那么还会产生一个 del 通知。</li><li>LPOP key 产生 lpop 通知。如果被弹出的元素是列表的最后一个元素，那么还会产生一个 del 通知。</li><li>LINSERT key BEFORE|AFTER pivot value 产生一个 linsert 通知。</li><li>LSET key index value 产生一个 lset 通知。</li><li>LTRIM key start stop 产生一个 ltrim 通知。如果 LTRIM key start stop 执行之后，列表键被清空，那么还会产生一个 del 通知。</li><li>RPOPLPUSH source destination 和 BRPOPLPUSH source destination timeout 产生一个 rpop 通知，以及一个 lpush 通知。两个命令都会保证 rpop 的通知在 lpush 的通知之前分发。如果从键弹出元素之后，被弹出的列表键被清空，那么还会产生一个 del 通知。</li><li>HSET hash field value 、 HSETNX hash field value 和 HMSET 都只产生一个 hset 通知。</li><li>HINCRBY 产生一个 hincrby 通知。</li><li>HINCRBYFLOAT 产生一个 hincrbyfloat 通知。</li><li>HDEL 产生一个 hdel 通知。如果执行 HDEL 之后，哈希键被清空，那么还会产生一个 del 通知。</li><li>SADD key member [member …] 产生一个 sadd 通知，即使有多个输入元素时，也是如此。</li><li>SREM key member [member …] 产生一个 srem 通知，如果执行 SREM key member [member …] 之后，集合键被清空，那么还会产生一个 del 通知。</li><li>SMOVE source destination member 为来源键（source key）产生一个 srem 通知，并为目标键（destination key）产生一个 sadd 事件。</li><li>SPOP key 产生一个 spop 事件。如果执行 SPOP key 之后，集合键被清空，那么还会产生一个 del 通知。</li><li>SINTERSTORE destination key [key …] 、 SUNIONSTORE destination key [key …] 和 SDIFFSTORE destination key [key …] 分别产生 sinterstore 、 sunionostore 和 sdiffstore 三种通知。如果用于保存结果的键已经存在，那么还会产生一个 del 通知。</li><li>ZINCRBY key increment member 产生一个 zincr 通知。（译注：非对称，请注意。）</li><li>ZADD key score member [[score member] [score member] …] 产生一个 zadd 通知，即使有多个输入元素时，也是如此。</li><li>ZREM key member [member …] 产生一个 zrem 通知，即使有多个输入元素时，也是如此。如果执行 ZREM key member [member …] 之后，有序集合键被清空，那么还会产生一个 del 通知。</li><li>ZREMRANGEBYSCORE key min max 产生一个 zrembyscore 通知。（译注：非对称，请注意。）如果用于保存结果的键已经存在，那么还会产生一个 del 通知。</li><li>ZREMRANGEBYRANK key start stop 产生一个 zrembyrank 通知。（译注：非对称，请注意。）如果用于保存结果的键已经存在，那么还会产生一个 del 通知。</li><li>ZINTERSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX] 和 ZUNIONSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX] 分别产生 zinterstore 和 zunionstore 两种通知。如果用于保存结果的键已经存在，那么还会产生一个 del 通知。</li><li>每当一个键因为过期而被删除时，产生一个 expired 通知。</li><li>每当一个键因为 maxmemory 政策而被删除以回收内存时，产生一个 evicted 通知。</li></ul><p><strong>Note</strong></p><pre><code>所有命令都只在键真的被改动了之后，才会产生通知。</code></pre><p>比如说，当 SREM key member [member …] 试图删除不存在于集合的元素时，删除操作会执行失败，因为没有真正的改动键，所以这一操作不会发送通知。</p><p>如果对命令所产生的通知有疑问， 最好还是使用以下命令， 自己来验证一下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli config <span class="built_in">set</span> notify-keyspace-events KEA</span><br><span class="line">$ redis-cli --csv psubscribe <span class="string">'__key*__:*'</span></span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line"><span class="string">"psubscribe"</span>,<span class="string">"__key*__:*"</span>,1</span><br></pre></td></tr></table></figure></p><p>然后， 只要在其他终端里用 Redis 客户端发送命令， 就可以看到产生的通知了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"pmessage"</span>,<span class="string">"__key*__:*"</span>,<span class="string">"__keyspace@0__:foo"</span>,<span class="string">"set"</span></span><br><span class="line"><span class="string">"pmessage"</span>,<span class="string">"__key*__:*"</span>,<span class="string">"__keyevent@0__:set"</span>,<span class="string">"foo"</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h3 id="过期通知的发送时间"><a href="#过期通知的发送时间" class="headerlink" title="过期通知的发送时间"></a>过期通知的发送时间</h3><p>Redis 使用以下两种方式删除过期的键：</p><ul><li>当一个键被访问时，程序会对这个键进行检查，如果键已经过期，那么该键将被删除。</li><li>底层系统会在后台渐进地查找并删除那些过期的键，从而处理那些已经过期、但是不会被访问到的键。</li></ul><p>当过期键被以上两个程序的任意一个发现、 并且将键从数据库中删除时， Redis 会产生一个 expired 通知。</p><p>Redis 并不保证生存时间（TTL）变为 0 的键会立即被删除： 如果程序没有访问这个过期键， 或者带有生存时间的键非常多的话， 那么在键的生存时间变为 0 ， 直到键真正被删除这中间， 可能会有一段比较显著的时间间隔。</p><p>因此， Redis 产生 expired 通知的时间为过期键被删除的时候， 而不是键的生存时间变为 0 的时候。</p><h2 id="通信协议（protocol）"><a href="#通信协议（protocol）" class="headerlink" title="通信协议（protocol）"></a>通信协议（protocol）</h2><p>Redis 协议在以下三个目标之间进行折中：</p><ul><li>易于实现</li><li>可以高效地被计算机分析（parse）</li><li>可以很容易地被人类读懂</li></ul><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>客户端和服务器通过 TCP 连接来进行数据交互， 服务器默认的端口号为 6379 。</p><p>客户端和服务器发送的命令或数据一律以 \r\n （CRLF）结尾。</p><h3 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h3><p>Redis 服务器接受命令以及命令的参数。</p><p>服务器会在接到命令之后，对命令进行处理，并将命令的回复传送回客户端。</p><h3 id="新版统一请求协议"><a href="#新版统一请求协议" class="headerlink" title="新版统一请求协议"></a>新版统一请求协议</h3><p>新版统一请求协议在 Redis 1.2 版本中引入， 并最终在 Redis 2.0 版本成为 Redis 服务器通信的标准方式。</p><p>你的 Redis 客户端应该按照这个新版协议来进行实现。</p><p>在这个协议中， 所有发送至 Redis 服务器的参数都是二进制安全（binary safe）的。</p><p>以下是这个协议的一般形式：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*&lt;参数数量&gt; CR LF</span><br><span class="line">$&lt;参数 1 的字节数量&gt; CR LF</span><br><span class="line">&lt;参数 1 的数据&gt; CR LF</span><br><span class="line">...</span><br><span class="line">$&lt;参数 N 的字节数量&gt; CR LF</span><br><span class="line">&lt;参数 N 的数据&gt; CR LF</span><br></pre></td></tr></table></figure></p><p><strong>Note</strong></p><pre><code>译注：命令本身也作为协议的其中一个参数来发送。</code></pre><p>举个例子， 以下是一个命令协议的打印版本：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*3</span><br><span class="line"><span class="variable">$3</span></span><br><span class="line">SET</span><br><span class="line"><span class="variable">$5</span></span><br><span class="line">mykey</span><br><span class="line"><span class="variable">$7</span></span><br><span class="line">myvalue</span><br></pre></td></tr></table></figure></p><p>这个命令的实际协议值如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"*3\r\n<span class="variable">$3</span>\r\nSET\r\n<span class="variable">$5</span>\r\nmykey\r\n<span class="variable">$7</span>\r\nmyvalue\r\n"</span></span><br></pre></td></tr></table></figure></p><p>稍后我们会看到， 这种格式除了用作命令请求协议之外， 也用在命令的回复协议中： 这种只有一个参数的回复格式被称为批量回复（Bulk Reply）。</p><p>统一协议请求原本是用在回复协议中， 用于将列表的多个项返回给客户端的， 这种回复格式被称为多条批量回复（Multi Bulk Reply）。</p><p>一个多条批量回复以 *\&lt;argc>\r\n 为前缀， 后跟多条不同的批量回复， 其中 argc 为这些批量回复的数量。</p><h3 id="回复"><a href="#回复" class="headerlink" title="回复"></a>回复</h3><p>Redis 命令会返回多种不同类型的回复。</p><p>通过检查服务器发回数据的第一个字节， 可以确定这个回复是什么类型：</p><ul><li>状态回复（status reply）的第一个字节是 “+”</li><li>错误回复（error reply）的第一个字节是 “-“</li><li>整数回复（integer reply）的第一个字节是 “:”</li><li>批量回复（bulk reply）的第一个字节是 “$”</li><li>多条批量回复（multi bulk reply）的第一个字节是 “*”</li></ul><h3 id="状态回复"><a href="#状态回复" class="headerlink" title="状态回复"></a>状态回复</h3><p>一个状态回复（或者单行回复，single line reply）是一段以 “+” 开始、 “\r\n” 结尾的单行字符串。</p><p>以下是一个状态回复的例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+OK</span><br></pre></td></tr></table></figure></p><p>客户端库应该返回 “+” 号之后的所有内容。 比如在在上面的这个例子中， 客户端就应该返回字符串 “OK” 。</p><p>状态回复通常由那些不需要返回数据的命令返回，这种回复不是二进制安全的，它也不能包含新行。</p><p>状态回复的额外开销非常少，只需要三个字节（开头的 “+” 和结尾的 CRLF）。</p><h3 id="错误回复"><a href="#错误回复" class="headerlink" title="错误回复"></a>错误回复</h3><p>错误回复和状态回复非常相似， 它们之间的唯一区别是， 错误回复的第一个字节是 “-“ ， 而状态回复的第一个字节是 “+” 。</p><p>错误回复只在某些地方出现问题时发送： 比如说， 当用户对不正确的数据类型执行命令， 或者执行一个不存在的命令， 等等。</p><p>一个客户端库应该在收到错误回复时产生一个异常。</p><p>以下是两个错误回复的例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-ERR unknown <span class="built_in">command</span> <span class="string">'foobar'</span></span><br><span class="line">-WRONGTYPE Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure></p><p>在 “-“ 之后，直到遇到第一个空格或新行为止，这中间的内容表示所返回错误的类型。</p><p>ERR 是一个通用错误，而 WRONGTYPE 则是一个更特定的错误。 一个客户端实现可以为不同类型的错误产生不同类型的异常， 或者提供一种通用的方式， 让调用者可以通过提供字符串形式的错误名来捕捉（trap）不同的错误。</p><p>不过这些特性用得并不多， 所以并不是特别重要， 一个受限的（limited）客户端可以通过简单地返回一个逻辑假（false）来表示一个通用的错误条件。</p><h3 id="整数回复"><a href="#整数回复" class="headerlink" title="整数回复"></a>整数回复</h3><p>整数回复就是一个以 “:” 开头， CRLF 结尾的字符串表示的整数。</p><p>比如说， “:0\r\n” 和 “:1000\r\n” 都是整数回复。</p><p>返回整数回复的其中两个命令是 INCR key 和 LASTSAVE 。 被返回的整数没有什么特殊的含义， INCR key 返回键的一个自增后的整数值， 而 LASTSAVE 则返回一个 UNIX 时间戳， 返回值的唯一限制是这些数必须能够用 64 位有符号整数表示。</p><p>整数回复也被广泛地用于表示逻辑真和逻辑假： 比如 EXISTS key 和 SISMEMBER key member 都用返回值 1 表示真， 0 表示假。</p><p>其他一些命令， 比如 SADD key member [member …] 、 SREM key member [member …] 和 SETNX key value ， 只在操作真正被执行了的时候， 才返回 1 ， 否则返回 0 。</p><p>以下命令都返回整数回复： SETNX key value 、 DEL key [key …] 、 EXISTS key 、 INCR key 、 INCRBY key increment 、 DECR key 、 DECRBY key decrement 、 DBSIZE 、 LASTSAVE 、 RENAMENX key newkey 、 MOVE key db 、 LLEN key 、 SADD key member [member …] 、 SREM key member [member …] 、 SISMEMBER key member 、 SCARD key 。</p><h3 id="批量回复"><a href="#批量回复" class="headerlink" title="批量回复"></a>批量回复</h3><p>服务器使用批量回复来返回二进制安全的字符串，字符串的最大长度为 512 MB 。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">客户端：GET mykey</span><br><span class="line">服务器：foobar</span><br></pre></td></tr></table></figure></p><p>服务器发送的内容中：</p><ul><li>第一字节为 “$” 符号</li><li>接下来跟着的是表示实际回复长度的数字值</li><li>之后跟着一个 CRLF</li><li>再后面跟着的是实际回复数据</li><li>最末尾是另一个 CRLF</li></ul><p>对于前面的 GET key 命令，服务器实际发送的内容为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"<span class="variable">$6</span>\r\nfoobar\r\n"</span></span><br></pre></td></tr></table></figure></p><p>如果被请求的值不存在， 那么批量回复会将特殊值 -1 用作回复的长度值， 就像这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">客户端：GET non-existing-key</span><br><span class="line">服务器：$-1</span><br></pre></td></tr></table></figure></p><p>这种回复称为空批量回复（NULL Bulk Reply）。</p><p>当请求对象不存在时，客户端应该返回空对象，而不是空字符串： 比如 Ruby 库应该返回 nil ， 而 C 库应该返回 NULL （或者在回复对象中设置一个特殊标志）， 诸如此类。</p><h3 id="多条批量回复"><a href="#多条批量回复" class="headerlink" title="多条批量回复"></a>多条批量回复</h3><p>像 LRANGE key start stop 这样的命令需要返回多个值， 这一目标可以通过多条批量回复来完成。</p><p>多条批量回复是由多个回复组成的数组， 数组中的每个元素都可以是任意类型的回复， 包括多条批量回复本身。</p><p>多条批量回复的第一个字节为 “*” ， 后跟一个字符串表示的整数值， 这个值记录了多条批量回复所包含的回复数量， 再后面是一个 CRLF 。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">客户端： LRANGE mylist 0 3</span><br><span class="line">服务器： *4</span><br><span class="line">服务器： <span class="variable">$3</span></span><br><span class="line">服务器： foo</span><br><span class="line">服务器： <span class="variable">$3</span></span><br><span class="line">服务器： bar</span><br><span class="line">服务器： <span class="variable">$5</span></span><br><span class="line">服务器： Hello</span><br><span class="line">服务器： <span class="variable">$5</span></span><br><span class="line">服务器： World</span><br></pre></td></tr></table></figure></p><p>在上面的示例中，服务器发送的所有字符串都由 CRLF 结尾。</p><p>正如你所见到的那样， 多条批量回复所使用的格式， 和客户端发送命令时使用的统一请求协议的格式一模一样。 它们之间的唯一区别是：</p><ul><li>统一请求协议只发送批量回复。</li><li>而服务器应答命令时所发送的多条批量回复，则可以包含任意类型的回复。</li></ul><p>以下例子展示了一个多条批量回复， 回复中包含四个整数值， 以及一个二进制安全字符串：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*5\r\n</span><br><span class="line">:1\r\n</span><br><span class="line">:2\r\n</span><br><span class="line">:3\r\n</span><br><span class="line">:4\r\n</span><br><span class="line"><span class="variable">$6</span>\r\n</span><br><span class="line">foobar\r\n</span><br></pre></td></tr></table></figure></p><p>在回复的第一行， 服务器发送 *5\r\n ， 表示这个多条批量回复包含 5 条回复， 再后面跟着的则是 5 条回复的正文。</p><p>多条批量回复也可以是空白的（empty）， 就像这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">客户端： LRANGE nokey 0 1</span><br><span class="line">服务器： *0\r\n</span><br></pre></td></tr></table></figure></p><p>无内容的多条批量回复（null multi bulk reply）也是存在的， 比如当 BLPOP key [key …] timeout 命令的阻塞时间超过最大时限时， 它就返回一个无内容的多条批量回复， 这个回复的计数值为 -1 ：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">客户端： BLPOP key 1</span><br><span class="line">服务器： *-1\r\n</span><br></pre></td></tr></table></figure></p><p>客户端库应该区别对待空白多条回复和无内容多条回复： 当 Redis 返回一个无内容多条回复时， 客户端库应该返回一个 null 对象， 而不是一个空数组。</p><h3 id="多条批量回复中的空元素"><a href="#多条批量回复中的空元素" class="headerlink" title="多条批量回复中的空元素"></a>多条批量回复中的空元素</h3><p>多条批量回复中的元素可以将自身的长度设置为 -1 ， 从而表示该元素不存在， 并且也不是一个空白字符串（empty string）。</p><p>当 SORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern …]] [ASC | DESC] [ALPHA] [STORE destination] 命令使用 GET pattern 选项对一个不存在的键进行操作时， 就会发生多条批量回复中带有空白元素的情况。</p><p>以下例子展示了一个包含空元素的多重批量回复：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">服务器： *3</span><br><span class="line">服务器： <span class="variable">$3</span></span><br><span class="line">服务器： foo</span><br><span class="line">服务器： $-1</span><br><span class="line">服务器： <span class="variable">$3</span></span><br><span class="line">服务器： bar</span><br></pre></td></tr></table></figure></p><p>其中， 回复中的第二个元素为空。</p><p>对于这个回复， 客户端库应该返回类似于这样的回复：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"foo"</span>, nil, <span class="string">"bar"</span>]</span><br></pre></td></tr></table></figure></p><h3 id="多命令和流水线"><a href="#多命令和流水线" class="headerlink" title="多命令和流水线"></a>多命令和流水线</h3><p>客户端可以通过流水线， 在一次写入操作中发送多个命令：</p><ul><li>在发送新命令之前， 无须阅读前一个命令的回复。</li><li>多个命令的回复会在最后一并返回。</li></ul><h3 id="内联命令"><a href="#内联命令" class="headerlink" title="内联命令"></a>内联命令</h3><p>当你需要和 Redis 服务器进行沟通， 但又找不到 redis-cli ， 而手上只有 telnet 的时候， 你可以通过 Redis 特别为这种情形而设的内联命令格式来发送命令。</p><p>以下是一个客户端和服务器使用内联命令来进行交互的例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">客户端： PING</span><br><span class="line">服务器： +PONG</span><br></pre></td></tr></table></figure></p><p>以下另一个返回整数值的内联命令的例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">客户端： EXISTS somekey</span><br><span class="line">服务器： :0</span><br></pre></td></tr></table></figure></p><p>因为没有了统一请求协议中的 “*” 项来声明参数的数量， 所以在 telnet 会话输入命令的时候， 必须使用空格来分割各个参数， 服务器在接收到数据之后， 会按空格对用户的输入进行分析（parse）， 并获取其中的命令参数。</p><h3 id="高性能-Redis-协议分析器"><a href="#高性能-Redis-协议分析器" class="headerlink" title="高性能 Redis 协议分析器"></a>高性能 Redis 协议分析器</h3><p>尽管 Redis 的协议非常利于人类阅读， 定义也很简单， 但这个协议的实现性能仍然可以和二进制协议一样快。</p><p>因为 Redis 协议将数据的长度放在数据正文之前， 所以程序无须像 JSON 那样， 为了寻找某个特殊字符而扫描整个 payload ， 也无须对发送至服务器的 payload 进行转义（quote）。</p><p>程序可以在对协议文本中的各个字符进行处理的同时， 查找 CR 字符， 并计算出批量回复或多条批量回复的长度， 就像这样：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = <span class="string">"$123\r\n"</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    p++;</span><br><span class="line">    <span class="keyword">while</span>(*p != <span class="string">'\r'</span>) &#123;</span><br><span class="line">        len = (len*<span class="number">10</span>)+(*p - <span class="string">'0'</span>);</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Now p points at '\r', and the len is in bulk_len. */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>得到了批量回复或多条批量回复的长度之后， 程序只需调用一次 read 函数， 就可以将回复的正文数据全部读入到内存中， 而无须对这些数据做任何的处理。</p><p>在回复最末尾的 CR 和 LF 不作处理，丢弃它们。</p><p>Redis 协议的实现性能可以和二进制协议的实现性能相媲美， 并且由于 Redis 协议的简单性， 大部分高级语言都可以轻易地实现这个协议， 这使得客户端软件的 bug 数量大大减少。</p><h2 id="复制（Replication）"><a href="#复制（Replication）" class="headerlink" title="复制（Replication）"></a>复制（Replication）</h2><p>Redis 支持简单且易用的主从复制（master-slave replication）功能， 该功能可以让从服务器(slave server)成为主服务器(master server)的精确复制品。</p><p>以下是关于 Redis 复制功能的几个重要方面：</p><ul><li><p>Redis 使用异步复制。 从 Redis 2.8 开始， 从服务器会以每秒一次的频率向主服务器报告复制流（replication stream）的处理进度。</p></li><li><p>一个主服务器可以有多个从服务器。</p></li><li><p>不仅主服务器可以有从服务器， 从服务器也可以有自己的从服务器， 多个从服务器之间可以构成一个图状结构。</p></li><li><p>复制功能不会阻塞主服务器： 即使有一个或多个从服务器正在进行初次同步， 主服务器也可以继续处理命令请求。</p></li><li><p>复制功能也不会阻塞从服务器： 只要在 redis.conf 文件中进行了相应的设置， 即使从服务器正在进行初次同步， 服务器也可以使用旧版本的数据集来处理命令查询。</p><p>  不过， 在从服务器删除旧版本数据集并载入新版本数据集的那段时间内， 连接请求会被阻塞。</p><p>  你还可以配置从服务器， 让它在与主服务器之间的连接断开时， 向客户端发送一个错误。</p></li><li><p>复制功能可以单纯地用于数据冗余（data redundancy）， 也可以通过让多个从服务器处理只读命令请求来提升扩展性（scalability）： 比如说， 繁重的 SORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern …]] [ASC | DESC] [ALPHA] [STORE destination] 命令可以交给附属节点去运行。</p></li><li><p>可以通过复制功能来让主服务器免于执行持久化操作： 只要关闭主服务器的持久化功能， 然后由从服务器去执行持久化操作即可。</p></li></ul><h3 id="关闭主服务器持久化时，复制功能的数据安全"><a href="#关闭主服务器持久化时，复制功能的数据安全" class="headerlink" title="关闭主服务器持久化时，复制功能的数据安全"></a>关闭主服务器持久化时，复制功能的数据安全</h3><p>当配置Redis复制功能时，强烈建议打开主服务器的持久化功能。 否则的话，由于延迟等问题，部署的服务应该要避免自动拉起。</p><p>为了帮助理解主服务器关闭持久化时自动拉起的危险性，参考一下以下会导致主从服务器数据全部丢失的例子：</p><ol><li><p>假设节点A为主服务器，并且关闭了持久化。 并且节点B和节点C从节点A复制数据</p></li><li><p>节点A崩溃，然后由自动拉起服务重启了节点A. 由于节点A的持久化被关闭了，所以重启之后没有任何数据</p></li><li><p>节点B和节点C将从节点A复制数据，但是A的数据是空的， 于是就把自身保存的数据副本删除。</p></li></ol><p>在关闭主服务器上的持久化，并同时开启自动拉起进程的情况下，即便使用Sentinel来实现Redis的高可用性，也是非常危险的。 因为主服务器可能拉起得非常快，以至于Sentinel在配置的心跳时间间隔内没有检测到主服务器已被重启，然后还是会执行上面的数据丢失的流程。</p><p>无论何时，数据安全都是极其重要的，所以应该禁止主服务器关闭持久化的同时自动拉起。</p><h3 id="复制功能的运作原理"><a href="#复制功能的运作原理" class="headerlink" title="复制功能的运作原理"></a>复制功能的运作原理</h3><p>无论是初次连接还是重新连接， 当建立一个从服务器时， 从服务器都将向主服务器发送一个 SYNC 命令。</p><p>接到 SYNC 命令的主服务器将开始执行 BGSAVE ， 并在保存操作执行期间， 将所有新执行的写入命令都保存到一个缓冲区里面。</p><p>当 BGSAVE 执行完毕后， 主服务器将执行保存操作所得的 .rdb 文件发送给从服务器， 从服务器接收这个 .rdb 文件， 并将文件中的数据载入到内存中。</p><p>之后主服务器会以 Redis 命令协议的格式， 将写命令缓冲区中积累的所有内容都发送给从服务器。</p><p>你可以通过 telnet 命令来亲自验证这个同步过程： 首先连上一个正在处理命令请求的 Redis 服务器， 然后向它发送 SYNC 命令， 过一阵子， 你将看到 telnet 会话（session）接收到服务器发来的大段数据（.rdb 文件）， 之后还会看到， 所有在服务器执行过的写命令， 都会重新发送到 telnet 会话来。</p><p>即使有多个从服务器同时向主服务器发送 SYNC ， 主服务器也只需执行一次 BGSAVE 命令， 就可以处理所有这些从服务器的同步请求。</p><p>从服务器可以在主从服务器之间的连接断开时进行自动重连， 在 Redis 2.8 版本之前， 断线之后重连的从服务器总要执行一次完整重同步（full resynchronization）操作， 但是从 Redis 2.8 版本开始， 从服务器可以根据主服务器的情况来选择执行完整重同步还是部分重同步（partial resynchronization）。</p><h3 id="部分重同步"><a href="#部分重同步" class="headerlink" title="部分重同步"></a>部分重同步</h3><p>从 Redis 2.8 开始， 在网络连接短暂性失效之后， 主从服务器可以尝试继续执行原有的复制进程（process）， 而不一定要执行完整重同步操作。</p><p>这个特性需要主服务器为被发送的复制流创建一个内存缓冲区（in-memory backlog）， 并且主服务器和所有从服务器之间都记录一个复制偏移量（replication offset）和一个主服务器 ID （master run id）， 当出现网络连接断开时， 从服务器会重新连接， 并且向主服务器请求继续执行原来的复制进程：</p><ul><li>如果从服务器记录的主服务器 ID 和当前要连接的主服务器的 ID 相同， 并且从服务器记录的偏移量所指定的数据仍然保存在主服务器的复制流缓冲区里面， 那么主服务器会向从服务器发送断线时缺失的那部分数据， 然后复制工作可以继续执行。</li><li>否则的话， 从服务器就要执行完整重同步操作。</li></ul><p>Redis 2.8 的这个部分重同步特性会用到一个新增的 PSYNC master_run_id offset 内部命令， 而 Redis 2.8 以前的旧版本只有 SYNC 命令， 不过， 只要从服务器是 Redis 2.8 或以上的版本， 它就会根据主服务器的版本来决定到底是使用 PSYNC master_run_id offset 还是 SYNC ：</p><ul><li>如果主服务器是 Redis 2.8 或以上版本，那么从服务器使用 PSYNC master_run_id offset 命令来进行同步。</li><li>如果主服务器是 Redis 2.8 之前的版本，那么从服务器使用 SYNC 命令来进行同步。</li></ul><h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><p>配置一个从服务器非常简单， 只要在配置文件中增加以下的这一行就可以了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof 192.168.1.1 6379</span><br></pre></td></tr></table></figure></p><p>当然， 你需要将代码中的 192.168.1.1 和 6379 替换成你的主服务器的 IP 和端口号。</p><p>另外一种方法是调用 SLAVEOF host port 命令， 输入主服务器的 IP 和端口， 然后同步就会开始：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SLAVEOF 192.168.1.1 10086</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p><h3 id="只读从服务器"><a href="#只读从服务器" class="headerlink" title="只读从服务器"></a>只读从服务器</h3><p>从 Redis 2.6 开始， 从服务器支持只读模式， 并且该模式为从服务器的默认模式。</p><p>只读模式由 redis.conf 文件中的 slave-read-only 选项控制， 也可以通过 CONFIG SET parameter value 命令来开启或关闭这个模式。</p><p>只读从服务器会拒绝执行任何写命令， 所以不会出现因为操作失误而将数据不小心写入到了从服务器的情况。</p><p>即使从服务器是只读的， DEBUG 和 CONFIG 等管理式命令仍然是可以使用的， 所以我们还是不应该将服务器暴露给互联网或者任何不可信网络。 不过， 使用 redis.conf 中的命令改名选项， 我们可以通过禁止执行某些命令来提升只读从服务器的安全性。</p><p>你可能会感到好奇， 既然从服务器上的写数据会被重同步数据覆盖， 也可能在从服务器重启时丢失， 那么为什么要让一个从服务器变得可写呢？</p><p>原因是， 一些不重要的临时数据， 仍然是可以保存在从服务器上面的。 比如说， 客户端可以在从服务器上保存主服务器的可达性（reachability）信息， 从而实现故障转移（failover）策略。</p><h3 id="从服务器相关配置"><a href="#从服务器相关配置" class="headerlink" title="从服务器相关配置"></a>从服务器相关配置</h3><p>如果主服务器通过 requirepass 选项设置了密码， 那么为了让从服务器的同步操作可以顺利进行， 我们也必须为从服务器进行相应的身份验证设置。</p><p>对于一个正在运行的服务器， 可以使用客户端输入以下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config <span class="built_in">set</span> masterauth &lt;password&gt;</span><br></pre></td></tr></table></figure></p><p>要永久地设置这个密码， 那么可以将它加入到配置文件中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">masterauth &lt;password&gt;</span><br></pre></td></tr></table></figure></p><p>另外还有几个选项， 它们和主服务器执行部分重同步时所使用的复制流缓冲区有关， 详细的信息可以参考 Redis 源码中附带的 redis.conf 示例文件。</p><p>主服务器只在有至少 N 个从服务器的情况下，才执行写操作<br>从 Redis 2.8 开始， 为了保证数据的安全性， 可以通过配置， 让主服务器只在有至少 N 个当前已连接从服务器的情况下， 才执行写命令。</p><p>不过， 因为 Redis 使用异步复制， 所以主服务器发送的写数据并不一定会被从服务器接收到， 因此， 数据丢失的可能性仍然是存在的。</p><p>以下是这个特性的运作原理：</p><ul><li>从服务器以每秒一次的频率 PING 主服务器一次， 并报告复制流的处理情况。</li><li>主服务器会记录各个从服务器最后一次向它发送 PING 的时间。</li><li>用户可以通过配置， 指定网络延迟的最大值 min-slaves-max-lag ， 以及执行写操作所需的至少从服务器数量 min-slaves-to-write 。</li></ul><p>如果至少有 min-slaves-to-write 个从服务器， 并且这些服务器的延迟值都少于 min-slaves-max-lag 秒， 那么主服务器就会执行客户端请求的写操作。</p><p>你可以将这个特性看作 CAP 理论中的 C 的条件放宽版本： 尽管不能保证写操作的持久性， 但起码丢失数据的窗口会被严格限制在指定的秒数中。</p><p>另一方面， 如果条件达不到 min-slaves-to-write 和 min-slaves-max-lag 所指定的条件， 那么写操作就不会被执行， 主服务器会向请求执行写操作的客户端返回一个错误。</p><p>以下是这个特性的两个选项和它们所需的参数：</p><ul><li>min-slaves-to-write \<number of="" slaves\=""></number></li><li>min-slaves-max-lag \<number of="" seconds\=""></number></li></ul><p>详细的信息可以参考 Redis 源码中附带的 redis.conf 示例文件。</p><h2 id="事务（transaction）"><a href="#事务（transaction）" class="headerlink" title="事务（transaction）"></a>事务（transaction）</h2><p>MULTI 、 EXEC 、 DISCARD 和 WATCH 是 Redis 事务的基础。</p><p>事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p><ul><li><p>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p></li><li><p>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p><p>  EXEC 命令负责触发并执行事务中的所有命令：</p><ul><li>如果客户端在使用 MULTI 开启了一个事务之后，却因为断线而没有成功执行 EXEC ，那么事务中的所有命令都不会被执行。</li><li><p>另一方面，如果客户端成功在开启事务之后执行 EXEC ，那么事务中的所有命令都会被执行。</p><p>当使用 AOF 方式做持久化的时候， Redis 会使用单个 write(2) 命令将事务写入到磁盘中。</p><p>然而，如果 Redis 服务器因为某些原因被管理员杀死，或者遇上某种硬件故障，那么可能只有部分事务命令会被成功写入到磁盘中。</p><p>如果 Redis 在重新启动时发现 AOF 文件出了这样的问题，那么它会退出，并汇报一个错误。</p><p>使用 redis-check-aof 程序可以修复这一问题：它会移除 AOF 文件中不完整事务的信息，确保服务器可以顺利启动。</p></li></ul></li></ul><p>从 2.2 版本开始，Redis 还可以通过乐观锁（optimistic lock）实现 CAS （check-and-set）操作，具体信息请参考文档的后半部分。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>MULTI 命令用于开启一个事务，它总是返回 OK 。</p><p>MULTI 执行之后， 客户端可以继续向服务器发送任意多条命令， 这些命令不会立即被执行， 而是被放到一个队列中， 当 EXEC 命令被调用时， 所有队列中的命令才会被执行。</p><p>另一方面， 通过调用 DISCARD ， 客户端可以清空事务队列， 并放弃执行事务。</p><p>以下是一个事务例子， 它原子地增加了 foo 和 bar 两个键的值：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">&gt; INCR foo</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">&gt; INCR bar</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">&gt; EXEC</span><br><span class="line">1) (<span class="built_in">integer</span>) 1</span><br><span class="line">2) (<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure></p><p>EXEC 命令的回复是一个数组， 数组中的每个元素都是执行事务中的命令所产生的回复。 其中， 回复元素的先后顺序和命令发送的先后顺序一致。</p><p>当客户端处于事务状态时， 所有传入的命令都会返回一个内容为 QUEUED 的状态回复（status reply）， 这些被入队的命令将在 EXEC 命令被调用时执行。</p><h3 id="事务中的错误"><a href="#事务中的错误" class="headerlink" title="事务中的错误"></a>事务中的错误</h3><p>使用事务时可能会遇上以下两种错误：</p><ul><li>事务在执行 EXEC 之前，入队的命令可能会出错。比如说，命令可能会产生语法错误（参数数量错误，参数名错误，等等），或者其他更严重的错误，比如内存不足（如果服务器使用 maxmemory 设置了最大内存限制的话）。</li><li>命令可能在 EXEC 调用之后失败。举个例子，事务中的命令可能处理了错误类型的键，比如将列表命令用在了字符串键上面，诸如此类。</li></ul><p>对于发生在 EXEC 执行之前的错误，客户端以前的做法是检查命令入队所得的返回值：如果命令入队时返回 QUEUED ，那么入队成功；否则，就是入队失败。如果有命令在入队时失败，那么大部分客户端都会停止并取消这个事务。</p><p>不过，从 Redis 2.6.5 开始，服务器会对命令入队失败的情况进行记录，并在客户端调用 EXEC 命令时，拒绝执行并自动放弃这个事务。</p><p>在 Redis 2.6.5 以前， Redis 只执行事务中那些入队成功的命令，而忽略那些入队失败的命令。 而新的处理方式则使得在流水线（pipeline）中包含事务变得简单，因为发送事务和读取事务的回复都只需要和服务器进行一次通讯。</p><p>至于那些在 EXEC 命令执行之后所产生的错误， 并没有对它们进行特别处理： 即使事务中有某个/某些命令在执行时产生了错误， 事务中的其他命令仍然会继续执行。</p><p>从协议的角度来看这个问题，会更容易理解一些。 以下例子中， LPOP key 命令的执行将出错， 尽管调用它的语法是正确的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Trying 127.0.0.1...</span><br><span class="line">Connected to localhost.</span><br><span class="line">Escape character is <span class="string">'^]'</span>.</span><br><span class="line"></span><br><span class="line">MULTI</span><br><span class="line">+OK</span><br><span class="line"></span><br><span class="line">SET a 3</span><br><span class="line">abc</span><br><span class="line"></span><br><span class="line">+QUEUED</span><br><span class="line">LPOP a</span><br><span class="line"></span><br><span class="line">+QUEUED</span><br><span class="line">EXEC</span><br><span class="line"></span><br><span class="line">*2</span><br><span class="line">+OK</span><br><span class="line">-ERR Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure></p><p>EXEC 返回两条批量回复（bulk reply）： 第一条是 OK ，而第二条是 -ERR 。 至于怎样用合适的方法来表示事务中的错误， 则是由客户端自己决定的。</p><p>最重要的是记住这样一条， 即使事务中有某条/某些命令执行失败了， 事务队列中的其他命令仍然会继续执行 —— Redis 不会停止执行事务中的命令。</p><p>以下例子展示的是另一种情况， 当命令在入队时产生错误， 错误会立即被返回给客户端：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MULTI</span><br><span class="line">+OK</span><br><span class="line"></span><br><span class="line">INCR a b c</span><br><span class="line">-ERR wrong number of arguments <span class="keyword">for</span> <span class="string">'incr'</span> <span class="built_in">command</span></span><br></pre></td></tr></table></figure></p><p>因为调用 INCR key 命令的参数格式不正确， 所以这个 INCR key 命令入队失败。</p><h3 id="为什么-Redis-不支持回滚（roll-back）"><a href="#为什么-Redis-不支持回滚（roll-back）" class="headerlink" title="为什么 Redis 不支持回滚（roll back）"></a>为什么 Redis 不支持回滚（roll back）</h3><p>如果你有使用关系式数据库的经验， 那么 “Redis 在事务失败时不进行回滚，而是继续执行余下的命令”这种做法可能会让你觉得有点奇怪。</p><p>以下是这种做法的优点：</p><ul><li>Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。</li><li>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</li></ul><p>有种观点认为 Redis 处理事务的做法会产生 bug ， 然而需要注意的是， 在通常情况下， 回滚并不能解决编程错误带来的问题。 举个例子， 如果你本来想通过 INCR key 命令将键的值加上 1 ， 却不小心加上了 2 ， 又或者对错误类型的键执行了 INCR key ， 回滚是没有办法处理这些情况的。</p><p>鉴于没有任何机制能避免程序员自己造成的错误， 并且这类错误通常不会在生产环境中出现， 所以 Redis 选择了更简单、更快速的无回滚方式来处理事务。</p><h3 id="放弃事务"><a href="#放弃事务" class="headerlink" title="放弃事务"></a>放弃事务</h3><p>当执行 DISCARD 命令时， 事务会被放弃， 事务队列会被清空， 并且客户端会从事务状态中退出：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET foo 1</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; INCR foo</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; DISCARD</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET foo</span><br><span class="line"><span class="string">"1"</span></span><br></pre></td></tr></table></figure></p><h3 id="使用-check-and-set-操作实现乐观锁"><a href="#使用-check-and-set-操作实现乐观锁" class="headerlink" title="使用 check-and-set 操作实现乐观锁"></a>使用 check-and-set 操作实现乐观锁</h3><p>WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。</p><p>被 WATCH 的键会被监视，并会发觉这些键是否被改动过了。 如果有至少一个被监视的键在 EXEC 执行之前被修改了， 那么整个事务都会被取消， EXEC 返回空多条批量回复（null multi-bulk reply）来表示事务已经失败。</p><p>举个例子， 假设我们需要原子性地为某个值进行增 1 操作（假设 INCR key 不存在）。</p><p>首先我们可能会这样做：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val = GET mykey</span><br><span class="line">val = val + 1</span><br><span class="line">SET mykey val</span><br></pre></td></tr></table></figure></p><p>上面的这个实现在只有一个客户端的时候可以执行得很好。 但是， 当多个客户端同时对同一个键进行这样的操作时， 就会产生竞争条件。</p><p>举个例子， 如果客户端 A 和 B 都读取了键原来的值， 比如 10 ， 那么两个客户端都会将键的值设为 11 ， 但正确的结果应该是 12 才对。</p><p>有了 WATCH ， 我们就可以轻松地解决这类问题了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WATCH mykey</span><br><span class="line"></span><br><span class="line">val = GET mykey</span><br><span class="line">val = val + 1</span><br><span class="line"></span><br><span class="line">MULTI</span><br><span class="line">SET mykey val</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure></p><p>使用上面的代码， 如果在 WATCH 执行之后， EXEC 执行之前， 有其他客户端修改了 mykey 的值， 那么当前客户端的事务就会失败。 程序需要做的， 就是不断重试这个操作， 直到没有发生碰撞为止。</p><p>这种形式的锁被称作乐观锁， 它是一种非常强大的锁机制。 并且因为大多数情况下， 不同的客户端会访问不同的键， 碰撞的情况一般都很少， 所以通常并不需要进行重试。</p><h3 id="了解-WATCH"><a href="#了解-WATCH" class="headerlink" title="了解 WATCH"></a>了解 WATCH</h3><p>WATCH 使得 EXEC 命令需要有条件地执行： 事务只能在所有被监视键都没有被修改的前提下执行， 如果这个前提不能满足的话，事务就不会被执行。</p><p><strong>Note</strong></p><pre><code>如果你使用 WATCH 监视了一个带过期时间的键， 那么即使这个键过期了， 事务仍然可以正常执行， 关于这方面的详细情况，请看这个帖子： http://code.google.com/p/redis/issues/detail?id=270</code></pre><p>WATCH 命令可以被调用多次。 对键的监视从 WATCH 执行之后开始生效， 直到调用 EXEC 为止。</p><p>用户还可以在单个 WATCH 命令中监视任意多个键， 就像这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; WATCH key1 key2 key3</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p><p>当 EXEC 被调用时， 不管事务是否成功执行， 对所有键的监视都会被取消。</p><p>另外， 当客户端断开连接时， 该客户端对键的监视也会被取消。</p><p>使用无参数的 UNWATCH 命令可以手动取消对所有键的监视。 对于一些需要改动多个键的事务， 有时候程序需要同时对多个键进行加锁， 然后检查这些键的当前值是否符合程序的要求。 当值达不到要求时， 就可以使用 UNWATCH 命令来取消目前对键的监视， 中途放弃这个事务， 并等待事务的下次尝试。</p><h3 id="使用-WATCH-实现-ZPOP"><a href="#使用-WATCH-实现-ZPOP" class="headerlink" title="使用 WATCH 实现 ZPOP"></a>使用 WATCH 实现 ZPOP</h3><p>WATCH 可以用于创建 Redis 没有内置的原子操作。</p><p>举个例子， 以下代码实现了原创的 ZPOP 命令， 它可以原子地弹出有序集合中分值（score）最小的元素：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WATCH zset</span><br><span class="line">element = ZRANGE zset 0 0</span><br><span class="line">MULTI</span><br><span class="line">    ZREM zset element</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure></p><p>程序只要重复执行这段代码， 直到 EXEC 的返回值不是空多条回复（null multi-bulk reply）即可。</p><h3 id="Redis-脚本和事务"><a href="#Redis-脚本和事务" class="headerlink" title="Redis 脚本和事务"></a>Redis 脚本和事务</h3><p>从定义上来说， Redis 中的脚本本身就是一种事务， 所以任何在事务里可以完成的事， 在脚本里面也能完成。 并且一般来说， 使用脚本要来得更简单，并且速度更快。</p><p>因为脚本功能是 Redis 2.6 才引入的， 而事务功能则更早之前就存在了， 所以 Redis 才会同时存在两种处理事务的方法。</p><p>不过我们并不打算在短时间内就移除事务功能， 因为事务提供了一种即使不使用脚本， 也可以避免竞争条件的方法， 而且事务本身的实现并不复杂。</p><p>不过在不远的将来， 可能所有用户都会只使用脚本来实现事务也说不定。 如果真的发生这种情况的话， 那么我们将废弃并最终移除事务功能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>跨域问题及解决方案</title>
    <link href="https://www.sakuratears.top/blog/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html"/>
    <id>https://www.sakuratears.top/blog/跨域问题及解决方案.html</id>
    <published>2019-07-17T14:28:00.000Z</published>
    <updated>2019-07-17T14:35:30.616Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>要了解跨域问题，我们先来了解下浏览器的同源策略。</p><p>浏览器的同源策略限制了从同一个源加载的文档或脚本与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。</p><p>同源的定义：</p><blockquote><p>如果两个URL的协议、端口、IP（域名）都相同，则这两个URL具有相同的源。</p></blockquote><p>根据这个定义，我们给出了下面的表格，可以简单看一下。</p><table><thead><tr><th>URL A</th><th>URL B</th><th>是否同源</th><th>原因</th></tr></thead><tbody><tr><td><a href="http://abc.xyz.kk:8080/index.html" rel="external nofollow noopener noreferrer" target="_blank">http://abc.xyz.kk:8080/index.html</a></td><td><a href="http://abc.xyz.kk:8080/demo/demo.html" rel="external nofollow noopener noreferrer" target="_blank">http://abc.xyz.kk:8080/demo/demo.html</a></td><td>是</td><td>协议、端口、域名均相同</td></tr><tr><td><a href="http://abc.xyz.kk:8080/api" rel="external nofollow noopener noreferrer" target="_blank">http://abc.xyz.kk:8080/api</a></td><td><a href="http://abc.xyz.kk:8888/index.html" rel="external nofollow noopener noreferrer" target="_blank">http://abc.xyz.kk:8888/index.html</a></td><td>否</td><td>端口不相同</td></tr><tr><td><a href="http://abc.xyz.kk:8080/api" rel="external nofollow noopener noreferrer" target="_blank">http://abc.xyz.kk:8080/api</a></td><td><a href="http://xyz.abc.kk:8080/index.html" rel="external nofollow noopener noreferrer" target="_blank">http://xyz.abc.kk:8080/index.html</a></td><td>否</td><td>域名（IP）不相同</td></tr><tr><td><a href="http://abc.xyz.kk:8080/index.html" rel="external nofollow noopener noreferrer" target="_blank">http://abc.xyz.kk:8080/index.html</a></td><td><a href="https://abc.xyz.kk:8888/index.html" rel="external nofollow noopener noreferrer" target="_blank">https://abc.xyz.kk:8888/index.html</a></td><td>否</td><td>协议不相同</td></tr><tr><td><a href="http://abc.xyz.kk:8080/hello" rel="external nofollow noopener noreferrer" target="_blank">http://abc.xyz.kk:8080/hello</a></td><td><a href="https://mmm.sss.ll:8888/hello" rel="external nofollow noopener noreferrer" target="_blank">https://mmm.sss.ll:8888/hello</a></td><td>否</td><td>协议、端口、域名均不相同</td></tr></tbody></table><h1 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h1><p>看到前言所说，同源策略提高了数据安全性，为什么我们还要研究跨域问题呢？</p><p>如果单纯的Web网站，页面资源（html、js或jsp等）在服务端，我们是不用考虑跨域问题的，因为它们就在一个域下。</p><p>但是现在很多项目是前后端分离的，无论原生APP还是WebApp，由于IP、端口或者协议等的不同，它们的请求在访问后端系统时，如果不做些处理，就会受到浏览器同源策略的约束，进而出现403错误。</p><h1 id="跨域方法"><a href="#跨域方法" class="headerlink" title="跨域方法"></a>跨域方法</h1><p>我们目前有以下几种方法解决跨域问题，我们分别来看下吧。</p><h2 id="Cross-Origin-Resource-Sharing-CORS"><a href="#Cross-Origin-Resource-Sharing-CORS" class="headerlink" title="Cross-Origin Resource Sharing (CORS)"></a>Cross-Origin Resource Sharing (CORS)</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>CORS是一个跨域资源共享方案，为了解决跨域问题，通过增加一系列HTTP请求头和响应头，规范安全地进行跨站数据传输。</p><p>请求头主要包括以下参数：</p><table><thead><tr><th>参数名</th><th>说明</th></tr></thead><tbody><tr><td>Origin</td><td>用于在跨域请求或预先请求中，标明发起跨域请求的源域名</td></tr><tr><td>Access-Control-Request-Method</td><td>用于表明跨域请求使用的实际HTTP方法</td></tr><tr><td>Access-Control-Request-Headers</td><td>用于在预先请求时，告知服务器要发起的跨域请求中会携带的请求头信息</td></tr><tr><td>withCredentials</td><td>跨域请求是否携带凭据信息，如果设置为true，响应头的Access-Control-Allow-Origin必须指定具体域名，且Access-Control-Allow-Credentials参数为true</td></tr></tbody></table><p>响应头主要包括以下参数：</p><table><thead><tr><th>参数名</th><th>说明</th></tr></thead><tbody><tr><td>Access-Control-Allow-Origin</td><td>该参数中携带了服务器端验证后的允许的跨域请求域名，可以是一个具体的域名或是一个*（表示任意域名）</td></tr><tr><td>Access-Control-Expose-Headers</td><td>该参数用于允许返回给跨域请求的响应头列表，在列表中的响应头的内容，才可以被浏览器访问</td></tr><tr><td>Access-Control-Max-Age</td><td>该参数用于告知浏览器可以将预先检查请求返回结果缓存的时间，在缓存有效期内，浏览器会使用缓存的预先检查结果判断是否发送跨域请求</td></tr><tr><td>Access-Control-Allow-Methods</td><td>该参数用于告知浏览器可以在实际发送跨域请求时，可以支持的请求方法，可以是一个具体的方法列表或是一个*（表示任意方法）</td></tr><tr><td>Access-Control-Allow-Credentials</td><td>是否允许携带凭据信息。默认凭据信息 不包括在 CORS 请求之中</td></tr></tbody></table><p>当我们给客户端添加符合的上述请求头参数，给服务端添加符合的响应头参数后，客户端对服务端的请求便可以实现跨越访问。</p><p>对CORS有更多兴趣的同学可以参考MDN的这篇文章。</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" rel="external nofollow noopener noreferrer" target="_blank">Cross-Origin Resource Sharing (CORS)</a></li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>我们使用前端JS+后台SpringBoot的例子来看一下。</p><p>前端部分代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#test"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        type: <span class="string">"POST"</span>,</span><br><span class="line">        url: <span class="string">"http://abc.xyz.kk/hello"</span>,</span><br><span class="line">        data:&#123;</span><br><span class="line">            name:<span class="string">"hello"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">            alert(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>后端部分代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsFilter <span class="title">corsFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UrlBasedCorsConfigurationSource source = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">        CorsConfiguration corsConfiguration = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">        <span class="comment">//允许所有类型请求头</span></span><br><span class="line">        corsConfiguration.addAllowedHeader(<span class="string">"*"</span>);</span><br><span class="line">        <span class="comment">//允许HEAD、POST和OPTIONS方法</span></span><br><span class="line">        corsConfiguration.setAllowedMethods(Arrays.asList(<span class="string">"HEAD"</span>,<span class="string">"POST"</span>, <span class="string">"OPTIONS"</span>));</span><br><span class="line">        <span class="comment">//允许携带Cookie</span></span><br><span class="line">        corsConfiguration.setAllowCredentials(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//允许所有的源</span></span><br><span class="line">        corsConfiguration.setAllowedOrigins(Arrays.asList(<span class="string">"*"</span>));</span><br><span class="line">        <span class="comment">//时间设置为3600s</span></span><br><span class="line">        corsConfiguration.setMaxAge(<span class="number">3600L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//跨域设置</span></span><br><span class="line">        <span class="comment">//所有请求都允许跨域</span></span><br><span class="line">        source.registerCorsConfiguration(<span class="string">"/**"</span>, corsConfiguration);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsFilter(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般出现跨域问题，如果使用CORS，只需要后台配置CORS过滤器（如上）即可实现跨域访问。</p><h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>JSONP(JSON with Padding)是JSON的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题。</p><p>JSONP的原理就是借助HTML中的&lt;script&gt;标签可以跨域引入资源。所以动态创建一个&lt;srcipt&gt;标签，src为目的接口 + get数据包 + 处理数据的函数名。后台收到GET请求后解析并返回函数名(数据)给前端，前端&lt;script&gt;标签动态执行处理函数。</p><p>&lt;script&gt;标签的src属性是没有跨域的限制的。这样说来，这种跨域方式其实与Ajax XmlHttpRequest协议无关了。</p><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>我们看一下JSONP方式实现跨域的前后端大致代码：</p><p>前端部分代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">//jsonp回调方法，一定要写在jsonp请求之前</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">jsonptest</span>(<span class="params">result</span>)</span>&#123;</span></span><br><span class="line"><span class="undefined">        alert(result);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span> =<span class="string">"/hello/test?callback=jsonptest"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> &gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>后端部分代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span></span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"test"</span>,method=RequestMethod.GET)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">jsonpTest</span><span class="params">(String callback)</span></span>&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    <span class="keyword">return</span> callback +<span class="string">"('Hello World!');"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到如果客户期望返回Hello World！ 实际收到的请求为 <code>jsonptest(‘Hello World!’)</code>，然后调用jsonptest函数获得实际想要的结果。</p><p>因为JSONP使用js的&lt;script&gt;标签进行传参，故该种方式只支持GET请求，这也是JSONP的一个缺点。</p><h2 id="Nginx反向代理"><a href="#Nginx反向代理" class="headerlink" title="Nginx反向代理"></a>Nginx反向代理</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>出现跨域限制的根本原因是浏览器同源问题的限制。</p><p>我们如果把前端项目和前端要请求的后台API接口地址放在同源下不就可以实现跨域请求了么？</p><p>这样我们前后端都不需要做任何跨域配置处理。</p><h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><p>比如我们有一个H5项目，部署在 <a href="http://abc.xyz.kk:8088" rel="external nofollow noopener noreferrer" target="_blank">http://abc.xyz.kk:8088</a> Nginx服务器上，后台地址为 <a href="http://abc.123.ss:8888" rel="external nofollow noopener noreferrer" target="_blank">http://abc.123.ss:8888</a> ，后台项目API接口地址为 <a href="http://abc.123.ss:8888/api/" rel="external nofollow noopener noreferrer" target="_blank">http://abc.123.ss:8888/api/</a> 。</p><p>则Nginx的配置文件 nginx.conf 的 server部分配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    #charset koi8-r;</span><br><span class="line"></span><br><span class="line">    #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">        proxy_pass http://localhost:8000/; # 前端本机地址，实现自动更新</span><br><span class="line">        autoindex on;</span><br><span class="line">        autoindex_exact_size on;</span><br><span class="line">        autoindex_localtime on;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /api/ &#123;</span><br><span class="line">            proxy_pass http://abc.123.ss:8888; # 后台API接口地址</span><br><span class="line">            proxy_redirect off;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">    # redirect server error pages to the static page /50x.html</span><br><span class="line">    #</span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">    #</span><br><span class="line">    #location ~ \.php$ &#123;</span><br><span class="line">    #    proxy_pass   http://127.0.0.1;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line">    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">    #</span><br><span class="line">    #location ~ \.php$ &#123;</span><br><span class="line">    #    root           html;</span><br><span class="line">    #    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">    #    fastcgi_index  index.php;</span><br><span class="line">    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br><span class="line">    #    include        fastcgi_params;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line">    # deny access to .htaccess files, if Apache&apos;s document root</span><br><span class="line">    # concurs with nginx&apos;s one</span><br><span class="line">    #</span><br><span class="line">    #location ~ /\.ht &#123;</span><br><span class="line">    #    deny  all;</span><br><span class="line">    #&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们访问了 <a href="http://abc.xyz.kk:8088" rel="external nofollow noopener noreferrer" target="_blank">http://abc.xyz.kk:8088</a> 地址（代理前端地址），访问后台API时，通过反向代理，相当于访问 <a href="http://abc.xyz.kk:8088/api/" rel="external nofollow noopener noreferrer" target="_blank">http://abc.xyz.kk:8088/api/</a> 这个地址，就不会出现跨域问题了。</p><h2 id="其他跨域解决方案"><a href="#其他跨域解决方案" class="headerlink" title="其他跨域解决方案"></a>其他跨域解决方案</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>如果我们要通过A网页访问另一个域的B网页时，根据同源策略，也会出现跨域问题。</p><p>这种情况我们可以通过<code>window.postMessage</code>、<code>window.name</code>共享、<code>window.location.hash</code>共享等方法来解决，关于这块，我们简单的用<code>window.postMessage</code>来看下，其他的大家可以查询相关资料进行了解。</p><p>使用WebSocket也可以实现资源跨域访问，WebSocket是长连接，资源消耗较大，除在一些即时通讯等特殊场景，专门用来解决跨域问题还是少之又少的，这一块我们也不在详述。</p><h3 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h3><p>我们用<code>window.postMessage</code>来进行举例。</p><p>下面是两个HTML，<a href="http://aaa.aaa.aa/A.html" rel="external nofollow noopener noreferrer" target="_blank">http://aaa.aaa.aa/A.html</a> 和 <a href="http://bbb.bbb.bb/B.html" rel="external nofollow noopener noreferrer" target="_blank">http://bbb.bbb.bb/B.html</a> 用 postMessage进行交互的例子。</p><p>A.html (发送端)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>A.html<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"test"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"B.html"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"send"</span> &gt;</span>A发送消息给B<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"receiver"</span> <span class="attr">src</span>=<span class="string">"http://bbb.bbb.bb/B.html"</span> <span class="attr">width</span>=<span class="string">"500"</span> <span class="attr">height</span>=<span class="string">"60"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>你的浏览器不支持IFrame。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> receiver = <span class="built_in">document</span>.getElementById(<span class="string">'receiver'</span>).contentWindow;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'send'</span>);</span></span><br><span class="line"><span class="javascript">        btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">            e.preventDefault();</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> val = <span class="built_in">document</span>.getElementById(<span class="string">'test'</span>).value;</span></span><br><span class="line"><span class="javascript">            receiver.postMessage(<span class="string">"Hello "</span>+val+<span class="string">"！"</span>, <span class="string">"http://aaa.aaa.aa/A.html"</span>);</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>B.html (接收端)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>B.html<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"message"</span>&gt;</span></span><br><span class="line">    Hello World!</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> messageEle = <span class="built_in">document</span>.getElementById(<span class="string">'message'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">            alert(e.origin);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (e.origin !== <span class="string">"http://aaa.aaa.aa/A.html"</span>) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span>;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="javascript">            messageEle.innerHTML = <span class="string">"从"</span>+ e.origin +<span class="string">"收到消息： "</span> + e.data;</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上跨域解决方案，最常用的还是CORS和反向代理，其次是JSONP，其他很少会被使用。</p><p>在允许Ajax XmlHttpRequest的浏览器（高版本浏览器）并与后端交互的场景，CORS和反向代理应用最广。</p><p>如果浏览器不支持XmlHttpRequest（IE6、IE7….），可以考虑使用JSONP。</p><p>如果涉及到不同源网页交互，支持H5的浏览器可以采用<code>window.postMessage</code>，不支持的可以使用<code>window.name</code>共享、<code>window.location.hash</code>共享等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="跨域" scheme="https://www.sakuratears.top/tags/%E8%B7%A8%E5%9F%9F/"/>
    
      <category term="CORS" scheme="https://www.sakuratears.top/tags/CORS/"/>
    
      <category term="JSONP" scheme="https://www.sakuratears.top/tags/JSONP/"/>
    
  </entry>
  
  <entry>
    <title>JDK里那些有趣的代码（2）</title>
    <link href="https://www.sakuratears.top/blog/JDK%E9%87%8C%E9%82%A3%E4%BA%9B%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%882%EF%BC%89.html"/>
    <id>https://www.sakuratears.top/blog/JDK里那些有趣的代码（2）.html</id>
    <published>2019-07-09T13:55:00.000Z</published>
    <updated>2019-07-09T14:32:53.028Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>接 <a href="https://www.sakuratears.top/blog/JDK%E9%87%8C%E9%82%A3%E4%BA%9B%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%881%EF%BC%89.html">JDK里那些有趣的代码</a>这篇文章。</p><p>今天我们来看下另一个比较有意思的代码部分。</p><p>在说这个之前，我们先来研究一道比较有意思的题目。</p><blockquote><p>使用Java程序 获取下一个最小的比入参n大的2的高次幂</p></blockquote><p>这个题的意思就是：比如入参为10，则最小的比入参大的2的高次幂为 ${2}^{4} = {16}$；入参为100，则最小的比入参大的2的高次幂为${2}^{7}={128}$。</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>对于这种题目，我们如何处理呢？</p><p>最简单的是想到循环，2，4，8…..逐渐增大值，并与入参进行对比，相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNum1</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;= <span class="number">31</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">1</span>&lt;&lt;i;</span><br><span class="line">        <span class="keyword">if</span>(b &gt; n)&#123;</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上方法 <code>1&lt;&lt;i</code> 是把1左移i位，每次左移一位就是乘以2，所以<code> 1&lt;&lt;i </code>的结果是1乘以2的i次方。</p><p>当然我们也可以使用Java自带的<code>Math.pow</code>或者乘法算法方法，不过显然这种方法效率要低。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNum2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;= <span class="number">31</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">double</span> b = Math.pow(<span class="number">2</span>,i);</span><br><span class="line">        <span class="keyword">if</span>(b &gt; n)&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>)b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNum3</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;= <span class="number">31</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k &gt; n)&#123;</span><br><span class="line">            <span class="keyword">return</span> k;</span><br><span class="line">        &#125;</span><br><span class="line">        k *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者我们可以想到将入参每次除以2，直到小于1，记录次数i，然后2的i次方即是我们所要求的值。</p><p>相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNum4</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>&lt;&lt;i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们仍使用了移位运算，<code> n = n &gt;&gt; 1 </code>每次将n向右移一位即除以2，当n &lt;= 0 时记录次数 i,并使用<code> 1&lt;&lt;i </code>算出要求的值。</p><p>当然我们也可以使用普通的除法算法，但这种效率要低些，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNum5</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        n /=<span class="number">2</span>;</span><br><span class="line">       i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>&lt;&lt;i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实上面几种情况原理都是类似的。</p><p>还有什么别的方法么？</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>很巧，在JDK相关源码中也有类似的问题，即<em>获取下一个最小的比入参n大的2的高次幂</em>。</p><p>在哪儿会用到呢？</p><p>当然是HashMap了，HashMap在扩容时，扩容指定的大小就是<em>下一个最小的比入参n大的2的高次幂</em>。</p><p>下面是具体tableSizeFor方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以在CourrentHashMap、ForkJoinPool中发现类似的处理逻辑，这种处理的优点体现在哪儿呢？</p><p>我们把上面的代码在整理下，如下，对于入参n，该方法可以计算出最小的比入参n大的2的高次幂。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNum6</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> n &lt; <span class="number">0</span> ? <span class="number">1</span> : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：我们忽略源码中的<code>int n = cap - 1;</code> 这一步的作用是对于入参比如8，<code>tableSizeFor</code>方法会返回8，而<code>getNum6</code>会返回16，其实主要看题目怎么出，这儿我们找的是比入参n大的数，不包括n。</p><p>我们先来手动计算一下，以32和2000为例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 32 = 100000 = 0100000</span></span><br><span class="line">n|=n&gt;&gt;&gt;<span class="number">1</span>;<span class="comment">//  n=n|(n&gt;&gt;&gt;1)  = 0100000|0010000 = 0110000 = 48</span></span><br><span class="line">n|=n&gt;&gt;&gt;<span class="number">2</span>;<span class="comment">//  n=n|(n&gt;&gt;&gt;2)  = 0110000|0001100 = 0111100 = 60</span></span><br><span class="line">n|=n&gt;&gt;&gt;<span class="number">4</span>;<span class="comment">//  n=n|(n&gt;&gt;&gt;4)  = 0111100|0000011 = 0111111 = 63</span></span><br><span class="line">n|=n&gt;&gt;&gt;<span class="number">8</span>;<span class="comment">//  n=n|(n&gt;&gt;&gt;8)  = 0111111|0000000 = 0111111 = 63</span></span><br><span class="line">n|=n&gt;&gt;&gt;<span class="number">16</span>;<span class="comment">// n=n|(n&gt;&gt;&gt;16) = 0111111|0000000 = 0111111 = 63</span></span><br><span class="line"><span class="comment">// n + 1 =64</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2000 = 11111010000 = 11111010000</span></span><br><span class="line">n|=n&gt;&gt;&gt;<span class="number">1</span>;<span class="comment">//  n=n|(n&gt;&gt;&gt;1)  = 11111010000|01111101000 = 11111111000 = 2040</span></span><br><span class="line">n|=n&gt;&gt;&gt;<span class="number">2</span>;<span class="comment">//  n=n|(n&gt;&gt;&gt;2)  = 11111111000|00111111110 = 11111111110 = 2046</span></span><br><span class="line">n|=n&gt;&gt;&gt;<span class="number">4</span>;<span class="comment">//  n=n|(n&gt;&gt;&gt;4)  = 11111111110|00001111111 = 11111111111 = 2047</span></span><br><span class="line">n|=n&gt;&gt;&gt;<span class="number">8</span>;<span class="comment">//  n=n|(n&gt;&gt;&gt;8)  = 11111111111|00000000111 = 11111111111 = 2047</span></span><br><span class="line">n|=n&gt;&gt;&gt;<span class="number">16</span>;<span class="comment">// n=n|(n&gt;&gt;&gt;16) = 11111111111|00000000000 = 11111111111 = 2047</span></span><br><span class="line"><span class="comment">// n + 1 =2048</span></span><br></pre></td></tr></table></figure><p>计算过程比较简单，只要明白以下两点：</p><ul><li><p><code>n&gt;&gt;&gt;i</code> 是指二进制的n的值向右移i位；</p></li><li><p><code>i|k</code>指的是i和k进行位或运算，| 是把某两个二进制数中, 只要其中一个的某一位为1，则结果的该位就为1，与&amp;运算相反。</p></li></ul><p>我们来分析一下：</p><ul><li>首先，如果是2的整数次方数，其除最高位（指第一个不为0的数）外，其他位必然是0。比如 ${2}^{11}={2048}$，其二进制为 $100000000000$。</li><li><p>则2的整数次方数-1必定最高位为0，其他位必然为1。大致如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>   -<span class="number">1</span>   =    <span class="number">000000010</span> -<span class="number">1</span>   =  <span class="number">000000001</span></span><br><span class="line"><span class="number">4</span>   -<span class="number">1</span>   =    <span class="number">000000100</span> -<span class="number">1</span>   =  <span class="number">000000011</span></span><br><span class="line"><span class="number">8</span>   -<span class="number">1</span>   =    <span class="number">000001000</span> -<span class="number">1</span>   =  <span class="number">000000111</span></span><br><span class="line"><span class="number">16</span>  -<span class="number">1</span>   =    <span class="number">000010000</span> -<span class="number">1</span>   =  <span class="number">000001111</span></span><br><span class="line"><span class="number">32</span>  -<span class="number">1</span>   =    <span class="number">000100000</span> -<span class="number">1</span>   =  <span class="number">000011111</span></span><br><span class="line"><span class="number">64</span>  -<span class="number">1</span>   =    <span class="number">001000000</span> -<span class="number">1</span>   =  <span class="number">000111111</span></span><br><span class="line"><span class="number">128</span> -<span class="number">1</span>   =    <span class="number">010000000</span> -<span class="number">1</span>   =  <span class="number">001111111</span></span><br><span class="line"><span class="number">256</span> -<span class="number">1</span>   =    <span class="number">100000000</span> -<span class="number">1</span>   =  <span class="number">011111111</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure></li><li><p>我们对于任意数，如21，二进制为 000010101，当使用移位+位或运算时，最终该值会逐渐增大到 000011111，而这个值加1就是我们要找的值。其实质是右传播最左侧的一位，来找到最大值。</p></li><li><p>问：为什么右移位要按照1、2、4、8、16这样移动呢？而不是其他数字呢？</p><p>答：这很好理解，我们拿 $128 （010000000）$来举例，比它大的最小的2的高次幂是256，则需要得到255。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">010000000</span></span><br><span class="line"><span class="number">011000000</span>   右移<span class="number">1</span>位+位或</span><br><span class="line"><span class="number">011110000</span>   右移<span class="number">2</span>位+位或</span><br><span class="line"><span class="number">011111111</span>   右移<span class="number">4</span>位+位或</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>可以看到我们用了一个最小值128，得到255，只需要最左侧的1右移（1、2、4）并进行位或操作。int最大32位，故右移最大16位即可保证最高位的1对右边的0进行全覆盖（位或操作）。</p></li></ul><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>到底高不高效还是取决于测试结果，我们写一个简单的测试方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//生成若干数量的随机数，找到它们的最小的2的高次幂</span></span><br><span class="line">    <span class="keyword">int</span> [] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100000000</span>];</span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">        a[i] = random.nextInt(<span class="number">1073741824</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法1</span></span><br><span class="line">    <span class="keyword">long</span> start1 = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">        getNum1(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"方法1耗时:"</span>+(System.currentTimeMillis()-start1)+<span class="string">"ms"</span>);</span><br><span class="line">    <span class="comment">//方法2</span></span><br><span class="line">    <span class="keyword">long</span> start2 = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">        getNum2(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"方法2耗时:"</span>+(System.currentTimeMillis()-start2)+<span class="string">"ms"</span>);</span><br><span class="line">    <span class="comment">//方法3</span></span><br><span class="line">    <span class="keyword">long</span> start3 = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">        getNum3(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"方法3耗时:"</span>+(System.currentTimeMillis()-start3)+<span class="string">"ms"</span>);</span><br><span class="line">    <span class="comment">//方法4</span></span><br><span class="line">    <span class="keyword">long</span> start4 = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">        getNum4(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"方法4耗时:"</span>+(System.currentTimeMillis()-start4)+<span class="string">"ms"</span>);</span><br><span class="line">    <span class="comment">//方法5</span></span><br><span class="line">    <span class="keyword">long</span> start5 = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">        getNum5(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"方法5耗时:"</span>+(System.currentTimeMillis()-start5)+<span class="string">"ms"</span>);</span><br><span class="line">    <span class="comment">//方法6</span></span><br><span class="line">    <span class="keyword">long</span> start6 = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">        getNum6(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"方法6耗时:"</span>+(System.currentTimeMillis()-start6)+<span class="string">"ms"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>某次结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">方法<span class="number">1</span>耗时:<span class="number">1064</span>ms</span><br><span class="line"><span class="comment">//由于方法2耗时实在无法接受，便不再展示。调用Math.pow方法，同学们可实际测试下。</span></span><br><span class="line">方法<span class="number">3</span>耗时:<span class="number">1097</span>ms</span><br><span class="line">方法<span class="number">4</span>耗时:<span class="number">2232</span>ms</span><br><span class="line">方法<span class="number">5</span>耗时:<span class="number">3885</span>ms</span><br><span class="line">方法<span class="number">6</span>耗时:<span class="number">155</span>ms</span><br></pre></td></tr></table></figure><p>经过多次测试其结果相差不大。可以看到方法6（也就是JDK里的tableSizeFor方法）确实高效。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>该方法在 <a href="">Hacker’s Delight （高效程序的奥秘）</a>一书 3.2节中有一些介绍，有兴趣的同学也可以去看看。</p><p>通过上面的讲解，我们可以看到JDK源码中使用高效算法的艺术，多读源码，对我们也受益匪浅。</p><p>今天就先到这里，有时间我们在分析JDK源码中比较有趣的一些代码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JDK1.7与JDK1.8中ConcurrentHashMap的一些变化</title>
    <link href="https://www.sakuratears.top/blog/JDK1-7%E4%B8%8EJDK1-8%E4%B8%ADConcurrentHashMap%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8F%98%E5%8C%96.html"/>
    <id>https://www.sakuratears.top/blog/JDK1-7与JDK1-8中ConcurrentHashMap的一些变化.html</id>
    <published>2019-07-07T02:50:00.000Z</published>
    <updated>2019-07-07T03:19:01.181Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天我们来了解下<code>ConcurrentHashMap</code>的设计，并看下它在JDK1.7和JDK1.8中的一些改变。</p><p>说到<code>ConcurrentHashMap</code>，或许大家并不陌生，都知道它可以在并发访问的情况下使用，可以保证线程数据安全，相对于<code>Hashtable</code>和线程同步的<code>HashMap</code>-&gt;<code>Collections.synchronizedMap(new HashMap&lt;&gt;())</code>,它的效率更高。</p><p>在学习<code>ConcurrentHashMap</code>时，大家最好先对<code>HashMap</code>有一些认识，可以看一下我之前的一篇文章。<a href="https://www.sakuratears.top/blog/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html">HashMap实现原理</a></p><p>JDK1.7和JDK1.8 <code>ConcurrentHashMap</code>的设计实现是不同的，我们分别来看下，以进行对比。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="JDK1-7的ConcurrentHashMap"><a href="#JDK1-7的ConcurrentHashMap" class="headerlink" title="JDK1.7的ConcurrentHashMap"></a>JDK1.7的ConcurrentHashMap</h2><h3 id="1-7的ConcurrentHashMap设计思路"><a href="#1-7的ConcurrentHashMap设计思路" class="headerlink" title="1.7的ConcurrentHashMap设计思路"></a>1.7的ConcurrentHashMap设计思路</h3><p>1.7的 <code>ConcurrentHashMap</code>的设计是通过分段锁的方式实现的，提高了并发度。分段是一开始就确定的了，后期不能再进行扩容。</p><p>所谓分段锁，主要是根据<code>Segment</code>段来实现的。</p><p>其中的段<code>Segment</code>继承了重入锁<code>ReentrantLock</code>，有了锁的功能，同时含有类似<code>HashMap</code>中的数组加链表结构（这里没有使用红黑树）。</p><p>虽然<code>Segment</code>的个数是不能扩容的，但是单个<code>Segment</code>里面的数组是可以扩容的。</p><h3 id="整体概览"><a href="#整体概览" class="headerlink" title="整体概览"></a>整体概览</h3><p><code>ConcurrentHashMap</code>有3个参数：</p><ul><li>initialCapacity：初始总容量，默认16</li><li>loadFactor：加载因子，默认0.75</li><li>concurrencyLevel：并发级别，默认16</li></ul><p>然后我们需要知道的是：</p><ul><li><p><code>Segment</code>的个数即ssize：取大于等于并发级别的最小的2的幂次。如concurrencyLevel=16，那么sszie=16,如concurrencyLevel=10，那么ssize=16。</p></li><li><p>单个<code>Segment</code>的初始容量cap：c=initialCapacity/ssize,并且可能需要+1。如15/7=2，那么c要取3，如16/8=2，那么c取2，c可能是一个任意值，那么同上述一样，cap取的值就是大于等于c的最下2的幂次。最小值要求是MIN_SEGMENT_TABLE_CAPACITY = 2。</p></li><li><p>单个<code>Segment</code>的阈值threshold：threshold=cap*loadFactor。</p></li></ul><p>所以默认情况下，<code>Segment</code>的个数sszie=16,每个<code>Segment</code>的初始容量cap=2，单个<code>Segment</code>的阈值threshold=1。</p><p>如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-433.png" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-434.png" alt="upload successful"></p><p>通过上图我们可以算出上述数据。</p><h3 id="put过程"><a href="#put过程" class="headerlink" title="put过程"></a>put过程</h3><ol><li>首先根据key计算出一个hash值，找到对应的<code>Segment</code>；</li><li>调用<code>Segment</code>的lock方法，为后面的put操作加锁；</li><li>根据key计算出hash值，找到<code>Segment</code>中数组中对应index的链表，并将该数据放置到该链表中；</li><li>判断当前<code>Segment</code>包含元素的数量大于阈值，则<code>Segment</code>进行扩容。</li></ol><p>代码逻辑如下图源码：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-435.png" alt="upload successful"></p><p>其中<code>Segment</code>的put过程源码如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-436.png" alt="upload successful"></p><p>我们看一下加锁方法：</p><p>可以看到如果不成功会尝试进行重试直到成功，同时如果找不到key，会返回一个新的node节点，如果key存在，会返回null。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-437.png" alt="upload successful"></p><h3 id="扩容过程（rehash）"><a href="#扩容过程（rehash）" class="headerlink" title="扩容过程（rehash）"></a>扩容过程（rehash）</h3><p>这个扩容是在<code>Segment</code>的锁的保护下进行扩容的，不需要关注并发问题。</p><p>我们来看下相关源码：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-438.png" alt="upload successful"></p><p>我们看红框部分的内容，扩容的重点在于：</p><ul><li><p>首先找到一个lastRun，lastRun之后的元素和lastRun是在同一个桶中，所以后面的不需要进行变动。</p></li><li><p>然后对开始到lastRun部分的元素，重新计算下设置到newTable中，每次都是将当前元素作为newTable的首元素，之前老的链表作为该首元素的next部分。</p></li></ul><h3 id="get过程"><a href="#get过程" class="headerlink" title="get过程"></a>get过程</h3><ol><li>根据key计算出对应的<code>Segment</code>；</li><li>再根据key计算出对应<code>Segment</code>中数组的index；</li><li>最终遍历上述index位置的链表，查找出对应的key的value；</li></ol><p>源码如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-439.png" alt="upload successful"></p><h3 id="remove过程"><a href="#remove过程" class="headerlink" title="remove过程"></a>remove过程</h3><ol><li>根据key值计算hash找到对应的<code>Segment</code>；</li><li>如果<code>Segment</code>不为空就调用<code>Segment</code>的remove方法；</li><li>对<code>Segment</code>段进行加锁，根据hash计算出index，找到链表（如果存在的话）；</li><li>对于找到的链表，循环找到key对应的值，并进行删除。</li></ol><p>相关代码如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-440.png" alt="upload successful"></p><h3 id="size方法"><a href="#size方法" class="headerlink" title="size方法"></a>size方法</h3><p>我们先来看下源码：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-441.png" alt="upload successful"></p><p>其大致原理如下：</p><ol><li>使用一个循环，循环的退出条件是sum = last， 这次总数 = 上次总数，即<code>Segment</code>没有变化了；</li><li>每次循环，都记录 sum += modCount 和 size，如果超了int长度就返回最大int值；</li><li>循环一定次数（RETRIES_BEFORE_LOCK = 2）后如果<code>Segment</code>大小还在改变，就尝试对所有<code>Segment</code>加锁，来获取size；</li><li>最后要判断下所试次数（retries）是否大于RETRIES_BEFORE_LOCK，如果大于说明加过锁，还要对它们进行解锁。</li></ol><p>其他方法大家可以参考下源码，不再详述。</p><h2 id="JDK1-8的ConcurrentHashMap"><a href="#JDK1-8的ConcurrentHashMap" class="headerlink" title="JDK1.8的ConcurrentHashMap"></a>JDK1.8的ConcurrentHashMap</h2><h3 id="1-8的ConcurrentHashMap设计思路"><a href="#1-8的ConcurrentHashMap设计思路" class="headerlink" title="1.8的ConcurrentHashMap设计思路"></a>1.8的ConcurrentHashMap设计思路</h3><p>1.8的<code>ConcurrentHashMap</code>摒弃了1.7的<code>Segment</code>设计，而是在1.8<code>HashMap</code>的基础上实现了线程安全的版本，即也是采用数组+链表+红黑树的形式。</p><p>数组可以扩容，链表可以转化为红黑树。</p><h3 id="整体概览-1"><a href="#整体概览-1" class="headerlink" title="整体概览"></a>整体概览</h3><p>有一个重要的参数sizeCtl，代表数组的大小；</p><p>用户可以设置一个初始容量initialCapacity给<code>ConcurrentHashMap</code>；</p><p>sizeCtl = 大于（1.5倍initialCapacity+1）的最小的2的幂次，</p><p>即initialCapacity=20，则sizeCtl=32,如initialCapacity=24，则sizeCtl=64。</p><p>初始化的时候，会按照sizeCtl的大小创建出对应大小的数组。</p><p>相关代码如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-442.png" alt="upload successful"></p><h3 id="put过程-1"><a href="#put过程-1" class="headerlink" title="put过程"></a>put过程</h3><ol><li><p>如果数组还未初始化，那么进行初始化，这里会通过一个CAS操作将sizeCtl设置为-1，设置成功的，可以进行初始化操作；</p></li><li><p>根据key的hash值找到对应的桶，如果桶还不存在，那么通过一个CAS操作来设置桶的第一个元素，失败的继续执行下面的逻辑即向桶中插入或更新；</p></li><li><p>如果找到的桶存在，但是桶中第一个元素的hash值是-1，说明此时该桶正在进行迁移操作，这一块会在下面的扩容中详细介绍；</p></li><li><p>如果找到的桶存在，那么要么是链表结构要么是红黑树结构，此时需要获取该桶的锁，在锁定的情况下执行链表或者红黑树的插入或更新；</p><ul><li><p>如果桶中第一个元素的hash值大于0，说明是链表结构，则对链表插入或者更新；</p></li><li><p>如果桶中的第一个元素类型是TreeBin，说明是红黑树结构，则按照红黑树的方式进行插入或者更新；</p></li></ul></li><li><p>在锁的保护下插入或者更新完毕后，如果是链表结构，需要判断链表中元素的数量是否超过8（默认），一旦超过就要考虑进行数组扩容或者是链表转红黑树。</p></li></ol><p>如下图源码：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-443.png" alt="upload successful"></p><p>initTable方法代码如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-444.png" alt="upload successful"></p><p>我们再来看下扩容过程。</p><h3 id="扩容过程"><a href="#扩容过程" class="headerlink" title="扩容过程"></a>扩容过程</h3><p>一旦链表中的元素个数超过了8个，那么可以执行数组扩容或者链表转为红黑树，这里依据的策略跟<code>HashMap</code>依据的策略是一致的。</p><p>当数组长度还未达到64个时，优先数组的扩容，否则选择链表转为红黑树。</p><p>源码如下所示：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-445.png" alt="upload successful"></p><p>重点来看看这个扩容过程，即看下上述tryPresize方法，也可以看到上述是2倍扩容的方式。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-446.png" alt="upload successful"></p><p>第一个执行的线程会首先设置sizeCtl属性为一个负值，然后执行transfer(tab, null)，其他晚进来的线程会检查当前扩容是否已经完成，没完成则帮助进行扩容，完成了则直接退出。</p><p>该<code>ConcurrentHashMap</code>的扩容操作可以允许多个线程并发执行，那么就要处理好任务的分配工作。每个线程获取一部分桶的迁移任务，如果当前线程的任务完成，查看是否还有未迁移的桶，若有则继续领取任务执行，若没有则退出。在退出时需要检查是否还有其他线程在参与迁移工作，如果有则自己什么也不做直接退出，如果没有了则执行最终的收尾工作。</p><p>Q1：当前线程如何感知其他线程也在参与迁移工作？</p><p>A1: 靠sizeCtl的值，它初始值是一个负值=(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)，每当一个线程参与进来执行迁移工作，则该值进行CAS自增，该线程的任务执行完毕要退出时对该值进行CAS自减操作，所以当sizeCtl的值等于上述初值则说明了此时未有其他线程还在执行迁移工作，可以去执行收尾工作了。见如下代码:</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-447.png" alt="upload successful"></p><p>Q2: 任务按照什么规则进行分片？</p><p>A2： 下图stride即是每个分片的大小，目前有最低要求16，即每个分片至少需要16个桶。stride的计算依赖于CPU的核数，如果只有1个核，那么此时就不用分片，即stride=n。其他情况就是 (n &gt;&gt;&gt; 3) / NCPU。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-448.png" alt="upload successful"></p><p>Q3：如何记录目前已经分出去的任务？</p><p>A3: <code>ConcurrentHashMap</code>含有一个属性transferIndex（初值为最后一个桶），表示从transferIndex开始到后面所有的桶的迁移任务已经被分配出去了。所以每次线程领取扩容任务，则需要对该属性进行CAS的减操作，即一般是transferIndex-stride。</p><p>Q4：每个线程如何处理分到的部分桶的迁移工作？</p><p>A4：第一个获取到分片的线程会创建一个新的数组，容量是之前的2倍。</p><p>遍历自己所分到的桶：</p><ul><li><p>桶中元素不存在，则通过CAS操作设置桶中第一个元素为ForwardingNode，其Hash值为MOVED（-1）,同时该元素含有新的数组引用</p><p>此时若其他线程进行put操作，发现第一个元素的hash值为-1则代表正在进行扩容操作（并且表明该桶已经完成扩容操作了，可以直接在新的数组中重新进行hash和插入操作），该线程就可以去参与进去，或者没有任务则不用参与，此时可以去直接操作新的数组了</p></li><li><p>桶中元素存在且hash值为-1，则说明该桶已经被处理了（本不会出现多个线程任务重叠的情况，这里主要是该线程在执行完所有的任务后会再次进行检查，再次核对）</p></li><li><p>桶中为链表或者红黑树结构，则需要获取桶锁，防止其他线程对该桶进行put操作，然后处理方式同HashMap的处理方式一样，对桶中元素分为2类，分别代表当前桶中和要迁移到新桶中的元素。设置完毕后代表桶迁移工作已经完成，旧数组中该桶可以设置成ForwardingNode了</p></li></ul><p>下面来看下详细的代码：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-449.png" alt="upload successful"></p><h3 id="get过程-1"><a href="#get过程-1" class="headerlink" title="get过程"></a>get过程</h3><ul><li><p>根据k计算出hash值，找到对应的数组index;</p></li><li><p>如果该index位置无元素则直接返回null;</p></li><li><p>如果该index位置有元素:</p><ul><li><p>如果第一个元素的hash值小于0，则该节点可能为ForwardingNode或者红黑树节点TreeBin;</p><ul><li><p>如果是ForwardingNode（表示当前正在进行扩容），使用新的数组来进行查找;</p></li><li><p>如果是红黑树节点TreeBin，使用红黑树的查找方式来进行查找;</p></li></ul></li><li><p>如果第一个元素的hash大于等于0，则为链表结构，依次遍历即可找到对应的元素。</p></li></ul></li></ul><p>详细代码如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-450.png" alt="upload successful"></p><h3 id="其他方法过程"><a href="#其他方法过程" class="headerlink" title="其他方法过程"></a>其他方法过程</h3><p><code>ConcurrentHashMap</code>的一些其它方法，如remove，size等也是十分复杂的。我们后面在详聊JDK1.8 <code>ConcurrentHashMap</code>的一些其它方法。</p><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><h2 id="ConcurrentHashMap读为什么不需要锁？"><a href="#ConcurrentHashMap读为什么不需要锁？" class="headerlink" title="ConcurrentHashMap读为什么不需要锁？"></a>ConcurrentHashMap读为什么不需要锁？</h2><p>我们通常使用读写锁来保护对一堆数据的读写操作。读时加读锁，写时加写锁。在什么样的情况下可以不需要读锁呢？</p><p>如果对数据的读写是一个原子操作，那么此时是可以不需要读锁的。如<code>ConcurrentHashMap</code>对数据的读写，写操作是不需要分2次写的（没有中间状态），读操作也是不需要2次读取的。假如一个写操作需要分多次写，必然会有中间状态，如果读不加锁，那么可能就会读到中间状态，那就不对了。</p><p>假如<code>ConcurrentHashMap</code>提供put(key1,value1,key2,value2)，写入的时候必然会存在中间状态即key1写完成，但是key2还未写，此时如果读不加锁，那么就可能读到key1是新数据而key2是老数据的中间状态。</p><p>虽然<code>ConcurrentHashMap</code>的读不需要锁，但是需要保证能读到最新数据，所以必须加volatile。即数组的引用需要加volatile，同时一个Node节点中的val和next属性也必须要加volatile。</p><h2 id="ConcurrentHashMap是否可以在无锁的情况下进行迁移？"><a href="#ConcurrentHashMap是否可以在无锁的情况下进行迁移？" class="headerlink" title="ConcurrentHashMap是否可以在无锁的情况下进行迁移？"></a>ConcurrentHashMap是否可以在无锁的情况下进行迁移？</h2><p>目前1.8的<code>ConcurrentHashMap</code>迁移是在锁定旧桶的前提下进行迁移的，然而并没有去锁定新桶。那么就可能提出如下问题：</p><p>Q1：在某个桶的迁移过程中，别的线程想要对该桶进行put操作怎么办？</p><p>A1: 一旦某个桶在迁移过程中了，必然要获取该桶的锁，所以其他线程的put操作要被阻塞，一旦迁移完毕，该桶中第一个元素就会被设置成ForwardingNode节点，所以其他线程put时需要重新判断下桶中第一个元素是否被更改了，如果被改了重新获取重新执行逻辑，如下代码：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-451.png" alt="upload successful"></p><p>Q2: 某个桶已经迁移完成（其他桶还未完成），别的线程想要对该桶进行put操作怎么办？</p><p>A2: 该线程会首先检查是否还有未分配的迁移任务，如果有则先去执行迁移任务，如果没有即全部任务已经分发出去了，那么此时该线程可以直接对新的桶进行插入操作（映射到的新桶必然已经完成了迁移，所以可以放心执行操作）。</p><p>Q3: 从上面看到我们在迁移的时候还是需要对旧桶锁定的，能否在无锁的情况下实现迁移？</p><p>A3: 一旦扩容就涉及到迁移桶中元素的操作，将一个桶中的元素迁移到另一个桶中的操作不是一个原子操作，所以需要在锁的保护下进行迁移。如果扩容操作是移动桶的指向，那么就可以通过一个CAS操作来完成扩容操作。可以参考参考这篇论文<a href="http://people.csail.mit.edu/shanir/publications/Split-Ordered_Lists.pdf" rel="external nofollow noopener noreferrer" target="_blank">Split-Ordered Lists: Lock-Free Extensible Hash Tables</a></p><h2 id="ConcurrentHashMap曾经的弱一致性"><a href="#ConcurrentHashMap曾经的弱一致性" class="headerlink" title="ConcurrentHashMap曾经的弱一致性"></a>ConcurrentHashMap曾经的弱一致性</h2><p>曾经老版本的<code>ConcurrentHashMap</code>是弱一致的，大家可以参考相关文档或者较早的<code>ConcurrentHashMap</code>源码。</p><p>曾经引发弱一致性的原因：</p><pre><code>对数组的引用是volatile来修饰的，但是数组中的元素并不是。即读取数组的引用总是能读取到最新的值，但是读取数组中某一个元素的时候并不一定能读到最新的值。所以说是弱一致性的。</code></pre><p>要实现强一致性，可以这样：</p><ul><li><p>对于新加的key，通过写入到链表的末尾即可。因为一个元素的next属性是volatile的，可以保证写入后立马看的到，如下1.8的方式；</p></li><li><p>或者对数组中元素的更新采用volatile写的方式，如下1.7的形式。</p></li></ul><p>但是现在1.7版本的<code>ConcurrentHashMap</code>对于数组中元素的写也是加了volatile的，如下代码：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-452.png" alt="upload successful"></p><p>1.8的方式就是直接将新加入的元素写入next属性（含有volatile修饰）中而不是修改桶中的第一个元素，如下代码：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-453.png" alt="upload successful"></p><p>所以在1.7和1.8版本的<code>ConcurrentHashMap</code>中不再是弱一致性，写入的数据是可以立即被读到的。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本文介绍了JDK1.7和JDK1.8版本下的<code>ConcurrentHashMap</code>的一些差异，也了解了1.7和1.8下<code>ConcurrentHashMap</code>的一些原理及方法，让我们对<code>ConcurrentHashMap</code>有了更深刻的一些认识。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://my.oschina.net/pingpangkuangmo/blog/817973" rel="external nofollow noopener noreferrer" target="_blank">jdk1.8的HashMap和ConcurrentHashMap</a> (有改动)</li><li>JDK1.8 ConcurrentHashMap源码</li><li>JDK1.7 ConcurrentHashMap源码</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="ConcurrentHashMap" scheme="https://www.sakuratears.top/tags/ConcurrentHashMap/"/>
    
  </entry>
  
  <entry>
    <title>（转）分布式系统下的CAP理论</title>
    <link href="https://www.sakuratears.top/blog/%EF%BC%88%E8%BD%AC%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%9A%84CAP%E7%90%86%E8%AE%BA.html"/>
    <id>https://www.sakuratears.top/blog/（转）分布式系统下的CAP理论.html</id>
    <published>2019-07-01T14:31:00.000Z</published>
    <updated>2019-07-01T14:36:06.202Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原文：<a href="https://www.hollischuang.com/archives/666" rel="external nofollow noopener noreferrer" target="_blank">分布式系统的CAP理论</a></p><blockquote><p>2000年7月，加州大学伯克利分校的Eric Brewer教授在ACM PODC会议上提出CAP猜想。2年后，麻省理工学院的Seth Gilbert和Nancy Lynch从理论上证明了CAP。之后，CAP理论正式成为分布式计算领域的公认定理。</p></blockquote><p>无论你是一个系统架构师，还是一个普通开发，当你开发或者设计一个分布式系统的时候，CAP理论是无论如何也绕不过去的。本文就来介绍一下到底什么是CAP理论，如何证明CAP理论，以及CAP的权衡问题。</p><h1 id="CAP理论概述"><a href="#CAP理论概述" class="headerlink" title="CAP理论概述"></a>CAP理论概述</h1><p>CAP理论：一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-429.png" alt="upload successful"></p><blockquote><p>读者需要注意的的是，CAP理论中的CA和数据库事务中ACID的CA并完全是同一回事儿。两者之中的A都是C都是一致性(Consistency)。CAP中的A指的是可用性（Availability），而ACID中的A指的是原子性（Atomicity)，切勿混为一谈。</p></blockquote><h1 id="CAP的定义"><a href="#CAP的定义" class="headerlink" title="CAP的定义"></a>CAP的定义</h1><h2 id="Consistency-一致性"><a href="#Consistency-一致性" class="headerlink" title="Consistency 一致性"></a>Consistency 一致性</h2><p>一致性指 “<font color="red">all nodes see the same data at the same time</font>” ，即更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致，所以，一致性，说的就是数据一致性。</p><p>对于一致性，可以分为从客户端和服务端两个不同的视角。从客户端来看，一致性主要指的是多并发访问时更新过的数据如何获取的问题。从服务端来看，则是更新如何复制分布到整个系统，以保证数据最终一致。</p><p>一致性是因为有并发读写才有的问题，因此在理解一致性的问题时，一定要注意结合考虑并发读写的场景。</p><p>从客户端角度，多进程并发访问时，更新过的数据在不同进程如何获取的不同策略，决定了不同的一致性。</p><p><strong>三种一致性策略</strong></p><p>对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是强一致性。</p><p>如果能容忍后续的部分或者全部访问不到，则是弱一致性。</p><p>如果经过一段时间后要求能访问到更新后的数据，则是最终一致性。</p><p>CAP中说，不可能同时满足的这个一致性指的是强一致性。</p><h2 id="Availability-可用性"><a href="#Availability-可用性" class="headerlink" title="Availability 可用性"></a>Availability 可用性</h2><p>可用性指 “<font color="red">Reads and writes always succeed</font>” ，即服务一直可用，而且是正常响应时间。</p><p>对于一个可用性的分布式系统，每一个非故障的节点必须对每一个请求作出响应。所以，一般我们在衡量一个系统的可用性的时候，都是通过停机时间来计算的。</p><table><thead><tr><th>可用性分类</th><th>可用水平（%）</th><th>年可容忍停机时间</th></tr></thead><tbody><tr><td>容错可用性</td><td>99.9999</td><td>&lt;1 min</td></tr><tr><td>极高可用性</td><td>99.999</td><td>&lt;5 min</td></tr><tr><td>具有故障自动恢复能力的可用性</td><td>99.99</td><td>&lt;53 min</td></tr><tr><td>高可用性</td><td>99.9</td><td>&lt;8.8h</td></tr><tr><td>商品可用性</td><td>99</td><td>&lt;43.8 min</td></tr></tbody></table><p>通常我们描述一个系统的可用性时，我们说淘宝的系统可用性可以达到5个9，意思就是说他的可用水平是99.999%，即全年停机时间不超过<code> (1-0.99999)<em>365</em>24*60 = 5.256 min</code>，这是一个极高的要求。</p><p>好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。一个分布式系统，上下游设计很多系统如负载均衡、WEB服务器、应用代码、数据库服务器等，任何一个节点的不稳定都可以影响可用性。</p><h2 id="Partition-Tolerance分区容错性"><a href="#Partition-Tolerance分区容错性" class="headerlink" title="Partition Tolerance分区容错性"></a>Partition Tolerance分区容错性</h2><p>分区容错性指 “<font color="red">the system continues to operate despite arbitrary message loss or failure of part of the system</font>” ，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。</p><p>分区容错性和扩展性紧密相关。在分布式应用中，可能因为一些分布式的原因导致系统无法正常运转。好的分区容错性要求能够使应用虽然是一个分布式系统，而看上去却好像是在一个可以运转正常的整体。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，或者是机器之间有网络异常，将分布式系统分隔未独立的几个部分，各个部分还能维持分布式系统的运作，这样就具有好的分区容错性。</p><p>简单点说，就是在网络中断，消息丢失的情况下，系统如果还能正常工作，就是有比较好的分区容错性。</p><h1 id="CAP的证明"><a href="#CAP的证明" class="headerlink" title="CAP的证明"></a>CAP的证明</h1><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-430.png" alt="upload successful"></p><p>如上图，是我们证明CAP的基本场景，网络中有两个节点N1和N2，可以简单的理解N1和N2分别是两台计算机，他们之间网络可以连通，N1中有一个应用程序A，和一个数据库V，N2也有一个应用程序B2和一个数据库V。现在，A和B是分布式系统的两个部分，V是分布式系统的数据存储的两个子数据库。</p><p>在满足一致性的时候，N1和N2中的数据是一样的，V0=V0。在满足可用性的时候，用户不管是请求N1或者N2，都会得到立即响应。在满足分区容错性的情况下，N1和N2有任何一方宕机，或者网络不通的时候，都不会影响N1和N2彼此之间的正常运作。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-431.png" alt="upload successful"></p><p>如上图，是分布式系统正常运转的流程，用户向N1机器请求数据更新，程序A更新数据库Vo为V1，分布式系统将数据进行同步操作M，将V1同步的N2中V0，使得N2中的数据V0也更新为V1，N2中的数据再响应N2的请求。</p><p>这里，可以定义N1和N2的数据库V之间的数据是否一样为一致性；外部对N1和N2的请求响应为可用行；N1和N2之间的网络环境为分区容错性。这是正常运作的场景，也是理想的场景，然而现实是残酷的，当错误发生的时候，一致性和可用性还有分区容错性，是否能同时满足，还是说要进行取舍呢？</p><p>作为一个分布式系统，它和单机系统的最大区别，就在于网络，现在假设一种极端情况，N1和N2之间的网络断开了，我们要支持这种网络异常，相当于要满足分区容错性，能不能同时满足一致性和响应性呢？还是说要对他们进行取舍。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-432.png" alt="upload successful"></p><p>假设在N1和N2之间网络断开的时候，有用户向N1发送数据更新请求，那N1中的数据V0将被更新为V1，由于网络是断开的，所以分布式系统同步操作M，所以N2中的数据依旧是V0；这个时候，有用户向N2发送数据读取请求，由于数据还没有进行同步，应用程序没办法立即给用户返回最新的数据V1，怎么办呢？</p><p>有二种选择，第一，牺牲数据一致性，保证可用性。响应旧的数据V0给用户；</p><p>第二，牺牲可用性，保证数据一致性。阻塞等待，直到网络连接恢复，数据更新操作M完成之后，再给用户响应最新的数据V1。</p><p>这个过程，证明了要满足分区容错性的分布式系统，只能在一致性和可用性两者中，选择其中一个。</p><h1 id="CAP权衡"><a href="#CAP权衡" class="headerlink" title="CAP权衡"></a>CAP权衡</h1><p>通过CAP理论及前面的证明，我们知道无法同时满足一致性、可用性和分区容错性这三个特性，那要舍弃哪个呢？</p><p>我们分三种情况来阐述一下。</p><h2 id="CA-without-P"><a href="#CA-without-P" class="headerlink" title="CA without P"></a>CA without P</h2><p>这种情况在分布式系统中几乎是不存在的。首先在分布式环境下，网络分区是一个自然的事实。因为分区是必然的，所以如果舍弃P，意味着要舍弃分布式系统。那也就没有必要再讨论CAP理论了。这也是为什么在前面的CAP证明中，我们以系统满足P为前提论述了无法同时满足C和A。</p><p>比如我们熟知的关系型数据库，如My Sql和Oracle就是保证了可用性和数据一致性，但是他并不是个分布式系统。一旦关系型数据库要考虑主备同步、集群部署等就必须要把P也考虑进来。</p><p>其实，在CAP理论中。C，A，P三者并不是平等的，CAP之父在《Spanner，真时，CAP理论》一文中写到：</p><blockquote><p>如果说Spanner真有什么特别之处，那就是谷歌的广域网。Google通过建立私有网络以及强大的网络工程能力来保证P，在多年运营改进的基础上，在生产环境中可以最大程度的减少分区发生，从而实现高可用性。</p></blockquote><p>从Google的经验中可以得到的结论是，无法通过降低CA来提升P。要想提升系统的分区容错性，需要通过提升基础设施的稳定性来保障。</p><p>所以，对于一个分布式系统来说。P是一个基本要求，CAP三者中，只能在CA两者之间做权衡，并且要想尽办法提升P。</p><h2 id="CP-without-A"><a href="#CP-without-A" class="headerlink" title="CP without A"></a>CP without A</h2><p>如果一个分布式系统不要求强的可用性，即容许系统停机或者长时间无响应的话，就可以在CAP三者中保障CP而舍弃A。</p><p>一个保证了CP而一个舍弃了A的分布式系统，一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验，等待所有数据全部一致了之后再让用户访问系统。</p><p>设计成CP的系统其实也不少，其中最典型的就是很多分布式数据库，他们都是设计成CP的。在发生极端情况时，优先保证数据的强一致性，代价就是舍弃系统的可用性。如Redis、HBase等，还有分布式系统中常用的Zookeeper也是在CAP三者之中选择优先保证CP的。</p><p>无论是像Redis、HBase这种分布式存储系统，还是像Zookeeper这种分布式协调组件。数据的一致性是他们最最基本的要求。一个连数据一致性都保证不了的分布式存储要他有何用？</p><blockquote><p>ZooKeeper是个CP（一致性+分区容错性）的，即任何时刻对ZooKeeper的访问请求能得到一致的数据结果，同时系统对网络分割具备容错性。但是它不能保证每次服务请求的可用性，也就是在极端环境下，ZooKeeper可能会丢弃一些请求，消费者程序需要重新请求才能获得结果。ZooKeeper是分布式协调服务，它的职责是保证数据在其管辖下的所有服务之间保持同步、一致。所以就不难理解为什么ZooKeeper被设计成CP而不是AP特性的了。</p></blockquote><h2 id="AP-wihtout-C"><a href="#AP-wihtout-C" class="headerlink" title="AP wihtout C"></a>AP wihtout C</h2><p>要高可用并允许分区，则需放弃一致性。一旦网络问题发生，节点之间可能会失去联系。为了保证高可用，需要在用户访问时可以马上得到返回，则每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。</p><p>这种舍弃强一致性而保证系统的分区容错性和可用性的场景和案例非常多。前面我们介绍可用性的时候说到过，很多系统在可用性方面会做很多事情来保证系统的全年可用性可以达到N个9，所以，对于很多业务系统来说，比如淘宝的购物，12306的买票。都是在可用性和一致性之间舍弃了一致性而选择可用性。</p><p>你在12306买票的时候肯定遇到过这种场景，当你购买的时候提示你是有票的（但是可能实际已经没票了），你也正常的去输入验证码，下单了。但是过了一会系统提示你下单失败，余票不足。这其实就是先在可用性方面保证系统可以正常的服务，然后在数据的一致性方面做了些牺牲，会影响一些用户体验，但是也不至于造成用户流程的严重阻塞。</p><p>但是，我们说很多网站牺牲了一致性，选择了可用性，这其实也不准确的。就比如上面的买票的例子，其实舍弃的只是强一致性。退而求其次保证了最终一致性。也就是说，虽然下单的瞬间，关于车票的库存可能存在数据不一致的情况，但是过了一段时间，还是要保证最终一致性的。</p><p>对于多数大型互联网应用的场景，主机众多、部署分散，而且现在的集群规模越来越大，所以节点故障、网络故障是常态，而且要保证服务可用性达到N个9，即保证P和A，舍弃C（退而求其次保证最终一致性）。虽然某些地方会影响客户体验，但没达到造成用户流程的严重程度。</p><h2 id="适合的才是最好的"><a href="#适合的才是最好的" class="headerlink" title="适合的才是最好的"></a>适合的才是最好的</h2><p>上面介绍了如何CAP中权衡及取舍以及典型的案例。孰优孰略，没有定论，只能根据场景定夺，适合的才是最好的。</p><p>对于涉及到钱财这样不能有一丝让步的场景，C必须保证。网络发生故障宁可停止服务，这是保证CP，舍弃A。比如前几年支付宝光缆被挖断的事件，在网络出现故障的时候，支付宝就在可用性和数据一致性之间选择了数据一致性，用户感受到的是支付宝系统长时间宕机，但是其实背后是无数的工程师在恢复数据，保证数数据的一致性。</p><p>对于其他场景，比较普遍的做法是选择可用性和分区容错性，舍弃强一致性，退而求其次使用最终一致性来保证数据的安全。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>无论你是一个架构师，还是一个普通开发，在设计或开发分布式系统的时候，不可避免的要在CAP中做权衡。需要根据自己的系统的实际情况，选择最适合自己的方案。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="CAP" scheme="https://www.sakuratears.top/tags/CAP/"/>
    
      <category term="分布式" scheme="https://www.sakuratears.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JVM堆内存及垃圾回收简介</title>
    <link href="https://www.sakuratears.top/blog/JVM%E5%A0%86%E5%86%85%E5%AD%98%E5%8F%8A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%80%E4%BB%8B.html"/>
    <id>https://www.sakuratears.top/blog/JVM堆内存及垃圾回收简介.html</id>
    <published>2019-06-27T13:48:00.000Z</published>
    <updated>2019-06-27T14:10:50.304Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们知道在JVM内存模型中，堆是十分重要的一块，堆是内存占用最大，管理最复杂的一个区域，其用途就是存放生成的对象实例，所有的对象都会在堆上进行分配使用。</p><p>JDK1.8后，字符串常量池从永久代剥离了出来，也存放在了堆上。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="堆内存结构"><a href="#堆内存结构" class="headerlink" title="堆内存结构"></a>堆内存结构</h2><p>我们来看一下堆内存结构，JDK1.8后JVM堆内存结构如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-420.png" alt="upload successful"></p><p>可以看到堆内存分为年轻代（Young Generation）、年老代（Old Generation）及元空间（MetaData Space）。</p><p>PS:JDK8 完全移除永久代(Permanent Generation), 取而代之的是元空间MetaData Space（JVM使用本地内存，存放类的元数据）。</p><p>年轻代（Young Generation）又分为 Eden Space 和 Survivor Space，其中Survivor区有两部分构成 Survivor 1 和 Survivor 2 。</p><p>JVM虚拟机默认Eden区和两块Survivor区的内存比例为8:1:1。</p><h2 id="GC流程"><a href="#GC流程" class="headerlink" title="GC流程"></a>GC流程</h2><p>年轻代内存的大致使用过程为：</p><pre><code>年轻代将内存分为Eden和2块Survivor区（分别叫from和to）。一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。经过Minor GC之后，如果Survivor存放不下存活的对象，对象就会通过分配担保机制进入老年代，而如果老年代空间还不够，就会进行Full GC。Minor GC会一直重复这样的过程，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</code></pre><p>因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。</p><p>因此对象进入年老代有以下4种情况：</p><ul><li><p>经过Minor GC后，Survivor区存放不下存活的对象进入年老代。</p></li><li><p>对象长期存活，当年龄达到一定阈值后进入年老代，默认15。年龄阈值，可以通过-XX:MaxTenuringThreshold来设置。</p></li><li><p>大对象直接进入年老代，通过 -XX:PretenureSizeThreshold 参数可以进行设置多大的对象直接在年老代进行分配，从而避免大对象在年轻代（Eden和Survivor区）发生大量内存赋值操作。</p></li><li><p>如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。（动态对象年龄绑定）</p></li></ul><p>GC的大致回收流程如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-421.png" alt="upload successful"></p><p>GC的回收分为垃圾的收集和回收两部分，收集和回收都涉及到一些算法逻辑，我们来整理下。</p><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p>JVM中常用的垃圾收集算法大致有两种，引用计数法和根搜索法。</p><ol><li><p>引用计数法</p><p> 引用计数法本质是给对象添加引用计数器，当引用对象时计数器+1，引用失效时，计数器-1，当计数器等于0时，对象失效，内存可以被回收。</p><p> 但会有一个问题，如果A对象引用B对象，同时B对象又引用A对象，但它们都不会再被系统使用，则它们可认为为垃圾，但是它们的引用计数是永不为0的，因此该方法永远也不会将其标位垃圾。</p><p> 优点：实现简单高效。</p><p> 缺点：对象之间的互相循环引用问题不好解决。</p></li><li><p>根搜索法</p><p> 通过GC roots可达的对象路径称为引用链（reference chain），当一个对象没有引用链时（即从GC roots不可达）则视为不可用对象，内存可以被回收。</p><p> JVM主要使用根搜索法进行垃圾收集。</p><p> 那在JVM中，哪些对象可以视为GC roots呢？</p><ul><li><p>虚拟机栈中（即栈帧中的本地变量）的引用对象；</p></li><li><p>本地方法栈中的引用对象；</p></li><li><p>方法区中的静态变量引用的对象和常量池中引用的对象。</p></li></ul></li></ol><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><ol><li><p>标记-清除算法</p><p> 分两步进行，第一步标记出可以回收的对象，第二步统一清理可以回收的对象内存。</p><p> 缺点：如果在被标记后直接对对象进行清除，会带来另一个新的问题——内存碎片化。如果下次有比较大的对象实例需要在堆上分配较大的内存空间时，可能会出现无法找到足够的连续内存而不得不再次触发垃圾回收。</p></li><li><p>复制算法</p><p> 此GC算法实际上解决了标记-清除算法带来的“内存碎片化”问题。首先还是先标记处待回收内存和不用回收的内存，下一步将不用回收的内存复制到新的内存区域，这样旧的内存区域就可以全部回收，而新的内存区域则是连续的。</p><p> 缺点：就是会损失掉部分系统内存，因为你总要腾出一部分内存用于复制。</p></li><li><p>标记-整理算法</p><p> 标记-压缩算法首先还是“标记”，标记过后，将不用回收的内存对象压缩到内存一端，此时即可直接清除边界处的内存，这样就能避免复制算法带来的效率问题，同时也能避免内存碎片化的问题。</p></li><li><p>分代收集算法</p><p> 对于JVM堆内存的垃圾回收，可以认为是分代收集算法。</p><p> 对于年轻代，大部分对象都不会存活，所以在新生代中使用复制算法较为高效。</p><p> 而对于年老代来讲，大部分对象可能会继续存活下去，如果此时还是利用复制算法，效率则会降低，此时使用标记-整理算法，不仅提高效率，更节约内存。</p></li></ol><p>当然，具体使用哪种垃圾回收算法，也和垃圾收集器的实现有具体关系。</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>再来看一下JVM的几种垃圾收集器。</p><p>目前JVM有7种作用于不同分代的垃圾收集器。如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-422.png" alt="upload successful"></p><p>上图两个垃圾收集器之间的连线表示它们可以搭配使用。</p><ol><li><p>Serial收集器</p><p>Serial收集器是最基本、发展历史最悠久的收集器。是单线程的收集器。它在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集完成。</p><p>Serial收集器依然是虚拟机运行在Client模式下默认新生代（年轻代）收集器，对于运行在Client模式下的虚拟机来说是一个很好的选择。</p></li><li><p>ParNew收集器</p><p>ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与Serial 收集器完全一样。</p><p>ParNew收集器是许多运行在Server模式下的虚拟机中首选新生代收集器，其中有一个与性能无关但很重要的原因是，除Serial收集器之外，目前只有ParNew它能与CMS收集器配合工作。</p></li><li><p>Parallel Scavenge（并行回收）收集器</p><p>Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器。</p><p>该收集器的目标是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即 吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）。</p><p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可用高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p><p>Parallel Scavenge收集器提供两个参数用于精确控制吞吐量，分别是控制最大垃圾收起停顿时间的 -XX:MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX:GCTimeRatio参数</p><p>Parallel Scavenge收集器还有一个参数：-XX:+UseAdaptiveSizePolicy。这是一个开关参数，当这个参数打开后，就不需要手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数，只需要把基本的内存数据设置好（如-Xmx设置最大堆），然后使用MaxGVPauseMillis参数或GCTimeRation参数给虚拟机设立一个优化目标。</p><p>自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别。</p></li><li><p>Serial Old 收集器</p><p>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记整理算法。这个收集器的主要意义也是在于给Client模式下的虚拟机使用。</p><p>如果在Server模式下，主要两大用途：</p><p>  （1）在JDK1.5以及之前的版本中与Parallel Scavenge收集器搭配使用。</p><p>  （2）作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。</p></li><li><p>Parallel Old 收集器</p><p> Parallel Old 是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。这个收集器在1.6中才开始提供。</p></li><li><p>CMS收集器</p><p>CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务器的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。</p><p>CMS收集器是基于“标记-清除”算法实现的。它的运作过程相对前面几种收集器来说更复杂一些，整个过程分为4个步骤：</p><p>  （1）初始标记</p><p>  （2）并发标记</p><p>  （3）重新标记</p><p>  （4）并发清除</p><p>其中，初始标记、重新标记这两个步骤仍然需要“Stop The World”.</p><p>CMS收集器主要优点：并发收集，低停顿。</p><p>CMS三个明显的缺点：</p><p>  （1）CMS收集器对CPU资源非常敏感。CPU个数少于4个时，CMS对于用户程序的影响就可能变得很大，为了应付这种情况，虚拟机提供了一种称为“增量式并发收集器”的CMS收集器变种。所做的事情和单CPU年代PC机操作系统使用抢占式来模拟多任务机制的思想。</p><p>  （2）CMS收集器无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。在JDK1.5的默认设置下，CMS收集器当老年代使用了68%的空间后就会被激活，这是一个偏保守的设置，如果在应用中老年代增长不是太快，可以适当调高参数-XX:CMSInitiatingOccupancyFraction的值来提高触发百分比，以便降低内存回收次数从而获取更好的性能，在JDK1.6中，CMS收集器的启动阀值已经提升至92%。</p><p>  （3）CMS是基于“标记-清除”算法实现的收集器，收集结束时会有大量空间碎片产生。空间碎片过多，可能会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发FullGC。为了解决这个问题，CMS收集器提供了一个-XX:+UseCMSCompactAtFullCollection开关参数（默认就是开启的），用于在CMS收集器顶不住要进行FullGC时开启内存碎片合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间变长了。虚拟机设计者还提供了另外一个参数-XX:CMSFullGCsBeforeCompaction,这个参数是用于设置执行多少次不压缩的Full GC后，跟着来一次带压缩的Full GC（默认值为0，表示每次进入Full GC时都进行碎片整理）。</p></li><li><p>G1收集器</p><p>G1收集器的优势：</p><p> （1）并行与并发</p><p> （2）分代收集</p><p> （3）空间整理 （标记——整理算法，复制算法）</p><p> （4）可预测的停顿（G1除处理追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经实现Java（RTSJ）的垃圾收集器的特征）</p><p> 备注：</p><blockquote><p> The Real-time Specification for Java (RTSJ) is an open specification that augments the Java language to open the door more widely to using the language to build real-time systems (see Related topics). Implementing the RTSJ requires support in the operating system, the JRE, and the Java Class Library (JCL).</p></blockquote><p> 详见：<a href="https://www.ibm.com/developerworks/library/j-rtj1/index.html" rel="external nofollow noopener noreferrer" target="_blank">RTSJ</a> 中的Garbage collection的规范。</p><p>使用G1收集器时，Java堆的内存布局是整个规划为多个大小相等的独立区域（Region）,虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region的集合。</p><p> G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获取的空间大小以及回收所需要的时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（这也就是Garbage-First名称的又来）。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽量可能高的收集效率。</p><p> G1 内存“化整为零”的思路：</p><p> 在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会遗漏。</p><p> 如果不计算维护Remembered Set的操作，G1收集器的运作大致可划分为一下步骤：</p><p>（1）初始标记</p><p>（2）并发标记</p><p>（3）最终标记</p><p>（4）筛选回收</p></li></ol><p>参考：<a href="https://www.cnblogs.com/chengxuyuanzhilu/p/7088316.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/chengxuyuanzhilu/p/7088316.html</a></p><h2 id="JVM的一些参数"><a href="#JVM的一些参数" class="headerlink" title="JVM的一些参数"></a>JVM的一些参数</h2><p>我们再来看下JVM的一些常用参数设置。</p><h3 id="JVM的基础参数"><a href="#JVM的基础参数" class="headerlink" title="JVM的基础参数"></a>JVM的基础参数</h3><ul><li>-Xmx2048m：设置JVM最大堆内存为2048M。</li><li>-Xms2048m：设置JVM初始堆内存为2048M。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。</li><li>-Xss128k：设置每个线程的栈大小。JDK5.0以后每个线程栈大小为1M，之前每个线程栈大小为256K。应当根据应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。需要注意的是：当这个值被设置的较大（例如&gt;2MB）时将会在很大程度上降低系统的性能。</li><li>-Xmn1g：设置年轻代大小为1G。在整个堆内存大小确定的情况下，增大年轻代将会减小年老代，反之亦然。此值关系到JVM垃圾回收，对系统性能影响较大，官方推荐配置为整个堆大小的3/8。</li><li>-XX:NewSize=1024m：设置年轻代初始值为1024M。</li><li>-XX:MaxNewSize=1024m：设置年轻代最大值为1024M。</li><li>-XX:PermSize=256m：设置持久代初始值为256M。（1.7以下JDK版本有效）</li><li>-XX:MaxPermSize=256m：设置持久代最大值为256M。（1.7以下JDK版本有效）</li><li>-XX:MetaspaceSize=8m：初始元数据空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。（1.7以上JDK版本有效）</li><li>-XX:MaxMetaspaceSize=50m：元数据最大空间大小，默认是没有限制的。（1.7以上JDK版本有效）</li><li>-XX:NewRatio=4：设置年轻代（包括1个Eden和2个Survivor区）与年老代的比值。表示年轻代比年老代为1:4。</li><li>-XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的比值。表示2个Survivor区与1个Eden区的比值为2:4，即1个Survivor区占整个年轻代大小的1/6。</li><li>-XX:MaxTenuringThreshold=7：表示一个对象如果在Survivor区（救助空间）移动了7次还没有被垃圾回收就进入年老代。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代，对于需要大量常驻内存的应用，这样做可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象在年轻代存活时间，增加对象在年轻代被垃圾回收的概率，减少Full GC的频率，这样做可以在某种程度上提高服务稳定性。</li><li>-XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集。（1.7以上JDK版本有效）</li><li>-XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集。（1.7以上JDK版本有效）</li></ul><p>PS:可以看到-Xmn，-XX:NewSize/-XX:MaxNewSize，-XX:NewRatio 3组参数都可以影响年轻代的大小，它们混合使用生效的优先级为：</p><pre><code>高优先级：-XX:NewSize/-XX:MaxNewSize 中优先级：-Xmn（默认等效  -Xmn=-XX:NewSize=-XX:MaxNewSize=?） 低优先级：-XX:NewRatio </code></pre><p>推荐使用-Xmn参数。</p><h3 id="JVM垃圾回收参数"><a href="#JVM垃圾回收参数" class="headerlink" title="JVM垃圾回收参数"></a>JVM垃圾回收参数</h3><ul><li>-XX:+UseSerialGC：设置串行收集器。</li><li>-XX:+UseParallelGC：设置为并行收集器。此配置仅对年轻代有效。即年轻代使用并行收集，而年老代仍使用串行收集。</li><li>-XX:ParallelGCThreads=20：配置并行收集器的线程数，即：同时有多少个线程一起进行垃圾回收。此值建议配置与CPU数目相等。</li><li>-XX:+UseParallelOldGC：配置年老代垃圾收集方式为并行收集。JDK6.0开始支持对年老代并行收集。</li><li>-XX:MaxGCPauseMillis=100：设置每次年轻代垃圾回收的最长时间（单位毫秒）。如果无法满足此时间，JVM会自动调整年轻代大小，以满足此时间。</li><li>-XX:+UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动调整年轻代Eden区大小和Survivor区大小的比例，以达成目标系统规定的最低响应时间或者收集频率等指标。此参数建议在使用并行收集器时，一直打开。</li><li>-XX:+UseConcMarkSweepGC：即CMS收集，设置年老代为并发收集。CMS收集是JDK1.4后期版本开始引入的新GC算法。它的主要适合场景是对响应时间的重要性需求大于对吞吐量的需求，能够承受垃圾回收线程和应用线程共享CPU资源，并且应用中存在比较多的长生命周期对象。CMS收集的目标是尽量减少应用的暂停时间，减少Full GC发生的几率，利用和应用程序线程并发的垃圾回收线程来标记清除年老代内存。</li><li>-XX:+UseParNewGC：设置年轻代为并发收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此参数。</li><li>-XX:CMSFullGCsBeforeCompaction=0：由于并发收集器不对内存空间进行压缩和整理，所以运行一段时间并行收集以后会产生内存碎片，内存使用效率降低。此参数设置运行0次Full GC后对内存空间进行压缩和整理，即每次Full GC后立刻开始压缩和整理内存。</li><li>-XX:+UseCMSCompactAtFullCollection：打开内存空间的压缩和整理，在Full GC后执行。可能会影响性能，但可以消除内存碎片。</li><li>-XX:+CMSIncrementalMode：设置为增量收集模式。一般适用于单CPU情况。</li><li>-XX:CMSInitiatingOccupancyFraction=70：表示年老代内存空间使用到70%时就开始执行CMS收集，以确保年老代有足够的空间接纳来自年轻代的对象，避免Full GC的发生。</li><li>-XX:+ScavengeBeforeFullGC：年轻代GC优于Full GC执行。</li><li>-XX:+DisableExplicitGC：不响应 System.gc() 代码。</li><li>-XX:+UseThreadPriorities：启用本地线程优先级API。即使 java.lang.Thread.setPriority() 生效，不启用则无效。</li><li>-XX:SoftRefLRUPolicyMSPerMB=0：软引用对象在最后一次被访问后能存活0毫秒（JVM默认为1000毫秒）。</li><li>-XX:TargetSurvivorRatio=90：允许90%的Survivor区被占用（JVM默认为50%）。提高对于Survivor区的使用率。</li><li>-XX:+UseG1GC: 设置使用G1垃圾回收器（1.7以上JDK版本有效）</li><li>-XX:G1HeapRegionSize=n:设置g1 region大小，不设置的话自己会根据堆大小算，目标是根据最小堆内存划分2048个区域（1.7以上JDK版本有效）</li></ul><h3 id="JVM其它参数"><a href="#JVM其它参数" class="headerlink" title="JVM其它参数"></a>JVM其它参数</h3><ul><li>-XX:+CITime：打印消耗在JIT编译的时间。</li><li>-XX:ErrorFile=./hs_err_pid.log：保存错误日志或数据到指定文件中。</li><li>-XX:HeapDumpPath=./java_pid.hprof：指定Dump堆内存时的路径。</li><li>-XX:+HeapDumpOnOutOfMemoryError：当首次遭遇内存溢出时Dump出此时的堆内存。</li><li>-XX:OnError=”;”：出现致命ERROR后运行自定义命令。</li><li>-XX:OnOutOfMemoryError=”;”：当首次遭遇内存溢出时执行自定义命令。</li><li>-XX:+PrintClassHistogram：按下 Ctrl+Break 后打印堆内存中类实例的柱状信息，同JDK的 jmap -histo 命令。</li><li>-XX:+PrintConcurrentLocks：按下 Ctrl+Break 后打印线程栈中并发锁的相关信息，同JDK的 jstack -l 命令。</li><li>-XX:+PrintCompilation：当一个方法被编译时打印相关信息。</li><li>-XX:+PrintGC：每次GC时打印相关信息。</li><li>-XX:+PrintGCDetails：每次GC时打印详细信息。</li><li>-XX:+PrintGCTimeStamps：打印每次GC的时间戳。</li><li>-XX:+TraceClassLoading：跟踪类的加载信息。</li><li>-XX:+TraceClassLoadingPreorder：跟踪被引用到的所有类的加载信息。</li><li>-XX:+TraceClassResolution：跟踪常量池。</li><li>-XX:+TraceClassUnloading：跟踪类的卸载信息。</li><li>-client：设置JVM使用Client模式，特点是启动速度比较快，但运行时性能和内存管理效率不高，通常用于客户端应用程序或开发调试；在32位环境下直接运行Java程序默认启用该模式。</li><li>-server：设置JVM使Server模式，特点是启动速度比较慢，但运行时性能和内存管理效率很高，适用于生产环境。在具有64位能力的JDK环境下默认启用该模式。</li></ul><p>PS：关于参数名称定义如下。</p><pre><code>标准参数（-），所有JVM都必须支持这些参数的功能，而且向后兼容；非标准参数（-X），默认JVM实现这些参数的功能，但是并不保证所有JVM实现都满足，且不保证向后兼容；非稳定参数（-XX），此类参数各个JVM实现会有所不同，将来可能会不被支持，需要慎重使用；</code></pre><p>参考：<a href="https://blog.csdn.net/kthq/article/details/8618052" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/kthq/article/details/8618052</a></p><h2 id="各个区域的OOM"><a href="#各个区域的OOM" class="headerlink" title="各个区域的OOM"></a>各个区域的OOM</h2><p>我们来看下JVM各个区域的OOM。</p><p><strong>堆的OOM</strong></p><p>我们创建如下类，进行测试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">oomTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">List&lt;JvmTest&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">list.add(<span class="keyword">new</span> JvmTest());</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;  </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> JvmTest().oomTest();</span><br><span class="line">&#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后可以看到抛出如下异常：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-423.png" alt="upload successful"></p><p>这也是非常常见的一种OOM异常。出现的原因可能是创建了大量大对象、一些流未及时关闭等，导致堆内存溢出。</p><p>出现这种情况，必须考虑程序的优化解决方法。而不是单纯的通过-Xmn参数增大内存来解决。</p><p><strong>栈的OOM</strong></p><p>当栈深度超过虚拟机分配给线程的栈大小时，就会出现栈的溢出异常。</p><p>我们创建测试类，来看一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">stackOverTest</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> stackOverTest(n-<span class="number">1</span>)+<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> JvmTest().stackOverTest(<span class="number">200000</span>);</span><br><span class="line">&#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后可以看到如下异常：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-424.png" alt="upload successful"></p><p>这种异常一般是调用递归或者死循环等产生的，导致栈深度超过虚拟机分配给线程的栈大小。</p><p>当然可以通过-Xss参数控制每个线程的栈大小来解决，但通常情况下，应检查程序，减少递归的使用。</p><p><strong>关于Metaspace与PermGen（永久代）</strong></p><p>JDK1.8移除了PermGen（永久代），取而代之的是Metaspace（元空间），元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。</p><p>我们在JDK1.8环境下，设置Metaspace的大小，进行测试。(-XX:MetaspaceSize=5M -XX:MaxMetaspaceSize=5M)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MetaSpaceOOMTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">enhancer.setSuperclass(JvmTest.class);</span><br><span class="line">enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">enhancer.setCallback(</span><br><span class="line"><span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="keyword">return</span> methodProxy.invokeSuper(o,objects);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line">enhancer.create();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> JvmTest().MetaSpaceOOMTest();</span><br><span class="line">&#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后可以看到如下异常：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-425.png" alt="upload successful"></p><p>这种问题出现较少，如果出现一般为动态代理生成大量class类引起的问题。</p><p>我们在JDK1.6环境下，设置PermGen（永久代）大小，进行测试。（-XX:PermSize=10m -XX:MaxPermSize=10m）</p><p>测试方法同上。</p><p>可以看到日志输出如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-426.png" alt="upload successful"></p><p>由于项目大多数JDK版本都在8及以上，故这种OOM异常已经很少在见到了。</p><h2 id="JVM-日志"><a href="#JVM-日志" class="headerlink" title="JVM 日志"></a>JVM 日志</h2><p>我们再来看下JVM的垃圾回收日志，并简单解读下。我们这儿主要来看新的JVM（1.8及其后）的GC日志。</p><p>我们在运行时添加如下参数： -XX:-PrintGCDetails</p><p>我们用上面的 JvmTest类里的oomTest方法来进行测试。</p><p>可以看到如下一些GC运行日志和OOM的dump日志。</p><p>我们先来看下GC的运行日志部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 207268K-&gt;200192K(339968K)] 879015K-&gt;879170K(1489408K), 0.8137540 secs] [Times: user=2.95 sys=0.06, real=0.81 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 339968K-&gt;243200K(339456K)] 1292739K-&gt;1292955K(1488896K), 0.8972164 secs] [Times: user=3.18 sys=0.20, real=0.90 secs] </span><br><span class="line">[Full GC (Ergonomics) [PSYoungGen: 243200K-&gt;0K(339456K)] [ParOldGen: 1049755K-&gt;1110054K(1722880K)] 1292955K-&gt;1110054K(2062336K), [Metaspace: 3502K-&gt;3502K(1056768K)], 7.8097561 secs] [Times: user=16.27 sys=0.19, real=7.81 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 96256K-&gt;96384K(424448K)] 1206310K-&gt;1206438K(2147328K), 0.3838048 secs] [Times: user=1.39 sys=0.05, real=0.38 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 192640K-&gt;192672K(425472K)] 1302694K-&gt;1302726K(2148352K), 0.6567791 secs] [Times: user=2.53 sys=0.00, real=0.66 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 303776K-&gt;303840K(430080K)] 1824520K-&gt;1824584K(2152960K), 1.1635894 secs] [Times: user=4.29 sys=0.00, real=1.16 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 414944K-&gt;347136K(496640K)] 1935688K-&gt;1935808K(2219520K), 1.6472200 secs] [Times: user=5.76 sys=0.19, real=1.65 secs] </span><br><span class="line">[Full GC (Ergonomics) [PSYoungGen: 347136K-&gt;0K(496640K)] [ParOldGen: 1588672K-&gt;1661667K(2083840K)] 1935808K-&gt;1661667K(2580480K), [Metaspace: 3502K-&gt;3502K(1056768K)], 10.5294207 secs] [Times: user=23.63 sys=0.09, real=10.53 secs]</span><br></pre></td></tr></table></figure><ul><li><p>(Allocation Failure)：Allocation Failure表示向young generation(eden)给新对象申请空间，但是young generation(eden)剩余的合适空间不够所需的大小导致的GC。</p></li><li><p>[PSYoungGen: 207268K-&gt;200192K(339968K)] 879015K-&gt;879170K(1489408K), 0.8137540 secs] 这段分别表示 [年轻代: GC前内存容量 -&gt; GC后内存容量 (年轻代总容量)] GC前堆内存大小 -&gt; GC后堆内存大小(堆内存总大小),该内存区域GC耗时（与Times的real相等），单位是秒。</p></li><li><p>[Times: user=2.95 sys=0.06, real=0.81 secs] 这段分别表示用户态耗时，内核态耗时和总耗时。</p></li><li><p>Full GC (Ergonomics) 表明该次发生了Full GC，Ergonomics就是Full GC的原因，可以认为如果晋升到老生代的平均大小大于老生代的剩余大小，则认为需要一次full gc。某些垃圾回收器会负责自动的调解gc暂停时间和吞吐量之间的平衡，然后JVM虚拟机性能更好，因而会出现这种Full GC原因。</p></li><li><p>ParOldGen部分表示年老代的相关GC信息。</p></li><li><p>Metaspace部分表示元空间的相关GC信息。</p></li></ul><p>我们在GC相关源码(openjdk源码中gcCause.cpp文件)中还可以看到多种GC原因，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"precompiled.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"gc/shared/gcCause.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* GCCause::to_string(GCCause::Cause cause) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (cause) &#123;</span><br><span class="line">    <span class="keyword">case</span> _java_lang_system_gc:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"System.gc()"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _full_gc_alot:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"FullGCAlot"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _scavenge_alot:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"ScavengeAlot"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _allocation_profiler:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Allocation Profiler"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _jvmti_force_gc:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"JvmtiEnv ForceGarbageCollection"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _gc_locker:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"GCLocker Initiated GC"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _heap_inspection:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Heap Inspection Initiated GC"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _heap_dump:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Heap Dump Initiated GC"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _wb_young_gc:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"WhiteBox Initiated Young GC"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _wb_conc_mark:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"WhiteBox Initiated Concurrent Mark"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _wb_full_gc:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"WhiteBox Initiated Full GC"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _update_allocation_context_stats_inc:</span><br><span class="line">    <span class="keyword">case</span> _update_allocation_context_stats_full:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Update Allocation Context Stats"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _no_gc:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"No GC"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _allocation_failure:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Allocation Failure"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _tenured_generation_full:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Tenured Generation Full"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _metadata_GC_threshold:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Metadata GC Threshold"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _metadata_GC_clear_soft_refs:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Metadata GC Clear Soft References"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _cms_generation_full:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"CMS Generation Full"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _cms_initial_mark:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"CMS Initial Mark"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _cms_final_remark:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"CMS Final Remark"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _cms_concurrent_mark:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"CMS Concurrent Mark"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _old_generation_expanded_on_last_scavenge:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Old Generation Expanded On Last Scavenge"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _old_generation_too_full_to_scavenge:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Old Generation Too Full To Scavenge"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _adaptive_size_policy:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Ergonomics"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _g1_inc_collection_pause:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"G1 Evacuation Pause"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _g1_humongous_allocation:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"G1 Humongous Allocation"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _dcmd_gc_run:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Diagnostic Command"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _last_gc_cause:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"ILLEGAL VALUE - last gc cause - ILLEGAL VALUE"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"unknown GCCause"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ShouldNotReachHere();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这儿就不在对上面的所有GC情况做详细介绍了，有兴趣的同学可以查阅相关资料了解。</p><p>gcCause相关资料：</p><ul><li><a href="http://hg.openjdk.java.net/jdk8u/hs-dev/hotspot/file/tip/src/share/vm/gc_interface/gcCause.cpp" rel="external nofollow noopener noreferrer" target="_blank">openjdk-gcCause.cpp</a></li><li><a href="http://netflix.github.io/spectator/en/latest/ext/jvm-gc-causes/" rel="external nofollow noopener noreferrer" target="_blank">jvm-gcCause-info</a></li></ul><p>我们再来看下出现OOM后GC的dump日志部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 584192K, used 10301K [0x0000000780700000, 0x00000007ba880000, 0x00000007c0000000)</span><br><span class="line">  eden space 257536K, 3% used [0x0000000780700000,0x000000078110f510,0x0000000790280000)</span><br><span class="line">  from space 326656K, 0% used [0x00000007a6980000,0x00000007a6980000,0x00000007ba880000)</span><br><span class="line">  to   space 347136K, 0% used [0x0000000790280000,0x0000000790280000,0x00000007a5580000)</span><br><span class="line"> ParOldGen       total 2083840K, used 2054113K [0x0000000701400000, 0x0000000780700000, 0x0000000780700000)</span><br><span class="line">  object space 2083840K, 98% used [0x0000000701400000,0x000000077e9f8790,0x0000000780700000)</span><br><span class="line"> Metaspace       used 3535K, capacity 4506K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 392K, capacity 394K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure><p>它们打印的JVM终止时Heap（堆内存）的信息，从该日志中我们能分析出JVM终止的一些原因。</p><p>可以看到PSYoungGen（年轻代） eden区使用了3%，（两个Survivor）from和to区使用了0%，ParOldGen（年老代） object space（对象区）使用了98%，Metaspace（元空间） class space（类加载区）的使用情况。</p><p>因此明显由于创建了大量对象，一直存在，无法被垃圾回收，导致内存空间用尽，出现OOM异常。</p><h2 id="JVM监控Demo"><a href="#JVM监控Demo" class="headerlink" title="JVM监控Demo"></a>JVM监控Demo</h2><p>现在有许多JVM监控工具，如JConsole、Java VisualVM等，我们这里不过多介绍。</p><p>我们自写一个监控Demo来看下JVM在内存使用过程中的一些变化特点。</p><p>来看下<code>java.lang.management</code>包下的一些类。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-427.png" alt="upload successful"></p><ul><li>MemoryMXBean ： 它里面有两个方法 <code>getHeapMemoryUsage</code> （获取堆内存使用情况）和<code>getNonHeapMemoryUsage</code>（获取非堆内存使用情况），返回<code>MemoryUsage</code>对象。</li><li>MemoryUsage：包含<code>init</code>（初始化了多少内存）、<code>used</code>（使用了多少内存）、<code>committed</code>（申请了多少内存）、<code>max</code>（最大内存）信息。</li><li>MemoryPoolMXBean：这里包含young（eden和survivor）、old等内存区的使用情况，我们可以通过 <code>ManagementFactory.getMemoryPoolMXBeans()</code> 获取到一个 <code>MemoryPoolMXBean</code> 列表，<code>MemoryPoolMXBean</code>里还有一个<code>getName</code>方法可以获得当前区域的名称。</li><li>GarbageCollectorMXBean：这个是垃圾收集相关的Bean，可以通过<code>ManagementFactory.getGarbageCollectorMXBeans()</code>获取其列表。其<code>getName</code>方法可以获得垃圾收集器的名称，<code>getCollectionCount</code>可以获得当前已经进行了多少次垃圾收集，<code>getCollectionTime</code>返回垃圾收集时间。</li></ul><p>我们写一个测试类来看一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JVMMonitorMemoryTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定时任务线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ScheduledExecutorService executorService = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> ScheduledFuture future = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> JvmTest jvmTest = <span class="keyword">new</span> JvmTest();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doMonitor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        future = executorService.scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="line">            JSONObject jsonObject = <span class="keyword">new</span> JSONObject();</span><br><span class="line">            MemoryMXBean memoryMXBean = ManagementFactory.getMemoryMXBean();</span><br><span class="line">            jsonObject.put(<span class="string">"totalMaxMemery"</span>, memoryMXBean.getHeapMemoryUsage().getMax()&gt;&gt;<span class="number">10</span>&gt;&gt;<span class="number">10</span>);</span><br><span class="line">            jsonObject.put(<span class="string">"totalUsedMemery"</span>, memoryMXBean.getHeapMemoryUsage().getUsed()&gt;&gt;<span class="number">10</span>&gt;&gt;<span class="number">10</span>);</span><br><span class="line">            jsonObject.put(<span class="string">"totalInitMemery"</span>, memoryMXBean.getHeapMemoryUsage().getInit()&gt;&gt;<span class="number">10</span>&gt;&gt;<span class="number">10</span>);</span><br><span class="line">            <span class="comment">//这里会返回老年代，新生代等内存区的使用情况</span></span><br><span class="line">            List&lt;MemoryPoolMXBean&gt; memoryPoolMXBeans = ManagementFactory.getMemoryPoolMXBeans();</span><br><span class="line">            memoryPoolMXBeans.forEach((pool) -&gt; &#123;</span><br><span class="line">                String poolName = pool.getName().trim();</span><br><span class="line">                <span class="keyword">long</span> max = pool.getUsage().getMax()&gt;&gt;<span class="number">10</span>&gt;&gt;<span class="number">10</span>;</span><br><span class="line">                <span class="keyword">long</span> used = pool.getUsage().getUsed()&gt;&gt;<span class="number">10</span>&gt;&gt;<span class="number">10</span>;</span><br><span class="line">                <span class="keyword">long</span> init = pool.getUsage().getInit()&gt;&gt;<span class="number">10</span>&gt;&gt;<span class="number">10</span>;</span><br><span class="line">                <span class="keyword">long</span> maxPeak = pool.getPeakUsage().getMax()&gt;&gt;<span class="number">10</span>&gt;&gt;<span class="number">10</span>;</span><br><span class="line">                <span class="keyword">long</span> usedPeak = pool.getPeakUsage().getUsed()&gt;&gt;<span class="number">10</span>&gt;&gt;<span class="number">10</span>;</span><br><span class="line">                <span class="keyword">long</span> initPeak = pool.getPeakUsage().getInit()&gt;&gt;<span class="number">10</span>&gt;&gt;<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">                JSONObject poolJSON = <span class="keyword">new</span> JSONObject();</span><br><span class="line">                poolJSON.put(<span class="string">"max"</span>, max);</span><br><span class="line">                poolJSON.put(<span class="string">"used"</span>, used);</span><br><span class="line">                poolJSON.put(<span class="string">"init"</span>, init);</span><br><span class="line">                poolJSON.put(<span class="string">"maxPeak"</span>, maxPeak);</span><br><span class="line">                poolJSON.put(<span class="string">"usedPeak"</span>, usedPeak);</span><br><span class="line">                poolJSON.put(<span class="string">"initPeak"</span>, initPeak);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(<span class="string">"PS Eden Space"</span>.equalsIgnoreCase(poolName))&#123;</span><br><span class="line">                    jsonObject.put(<span class="string">"eden"</span>, poolJSON);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"PS Survivor Space"</span>.equalsIgnoreCase(poolName))&#123;</span><br><span class="line">                    jsonObject.put(<span class="string">"survivor"</span>, poolJSON);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"PS Old Gen"</span>.equalsIgnoreCase(poolName))&#123;</span><br><span class="line">                    jsonObject.put(<span class="string">"old"</span>, poolJSON);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"Metaspace"</span>.equalsIgnoreCase(poolName))&#123;</span><br><span class="line">                    jsonObject.put(<span class="string">"metaspace"</span>,poolJSON);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//垃圾收集相关</span></span><br><span class="line">            List&lt;GarbageCollectorMXBean&gt; garbageCollectorMXBeans = ManagementFactory.getGarbageCollectorMXBeans();</span><br><span class="line">            garbageCollectorMXBeans.forEach(collector -&gt; &#123;</span><br><span class="line">                String gcName = collector.getName();</span><br><span class="line">                <span class="keyword">long</span> gcCount = collector.getCollectionCount();</span><br><span class="line">                <span class="keyword">long</span> gcTime = collector.getCollectionTime();</span><br><span class="line">                JSONObject gcJSON = <span class="keyword">new</span> JSONObject();</span><br><span class="line">                gcJSON.put(<span class="string">"gcCount"</span>, gcCount);</span><br><span class="line">                gcJSON.put(<span class="string">"gcTime"</span>, gcTime);</span><br><span class="line">                <span class="keyword">if</span>(gcName.toLowerCase().contains(<span class="string">"scavenge"</span>))&#123;</span><br><span class="line">                    jsonObject.put(<span class="string">"edenGc"</span>, gcJSON);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(gcName.toLowerCase().contains(<span class="string">"marksweep"</span>))&#123;</span><br><span class="line">                    jsonObject.put(<span class="string">"oldGc"</span>, gcJSON);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            System.out.println(JSON.toJSONString(jsonObject));</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用生成对象的方法</span></span><br><span class="line">        jvmTest.test();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JVMMonitorMemoryTest jvmMonitorMemoryTest = <span class="keyword">new</span> JVMMonitorMemoryTest();</span><br><span class="line">        jvmMonitorMemoryTest.doMonitor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个方法不停生产对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">List&lt;JvmTest&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">list.add(<span class="keyword">new</span> JvmTest());</span><br><span class="line"><span class="keyword">if</span>(list.size()&gt;<span class="number">10000</span>)&#123;</span><br><span class="line">list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们运行后可以看到相关输出信息，即JVM堆内存变化情况及垃圾收集情况。</p><p>数字数据不是很直观，我们结合Echart图表，动态展示JVM相关信息，因此我们把项目改造下，结合WebSocket来实现。</p><p>项目大致结构如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-428.png" alt="upload successful"></p><p>说一下里面的关键部分，MonitorJVMMemory.java（监控JVM内存变化类）和jvm-echart.js（Echart前端动态展示）。</p><p>MonitorJVMMemory相关代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ServerEndpoint</span>(<span class="string">"/websocket/jvm/monitor"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorJVMMemory</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(MonitorJVMMemory.class);</span><br><span class="line">    <span class="comment">//定时任务线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ScheduledExecutorService executorService = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> ScheduledFuture future = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> JvmTest jvmTest = <span class="keyword">new</span> JvmTest();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * websocket会话</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Session session;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.session = session;</span><br><span class="line">        future = executorService.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            JSONObject jsonObject = <span class="keyword">new</span> JSONObject();</span><br><span class="line">            MemoryMXBean memoryMXBean = ManagementFactory.getMemoryMXBean();</span><br><span class="line">            jsonObject.put(<span class="string">"totalMaxMemery"</span>, memoryMXBean.getHeapMemoryUsage().getMax() &gt;&gt; <span class="number">10</span> &gt;&gt; <span class="number">10</span>);</span><br><span class="line">            jsonObject.put(<span class="string">"totalUsedMemery"</span>, memoryMXBean.getHeapMemoryUsage().getUsed() &gt;&gt; <span class="number">10</span> &gt;&gt; <span class="number">10</span>);</span><br><span class="line">            jsonObject.put(<span class="string">"totalInitMemery"</span>, memoryMXBean.getHeapMemoryUsage().getInit() &gt;&gt; <span class="number">10</span> &gt;&gt; <span class="number">10</span>);</span><br><span class="line">            <span class="comment">//这里会返回老年代，新生代等内存区的使用情况，按需自取就好</span></span><br><span class="line">            List&lt;MemoryPoolMXBean&gt; memoryPoolMXBeans = ManagementFactory.getMemoryPoolMXBeans();</span><br><span class="line">            memoryPoolMXBeans.forEach((pool) -&gt; &#123;</span><br><span class="line">                String poolName = pool.getName().trim();</span><br><span class="line">                <span class="keyword">long</span> max = pool.getUsage().getMax() &gt;&gt; <span class="number">10</span> &gt;&gt; <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">long</span> used = pool.getUsage().getUsed() &gt;&gt; <span class="number">10</span> &gt;&gt; <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">long</span> init = pool.getUsage().getInit() &gt;&gt; <span class="number">10</span> &gt;&gt; <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">long</span> maxPeak = pool.getPeakUsage().getMax() &gt;&gt; <span class="number">10</span> &gt;&gt; <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">long</span> usedPeak = pool.getPeakUsage().getUsed() &gt;&gt; <span class="number">10</span> &gt;&gt; <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">long</span> initPeak = pool.getPeakUsage().getInit() &gt;&gt; <span class="number">10</span> &gt;&gt; <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">                JSONObject poolJSON = <span class="keyword">new</span> JSONObject();</span><br><span class="line">                poolJSON.put(<span class="string">"max"</span>, max);</span><br><span class="line">                poolJSON.put(<span class="string">"used"</span>, used);</span><br><span class="line">                poolJSON.put(<span class="string">"init"</span>, init);</span><br><span class="line">                poolJSON.put(<span class="string">"maxPeak"</span>, maxPeak);</span><br><span class="line">                poolJSON.put(<span class="string">"usedPeak"</span>, usedPeak);</span><br><span class="line">                poolJSON.put(<span class="string">"initPeak"</span>, initPeak);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"PS Eden Space"</span>.equalsIgnoreCase(poolName)) &#123;</span><br><span class="line">                    jsonObject.put(<span class="string">"eden"</span>, poolJSON);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"PS Survivor Space"</span>.equalsIgnoreCase(poolName)) &#123;</span><br><span class="line">                    jsonObject.put(<span class="string">"survivor"</span>, poolJSON);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"PS Old Gen"</span>.equalsIgnoreCase(poolName)) &#123;</span><br><span class="line">                    jsonObject.put(<span class="string">"old"</span>, poolJSON);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//垃圾收集</span></span><br><span class="line">            List&lt;GarbageCollectorMXBean&gt; garbageCollectorMXBeans = ManagementFactory.getGarbageCollectorMXBeans();</span><br><span class="line">            garbageCollectorMXBeans.forEach(collector -&gt; &#123;</span><br><span class="line">                String gcName = collector.getName();</span><br><span class="line">                <span class="keyword">long</span> gcCount = collector.getCollectionCount();</span><br><span class="line">                <span class="keyword">long</span> gcTime = collector.getCollectionTime();</span><br><span class="line">                JSONObject gcJSON = <span class="keyword">new</span> JSONObject();</span><br><span class="line">                gcJSON.put(<span class="string">"gcCount"</span>, gcCount);</span><br><span class="line">                gcJSON.put(<span class="string">"gcTime"</span>, gcTime);</span><br><span class="line">                <span class="keyword">if</span> (gcName.toLowerCase().contains(<span class="string">"scavenge"</span>)) &#123;</span><br><span class="line">                    jsonObject.put(<span class="string">"edenGc"</span>, gcJSON);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (gcName.toLowerCase().contains(<span class="string">"marksweep"</span>)) &#123;</span><br><span class="line">                    jsonObject.put(<span class="string">"oldGc"</span>, gcJSON);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                session.getBasicRemote().sendText(jsonObject.toJSONString());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        jvmTest.test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acceptMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"Accept&gt;&gt;&gt;"</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭会话</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeSession</span><span class="params">(CloseReason closeReason)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.destory();</span><br><span class="line">        logger.info(closeReason.getReasonPhrase());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnError</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">errorHandler</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.destory();</span><br><span class="line">        logger.info(<span class="string">"MonitorJVMMemory websocket error ："</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (future != <span class="keyword">null</span> &amp;&amp; !future.isCancelled()) &#123;</span><br><span class="line">                future.cancel(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">                session.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">"destory"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent servletContextEvent)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent servletContextEvent)</span> </span>&#123;</span><br><span class="line">        jvmTest.stop();</span><br><span class="line">        executorService.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们使用了Websocket，当连接Open后，使用定长线程池，里面维护一个每隔1s调用一次的方法，来查看当前内存情况，并使用<code>jvmTest.test()</code>来生成测试对象。</p><p>线程池里运行的线程执行的就是我们上面JVMMonitorMemoryTest类的doMonitor方法。</p><p>再看下jvm-echart.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//echart</span></span><br><span class="line"><span class="keyword">var</span> memoryEchart = echarts.init(<span class="built_in">document</span>.getElementById(<span class="string">'memory_main'</span>));</span><br><span class="line"><span class="keyword">var</span> memoryData = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//定义图表样式</span></span><br><span class="line"><span class="keyword">var</span> memoryOption = &#123;</span><br><span class="line">    tooltip : &#123;</span><br><span class="line">        trigger: <span class="string">'axis'</span>,</span><br><span class="line">        axisPointer : &#123;            <span class="comment">// 坐标轴指示器，坐标轴触发有效</span></span><br><span class="line">            type : <span class="string">'shadow'</span>        <span class="comment">// 默认为直线，可选为：'line' | 'shadow'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        formatter: <span class="function"><span class="keyword">function</span> (<span class="params">params</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> dataIndex = params[<span class="number">0</span>].dataIndex;</span><br><span class="line">            <span class="keyword">var</span> res = params[<span class="number">0</span>].axisValue;</span><br><span class="line">            <span class="keyword">if</span>(dataIndex==<span class="number">0</span> || dataIndex==<span class="number">1</span>)&#123;</span><br><span class="line">                res += <span class="string">'&lt;br/&gt;累计回收次数：'</span> + params[<span class="number">0</span>].data;</span><br><span class="line">                res += <span class="string">'&lt;br/&gt;累计回收时间：'</span> + params[<span class="number">1</span>].data + <span class="string">"ms"</span>;</span><br><span class="line">                res += <span class="string">'&lt;br/&gt;平均回收时间：'</span> + <span class="built_in">parseInt</span>(params[<span class="number">1</span>].data/params[<span class="number">0</span>].data) + <span class="string">"ms"</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res += <span class="string">'&lt;br/&gt;已用内存量：'</span> + params[<span class="number">0</span>].data + <span class="string">"MB"</span>;</span><br><span class="line">                <span class="keyword">if</span>(params[<span class="number">0</span>].axisValue!=<span class="string">'峰值内存消耗'</span>)&#123;</span><br><span class="line">                    <span class="keyword">var</span> maxData = memoryData[<span class="number">2</span>];</span><br><span class="line">                    res += <span class="string">'&lt;br/&gt;可用内存量：'</span> + params[<span class="number">1</span>].data + <span class="string">"MB"</span>;</span><br><span class="line">                    res += <span class="string">'&lt;br/&gt;最大内存量：'</span> + maxData[dataIndex] + <span class="string">"MB"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    color: [<span class="string">'#ff0000'</span>,<span class="string">'#91C7AE'</span>],</span><br><span class="line">    legend: &#123;</span><br><span class="line">        data: [<span class="string">'已用内存(MB)'</span>, <span class="string">'可用内存(MB)'</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    grid: &#123;</span><br><span class="line">        left: <span class="string">'3%'</span>,</span><br><span class="line">        right: <span class="string">'4%'</span>,</span><br><span class="line">        bottom: <span class="string">'3%'</span>,</span><br><span class="line">        containLabel: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    xAxis:  &#123;</span><br><span class="line">        type: <span class="string">'value'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    yAxis: &#123;</span><br><span class="line">        type: <span class="string">'category'</span>,</span><br><span class="line">        data: [<span class="string">'OldGenGC'</span>,<span class="string">'EdenGC'</span>,<span class="string">'Old Gen'</span>,<span class="string">'Survivor Space'</span>,<span class="string">'Eden Space'</span>,<span class="string">'峰值内存消耗'</span>,<span class="string">'JVM总内存'</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    series: [</span><br><span class="line">        &#123;</span><br><span class="line">            name: <span class="string">'已用内存(MB)'</span>,</span><br><span class="line">            type: <span class="string">'bar'</span>,</span><br><span class="line">            stack: <span class="string">'总量'</span>,</span><br><span class="line">            barWidth: <span class="number">60</span>,</span><br><span class="line">            label: &#123;</span><br><span class="line">                normal: &#123;</span><br><span class="line">                    show: <span class="literal">true</span>,</span><br><span class="line">                    position: <span class="string">'insideRight'</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            data: memoryData[<span class="number">0</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            name: <span class="string">'可用内存(MB)'</span>,</span><br><span class="line">            type: <span class="string">'bar'</span>,</span><br><span class="line">            stack: <span class="string">'总量'</span>,</span><br><span class="line">            barWidth: <span class="number">60</span>,</span><br><span class="line">            label: &#123;</span><br><span class="line">                normal: &#123;</span><br><span class="line">                    show: <span class="literal">true</span>,</span><br><span class="line">                    position: <span class="string">'insideRight'</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            data: memoryData[<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">memoryEchart.setOption(memoryOption);</span><br><span class="line"></span><br><span class="line"><span class="comment">//刷新图表数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">refreshMemoryData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    memoryEchart.setOption(&#123;</span><br><span class="line">        series: [&#123;</span><br><span class="line">            data: memoryData[<span class="number">0</span>]</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            data: memoryData[<span class="number">1</span>]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与websocket建立连接</span></span><br><span class="line"><span class="keyword">var</span> memorySocket;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initMemorySocket</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(memorySocket!=<span class="literal">undefined</span> || memorySocket!=<span class="literal">null</span>)&#123;</span><br><span class="line">        memorySocket.close(<span class="string">"3000"</span>, <span class="string">"断开连接"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> wsUrl = <span class="string">'ws://'</span>+$(<span class="string">'#hid_host'</span>).val()+<span class="string">'/websocket/jvm/monitor'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(wsUrl);</span><br><span class="line">    memorySocket = <span class="keyword">new</span> WebSocket(wsUrl);</span><br><span class="line">    memorySocket.onopen = <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Connection the jvm monitor server success!!!"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    memorySocket.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> memory = $.parseJSON(evt.data);</span><br><span class="line">        <span class="keyword">var</span> peakUsed = memory.old.usedPeak + memory.eden.usedPeak;</span><br><span class="line">        <span class="keyword">var</span> usedData = [memory.oldGc.gcCount, memory.edenGc.gcCount, memory.old.used, memory.survivor.used, memory.eden.used, peakUsed, memory.totalUsedMemery];</span><br><span class="line">        <span class="keyword">var</span> peakMax = <span class="built_in">parseInt</span>((memory.old.maxPeak + memory.eden.maxPeak)*<span class="number">0.8</span>);</span><br><span class="line">        <span class="keyword">var</span> usable = [memory.oldGc.gcTime, memory.edenGc.gcTime, memory.old.max-memory.old.used,</span><br><span class="line">            memory.survivor.max-memory.survivor.used, memory.eden.max-memory.eden.used, <span class="number">0</span>, memory.totalMaxMemery-memory.totalUsedMemery];</span><br><span class="line">        <span class="keyword">var</span> maxData = [memory.oldGc.gcTime, memory.edenGc.gcTime, memory.old.max, memory.survivor.max, memory.eden.max, <span class="number">0</span>, memory.totalMaxMemery];</span><br><span class="line">        memoryData[<span class="number">0</span>] = usedData;</span><br><span class="line">        memoryData[<span class="number">1</span>] = usable;</span><br><span class="line">        memoryData[<span class="number">2</span>] = maxData;</span><br><span class="line">        refreshMemoryData();</span><br><span class="line">    &#125;;</span><br><span class="line">    memorySocket.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123;</span><br><span class="line">        memorySocket.close();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//断开监控连接</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">closeMemoryMonitor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(memorySocket!=<span class="literal">undefined</span> || memorySocket!=<span class="literal">null</span>)&#123;</span><br><span class="line">        memorySocket.close(<span class="string">"3000"</span>, <span class="string">"断开连接"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    memoryData[<span class="number">0</span>] = [];</span><br><span class="line">    memoryData[<span class="number">1</span>] = [];</span><br><span class="line">    memoryData[<span class="number">2</span>] = [];</span><br><span class="line">    refreshMemoryData();</span><br><span class="line">    $.messager.show(&#123; <span class="attr">title</span>: <span class="string">'系统提示'</span>, <span class="attr">msg</span>: <span class="string">'已断开监控连接！'</span>&#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Disconnect the jvm monitor server success!!!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    initMemorySocket();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个就是在解析后台数据构造Echart图表，这儿就不详细介绍了。</p><p>详细源码可以在 <a href="https://github.com/JavaZWT/framework-base/tree/master/jvm-monitor-memory" rel="external nofollow noopener noreferrer" target="_blank">jvm-monitor-memory</a> 看到。</p><p>我们可以简单看下运行效果图，可以看到JVM进行垃圾回收后内存的变化情况。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-428.gif" alt="upload successful"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过这篇文章，我们了解了JVM垃圾回收的一些运行原理，对JVM堆内存有了更深入的认识。了解虚拟机内存及垃圾回收的一些特性，有助于我们在工作过程中排查定位问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="JVM" scheme="https://www.sakuratears.top/tags/JVM/"/>
    
      <category term="GC" scheme="https://www.sakuratears.top/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>Spring Lookup注解</title>
    <link href="https://www.sakuratears.top/blog/Spring-Lookup%E6%B3%A8%E8%A7%A3.html"/>
    <id>https://www.sakuratears.top/blog/Spring-Lookup注解.html</id>
    <published>2019-06-18T13:41:00.000Z</published>
    <updated>2019-06-18T13:42:37.862Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天我们看下Spring的Lookup注解，这个注解可以使Spring替换一个bean原有的，获取其它对象具体的方法，并自动返回在容器中的查找结果。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>在了解它之前，我们先来看下一个例子。</p><p>我们有一个Bean，TestClassB，它是多例的。大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope</span>(value = SCOPE_PROTOTYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClassB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is TestClass B: "</span> + <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在一个单例Bean，TestClassA，使用到了TestClassB，代码大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClassA</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestClassB testClassB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is TestClass A: "</span> + <span class="keyword">this</span>);</span><br><span class="line">        testClassB.printClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们进行下测试，可以发现一些问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LookUpTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestClassA testClassA;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            testClassA.printClass();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">This is TestClass A: com.zwt.demo.util.TestClassA@2c768ada</span><br><span class="line">This is TestClass B: com.zwt.demo.util.TestClassB@c1fca2a</span><br><span class="line">This is TestClass A: com.zwt.demo.util.TestClassA@2c768ada</span><br><span class="line">This is TestClass B: com.zwt.demo.util.TestClassB@c1fca2a</span><br><span class="line">This is TestClass A: com.zwt.demo.util.TestClassA@2c768ada</span><br><span class="line">This is TestClass B: com.zwt.demo.util.TestClassB@c1fca2a</span><br><span class="line">This is TestClass A: com.zwt.demo.util.TestClassA@2c768ada</span><br><span class="line">This is TestClass B: com.zwt.demo.util.TestClassB@c1fca2a</span><br><span class="line">This is TestClass A: com.zwt.demo.util.TestClassA@2c768ada</span><br><span class="line">This is TestClass B: com.zwt.demo.util.TestClassB@c1fca2a</span><br></pre></td></tr></table></figure><p>对于TestClassA，它因为是单例，所以一直是一个实例，我们是可以理解的，但是对于TestClassB，我们明明设置了多例，但是我们发现它仍是一个实例，相当于单例。</p><p>对于这种情况的产生，很好理解，因为TestClassA为单例，因此TestClassB只有一次注入的机会，即在生成单例TestClassA的时候，因此导致了TestClassB的多例不体现，仍相当于个单例模式。</p><p>如果我们要求TestClassB必须为多例的，那么上面这种情况是会出现问题的。</p><p>如何解决这种问题呢？</p><p>其实我们最常用的一种方法是拿到SpringContext，然后手动获取Bean。代码大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringUtils</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext applicationContext;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        SpringUtils.applicationContext=applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApplicationContext <span class="title">getApplicationContext</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; clazz)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> applicationContext.getBean(clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时TestClassA里的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClassA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is TestClass A: "</span> + <span class="keyword">this</span>);</span><br><span class="line">        SpringUtils.getBean(TestClassB.class).printClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到输出结果,TestClassB已经是多例的了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">This is TestClass A: com.zwt.demo.util.TestClassA@7c447c76</span><br><span class="line">This is TestClass B: com.zwt.demo.util.TestClassB@1640c151</span><br><span class="line">This is TestClass A: com.zwt.demo.util.TestClassA@7c447c76</span><br><span class="line">This is TestClass B: com.zwt.demo.util.TestClassB@5d5b5fa7</span><br><span class="line">This is TestClass A: com.zwt.demo.util.TestClassA@7c447c76</span><br><span class="line">This is TestClass B: com.zwt.demo.util.TestClassB@2a32fb6</span><br><span class="line">This is TestClass A: com.zwt.demo.util.TestClassA@7c447c76</span><br><span class="line">This is TestClass B: com.zwt.demo.util.TestClassB@6107165</span><br><span class="line">This is TestClass A: com.zwt.demo.util.TestClassA@7c447c76</span><br><span class="line">This is TestClass B: com.zwt.demo.util.TestClassB@164a62bf</span><br></pre></td></tr></table></figure><p>当然也可以让TestClassA继承ApplicationContextAware直接拿到ApplicationContext，然后获取TestClassB。</p><p>这种方式在项目使用中还是比较多的，也是很方便的。</p><p>还有其他方法吗？</p><p>下面我们来说另一种方式，当然就是我们今天的主角，Lookup注解。那具体如何使用呢，我们来看下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClassA</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Lookup</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestClassB <span class="title">getTestClassB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is TestClass A: "</span> + <span class="keyword">this</span>);</span><br><span class="line">        getTestClassB().printClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们运行测试类，可以看到输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">This is TestClass A: com.zwt.demo.util.TestClassA$$EnhancerBySpringCGLIB$$a967ae38@5a00eb1e</span><br><span class="line">This is TestClass B: com.zwt.demo.util.TestClassB@1aac188d</span><br><span class="line">This is TestClass A: com.zwt.demo.util.TestClassA$$EnhancerBySpringCGLIB$$a967ae38@5a00eb1e</span><br><span class="line">This is TestClass B: com.zwt.demo.util.TestClassB@7026b7ee</span><br><span class="line">This is TestClass A: com.zwt.demo.util.TestClassA$$EnhancerBySpringCGLIB$$a967ae38@5a00eb1e</span><br><span class="line">This is TestClass B: com.zwt.demo.util.TestClassB@2d23faef</span><br><span class="line">This is TestClass A: com.zwt.demo.util.TestClassA$$EnhancerBySpringCGLIB$$a967ae38@5a00eb1e</span><br><span class="line">This is TestClass B: com.zwt.demo.util.TestClassB@7cb8437d</span><br><span class="line">This is TestClass A: com.zwt.demo.util.TestClassA$$EnhancerBySpringCGLIB$$a967ae38@5a00eb1e</span><br><span class="line">This is TestClass B: com.zwt.demo.util.TestClassB@62a4417</span><br></pre></td></tr></table></figure><p>发现TestClassB是多例的，可是我们根据上面的代码，感觉TestClassB返回应该不是null么。</p><p>当然，这就要来了解下Lookup注解了，我们分析一下它的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Lookup &#123;</span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到该注解作用于方法上，有一个参数value，这个值可以指定要look up的Bean的名字。如果不指定，就会默认方法返回的类型寻找Bean并进行Look up。</p><p>我们在Spring源码中寻找下该注解 @Lookup，会发现只有一个地方使用到了该注解。</p><p>在AutowiredAnnotationBeanPostProcessor类的determineCandidateConstructors方法里。该方法部分内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Constructor&lt;?&gt;[] determineCandidateConstructors(Class&lt;?&gt; beanClass, <span class="keyword">final</span> String beanName)</span><br><span class="line"><span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Let's check for lookup methods here..</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.lookupMethodsChecked.contains(beanName)) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ReflectionUtils.doWithMethods(beanClass, <span class="keyword">new</span> ReflectionUtils.MethodCallback() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWith</span><span class="params">(Method method)</span> <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException </span>&#123;</span><br><span class="line">Lookup lookup = method.getAnnotation(Lookup.class);</span><br><span class="line"><span class="keyword">if</span> (lookup != <span class="keyword">null</span>) &#123;</span><br><span class="line">LookupOverride override = <span class="keyword">new</span> LookupOverride(method, lookup.value());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">RootBeanDefinition mbd = (RootBeanDefinition) beanFactory.getMergedBeanDefinition(beanName);</span><br><span class="line">mbd.getMethodOverrides().addOverride(override);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line"><span class="string">"Cannot apply @Lookup to beans without corresponding bean definition"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"Lookup method resolution failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NoClassDefFoundError err) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"Failed to introspect bean class ["</span> + beanClass.getName() +</span><br><span class="line"><span class="string">"] for lookup method metadata: could not find class that it depends on"</span>, err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.lookupMethodsChecked.add(beanName);</span><br><span class="line">&#125;</span><br><span class="line">       <span class="comment">//部分代码略......</span></span><br></pre></td></tr></table></figure><p>可以看到Spring会首先判断该Bean是否有Lookup注解的方法，现在缓存里看，缓存没有的话会尝试获取方法上的Lookup注解，如果存在，拿到需要重写（覆盖）的方法信息放入LookupOverride，最后为RootBeanDefinition添加LookupOverride的属性。这个方法最终会被AbstractAutowireCapableBeanFactory类中的createBeanInstance方法调用，去生成新的Bean并重写，实现改变Bean的效果。</p><p>因此原理大致为：方法执行返回的对象，使用 Spring 内原有的这类对象替换，通过改变方法返回值来动态改变方法。内部实现为使用 cglib 方法，重新生成子类，重写配置的方法和返回对象，达到动态改变的效果。因此Bean的多列特性也被体现了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过解决一个单例Bean（无状态Bean）调用多例Bean（有状态Bean）的问题，我们了解了Lookup注解的一些简单用法，对Spring也有了一些深入的认识。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="Spring" scheme="https://www.sakuratears.top/tags/Spring/"/>
    
      <category term="Lookup" scheme="https://www.sakuratears.top/tags/Lookup/"/>
    
  </entry>
  
  <entry>
    <title>SpringRetry框架简介</title>
    <link href="https://www.sakuratears.top/blog/SpringRetry%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B.html"/>
    <id>https://www.sakuratears.top/blog/SpringRetry框架简介.html</id>
    <published>2019-05-29T15:06:00.000Z</published>
    <updated>2019-05-29T15:17:07.371Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天我们来聊一聊Spring Retry框架。</p><p>Spring Retry提供了一个关于重试失败操作的抽象，强调对流程和基于策略的行为的声明性控制，易于扩展和定制。例如，对于一个操作，如果它失败了，我们可以根据异常的类型，使用一个固定的或指数级的回退来重试它。</p><p>并不是所有的异常失败都适合重试，比如参数校验错误，显然不适合重试，而Spring Retry可以指定要重试的异常类型，对于指定类型的异常进行重试。</p><p>考虑到网络原因，可能一些方法失败后不立即进行下一次重试，而等待若干时间后再进行，Spring Retry里也支持此种类型的重试。</p><p>可能所有的重试都不成功，此时需要返回一个程序默认值或者直接抛出异常等，Spring Retry的兜底函数可以解决此类问题。</p><p>另外Spring Retry还支持简单的熔断策略。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>说了这么多，我们来看下Spring Retry吧。</p><p>要使用Spring Retry，首先要引入相关jar包，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.retry&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-retry&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.2.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>先简单的写一个例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RetryTemplate template = <span class="keyword">new</span> RetryTemplate();</span><br><span class="line">        <span class="comment">//重试策略：次数重试策略</span></span><br><span class="line">        SimpleRetryPolicy retryPolicy = <span class="keyword">new</span> SimpleRetryPolicy();</span><br><span class="line">        retryPolicy.setMaxAttempts(<span class="number">3</span>);</span><br><span class="line">        template.setRetryPolicy(retryPolicy);</span><br><span class="line">        <span class="comment">//退避策略：固定退避策略</span></span><br><span class="line">        FixedBackOffPolicy backOffPolicy = <span class="keyword">new</span> FixedBackOffPolicy();</span><br><span class="line">        backOffPolicy.setBackOffPeriod(<span class="number">4</span>*<span class="number">1000L</span>);</span><br><span class="line">        template.setBackOffPolicy(backOffPolicy);</span><br><span class="line">        </span><br><span class="line">        String str = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">//当重试失败后，执行RecoveryCallback</span></span><br><span class="line">        String result2 = template.execute((retryCallback)-&gt;&#123;</span><br><span class="line">                System.out.println(<span class="string">"retry count:"</span> + retryCallback.getRetryCount());</span><br><span class="line">                <span class="keyword">return</span> getStr(str);</span><br><span class="line">        &#125;, (recoveryCallback)-&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"所有重试均失败!!"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">"返回值为："</span>+result2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getStr</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isBlank(str))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"数据为空！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，当我们传入空或者空字符串时，可以看到程序会重试3次（每隔4s），均不成功，最后返回recoveryCallback的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">18:05:20.879 [main] DEBUG org.springframework.retry.support.RetryTemplate - Retry: count=0</span><br><span class="line">retry count:0</span><br><span class="line">18:05:24.889 [main] DEBUG org.springframework.retry.support.RetryTemplate - Checking for rethrow: count=1</span><br><span class="line">18:05:24.889 [main] DEBUG org.springframework.retry.support.RetryTemplate - Retry: count=1</span><br><span class="line">retry count:1</span><br><span class="line">18:05:28.890 [main] DEBUG org.springframework.retry.support.RetryTemplate - Checking for rethrow: count=2</span><br><span class="line">18:05:28.890 [main] DEBUG org.springframework.retry.support.RetryTemplate - Retry: count=2</span><br><span class="line">retry count:2</span><br><span class="line">18:05:28.890 [main] DEBUG org.springframework.retry.support.RetryTemplate - Checking for rethrow: count=3</span><br><span class="line">18:05:28.890 [main] DEBUG org.springframework.retry.support.RetryTemplate - Retry failed last attempt: count=3</span><br><span class="line">所有重试均失败!!</span><br><span class="line">返回值为：失败</span><br></pre></td></tr></table></figure><p>我们来看下例子中涉及到的一些东西。</p><p>可以看到，要使用重试功能，首先要创建一个RetryTemplate，并设置它的两个重要参数：重试策略（RetryPolicy）和退避策略（BackOffPolicy）。</p><h2 id="重试策略"><a href="#重试策略" class="headerlink" title="重试策略"></a>重试策略</h2><p>这两个策略还是比较好理解的，对于重试策略，指的就是请求不成功后下次请求的策略。很明显我们可以看到它是一个接口RetryPolicy。</p><p>这个接口里比较重要的一个方法为canRetry，它的返回值决定下一次是否重试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canRetry</span><span class="params">(RetryContext context)</span></span>;</span><br></pre></td></tr></table></figure><p>对于这个接口，可以看到它目前有8种重试策略。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-415.png" alt="upload successful"></p><ul><li><p>NeverRetryPolicy</p><p>  只调用被执行方法一次，不会进行重试操作。</p><p>  我们可以看到它的canRetry方法。可以看到这个方法会一直返回false。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canRetry</span><span class="params">(RetryContext context)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> !((NeverRetryContext) context).isFinished();</span><br><span class="line">&#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NeverRetryContext</span> <span class="keyword">extends</span> <span class="title">RetryContextSupport</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> finished = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NeverRetryContext</span><span class="params">(RetryContext parent)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(parent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFinished</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> finished;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFinished</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.finished = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AlwaysRetryPolicy</p><p>  如果被执行方法调用不成功会一直重试，这种方法如果操作不当会出现死循环的情况，应当注意。</p><p>  我们可以看到它里面的canRetry方法一直返回true，即如果调用失败，会一直重试直到成功。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canRetry</span><span class="params">(RetryContext context)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>SimpleRetryPolicy</p><p>  固定次数重试策略，默认最多重试3次，我们可以通过指定其maxAttempts参数的值来规定最多重试多少次。</p><p>  它的canRetry方法可以看到和当前已重试次数做了比较来确定下一次是否重试。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canRetry</span><span class="params">(RetryContext context)</span> </span>&#123;</span><br><span class="line">Throwable t = context.getLastThrowable();</span><br><span class="line"><span class="keyword">return</span> (t == <span class="keyword">null</span> || retryForException(t)) &amp;&amp; context.getRetryCount() &lt; maxAttempts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>TimeoutRetryPolicy</p><p>  超时重试策略，只有在超时时间内才可以重试，超过后就不会再进行重试，超时时间可以认为是在第一次请求开始时计数。默认超时时间1000ms，我们可以通过设置timeout的值来指定超时时间。</p><p>  它的canRetry方法，可以看到时间的对比来确定是否进行重试。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canRetry</span><span class="params">(RetryContext context)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ((TimeoutRetryContext) context).isAlive();</span><br><span class="line">&#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeoutRetryContext</span> <span class="keyword">extends</span> <span class="title">RetryContextSupport</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> timeout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> start;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TimeoutRetryContext</span><span class="params">(RetryContext parent, <span class="keyword">long</span> timeout)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(parent);</span><br><span class="line"><span class="keyword">this</span>.start = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">this</span>.timeout = timeout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAlive</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (System.currentTimeMillis() - start) &lt;= timeout;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>CompositeRetryPolicy</p><p>  组合重试策略，有乐观重试和悲观重试两种情况。可以看到它有两个参数，optimistic和policies。</p><p>  optimistic表示是否乐观，默认false。</p><p>  policies表示所有传入的重试策略。</p><p>  我们根据它的canRetry方法，可以清楚的知道，如果乐观情况下，有一个策略（policies[i]）canRetry为true就可以进行重试，悲观情况下只有所有的传入的重试策略canRetry为true才可以进行重试。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canRetry</span><span class="params">(RetryContext context)</span> </span>&#123;</span><br><span class="line">RetryContext[] contexts = ((CompositeRetryContext) context).contexts;</span><br><span class="line">RetryPolicy[] policies = ((CompositeRetryContext) context).policies;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> retryable = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.optimistic) &#123;</span><br><span class="line">retryable = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; contexts.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (policies[i].canRetry(contexts[i])) &#123;</span><br><span class="line">retryable = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; contexts.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!policies[i].canRetry(contexts[i])) &#123;</span><br><span class="line">retryable = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> retryable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ExpressionRetryPolicy</p><p>  异常重试策略，会对抛出指定异常的情况下进行重试，继承SimpleRetryPolicy。可以指定要重试的异常参数expression，也可以指定异常的全名字符串，会被转化为指定异常。</p><p>  我们看一下它的canRetry方法。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canRetry</span><span class="params">(RetryContext context)</span> </span>&#123;</span><br><span class="line">Throwable lastThrowable = context.getLastThrowable();</span><br><span class="line"><span class="keyword">if</span> (lastThrowable == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.canRetry(context);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.canRetry(context)</span><br><span class="line">&amp;&amp; <span class="keyword">this</span>.expression.getValue(<span class="keyword">this</span>.evaluationContext, lastThrowable, Boolean.class);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  可以看到除了使用了SimpleRetryPolicy的canRetry判断还有对是不是当前异常的判断，来确定是否重试。</p><p>  当然这个策略也是可以指定最大重试次数maxAttempts的。</p></li></ul><ul><li><p>ExceptionClassifierRetryPolicy</p><p>  根据最新的异常动态的适应注入的策略，需要设置参数exceptionClassifier。</p><p>  比如第一次重试时，抛出异常A，对应传入策略A，当第二次重试时，抛出异常B，则对应传入的策略B。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canRetry</span><span class="params">(RetryContext context)</span> </span>&#123;</span><br><span class="line">RetryPolicy policy = (RetryPolicy) context;</span><br><span class="line"><span class="keyword">return</span> policy.canRetry(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  可以看到它的canRetry返回值取决于当前使用的策略的canRetry方法的返回值，而策略的动态切换由ExceptionClassifierRetryContext这个类来处理，这儿不再过多介绍。</p></li><li><p>CircuitBreakerRetryPolicy</p><p>  带有熔断的重试策略，该策略提供过载保护功能，它的canRetry代码如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canRetry</span><span class="params">(RetryContext context)</span> </span>&#123;</span><br><span class="line">CircuitBreakerRetryContext circuit = (CircuitBreakerRetryContext) context;</span><br><span class="line">       <span class="comment">//如果熔断器处于打开状态，就直接短路，返回失败</span></span><br><span class="line"><span class="keyword">if</span> (circuit.isOpen()) &#123;</span><br><span class="line">circuit.incrementShortCircuitCount();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//重置熔断器</span></span><br><span class="line">circuit.reset();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.delegate.canRetry(circuit.context);</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">//------- isOpen方法如下</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> time = System.currentTimeMillis() - <span class="keyword">this</span>.start;</span><br><span class="line"><span class="keyword">boolean</span> retryable = <span class="keyword">this</span>.policy.canRetry(<span class="keyword">this</span>.context);</span><br><span class="line">       <span class="comment">//当前不允许重试</span></span><br><span class="line"><span class="keyword">if</span> (!retryable) &#123;</span><br><span class="line">           <span class="comment">//如果已经超过重置时间，重新闭合，关闭熔断器</span></span><br><span class="line"><span class="keyword">if</span> (time &gt; <span class="keyword">this</span>.timeout) &#123;</span><br><span class="line">logger.trace(<span class="string">"Closing"</span>);</span><br><span class="line"><span class="keyword">this</span>.context = createDelegateContext(policy, getParent());</span><br><span class="line"><span class="keyword">this</span>.start = System.currentTimeMillis();</span><br><span class="line">retryable = <span class="keyword">this</span>.policy.canRetry(<span class="keyword">this</span>.context);</span><br><span class="line">&#125;</span><br><span class="line">           <span class="comment">// 如果小于熔断器打开时间，读取关闭状态，如果熔断器是关闭的，就打开熔断器，重置熔断计时器</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (time &lt; <span class="keyword">this</span>.openWindow) &#123;</span><br><span class="line"><span class="keyword">if</span> ((Boolean) getAttribute(CIRCUIT_OPEN) == <span class="keyword">false</span>) &#123;</span><br><span class="line">logger.trace(<span class="string">"Opening circuit"</span>);</span><br><span class="line">setAttribute(CIRCUIT_OPEN, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.start = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">       <span class="comment">//允许重试</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//判断是否在openWindow熔断器电路打开的超时时间之外，超过打开时间，就重置上下文，并且返回false</span></span><br><span class="line"><span class="keyword">if</span> (time &gt; <span class="keyword">this</span>.openWindow) &#123;</span><br><span class="line">logger.trace(<span class="string">"Resetting context"</span>);</span><br><span class="line"><span class="keyword">this</span>.start = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">this</span>.context = createDelegateContext(policy, getParent());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Open: "</span> + !retryable);</span><br><span class="line">&#125;</span><br><span class="line">setAttribute(CIRCUIT_OPEN, !retryable);</span><br><span class="line"><span class="keyword">return</span> !retryable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  它接受三个参数，delegate、resetTimeout和openTimeout。</p><p>  delegate指使用的重试策略，默认使用SimpleRetryPolicy。</p><p>  resetTimeout表示重置线路超时时间(以毫秒为单位)。当线路打开后，它会在此时间过后重新关闭，上下文将重新启动。</p><p>  openTimeout表示断开线路的超时时间。如果委托策略无法重试，则自上下文启动以来经过的时间小于此时间，则打开线路。</p></li></ul><h2 id="退避策略"><a href="#退避策略" class="headerlink" title="退避策略"></a>退避策略</h2><p>我们再来看一下退避策略（BackOffPolicy）。</p><p>退避策略接口（BackOffPolicy）目前有5种已实现策略。如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-416.png" alt="upload successful"></p><p>我们来分别看一下它们。</p><p>要实现退避策略，重要的是实现接口的backoff方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BackOffPolicy</span> </span>&#123;</span><br><span class="line"><span class="function">BackOffContext <span class="title">start</span><span class="params">(RetryContext context)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backOff</span><span class="params">(BackOffContext backOffContext)</span> <span class="keyword">throws</span> BackOffInterruptedException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的实现有两个主要类，抽象类StatelessBackOffPolicy和实现类ExponentialBackOffPolicy。</p><p>如图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-417.png" alt="upload successful"></p><ul><li><p>StatelessBackOffPolicy</p><p>这是用于在调用之间不维护任何状态的退避策略实现的简单基类，它的backoff方法调用了子类的doBackOff方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">backOff</span><span class="params">(BackOffContext backOffContext)</span> <span class="keyword">throws</span> BackOffInterruptedException </span>&#123;</span><br><span class="line">doBackOff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到它的三个实现并简单分析，如下图。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-418.png" alt="upload successful"></p><ul><li><p>NoBackOffPolicy</p><p>无任何退避策略，可以看到doBackOff方法什么也没做。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBackOff</span><span class="params">()</span> <span class="keyword">throws</span> BackOffInterruptedException </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下，如果一次重试不成功，下一次会直接再进行重试。</p></li><li><p>FixedBackOffPolicy</p><p>固定退避策略，这种情况下，一次重试不成功，下一次会间隔一段时间后在进行重试。</p><p>可以看到它可以通过设置backOffPeriod（退避间隔）来指定与下一次重试的间隔时间。这个值默认为1000ms。</p><p>这个类里面另一个比较重要的参数为Sleeper（休眠器），它可以指定程序的休眠方式，默认使用ThreadWaitSleeper休眠器。</p><p>可以看到它的doBackOff方法直接调用了休眠器的sleep方法休眠一段时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBackOff</span><span class="params">()</span> <span class="keyword">throws</span> BackOffInterruptedException </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">sleeper.sleep(backOffPeriod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BackOffInterruptedException(<span class="string">"Thread interrupted while sleeping"</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>UniformRandomBackOffPolicy</p><p>随机休眠退避策略，当一次重试失败后，下一次重试之前，这个策略会随机退避一段时间。</p><p>看到这个我们明显就知道它会有minBackOffPeriod（最小退避时间）和maxBackOffPeriod（最大退避时间）两个值了。最小退避值默认500ms，最大退避值默认1500ms。</p><p>除了上面两个参数，它里面比较重要的两个参数一个是取值器和休眠器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">private</span> Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line"><span class="keyword">private</span> Sleeper sleeper = <span class="keyword">new</span> ThreadWaitSleeper();</span><br></pre></td></tr></table></figure><p>上面代码可以看到它们的值（random取值器不可人为修改）。</p><p>再来看下doBackOff方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBackOff</span><span class="params">()</span> <span class="keyword">throws</span> BackOffInterruptedException </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">long</span> delta = maxBackOffPeriod==minBackOffPeriod ? <span class="number">0</span> : random.nextInt((<span class="keyword">int</span>) (maxBackOffPeriod - minBackOffPeriod));</span><br><span class="line">sleeper.sleep(minBackOffPeriod + delta );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BackOffInterruptedException(<span class="string">"Thread interrupted while sleeping"</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是比较好理解的，可以看到当最大时间和最小时间相等时，delta=0，即每次重试之前都休眠minBackOffPeriod时间。</p></li></ul></li><li><p>ExponentialBackOffPolicy</p><p>指数型退避策略，顾名思义，它的退避时间是指数增长的。</p><p>我们来看下它的三个参数，initialInterval 初始时间间隔，maxInterval 最大时间间隔，multiplier指数因子。</p><p>来看一下它的backOff方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backOff</span><span class="params">(BackOffContext backOffContext)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BackOffInterruptedException </span>&#123;</span><br><span class="line">ExponentialBackOffContext context = (ExponentialBackOffContext) backOffContext;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">long</span> sleepTime = context.getSleepAndIncrement();</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Sleeping for "</span> + sleepTime);</span><br><span class="line">&#125;</span><br><span class="line">sleeper.sleep(sleepTime);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BackOffInterruptedException(<span class="string">"Thread interrupted while sleeping"</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及它涉及到的下面的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">getSleepAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> sleep = <span class="keyword">this</span>.interval;</span><br><span class="line"><span class="keyword">if</span> (sleep &gt; maxInterval) &#123;</span><br><span class="line">sleep = maxInterval;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.interval = getNextInterval();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sleep;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">getNextInterval</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">long</span>) (<span class="keyword">this</span>.interval * <span class="keyword">this</span>.multiplier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到逻辑很好理解，默认退避时间为interval，如果interval超过maxInterval，退避时间就为maxInterval，否则就获取下一次的interval时间，这个时间就是interval*multiplier，所以退避时间会以指数增长。</p><p>它的另一个参数Sleeper（休眠器）默认也是ThreadWaitSleeper。</p><p>initialInterval初始时间默认值为100ms，maxInterval最大时间默认为30000ms，multiplier指数因子默认为2.</p></li><li><p>ExponentialRandomBackOffPolicy</p><p>随机指数退避策略，对于上面的指数策略，这儿不一样的就是指数因子会随机变化。</p><p>我们大致看一下这个策略的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExponentialRandomBackOffPolicy</span> <span class="keyword">extends</span> <span class="title">ExponentialBackOffPolicy</span> </span>&#123;</span><br><span class="line">   <span class="comment">//部分代码略</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExponentialRandomBackOffContext</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">ExponentialBackOffPolicy</span>.<span class="title">ExponentialBackOffContext</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExponentialRandomBackOffContext</span><span class="params">(<span class="keyword">long</span> expSeed, <span class="keyword">double</span> multiplier,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">long</span> maxInterval)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(expSeed, multiplier, maxInterval);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">getSleepAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> next = <span class="keyword">super</span>.getSleepAndIncrement();</span><br><span class="line">next = (<span class="keyword">long</span>) (next * (<span class="number">1</span> + r.nextFloat() * (getMultiplier() - <span class="number">1</span>)));</span><br><span class="line"><span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">//部分代码略</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>可以看到它继承了ExponentialBackOffPolicy，并重写了ExponentialBackOffContext里的getSleepAndIncrement方法，原来的指数因子改为随机的了。</p><p>其它与ExponentialBackOffPolicy一致，这儿不再介绍。</p></li></ul><h2 id="RetryTemplate"><a href="#RetryTemplate" class="headerlink" title="RetryTemplate"></a>RetryTemplate</h2><p>再来看下重试模板RetryTemplate，除了上面说到RetryPolicy和BackOffPolicy，它还有几个比较重要的参数。</p><ul><li>RetryListener ：可以传入一个listener数组，主要功能是用于监控重试行为。</li><li>RetryCallback ：重试回调，用户包装业务流，第一次执行和产生重试执行都会调用这个callback代码。</li><li>RecoveryCallback ：当所有重试都失败后，回调该接口，提供给业务重试回复机制。</li><li>RetryState ：重试状态，对于一些有事务的方法，如果出现某些异常，可能需要回滚而不是进行重试，这个参数可以完成这一功能。</li><li>RetryContext ： 重试上下文，每次重试都会将其作为参数传入RetryCallback中使用。</li></ul><p>然后我们大致来看下RetryTemplate的部分关键代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T, E extends Throwable&gt; <span class="function">T <span class="title">doExecute</span><span class="params">(RetryCallback&lt;T, E&gt; retryCallback,</span></span></span><br><span class="line"><span class="function"><span class="params">RecoveryCallback&lt;T&gt; recoveryCallback, RetryState state)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> E, ExhaustedRetryException </span>&#123;</span><br><span class="line">        <span class="comment">//拿到重试策略和退避策略</span></span><br><span class="line">RetryPolicy retryPolicy = <span class="keyword">this</span>.retryPolicy;</span><br><span class="line">BackOffPolicy backOffPolicy = <span class="keyword">this</span>.backOffPolicy;</span><br><span class="line">        <span class="comment">//初始化重试上下文</span></span><br><span class="line">RetryContext context = open(retryPolicy, state);</span><br><span class="line">RetrySynchronizationManager.register(context);</span><br><span class="line">Throwable lastException = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> exhausted = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//执行切面方法，在执行业务之前可以通过listener进行监控</span></span><br><span class="line"><span class="keyword">boolean</span> running = doOpenInterceptors(retryCallback, context);</span><br><span class="line"><span class="keyword">if</span> (!running) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> TerminatedRetryException(</span><br><span class="line"><span class="string">"Retry terminated abnormally by interceptor before first attempt"</span>);</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">//确定退避上下文环境</span></span><br><span class="line">BackOffContext backOffContext = <span class="keyword">null</span>;</span><br><span class="line">Object resource = context.getAttribute(<span class="string">"backOffContext"</span>);</span><br><span class="line"><span class="keyword">if</span> (resource <span class="keyword">instanceof</span> BackOffContext) &#123;</span><br><span class="line">backOffContext = (BackOffContext) resource;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (backOffContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">backOffContext = backOffPolicy.start(context);</span><br><span class="line"><span class="keyword">if</span> (backOffContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">context.setAttribute(<span class="string">"backOffContext"</span>, backOffContext);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">//开始重试循环</span></span><br><span class="line">            <span class="comment">//如果重试策略认为可以重试</span></span><br><span class="line"><span class="keyword">while</span> (canRetry(retryPolicy, context) &amp;&amp; !context.isExhaustedOnly()) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//清空上次的异常</span></span><br><span class="line">lastException = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">//执行业务方法</span></span><br><span class="line"><span class="keyword">return</span> retryCallback.doWithRetry(context);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    <span class="comment">//出现异常，最新异常就是此次异常</span></span><br><span class="line">lastException = e;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//将异常信息通知到retryPolicy、state和context</span></span><br><span class="line">registerThrowable(retryPolicy, state, context, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> TerminatedRetryException(<span class="string">"Could not register throwable"</span>,</span><br><span class="line">ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">//对于重试出现的异常，我们使用切面listener进行监听</span></span><br><span class="line">doOnErrorInterceptors(retryCallback, context, e);</span><br><span class="line">&#125;</span><br><span class="line">                    <span class="comment">//如果重试策略认为还可以重试</span></span><br><span class="line"><span class="keyword">if</span> (canRetry(retryPolicy, context) &amp;&amp; !context.isExhaustedOnly()) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">//执行退避策略</span></span><br><span class="line">backOffPolicy.backOff(backOffContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BackOffInterruptedException ex) &#123;</span><br><span class="line">lastException = e;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">                    <span class="comment">//确认下是否需要重新抛出（对于有事务的逻辑，重新抛出指定异常方便事务回滚）</span></span><br><span class="line"><span class="keyword">if</span> (shouldRethrow(retryPolicy, context, state)) &#123;</span><br><span class="line"><span class="keyword">throw</span> RetryTemplate.&lt;E&gt;wrapIfNecessary(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (state != <span class="keyword">null</span> &amp;&amp; context.hasAttribute(GLOBAL_STATE)) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">//重试完成后，执行recoveryCallback操作</span></span><br><span class="line">exhausted = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">return</span> handleRetryExhausted(recoveryCallback, context, state);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line"><span class="keyword">throw</span> RetryTemplate.&lt;E&gt;wrapIfNecessary(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭</span></span><br><span class="line">close(retryPolicy, context, state, lastException == <span class="keyword">null</span> || exhausted);</span><br><span class="line">            <span class="comment">//使用切面listener进行监控关闭等流程</span></span><br><span class="line">doCloseInterceptors(retryCallback, context, lastException);</span><br><span class="line">RetrySynchronizationManager.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中用到的一些方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//该异常是否抛出</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">shouldRethrow</span><span class="params">(RetryPolicy retryPolicy, RetryContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">RetryState state)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> state != <span class="keyword">null</span> &amp;&amp; state.rollbackFor(context.getLastThrowable());</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">//监听open操作</span></span><br><span class="line"><span class="keyword">private</span> &lt;T, E extends Throwable&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">doOpenInterceptors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">RetryCallback&lt;T, E&gt; callback, RetryContext context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> result = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (RetryListener listener : <span class="keyword">this</span>.listeners) &#123;</span><br><span class="line">result = result &amp;&amp; listener.open(context, callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">//监听close操作</span></span><br><span class="line"><span class="keyword">private</span> &lt;T, E extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doCloseInterceptors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">RetryCallback&lt;T, E&gt; callback, RetryContext context, Throwable lastException)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.listeners.length; i-- &gt; <span class="number">0</span>;) &#123;</span><br><span class="line"><span class="keyword">this</span>.listeners[i].close(context, callback, lastException);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">//监听error操作</span></span><br><span class="line"><span class="keyword">private</span> &lt;T, E extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doOnErrorInterceptors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">RetryCallback&lt;T, E&gt; callback, RetryContext context, Throwable throwable)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.listeners.length; i-- &gt; <span class="number">0</span>;) &#123;</span><br><span class="line"><span class="keyword">this</span>.listeners[i].onError(context, callback, throwable);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面的描述，RetryTemplate的执行流程大致如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-419.png" alt="upload successful"></p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>我们把开始提到的例子复杂化下。引入Listener和RetryState参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RetryTemplate template = <span class="keyword">new</span> RetryTemplate();</span><br><span class="line">        <span class="comment">//重试策略：次数重试策略</span></span><br><span class="line">        SimpleRetryPolicy retryPolicy = <span class="keyword">new</span> SimpleRetryPolicy();</span><br><span class="line">        retryPolicy.setMaxAttempts(<span class="number">3</span>);</span><br><span class="line">        template.setRetryPolicy(retryPolicy);</span><br><span class="line">        <span class="comment">//退避策略：固定退避策略</span></span><br><span class="line">        FixedBackOffPolicy backOffPolicy = <span class="keyword">new</span> FixedBackOffPolicy();</span><br><span class="line">        backOffPolicy.setBackOffPeriod(<span class="number">1000L</span>);</span><br><span class="line">        template.setBackOffPolicy(backOffPolicy);</span><br><span class="line">        <span class="comment">//设置有状态重试</span></span><br><span class="line">        BinaryExceptionClassifier classifier = <span class="keyword">new</span> BinaryExceptionClassifier(</span><br><span class="line">                Collections.singleton(NullPointerException.class)</span><br><span class="line">        );</span><br><span class="line">        RetryState state = <span class="keyword">new</span> DefaultRetryState(<span class="string">"rollbackKey"</span>, <span class="keyword">false</span>, classifier);</span><br><span class="line">        <span class="comment">//设置监听</span></span><br><span class="line">        DefaultStatisticsRepository defaultStatisticsRepository =<span class="keyword">new</span> DefaultStatisticsRepository();</span><br><span class="line">        template.setListeners(<span class="keyword">new</span> RetryListener[]&#123;<span class="keyword">new</span> StatisticsListener(defaultStatisticsRepository)&#125;);</span><br><span class="line"></span><br><span class="line">        String str = <span class="string">"1"</span>;</span><br><span class="line">        <span class="comment">//当重试失败后，执行RecoveryCallback</span></span><br><span class="line">        String result2 = template.execute((retryCallback)-&gt;&#123;</span><br><span class="line">                System.out.println(<span class="string">"retry count:"</span> + retryCallback.getRetryCount());</span><br><span class="line">                retryCallback.setAttribute(RetryContext.NAME,<span class="string">"method.key"</span>);</span><br><span class="line">                <span class="keyword">return</span> getStr(str);</span><br><span class="line">        &#125;, (recoveryCallback)-&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"所有重试均失败!!"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"失败"</span>;</span><br><span class="line">        &#125;,state);</span><br><span class="line">        RetryStatistics statistics = defaultStatisticsRepository.findOne(<span class="string">"method.key"</span>);</span><br><span class="line">        System.out.println(statistics);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getStr</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isBlank(str))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"数据为空！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"1"</span>.equals(str))&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数为1！！！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们对str赋值1和””，可以清楚的看到输出的日志。当赋值””时，执行一次后直接抛出空指针异常，不会再进行重试。如果调用的方法有事务，可以进行回滚等操作，这就是有状态的重试。</p><p>当str=”1”时，可以看到监听分析的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DefaultRetryStatistics [name=method.key, startedCount=0, completeCount=0, recoveryCount=1, errorCount=3, abortCount=0]</span><br></pre></td></tr></table></figure><h2 id="重试注解"><a href="#重试注解" class="headerlink" title="重试注解"></a>重试注解</h2><p>Spring Retry也支持使用注解的形式标注。如下：</p><h3 id="EnableRetry"><a href="#EnableRetry" class="headerlink" title="EnableRetry"></a>EnableRetry</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span>(proxyTargetClass = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@Import</span>(RetryConfiguration.class)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableRetry &#123;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>proxyTargetClass指是否使用CGLIB增强代理，默认false。</code></pre><p>这个注解作用在类上，如果想要某个方法可以进行重试，则这个方法所在的类需要有EnableRetry注解。</p><h3 id="Retryable"><a href="#Retryable" class="headerlink" title="Retryable"></a>Retryable</h3><p>内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123; ElementType.METHOD, ElementType.TYPE &#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retryable &#123;</span><br><span class="line"><span class="function">String <span class="title">interceptor</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">Class&lt;? extends Throwable&gt;[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">Class&lt;? extends Throwable&gt;[] include() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">Class&lt;? extends Throwable&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"><span class="function">String <span class="title">label</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">stateful</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxAttempts</span><span class="params">()</span> <span class="keyword">default</span> 3</span>;</span><br><span class="line"><span class="function">String <span class="title">maxAttemptsExpression</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"><span class="function">Backoff <span class="title">backoff</span><span class="params">()</span> <span class="keyword">default</span> @<span class="title">Backoff</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">String <span class="title">exceptionExpression</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该注解作用在方法上，指定的方法会进行重试操作。</p><p>参数说明：</p><pre><code>interceptor：拦截器value：可以重试的异常类型，如果为空并且exclude为空，则会重试所有异常，与include同义。include：与value同义。exclude：不需要重试的异常。label：分析报告的名称，listener相关使用。stateful：是否有状态重试，有的话指定的异常要抛出而不是重试。maxAttempts：最大重试次数。maxAttemptsExpression：最大重试次数表达式。backoff：退避策略，详见BackOff注解。exceptionExpression：异常表达式，要抛出的异常（有状态情况下）的表达式。</code></pre><h3 id="Backoff"><a href="#Backoff" class="headerlink" title="Backoff"></a>Backoff</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Import</span>(RetryConfiguration.class)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Backoff &#123;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> 1000</span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">delay</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">maxDelay</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">multiplier</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line"><span class="function">String <span class="title">delayExpression</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"><span class="function">String <span class="title">maxDelayExpression</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"><span class="function">String <span class="title">multiplierExpression</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">random</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>退避策略注解，使用方式见上面Retryable的backoff值。</p><p>主要参数说明：</p><pre><code>value：退避间隔，和delay同义。delay：与value同义。在随机退避策略里表示最小值，在指数退避策略和随机指数退避策略里表示起始值。maxDelay：在随机退避策略里表示最大值，在指数退避策略和随机指数退避策略里表示最大值。multiplier：指数因子。delayExpression：退避间隔表达式。maxDelayExpression：最大值表达式。multiplierExpression：指数因子表达式。random：是否随机。</code></pre><p>可以看到，如果什么也不设置，将使用NoBackOffPolicy。如果只设置value或者delay值，将使用FixedBackOffPolicy。如果还设置了maxDelay和random，将使用UniformRandomBackOffPolicy……</p><h3 id="CircuitBreaker"><a href="#CircuitBreaker" class="headerlink" title="CircuitBreaker"></a>CircuitBreaker</h3><p>熔断注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123; ElementType.METHOD, ElementType.TYPE &#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retryable</span>(stateful = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CircuitBreaker &#123;</span><br><span class="line">Class&lt;? extends Throwable&gt;[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">Class&lt;? extends Throwable&gt;[] include() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">Class&lt;? extends Throwable&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxAttempts</span><span class="params">()</span> <span class="keyword">default</span> 3</span>;</span><br><span class="line"><span class="function">String <span class="title">label</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">resetTimeout</span><span class="params">()</span> <span class="keyword">default</span> 20000</span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">openTimeout</span><span class="params">()</span> <span class="keyword">default</span> 5000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要参数与上面说的Retryable基本说明一样，它的其它两个参数resetTimeout和openTimeout上面已经讲过。</p><h3 id="Recover"><a href="#Recover" class="headerlink" title="Recover"></a>Recover</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123; ElementType.METHOD, ElementType.TYPE &#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Import</span>(RetryConfiguration.class)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Recover &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个注解也作用于方法上，表示所有重试失败后兜底的返回信息，这个作用的方法，应该有以下特性：</p><ul><li>第一个参数是重试的程序抛出的异常（需要重试的异常）。</li><li>后面的参数应该与Retryable注释的入参一致，返回值也应一致。</li><li>第一个参数可选，但是如果不写，需要保证Retryable在没有其他的Recover匹配的情况下才会被调用。</li></ul><p>我们使用注解来简单写个例子，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@EnableRetry</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Retryable</span>(value = Exception.class,maxAttempts = <span class="number">5</span>,backoff = <span class="meta">@Backoff</span>(<span class="number">2000L</span>))</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">retryTest</span><span class="params">(String str1,Integer integer1)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isBlank(str1))&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"str1参数为空！！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(integer1==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"integer1参数不正确！！！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str1+integer1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Recover</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">recover</span><span class="params">(Exception e,String str1,Integer integer1)</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">"所有重试均失败，返回兜底值"</span>,e);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们创建了一个重试方法，这个方法最多重试5次，每重试一次之前都会退避2s后再进行，重试所有异常，当所有重试均不成功后会返回兜底值””。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过对Spring Retry框架的理解，我们对重试框架有了一个更全面的认识，了解了它的一些简单实现原理，明白了它的一些关键参数。如果有方法有重试需求，可以适当进行Spring Retry框架的考虑。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="SpringRetry" scheme="https://www.sakuratears.top/tags/SpringRetry/"/>
    
  </entry>
  
  <entry>
    <title>Java将文件上传到云服务器</title>
    <link href="https://www.sakuratears.top/blog/Java%E5%B0%86%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%88%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8.html"/>
    <id>https://www.sakuratears.top/blog/Java将文件上传到云服务器.html</id>
    <published>2019-05-20T13:50:00.000Z</published>
    <updated>2019-06-09T02:49:46.639Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天总结了一个云上传的小demo特地来跟大家分享下。</p><p>这个demo可以将一些文件上传到云服务器。我们来看下吧。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>我这里使用了阿里云、亚马逊S3和微软Azure这三种云上传做的demo。</p><p>要使用云上传，我们需要引入相关jar包，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--阿里云OSS--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--微软Azure--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.microsoft.azure&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;azure-storage&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;7.0.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--亚马逊S3--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.amazonaws&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;aws-java-sdk&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.8.9.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- 腾讯云cos --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.qcloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cos_api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.5.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>PS:如果只使用一种云上传方式，引入对应的jar包即可，不必全部引入。</p><p>我们可以提供一个通用的上传接口upload，而具体的上传逻辑让各个实现类去实现。</p><p>同时我们暴露公共方法出来供上传使用。</p><p>上传的文件有可能是本地文件，也有可能是前端传过来的Base64图片字符串，也有可能是MultipartFile等。</p><p>我们提供一个抽象的上传方法，大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">UploadAbstractUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(UploadAbstractUtil.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件缓存路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String basedir;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UploadAbstractUtil</span><span class="params">(String basedir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.basedir = basedir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上传文件到云</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tempFile</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> realName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">upload</span><span class="params">(File tempFile, String realName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上传文件到云</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> String <span class="title">upload</span><span class="params">(MultipartFile file)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上传文件到云</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> contentType</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">upload</span><span class="params">(<span class="keyword">byte</span>[] bytes,String contentType)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试初始化客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initClient</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成一个唯一的上传文件名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">generateUploadFileName</span><span class="params">(MultipartFile file)</span></span>&#123;</span><br><span class="line">        String name = file.getOriginalFilename();</span><br><span class="line">        String ext = name.substring(name.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line">        String uuid = UUID.randomUUID().toString();</span><br><span class="line">        <span class="comment">// 生成唯一的key</span></span><br><span class="line">        <span class="keyword">return</span> uuid + ext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * base64转为文件后在进行上传</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> base64Str</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">base64UploadUseTempFile</span><span class="params">(String base64Str)</span></span>&#123;</span><br><span class="line">        String realName = UUID.randomUUID().toString() + <span class="string">".jpg"</span>;</span><br><span class="line">        File file = <span class="keyword">new</span> File(basedir + <span class="string">"/"</span> + realName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                file.createNewFile();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                logger.error(<span class="string">"文件上传，尝试创建文件时失败！！！"</span>,e);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"文件上传失败！！！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> flag = Base64Utils.Base64ToImage(base64Str, file.getPath());</span><br><span class="line">        <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"base64转换为文件时发生错误！！！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String url;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">            url = upload(file, realName);</span><br><span class="line">            logger.info(<span class="string">"tempFile---上传服务耗时------time:[&#123;&#125;ms]"</span>, System.currentTimeMillis()-startTime);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">"文件上传，上传文件时发生异常！！！"</span>,e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"文件上传失败!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">            file.delete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通用文件上传</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath 文件路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">fileUpload</span><span class="params">(String filePath)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isBlank(filePath))&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"请输入正确的文件路径！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        File file = <span class="keyword">new</span> File(filePath);</span><br><span class="line">        <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"请输入正确的文件路径！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> position = filePath.lastIndexOf(<span class="string">"."</span>);</span><br><span class="line">        String fileSuffix = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(position &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            fileSuffix = filePath.substring(position);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//上传到云上的文件名</span></span><br><span class="line">        String realName = UUID.randomUUID().toString() + fileSuffix;</span><br><span class="line">        String url;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">            url = upload(file, realName);</span><br><span class="line">            logger.info(<span class="string">"filePath---上传服务耗时------time:[&#123;&#125;ms]"</span>, System.currentTimeMillis()-startTime);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">"文件上传，上传文件时发生异常！！！"</span>,e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"文件上传失败!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用流来进行文件上传</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> base64Str</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">base64UploadUseInputStream</span><span class="params">(String base64Str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = Base64Utils.Base64ToByte(base64Str);</span><br><span class="line">        String url;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">            url = upload(bytes,<span class="string">"image/jpeg"</span>);</span><br><span class="line">            logger.info(<span class="string">"Stream---上传服务耗时------time:[&#123;&#125;ms]"</span>, System.currentTimeMillis()-startTime);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">"文件上传，上传文件时发生异常！！！"</span>,e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"文件上传失败!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS： 这个类看着比较多……其实都是对文件进行处理，生成上传文件名，然后交给上传方法，开始写的时候代码较少，在学习优化的过程中不断添加新功能，导致了该结果。</p><p>上面的上传抽象类大致逻辑如下：</p><p>针对图片文件：</p><ul><li>如果在服务器上的，可以直接获取到文件后进行上传。（fileUpload方法）</li><li>如果APP端传过来的Base64编码的图片文件，可以把它生成临时文件，然后进行上传，也可以直接把Base64转换为流后进行上传。（base64UploadUseTempFile方法和base64UploadUseInputStream方法）</li><li>如果APP端传过来MultipartFile文件，直接将其进行转换并上传。（upload(MultipartFile file)方法）</li></ul><p>对于每种云上传，各个实现类具体如下：</p><h2 id="阿里云OSS"><a href="#阿里云OSS" class="headerlink" title="阿里云OSS"></a>阿里云OSS</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AliOssUploadUtil</span> <span class="keyword">extends</span> <span class="title">UploadAbstractUtil</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(AliOssUploadUtil.class);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阿里云accessKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String aliyunaccessKey;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阿里云secretKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String aliyunsecretKey;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阿里云endpoint</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String aliyunendpoint;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阿里云endpointexternal</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String aliyunendpointexternal;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阿里云bucket</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String aliyunbucket;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ossClient</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> OSSClient ossClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> basedir</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> aliyunaccessKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> aliyunsecretKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> aliyunendpoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> aliyunendpointexternal</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> aliyunbucket</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AliOssUploadUtil</span><span class="params">(String basedir, String aliyunaccessKey, String aliyunsecretKey, String aliyunendpoint, String aliyunendpointexternal, String aliyunbucket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(basedir);</span><br><span class="line">        <span class="keyword">this</span>.aliyunaccessKey = aliyunaccessKey;</span><br><span class="line">        <span class="keyword">this</span>.aliyunsecretKey = aliyunsecretKey;</span><br><span class="line">        <span class="keyword">this</span>.aliyunendpoint = aliyunendpoint;</span><br><span class="line">        <span class="keyword">this</span>.aliyunendpointexternal = aliyunendpointexternal;</span><br><span class="line">        <span class="keyword">this</span>.aliyunbucket = aliyunbucket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阿里云文件上传</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tempFile</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> realName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">upload</span><span class="params">(File tempFile,String realName)</span></span>&#123;</span><br><span class="line">        initClient();</span><br><span class="line">        ossClient.putObject(aliyunbucket, realName, tempFile);</span><br><span class="line">        URL url = ossClient.generatePresignedUrl(aliyunbucket, realName, <span class="keyword">new</span> Date(System.currentTimeMillis() + <span class="number">3600L</span> * <span class="number">1000</span> * <span class="number">24</span> * <span class="number">365</span> * <span class="number">100</span>));</span><br><span class="line">        String urlString = String.valueOf(url).split(<span class="string">"\\?"</span>)[<span class="number">0</span>];</span><br><span class="line">        logger.info(<span class="string">"阿里云OSS上传服务------图片内网url:[&#123;&#125;]"</span>, urlString);</span><br><span class="line">        urlString = urlString.replaceAll(aliyunendpoint, aliyunendpointexternal);</span><br><span class="line">        logger.info(<span class="string">"阿里云OSS上传服务------图片外网url:[&#123;&#125;]"</span>, urlString);</span><br><span class="line">        <span class="keyword">return</span> urlString;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阿里云文件上传</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">upload</span><span class="params">(MultipartFile file)</span> </span>&#123;</span><br><span class="line">        initClient();</span><br><span class="line">        String key = generateUploadFileName(file);</span><br><span class="line">        <span class="keyword">try</span> (InputStream is = <span class="keyword">new</span> ByteArrayInputStream(file.getBytes())) &#123;</span><br><span class="line">            ObjectMetadata metadata = <span class="keyword">new</span> ObjectMetadata();</span><br><span class="line">            metadata.setContentEncoding(StandardCharsets.UTF_8.name());</span><br><span class="line">            metadata.setContentLength(file.getSize());</span><br><span class="line">            metadata.setContentType(file.getContentType());</span><br><span class="line">            <span class="comment">// 上传</span></span><br><span class="line">            ossClient.putObject(aliyunbucket,key, is, metadata);</span><br><span class="line">            URL url = ossClient.generatePresignedUrl(aliyunbucket, key, <span class="keyword">new</span> Date(System.currentTimeMillis() + <span class="number">3600L</span> * <span class="number">1000</span> * <span class="number">24</span> * <span class="number">365</span> * <span class="number">100</span>));</span><br><span class="line">            String urlString = String.valueOf(url).split(<span class="string">"\\?"</span>)[<span class="number">0</span>];</span><br><span class="line">            logger.info(<span class="string">"阿里云OSS上传服务------图片内网url:[&#123;&#125;]"</span>, urlString);</span><br><span class="line">            urlString = urlString.replaceAll(aliyunendpoint, aliyunendpointexternal);</span><br><span class="line">            logger.info(<span class="string">"阿里云OSS上传服务------图片外网url:[&#123;&#125;]"</span>, urlString);</span><br><span class="line">            <span class="keyword">return</span> urlString;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            logger.error(<span class="string">"使用阿里云OSS上传文件出现异常"</span>,e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试初始化client</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ossClient == <span class="keyword">null</span>)&#123;</span><br><span class="line">            ossClient = <span class="keyword">new</span> OSSClient(aliyunendpoint, aliyunaccessKey, aliyunsecretKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">upload</span><span class="params">(<span class="keyword">byte</span>[] bytes, String contentType)</span> </span>&#123;</span><br><span class="line">        initClient();</span><br><span class="line">        String realName = UUID.randomUUID().toString() + <span class="string">".jpg"</span>;</span><br><span class="line">        <span class="keyword">try</span> (InputStream is = <span class="keyword">new</span> ByteArrayInputStream(bytes)) &#123;</span><br><span class="line">            ObjectMetadata metadata = <span class="keyword">new</span> ObjectMetadata();</span><br><span class="line">            metadata.setContentEncoding(StandardCharsets.UTF_8.name());</span><br><span class="line">            metadata.setContentLength(is.available());</span><br><span class="line">            metadata.setContentType(contentType);</span><br><span class="line">            <span class="comment">// 上传</span></span><br><span class="line">            ossClient.putObject(aliyunbucket,realName, is, metadata);</span><br><span class="line">            URL url = ossClient.generatePresignedUrl(aliyunbucket, realName, <span class="keyword">new</span> Date(System.currentTimeMillis() + <span class="number">3600L</span> * <span class="number">1000</span> * <span class="number">24</span> * <span class="number">365</span> * <span class="number">100</span>));</span><br><span class="line">            String urlString = String.valueOf(url).split(<span class="string">"\\?"</span>)[<span class="number">0</span>];</span><br><span class="line">            logger.info(<span class="string">"阿里云OSS上传服务------图片内网url:[&#123;&#125;]"</span>, urlString);</span><br><span class="line">            urlString = urlString.replaceAll(aliyunendpoint, aliyunendpointexternal);</span><br><span class="line">            logger.info(<span class="string">"阿里云OSS上传服务------图片外网url:[&#123;&#125;]"</span>, urlString);</span><br><span class="line">            <span class="keyword">return</span> urlString;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            logger.error(<span class="string">"使用阿里云OSS上传文件出现异常"</span>,e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * shutdown Client</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ossClient.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="亚马逊S3"><a href="#亚马逊S3" class="headerlink" title="亚马逊S3"></a>亚马逊S3</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmazonS3UploadUtil</span> <span class="keyword">extends</span> <span class="title">UploadAbstractUtil</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * S3 accessKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String s3accessKey;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  S3 secretKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String s3secretKey;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * S3 endpoint</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String s3endpoint;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * S3 bucket</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String s3bucket;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 协议</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Protocol protocol = Protocol.HTTP;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 亚马逊s3 client</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> AmazonS3 client;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> basedir</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s3accessKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s3secretKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s3endpoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s3bucket</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AmazonS3UploadUtil</span><span class="params">(String basedir, String s3accessKey, String s3secretKey, String s3endpoint, String s3bucket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(basedir);</span><br><span class="line">        <span class="keyword">this</span>.s3accessKey = s3accessKey;</span><br><span class="line">        <span class="keyword">this</span>.s3secretKey = s3secretKey;</span><br><span class="line">        <span class="keyword">this</span>.s3endpoint = s3endpoint;</span><br><span class="line">        <span class="keyword">this</span>.s3bucket = s3bucket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上传文件到 Amazon S3</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tempFile</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> realName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">upload</span><span class="params">(File tempFile, String realName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            initClient();</span><br><span class="line">            client.setEndpoint(s3endpoint);</span><br><span class="line">            client.setS3ClientOptions(<span class="keyword">new</span> S3ClientOptions().withPathStyleAccess(<span class="keyword">true</span>));</span><br><span class="line">            client.putObject(<span class="keyword">new</span> PutObjectRequest(s3bucket, realName, tempFile)</span><br><span class="line">                    .withCannedAcl(CannedAccessControlList.AuthenticatedRead));</span><br><span class="line">            String imageUrl = <span class="string">"http://"</span> + s3endpoint + <span class="string">"/"</span> + s3bucket + <span class="string">"/"</span> + realName;</span><br><span class="line">            logger.info(<span class="string">"亚马逊S3上传服务------图片url:[&#123;&#125;]"</span>, imageUrl);</span><br><span class="line">            <span class="keyword">return</span> imageUrl;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AmazonClientException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"使用亚马逊S3上传文件出现异常"</span>,e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上传文件到S3</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">upload</span><span class="params">(MultipartFile file)</span> </span>&#123;</span><br><span class="line">        initClient();</span><br><span class="line">        String key = generateUploadFileName(file);</span><br><span class="line">        <span class="keyword">try</span> (InputStream is = <span class="keyword">new</span> ByteArrayInputStream(file.getBytes()))&#123;</span><br><span class="line">            ObjectMetadata metadata = <span class="keyword">new</span> ObjectMetadata();</span><br><span class="line">            metadata.setContentEncoding(StandardCharsets.UTF_8.name());</span><br><span class="line">            metadata.setContentLength(file.getSize());</span><br><span class="line">            metadata.setContentType(file.getContentType());</span><br><span class="line">            PutObjectRequest mall = <span class="keyword">new</span> PutObjectRequest(s3bucket, key, is, metadata)</span><br><span class="line">                    .withCannedAcl(CannedAccessControlList.AuthenticatedRead);</span><br><span class="line">            <span class="comment">// 上传</span></span><br><span class="line">            client.putObject(mall);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"http://"</span> + s3endpoint + <span class="string">"/"</span> + s3bucket + <span class="string">"/"</span> + key;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            logger.error(<span class="string">"使用亚马逊S3上传文件出现异常"</span>,e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试初始化S3Client</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(client == <span class="keyword">null</span>)&#123;</span><br><span class="line">            AWSCredentials credential = <span class="keyword">new</span> BasicAWSCredentials(s3accessKey, s3secretKey);</span><br><span class="line">            ClientConfiguration clientConfig = <span class="keyword">new</span> ClientConfiguration();</span><br><span class="line">            clientConfig.setProtocol(protocol);</span><br><span class="line">            client = <span class="keyword">new</span> AmazonS3Client(credential, clientConfig);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">upload</span><span class="params">(<span class="keyword">byte</span>[] bytes, String contentType)</span> </span>&#123;</span><br><span class="line">        initClient();</span><br><span class="line">        String realName = UUID.randomUUID().toString() + <span class="string">".jpg"</span>;</span><br><span class="line">        <span class="keyword">try</span> (InputStream is = <span class="keyword">new</span> ByteArrayInputStream(bytes))&#123;</span><br><span class="line">            ObjectMetadata metadata = <span class="keyword">new</span> ObjectMetadata();</span><br><span class="line">            metadata.setContentEncoding(StandardCharsets.UTF_8.name());</span><br><span class="line">            metadata.setContentLength(is.available());</span><br><span class="line">            metadata.setContentType(contentType);</span><br><span class="line">            PutObjectRequest mall = <span class="keyword">new</span> PutObjectRequest(s3bucket, realName, is, metadata)</span><br><span class="line">                    .withCannedAcl(CannedAccessControlList.AuthenticatedRead);</span><br><span class="line">            <span class="comment">// 上传</span></span><br><span class="line">            client.putObject(mall);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"http://"</span> + s3endpoint + <span class="string">"/"</span> + s3bucket + <span class="string">"/"</span> + realName;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            logger.error(<span class="string">"使用亚马逊S3上传文件出现异常"</span>,e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="微软Azure"><a href="#微软Azure" class="headerlink" title="微软Azure"></a>微软Azure</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AzureUploadUtil</span> <span class="keyword">extends</span> <span class="title">UploadAbstractUtil</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span>  String accountName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 密码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span>  String accountKey;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * endPoint</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span>  String endPoint;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * containerName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span>  String containerName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String storageConnectionString;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Azure client</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> CloudBlobClient blobClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> accountName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> accountKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> endPoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> containerName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AzureUploadUtil</span><span class="params">(String basedir,String accountName, String accountKey, String endPoint, String containerName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(basedir);</span><br><span class="line">        <span class="keyword">this</span>.accountName = accountName;</span><br><span class="line">        <span class="keyword">this</span>.accountKey = accountKey;</span><br><span class="line">        <span class="keyword">this</span>.endPoint = endPoint;</span><br><span class="line">        <span class="keyword">this</span>.containerName = containerName;</span><br><span class="line">        <span class="keyword">this</span>.storageConnectionString = <span class="string">"DefaultEndpointsProtocol=https;AccountName="</span>+ accountName +<span class="string">";AccountKey="</span>+ accountKey +<span class="string">";EndpointSuffix="</span> + endPoint;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上传文件到Azure</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">upload</span><span class="params">(File tempFile,String realName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            initClient();</span><br><span class="line">            CloudBlobContainer container = blobClient.getContainerReference(containerName);</span><br><span class="line">            <span class="comment">// Create the container if it does not exist with public access.</span></span><br><span class="line">            container.createIfNotExists(BlobContainerPublicAccessType.CONTAINER, <span class="keyword">new</span> BlobRequestOptions(), <span class="keyword">new</span> OperationContext());</span><br><span class="line">            <span class="comment">//Getting a blob reference</span></span><br><span class="line">            CloudBlockBlob blob = container.getBlockBlobReference(tempFile.getName());</span><br><span class="line">            <span class="comment">//Creating blob and uploading file to it</span></span><br><span class="line">            blob.uploadFromFile(tempFile.getAbsolutePath());</span><br><span class="line">            String imageUrl = <span class="string">"https://"</span>+ accountName +<span class="string">".blob."</span>+ endPoint +<span class="string">"/"</span>+ containerName +<span class="string">"/"</span> + tempFile.getName();</span><br><span class="line">            logger.info(<span class="string">"微软Azure上传服务------图片url:[&#123;&#125;]"</span>, imageUrl);</span><br><span class="line">            <span class="keyword">return</span> imageUrl;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException| StorageException | URISyntaxException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"使用微软Azure上传文件出现异常"</span>,e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上传文件到Azure</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">upload</span><span class="params">(MultipartFile file)</span> </span>&#123;</span><br><span class="line">        initClient();</span><br><span class="line">        String key = generateUploadFileName(file);</span><br><span class="line">        <span class="keyword">try</span>(InputStream is = <span class="keyword">new</span> ByteArrayInputStream(file.getBytes()))&#123;</span><br><span class="line">            CloudBlobContainer container = blobClient.getContainerReference(containerName);</span><br><span class="line">            <span class="comment">// Create the container if it does not exist with public access.</span></span><br><span class="line">            container.createIfNotExists(BlobContainerPublicAccessType.CONTAINER, <span class="keyword">new</span> BlobRequestOptions(), <span class="keyword">new</span> OperationContext());</span><br><span class="line">            CloudBlockBlob blob = container.getBlockBlobReference(key);</span><br><span class="line">            <span class="comment">//Creating blob and uploading file to it</span></span><br><span class="line">            blob.upload(is, is.available());</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"https://"</span>+ accountName +<span class="string">".blob."</span>+ endPoint +<span class="string">"/"</span>+ containerName +<span class="string">"/"</span> + key;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException| StorageException | URISyntaxException e)&#123;</span><br><span class="line">            logger.error(<span class="string">"使用微软Azure上传文件出现异常"</span>,e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试初始化client</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(blobClient == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                CloudStorageAccount storageAccount = CloudStorageAccount.parse(storageConnectionString);</span><br><span class="line">                blobClient = storageAccount.createCloudBlobClient();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (URISyntaxException|InvalidKeyException e)&#123;</span><br><span class="line">                logger.error(<span class="string">"使用微软Azure初始化client失败！"</span>,e);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">upload</span><span class="params">(<span class="keyword">byte</span>[] bytes, String contentType)</span> </span>&#123;</span><br><span class="line">        initClient();</span><br><span class="line">        String realName = UUID.randomUUID().toString() + <span class="string">".jpg"</span>;</span><br><span class="line">        <span class="keyword">try</span>(InputStream is = <span class="keyword">new</span> ByteArrayInputStream(bytes))&#123;</span><br><span class="line">            CloudBlobContainer container = blobClient.getContainerReference(containerName);</span><br><span class="line">            <span class="comment">// Create the container if it does not exist with public access.</span></span><br><span class="line">            container.createIfNotExists(BlobContainerPublicAccessType.CONTAINER, <span class="keyword">new</span> BlobRequestOptions(), <span class="keyword">new</span> OperationContext());</span><br><span class="line">            CloudBlockBlob blob = container.getBlockBlobReference(realName);</span><br><span class="line">            <span class="comment">//Creating blob and uploading file to it</span></span><br><span class="line">            blob.upload(is, is.available());</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"https://"</span>+ accountName +<span class="string">".blob."</span>+ endPoint +<span class="string">"/"</span>+ containerName +<span class="string">"/"</span> + realName;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException| StorageException | URISyntaxException e)&#123;</span><br><span class="line">            logger.error(<span class="string">"使用微软Azure上传文件出现异常"</span>,e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="腾讯云COS"><a href="#腾讯云COS" class="headerlink" title="腾讯云COS"></a>腾讯云COS</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TencentCOSUploadUtil</span> <span class="keyword">extends</span> <span class="title">UploadAbstractUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(TencentCOSUploadUtil.class);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 腾讯云COS AccessKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String qAccessKey;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 腾讯云COS SecretKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String qSecretKey;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 腾讯云COS bucket</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String qBucket;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 腾讯云COS region</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String qRegion;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 腾讯云COS qEndpoint</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String qEndpoint;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 腾讯云COS qEndpointExternal</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String qEndpointExternal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * COSClient</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> COSClient cosClient;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TencentCOSUploadUtil</span><span class="params">(String basedir, String qAccessKey, String qSecretKey, String qBucket, String qRegion, String qEndpoint, String qEndpointExternal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(basedir);</span><br><span class="line">        <span class="keyword">this</span>.qAccessKey = qAccessKey;</span><br><span class="line">        <span class="keyword">this</span>.qSecretKey = qSecretKey;</span><br><span class="line">        <span class="keyword">this</span>.qBucket = qBucket;</span><br><span class="line">        <span class="keyword">this</span>.qRegion = qRegion;</span><br><span class="line">        <span class="keyword">this</span>.qEndpoint = qEndpoint;</span><br><span class="line">        <span class="keyword">this</span>.qEndpointExternal = qEndpointExternal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">upload</span><span class="params">(File tempFile, String realName)</span> </span>&#123;</span><br><span class="line">        initClient();</span><br><span class="line">        cosClient.putObject(qBucket,realName,tempFile);</span><br><span class="line">        URL url =cosClient.generatePresignedUrl(qBucket, realName, <span class="keyword">new</span> Date(System.currentTimeMillis() + <span class="number">3600L</span> * <span class="number">1000</span> * <span class="number">24</span> * <span class="number">365</span> * <span class="number">100</span>));</span><br><span class="line">        String urlString = String.valueOf(url).split(<span class="string">"\\?"</span>)[<span class="number">0</span>];</span><br><span class="line">        logger.info(<span class="string">"腾讯云COS上传服务------图片内网url:[&#123;&#125;]"</span>, urlString);</span><br><span class="line">        urlString = urlString.replaceAll(qEndpoint, qEndpointExternal);</span><br><span class="line">        logger.info(<span class="string">"腾讯云COS上传服务------图片外网url:[&#123;&#125;]"</span>, urlString);</span><br><span class="line">        <span class="keyword">return</span> urlString;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">upload</span><span class="params">(MultipartFile file)</span> </span>&#123;</span><br><span class="line">        initClient();</span><br><span class="line">        String key = generateUploadFileName(file);</span><br><span class="line">        <span class="keyword">try</span> (InputStream is = <span class="keyword">new</span> ByteArrayInputStream(file.getBytes())) &#123;</span><br><span class="line">            ObjectMetadata metadata = <span class="keyword">new</span> ObjectMetadata();</span><br><span class="line">            metadata.setContentEncoding(StandardCharsets.UTF_8.name());</span><br><span class="line">            metadata.setContentLength(file.getSize());</span><br><span class="line">            metadata.setContentType(file.getContentType());</span><br><span class="line">            <span class="comment">// 上传</span></span><br><span class="line">            cosClient.putObject(qBucket,key, is, metadata);</span><br><span class="line">            URL url = cosClient.generatePresignedUrl(qBucket, key, <span class="keyword">new</span> Date(System.currentTimeMillis() + <span class="number">3600L</span> * <span class="number">1000</span> * <span class="number">24</span> * <span class="number">365</span> * <span class="number">100</span>));</span><br><span class="line">            String urlString = String.valueOf(url).split(<span class="string">"\\?"</span>)[<span class="number">0</span>];</span><br><span class="line">            logger.info(<span class="string">"腾讯云COS上传服务------图片内网url:[&#123;&#125;]"</span>, urlString);</span><br><span class="line">            urlString = urlString.replaceAll(qEndpoint, qEndpointExternal);</span><br><span class="line">            logger.info(<span class="string">"腾讯云COS上传服务------图片外网url:[&#123;&#125;]"</span>, urlString);</span><br><span class="line">            <span class="keyword">return</span> urlString;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            logger.error(<span class="string">"使用腾讯云COS上传文件出现异常"</span>,e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">upload</span><span class="params">(<span class="keyword">byte</span>[] bytes, String contentType)</span> </span>&#123;</span><br><span class="line">        initClient();</span><br><span class="line">        String realName = UUID.randomUUID().toString() + <span class="string">".jpg"</span>;</span><br><span class="line">        <span class="keyword">try</span> (InputStream is = <span class="keyword">new</span> ByteArrayInputStream(bytes)) &#123;</span><br><span class="line">            ObjectMetadata metadata = <span class="keyword">new</span> ObjectMetadata();</span><br><span class="line">            metadata.setContentEncoding(StandardCharsets.UTF_8.name());</span><br><span class="line">            metadata.setContentLength(is.available());</span><br><span class="line">            metadata.setContentType(contentType);</span><br><span class="line">            <span class="comment">// 上传</span></span><br><span class="line">            cosClient.putObject(qBucket,realName, is, metadata);</span><br><span class="line">            URL url = cosClient.generatePresignedUrl(qBucket, realName, <span class="keyword">new</span> Date(System.currentTimeMillis() + <span class="number">3600L</span> * <span class="number">1000</span> * <span class="number">24</span> * <span class="number">365</span> * <span class="number">100</span>));</span><br><span class="line">            String urlString = String.valueOf(url).split(<span class="string">"\\?"</span>)[<span class="number">0</span>];</span><br><span class="line">            logger.info(<span class="string">"腾讯云COS上传服务------图片内网url:[&#123;&#125;]"</span>, urlString);</span><br><span class="line">            urlString = urlString.replaceAll(qEndpoint, qEndpointExternal);</span><br><span class="line">            logger.info(<span class="string">"腾讯云COS上传服务------图片外网url:[&#123;&#125;]"</span>, urlString);</span><br><span class="line">            <span class="keyword">return</span> urlString;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            logger.error(<span class="string">"使用腾讯云COS上传文件出现异常"</span>,e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>: 初始化COSCilent</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2019/6/2 9:42 AM</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Params</span>: []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Return</span>: void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cosClient==<span class="keyword">null</span>)&#123;</span><br><span class="line">            COSCredentials cosCredentials = <span class="keyword">new</span> BasicCOSCredentials(qAccessKey,qSecretKey);</span><br><span class="line">            ClientConfig clientConfig = <span class="keyword">new</span> ClientConfig(<span class="keyword">new</span> Region(qRegion));</span><br><span class="line">            cosClient = <span class="keyword">new</span> COSClient(cosCredentials,clientConfig);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * shutdown Client</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cosClient.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用到的相关工具类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * base64字符串转换成图片</span></span><br><span class="line"><span class="comment"> * 对字节数组字符串进行Base64解码并生成图片</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> imgStrbase64字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> imgFilePath图片存放路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">Base64ToImage</span><span class="params">(String imgStr,String imgFilePath)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 图像数据为空</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(imgStr)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果包含 data:image/jpeg;base64, 前缀需要去掉</span></span><br><span class="line">    <span class="keyword">if</span>(imgStr.contains(<span class="string">","</span>))&#123;</span><br><span class="line">        imgStr = imgStr.split(<span class="string">","</span>)[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    BASE64Decoder decoder = <span class="keyword">new</span> BASE64Decoder();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Base64解码</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = decoder.decodeBuffer(imgStr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.length; ++i) &#123;</span><br><span class="line">            <span class="comment">// 调整异常数据</span></span><br><span class="line">            <span class="keyword">if</span> (b[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                b[i] += <span class="number">256</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        OutputStream out = <span class="keyword">new</span> FileOutputStream(imgFilePath);</span><br><span class="line">        out.write(b);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合SpringBoot，引入自动配置，生成相关上传Bean，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OssUtilsConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;file.cache.dir&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String basedir;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;file.upload.server.type&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String uploadServerType;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 亚马逊S3配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String s3accessKey;</span><br><span class="line">    <span class="keyword">private</span> String s3secretKey;</span><br><span class="line">    <span class="keyword">private</span> String s3endpoint;</span><br><span class="line">    <span class="keyword">private</span> String s3bucket;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阿里云OSS配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String aliyunAccessKey;</span><br><span class="line">    <span class="keyword">private</span> String aliyunSecretKey;</span><br><span class="line">    <span class="keyword">private</span> String aliyunBucket;</span><br><span class="line">    <span class="keyword">private</span> String aliyunEndpoint;</span><br><span class="line">    <span class="keyword">private</span> String aliyunEndpointexternal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 微软Azure配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String azureAccountName;</span><br><span class="line">    <span class="keyword">private</span> String azureAccountKey;</span><br><span class="line">    <span class="keyword">private</span> String azureEndpointSuffix;</span><br><span class="line">    <span class="keyword">private</span> String azureContainerName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 腾讯云COS配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String qAccessKey;</span><br><span class="line">    <span class="keyword">private</span> String qSecretKey;</span><br><span class="line">    <span class="keyword">private</span> String qBucket;</span><br><span class="line">    <span class="keyword">private</span> String qRegion;</span><br><span class="line">    <span class="keyword">private</span> String qEndpoint;</span><br><span class="line">    <span class="keyword">private</span> String qEndpointExternal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据配置的 file.upload.server.type 选择一个上传服务器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UploadAbstractUtil <span class="title">uploadAbstractUtil</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//可以根据枚举进行配置 使用阿里云或者亚马逊S3或者Azure</span></span><br><span class="line">        UploadServerEnum uploadServerEnum = UploadServerEnum.getEnum(uploadServerType);</span><br><span class="line">        UploadAbstractUtil uploadAbstractUtil;</span><br><span class="line">        <span class="keyword">switch</span> (uploadServerEnum)&#123;</span><br><span class="line">            <span class="comment">//亚马逊s3</span></span><br><span class="line">            <span class="keyword">case</span> AMAZON:</span><br><span class="line">                s3accessKey = environment.getRequiredProperty(<span class="string">"s3.accessKey"</span>);</span><br><span class="line">                s3secretKey = environment.getRequiredProperty(<span class="string">"s3.secretKey"</span>);</span><br><span class="line">                s3endpoint = environment.getRequiredProperty(<span class="string">"s3.endpoint"</span>);</span><br><span class="line">                s3bucket = environment.getRequiredProperty(<span class="string">"s3.bucket"</span>);</span><br><span class="line">                uploadAbstractUtil = <span class="keyword">new</span> AmazonS3UploadUtil(basedir,s3accessKey,s3secretKey,s3endpoint,s3bucket);</span><br><span class="line">                <span class="keyword">return</span> uploadAbstractUtil;</span><br><span class="line">            <span class="comment">//阿里云OSS</span></span><br><span class="line">            <span class="keyword">case</span> ALIOSS:</span><br><span class="line">                aliyunAccessKey = environment.getRequiredProperty(<span class="string">"aliyun.accessKey"</span>);</span><br><span class="line">                aliyunSecretKey = environment.getRequiredProperty(<span class="string">"aliyun.secretKey"</span>);</span><br><span class="line">                aliyunBucket = environment.getRequiredProperty(<span class="string">"aliyun.bucket"</span>);</span><br><span class="line">                aliyunEndpoint = environment.getRequiredProperty(<span class="string">"aliyun.endpoint"</span>);</span><br><span class="line">                aliyunEndpointexternal = environment.getRequiredProperty(<span class="string">"aliyun.endpointexternal"</span>);</span><br><span class="line">                uploadAbstractUtil = <span class="keyword">new</span> AliOssUploadUtil(basedir,aliyunAccessKey,aliyunSecretKey,aliyunEndpoint,aliyunEndpointexternal,aliyunBucket);</span><br><span class="line">                <span class="keyword">return</span> uploadAbstractUtil;</span><br><span class="line">            <span class="comment">//微软Azure</span></span><br><span class="line">            <span class="keyword">case</span> AZURE:</span><br><span class="line">                azureAccountName = environment.getRequiredProperty(<span class="string">"azure.accountName"</span>);</span><br><span class="line">                azureAccountKey = environment.getRequiredProperty(<span class="string">"azure.accountKey"</span>);</span><br><span class="line">                azureEndpointSuffix = environment.getRequiredProperty(<span class="string">"azure.endpointSuffix"</span>);</span><br><span class="line">                azureContainerName = environment.getRequiredProperty(<span class="string">"azure.containerName"</span>);</span><br><span class="line">                uploadAbstractUtil = <span class="keyword">new</span> AzureUploadUtil(basedir,azureAccountName,azureAccountKey,azureEndpointSuffix,azureContainerName);</span><br><span class="line">                <span class="keyword">return</span> uploadAbstractUtil;</span><br><span class="line">            <span class="keyword">case</span> TENCENTCOS:</span><br><span class="line">                qAccessKey = environment.getRequiredProperty(<span class="string">"tencent.accessKey"</span>);</span><br><span class="line">                qSecretKey = environment.getRequiredProperty(<span class="string">"tencent.secretKey"</span>);</span><br><span class="line">                qBucket = environment.getRequiredProperty(<span class="string">"tencent.bucket"</span>);</span><br><span class="line">                qEndpoint = environment.getRequiredProperty(<span class="string">"tencent.endpoint"</span>);</span><br><span class="line">                qRegion = environment.getRequiredProperty(<span class="string">"tencent.region"</span>);</span><br><span class="line">                qEndpointExternal = environment.getRequiredProperty(<span class="string">"tencent.endpointexternal"</span>);</span><br><span class="line">                uploadAbstractUtil = <span class="keyword">new</span> TencentCOSUploadUtil(basedir,qAccessKey,qSecretKey,qBucket,qRegion,qEndpoint,qEndpointExternal);</span><br><span class="line">                <span class="keyword">return</span> uploadAbstractUtil;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"暂不支持其他类型的云上传！！！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UploadServerEnum 枚举如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span>  UploadServerEnum &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阿里云OSS</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ALIOSS(<span class="string">"aliyun_oss"</span>,<span class="string">"阿里云OSS"</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 亚马逊s3</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AMAZON(<span class="string">"amazon_s3"</span>,<span class="string">"亚马逊S3"</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 微软azure</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AZURE(<span class="string">"azure"</span>,<span class="string">"微软Azure"</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 腾讯云cos</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TENCENTCOS(<span class="string">"tencent_cos"</span>,<span class="string">"腾讯云cos"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    UploadServerEnum(String value, String desc) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDesc</span><span class="params">(String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取一个枚举</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UploadServerEnum <span class="title">getEnum</span><span class="params">(String value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(UploadServerEnum.values()).filter(e-&gt;e.value.equals(value)).findFirst().get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到代码比较多……</p><p>其实几种云上传的核心只要理解，便非常清楚了。它们的大致步骤如下：</p><ol><li>根据配置信息创建上传client</li><li>上传文件（有多种方式，直接上传文件或根据文件流来上传等）</li><li>上传结果，获取上传文件路径等等。</li><li>如需关闭client，需要关闭client。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过学习如何进行文件云上传，我们掌握了云上传的方法，也可以体验到一些封装、继承、多态的好处，总的来说是蛮不错的一次体验。</p><p>项目地址： <a href="https://github.com/JavaZWT/framework-base/tree/master/ossutils-spring-boot" rel="external nofollow noopener noreferrer" target="_blank">ossutils-spring-boot</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="云上传" scheme="https://www.sakuratears.top/tags/%E4%BA%91%E4%B8%8A%E4%BC%A0/"/>
    
  </entry>
  
  <entry>
    <title>Java序列化和反序列化的几种方式</title>
    <link href="https://www.sakuratears.top/blog/Java%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F.html"/>
    <id>https://www.sakuratears.top/blog/Java序列化和反序列化的几种方式.html</id>
    <published>2019-05-05T13:49:00.000Z</published>
    <updated>2019-05-05T14:01:24.237Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在Java中，我们知道可以随意创建对象，只要对象未被GC回收，我们都可以继续在程序里使用，但这些对象只是存在于JVM内存中的，我们JVM一旦停止，这些对象就消失不见了。</p><p>经常有些时候，我们需要把这些对象持久化下来，再次需要时，再重新把对象读取出来，Java中有一种机制，对象序列化机制（object serialization）便可以帮我们完成相关功能。</p><p>对象序列化，可以方便的把对象状态保存为字节数组，可以通过字节流进行远程网络传输等，接收到字节流，通过反序列化机制，可以将字节数组转换为相关对象。</p><p>常说的RPC远程调用，相关传输对象的生成类就必须实现序列化以便在网络间传输。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Serializable接口"><a href="#Serializable接口" class="headerlink" title="Serializable接口"></a>Serializable接口</h2><p>在Java中，我们最常用的实现序列化和反序列化的方法就是相关类实现 java.io.Serializable 接口了，这也是Java给我们提供的一个方便的API。</p><p>我们创建一个Apple类，实现序列化接口，通过测试，可以看到相关对象生成的字节码和反序列化后的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> weight;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(<span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Apple</span><span class="params">(String color, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Apple&#123;"</span> +</span><br><span class="line">                <span class="string">"color='"</span> + color + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", weight="</span> + weight +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException,ClassNotFoundException</span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> [] bytes = <span class="keyword">null</span>;</span><br><span class="line">        Apple apple = <span class="keyword">new</span> Apple(<span class="string">"red"</span>,<span class="number">150</span>);</span><br><span class="line">        <span class="comment">//序列化</span></span><br><span class="line">        <span class="keyword">try</span>(ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(baos)</span><br><span class="line">         )&#123;</span><br><span class="line">            oos.writeObject(apple);</span><br><span class="line">            bytes = baos.toByteArray();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">byte</span> b : baos.toByteArray()) &#123;</span><br><span class="line">                System.out.print(Byte.toString(b) + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//反序列化</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">            ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bais)</span><br><span class="line">            ) &#123;</span><br><span class="line">            System.out.println(ois.readObject().toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试输出结果：</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-412.png" alt="upload successful"></p><p>当我们去掉Apple类的Serializable接口后，执行测试会抛出异常，说明对象无法被序列化。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-413.png" alt="upload successful"></p><h2 id="序列化ID（serialVersionUID）"><a href="#序列化ID（serialVersionUID）" class="headerlink" title="序列化ID（serialVersionUID）"></a>序列化ID（serialVersionUID）</h2><p>JVM虚拟机是否可以对某个对象进行反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的点是两个类的序列化ID是否一致（就是 private static final long serialVersionUID)。</p><p>序列化ID有两种生成策略，一个是固定的 1L，一个是随机生成一个不重复的 long 类型数据（实际上是使用 JDK 工具生成），在这里有一个建议，如果没有特殊需求，就是用默认的 1L 就可以，这样可以确保代码一致时反序列化成功。那么随机生成的序列化ID有什么作用呢，有些时候，通过改变序列化 ID 可以用来限制某些用户的使用。</p><h2 id="序列化的实现方式"><a href="#序列化的实现方式" class="headerlink" title="序列化的实现方式"></a>序列化的实现方式</h2><p>在Java中，我们还可以利用其它方式对对象进行序列化，我总结了几种序列化方式如下。</p><p>让我们一起来看一下：</p><p>我们提供一个序列化与反序列化通用接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Serializer</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 序列化名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 序列化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">byte</span>[] serialize(Object obj) <span class="keyword">throws</span> IOException ;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反序列化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bytes</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Object <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> IOException </span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="标准的Java序列化"><a href="#标准的Java序列化" class="headerlink" title="标准的Java序列化"></a>标准的Java序列化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaSerializer</span> <span class="keyword">implements</span> <span class="title">Serializer</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"java"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(Object obj) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="keyword">try</span>(</span><br><span class="line">ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">)&#123;</span><br><span class="line">oos.writeObject(obj);</span><br><span class="line"><span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bits)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(bits == <span class="keyword">null</span> || bits.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> (</span><br><span class="line">ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(bits);</span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bais);</span><br><span class="line">)&#123;</span><br><span class="line"><span class="keyword">return</span> ois.readObject();</span><br><span class="line">&#125;<span class="keyword">catch</span> (ClassNotFoundException e)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到序列化就是我们将对象通过ObjectOutputStream转化为ByteArrayOutputStream字节流，反序列化就是将字节流转换为对象流并读取。</p><h3 id="FST实现序列化"><a href="#FST实现序列化" class="headerlink" title="FST实现序列化"></a>FST实现序列化</h3><p>需要引入相关jar包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;de.ruedigermoeller&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;fst&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.57&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FSTSerializer</span> <span class="keyword">implements</span> <span class="title">Serializer</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"fst"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(Object obj) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="keyword">try</span> (</span><br><span class="line">ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">FSTObjectOutput fout = <span class="keyword">new</span> FSTObjectOutput(out);</span><br><span class="line">)&#123;</span><br><span class="line">fout.writeObject(obj);</span><br><span class="line">fout.flush();</span><br><span class="line"><span class="keyword">return</span> out.toByteArray();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(bytes == <span class="keyword">null</span> || bytes.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> (</span><br><span class="line">FSTObjectInput in = <span class="keyword">new</span> FSTObjectInput(<span class="keyword">new</span> ByteArrayInputStream(bytes));</span><br><span class="line">)&#123;</span><br><span class="line"><span class="keyword">return</span> in.readObject();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Kryo实现序列化"><a href="#Kryo实现序列化" class="headerlink" title="Kryo实现序列化"></a>Kryo实现序列化</h3><p>需要引入相关jar包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.esotericsoftware&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;kryo&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.0.0-RC4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KryoSerializer</span> <span class="keyword">implements</span> <span class="title">Serializer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Kryo kryo = <span class="keyword">new</span> Kryo();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"kryo"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(Object obj) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">try</span> (ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">             Output output = <span class="keyword">new</span> Output(baos)) &#123;</span><br><span class="line">            kryo.register(obj.getClass());</span><br><span class="line">            kryo.writeClassAndObject(output, obj);</span><br><span class="line">            output.flush();</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bits)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bits == <span class="keyword">null</span> || bits.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> (ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(bits);</span><br><span class="line">             Input ois = <span class="keyword">new</span> Input(bais)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">return</span> kryo.readClassAndObject(ois);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KryoPool实现序列化"><a href="#KryoPool实现序列化" class="headerlink" title="KryoPool实现序列化"></a>KryoPool实现序列化</h3><p>由于kryo创建的代价相对较高，我们可以使用一个KryoPool池来管理Kryo，使用空间换取时间，提高运行效率。</p><p>我们使用一个双端队列来对Kryo进行管理，相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KryoPoolSerializer</span> <span class="keyword">implements</span> <span class="title">Serializer</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Kryo 的包装</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">KryoHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Kryo kryo;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">1024</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * reuse</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> Output output = <span class="keyword">new</span> Output(BUFFER_SIZE, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> Input input = <span class="keyword">new</span> Input();</span><br><span class="line">        KryoHolder(Kryo kryo) &#123;</span><br><span class="line">            <span class="keyword">this</span>.kryo = kryo;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">KryoPool</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * get o kryo object</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> KryoHolder instance</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function">KryoHolder <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * return object</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> kryo holder</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">offer</span><span class="params">(KryoHolder kryo)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 由于kryo创建的代价相对较高 ，这里使用空间换时间</span></span><br><span class="line"><span class="comment">     * 对KryoHolder对象进行重用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">KryoPoolImpl</span> <span class="keyword">implements</span> <span class="title">KryoPool</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * default is 1500</span></span><br><span class="line"><span class="comment">         * online server limit 3K</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * thread safe list</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;KryoHolder&gt; kryoHolderDeque=<span class="keyword">new</span> ConcurrentLinkedDeque&lt;KryoHolder&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">KryoPoolImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> KryoPool instance</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> KryoPool <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Singleton.pool;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * get o KryoHolder object</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> KryoHolder instance</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> KryoHolder <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Retrieves and removes the head of the queue represented by this table</span></span><br><span class="line">            KryoHolder kryoHolder = kryoHolderDeque.pollFirst();</span><br><span class="line">            <span class="keyword">return</span> kryoHolder == <span class="keyword">null</span> ? creatInstnce() : kryoHolder;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * create a new kryo object to application use</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> KryoHolder instance</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> KryoHolder <span class="title">creatInstnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Kryo kryo = <span class="keyword">new</span> Kryo();</span><br><span class="line">            kryo.setReferences(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> KryoHolder(kryo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * return object</span></span><br><span class="line"><span class="comment">         * Inserts the specified element at the tail of this queue.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> kryoHolder ...</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(KryoHolder kryoHolder)</span> </span>&#123;</span><br><span class="line">            kryoHolderDeque.addLast(kryoHolder);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * creat a Singleton</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> KryoPool pool = <span class="keyword">new</span> KryoPoolImpl();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Kryo_Pool"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Serialize object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj what to serialize</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> return serialize data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(Object obj) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        KryoHolder kryoHolder = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"obj can not be null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            kryoHolder = KryoPoolImpl.getInstance().get();</span><br><span class="line">            kryoHolder.kryo.register(obj.getClass());</span><br><span class="line">            <span class="comment">//reset Output    --&gt;每次调用的时候  重置</span></span><br><span class="line">            kryoHolder.output.reset();</span><br><span class="line">            kryoHolder.kryo.writeClassAndObject(kryoHolder.output, obj);</span><br><span class="line">            <span class="comment">// 无法避免拷贝  ~~~</span></span><br><span class="line">            <span class="keyword">return</span> kryoHolder.output.toBytes();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Serialize obj exception"</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            KryoPoolImpl.getInstance().offer(kryoHolder);</span><br><span class="line">            <span class="comment">//GC</span></span><br><span class="line">            obj = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Deserialize data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes what to deserialize</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        KryoHolder kryoHolder = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"bytes can not be null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            kryoHolder = KryoPoolImpl.getInstance().get();</span><br><span class="line">            <span class="comment">//call it ,and then use input object  ,discard any array</span></span><br><span class="line">            kryoHolder.input.setBuffer(bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">            <span class="keyword">return</span> kryoHolder.kryo.readClassAndObject(kryoHolder.input);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Deserialize bytes exception"</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            KryoPoolImpl.getInstance().offer(kryoHolder);</span><br><span class="line">            <span class="comment">//  for gc</span></span><br><span class="line">            bytes = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Jackson-实现序列化和反序列化"><a href="#Jackson-实现序列化和反序列化" class="headerlink" title="Jackson 实现序列化和反序列化"></a>Jackson 实现序列化和反序列化</h3><p>Jackson也可以实现相关序列化和反序列化功能，需要引入jackson 的jar包。</p><p>使用writeValueAsBytes和readValue方法即可完成相关功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.5.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JacksonSerializer</span> <span class="keyword">implements</span> <span class="title">Serializer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Jackson"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(Object obj) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> mapper.writeValueAsBytes(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mapper.readValue(bytes,Object.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FastJson实现序列化和反序列化"><a href="#FastJson实现序列化和反序列化" class="headerlink" title="FastJson实现序列化和反序列化"></a>FastJson实现序列化和反序列化</h3><p>FastJson实现序列化与反序列化，需要引入相关jar包，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.58&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastJsonSerializer</span> <span class="keyword">implements</span> <span class="title">Serializer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"FastJson"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(Object obj) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> JSON.toJSONString(obj, SerializerFeature.WriteClassName).getBytes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JSON.parse(<span class="keyword">new</span> String(bytes), Feature.SupportAutoType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的序列化与反序列化的对象都需要实现Serializable接口。</p><p>我们对上述代码进行相关测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializationUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Apple apple =<span class="keyword">new</span> Apple();</span><br><span class="line">        apple.setColor(<span class="string">"red"</span>);</span><br><span class="line">        apple.setWeight(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        printData(<span class="keyword">new</span> JavaSerializer(),apple);</span><br><span class="line">        printData(<span class="keyword">new</span> FSTSerializer(),apple);</span><br><span class="line">        printData(<span class="keyword">new</span> KryoSerializer(),apple);</span><br><span class="line">        printData(<span class="keyword">new</span> KryoPoolSerializer(),apple);</span><br><span class="line">        printData(<span class="keyword">new</span> JacksonSerializer(),apple);</span><br><span class="line">        printData(<span class="keyword">new</span> FastJsonSerializer(),apple);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printData</span><span class="params">(Serializer serializer,Apple apple)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">byte</span>[] bits = serializer.serialize(apple);</span><br><span class="line">        System.out.println(serializer.name()+<span class="string">"序列化所需时间："</span>+(System.currentTimeMillis()-start)+<span class="string">"ms"</span>);</span><br><span class="line">        System.out.println(serializer.name()+<span class="string">"序列化后字节码长度："</span>+bits.length);</span><br><span class="line">        <span class="keyword">long</span> start1 = System.currentTimeMillis();</span><br><span class="line">        Object obj = serializer.deserialize(bits);</span><br><span class="line">        System.out.println(serializer.name()+<span class="string">"反序列化所需时间："</span>+(System.currentTimeMillis()-start1)+<span class="string">"ms"</span>);</span><br><span class="line">        System.out.println(serializer.name()+<span class="string">"反序列化后对象："</span>+obj.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到输出后的结果：</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-414.png" alt="upload successful"></p><p>根据结果判断正确性后，也大致能看出各种序列化方式的一些优点和缺点。</p><ul><li><p>JavaSerializer 明显的优点是不用引用包，也是Java程序默认的序列化方式，但是其序列化后占用空间是几种序列化方式里最大的，如果遇到大对象序列化，处理起来可能就比较力不从心了。</p></li><li><p>FSTSerializer、JacksonSerializer、FastJsonSerializer 它们是一种比较适中的序列化方式，序列化后的字节比Java方法少，时间也差不多。</p></li><li><p>KryoSerializer 是一种比较优异的序列化方式，可以看到它的序列化后的字节很短，占用空间少，且序列化和反序列化时间短。</p></li><li><p>KryoPoolSerializer 这种相当于KryoSerializer的改进版，利用了一部分内存空间，进一步降低了序列化和反序列化的时间。</p></li></ul><p>正因为Kryo如此高效的序列化和反序列化性能，因此在大数据领域应用广泛。如Apache的spark、hive等。</p><p>如果需要更准确的结果比较各种序列化方式的性能，可以创建大量对象并对它们进行序列化记录时间等参数比较，这儿就不过多讨论了。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>通过对序列化和反序列化的简单介绍，并比较了一些常用的序列化方式，我们对对象的序列化与反序列化有了更进一步的认知。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="序列化与反序列化" scheme="https://www.sakuratears.top/tags/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>生产者和消费者模式</title>
    <link href="https://www.sakuratears.top/blog/%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F.html"/>
    <id>https://www.sakuratears.top/blog/生产者和消费者模式.html</id>
    <published>2019-04-21T05:43:00.000Z</published>
    <updated>2019-04-21T05:55:45.231Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天我们来学习下生产者与消费者模式。</p><p>生产者和消费者模式可以解决绝大多数并发问题，一般由生产者、数据缓冲区、消费者构成。</p><p>如下图，其原理是将原来的直接调用（消费者-&gt;生产者）变为了生产者生产数据放入缓存区，消费者从缓存区获取数据并消费这种模式。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-410.png" alt="upload successful"></p><p>可以知道MQ就是生产者与消费者模式的典型代表。</p><p>我们可以举例比如一个定时任务，每天要批处理数据，比如上传文件，每天如果要上传1000个文件或者更多，这时候我们使用平常的循环上传方法，明显大部分时间均浪费在了上传的时间上。</p><p>如果按照每个文件处理需要3s，1000个文件则至少需要3000s时间。</p><p>如果我们引入生产者和消费者模式，生产者部分负责查询组装数据并把它们放入数据缓存区，消费者部分负责处理数据并上传，可以大大提高并发性能。</p><p>使用生产者与消费者模式的典型优点如下：</p><ol><li><p><strong>并发支持</strong></p><p>可以看到，如果消费者处理比较耗时，我们可以使用多个生产者生产数据或者消费者去处理队列数据，从而提高系统并发性能。即消费者和生产者可以为两个独立的并发主体。</p></li><li><p><strong>解耦</strong></p><p>我们将生产者和消费者分开后，即使生产者部分处理数据的逻辑有变化，也不会影响到消费者部分，而相比之前在一起的逻辑，我们可能需要改动整个业务部分以完成数据处理。即生产者和消费者没有过分的依赖关系，只要保证传输数据格式的正确性即可。</p></li><li><p><strong>解决忙闲不均问题</strong></p><p>可以看到生产者和消费者模式可以完美解决忙闲不均的问题，当生产者数据过多时，进入数据缓存区等待消费者慢慢处理，生产者数据少时，由于缓存区的数据，也不至于消费者无事可做。即无论生产者或者消费者谁快谁慢，我们总可以通过对他们的数量控制来均衡资源的分配。</p></li></ol><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>我们通过上面的例子来实践下消费者和生产者模式。</p><p>我们正常逻辑可能如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">//1. 组装数据</span></span><br><span class="line">    <span class="comment">//数据库查询、组装数据过程略，由for循环插入数据代替</span></span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//假设处理每条数据花费平均10ms时间</span></span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        list.add(i+<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 上传数据/文件</span></span><br><span class="line">    <span class="comment">//上传过程略</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">        <span class="comment">//假设每个文件平均耗时1s</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个过程是非常耗时的，我们使用生产者和消费者模式来设计下这个业务场景。</p><p>我们数据缓存区使用队列来暂存数据，生产者组生产数据时会将数据放入队列，消费者消费数据时会从队列中获取数据。</p><p>我们用阻塞队列<code>LinkedBlockingQueue</code>来作为数据缓存区，写一个生产者放入数据和消费者取出数据的方法。</p><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(Context.class);</span><br><span class="line">    <span class="comment">//阻塞队列用来暂存数据</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LinkedBlockingQueue&lt;E&gt; consumptionQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;E&gt;(<span class="number">2500</span>);</span><br><span class="line"><span class="comment">// 生产线程的状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ThreadState producersThreadState;</span><br><span class="line"><span class="comment">// 消费线程的状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ThreadState consumersThreadState;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取队列大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getConsumptionQueueSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> consumptionQueue.size();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定元素插入到此队列的尾部，如有必要（队列空间已满且消费线程未停止运行），则等待空间变得可用。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean true:插入成功;false:插入失败（消费线程已停止运行）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerDataToConsumptionQueue</span><span class="params">(E e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//设置生产者线程为运行</span></span><br><span class="line">setProducersThreadState(ThreadState.RUNNING);</span><br><span class="line"><span class="comment">// 如果消费线程停止了，不再生产数据</span></span><br><span class="line"><span class="keyword">if</span> (ThreadState.DEAD == <span class="keyword">this</span>.getConsumersThreadState())&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//一直尝试将数据放入队列</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//将数据放入队列，如果成功返回成功</span></span><br><span class="line"><span class="keyword">if</span> (consumptionQueue.offer(e, <span class="number">2</span>, TimeUnit.SECONDS))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加元素失败，很有可能是队列已满，再次检查消费线程是否工作中</span></span><br><span class="line"><span class="comment">// 如果消费线程停止了，不再生产数据</span></span><br><span class="line"><span class="keyword">if</span> (ThreadState.DEAD == <span class="keyword">this</span>.getConsumersThreadState()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取并移除此队列的头，如果此队列为空且生产线程已停止，则返回 null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> E 队列的头元素，如果队列为空且生产线程已停止则返回null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollDataFromConsumptionQueue</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//设置消费者线程为运行</span></span><br><span class="line">setConsumersThreadState(ThreadState.RUNNING);</span><br><span class="line">        <span class="comment">//一直尝试从队列里获取数据</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//尝试从队列里获取数据</span></span><br><span class="line">E e = consumptionQueue.poll(<span class="number">20</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"><span class="keyword">if</span> (e != <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没有从队列里获取到元素，并且生产线程已停止，则返回null</span></span><br><span class="line"><span class="keyword">if</span> (ThreadState.DEAD == <span class="keyword">this</span>.getProducersThreadState())&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">log.debug(<span class="string">"demand exceeds supply(供不应求，需生产数据)..."</span>);</span><br><span class="line">Thread.sleep(<span class="number">50</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取 producersThreadState</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> producersThreadState</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ThreadState <span class="title">getProducersThreadState</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> producersThreadState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置 producersThreadState</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> producersThreadState</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setProducersThreadState</span><span class="params">(ThreadState producersThreadState)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.producersThreadState = producersThreadState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取 consumersThreadState</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> consumersThreadState</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ThreadState <span class="title">getConsumersThreadState</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> consumersThreadState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置 consumersThreadState</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> consumersThreadState</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setConsumersThreadState</span><span class="params">(ThreadState consumersThreadState)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.consumersThreadState = consumersThreadState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程状态枚举：新线程(NEW)、可运行的(RUNNABLE)、运行中(RUNNING)、死亡(DEAD)、阻塞(BLOCKED)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> ThreadState &#123;</span><br><span class="line">NEW, RUNNABLE, RUNNING, DEAD, BLOCKED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们构造两个模板接口，一个生产者模板接口一个消费者模板接口，分别提供生产者产生数据的方法和消费者消费数据的方法。具体实现有各自的业务实现类实现即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者模板</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;C_E&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProducerTemplate</span>&lt;<span class="title">C_E</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">production</span><span class="params">(Context&lt;C_E&gt; context)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费者模板</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;C_E&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConsumerTemplate</span>&lt;<span class="title">C_E</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumption</span><span class="params">(Context&lt;C_E&gt; context)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个生产者与消费者的协调者类，用来启动生产者或者消费者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产与消费协调者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coordinator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(Coordinator.class);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition enabledConsumers = lock.newCondition();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isEnabledForConsumers;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Context&lt;?&gt; context;</span><br><span class="line"><span class="comment">// 是否等待生产及消费完成</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> isWaitingToFinish;</span><br><span class="line"><span class="comment">// 最大消费线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> consumersMaxTotal;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Coordinator</span><span class="params">(Context&lt;?&gt; context, <span class="keyword">int</span> consumersMaxTotal)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(context, consumersMaxTotal, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Coordinator</span><span class="params">(Context&lt;?&gt; context, <span class="keyword">int</span> consumersMaxTotal, <span class="keyword">boolean</span> isWaitingToFinish)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.context = context;</span><br><span class="line"><span class="keyword">this</span>.consumersMaxTotal = consumersMaxTotal;</span><br><span class="line"><span class="keyword">this</span>.isWaitingToFinish = isWaitingToFinish;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *启动生产、消费</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  producerTemplate 生产者模板</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  consumerTemplate 消费者模板</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(ProducerTemplate&lt;?&gt; producerTemplate,ConsumerTemplate&lt;?&gt; consumerTemplate)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (context.getConsumersThreadState() != <span class="keyword">null</span> || context.getProducersThreadState() != <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">ProducersThreadUnit producersThreadUnit = <span class="keyword">new</span> ProducersThreadUnit(producerTemplate, <span class="string">"production"</span>, context);</span><br><span class="line">ConsumersThreadUnit consumersThreadUnit = <span class="keyword">new</span> ConsumersThreadUnit(consumerTemplate, <span class="string">"consumption"</span>, context);</span><br><span class="line"><span class="keyword">this</span>.start(producersThreadUnit, consumersThreadUnit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动生产、消费（适用于生产函数、消费函数不在一个类里实现，或者一个类里有多对生产、消费组合，或者方法入参列表复杂）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> producersThreadUnit</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> consumersThreadUnit</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(ProducersThreadUnit producersThreadUnit, ConsumersThreadUnit consumersThreadUnit)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (context.getConsumersThreadState() != ThreadState.NEW || context.getProducersThreadState() != ThreadState.NEW)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//启动生产者</span></span><br><span class="line">Thread startProducersThread = <span class="keyword">this</span>.startProducers(producersThreadUnit);</span><br><span class="line">            <span class="comment">//启动消费者</span></span><br><span class="line">Thread startConsumersThread = <span class="keyword">this</span>.startConsumers(consumersThreadUnit);</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.isWaitingToFinish)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">startProducersThread.join();</span><br><span class="line"><span class="keyword">if</span> (startConsumersThread != <span class="keyword">null</span>)&#123;</span><br><span class="line">startConsumersThread.join();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">log.error(<span class="string">"start worker error..."</span>, e);</span><br><span class="line"><span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br><span class="line">log.info(String.format(<span class="string">"processing is completed... man-hour(millisecond)=[%s]"</span>, System.currentTimeMillis() - time));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动生产</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> producersThreadUnit</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Thread <span class="title">startProducers</span><span class="params">(ProducersThreadUnit producersThreadUnit)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(producersThreadUnit);</span><br><span class="line">thread.start();</span><br><span class="line"><span class="keyword">return</span> thread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动消费</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> consumersThreadUnit</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Thread <span class="title">startConsumers</span><span class="params">(ConsumersThreadUnit consumersThreadUnit)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">log.info(<span class="string">"wating for producers..."</span>);</span><br><span class="line"><span class="keyword">while</span> (!isEnabledForConsumers)&#123;</span><br><span class="line"><span class="comment">// 等待生产（造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态）,假定可能发生虚假唤醒（这并非是因为等待超时），因此总是在一个循环中等待</span></span><br><span class="line"><span class="comment">// 间隔检查，防止意外情况下线程没能被成功唤醒（机率小之又小,导致线程无限挂起）</span></span><br><span class="line">enabledConsumers.await(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (context.getConsumptionQueueSize() == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">log.info(<span class="string">"start consumers before..."</span>);</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(consumersThreadUnit);</span><br><span class="line">thread.start();</span><br><span class="line"><span class="keyword">return</span> thread;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">log.error(<span class="string">"start consumers error..."</span>, e);</span><br><span class="line"><span class="keyword">throw</span> e;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产者和消费者的线程单元如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducersThreadUnit</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object targetObject;</span><br><span class="line"><span class="keyword">private</span> String targetMethodName;</span><br><span class="line"><span class="keyword">private</span> Object[] targetMethodParameters;</span><br><span class="line"><span class="keyword">private</span> ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ProducersThreadUnit</span><span class="params">(Object targetObject, String targetMethodName, Object... targetMethodParameters)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.targetObject = targetObject;</span><br><span class="line"><span class="keyword">this</span>.targetMethodName = targetMethodName;</span><br><span class="line"><span class="keyword">this</span>.targetMethodParameters = targetMethodParameters;</span><br><span class="line">context.setProducersThreadState(ThreadState.NEW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">executorService.execute(<span class="keyword">new</span> RunnableThreadUnit(targetObject, targetMethodName, targetMethodParameters));</span><br><span class="line">context.setProducersThreadState(ThreadState.RUNNABLE);</span><br><span class="line">executorService.shutdown();</span><br><span class="line"><span class="comment">// 阻塞线程，直到生产中（消费队列不为空）或者停止生产</span></span><br><span class="line"><span class="keyword">while</span> (!executorService.isTerminated() &amp;&amp; context.getConsumptionQueueSize() == <span class="number">0</span>)&#123;</span><br><span class="line">Thread.sleep(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line">log.info(<span class="string">"production the end or products have been delivered,ready to inform consumers..."</span>);</span><br><span class="line"><span class="keyword">this</span>.wakeConsumers();</span><br><span class="line">log.info(<span class="string">"wait until the production is complete..."</span>);</span><br><span class="line"><span class="keyword">while</span> (!executorService.isTerminated())&#123;</span><br><span class="line"><span class="comment">// 等待生产完毕</span></span><br><span class="line">Thread.sleep(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">log.error(String.format(<span class="string">"production error... targetObject=[%s],targetMethodName=[%s],targetMethodParameters=[%s]"</span>, targetObject, targetMethodName, targetMethodParameters), e);</span><br><span class="line"><span class="keyword">if</span> (!executorService.isShutdown())&#123;</span><br><span class="line">executorService.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">log.info(<span class="string">"production the end..."</span>);</span><br><span class="line">context.setProducersThreadState(ThreadState.DEAD);</span><br><span class="line"><span class="comment">// 无论在何种情况下，必须确保能够结束挂起中的消费者线程</span></span><br><span class="line">isEnabledForConsumers = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向消费者发送信号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">wakeConsumers</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 即使唤醒消费者线程失败，也可以使用该句柄结束挂起中的消费者线程</span></span><br><span class="line">isEnabledForConsumers = <span class="keyword">true</span>;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">enabledConsumers.signal();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">log.error(<span class="string">"inform to consumers error..."</span>, e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumersThreadUnit</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object targetObject;</span><br><span class="line"><span class="keyword">private</span> String targetMethodName;</span><br><span class="line"><span class="keyword">private</span> Object[] targetMethodParameters;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConsumersThreadUnit</span><span class="params">(Object targetObject, String targetMethodName, Object... targetMethodParameters)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.targetObject = targetObject;</span><br><span class="line"><span class="keyword">this</span>.targetMethodName = targetMethodName;</span><br><span class="line"><span class="keyword">this</span>.targetMethodParameters = targetMethodParameters;</span><br><span class="line">context.setConsumersThreadState(ThreadState.NEW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ThreadPoolExecutor threadPoolExecutor = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span> concurrencyMaxTotal = Coordinator.<span class="keyword">this</span>.consumersMaxTotal;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, concurrencyMaxTotal, <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line"><span class="keyword">while</span> (concurrencyMaxTotal &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (threadPoolExecutor.getPoolSize() &gt; context.getConsumptionQueueSize()) &#123;</span><br><span class="line"><span class="keyword">if</span> (ThreadState.DEAD == context.getProducersThreadState()) &#123;</span><br><span class="line"><span class="comment">// 无须再提交新任务</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">50</span>);</span><br><span class="line"><span class="comment">// 再次检查是否有必要提交新任务</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">RunnableThreadUnit consumers = <span class="keyword">new</span> RunnableThreadUnit(targetObject, targetMethodName, targetMethodParameters);</span><br><span class="line">threadPoolExecutor.execute(consumers);</span><br><span class="line">context.setConsumersThreadState(ThreadState.RUNNABLE);</span><br><span class="line">log.info(<span class="string">"submit consumption task..."</span>);</span><br><span class="line">concurrencyMaxTotal--;</span><br><span class="line">&#125;</span><br><span class="line">threadPoolExecutor.shutdown();</span><br><span class="line"><span class="keyword">while</span> (!threadPoolExecutor.isTerminated()) &#123;</span><br><span class="line"><span class="comment">// 等待消费完毕</span></span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">log.error(String.format(<span class="string">"consumption error... targetObject=[%s],targetMethodName=[%s],targetMethodParameters=[%s]"</span>, targetObject, targetMethodName, targetMethodParameters), e);</span><br><span class="line"><span class="keyword">if</span> (threadPoolExecutor != <span class="keyword">null</span> &amp;&amp; !threadPoolExecutor.isShutdown()) &#123;</span><br><span class="line">threadPoolExecutor.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">log.info(<span class="string">"consumption the end..."</span>);</span><br><span class="line">context.setConsumersThreadState(ThreadState.DEAD);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *线程单元（无返回值）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableThreadUnit</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(RunnableThreadUnit.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object object;</span><br><span class="line"><span class="keyword">private</span> String methodName;</span><br><span class="line"><span class="keyword">private</span> Object[] methodParameters;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RunnableThreadUnit</span><span class="params">(Object object, String methodName, Object... methodParameters)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (object == <span class="keyword">null</span> || StringUtils.isBlank(methodName) || methodParameters == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"init runnable thread unit error..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.object = object;</span><br><span class="line"><span class="keyword">this</span>.methodName = methodName;</span><br><span class="line"><span class="keyword">this</span>.methodParameters = methodParameters;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class&lt;?&gt;[] classes = <span class="keyword">new</span> Class[methodParameters.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methodParameters.length; i++) &#123;</span><br><span class="line">classes[i] = methodParameters[i].getClass();</span><br><span class="line">&#125;</span><br><span class="line">Method method = object.getClass().getMethod(methodName, classes);</span><br><span class="line">method.invoke(object, methodParameters);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">logger.error(String.format(<span class="string">"execute runnable thread unit error... service=[%s],invokeMethodName=[%s]"</span>, object, methodName), e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们使用反射获取了production和consumption方法，并执行它们。启动了两个线程，生产者线程和消费者线程去处理业务，其中消费者线程利用了线程池，可以放置concurrencyMaxTotal个子线程去消费任务。</p><p>我们创建一个测试类进行测试，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CourrentTest</span> <span class="keyword">implements</span> <span class="title">ProducerTemplate</span>&lt;<span class="title">String</span>&gt;, <span class="title">ConsumerTemplate</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">production</span><span class="params">(Context&lt;String&gt; context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1. 组装数据</span></span><br><span class="line">        <span class="comment">//数据库查询、组装数据过程略，由for循环插入数据代替</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            <span class="comment">//插入不成功，说明可能是消费者线程死亡或者队列已满</span></span><br><span class="line">            <span class="keyword">if</span>(!context.offerDataToConsumptionQueue(i+<span class="string">""</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumption</span><span class="params">(Context&lt;String&gt; context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//2. 上传数据/文件</span></span><br><span class="line">        <span class="comment">//消费者消费数据</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            String str = context.pollDataFromConsumptionQueue();</span><br><span class="line">            <span class="keyword">if</span> (str == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//假设每个文件上传消耗1s时间</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        CourrentTest courrentTest = <span class="keyword">new</span> CourrentTest();</span><br><span class="line">        <span class="keyword">new</span> Coordinator(<span class="keyword">new</span> Context&lt;String&gt;(),<span class="number">10</span>).start(courrentTest,courrentTest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后可以看到输出的结果。</p><p>这儿我们可以看到对比较耗时的上传方法（消费者端）进行了并发处理以提高效率，生产端如果保证了数据的安全性，我们可以使用并行流等放入数据以提高放入数据的效率。</p><p>其实我们看到这儿，可以理解线程池也是一个类似于生产者消费者模式的东西。线程池里面有任务就会去执行，相当于消费者，线程池里的队列相当于缓存区，而生产者就是我们一个个放入线程的Runable方法。</p><p>上述代码的运行原理图大致如下：</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-411.png" alt="upload successful"></p><p>PS: 上述代码可以在我的GitHub项目里找到。 </p><p><a href="https://github.com/JavaZWT/framework-base" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/JavaZWT/framework-base</a></p><p>另外提供了一个简易模板SimpleTemplate可以适用生产者方法和消费者方法在一个类里的情况，只继承这一个方法即可。不用分别继承ConsumerTemplate和ProducerTemplate接口了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过对上面一个列子使用生产者和消费者模式，我们了解了这种模式的一些适用情形和优点。</p><p>当然也了解了它的一些缺点，对于解决并发问题的方案，最要重视的应该就是数据安全问题了。</p><p>我们在平时工作中也可以考虑什么样的场景下可以使用这种模式，其实这种模式的适用场景还是蛮多的，对于一些处理较耗时的操作，文件上传、图片生成转换等都可以考虑这种模式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="设计模式" scheme="https://www.sakuratears.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="生产者与消费者模式" scheme="https://www.sakuratears.top/tags/%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Redis在项目中的一些应用</title>
    <link href="https://www.sakuratears.top/blog/Redis%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BA%94%E7%94%A8.html"/>
    <id>https://www.sakuratears.top/blog/Redis在项目中的一些应用.html</id>
    <published>2019-04-13T08:07:00.000Z</published>
    <updated>2019-04-15T13:50:31.574Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天我们来总结下Redis在项目中的一些应用。</p><p>Redis在实际项目中除了可以作为缓存或者持久化数据库外，还能解决项目中遇到的一些棘手的问题。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="限流-防高频问题"><a href="#限流-防高频问题" class="headerlink" title="限流/防高频问题"></a>限流/防高频问题</h2><p>这基本上属于项目中一个比较经典的问题了，我们以防止用户高频访问来举例，大多数的项目中都是通过Redis来解决高频访问问题的。</p><p>我们知道，对于高频访问问题，要有以下3要素：单位时间、单位时间限制访问次数、超频后的限制访问时间长。</p><p>我们定义一个Bean，控制这几个参数，当然也可以直接使用配置文件的方式进行配置等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LimitRule</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单位访问时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> seconds;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单位时间内限制的访问次数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> limitCount;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单位时间超过访问次数后的锁定时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> lockTime;</span><br><span class="line"><span class="comment">//Get Set略</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enableLimitLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> getLockTime() &gt; <span class="number">0</span> &amp;&amp; getLimitCount() &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Redis有一种数据结构，名字为Zset，可以通过方法zadd添加元素，通过zcount统计记录数，我们可以用Zset的有序集的value来存放访问时间，判断超频时，只需要用zcount判断单位时间seconds内Zset里的元素数据是否超过limitCount即可，超过后即为该用户添加一个锁定lockTime的Redis key。</p><p>因此，我们代码大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HighFreqLimit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录用户行为并判断高频访问的zset</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REDIS_VISIT_KEY_FORMAT = <span class="string">"redis.visit:user:zset:%s"</span>;</span><br><span class="line">    <span class="comment">//高频访问用户key</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REDIS_LIMIT_KEY_FORMAT = <span class="string">"redis.limit:user:%s"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Redis 工具</span></span><br><span class="line">    <span class="keyword">private</span> RedisUtil redisUtil;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HighFreqLimit</span><span class="params">(RedisUtil redisUtil)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.redisUtil = redisUtil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方案一：使用Zset来判断高频访问情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断用户是否高频访问</span></span><br><span class="line"><span class="comment">     * 高频访问抛出异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userNo 用户唯一的编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> limitRule 访问规则   这个规则可以用配置文件的方式处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkLimit1</span><span class="params">(String userNo,LimitRule limitRule)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否启用了高频访问</span></span><br><span class="line">        <span class="keyword">if</span>(!limitRule.enableLimitLock())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String redisKeyUserVisitZset = String.format(REDIS_VISIT_KEY_FORMAT,userNo);</span><br><span class="line">        String redisUserFreqLimitKey = String.format(REDIS_LIMIT_KEY_FORMAT,userNo);</span><br><span class="line">        <span class="comment">//如果存在高频访问key说明已经高频访问了</span></span><br><span class="line">        <span class="keyword">if</span> (redisUtil.exists(redisUserFreqLimitKey)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"您操作的太快了，请稍后访问"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> currentTimeMillis=System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//访问信息，可以根据具体业务定制</span></span><br><span class="line">        String visitInfo = userNo +<span class="string">":"</span>+ System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//将信息添加到zset里</span></span><br><span class="line">        redisUtil.zadd(redisKeyUserVisitZset,System.currentTimeMillis(), visitInfo);</span><br><span class="line">        <span class="comment">//设置过期时间为单位时间</span></span><br><span class="line">        redisUtil.expire(redisKeyUserVisitZset, limitRule.getSeconds());</span><br><span class="line">        <span class="keyword">long</span> startTimeMillis = currentTimeMillis - limitRule.getSeconds() * <span class="number">1000</span>;</span><br><span class="line">        <span class="comment">//统计单位时间内Zset的元素个数</span></span><br><span class="line">        <span class="keyword">long</span> visitCount = redisUtil.zcount(redisKeyUserVisitZset, startTimeMillis, currentTimeMillis);</span><br><span class="line">        <span class="comment">//超过阈值则成为高频用户</span></span><br><span class="line">        <span class="keyword">if</span> (visitCount &gt; limitRule.getLimitCount()) &#123;</span><br><span class="line">            redisUtil.setString(redisUserFreqLimitKey, visitInfo);</span><br><span class="line">            redisUtil.expire(redisUserFreqLimitKey, limitRule.getLockTime());</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"您操作的太快了，请稍后访问"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Redis在2.6版本后支持Lua表达式，因此我们也可以构建使用Lua表达式来解决上述问题。</p><p>构建Lua表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REDIS_VISIT_KEY_FORMAT2 = <span class="string">"redis.visit:user:lua:%s"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方案二：使用Lua表达式来判断高频访问情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断用户是否高频访问</span></span><br><span class="line"><span class="comment">     * 高频访问抛出异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userNo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> limitRule</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">checkLimit2</span><span class="params">(String userNo, LimitRule limitRule)</span> </span>&#123;</span><br><span class="line">        String redisKeyUserVisit = String.format(REDIS_VISIT_KEY_FORMAT2,userNo);</span><br><span class="line">        <span class="keyword">long</span> count;</span><br><span class="line">        List&lt;String&gt; keys = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        keys.add(redisKeyUserVisit);</span><br><span class="line">        List&lt;String&gt; args = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        args.add(limitRule.getLimitCount() + <span class="string">""</span>);</span><br><span class="line">        args.add(limitRule.getSeconds() + <span class="string">""</span>);</span><br><span class="line">        args.add(limitRule.getLockTime() + <span class="string">""</span>);</span><br><span class="line">        count = Long.parseLong(redisUtil.getJedisFactory().getJedisCluster().eval(buildLuaScript(limitRule), keys, args) + <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">if</span>(count &gt; limitRule.getLimitCount())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"您操作的太快了，请稍后访问"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">buildLuaScript</span><span class="params">(LimitRule limitRule)</span> </span>&#123;</span><br><span class="line">        StringBuilder lua = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        lua.append(<span class="string">"\nlocal c"</span>);</span><br><span class="line">        lua.append(<span class="string">"\nc = redis.call('get',KEYS[1])"</span>);</span><br><span class="line">        lua.append(<span class="string">"\nif c and tonumber(c) &gt; tonumber(ARGV[1]) then"</span>);</span><br><span class="line">        lua.append(<span class="string">"\nreturn c;"</span>);</span><br><span class="line">        lua.append(<span class="string">"\nend"</span>);</span><br><span class="line">        lua.append(<span class="string">"\nc = redis.call('incr',KEYS[1])"</span>);</span><br><span class="line">        lua.append(<span class="string">"\nif tonumber(c) == 1 then"</span>);</span><br><span class="line">        lua.append(<span class="string">"\nredis.call('expire',KEYS[1],ARGV[2])"</span>);</span><br><span class="line">        lua.append(<span class="string">"\nend"</span>);</span><br><span class="line">        <span class="keyword">if</span> (limitRule.enableLimitLock()) &#123;</span><br><span class="line">            lua.append(<span class="string">"\nif tonumber(c) &gt; tonumber(ARGV[1]) then"</span>);</span><br><span class="line">            lua.append(<span class="string">"\nredis.call('expire',KEYS[1],ARGV[3])"</span>);</span><br><span class="line">            lua.append(<span class="string">"\nend"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        lua.append(<span class="string">"\nreturn c;"</span>);</span><br><span class="line">        <span class="keyword">return</span> lua.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对于上述表达式，KEYS[1]即为redisKeyUserVisit，可以看到先进行取值，如果有值并且值比limitCount大就返回了，根据后面<code>count &gt; limitRule.getLimitCount()</code>的判断说明已经超频了，如果不大于该值，则进行自增，如果该值是1，说明单位时间第一次访问，就设置它的单位时间过期，然后如果该值超频后会这是这个Key的过期时间为lockTime。</p><h2 id="序列号生成问题"><a href="#序列号生成问题" class="headerlink" title="序列号生成问题"></a>序列号生成问题</h2><p>项目中另一种常见的情况就是流水号的生成了，很多业务流水号有如下格式 XXXX2019040100001 等，我最近的一个项目就有类似的复杂需求，这种情况下我们可以使用Redis来生成某一天的自增流水号，大致如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RedisUtil redisUtil;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SequenceUtils</span><span class="params">(RedisUtil redisUtil)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.redisUtil = redisUtil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//业务规定序号为00001 ，00002  这种5位格式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_LENGTH = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">//缓存时长</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ONE_DAY_TIME = <span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REDIS_CACHE_KEY = <span class="string">"redis.serialnumber:%s:%s"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取自增数字的字符串形式,包含0前缀</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> seq</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getSequenceWithZeroPrefix</span><span class="params">(<span class="keyword">long</span> seq)</span> </span>&#123;</span><br><span class="line">        String str = String.valueOf(seq);</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        <span class="keyword">if</span> (len &gt;= DEFAULT_LENGTH) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Sequence generate failed!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rest = DEFAULT_LENGTH - len;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rest; i++) &#123;</span><br><span class="line">            sb.append(<span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(str);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取自增数字的字符串形式,不包含0前缀</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> seq</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getSequenceNoZeroPrefix</span><span class="params">(<span class="keyword">long</span> seq)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(seq);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列号生成器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bizCode  业务码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> needZero 是否需要0前缀</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">generate</span><span class="params">(String bizCode,<span class="keyword">boolean</span> needZero)</span></span>&#123;</span><br><span class="line">        String date = DateFormatUtils.format(<span class="keyword">new</span> Date(),<span class="string">"yyyyMMdd"</span>);</span><br><span class="line">        <span class="comment">//redis key</span></span><br><span class="line">        String key = String.format(REDIS_CACHE_KEY,bizCode,date);</span><br><span class="line">        <span class="comment">//自增并设置过期时间</span></span><br><span class="line">        <span class="keyword">long</span> sequence = redisUtil.incr(key);</span><br><span class="line">        redisUtil.expire(key,ONE_DAY_TIME);</span><br><span class="line"></span><br><span class="line">        String seq;</span><br><span class="line">        <span class="keyword">if</span>(needZero)&#123;</span><br><span class="line">            seq = getSequenceWithZeroPrefix(sequence);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            seq = getSequenceNoZeroPrefix(sequence);</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        sb.append(bizCode).append(date).append(seq);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为保证绝对可靠，还可以进行改善，当Redis拿不到值时可以去数据库初始化今天的起始流水号等，这儿不再过多介绍，可以看到主要就是利用了Redis的自增incr和指定时间过期expire这两个关键方法。</p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>还可以使用Redis做分布式锁，相比较之前说的Zookeeper实现分布式锁，使用Redis实现分布式锁，最明显的优点就是指令为内存操作，速度较快，性能较高；但缺点也比较明显，使用Redis实现分布式锁较为复杂，需要考虑超时、原子性、误删等情形，较为复杂，且由于没有等待锁的队列，等待锁只能依靠客户端自旋，效率较为低下。反观ZK实现的分布式锁，有等待锁的队列，但是添加删除节点性能较低。</p><p>我们使用Redis来简单实现一个分布式锁。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//锁的key前缀</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String LOCK_PREFIX=<span class="string">"redis.lock:%s"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RedisUtil redisUtil;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisLock</span><span class="params">(RedisUtil redisUtil)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.redisUtil = redisUtil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获得锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  String key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockTimeOut long 超时时间(毫秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 大于 0  获得到锁并,等于0获取锁失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">tryLock</span><span class="params">(String key,<span class="keyword">long</span> lockTimeOut)</span></span>&#123;</span><br><span class="line">        key= String.format(LOCK_PREFIX,key);</span><br><span class="line">        <span class="keyword">long</span> expireTime = <span class="number">0</span>;</span><br><span class="line">        expireTime = System.currentTimeMillis() + lockTimeOut +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(redisUtil.setStringIfNotExists(key, String.valueOf(expireTime))==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> expireTime;</span><br><span class="line">        &#125;<span class="keyword">else</span>  &#123;</span><br><span class="line">            String curLockTimeStr =  redisUtil.getString(key);</span><br><span class="line">            <span class="comment">//判断是否过期</span></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isBlank(curLockTimeStr) || System.currentTimeMillis() &gt; Long.valueOf(curLockTimeStr)) &#123;</span><br><span class="line">                expireTime = System.currentTimeMillis() + lockTimeOut +<span class="number">1</span>;</span><br><span class="line">                curLockTimeStr = redisUtil.getSet(key, String.valueOf(expireTime));</span><br><span class="line">                <span class="comment">//仍然过期,则得到锁</span></span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isBlank(curLockTimeStr) || System.currentTimeMillis() &gt; Long.valueOf(curLockTimeStr))&#123;</span><br><span class="line">                    <span class="keyword">return</span> expireTime;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一直等待获得锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key String key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockTimeOut   long  超时时间(毫秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> perSleeplong 获得锁循环等待休眠时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  大于 0  获得到锁并,等于0获取锁失败</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">lock</span><span class="params">(String key,<span class="keyword">long</span> lockTimeOut,<span class="keyword">long</span> perSleep)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        key= String.format(LOCK_PREFIX,key);</span><br><span class="line">        <span class="keyword">long</span> starttime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> sleep = (perSleep==<span class="number">0</span> ? lockTimeOut/ <span class="number">10</span> : perSleep);</span><br><span class="line">        <span class="comment">//得到锁后设置的过期时间，未得到锁返回0</span></span><br><span class="line">        <span class="keyword">long</span> expireTime = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            expireTime = System.currentTimeMillis() + lockTimeOut +<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (redisUtil.setStringIfNotExists(key, String.valueOf(expireTime)) == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//得到了锁返回</span></span><br><span class="line">                <span class="keyword">return</span> expireTime;</span><br><span class="line">            &#125;<span class="keyword">else</span>  &#123;</span><br><span class="line">                String curLockTimeStr =  redisUtil.getString(key);</span><br><span class="line">                <span class="comment">//判断是否过期</span></span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isBlank(curLockTimeStr) || System.currentTimeMillis() &gt; Long.valueOf(curLockTimeStr)) &#123;</span><br><span class="line">                    expireTime = System.currentTimeMillis() + lockTimeOut +<span class="number">1</span>;</span><br><span class="line">                    curLockTimeStr = redisUtil.getSet(key, String.valueOf(expireTime));</span><br><span class="line">                    <span class="comment">//仍然过期,则得到锁</span></span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.isBlank(curLockTimeStr) || System.currentTimeMillis() &gt; Long.valueOf(curLockTimeStr))&#123;</span><br><span class="line">                        <span class="keyword">return</span> expireTime;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        Thread.sleep(sleep);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread.sleep(sleep);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (lockTimeOut &gt; <span class="number">0</span> &amp;&amp; ((System.currentTimeMillis() - starttime) &gt;= lockTimeOut)) &#123;</span><br><span class="line">                expireTime = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> expireTime;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key String key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime   long  超时时间(毫秒)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">(String key,<span class="keyword">long</span> expireTime)</span></span>&#123;</span><br><span class="line">        key= String.format(LOCK_PREFIX,key);</span><br><span class="line">        <span class="keyword">if</span> (System.currentTimeMillis()-expireTime&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        String curLockTimeStr = redisUtil.getString(key);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(curLockTimeStr) &amp;&amp; Long.valueOf(curLockTimeStr)&gt;System.currentTimeMillis()) &#123;</span><br><span class="line">            redisUtil.delKey(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在等待锁的阶段，如果设置超时时间，则客户端只能自旋等待锁，如果在指定时间内未获得锁，就会超时。</p><p>可以看到主要逻辑是，首先使用setStringIfNotExists （对应Redis的set str  NX 命令）方法尝试设置key，如果成功说明获得锁，返回超时时间；如果不成功说明已经有程序在使用该锁，需要判断剩余过期时间，如果没有剩余过期时间，再尝试获得锁，否则线程sleep剩余过期时间。</p><p>可以看到，我们需要指定锁的使用时间，如果不指定时间，有可能会造成死锁等问题。</p><h2 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h2><p>Redis也可以用来实现配置中心的相关功能。</p><p>Redis 做配置中心，需要结合数据库来实现以确保稳定性。</p><p>数据库设计一张配置表用于存储配置数据，在Redis可以将数据存入哈希表来进行处理。</p><p>当然我们新增修改或者删除数据时需要同时对Redis和数据库进行操作。</p><p>并可以添加数据从Redis刷新到数据库和从数据库刷新到Redis等功能。</p><p>部分代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfigCenter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置中心key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIG_CENTER_KEY = <span class="string">"redis.configcenter:hash:key"</span>;</span><br><span class="line">    <span class="comment">//Redis 工具</span></span><br><span class="line">    <span class="keyword">private</span> RedisUtil redisUtil;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisConfigCenter</span><span class="params">(RedisUtil redisUtil)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.redisUtil = redisUtil;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置中心添加数据</span></span><br><span class="line"><span class="comment">     * 可以添加一个或多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insertData</span><span class="params">(Map&lt;String,String&gt; insertData)</span></span>&#123;</span><br><span class="line">        <span class="comment">//放入Redis hash表</span></span><br><span class="line">        <span class="keyword">boolean</span> exists = redisUtil.exists(CONFIG_CENTER_KEY);</span><br><span class="line">        <span class="keyword">if</span>(exists)&#123;</span><br><span class="line">            <span class="comment">//拿到key对应的Redis hash表数据</span></span><br><span class="line">            Map&lt;String,String&gt; redisMap = redisUtil.hashGetAll(CONFIG_CENTER_KEY);</span><br><span class="line">            insertData.putAll(redisMap);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//写入Redis hash表</span></span><br><span class="line">        redisUtil.hashMultipleSet(CONFIG_CENTER_KEY,insertData);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数据库处理部分代码略</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置中心更新数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> updateData</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">updateData</span><span class="params">(Map&lt;String,String&gt; updateData)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> exists = redisUtil.exists(CONFIG_CENTER_KEY);</span><br><span class="line">        <span class="keyword">if</span>(!exists)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"请先新增数据!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拿到key对应的Redis hash表数据</span></span><br><span class="line">        Map&lt;String,String&gt; redisMap = redisUtil.hashGetAll(CONFIG_CENTER_KEY);</span><br><span class="line">        redisMap.putAll(updateData);</span><br><span class="line">        <span class="comment">//写入Redis hash表</span></span><br><span class="line">        redisUtil.hashMultipleSet(CONFIG_CENTER_KEY,updateData);</span><br><span class="line">        <span class="comment">//数据库处理部分代码略</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置中心删除数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> deleteKeys</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteData</span><span class="params">(List&lt;String&gt; deleteKeys)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> exists = redisUtil.exists(CONFIG_CENTER_KEY);</span><br><span class="line">        <span class="keyword">if</span>(!exists)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"请先新增数据!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拿到key对应的Redis hash表数据</span></span><br><span class="line">        Map&lt;String,String&gt; redisMap = redisUtil.hashGetAll(CONFIG_CENTER_KEY);</span><br><span class="line">        deleteKeys.forEach(key-&gt;&#123;</span><br><span class="line">            redisMap.remove(key);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//写入Redis hash表</span></span><br><span class="line">        redisUtil.hashMultipleSet(CONFIG_CENTER_KEY,redisMap);</span><br><span class="line">        <span class="comment">//数据库处理部分代码略</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询数据列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String,String&gt; <span class="title">selectData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> exists = redisUtil.exists(CONFIG_CENTER_KEY);</span><br><span class="line">        <span class="keyword">if</span>(!exists)&#123;</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        &#125;</span><br><span class="line">        map = redisUtil.hashGetAll(CONFIG_CENTER_KEY);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数据库数据刷新到Redis</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">refreshToRedis</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//数据库获取到数据集合 略</span></span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//TODO</span></span><br><span class="line">        redisUtil.hashMultipleSet(CONFIG_CENTER_KEY,map);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Redis刷新到数据库</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">refreshToDataBase</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Map&lt;String,String&gt; map = redisUtil.hashGetAll(CONFIG_CENTER_KEY);</span><br><span class="line">        <span class="comment">//数据库操作，略</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，为保证数据可靠性，可以启动两个线程，指定时间从Redis刷新到数据库或者从数据库刷新到Redis的功能。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 可以改为配置的形式</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> refreshRedisThreadStop = <span class="keyword">false</span>;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> refreshDataBaseThreadStop = <span class="keyword">false</span>;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 刷新数据的线程</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 初始化</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// refresh thread</span></span><br><span class="line">     executorService.submit(() -&gt;&#123;</span><br><span class="line">         <span class="keyword">while</span> (!refreshRedisThreadStop) &#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="comment">//30 min 刷新一次</span></span><br><span class="line">                 TimeUnit.MINUTES.sleep(<span class="number">30</span>);</span><br><span class="line">                 refreshToRedis();</span><br><span class="line">             &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">     executorService.submit(() -&gt;&#123;</span><br><span class="line">         <span class="keyword">while</span> (!refreshDataBaseThreadStop) &#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="comment">//30 min 刷新一次</span></span><br><span class="line">                 TimeUnit.MINUTES.sleep(<span class="number">30</span>);</span><br><span class="line">                 refreshToDataBase();</span><br><span class="line">             &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>通过以上对Redis在应用中的各个功能的应用，让我们对Redis的应用有了更深入的了解，以及对Redis的应用场景有了更加深刻的认识。</p><p>Redis 在项目中基本上已经是很平常的存在了，如何使用好它，解决棘手问题乃是我们的重中之重。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="Redis" scheme="https://www.sakuratears.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>开发中遇到的一些问题与解决思路（1）</title>
    <link href="https://www.sakuratears.top/blog/%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF-1.html"/>
    <id>https://www.sakuratears.top/blog/开发中遇到的一些问题与解决思路-1.html</id>
    <published>2019-04-08T15:54:00.000Z</published>
    <updated>2019-06-09T03:00:35.715Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>整理了一下开发中遇到的一些问题及解决思路，特地分享下。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Mysql临时变量（局部变量）的使用"><a href="#Mysql临时变量（局部变量）的使用" class="headerlink" title="Mysql临时变量（局部变量）的使用"></a>Mysql临时变量（局部变量）的使用</h2><p>Mysql临时变量又称为局部变量，其带有@符号，使用时不需要声明，只在局部起作用。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><ul><li><p>set @num=1; 或set @num:=1; </p><p>这里要使用变量来保存数据，直接使用@num变量即可</p></li><li><p>select @num:=1; 或 select @num:=字段名 from 表名 where ……</p></li></ul><p>注意上面两种赋值符号，使用set时可以用“=”或“：=”，但是使用select时必须用“：=赋值”</p><p>巧妙的使用临时变量，可以解决我们遇到的一些比较棘手的问题。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>假设有一张客户表，<strong>customer</strong> ，其有字段 <strong>id</strong>（表示唯一id），字段 <strong>locale</strong> （表示国家，0001 中国，0002 美国，0003 日本 等），字段 <strong>create_time</strong> 表示这个用户的创建日期（yyyy-MM-dd hh:MM:ss）形式，等其他字段。</p><p>现在这张表已经上线一段时间，有了大量数据，由于某些原因（需求），需要新增字段 客户号 <strong>customer_no</strong> ，客户号的生成遵循一定规则，比如 2018-11-12 日当天第一个中国用户，则客户号为 CN201811120001 这种格式，第20个中国用户客户号为 CN201811120020，即用户号的生成规则是 <strong>国家简称 + 日期yyyyMMdd + 0001</strong> 递增，当天第一个美国用户客户号为 AM201811120001 这种形式，如果日期变为2018-11-13 则这一天的第一个中国用户为 CN201811130001 这种形式。</p><p>这儿就不讨论客户号之后的生成逻辑，现在这张表已经有一定量的数据，新增了客户号字段，需要维护旧数据的此字段，手动修改显然是不现实的……</p><p>这时候我们可以借助临时变量来实现对旧数据的更新维护，<strong>locale</strong>为中国（CN）的代码更新可以如下（其它国家类似）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 临时自增变量</span></span><br><span class="line"><span class="keyword">SET</span> @<span class="keyword">rownum</span> = <span class="number">0</span>;</span><br><span class="line"><span class="comment">-- 初始值，需要手动设置，选择一个日期</span></span><br><span class="line"><span class="keyword">SET</span> @startdate = <span class="string">'20181227'</span>;</span><br><span class="line"><span class="comment">-- 更新语句</span></span><br><span class="line"><span class="keyword">UPDATE</span> customer p</span><br><span class="line"><span class="keyword">SET</span> p.customer_no = (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">b.num</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">            <span class="keyword">CASE</span> <span class="keyword">DATE_FORMAT</span>(a.create_time, <span class="string">"%Y%m%d"</span>)</span><br><span class="line"><span class="keyword">WHEN</span> @startdate <span class="keyword">THEN</span></span><br><span class="line">@<span class="keyword">rownum</span> :=@<span class="keyword">rownum</span> + <span class="number">1</span></span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">@<span class="keyword">rownum</span> := <span class="number">1</span></span><br><span class="line"><span class="keyword">END</span> <span class="keyword">as</span> temp,</span><br><span class="line"><span class="keyword">CONCAT</span>(</span><br><span class="line"><span class="string">'CN'</span>,</span><br><span class="line"><span class="keyword">DATE_FORMAT</span>(a.create_time, <span class="string">"%Y%m%d"</span>),</span><br><span class="line"><span class="keyword">CASE</span></span><br><span class="line"><span class="keyword">WHEN</span> @<span class="keyword">rownum</span> &gt; <span class="number">999</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="string">''</span></span><br><span class="line"><span class="keyword">WHEN</span> @<span class="keyword">rownum</span> &gt; <span class="number">99</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="string">'0'</span></span><br><span class="line"><span class="keyword">WHEN</span> @<span class="keyword">rownum</span> &gt; <span class="number">9</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="string">'00'</span></span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line"><span class="string">'000'</span></span><br><span class="line"><span class="keyword">END</span>,</span><br><span class="line">@<span class="keyword">rownum</span></span><br><span class="line">) <span class="keyword">AS</span> <span class="keyword">num</span>,</span><br><span class="line">(</span><br><span class="line"><span class="keyword">CASE</span> <span class="keyword">DATE_FORMAT</span>(a.create_time, <span class="string">"%Y%m%d"</span>)</span><br><span class="line"><span class="keyword">WHEN</span> @startdate <span class="keyword">THEN</span></span><br><span class="line">@startdate</span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">@startdate := <span class="keyword">DATE_FORMAT</span>(a.create_time, <span class="string">"%Y%m%d"</span>)</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">) <span class="keyword">AS</span> helpdata,</span><br><span class="line">a.id <span class="keyword">AS</span> <span class="keyword">id</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">customer a</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"><span class="number">1</span> = <span class="number">1</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> p.create_time <span class="keyword">asc</span></span><br><span class="line">) <span class="keyword">AS</span> b</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">b.id = p.id</span><br><span class="line">)</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">p.locale = <span class="string">'0001'</span>;</span><br></pre></td></tr></table></figure><p>可以看到这个SQL超级长，其实不算复杂，其<strong>customer_no</strong>的赋值就是借助了两个临时变量进行的，可以看到第一个<strong>@rownum</strong>临时变量，用来进行自增，拼接为0001、0010等等这种形式。</p><p>为什么还有个<strong>@startdate</strong>临时变量呢？</p><p>这个变量主要用来记录上一条的时间跟要更新的这一条的时间是否一致，一致的话<strong>@rownum</strong>自增1，不一致说明是新的时间，<strong>@rownum</strong>重新从1开始，这样做的前提保证是数据要根据<strong>create_time</strong>进行排序，即 <code>ORDER BY p.create_time asc</code>的作用。</p><p>同时我们还可以看到我们借助了中间表b实现了对<strong>@startdate</strong>的赋值。</p><p>其实主要思想可以如下分解，更新表里的旧数据，需要将<strong>customer_no</strong>赋值，则可以先写一个select语句查询出 CN201811120001 这种形式的一张表，通过<code>b.id = p.id</code>实现关联到指定的要更新的数据，然后进行数据update。</p><p>这属于一个较复杂的Mysql临时变量的使用例子，临时变量虽然在Mysql查询等语句中使用的不多，但是关键时候还是有很大作用的。</p><h2 id="使用并行流时，必须保证操作对象的线程安全性"><a href="#使用并行流时，必须保证操作对象的线程安全性" class="headerlink" title="使用并行流时，必须保证操作对象的线程安全性"></a>使用并行流时，必须保证操作对象的线程安全性</h2><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">//构造一个源数据List</span></span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">100000</span>;i++)&#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//线程同步的ArrayList</span></span><br><span class="line">    List&lt;Integer&gt; list1 = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    <span class="comment">//普通的ArrayList</span></span><br><span class="line">    List&lt;Integer&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//并行流处理</span></span><br><span class="line">    list.parallelStream().forEach(e-&gt;&#123;</span><br><span class="line">        list1.add(e);</span><br><span class="line">        list2.add(e);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//输出结果</span></span><br><span class="line">    System.out.println(list1.size());</span><br><span class="line">    System.out.println(list2.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100000</span><br><span class="line">99785</span><br></pre></td></tr></table></figure><p>可以看到list2 数据不正常，多运行几次，可以发现list2有时候正常，有时候不正常，有时候甚至会出现数组下标越界异常等情况。</p><p>而list1的数据结果一直没有问题。</p><p>所以在操作ArrayList的不安全操作时（或者其他不安全数据结构），如add，delete等，如果使用并行流，必须保证被操作对象的线程安全性。</p><p>上述情况一般有两种解决办法：</p><ol><li>使用线程安全的对象，如ArrayList使用Collections.synchronizedList 方法变为同步的List，或者使用Vector等。</li><li>抛弃并行流，使用串行流或者其他解决办法。</li></ol><h2 id="Java8-lambda表达式无法抛出受检查异常的问题"><a href="#Java8-lambda表达式无法抛出受检查异常的问题" class="headerlink" title="Java8 lambda表达式无法抛出受检查异常的问题"></a>Java8 lambda表达式无法抛出受检查异常的问题</h2><p>我们知道Java异常分为两类，受检查异常（Checked Exception）跟非受检异常（UnChecked Exception）。</p><p>对于受检查异常，代码中必须显式处理该异常，不然编译不通过，如IOException等。</p><p>而对于非受检查异常，或称为运行时异常，可以不用处理，如RunTimeException等。</p><p>对于一个方法，如果方法内部抛出受检查异常，则方法本身也要显式抛出异常。</p><p>我们来看下下面两个例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">"1"</span>);</span><br><span class="line">    list.stream().forEach(e-&gt;&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Exception"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">"1"</span>);</span><br><span class="line">    list.stream().forEach(e-&gt;&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Exception"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到第二个main方法是编译不通过的，因为抛出了受检查异常，而它lambda表达式如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consumer consumer = e-&gt;&#123;<span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Exception"</span>);&#125;;</span><br></pre></td></tr></table></figure><p>由于Consumer执行的accept方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>故需要该方法抛出受检查异常才可以，显然我们是无法修改Java源码的。</p><p>对于其它函数式接口lambda表达式亦是如此。</p><p>那如何处理这种情况呢？</p><p>在程序代码想使用lambda表达式的情况下，大致有如下两种办法：</p><ol><li><p>将受检查异常包装成非受检查异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.stream().forEach(e-&gt;&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="keyword">new</span> IOException(<span class="string">"Exception"</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样虽然解决了问题，但是破坏了异常结构，代码也不是很美观，在涉及到一些事务的方法上，还会导致不能正确捕捉异常进行回滚而产生一些问题等。</p><p>不推荐使用。</p></li><li><p>包装泛型异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">"1"</span>);</span><br><span class="line">    list.stream().forEach(e-&gt;&#123;</span><br><span class="line">        doThrow(<span class="keyword">new</span> IOException());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E extends Exception&gt; <span class="function"><span class="keyword">void</span> <span class="title">doThrow</span><span class="params">(Exception e)</span> <span class="keyword">throws</span> E </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> (E)e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们利用异常泛型包装了异常处理，这时候编译器不能明确异常类型，因此编译通过。</p><p>这时候我们在测试，可以看到lambda表达式运行后抛出了我们期望的IOException。</p></li></ol><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>以后再有开发相关方面的问题，值得记录和分享的，我会在更新。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="MySQL" scheme="https://www.sakuratears.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>PDF.js插件</title>
    <link href="https://www.sakuratears.top/blog/PDF-js%E6%8F%92%E4%BB%B6.html"/>
    <id>https://www.sakuratears.top/blog/PDF-js插件.html</id>
    <published>2019-03-14T13:01:00.000Z</published>
    <updated>2019-03-14T13:18:18.734Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天我们来学习下一款非常有意思的插件PDF.js，正如它的名字一样，它是由Mozilla开源的，用来在Web浏览器上预览PDF文件的一款插件。</p><p>我们知道，目前很多浏览器已经支持了PDF的在线预览及下载功能，但是展示的样式各异，并且一部分手机浏览器并不支持预览，在开发WebApp遇到预览PDF的功能，可能需要下载下来借助手机第三方软件打开，显然用户体验不够友好。</p><p>而PDF.js恰恰解决了以上问题。</p><p>如果说PDF.js的缺点，那大概就是它不支持IE 8 及以下浏览器。（PS:PDF.js使用了HTML 5的相关技术，如canvas，理论上不支持HTML 5的浏览器均不能使用）</p><p>项目地址：<a href="https://mozilla.github.io/pdf.js/" rel="external nofollow noopener noreferrer" target="_blank">https://mozilla.github.io/pdf.js/</a></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>我们来了解并使用下这款插件。</p><p>根据上面地址，我们可以下载PDF.js的预编译版本和源码。</p><p>PDF.js提供的预编译版本是可以直接使用的，当然我们也可以使用源码自己编译生成PDF.js插件。</p><p>我们来简单说下PDF.js预编译版本的基本构成，截止当前，我使用的是 Stable(v2.0.943) 的预编译版本。</p><p>它的结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">├── build/</span><br><span class="line">│   ├── pdf.js                             - display layer</span><br><span class="line">│   ├── pdf.js.map                         - display layer&apos;s source map</span><br><span class="line">│   ├── pdf.worker.js                      - core layer</span><br><span class="line">│   └── pdf.worker.js.map                  - core layer&apos;s source map</span><br><span class="line">├── web/</span><br><span class="line">│   ├── cmaps/                             - character maps (required by core)</span><br><span class="line">│   ├── compressed.tracemonkey-pldi-09.pdf - PDF file for testing purposes</span><br><span class="line">│   ├── debugger.js                        - helpful debugging features</span><br><span class="line">│   ├── images/                            - images for the viewer and annotation icons</span><br><span class="line">│   ├── locale/                            - translation files</span><br><span class="line">│   ├── viewer.css                         - viewer style sheet</span><br><span class="line">│   ├── viewer.html                        - viewer layout</span><br><span class="line">│   ├── viewer.js                          - viewer layer</span><br><span class="line">│   └── viewer.js.map                      - viewer layer&apos;s source map</span><br><span class="line">└── LICENSE</span><br></pre></td></tr></table></figure><p>主要由build和web包构成，build包里的pdf.worker.js是PDF.js的核心处理包，web包里的viewer.js viewer.html viewer.css 用来在Web页面上展示渲染PDF（边框，工具栏等）。</p><p>images文件夹里存放一些工具栏图标等内容，locale文件夹里存放各地区语言包。</p><p>debugger.js 是debug相关js，我们在使用时可以开启debug输出某些信息来进行调试。</p><p>compressed.tracemonkey-pldi-09.pdf 是一个PDF测试类，当我们没有加载自己定义的PDF时，会默认加载此文件。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="集成PDF-js插件"><a href="#集成PDF-js插件" class="headerlink" title="集成PDF.js插件"></a>集成PDF.js插件</h3><p>我们在SpringBoot项目下引入PDF.js插件并简单使用。</p><p>我们新建SpringBoot项目，引入Web模块，生成项目后，我们只需在项目的static文件夹下引入预编译版本的PDF.js即可。</p><p>如图：</p><p>PS: 为方便管理，我把PDF.js插件放到了一个pdfViewer文件夹里。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-396.png" alt="upload successful"></p><p>我们启动项目，通过浏览器访问viewer.html，即 <a href="http://localhost:8080/pdfViewer/web/viewer.html" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:8080/pdfViewer/web/viewer.html</a></p><p>可以看到成功打开了我们的测试PDF。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-397.png" alt="upload successful"></p><p>我们如果想打开自己的PDF应该如何操作呢？</p><p>我们可以在上述网络地址上加上file参数指向我们的PDF。 <a href="http://localhost:8080/pdfViewer/web/viewer.html?file=...." rel="external nofollow noopener noreferrer" target="_blank">http://localhost:8080/pdfViewer/web/viewer.html?file=....</a>. 的形式。</p><p>我们在项目static文件夹中新建pdf包，放入我们的PDF，如下：</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-398.png" alt="upload successful"></p><p>PDF文件在本项目中，访问有两种方式，网络路径访问和相对路径访问。</p><ul><li><p>相对路径访问。</p><p>通过  <a href="http://localhost:8080/pdfViewer/web/viewer.html?file=../../pdf/IT%E5%85%A5%E8%81%8C%E6%8C%87%E5%8D%97.pdf" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:8080/pdfViewer/web/viewer.html?file=../../pdf/IT%E5%85%A5%E8%81%8C%E6%8C%87%E5%8D%97.pdf</a> 进行访问。</p><p>可以看到file后面跟的路径是PDF文件相对于viewer.html的路径。</p></li><li><p>网络路径访问。</p><p>通过 <a href="http://localhost:8080/pdfViewer/web/viewer.html?file=http://localhost:8080/pdf/IT%E5%85%A5%E8%81%8C%E6%8C%87%E5%8D%97.pdf" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:8080/pdfViewer/web/viewer.html?file=http://localhost:8080/pdf/IT%E5%85%A5%E8%81%8C%E6%8C%87%E5%8D%97.pdf</a> 进行访问。</p><p>file后面跟的参数是PDF所在的网络地址。</p></li></ul><p>最后预览效果如下图：</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-399.png" alt="upload successful"></p><p>如果PDF文件不在本项目中呢？那一定会出现跨域问题，我们来看一下。</p><p>访问 <a href="http://localhost:8080/pdfViewer/web/viewer.html?file=http://localhost:8081/pdf/IT%E5%85%A5%E8%81%8C%E6%8C%87%E5%8D%97.pdf" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:8080/pdfViewer/web/viewer.html?file=http://localhost:8081/pdf/IT%E5%85%A5%E8%81%8C%E6%8C%87%E5%8D%97.pdf</a> 可以看到文件不存在。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-400.png" alt="upload successful"></p><p>我们F12查看信息，可以看到PDF.js插件出现如下错误：<code>Uncaught (in promise) Error: file origin does not match viewer’s</code></p><p>说明出现了跨域问题。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-401.png" alt="upload successful"></p><p>如何解决呢？ 毕竟不是所有的PDF文件都会放在项目中的。</p><p>这就需要解决跨域问题，通常有两种方法：</p><p>我们如果仍使用路径的方式，则需要对PDF.js进行配置，通过刚才报错的信息，我们很容易在viewer.js 里找到如下内容。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-402.png" alt="upload successful"></p><p>这段js很好理解，设置允许跨域的路径，我们把我们的服务器网络路径添加到HOSTED_VIEWER_ORIGINS对象里，<a href="http://localhost:8080。" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:8080。</a></p><p>PS: 这里要注意，viewer.js.map 文件里的 HOSTED_VIEWER_ORIGINS 对象也要改变（预编译版本），否则你会看到很奇怪的缓存问题。</p><p>但这样仍是不行的，我们尝试访问 <a href="http://localhost:8080/pdfViewer/web/viewer.html?file=http://localhost:8081/pdf/IT%E5%85%A5%E8%81%8C%E6%8C%87%E5%8D%97.pdf" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:8080/pdfViewer/web/viewer.html?file=http://localhost:8081/pdf/IT%E5%85%A5%E8%81%8C%E6%8C%87%E5%8D%97.pdf</a> 可以看到跨域问题仍然存在。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-403.png" alt="upload successful"></p><p>因为要解决跨域问题，服务器也需要进行设置，我们找到8081服务器，添加跨域设置，主要内容如下（SpringBoot项目）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsFilter <span class="title">corsFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UrlBasedCorsConfigurationSource source = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">        CorsConfiguration corsConfiguration = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">        String apiAllowOrigins = <span class="string">"http://localhost:8080"</span>;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(apiAllowOrigins))&#123;</span><br><span class="line">            corsConfiguration.addAllowedOrigin(<span class="string">"*"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            corsConfiguration.setAllowedOrigins(Arrays.asList(apiAllowOrigins.split(<span class="string">","</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        corsConfiguration.addAllowedHeader(<span class="string">"*"</span>);</span><br><span class="line">        corsConfiguration.setAllowedMethods(Arrays.asList(<span class="string">"HEAD"</span>,<span class="string">"POST"</span>, <span class="string">"OPTIONS"</span>,<span class="string">"GET"</span>));</span><br><span class="line">        corsConfiguration.setAllowCredentials(<span class="keyword">true</span>);</span><br><span class="line">        corsConfiguration.setMaxAge(<span class="number">3600L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//跨域设置</span></span><br><span class="line">        source.registerCorsConfiguration(<span class="string">"/**"</span>, corsConfiguration);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsFilter(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码很好理解，apiAllowOrigins设置成我们请求的服务器地址即可。</p><p>这时候我们在访问上面的PDF地址，可以看到PDF被加载出来了。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-404.png" alt="upload successful"></p><p>我们也可以使用流的方式来加载远程的PDF文件，当然也需要设置跨域属性。</p><p>上面的CorsConfig.java 在8081服务器上保持不变，我们在该项目里新增一个类PDFController，用于解析文件并返回流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PDFController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/getPDF"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPDF</span><span class="params">(@RequestParam(<span class="string">"fileName"</span>)</span> String fileName, HttpServletRequest request, HttpServletResponse response) <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        response.setStatus(HttpServletResponse.SC_OK);</span><br><span class="line">        response.setContentType(<span class="string">"application/pdf;charset=UTF-8"</span>);</span><br><span class="line">        <span class="comment">//PDF文件在服务器上的位置，可以通过程序获取，略，我直接写死了</span></span><br><span class="line">        <span class="keyword">try</span>(FileInputStream input =<span class="keyword">new</span> FileInputStream(<span class="string">"E:\\WorkSpace\\spring-cloud\\pdf1-service\\src\\main\\resources\\static\\pdf\\"</span>+fileName);</span><br><span class="line">            ServletOutputStream out = response.getOutputStream())&#123;</span><br><span class="line">            <span class="keyword">byte</span> buffBytes[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> read = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((read = input.read(buffBytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                out.write(buffBytes, <span class="number">0</span>, read);</span><br><span class="line">            &#125;</span><br><span class="line">            out.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我这里传入了fileName属性来获取PDF流。</p><p>这样在调用PDF.js 插件时，需要先通过ajax获取PDF流拿到PDF，并提供给PDF.js插件。</p><p>我们打开viewer.js 找到如下代码。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-405.png" alt="upload successful"></p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-406.png" alt="upload successful"></p><p>这个方法是webView初始化方法，如果没有传file属性，就加载默认的PDF文件。</p><p>我们把 <code>file = ‘file’ in params ? params.file : _app_options.AppOptions.get(‘defaultUrl’);</code> 这段代码换成如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file = <span class="string">'file'</span> <span class="keyword">in</span> params ? params.file : DEFAULT_URL;</span><br></pre></td></tr></table></figure><p>很好理解，就是不用它的默认值，我们传入一个DEFAULT_URL值。</p><p>我们新建helper.js，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> DEFAULT_URL = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">var</span> PDFData = <span class="string">""</span>;</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    type:<span class="string">"post"</span>,</span><br><span class="line">    <span class="keyword">async</span>:<span class="literal">false</span>, </span><br><span class="line">    mimeType: <span class="string">'text/plain; charset=x-user-defined'</span>,</span><br><span class="line">    url:<span class="string">"http://localhost:8081/getPDF"</span>,</span><br><span class="line">    data:&#123;<span class="attr">fileName</span>:<span class="string">"IT入职指南.pdf"</span>&#125;,</span><br><span class="line">    success:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        PDFData = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> rawLength = PDFData.length;</span><br><span class="line"><span class="comment">//转换成pdf.js能直接解析的Uint8Array类型</span></span><br><span class="line"><span class="keyword">var</span> array = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(rawLength));</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; rawLength; i++) &#123;</span><br><span class="line">    array[i] = PDFData.charCodeAt(i) &amp; <span class="number">0xff</span>;</span><br><span class="line">&#125;</span><br><span class="line">DEFAULT_URL = array;</span><br></pre></td></tr></table></figure><p>并在PDF.js插件的web包下引入helper.js 和 jquery.js。</p><p>PS: jquery.js 的引用就使用了一个ajax，如果由其他的ajax方案可以不引入jquery。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-407.png" alt="upload successful"></p><p>并在viewer.html里引入依赖，需要在viewer.js 之前引入。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.....部分代码略</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../build/pdf.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"jquery-3.3.1.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"helper.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"viewer.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">.......部分代码略</span><br></pre></td></tr></table></figure><p>设置好后，我们重新启动下服务器，可以看到PDF文件被加载了。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-408.png" alt="upload successful"></p><p>PS:根据上面，我们可以看到当不传入file参数时，PDF.js会加载默认配置，我们可以通过js等控制这个默认配置，让PDF.js每次打开的都是 <a href="http://localhost:8080/pdfViewer/web/viewer.html" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:8080/pdfViewer/web/viewer.html</a> ，但是PDF文件变化，以实现不显示file参数的需求。</p><h3 id="PDF-js-插件的个性化需求"><a href="#PDF-js-插件的个性化需求" class="headerlink" title="PDF.js 插件的个性化需求"></a>PDF.js 插件的个性化需求</h3><p>我们使用了PDF.js 插件后，可以看到功能很全，什么工具栏，放大缩小，打印，下载等等功能一应俱全，但现实中我们有可能是不需要这么多的。</p><p>尤其在WebApp中，我们可能仅仅可以查看PDF即可，偶尔可以有个放大缩小功能，这样应该如何处理呢。</p><p>这项功能的实现是非常简单的，我们找到该功能的按钮的button，直接添加hidden属性即可。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-409.png" alt="upload successful"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"sidebarToggle"</span> <span class="attr">class</span>=<span class="string">"toolbarButton"</span> <span class="attr">title</span>=<span class="string">"Toggle Sidebar"</span> <span class="attr">tabindex</span>=<span class="string">"11"</span> <span class="attr">data-l10n-id</span>=<span class="string">"toggle_sidebar"</span> <span class="attr">hidden</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">data-l10n-id</span>=<span class="string">"toggle_sidebar_label"</span>&gt;</span>Toggle Sidebar<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"toolbarButtonSpacer"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"viewFind"</span> <span class="attr">class</span>=<span class="string">"toolbarButton"</span> <span class="attr">title</span>=<span class="string">"Find in Document"</span> <span class="attr">tabindex</span>=<span class="string">"12"</span> <span class="attr">data-l10n-id</span>=<span class="string">"findbar"</span> <span class="attr">hidden</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">data-l10n-id</span>=<span class="string">"findbar_label"</span>&gt;</span>Find<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">......</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"secondaryToolbarToggle"</span> <span class="attr">class</span>=<span class="string">"toolbarButton"</span> <span class="attr">title</span>=<span class="string">"Tools"</span> <span class="attr">tabindex</span>=<span class="string">"36"</span> <span class="attr">data-l10n-id</span>=<span class="string">"tools"</span> <span class="attr">hidden</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">span</span> <span class="attr">data-l10n-id</span>=<span class="string">"tools_label"</span>&gt;</span>Tools<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure><h3 id="PDF-js-踩坑记"><a href="#PDF-js-踩坑记" class="headerlink" title="PDF.js 踩坑记"></a>PDF.js 踩坑记</h3><ol><li><p>关于过大PDF无法显示的问题</p><p>曾经遇到过测试环境PDF文件预览正常但是生产环境部分过大PDF文件无法打开的问题，后查看请求发现GET请求的range范围为0-65535，判断可能是服务器对 Range 进行了某些特殊限制。</p><p>而PDF.js 插件里有一项参数是可以禁止使用Range的，在viewer.js defaultOptions 对象里，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> defaultOptions = &#123;</span><br><span class="line">      disableRange: &#123;</span><br><span class="line">         value: <span class="literal">false</span>,</span><br><span class="line">         kind: OptionKind.API</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将属性设置为true得以解决问题。（如果不生效，可能是map文件存在的缘故，需要重新生成viewer.js.map文件）</p></li><li><p>PDF无法正常显示</p><p>如果相对路径无法加载，可尝试网络路径。</p><p>如果使用的是网络路径扔无法加载，可以对网络路径进行encode编码在返回给前端调用。</p><p>如果仍不可以，可以考虑使用流传输的方式。</p></li><li><p>关于PDF.js 插件的缓存问题</p><p>使用PDF.js插件过程中，你会发现它会缓存看过的PDF的阅读位置，这本是一项人性化的设定，但如果你就是想每次打开PDF文件后从头开始看起，请使用 disableHistory 参数。</p><p>它也在defaultOptions对象里，默认false，改为true后每次再打开这个PDF文件时就会从第一页看起。</p></li><li><p>viewer.js defaultOptions 对象</p><p>可以看到PDF.js 插件  defaultOptions 对象里还有很多很多的默认参数，我们都是可以对其进行设置以实现相关功能或者禁用相关功能的。</p><p>关于它们的用法，可以参考一些相关文档，这儿就不做过多叙述了。</p></li></ol><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>今天主要介绍了PDF.js 插件的使用，这是一款非常优秀的插件，在WebApp 预览PDF文件时经常会被使用，而且 Mozilla 以后有意将该插件集成到 FireFox 浏览器里，并且通过该插件立志于打造一项Web浏览PDF文件的标准。</p><p>让我们拭目以待吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="JavaScript" scheme="https://www.sakuratears.top/tags/JavaScript/"/>
    
      <category term="PDF.js" scheme="https://www.sakuratears.top/tags/PDF-js/"/>
    
  </entry>
  
  <entry>
    <title>搭建自己的Hexo博客（3）</title>
    <link href="https://www.sakuratears.top/blog/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2%EF%BC%883%EF%BC%89.html"/>
    <id>https://www.sakuratears.top/blog/搭建自己的Hexo博客（3）.html</id>
    <published>2019-03-12T06:40:00.000Z</published>
    <updated>2019-07-23T14:07:06.144Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>接 <a href="https://www.sakuratears.top/blog/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2%EF%BC%882%EF%BC%89.html">搭建自己的Hexo博客（2）</a> 这篇文章，时隔一段时间，我对自己的博客陆陆续续又进行了部分优化，特地总结了下。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="图片存储问题"><a href="#图片存储问题" class="headerlink" title="图片存储问题"></a>图片存储问题</h2><p>原来blog的图片也随静态页面托管在Github Pages 上的，后来页面访问加载速度很慢，而且图片本来较大，上传至Github上也是比较费劲的。</p><p>就考虑到将其存储到OSS服务上，由于我的域名没有经过网络备案，因此无法开启CDN服务，开启CDN服务后可以进一步提高图片加载速度。</p><p>我的域名在阿里云申请的，进而选择了阿里云的OSS服务。</p><p>PS：当然，对于阿里云，CDN服务和OSS服务都是要收取一定费用的。</p><p>我们登陆阿里云，选择对象存储OSS服务，如未开通请选择开通，而后新建一个我们blog的Bucket，找到文件管理选项，选择上传文件，上传我们的blog图片，上传成功后，可以通过复制图片URL的方式拿到图片地址，将博文中的图片地址指向此路径即可。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-385.png" alt="upload successful"></p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-386.png" alt="upload successful"></p><p>因为上传到OSS图片并在blog中使用后，图片的地址会被暴露在网页上，为了防止图片地址被盗用，我们可以设置只允许我们的域名可以访问图片，以进一步确保安全，如下：</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-387.png" alt="upload successful"></p><h2 id="添加相册功能"><a href="#添加相册功能" class="headerlink" title="添加相册功能"></a>添加相册功能</h2><p>我们为blog添加相册功能，进一步美化blog。</p><p>我们可以为相册增加一个标签，如图所示，点击进入到相册页面。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-388.png" alt="upload successful"></p><p>在 next 主题的config文件里添加相册(photos)标签，如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">  home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line"><span class="attr">  about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">user</span></span><br><span class="line"><span class="attr">  tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">  categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line"><span class="attr">  archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || heartbeat</span></span><br><span class="line"><span class="attr">  support:</span> <span class="string">/support/</span> <span class="string">||</span> <span class="string">support</span></span><br><span class="line"><span class="attr">  photos:</span> <span class="string">/photos/</span> <span class="string">||</span> <span class="string">photo</span></span><br></pre></td></tr></table></figure><p>PS: 如果不显示中文（相册），只显示photos，需要在next主题里的languages/zh-Hans.yml 里配置 <code>photos: 相册</code>。</p><p>添加完标签后，回到hexo的source文件夹，在里面新建photos文件夹，并在该文件夹里新建index.md 文件，内容如下：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">title: 相册</span><br><span class="line">comments: false</span><br><span class="line">type: photos</span><br><span class="line">noDate: true</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"ImageGrid"</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>ImageGrid的div即用来存放相册的一个div。</p><p>我们在博客的根目录下新建photosTool.js，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">const</span> sizeOf = <span class="built_in">require</span>(<span class="string">'image-size'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="string">"source/images_backup/photos"</span>;</span><br><span class="line"><span class="keyword">const</span> output = <span class="string">"source/photos/photos.json"</span>;</span><br><span class="line"><span class="keyword">var</span> dimensions;</span><br><span class="line">fs.readdir(path, <span class="function"><span class="keyword">function</span>(<span class="params">err, files</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> <span class="title">iterator</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == files.length) &#123;</span><br><span class="line">            fs.writeFile(output, <span class="built_in">JSON</span>.stringify(arr, <span class="literal">null</span>, <span class="string">"\t"</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fs.stat(path + <span class="string">"/"</span> + files[index], <span class="function"><span class="keyword">function</span>(<span class="params">err, stats</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!files[index].endsWith(<span class="string">".jpg"</span>) || files[index].endsWith(<span class="string">".jpeg"</span>)) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stats.isFile()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (files[index].endsWith(<span class="string">".jpg"</span>) || files[index].endsWith(<span class="string">".jpeg"</span>) ||</span><br><span class="line">                    files[index].endsWith(<span class="string">".mp4"</span>) || files[index].endsWith(<span class="string">".png"</span>) || files[index].endsWith(<span class="string">".gif"</span>)) &#123;</span><br><span class="line">                    dimensions = sizeOf(path + <span class="string">"/"</span> + files[index]);</span><br><span class="line">                    <span class="built_in">console</span>.log(dimensions.width, dimensions.height);</span><br><span class="line">                    arr.push(dimensions.width + <span class="string">'.'</span> + dimensions.height + <span class="string">' '</span> + files[index]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            iterator(index + <span class="number">1</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;(<span class="number">0</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个js用于获取图片的长和宽，以便可以获得更好的展示效果，同时，她会生成一个photos.json的文件，里面保存这图片的长和宽，如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">photo<span class="number">-1</span><span class="number">-1.</span>jpg,</span><br><span class="line"><span class="string">"3200.2000 photo-10.jpg"</span>,</span><br><span class="line"><span class="string">"1920.1200 photo-11.jpg"</span>,</span><br><span class="line"><span class="string">"1920.1080 photo-12.jpg"</span>,</span><br><span class="line"><span class="string">"1920.1200 photo-13.jpg"</span>,</span><br><span class="line"><span class="string">"1920.1080 photo-14.jpg"</span>,</span><br><span class="line"><span class="string">"1920.1080 photo-15.jpg"</span>,</span><br><span class="line"><span class="string">"1920.1200 photo-16.jpg"</span>,</span><br><span class="line"><span class="string">"1920.1080 photo-17.jpg"</span>,</span><br><span class="line"><span class="string">"1920.1186 photo-18.jpg"</span>,</span><br><span class="line"><span class="string">"1920.1080 photo-19.jpg"</span>,</span><br><span class="line"><span class="string">"1024.610 photo-2.jpg"</span>,</span><br><span class="line"><span class="string">"2200.1400 photo-3.jpg"</span>,</span><br><span class="line"><span class="string">"1200.750 photo-4.jpg"</span>,</span><br><span class="line"><span class="string">"3500.1898 photo-5.jpg"</span>,</span><br><span class="line"><span class="string">"1080.1920 photo-6.jpg"</span>,</span><br><span class="line"><span class="string">"1600.1120 photo-7.jpg"</span>,</span><br><span class="line"><span class="string">"1728.1080 photo-8.jpg"</span>,</span><br><span class="line"><span class="string">"1920.1080 photo-9.jpg"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这个文件我生成在了photos文件夹下。</p><p>可以看到它们的图片是从<code>source/images_backup/photos</code>路径下获取的。</p><p>为提高相应速度，需要将这些图片放到阿里云OSS上，存放到上面后，我们需要一个photos.js来解析图片并展示。</p><p>找到<code>themes/next/source/js/src</code>文件夹，新建photos.js文件，内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">photo = &#123;</span><br><span class="line">    page: <span class="number">1</span>,</span><br><span class="line">    offset: <span class="number">20</span>,</span><br><span class="line">    init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">        $.getJSON(<span class="string">"/photos/photos.json"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">            that.render(that.page, data);</span><br><span class="line">            <span class="comment">//that.scroll(data);</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params">page, data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> begin = (page - <span class="number">1</span>) * <span class="keyword">this</span>.offset;</span><br><span class="line">        <span class="keyword">var</span> end = page * <span class="keyword">this</span>.offset;</span><br><span class="line">        <span class="keyword">if</span> (begin &gt;= data.length) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">var</span> html, imgNameWithPattern, imgName, imageSize, imageX, imageY, li = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = begin; i &lt; end &amp;&amp; i &lt; data.length; i++) &#123;</span><br><span class="line">            imgNameWithPattern = data[i].split(<span class="string">' '</span>)[<span class="number">1</span>];</span><br><span class="line">            imgName = imgNameWithPattern.split(<span class="string">'.'</span>)[<span class="number">0</span>]</span><br><span class="line">            imageSize = data[i].split(<span class="string">' '</span>)[<span class="number">0</span>];</span><br><span class="line">            imageX = imageSize.split(<span class="string">'.'</span>)[<span class="number">0</span>];</span><br><span class="line">            imageY = imageSize.split(<span class="string">'.'</span>)[<span class="number">1</span>];</span><br><span class="line">            li += <span class="string">'&lt;div class="card" style="width:330px"&gt;'</span> +</span><br><span class="line">                <span class="string">'&lt;div class="ImageInCard" style="height:'</span> + <span class="number">330</span> * imageY / imageX + <span class="string">'px"&gt;'</span> +</span><br><span class="line">                <span class="string">'&lt;a data-fancybox="gallery" href="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/photos/'</span> + imgNameWithPattern + <span class="string">'?raw=true" data-caption="'</span> + imgName + <span class="string">'"&gt;'</span> +</span><br><span class="line">                <span class="string">'&lt;img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/photos/'</span> + imgNameWithPattern + <span class="string">'?raw=true"/&gt;'</span> +</span><br><span class="line">                <span class="string">'&lt;/a&gt;'</span> +</span><br><span class="line">                <span class="string">'&lt;/div&gt;'</span> +</span><br><span class="line">                <span class="comment">// '&lt;div class="TextInCard"&gt;' + imgName + '&lt;/div&gt;' +</span></span><br><span class="line">                <span class="string">'&lt;/div&gt;'</span></span><br><span class="line">        &#125;</span><br><span class="line">        $(<span class="string">".ImageGrid"</span>).append(li);</span><br><span class="line">        $(<span class="string">".ImageGrid"</span>).lazyload();</span><br><span class="line">        <span class="keyword">this</span>.minigrid();</span><br><span class="line">    &#125;,</span><br><span class="line">    minigrid: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> grid = <span class="keyword">new</span> Minigrid(&#123;</span><br><span class="line">            container: <span class="string">'.ImageGrid'</span>,</span><br><span class="line">            item: <span class="string">'.card'</span>,</span><br><span class="line">            gutter: <span class="number">12</span></span><br><span class="line">        &#125;);</span><br><span class="line">        grid.mount();</span><br><span class="line">        $(<span class="built_in">window</span>).resize(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            grid.mount();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">photo.init();</span><br></pre></td></tr></table></figure><p>可以看到，我们主要是解析原来生成的photos.json文件，获得长和宽，并将其放到card框里，同时图片是通过OSS获取的。</p><p>要使该js生效，需要被引用并加载，打开<code>themes/next/layout/_scripts/commons.swig</code>文件，添加photos.js的引用，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if page.type ===&apos;photos&apos; %&#125;</span><br><span class="line">&#123;%</span><br><span class="line">  set js_commons = [</span><br><span class="line">    &apos;src/utils.js&apos;,</span><br><span class="line">    &apos;src/motion.js&apos;,</span><br><span class="line">    &apos;src/minigrid.min.js&apos;,</span><br><span class="line">    &apos;src/photos.js&apos;</span><br><span class="line">  ]</span><br><span class="line">%&#125;</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">&#123;%</span><br><span class="line">  set js_commons = [</span><br><span class="line">    &apos;src/utils.js&apos;,</span><br><span class="line">    &apos;src/motion.js&apos;</span><br><span class="line">  ]</span><br><span class="line">%&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% for common in js_commons %&#125;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot; src=&quot;&#123;&#123; url_for(theme.js) &#125;&#125;/&#123;&#123; common &#125;&#125;?v=&#123;&#123; theme.version &#125;&#125;&quot;&gt;&lt;/script&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><p>PS:一些自己想实现的其它功能，如果有新的js文件，也可以做如下的添加方式，另使photos.js生效不仅仅只可以添加到这儿，也可以通过其它的地方引入，考虑到以后维护的方便，我们可以统一添加到了这里。</p><p>可以为相册相框添加缩放效果及一些其它效果，我的相框的css样式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//图片鼠标靠近放大效果</span><br><span class="line"><span class="selector-class">.fancybox</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: block;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">scale</span>(1);</span><br><span class="line"><span class="attribute">transition</span>: all <span class="number">1s</span> ease <span class="number">0s</span>;</span><br><span class="line"><span class="attribute">-webkit-transform</span>: <span class="built_in">scale</span>(1);</span><br><span class="line"><span class="attribute">-webkit-transform</span>: all <span class="number">1s</span> ease <span class="number">0s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.fancybox</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">scale</span>(1.1);</span><br><span class="line"><span class="attribute">transition</span>: all <span class="number">1s</span> ease <span class="number">0s</span>;</span><br><span class="line"><span class="attribute">-webkit-transform</span>: <span class="built_in">scale</span>(1.1);</span><br><span class="line"><span class="attribute">-webkit-transform</span>: all <span class="number">1s</span> ease <span class="number">0s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.ImageGrid</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">1040px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.card</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">transition</span>: .<span class="number">3s</span> ease-in-out;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">8px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ddd</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.ImageInCard</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.TextInCard</span> &#123;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">54px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ffffff</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">24px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个css内容我们添加到<code>themes/next/source/css/_custom/custom.styl</code>文件夹里。</p><p>最终效果如下：</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-389.png" alt="upload successful"></p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-390.gif" alt="upload successful"></p><h2 id="SEO-相关优化"><a href="#SEO-相关优化" class="headerlink" title="SEO 相关优化"></a>SEO 相关优化</h2><p>这一块的优化还是蛮多的，我挑几个比较重要的说下。</p><p>我们知道，我们的blog有了域名后，相当于发布在了外网，为了提高blog阅读量，需要对blog或者其它方面做些工作，这都可以称谓博客的SEO优化。</p><h3 id="编写质量高的原创博文"><a href="#编写质量高的原创博文" class="headerlink" title="编写质量高的原创博文"></a>编写质量高的原创博文</h3><p>这一条基本不用多说，好的文章从不缺少流量。关键在于作者提高自身的写作水平。</p><h3 id="更改博文生成结构"><a href="#更改博文生成结构" class="headerlink" title="更改博文生成结构"></a>更改博文生成结构</h3><p>使用hexo生成博文时，博文的生成方式(permalink)为<code>blog/:title:year:month:day/</code>这种格式，这种是不便于搜索的，因为相当于四级目录，我们可以改为<code>blog/:title.html</code>这种格式。</p><p>在hexo 的 config.yml文件里进行修改，并重新运行命令生成博文。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="attr">https://www.sakuratears.top</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">blog/:title.html</span>  <span class="comment">## SEO优化</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br></pre></td></tr></table></figure><h3 id="禁止外链"><a href="#禁止外链" class="headerlink" title="禁止外链"></a>禁止外链</h3><p>我们在写作博文时，有可能引用到其它博文的文章，会有指向其它博文的链接，这样是不便于SEO的，我们又不能去掉该外链而影响到博文功能。因此我们可以引入 <code>hexo-autonofollow</code> 插件，在package.json文件里配置并安装该插件后，在hexo的config.yml文件里添加如下配置。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## nofollow  SEO 优化</span></span><br><span class="line"><span class="attr">nofollow:</span></span><br><span class="line"><span class="attr">   enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">   exclude:</span>  <span class="comment"># 除外的链接</span></span><br><span class="line"><span class="bullet">   -</span> <span class="string">‘https://www.sakuratears.top’</span></span><br></pre></td></tr></table></figure><p>可以使网页爬虫更好的获取我们的页面数据，提高SEO。</p><h3 id="人为发布博客外链"><a href="#人为发布博客外链" class="headerlink" title="人为发布博客外链"></a>人为发布博客外链</h3><p>这个就比较简单了，我们可以在一些平台等地方发布我们的博客地址，提高曝光度，提高SEO。</p><h3 id="使百度、谷歌、必应等网站收录你的网站"><a href="#使百度、谷歌、必应等网站收录你的网站" class="headerlink" title="使百度、谷歌、必应等网站收录你的网站"></a>使百度、谷歌、必应等网站收录你的网站</h3><p>这项是一项漫长而又复杂的过程，但也是效果最明显的一个。</p><p>我们如果有百度账号的话，可以登陆百度站长平台，将我们的站点添加百度收录。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-390.png" alt="upload successful"></p><p>如果网站已备案，添加备案号可以加快收录速度。</p><p>我们可以在链接提交-自动提交-sitemap里添加我们网站的sitemap.xml并提交，以加快百度对我们网站的收录。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-391.png" alt="upload successful"></p><p>同时在自动推送里，我们看到我们可以使用js进行自动推送，由于hexo已经集成了该功能，我们简单设置下就行。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># SEO Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Canonical, set a canonical link tag in your hexo, you could use it for your SEO of blog.</span></span><br><span class="line"><span class="comment"># See: https://support.google.com/webmasters/answer/139066</span></span><br><span class="line"><span class="comment"># Tips: Before you open this tag, remember set up your URL in hexo _config.yml ( ex. url: http://yourdomain.com )</span></span><br><span class="line"><span class="attr">canonical:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Change headers hierarchy on site-subtitle (will be main site description) and on all post/pages titles for better SEO-optimization.</span></span><br><span class="line"><span class="attr">seo:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEO</span></span><br><span class="line"><span class="attr">baidu_push:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>可以看到hexo里面集成的<code>baidu_push.swig</code>内容和百度提供的js是一样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.baidu_push %&#125;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">(function()&#123;</span><br><span class="line">    var bp = document.createElement(&apos;script&apos;);</span><br><span class="line">    var curProtocol = window.location.protocol.split(&apos;:&apos;)[0];</span><br><span class="line">    if (curProtocol === &apos;https&apos;) &#123;</span><br><span class="line">        bp.src = &apos;https://zz.bdstatic.com/linksubmit/push.js&apos;;        </span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        bp.src = &apos;http://push.zhanzhang.baidu.com/push.js&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    var s = document.getElementsByTagName(&quot;script&quot;)[0];</span><br><span class="line">    s.parentNode.insertBefore(bp, s);</span><br><span class="line">&#125;)();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用手动抓取功能对我们的网站进行抓取，如下效果图。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-392.png" alt="upload successful"></p><p>PS：由于网络等一些原因，有可能抓取失败。</p><p>弄好后，过一段时间，可以看到数据的变化。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-393.png" alt="upload successful"></p><p>我们可以通过 <code>site:<a href="http://www.sakuratears.top">www.sakuratears.top</a></code>来检查百度是否收录了我们的网站，如图。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-394.png" alt="upload successful"></p><p>PS:我在bing上进行测试，发现必应收录的比百度要快。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-395.png" alt="upload successful"></p><p>后来查询了解得知Github屏蔽掉了百度爬虫，所以一些blog作者在国内托管到Coding或者Gitee上，在国外托管到GitHub上，以加快博客访问速度，提高SEO优化。</p><p>有关这一块内容，我准备后面在处理。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>今天差不多就这些了，关于博客的一些其它优化内容我会在整理一下。</p><p>一些其它的想法: </p><ul><li><p>原来blog的音乐播放器直接使用的网易云的，但是我们公司居然把网易云墙了，而且考虑到歌曲以后可能放在那边会404等情况，下阶段优化考虑使用Hexo的aplayer去处理，并将音乐放到OSS存储上。</p></li><li><p>关于托管到Coding或者Gitee上的问题，也要研究下。</p></li><li><p>每次看博客是都会出现live2D妹子，可能并不是所有人都喜欢，也有时候觉得碍事，可能考虑新增一个关闭按钮，可以主动开启或关闭live2D妹子。</p></li><li><p>部分页面需要美化下，SEO的部分还要看看有没有需要总结的，毕竟SEO优化是条漫长的道路。</p></li></ul><p>以上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="blog" scheme="https://www.sakuratears.top/tags/blog/"/>
    
      <category term="Hexo" scheme="https://www.sakuratears.top/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Eureka简介及简单使用</title>
    <link href="https://www.sakuratears.top/blog/Eureka%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.html"/>
    <id>https://www.sakuratears.top/blog/Eureka简介及简单使用.html</id>
    <published>2019-03-10T01:20:00.000Z</published>
    <updated>2019-03-12T06:35:04.048Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Eureka是Spring Cloud Netflix微服务套件中的一部分，一般与SpringBoot构建的微服务进行整合。它基于Netflix Eureka做了二次封装，主要负责完成微服务架构中的服务治理功能。</p><p>服务治理可以说是微服务架构中最为核心和基础的模块。服务治理通常包含服务注册和服务发现两部分。</p><p>Eureka包含客户端和服务端部分。</p><ul><li><p>Eureka服务端，我们也称为服务注册中心。它支持高可用配置。它依托于强一致性提供良好的服务实例可用性，可以应对多种不同的故障场景。如果Eureka以集群模式部署，当集群中有分片出现故障时，那么Eureka就转入自我保护模式。它允许在分片故障期间继续提供服务的发现和注册，当故障分片恢复运行时，集群中的其他分片就会把它们的状态再次同步回来。不同可用区域的服务注册中心通过异步模式互相复制各自的状态，这意味着在任意给定的时间点每个实例关于所有服务的状态是有细微差别的。</p></li><li><p>Eureka客户端，主要处理服务的注册与发现。客户端服务通过注解和参数配置的方式，嵌在客户端应用程序的代码中，在应用程序运行时，Eureka客户端向注册中心注册自身提供的服务并周期性的发送心跳来更新它的服务租约。同时，它也能从服务端查询当前注册的服务信息并把它们缓存到本地并进行周期性的刷新服务状态。</p></li></ul><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>我们今天先简单通过例子了解一下Eureka，后面在对其进行一些深入研究。</p><h2 id="Eureka服务端"><a href="#Eureka服务端" class="headerlink" title="Eureka服务端"></a>Eureka服务端</h2><p>我们创建一个Eureka服务端，如下：</p><ul><li><p>新建SpringBoot项目，命名为eureka-server</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-373.png" alt="upload successful"></p></li><li><p>选择Eureka Server依赖</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-374.png" alt="upload successful"></p></li><li><p>Eureka Server 的配置</p><ul><li><p>首先我们需要启用EurekaServer，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaServerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在application.properties里进行相关配置，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 应用名称</span><br><span class="line">spring.application.name=eureka-server</span><br><span class="line"># 实例端口</span><br><span class="line">server.port=8001</span><br><span class="line"># server地址</span><br><span class="line">server.address=172.30.13.173</span><br><span class="line"># 实例名称</span><br><span class="line">eureka.instance.hostname=test1</span><br><span class="line"># 实例ID</span><br><span class="line">eureka.instance.instance-id=$&#123;server.address&#125;:$&#123;server.port&#125;</span><br><span class="line"># 是否向注册中心注册自己</span><br><span class="line">eureka.client.register-with-eureka=false</span><br><span class="line"># 是否需要检索服务</span><br><span class="line">eureka.client.fetch-registry=false</span><br><span class="line"># 使用IP地址定义主机名</span><br><span class="line">eureka.instance.prefer-ip-address=true</span><br><span class="line"># eureka服务地址</span><br><span class="line">eureka.client.service-url.defaultZone = http://172.30.13.173:8001/eureka/</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>我们启动EurekaServer，通过 <a href="http://172.30.13.173:8001/" rel="external nofollow noopener noreferrer" target="_blank">http://172.30.13.173:8001/</a> 进行访问，可以看到如下图，Eureka注册中心中尚未有可以使用的实例。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-375.png" alt="upload successful"></p><h2 id="Eureka-客户端"><a href="#Eureka-客户端" class="headerlink" title="Eureka 客户端"></a>Eureka 客户端</h2><p>我们再新创建一个项目sakura-service，并为其添加web模块和eureka-client模块，以使其注册到eureka中心上。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-376.png" alt="upload successful"></p><p>启用服务发现，@EnableDiscoveryClient。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SakuraServiceApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SakuraServiceApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>application.properties进行如下相关配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 实例端口</span><br><span class="line">server.port=9001</span><br><span class="line"># 应用名称</span><br><span class="line">spring.application.name=sakura-service</span><br><span class="line"># eureka服务地址</span><br><span class="line">eureka.client.service-url.defaultZone = http://172.30.13.173:8001/eureka/</span><br></pre></td></tr></table></figure><p>我们在该项目中新建一个SakuraController类，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SakuraController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务注册</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"eurekaRegistration"</span>)</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Registration registration;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DiscoveryClient client;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/hello"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ServiceInstance instance = serviceInstance();</span><br><span class="line">        System.out.println(<span class="string">"Host:"</span>+instance.getHost()+<span class="string">";ServiceID:"</span>+instance.getServiceId());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServiceInstance <span class="title">serviceInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;ServiceInstance&gt; list = client.getInstances(registration.getServiceId());</span><br><span class="line">        <span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list.stream().findAny().get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在启动此项目，可以看到此项目已被注册到了注册中心上。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-377.png" alt="upload successful"></p><p>我们在创建一个服务消费者用于消费刚才我们创建的服务Service。</p><p>需要添加web模块，eureka-client模块和ribbon模块，Ribbon是一个基于HTTP和TCP的客户端负载均衡器，它可以通过客户端配置的ribbonServerList服务端列表去轮询达到负载均衡的目的，和Eureka联合使用时，Ribbon会从Eureka的注册中心获取服务列表去轮询。关于Ribbon的内容，我们后面在研究。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-378.png" alt="upload successful"></p><p>启用服务发现，@EnableDiscoveryClient。并添加RestTemplate，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SakuraConsumerApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SakuraConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>application.properties进行如下相关配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 实例端口</span><br><span class="line">server.port=7001</span><br><span class="line"># 应用名称</span><br><span class="line">spring.application.name=sakura-consumer</span><br><span class="line"># eureka服务地址</span><br><span class="line">eureka.client.service-url.defaultZone = http://172.30.13.173:8001/eureka/</span><br></pre></td></tr></table></figure><p>我们在项目中新建SakuraController用于对sakura-service的hello服务进行调用，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SakuraController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/consumer"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForEntity(<span class="string">"http://SAKURA-SERVICE/hello"</span>,String.class).getBody();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动此项目，可以发现此项目也被注册到了Eureka注册中心。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-379.png" alt="upload successful"></p><p>我们尝试访问消费者，<a href="http://172.30.13.173:7001/consumer" rel="external nofollow noopener noreferrer" target="_blank">http://172.30.13.173:7001/consumer</a> 可以看到打印了 sakura-service的 Hello World 字样，同时 sakura-service项目日志中输出相关信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Host:DELL-3020-PC;ServiceID:SAKURA-SERVICE</span><br></pre></td></tr></table></figure><h2 id="高可用Eureka注册中心"><a href="#高可用Eureka注册中心" class="headerlink" title="高可用Eureka注册中心"></a>高可用Eureka注册中心</h2><p>上面的例子，当我们关掉Eureka服务端时，可以发现两个项目之间已经无法进行相互调用了。因此，单节点的服务注册中心是不合理的。</p><p>所以作为注册中心，应具备高可用性的特征。</p><p>Eureka Server在设计的一开始就考虑了高可用的问题，在Eureka的服务治理设计中，所有节点既是服务提供方，也是服务消费方，服务注册中心也不例外。</p><p>我们在配置单节点的注册中心时，设置过如下两个参数，让服务注册中心不注册自己。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 是否向注册中心注册自己</span><br><span class="line">eureka.client.register-with-eureka=false</span><br><span class="line"># 是否需要检索服务</span><br><span class="line">eureka.client.fetch-registry=false</span><br></pre></td></tr></table></figure><p>Eureka Server 的高可用实际上就是将自己作为服务向其他服务注册中心注册自己，这样就形成一组相互注册的服务注册中心，以实现服务清单的相互同步，达到高可用的效果。</p><p>下面我们来尝试搭建高可用的服务注册中心集群，我们构建一个三节点的服务注册中心集群。</p><p>在搭建之前，我们需要知道SpringBoot是支持多环境配置的，其命名格式需要满足 application-{profile}.properties的格式，其中{profile}对应环境标识，如下：</p><ul><li>application-dev.properties: 开发环境</li><li>application-test.properties: 测试环境</li><li>application-prod.properties: 生产环境</li></ul><p>至于要加载那个配置文件，需要在application.properties 文件中通过spring.profiles.active 属性来设置，spring.profiles.active=dev 就会加载 application-dev.properties配置。</p><p>另外我们在启动项目时，可以通过 java -jar xxxxx.jar –spring.profiles.active = test 来指定使用哪个配置。</p><p>根据上面所述，我们可以在原来eureka-server项目里创建3份properties文件，如下：</p><ul><li><p>application-test1.properties</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 应用名称</span><br><span class="line">spring.application.name=eureka-server</span><br><span class="line"># 实例端口</span><br><span class="line">server.port=8001</span><br><span class="line"># server地址</span><br><span class="line">server.address=172.30.13.173</span><br><span class="line"># 实例名称</span><br><span class="line">eureka.instance.hostname=test1</span><br><span class="line"># 实例ID</span><br><span class="line">eureka.instance.instance-id=$&#123;server.address&#125;:$&#123;server.port&#125;</span><br><span class="line"># 是否向注册中心注册自己</span><br><span class="line">eureka.client.register-with-eureka=true</span><br><span class="line"># 是否需要检索服务</span><br><span class="line">eureka.client.fetch-registry=true</span><br><span class="line"># 使用IP地址定义主机名</span><br><span class="line">eureka.instance.prefer-ip-address=true</span><br><span class="line"># eureka服务地址</span><br><span class="line">eureka.client.service-url.defaultZone = http://172.30.13.173:8002/eureka/,http://172.30.13.173:8003/eureka/</span><br></pre></td></tr></table></figure></li><li><p>application-test2.properties</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 应用名称</span><br><span class="line">spring.application.name=eureka-server</span><br><span class="line"># 实例端口</span><br><span class="line">server.port=8002</span><br><span class="line"># server地址</span><br><span class="line">server.address=172.30.13.173</span><br><span class="line"># 实例名称</span><br><span class="line">eureka.instance.hostname=test2</span><br><span class="line"># 实例ID</span><br><span class="line">eureka.instance.instance-id=$&#123;server.address&#125;:$&#123;server.port&#125;</span><br><span class="line"># 是否向注册中心注册自己</span><br><span class="line">eureka.client.register-with-eureka=true</span><br><span class="line"># 是否需要检索服务</span><br><span class="line">eureka.client.fetch-registry=true</span><br><span class="line"># 使用IP地址定义主机名</span><br><span class="line">eureka.instance.prefer-ip-address=true</span><br><span class="line"># eureka服务地址</span><br><span class="line">eureka.client.service-url.defaultZone=http://172.30.13.173:8001/eureka/,http://172.30.13.173:8003/eureka/</span><br></pre></td></tr></table></figure></li><li><p>application-test3.properties</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 应用名称</span><br><span class="line"> spring.application.name=eureka-server</span><br><span class="line"> # 实例端口</span><br><span class="line"> server.port=8003</span><br><span class="line"> # server地址</span><br><span class="line"> server.address=172.30.13.173</span><br><span class="line"> # 实例名称</span><br><span class="line"> eureka.instance.hostname=test3</span><br><span class="line"> # 实例ID</span><br><span class="line"> eureka.instance.instance-id=$&#123;server.address&#125;:$&#123;server.port&#125;</span><br><span class="line"> # 是否向注册中心注册自己</span><br><span class="line"> eureka.client.register-with-eureka=true</span><br><span class="line"> # 是否需要检索服务</span><br><span class="line"> eureka.client.fetch-registry=true</span><br><span class="line"> # 使用IP地址定义主机名</span><br><span class="line"> eureka.instance.prefer-ip-address=true</span><br><span class="line"> # eureka服务地址</span><br><span class="line"> eureka.client.service-url.defaultZone=http://172.30.13.173:8002/eureka/,http://172.30.13.173:8001/eureka/</span><br></pre></td></tr></table></figure></li></ul><p>可以看到我们在一台机器上使用了3个不同端口（8001，8002，8003）来搭建了一个Eureka服务注册中心集群。</p><p>PS: application.properties 里可以配置 spring.profiles.active=test1 让其默认使用 test1的配置。</p><p>我们使用Maven 打包生成 eureka-server-1.0.0-SNAPSHOT.jar 包，并使用 java -jar eureka-server-1.0.0-SNAPSHOT.jar –spring.profiles.active=test1 启动test1 ,相同的方式启动test2和test3。</p><p>完成后访问eureka注册中心界面（<a href="http://172.30.13.173:8001/" rel="external nofollow noopener noreferrer" target="_blank">http://172.30.13.173:8001/</a> 或者 <a href="http://172.30.13.173:8002/" rel="external nofollow noopener noreferrer" target="_blank">http://172.30.13.173:8002/</a> 或者 <a href="http://172.30.13.173:8003/），如图：" rel="external nofollow noopener noreferrer" target="_blank">http://172.30.13.173:8003/），如图：</a></p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-380.png" alt="upload successful"></p><p>可以看到Eureka形成了一组相互注册的服务注册中心。</p><p>那它的高可用性能被保证吗？</p><p>我们来测试下，我们根据上面所述，对sakura-service做成两个微服务，如下：</p><p>sakura-service项目的配置文件</p><ul><li><p>application-test1.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.port=9001</span><br><span class="line">spring.application.name=sakura-service</span><br><span class="line">eureka.client.service-url.defaultZone = http://172.30.13.173:8001/eureka/,http://172.30.13.173:8002/eureka/,http://172.30.13.173:8003/eureka/</span><br></pre></td></tr></table></figure></li><li><p>application-test2.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.port=9002</span><br><span class="line">spring.application.name=sakura-service</span><br><span class="line">eureka.client.service-url.defaultZone = http://172.30.13.173:8001/eureka/,http://172.30.13.173:8002/eureka/,http://172.30.13.173:8003/eureka/</span><br></pre></td></tr></table></figure></li></ul><p>启动它们，可以看到服务注册中心已经有了它们的实例。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-381.png" alt="upload successful"></p><p>我们启动消费者项目sakura-consumer将其也注册到注册中心。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-382.png" alt="upload successful"></p><p>访问 <a href="http://172.30.13.173:7001/consumer" rel="external nofollow noopener noreferrer" target="_blank">http://172.30.13.173:7001/consumer</a> 可以看到两个注册的sakura-service交替输出信息，这也是使用ribbon可以做到负载均衡的体现。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-383.png" alt="upload successful"></p><p>这时候我们停止掉 eureka-server 的test1 ，可以看到 使用consumer调用 sakura-service的服务仍然正常。</p><p>可以看到test2和test3仍然正常进行服务，我们也可以继续停掉test2，可以看到test3正常服务，保证注册中心的服务正常进行。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-384.png" alt="upload successful"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>今天我们研究了Eureka注册中心的使用及如何创建一个高可用的注册中心，后面会结合Eureka的源码详细了解Eureka使用及特点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Spring Cloud" scheme="https://www.sakuratears.top/tags/Spring-Cloud/"/>
    
      <category term="Eureka" scheme="https://www.sakuratears.top/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>MySql数据库知识点总结(1)</title>
    <link href="https://www.sakuratears.top/blog/MySql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93(1).html"/>
    <id>https://www.sakuratears.top/blog/MySql数据库知识点总结(1).html</id>
    <published>2019-02-25T14:21:00.000Z</published>
    <updated>2019-02-25T14:27:26.951Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在使用MySql数据库过程中，遇到了一些问题，并抽时间总结了下来，也是结合Java语言和MyBatis的方方面面，在此分享给大家。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="中文姓名排序问题"><a href="#中文姓名排序问题" class="headerlink" title="中文姓名排序问题"></a>中文姓名排序问题</h2><p>比如一张有中文姓名的表，我们要对中文姓名按拼音进行排序，在没有<strong>姓名拼音字段</strong>（插入姓名时顺带插入了姓名拼音）的帮助下，可以使用如下语法。</p><ul><li><p>如果MySql的排序字段采用的GBK字符集，那可以直接使用 <code>order by ‘字段名’ asc </code> 语法。</p></li><li><p>如果MySql的排序字段采用的不是GBK字符集，那么可以使用如下方法。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="string">'表名称'</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">convert</span>(<span class="string">'字段名'</span> <span class="keyword">using</span> gbk) <span class="keyword">asc</span>;</span><br></pre></td></tr></table></figure><p>使用该语法，姓名字段名无法使用索引（如果有的话），需要注意。</p></li></ul><h2 id="多个字段去重并统计数量"><a href="#多个字段去重并统计数量" class="headerlink" title="多个字段去重并统计数量"></a>多个字段去重并统计数量</h2><p>这个问题还是比较常见的，比如有一张用户表，有用户姓名 <code>user_name</code> 用户身份证号 <code>id_card_no</code> 等字段，现在我们要把姓名和身份证号一致的认为一个用户，其它情况均为两个用户，则可以使用以下语法。</p><ul><li><p>可以使用DISTINCT，虽然DISTINCT只能去重一行，但是可以使用字段合并功能来进行处理。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">DISTINCT</span>(c.user_name + <span class="keyword">IFNULL</span>(c.id_card_no,<span class="string">''</span>))) <span class="keyword">from</span> <span class="keyword">user</span> c <span class="keyword">where</span> c.invite_id = <span class="string">'xxxxx'</span>;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>： 两列的类型最好为<code>varchar</code>类型，其他类型不推荐使用此方法，比如<code>char</code>和<code>int</code>相加，会得到意想不到的结果从而产生问题。</p></li><li><p>使用GROUP BY语句，需要有子查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> (<span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> u <span class="keyword">where</span> u.invite_id = <span class="string">'xxxxx'</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> u.user_name,<span class="keyword">IFNULL</span>(u.id_card_no,<span class="string">''</span>)) a ;</span><br></pre></td></tr></table></figure></li></ul><p>  <strong>注意</strong>：子查询得到的表必须有别名，不然SQL语句报错。</p><h2 id="查询条件字段有多个条件的查询"><a href="#查询条件字段有多个条件的查询" class="headerlink" title="查询条件字段有多个条件的查询"></a>查询条件字段有多个条件的查询</h2><p>这个问题是这样，比如我们有一群用户在user表，他们有个字段表示所属平台platform，比如有A、B、C、D等几种平台，现在要查询所属平台为A或B平台的用户。</p><ul><li><p>我们可以明显看到用<code>in</code>即可以解决。在MyBatis里，对于这个字段，则需要传入一个<code>List<string></string></code>形式的数组，并在xml文件里通过循环赋值给SQL语句进行查询，也是比较常用的方法。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUser"</span> <span class="attr">parameterType</span>=<span class="string">"com.xxx.NewUser"</span>&gt;</span></span><br><span class="line">    select * from user u where  u.invite_id= #&#123;condition.inviteID&#125; and u.platform in </span><br><span class="line">      <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">item</span>=<span class="string">"condition.platform"</span> <span class="attr">index</span>=<span class="string">"index"</span> <span class="attr">open</span>=<span class="string">"("</span> <span class="attr">close</span>=<span class="string">")"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">       #&#123;condition.platform&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的NewUser对象里的platform字段是个List<string>，最后组成的SQL语句如下。</string></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> u <span class="keyword">where</span>  u.invite_id= <span class="string">'xxxxxx'</span> <span class="keyword">and</span> u.platform <span class="keyword">in</span> (<span class="string">'A'</span>,<span class="string">'B'</span>);</span><br></pre></td></tr></table></figure></li><li><p>我们还可以利用<code>FIND_IN_SET</code>函数，同时在MyBatis里传入的参数直接为<code>String</code>即可，但是A、B平台需要用逗号隔开。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUser"</span> <span class="attr">parameterType</span>=<span class="string">"com.xxx.User"</span>&gt;</span></span><br><span class="line">    select * from user u where  u.invite_id= #&#123;condition.inviteID&#125; and FIND_IN_SET(u.platform,#&#123;condition.platform&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的User对象里的platform字段是个String，平台之间用逗号分割，最后SQL如下。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> u <span class="keyword">where</span>  u.invite_id= <span class="string">'xxxxxx'</span> <span class="keyword">and</span> FIND_IN_SET(u.platform,<span class="string">'A,B'</span>);</span><br></pre></td></tr></table></figure></li></ul><p>这儿需要注意的一点是，FIND_IN_SET无法使用u.platform字段的索引。</p><p>虽然无法使用索引，但如果SQL语句本身其它条件索引检索后数据量不大，或者被FIND_IN_SET的字段没有索引，也是可以使用的。</p><p>如果传入Mybatis里的实体类字段本身就是逗号分割的，我们在拆成一个一个数据最后再使用in也是非常费事的，可以使用FIND_IN_SET轻松搞定。</p><h2 id="使用程序对MySql批量处理数据"><a href="#使用程序对MySql批量处理数据" class="headerlink" title="使用程序对MySql批量处理数据"></a>使用程序对MySql批量处理数据</h2><p>我们知道，对于MySql批量处理数据，我们可以使用MyBatis的批量处理方法。</p><p>大致如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertBatch"</span> <span class="attr">parameterType</span>=<span class="string">"java.util.List"</span>&gt;</span></span><br><span class="line">  insert into student (id, stu_no, stu_name, stu_sex, stu_birthday, stu_class)</span><br><span class="line">  values</span><br><span class="line">  <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">item</span>=<span class="string">"item"</span> <span class="attr">index</span>=<span class="string">"index"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">    (#&#123;item.id,jdbcType=INTEGER&#125;, #&#123;item.stuNo,jdbcType=VARCHAR&#125;, #&#123;item.stuName,jdbcType=VARCHAR&#125;, #&#123;item.stuSex,jdbcType=CHAR&#125;, #&#123;item.stuBirthday,jdbcType=DATE&#125;, #&#123;item.stuClass,jdbcType=CHAR&#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种方法比普通的程序循环一条条插入要快很多，下面是一个例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">long</span> start1 =System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">        StudentModel studentModel = <span class="keyword">new</span> StudentModel();</span><br><span class="line">        studentModel.setId(i);</span><br><span class="line">        studentModel.setStuName(i+<span class="string">""</span>);</span><br><span class="line">        studentModel.setStuClass(<span class="string">"1"</span>);</span><br><span class="line">        studentModel.setStuNo(i+<span class="string">""</span>);</span><br><span class="line">        studentModel.setStuBirthday(<span class="keyword">new</span> Date());</span><br><span class="line">        studentModel.setStuSex(<span class="string">"M"</span>);</span><br><span class="line">        studentMapper.insert(studentModel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> end1 =System.currentTimeMillis();</span><br><span class="line">    System.out.println(end1-start1);</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> start2 =System.currentTimeMillis();</span><br><span class="line">    List&lt;StudentModel&gt; list3 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1000</span>;i&lt;<span class="number">2000</span>;i++)&#123;</span><br><span class="line">        StudentModel studentModel = <span class="keyword">new</span> StudentModel();</span><br><span class="line">        studentModel.setId(i);</span><br><span class="line">        studentModel.setStuName(i+<span class="string">""</span>);</span><br><span class="line">        studentModel.setStuClass(<span class="string">"1"</span>);</span><br><span class="line">        studentModel.setStuNo(i+<span class="string">""</span>);</span><br><span class="line">        studentModel.setStuBirthday(<span class="keyword">new</span> Date());</span><br><span class="line">        studentModel.setStuSex(<span class="string">"M"</span>);</span><br><span class="line">        list3.add(studentModel);</span><br><span class="line">    &#125;</span><br><span class="line">    studentMapper.insertBatch(list3);</span><br><span class="line">    <span class="keyword">long</span> end2 =System.currentTimeMillis();</span><br><span class="line">    System.out.println(end2-start2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2019-02-25 14:46:14.851  INFO 9360 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...</span><br><span class="line">2019-02-25 14:46:15.031  INFO 9360 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.</span><br><span class="line">120601</span><br><span class="line">260</span><br><span class="line">2019-02-25 14:48:17.666  INFO 9360 --- [       Thread-2] o.s.w.c.s.GenericWebApplicationContext   : Closing org.springframework.web.context.support.GenericWebApplicationContext@2ddc9a9f: startup date [Mon Feb 25 14:46:09 CST 2019]; root of context hierarchy</span><br><span class="line">2019-02-25 14:48:17.671  INFO 9360 --- [       Thread-2] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown initiated...</span><br><span class="line">2019-02-25 14:48:17.675  INFO 9360 --- [       Thread-2] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown completed.</span><br></pre></td></tr></table></figure><p>可以看到批处理要比单条处理快了N倍，这儿不再过多介绍。</p><p><strong>Tips</strong>：如果数据量过大，如100w，1000w等，可以将数据分成多份循环去批处理插入。</p><p><strong>关于批量的处理的另外一点思考：</strong></p><p>当我们需要对多张表进行批量处理时，如果想提高运行效率，可以考虑使用多线程处理，比如下面的例子。</p><p>我们对4张表插入1w数据，正常的处理逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> start1 = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    List&lt;ScoreModel&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        ScoreModel scoreModel = <span class="keyword">new</span> ScoreModel();</span><br><span class="line">        scoreModel.setId(i);</span><br><span class="line">        scoreModel.setScore(<span class="keyword">new</span> BigDecimal(<span class="number">100</span>));</span><br><span class="line">        scoreModel.setCouNo(i + <span class="string">""</span>);</span><br><span class="line">        scoreModel.setStuNo(i + <span class="string">""</span>);</span><br><span class="line">        list1.add(scoreModel);</span><br><span class="line">    &#125;</span><br><span class="line">    scoreMapper.insertBatch(list1);</span><br><span class="line"></span><br><span class="line">    List&lt;TeacherModel&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        TeacherModel teacherModel = <span class="keyword">new</span> TeacherModel();</span><br><span class="line">        teacherModel.setId(i);</span><br><span class="line">        teacherModel.setTeachNo(i + <span class="string">""</span>);</span><br><span class="line">        teacherModel.setTeachName(i + <span class="string">""</span>);</span><br><span class="line">        teacherModel.setTeachBirthday(<span class="keyword">new</span> Date());</span><br><span class="line">        teacherModel.setTeachDepart(i + <span class="string">""</span>);</span><br><span class="line">        teacherModel.setTeachSex(<span class="string">"M"</span>);</span><br><span class="line">        teacherModel.setTeachProf(i + <span class="string">""</span>);</span><br><span class="line">        list2.add(teacherModel);</span><br><span class="line">    &#125;</span><br><span class="line">    teacherMapper.insertBatch(list2);</span><br><span class="line"></span><br><span class="line">    List&lt;StudentModel&gt; list3 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        StudentModel studentModel = <span class="keyword">new</span> StudentModel();</span><br><span class="line">        studentModel.setId(i);</span><br><span class="line">        studentModel.setStuName(i + <span class="string">""</span>);</span><br><span class="line">        studentModel.setStuClass(<span class="string">"1"</span>);</span><br><span class="line">        studentModel.setStuNo(i + <span class="string">""</span>);</span><br><span class="line">        studentModel.setStuBirthday(<span class="keyword">new</span> Date());</span><br><span class="line">        studentModel.setStuSex(<span class="string">"M"</span>);</span><br><span class="line">        list3.add(studentModel);</span><br><span class="line">    &#125;</span><br><span class="line">    studentMapper.insertBatch(list3);</span><br><span class="line"></span><br><span class="line">    List&lt;CourseModel&gt; list4 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        CourseModel courseModel = <span class="keyword">new</span> CourseModel();</span><br><span class="line">        courseModel.setId(i);</span><br><span class="line">        courseModel.setCouName(i + <span class="string">""</span>);</span><br><span class="line">        courseModel.setCouNo(i + <span class="string">""</span>);</span><br><span class="line">        courseModel.setTeachNo(i + <span class="string">""</span>);</span><br><span class="line">        list4.add(courseModel);</span><br><span class="line">    &#125;</span><br><span class="line">    courseMapper.insertBatch(list4);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> end1 = System.currentTimeMillis();</span><br><span class="line">    System.out.println(end1 - start1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2019-02-25 15:01:23.688  INFO 9576 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...</span><br><span class="line">2019-02-25 15:01:23.850  INFO 9576 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.</span><br><span class="line">4348</span><br><span class="line">2019-02-25 15:01:27.689  INFO 9576 --- [       Thread-2] o.s.w.c.s.GenericWebApplicationContext   : Closing org.springframework.web.context.support.GenericWebApplicationContext@298a5e20: startup date [Mon Feb 25 15:01:18 CST 2019]; root of context hierarchy</span><br><span class="line">2019-02-25 15:01:27.691  INFO 9576 --- [       Thread-2] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown initiated...</span><br><span class="line">2019-02-25 15:01:27.700  INFO 9576 --- [       Thread-2] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown completed.</span><br></pre></td></tr></table></figure><p>我们用线程池对四张表分别进行批量操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">long</span> start1 =System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    Future&lt;Boolean&gt; future1= executorService.submit(()-&gt;&#123;</span><br><span class="line">        List&lt;ScoreModel&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">            ScoreModel scoreModel =<span class="keyword">new</span> ScoreModel();</span><br><span class="line">            scoreModel.setId(i);</span><br><span class="line">            scoreModel.setScore(<span class="keyword">new</span> BigDecimal(<span class="number">100</span>));</span><br><span class="line">            scoreModel.setCouNo(i+<span class="string">""</span>);</span><br><span class="line">            scoreModel.setStuNo(i+<span class="string">""</span>);</span><br><span class="line">            list1.add(scoreModel);</span><br><span class="line">        &#125;</span><br><span class="line">        scoreMapper.insertBatch(list1);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    Future&lt;Boolean&gt; future2= executorService.submit(()-&gt;&#123;</span><br><span class="line">        List&lt;TeacherModel&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">            TeacherModel teacherModel =<span class="keyword">new</span> TeacherModel();</span><br><span class="line">            teacherModel.setId(i);</span><br><span class="line">            teacherModel.setTeachNo(i+<span class="string">""</span>);</span><br><span class="line">            teacherModel.setTeachName(i+<span class="string">""</span>);</span><br><span class="line">            teacherModel.setTeachBirthday(<span class="keyword">new</span> Date());</span><br><span class="line">            teacherModel.setTeachDepart(i+<span class="string">""</span>);</span><br><span class="line">            teacherModel.setTeachSex(<span class="string">"M"</span>);</span><br><span class="line">            teacherModel.setTeachProf(i+<span class="string">""</span>);</span><br><span class="line">            list2.add(teacherModel);</span><br><span class="line">        &#125;</span><br><span class="line">        teacherMapper.insertBatch(list2);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    Future&lt;Boolean&gt; future3= executorService.submit(()-&gt;&#123;</span><br><span class="line">        List&lt;StudentModel&gt; list3 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">            StudentModel studentModel = <span class="keyword">new</span> StudentModel();</span><br><span class="line">            studentModel.setId(i);</span><br><span class="line">            studentModel.setStuName(i+<span class="string">""</span>);</span><br><span class="line">            studentModel.setStuClass(<span class="string">"1"</span>);</span><br><span class="line">            studentModel.setStuNo(i+<span class="string">""</span>);</span><br><span class="line">            studentModel.setStuBirthday(<span class="keyword">new</span> Date());</span><br><span class="line">            studentModel.setStuSex(<span class="string">"M"</span>);</span><br><span class="line">            list3.add(studentModel);</span><br><span class="line">        &#125;</span><br><span class="line">        studentMapper.insertBatch(list3);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    Future&lt;Boolean&gt; future4= executorService.submit(()-&gt;&#123;</span><br><span class="line">        List&lt;CourseModel&gt; list4 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">            CourseModel courseModel = <span class="keyword">new</span> CourseModel();</span><br><span class="line">            courseModel.setId(i);</span><br><span class="line">            courseModel.setCouName(i+<span class="string">""</span>);</span><br><span class="line">            courseModel.setCouNo(i+<span class="string">""</span>);</span><br><span class="line">            courseModel.setTeachNo(i+<span class="string">""</span>);</span><br><span class="line">            list4.add(courseModel);</span><br><span class="line">        &#125;</span><br><span class="line">        courseMapper.insertBatch(list4);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    future1.get();</span><br><span class="line">    future2.get();</span><br><span class="line">    future3.get();</span><br><span class="line">    future4.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> end1 = System.currentTimeMillis();</span><br><span class="line">    System.out.println(end1-start1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2019-02-25 15:04:46.623  INFO 8284 --- [pool-1-thread-3] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...</span><br><span class="line">2019-02-25 15:04:47.084  INFO 8284 --- [pool-1-thread-3] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.</span><br><span class="line">1993</span><br><span class="line">2019-02-25 15:04:47.986  INFO 8284 --- [       Thread-2] o.s.w.c.s.GenericWebApplicationContext   : Closing org.springframework.web.context.support.GenericWebApplicationContext@298a5e20: startup date [Mon Feb 25 15:04:40 CST 2019]; root of context hierarchy</span><br><span class="line">2019-02-25 15:04:47.990  INFO 8284 --- [       Thread-2] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown initiated...</span><br><span class="line">2019-02-25 15:04:48.004  INFO 8284 --- [       Thread-2] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown completed.</span><br></pre></td></tr></table></figure><p>可以看到速度提高了1倍，当数据量更大时，提高效果更明显。</p><p><strong>注意</strong></p><ul><li><p>对于上面多线程多表批量插入，如果需要保证事务，单独的每张表的事务是可以保证的（将每张表的批量插入提出来，形成一个方法，并加上事务属性，如果有错误就会回滚），但是如果要同时保证4张表的事务（这几张表要么全成功，要么全不成功），是无法满足的，由于多线程的特殊性。所以这种情况下请使用第一种同步方法，并加上事务，才能保证4张表批处理要么全成功，要么全不成功。</p></li><li><p>对于一张表的批处理，如果数据量过大时，可以使用多线程同时插入这一张表吗？</p><p>答案是否定的，对于MySQL InnoDB数据库，默认是行锁，前提条件是建立在索引之上的。如果筛选条件没有建立索引，会降级到表锁。即如果where条件中的字段都加了索引，则加的是行锁；否则加的是表锁。</p><ul><li><p>当为表锁时，瓶颈在数据库，多线程是无法提高对同一张表的插入效率的；</p></li><li><p>当为行锁时，看起来可以insert A行时同时insert B行，确实可以提高效率，但有数据冲突的错误情况，一般也不会使用。</p></li></ul></li></ul><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>我还会在工作学习过程中不断总结，此文章类型也会不断更新，今天就先到这里吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="MySQL" scheme="https://www.sakuratears.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Redis命令使用参考手册</title>
    <link href="https://www.sakuratears.top/blog/Redis%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C.html"/>
    <id>https://www.sakuratears.top/blog/Redis命令使用参考手册.html</id>
    <published>2019-02-21T14:00:00.000Z</published>
    <updated>2019-02-24T14:11:22.346Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们来详细了解下Redis，及其一些命令的具体使用方法，并学会如何使用 Redis 的事务、持久化、复制、Sentinel、集群等功能。</p><h1 id="主要命令"><a href="#主要命令" class="headerlink" title="主要命令"></a>主要命令</h1><p>我们知道Redis支持五种数据类型：<a href="#字符串">string（字符串）</a>，<a href="#哈希表">hash（哈希表）</a>，<a href="#列表">list（列表）</a>，<a href="#集合">set（集合）</a>及<a href="#有序集合">zset(sorted set：有序集合)</a>。先来看下它们的一些操作命令。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a><a name="字符串">字符串</a></h2><h3 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h3><h4 id="SET-key-value-EX-seconds-PX-milliseconds-NX-XX"><a href="#SET-key-value-EX-seconds-PX-milliseconds-NX-XX" class="headerlink" title="SET key value [EX seconds] [PX milliseconds] [NX|XX]"></a>SET key value [EX seconds] [PX milliseconds] [NX|XX]</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>将字符串值 <code>value</code> 关联到 <code>key</code> 。</p><p>如果 <code>key</code> 已经持有其他值， SET 就覆写旧值， 无视类型。</p><p>当 SET 命令对一个带有生存时间（TTL）的键进行设置之后， 该键原有的 TTL 将被清除。</p><h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><p>从 Redis 2.6.12 版本开始， SET 命令的行为可以通过一系列参数来修改：</p><ul><li>EX seconds ： 将键的过期时间设置为 seconds 秒。 执行 <code>SET key value EX seconds</code> 的效果等同于执行 <code>SETEX key seconds value</code> 。</li><li>PX milliseconds ： 将键的过期时间设置为 milliseconds 毫秒。 执行 <code>SET key value PX milliseconds</code> 的效果等同于执行 <code>PSETEX key milliseconds value</code> 。</li><li>NX ： 只在键不存在时， 才对键进行设置操作。 执行 <code>SET key value NX</code> 的效果等同于执行 <code>SETNX key value</code> 。</li><li>XX ： 只在键已经存在时， 才对键进行设置操作。</li></ul><font color="red"><strong>Note</strong></font><pre><code>因为 SET 命令可以通过参数来实现 SETNX 、 SETEX 以及 PSETEX 命令的效果， 所以 Redis 将来的版本可能会移除并废弃 SETNX 、 SETEX 和 PSETEX 这三个命令。</code></pre><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>在 Redis 2.6.12 版本以前， SET 命令总是返回 OK 。</p><p>从 Redis 2.6.12 版本开始， SET 命令只在设置操作成功完成时才返回 OK ； 如果命令使用了 NX 或者 XX 选项， 但是因为条件没达到而造成设置操作未执行， 那么命令将返回空批量回复（NULL Bulk Reply）。</p><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><p>对不存在的键进行设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET key <span class="string">"value"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET key</span><br><span class="line"><span class="string">"value"</span></span><br></pre></td></tr></table></figure><p>对已存在的键进行设置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET key <span class="string">"new-value"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET key</span><br><span class="line"><span class="string">"new-value"</span></span><br></pre></td></tr></table></figure></p><p>使用 EX 选项：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET key-with-expire-time <span class="string">"hello"</span> EX 10086</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET key-with-expire-time</span><br><span class="line"><span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line">redis&gt; TTL key-with-expire-time</span><br><span class="line">(<span class="built_in">integer</span>) 10069</span><br></pre></td></tr></table></figure></p><p>使用 PX 选项：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET key-with-pexpire-time <span class="string">"moto"</span> PX 123321</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET key-with-pexpire-time</span><br><span class="line"><span class="string">"moto"</span></span><br><span class="line"></span><br><span class="line">redis&gt; PTTL key-with-pexpire-time</span><br><span class="line">(<span class="built_in">integer</span>) 111939</span><br></pre></td></tr></table></figure></p><p>使用 NX 选项：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET not-exists-key <span class="string">"value"</span> NX</span><br><span class="line">OK      <span class="comment"># 键不存在，设置成功</span></span><br><span class="line"></span><br><span class="line">redis&gt; GET not-exists-key</span><br><span class="line"><span class="string">"value"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SET not-exists-key <span class="string">"new-value"</span> NX</span><br><span class="line">(nil)   <span class="comment"># 键已经存在，设置失败</span></span><br><span class="line"></span><br><span class="line">redis&gt; GEt not-exists-key</span><br><span class="line"><span class="string">"value"</span> <span class="comment"># 维持原值不变</span></span><br></pre></td></tr></table></figure></p><p>使用 XX 选项：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; EXISTS exists-key</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; SET exists-key <span class="string">"value"</span> XX</span><br><span class="line">(nil)   <span class="comment"># 因为键不存在，设置失败</span></span><br><span class="line"></span><br><span class="line">redis&gt; SET exists-key <span class="string">"value"</span></span><br><span class="line">OK      <span class="comment"># 先给键设置一个值</span></span><br><span class="line"></span><br><span class="line">redis&gt; SET exists-key <span class="string">"new-value"</span> XX</span><br><span class="line">OK      <span class="comment"># 设置新值成功</span></span><br><span class="line"></span><br><span class="line">redis&gt; GET exists-key</span><br><span class="line"><span class="string">"new-value"</span></span><br></pre></td></tr></table></figure></p><h3 id="SETNX"><a href="#SETNX" class="headerlink" title="SETNX"></a>SETNX</h3><h4 id="SETNX-key-value"><a href="#SETNX-key-value" class="headerlink" title="SETNX key value"></a>SETNX key value</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>只在键 <code>key</code> 不存在的情况下， 将键 <code>key</code> 的值设置为 <code>value</code> 。</p><p>若键 <code>key</code> 已经存在， 则 SETNX 命令不做任何动作。</p><p>SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。</p><h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><p>命令在设置成功时返回 1 ， 设置失败时返回 0 。</p><h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; EXISTS job                <span class="comment"># job 不存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; SETNX job <span class="string">"programmer"</span>    <span class="comment"># job 设置成功</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; SETNX job <span class="string">"code-farmer"</span>   <span class="comment"># 尝试覆盖 job ，失败</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; GET job                   <span class="comment"># 没有被覆盖</span></span><br><span class="line"><span class="string">"programmer"</span></span><br></pre></td></tr></table></figure><h3 id="SETEX"><a href="#SETEX" class="headerlink" title="SETEX"></a>SETEX</h3><h4 id="SETEX-key-seconds-value"><a href="#SETEX-key-seconds-value" class="headerlink" title="SETEX key seconds value"></a>SETEX key seconds value</h4><pre><code>可用版本： &gt;= 2.0.0时间复杂度： O(1)</code></pre><p>将键 <code>key</code> 的值设置为 <code>value</code> ， 并将键 <code>key</code> 的生存时间设置为 seconds 秒钟。</p><p>如果键 <code>key</code> 已经存在， 那么 SETEX 命令将覆盖已有的值。</p><p>SETEX 命令的效果和以下两个命令的效果类似：</p><ul><li><code>SET key value</code></li><li><code>EXPIRE key seconds</code>  # 设置生存时间</li></ul><p>SETEX 和这两个命令的不同之处在于 SETEX 是一个原子（atomic）操作， 它可以在同一时间内完成设置值和设置过期时间这两个操作， 因此 SETEX 命令在储存缓存的时候非常实用。</p><h4 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h4><p>命令在设置成功时返回 OK 。 </p><p>当 seconds 参数不合法时， 命令将返回一个错误。</p><h4 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h4><p>在键 <code>key</code> 不存在的情况下执行 SETEX ：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SETEX cache_user_id 60 10086</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET cache_user_id  <span class="comment"># 值</span></span><br><span class="line"><span class="string">"10086"</span></span><br><span class="line"></span><br><span class="line">redis&gt; TTL cache_user_id  <span class="comment"># 剩余生存时间</span></span><br><span class="line">(<span class="built_in">integer</span>) 49</span><br></pre></td></tr></table></figure></p><p>键 <code>key</code> 已经存在， 使用 SETEX 覆盖旧值：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET <span class="built_in">cd</span> <span class="string">"timeless"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SETEX <span class="built_in">cd</span> 3000 <span class="string">"goodbye my love"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET <span class="built_in">cd</span></span><br><span class="line"><span class="string">"goodbye my love"</span></span><br><span class="line"></span><br><span class="line">redis&gt; TTL <span class="built_in">cd</span></span><br><span class="line">(<span class="built_in">integer</span>) 2997</span><br></pre></td></tr></table></figure></p><h3 id="PSETEX"><a href="#PSETEX" class="headerlink" title="PSETEX"></a>PSETEX</h3><h4 id="PSETEX-key-milliseconds-value"><a href="#PSETEX-key-milliseconds-value" class="headerlink" title="PSETEX key milliseconds value"></a>PSETEX key milliseconds value</h4><pre><code>可用版本： &gt;= 2.6.0时间复杂度： O(1)</code></pre><p>这个命令和 SETEX 命令相似， 但它以毫秒为单位设置 <code>key</code> 的生存时间， 而不是像 SETEX 命令那样以秒为单位进行设置。</p><h4 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h4><p>命令在设置成功时返回 OK 。</p><h4 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; PSETEX mykey 1000 <span class="string">"Hello"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; PTTL mykey</span><br><span class="line">(<span class="built_in">integer</span>) 999</span><br><span class="line"></span><br><span class="line">redis&gt; GET mykey</span><br><span class="line"><span class="string">"Hello"</span></span><br></pre></td></tr></table></figure><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><h4 id="GET-key"><a href="#GET-key" class="headerlink" title="GET key"></a>GET key</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>返回与键 <code>key</code> 相关联的字符串值。</p><h4 id="返回值-4"><a href="#返回值-4" class="headerlink" title="返回值"></a>返回值</h4><p>如果键 <code>key</code> 不存在， 那么返回特殊值 <code>nil</code> ； 否则， 返回键 <code>key</code> 的值。</p><p>如果键 <code>key</code> 的值并非字符串类型， 那么返回一个错误， 因为 GET 命令只能用于字符串值。</p><h4 id="代码示例-4"><a href="#代码示例-4" class="headerlink" title="代码示例"></a>代码示例</h4><p>对不存在的键 <code>key</code> 或是字符串类型的键 <code>key</code> 执行 GET 命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GET db</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line">redis&gt; SET db redis</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET db</span><br><span class="line"><span class="string">"redis"</span></span><br></pre></td></tr></table></figure></p><p>对不是字符串类型的键 <code>key</code> 执行 GET 命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; DEL db</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; LPUSH db redis mongodb mysql</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis&gt; GET db</span><br><span class="line">(error) ERR Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure></p><h3 id="GETSET"><a href="#GETSET" class="headerlink" title="GETSET"></a>GETSET</h3><h4 id="GETSET-key-value"><a href="#GETSET-key-value" class="headerlink" title="GETSET key value"></a>GETSET key value</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>将键 <code>key</code> 的值设为 <code>value</code> ， 并返回键 <code>key</code> 在被设置之前的旧值。</p><h4 id="返回值-5"><a href="#返回值-5" class="headerlink" title="返回值"></a>返回值</h4><p>返回给定键 <code>key</code> 的旧值。</p><p>如果键 <code>key</code> 没有旧值， 也即是说， 键 <code>key</code> 在被设置之前并不存在， 那么命令返回 <code>nil</code> 。</p><p>当键 <code>key</code> 存在但不是字符串类型时， 命令返回一个错误。</p><h4 id="代码示例-5"><a href="#代码示例-5" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GETSET db mongodb    <span class="comment"># 没有旧值，返回 nil</span></span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line">redis&gt; GET db</span><br><span class="line"><span class="string">"mongodb"</span></span><br><span class="line"></span><br><span class="line">redis&gt; GETSET db redis      <span class="comment"># 返回旧值 mongodb</span></span><br><span class="line"><span class="string">"mongodb"</span></span><br><span class="line"></span><br><span class="line">redis&gt; GET db</span><br><span class="line"><span class="string">"redis"</span></span><br></pre></td></tr></table></figure><h3 id="STRLEN"><a href="#STRLEN" class="headerlink" title="STRLEN"></a>STRLEN</h3><h4 id="STRLEN-key"><a href="#STRLEN-key" class="headerlink" title="STRLEN key"></a>STRLEN key</h4><pre><code>可用版本： &gt;= 2.2.0复杂度： O(1)</code></pre><p>返回键 <code>key</code> 储存的字符串值的长度。</p><h4 id="返回值-6"><a href="#返回值-6" class="headerlink" title="返回值"></a>返回值</h4><p>STRLEN 命令返回字符串值的长度。</p><p>当键 <code>key</code> 不存在时， 命令返回 0 。</p><p>当 <code>key</code> 储存的不是字符串值时， 返回一个错误。</p><h4 id="代码示例-6"><a href="#代码示例-6" class="headerlink" title="代码示例"></a>代码示例</h4><p>获取字符串值的长度：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET mykey <span class="string">"Hello world"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; STRLEN mykey</span><br><span class="line">(<span class="built_in">integer</span>) 11</span><br></pre></td></tr></table></figure></p><p>不存在的键的长度为 0 ：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; STRLEN nonexisting</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure></p><h3 id="APPEND"><a href="#APPEND" class="headerlink" title="APPEND"></a>APPEND</h3><h4 id="APPEND-key-value"><a href="#APPEND-key-value" class="headerlink" title="APPEND key value"></a>APPEND key value</h4><pre><code>可用版本： &gt;= 2.0.0时间复杂度： 平摊O(1)</code></pre><p>如果键 <code>key</code> 已经存在并且它的值是一个字符串， APPEND 命令将把 <code>value</code> 追加到键 <code>key</code> 现有值的末尾。</p><p>如果 <code>key</code> 不存在， APPEND 就简单地将键 <code>key</code> 的值设为 <code>value</code> ， 就像执行 <code>SET key value</code> 一样。</p><h4 id="返回值-7"><a href="#返回值-7" class="headerlink" title="返回值"></a>返回值</h4><p>追加 <code>value</code> 之后， 键 <code>key</code> 的值的长度。</p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><p>对不存在的 <code>key</code> 执行 APPEND ：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; EXISTS myphone               <span class="comment"># 确保 myphone 不存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; APPEND myphone <span class="string">"nokia"</span>       <span class="comment"># 对不存在的 key 进行 APPEND ，等同于 SET myphone "nokia"</span></span><br><span class="line">(<span class="built_in">integer</span>) 5                         <span class="comment"># 字符长度</span></span><br></pre></td></tr></table></figure></p><p>对已存在的字符串进行 APPEND ：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; APPEND myphone <span class="string">" - 1110"</span>     <span class="comment"># 长度从 5 个字符增加到 12 个字符</span></span><br><span class="line">(<span class="built_in">integer</span>) 12</span><br><span class="line"></span><br><span class="line">redis&gt; GET myphone</span><br><span class="line"><span class="string">"nokia - 1110"</span></span><br></pre></td></tr></table></figure></p><h3 id="SETRANGE"><a href="#SETRANGE" class="headerlink" title="SETRANGE"></a>SETRANGE</h3><h4 id="SETRANGE-key-offset-value"><a href="#SETRANGE-key-offset-value" class="headerlink" title="SETRANGE key offset value"></a>SETRANGE key offset value</h4><pre><code>可用版本： &gt;= 2.2.0时间复杂度：对于长度较短的字符串，命令的平摊复杂度O(1)；对于长度较大的字符串，命令的复杂度为 O(M) ，其中 M 为 value 的长度。</code></pre><p>从偏移量 <code>offset</code> 开始， 用 <code>value</code> 参数覆写(overwrite)键 <code>key</code> 储存的字符串值。</p><p>不存在的键 <code>key</code> 当作空白字符串处理。</p><p>SETRANGE 命令会确保字符串足够长以便将 <code>value</code> 设置到指定的偏移量上， 如果键 <code>key</code> 原来储存的字符串长度比偏移量小(比如字符串只有 5 个字符长，但你设置的 <code>offset</code> 是 10 )， 那么原字符和偏移量之间的空白将用零字节(zerobytes, “\x00” )进行填充。</p><p>因为 Redis 字符串的大小被限制在 512 兆(megabytes)以内， 所以用户能够使用的最大偏移量为 2^29-1(536870911) ， 如果你需要使用比这更大的空间， 请使用多个 <code>key</code> 。</p><font color="red"><strong>Warning</strong></font><pre><code>当生成一个很长的字符串时， Redis 需要分配内存空间， 该操作有时候可能会造成服务器阻塞(block)。 在2010年出产的Macbook Pro上， 设置偏移量为 536870911(512MB 内存分配)将耗费约 300 毫秒， 设置偏移量为 134217728(128MB 内存分配)将耗费约 80 毫秒， 设置偏移量 33554432(32MB 内存分配)将耗费约 30 毫秒， 设置偏移量为 8388608(8MB 内存分配)将耗费约 8 毫秒。</code></pre><h4 id="返回值-8"><a href="#返回值-8" class="headerlink" title="返回值"></a>返回值</h4><p>SETRANGE 命令会返回被修改之后， 字符串值的长度。</p><h4 id="代码示例-7"><a href="#代码示例-7" class="headerlink" title="代码示例"></a>代码示例</h4><p>对非空字符串执行 SETRANGE 命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET greeting <span class="string">"hello world"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SETRANGE greeting 6 <span class="string">"Redis"</span></span><br><span class="line">(<span class="built_in">integer</span>) 11</span><br><span class="line"></span><br><span class="line">redis&gt; GET greeting</span><br><span class="line"><span class="string">"hello Redis"</span></span><br></pre></td></tr></table></figure></p><p>对空字符串/不存在的键执行 SETRANGE 命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; EXISTS empty_string</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; SETRANGE empty_string 5 <span class="string">"Redis!"</span>   <span class="comment"># 对不存在的 key 使用 SETRANGE</span></span><br><span class="line">(<span class="built_in">integer</span>) 11</span><br><span class="line"></span><br><span class="line">redis&gt; GET empty_string                   <span class="comment"># 空白处被"\x00"填充</span></span><br><span class="line"><span class="string">"\x00\x00\x00\x00\x00Redis!"</span></span><br></pre></td></tr></table></figure></p><h3 id="GETRANGE"><a href="#GETRANGE" class="headerlink" title="GETRANGE"></a>GETRANGE</h3><h4 id="GETRANGE-key-start-end"><a href="#GETRANGE-key-start-end" class="headerlink" title="GETRANGE key start end"></a>GETRANGE key start end</h4><pre><code>可用版本： &gt;= 2.4.0时间复杂度： O(N)，其中 N 为被返回的字符串的长度。</code></pre><p>返回键 <code>key</code> 储存的字符串值的指定部分， 字符串的截取范围由 <code>start</code> 和 <code>end</code> 两个偏移量决定 (包括 <code>start</code> 和 <code>end</code> 在内)。</p><p>负数偏移量表示从字符串的末尾开始计数， -1 表示最后一个字符， -2 表示倒数第二个字符， 以此类推。</p><p>GETRANGE 通过保证子字符串的值域(range)不超过实际字符串的值域来处理超出范围的值域请求。</p><p><strong>Note</strong></p><pre><code>GETRANGE 命令在 Redis 2.0 之前的版本里面被称为 SUBSTR 命令。</code></pre><h4 id="返回值-9"><a href="#返回值-9" class="headerlink" title="返回值"></a>返回值</h4><p>GETRANGE 命令会返回字符串值的指定部分。</p><h4 id="代码示例-8"><a href="#代码示例-8" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET greeting <span class="string">"hello, my friend"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GETRANGE greeting 0 4          <span class="comment"># 返回索引0-4的字符，包括4。</span></span><br><span class="line"><span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line">redis&gt; GETRANGE greeting -1 -5        <span class="comment"># 不支持回绕操作</span></span><br><span class="line"><span class="string">""</span></span><br><span class="line"></span><br><span class="line">redis&gt; GETRANGE greeting -3 -1        <span class="comment"># 负数索引</span></span><br><span class="line"><span class="string">"end"</span></span><br><span class="line"></span><br><span class="line">redis&gt; GETRANGE greeting 0 -1         <span class="comment"># 从第一个到最后一个</span></span><br><span class="line"><span class="string">"hello, my friend"</span></span><br><span class="line"></span><br><span class="line">redis&gt; GETRANGE greeting 0 1008611    <span class="comment"># 值域范围不超过实际字符串，超过部分自动被符略</span></span><br><span class="line"><span class="string">"hello, my friend"</span></span><br></pre></td></tr></table></figure><h3 id="INCRBY"><a href="#INCRBY" class="headerlink" title="INCRBY"></a>INCRBY</h3><h4 id="INCRBY-key-increment"><a href="#INCRBY-key-increment" class="headerlink" title="INCRBY key increment"></a>INCRBY key increment</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>为键 <code>key</code> 储存的数字值加上增量 increment 。</p><p>如果键 <code>key</code> 不存在， 那么键 <code>key</code> 的值会先被初始化为 0 ， 然后再执行 INCRBY 命令。</p><p>如果键 <code>key</code> 储存的值不能被解释为数字， 那么 INCRBY 命令将返回一个错误。</p><p>本操作的值限制在 64 位(bit)有符号数字表示之内。</p><h4 id="返回值-10"><a href="#返回值-10" class="headerlink" title="返回值"></a>返回值</h4><p>在加上增量 increment 之后， 键 <code>key</code> 当前的值。</p><h4 id="代码示例-9"><a href="#代码示例-9" class="headerlink" title="代码示例"></a>代码示例</h4><p>键存在，并且值为数字：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET rank 50</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; INCRBY rank 20</span><br><span class="line">(<span class="built_in">integer</span>) 70</span><br><span class="line"></span><br><span class="line">redis&gt; GET rank</span><br><span class="line"><span class="string">"70"</span></span><br></pre></td></tr></table></figure></p><p>键不存在：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; EXISTS counter</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; INCRBY counter 30</span><br><span class="line">(<span class="built_in">integer</span>) 30</span><br><span class="line"></span><br><span class="line">redis&gt; GET counter</span><br><span class="line"><span class="string">"30"</span></span><br></pre></td></tr></table></figure></p><p>键存在，但值无法被解释为数字：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET book <span class="string">"long long ago..."</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; INCRBY book 200</span><br><span class="line">(error) ERR value is not an <span class="built_in">integer</span> or out of range</span><br></pre></td></tr></table></figure></p><h3 id="INCRBYFLOAT"><a href="#INCRBYFLOAT" class="headerlink" title="INCRBYFLOAT"></a>INCRBYFLOAT</h3><h4 id="INCRBYFLOAT-key-increment"><a href="#INCRBYFLOAT-key-increment" class="headerlink" title="INCRBYFLOAT key increment"></a>INCRBYFLOAT key increment</h4><pre><code>可用版本： &gt;= 2.6.0时间复杂度： O(1)</code></pre><p>为键 <code>key</code> 储存的值加上浮点数增量 increment 。</p><p>如果键 <code>key</code> 不存在， 那么 INCRBYFLOAT 会先将键 <code>key</code> 的值设为 0 ， 然后再执行加法操作。</p><p>如果命令执行成功， 那么键 <code>key</code> 的值会被更新为执行加法计算之后的新值， 并且新值会以字符串的形式返回给调用者。</p><p>无论是键 <code>key</code> 的值还是增量 increment ， 都可以使用像 2.0e7 、 3e5 、 90e-2 那样的指数符号(exponential notation)来表示， 但是， 执行 INCRBYFLOAT 命令之后的值总是以同样的形式储存， 也即是， 它们总是由一个数字， 一个（可选的）小数点和一个任意长度的小数部分组成（比如 3.14 、 69.768 ，诸如此类)， 小数部分尾随的 0 会被移除， 如果可能的话， 命令还会将浮点数转换为整数（比如 3.0 会被保存成 3 ）。</p><p>此外， 无论加法计算所得的浮点数的实际精度有多长， INCRBYFLOAT 命令的计算结果最多只保留小数点的后十七位。</p><p>当以下任意一个条件发生时， 命令返回一个错误：</p><ul><li>键 <code>key</code> 的值不是字符串类型(因为 Redis 中的数字和浮点数都以字符串的形式保存，所以它们都属于字符串类型）；</li><li>键 <code>key</code> 当前的值或者给定的增量 increment 不能被解释(parse)为双精度浮点数。</li></ul><h4 id="返回值-11"><a href="#返回值-11" class="headerlink" title="返回值"></a>返回值</h4><p>在加上增量 increment 之后， 键 <code>key</code> 的值。</p><h4 id="代码示例-10"><a href="#代码示例-10" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GET decimal</span><br><span class="line"><span class="string">"3.0"</span></span><br><span class="line"></span><br><span class="line">redis&gt; INCRBYFLOAT decimal 2.56</span><br><span class="line"><span class="string">"5.56"</span></span><br><span class="line"></span><br><span class="line">redis&gt; GET decimal</span><br><span class="line"><span class="string">"5.56"</span></span><br></pre></td></tr></table></figure><h3 id="DECR"><a href="#DECR" class="headerlink" title="DECR"></a>DECR</h3><h4 id="DECR-key"><a href="#DECR-key" class="headerlink" title="DECR key"></a>DECR key</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>为键 <code>key</code> 储存的数字值减去一。</p><p>如果键 <code>key</code> 不存在， 那么键 <code>key</code> 的值会先被初始化为 0 ， 然后再执行 DECR 操作。</p><p>如果键 <code>key</code> 储存的值不能被解释为数字， 那么 DECR 命令将返回一个错误。</p><p>本操作的值限制在 64 位(bit)有符号数字表示之内。</p><h4 id="返回值-12"><a href="#返回值-12" class="headerlink" title="返回值"></a>返回值</h4><p>DECR 命令会返回键 <code>key</code> 在执行减一操作之后的值。</p><h4 id="代码示例-11"><a href="#代码示例-11" class="headerlink" title="代码示例"></a>代码示例</h4><p>对储存数字值的键 <code>key</code> 执行 DECR 命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET failure_times 10</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; DECR failure_times</span><br><span class="line">(<span class="built_in">integer</span>) 9</span><br></pre></td></tr></table></figure></p><p>对不存在的键执行 DECR 命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; EXISTS count</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; DECR count</span><br><span class="line">(<span class="built_in">integer</span>) -1</span><br></pre></td></tr></table></figure></p><h3 id="DECRBY"><a href="#DECRBY" class="headerlink" title="DECRBY"></a>DECRBY</h3><h4 id="DECRBY-key-decrement"><a href="#DECRBY-key-decrement" class="headerlink" title="DECRBY key decrement"></a>DECRBY key decrement</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>将键 <code>key</code> 储存的整数值减去减量 decrement 。</p><p>如果键 <code>key</code> 不存在， 那么键 <code>key</code> 的值会先被初始化为 0 ， 然后再执行 DECRBY 命令。</p><p>如果键 <code>key</code> 储存的值不能被解释为数字， 那么 DECRBY 命令将返回一个错误。</p><p>本操作的值限制在 64 位(bit)有符号数字表示之内。</p><h4 id="返回值-13"><a href="#返回值-13" class="headerlink" title="返回值"></a>返回值</h4><p>DECRBY 命令会返回键在执行减法操作之后的值。</p><h4 id="代码示例-12"><a href="#代码示例-12" class="headerlink" title="代码示例"></a>代码示例</h4><p>对已经存在的键执行 DECRBY 命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET count 100</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; DECRBY count 20</span><br><span class="line">(<span class="built_in">integer</span>) 80</span><br></pre></td></tr></table></figure></p><p>对不存在的键执行 DECRBY 命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; EXISTS pages</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; DECRBY pages 10</span><br><span class="line">(<span class="built_in">integer</span>) -10</span><br></pre></td></tr></table></figure></p><h3 id="MSET"><a href="#MSET" class="headerlink" title="MSET"></a>MSET</h3><h4 id="MSET-key-value-key-value-…"><a href="#MSET-key-value-key-value-…" class="headerlink" title="MSET key value [key value …]"></a>MSET key value [key value …]</h4><pre><code>可用版本： &gt;= 1.0.1时间复杂度： O(N)，其中 N 为被设置的键数量。</code></pre><p>同时为多个键设置值。</p><p>如果某个给定键已经存在， 那么 MSET 将使用新值去覆盖旧值， 如果这不是你所希望的效果， 请考虑使用 MSETNX 命令， 这个命令只会在所有给定键都不存在的情况下进行设置。</p><p>MSET 是一个原子性(atomic)操作， 所有给定键都会在同一时间内被设置， 不会出现某些键被设置了但是另一些键没有被设置的情况。</p><h4 id="返回值-14"><a href="#返回值-14" class="headerlink" title="返回值"></a>返回值</h4><p>MSET 命令总是返回 OK 。</p><h4 id="代码示例-13"><a href="#代码示例-13" class="headerlink" title="代码示例"></a>代码示例</h4><p>同时对多个键进行设置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MSET date <span class="string">"2012.3.30"</span> time <span class="string">"11:00 a.m."</span> weather <span class="string">"sunny"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; MGET date time weather</span><br><span class="line">1) <span class="string">"2012.3.30"</span></span><br><span class="line">2) <span class="string">"11:00 a.m."</span></span><br><span class="line">3) <span class="string">"sunny"</span></span><br></pre></td></tr></table></figure></p><p>覆盖已有的值：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MGET k1 k2</span><br><span class="line">1) <span class="string">"hello"</span></span><br><span class="line">2) <span class="string">"world"</span></span><br><span class="line"></span><br><span class="line">redis&gt; MSET k1 <span class="string">"good"</span> k2 <span class="string">"bye"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; MGET k1 k2</span><br><span class="line">1) <span class="string">"good"</span></span><br><span class="line">2) <span class="string">"bye"</span></span><br></pre></td></tr></table></figure></p><h3 id="MSETNX"><a href="#MSETNX" class="headerlink" title="MSETNX"></a>MSETNX</h3><h4 id="MSETNX-key-value-key-value-…"><a href="#MSETNX-key-value-key-value-…" class="headerlink" title="MSETNX key value [key value …]"></a>MSETNX key value [key value …]</h4><pre><code>可用版本： &gt;= 1.0.1时间复杂度： O(N)， 其中 N 为被设置的键数量。</code></pre><p>当且仅当所有给定键都不存在时， 为所有给定键设置值。</p><p>即使只有一个给定键已经存在， MSETNX 命令也会拒绝执行对所有键的设置操作。</p><p>MSETNX 是一个原子性(atomic)操作， 所有给定键要么就全部都被设置， 要么就全部都不设置， 不可能出现第三种状态。</p><h4 id="返回值-15"><a href="#返回值-15" class="headerlink" title="返回值"></a>返回值</h4><p>当所有给定键都设置成功时， 命令返回 1 ； </p><p>如果因为某个给定键已经存在而导致设置未能成功执行， 那么命令返回 0 。</p><h4 id="代码示例-14"><a href="#代码示例-14" class="headerlink" title="代码示例"></a>代码示例</h4><p>对不存在的键执行 MSETNX 命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MSETNX rmdbs <span class="string">"MySQL"</span> nosql <span class="string">"MongoDB"</span> key-value-store <span class="string">"redis"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; MGET rmdbs nosql key-value-store</span><br><span class="line">1) <span class="string">"MySQL"</span></span><br><span class="line">2) <span class="string">"MongoDB"</span></span><br><span class="line">3) <span class="string">"redis"</span></span><br></pre></td></tr></table></figure></p><p>对某个已经存在的键进行设置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MSETNX rmdbs <span class="string">"Sqlite"</span> language <span class="string">"python"</span>  <span class="comment"># rmdbs 键已经存在，操作失败</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; EXISTS language                          <span class="comment"># 因为 MSETNX 命令没有成功执行</span></span><br><span class="line">(<span class="built_in">integer</span>) 0                                     <span class="comment"># 所以 language 键没有被设置</span></span><br><span class="line"></span><br><span class="line">redis&gt; GET rmdbs                                <span class="comment"># rmdbs 键也没有被修改</span></span><br><span class="line"><span class="string">"MySQL"</span></span><br></pre></td></tr></table></figure></p><h3 id="MGET"><a href="#MGET" class="headerlink" title="MGET"></a>MGET</h3><h4 id="MGET-key-key-…"><a href="#MGET-key-key-…" class="headerlink" title="MGET key [key …]"></a>MGET key [key …]</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(N) ，其中 N 为给定键的数量。</code></pre><p>返回给定的一个或多个字符串键的值。</p><ul><li>如果给定的字符串键里面， 有某个键不存在， 那么这个键的值将以特殊值 nil 表示。</li></ul><h4 id="返回值-16"><a href="#返回值-16" class="headerlink" title="返回值"></a>返回值</h4><p>MGET 命令将返回一个列表， 列表中包含了所有给定键的值。</p><h4 id="代码示例-15"><a href="#代码示例-15" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET redis redis.com</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SET mongodb mongodb.org</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; MGET redis mongodb</span><br><span class="line">1) <span class="string">"redis.com"</span></span><br><span class="line">2) <span class="string">"mongodb.org"</span></span><br><span class="line"></span><br><span class="line">redis&gt; MGET redis mongodb mysql     <span class="comment"># 不存在的 mysql 返回 nil</span></span><br><span class="line">1) <span class="string">"redis.com"</span></span><br><span class="line">2) <span class="string">"mongodb.org"</span></span><br><span class="line">3) (nil)</span><br></pre></td></tr></table></figure><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a><a name="哈希表">哈希表</a></h2><h3 id="HSET"><a href="#HSET" class="headerlink" title="HSET"></a>HSET</h3><h4 id="HSET-hash-field-value"><a href="#HSET-hash-field-value" class="headerlink" title="HSET hash field value"></a>HSET hash field value</h4><pre><code>可用版本： &gt;= 2.0.0时间复杂度： O(1)</code></pre><p>将哈希表 hash 中域 field 的值设置为 <code>value</code> 。</p><p>如果给定的哈希表并不存在， 那么一个新的哈希表将被创建并执行 HSET 操作。</p><p>如果域 field 已经存在于哈希表中， 那么它的旧值将被新值 <code>value</code> 覆盖。</p><h4 id="返回值-17"><a href="#返回值-17" class="headerlink" title="返回值"></a>返回值</h4><ul><li>当 HSET 命令在哈希表中新创建 field 域并成功为它设置值时， 命令返回 1 ； </li><li>如果域 field 已经存在于哈希表， 并且 HSET 命令成功使用新值覆盖了它的旧值， 那么命令返回 0 。</li></ul><h4 id="代码示例-16"><a href="#代码示例-16" class="headerlink" title="代码示例"></a>代码示例</h4><p>设置一个新域：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSET website google <span class="string">"www.g.cn"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HGET website google</span><br><span class="line"><span class="string">"www.g.cn"</span></span><br></pre></td></tr></table></figure></p><p>对一个已存在的域进行更新：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSET website google <span class="string">"www.google.com"</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; HGET website google</span><br><span class="line"><span class="string">"www.google.com"</span></span><br></pre></td></tr></table></figure></p><h3 id="HSETNX"><a href="#HSETNX" class="headerlink" title="HSETNX"></a>HSETNX</h3><h4 id="HSETNX-hash-field-value"><a href="#HSETNX-hash-field-value" class="headerlink" title="HSETNX hash field value"></a>HSETNX hash field value</h4><pre><code>可用版本： &gt;= 2.0.0时间复杂度： O(1)</code></pre><p>当且仅当域 field 尚未存在于哈希表的情况下， 将它的值设置为 <code>value</code> 。</p><p>如果给定域已经存在于哈希表当中， 那么命令将放弃执行设置操作。</p><p>如果哈希表 hash 不存在， 那么一个新的哈希表将被创建并执行 HSETNX 命令。</p><h4 id="返回值-18"><a href="#返回值-18" class="headerlink" title="返回值"></a>返回值</h4><p>HSETNX 命令在设置成功时返回 1 ， 在给定域已经存在而放弃执行设置操作时返回 0 。</p><h4 id="代码示例-17"><a href="#代码示例-17" class="headerlink" title="代码示例"></a>代码示例</h4><p>域尚未存在， 设置成功：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSETNX database key-value-store Redis</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HGET database key-value-store</span><br><span class="line"><span class="string">"Redis"</span></span><br></pre></td></tr></table></figure></p><p>域已经存在， 设置未成功， 域原有的值未被改变：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSETNX database key-value-store Riak</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; HGET database key-value-store</span><br><span class="line"><span class="string">"Redis"</span></span><br></pre></td></tr></table></figure></p><h3 id="HGET"><a href="#HGET" class="headerlink" title="HGET"></a>HGET</h3><h4 id="HGET-hash-field"><a href="#HGET-hash-field" class="headerlink" title="HGET hash field"></a>HGET hash field</h4><pre><code>可用版本： &gt;= 2.0.0时间复杂度： O(1)</code></pre><p>返回哈希表中给定域的值。</p><h4 id="返回值-19"><a href="#返回值-19" class="headerlink" title="返回值"></a>返回值</h4><p>HGET 命令在默认情况下返回给定域的值。</p><p>如果给定域不存在于哈希表中， 又或者给定的哈希表并不存在， 那么命令返回 nil 。</p><h4 id="代码示例-18"><a href="#代码示例-18" class="headerlink" title="代码示例"></a>代码示例</h4><p>域存在的情况：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSET homepage redis redis.com</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HGET homepage redis</span><br><span class="line"><span class="string">"redis.com"</span></span><br></pre></td></tr></table></figure></p><p>域不存在的情况：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HGET site mysql</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure></p><h3 id="HEXISTS"><a href="#HEXISTS" class="headerlink" title="HEXISTS"></a>HEXISTS</h3><h4 id="HEXISTS-hash-field"><a href="#HEXISTS-hash-field" class="headerlink" title="HEXISTS hash field"></a>HEXISTS hash field</h4><pre><code>可用版本： &gt;= 2.0.0时间复杂度： O(1)</code></pre><p>检查给定域 field 是否存在于哈希表 hash 当中。</p><h4 id="返回值-20"><a href="#返回值-20" class="headerlink" title="返回值"></a>返回值</h4><p>HEXISTS 命令在给定域存在时返回 1 ， 在给定域不存在时返回 0 。</p><h4 id="代码示例-19"><a href="#代码示例-19" class="headerlink" title="代码示例"></a>代码示例</h4><p>给定域不存在：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HEXISTS phone myphone</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure></p><p>给定域存在：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSET phone myphone nokia-1110</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HEXISTS phone myphone</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure></p><h3 id="HDEL"><a href="#HDEL" class="headerlink" title="HDEL"></a>HDEL</h3><h4 id="HDEL-key-field-field-…"><a href="#HDEL-key-field-field-…" class="headerlink" title="HDEL key field [field …]"></a>HDEL key field [field …]</h4><pre><code>可用版本：&gt;= 2.0.0时间复杂度:O(N)， N 为要删除的域的数量。</code></pre><p>删除哈希表 <code>key</code> 中的一个或多个指定域，不存在的域将被忽略。</p><font color="red"><strong>Note</strong></font><pre><code>在Redis2.4以下的版本里， HDEL 每次只能删除单个域，如果你需要在一个原子时间内删除多个域，请将命令包含在 MULTI / EXEC 块内。</code></pre><h4 id="返回值-21"><a href="#返回值-21" class="headerlink" title="返回值"></a>返回值</h4><p>被成功移除的域的数量，不包括被忽略的域。</p><h4 id="代码示例-20"><a href="#代码示例-20" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试数据</span></span><br><span class="line">redis&gt; HGETALL abbr</span><br><span class="line">1) <span class="string">"a"</span></span><br><span class="line">2) <span class="string">"apple"</span></span><br><span class="line">3) <span class="string">"b"</span></span><br><span class="line">4) <span class="string">"banana"</span></span><br><span class="line">5) <span class="string">"c"</span></span><br><span class="line">6) <span class="string">"cat"</span></span><br><span class="line">7) <span class="string">"d"</span></span><br><span class="line">8) <span class="string">"dog"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除单个域</span></span><br><span class="line">redis&gt; HDEL abbr a</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除不存在的域</span></span><br><span class="line">redis&gt; HDEL abbr not-exists-field</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除多个域</span></span><br><span class="line">redis&gt; HDEL abbr b c</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; HGETALL abbr</span><br><span class="line">1) <span class="string">"d"</span></span><br><span class="line">2) <span class="string">"dog"</span></span><br></pre></td></tr></table></figure><h3 id="HLEN"><a href="#HLEN" class="headerlink" title="HLEN"></a>HLEN</h3><h4 id="HLEN-key"><a href="#HLEN-key" class="headerlink" title="HLEN key"></a>HLEN key</h4><pre><code>时间复杂度：O(1)</code></pre><p>返回哈希表 key 中域的数量。</p><h4 id="返回值-22"><a href="#返回值-22" class="headerlink" title="返回值"></a>返回值</h4><p>哈希表中域的数量。</p><p>当 key 不存在时，返回 0 。</p><h4 id="代码示例-21"><a href="#代码示例-21" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSET db redis redis.com</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HSET db mysql mysql.com</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HLEN db</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; HSET db mongodb mongodb.org</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HLEN db</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure><h3 id="HSTRLEN"><a href="#HSTRLEN" class="headerlink" title="HSTRLEN"></a>HSTRLEN</h3><h4 id="HSTRLEN-key-field"><a href="#HSTRLEN-key-field" class="headerlink" title="HSTRLEN key field"></a>HSTRLEN key field</h4><pre><code>可用版本：&gt;= 3.2.0时间复杂度：O(1)</code></pre><p>返回哈希表 key 中， 与给定域 field 相关联的值的字符串长度（string length）。</p><p>如果给定的键或者域不存在， 那么命令返回 0 。</p><h4 id="返回值-23"><a href="#返回值-23" class="headerlink" title="返回值"></a>返回值</h4><p>一个整数。</p><h4 id="代码示例-22"><a href="#代码示例-22" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HMSET myhash f1 <span class="string">"HelloWorld"</span> f2 <span class="string">"99"</span> f3 <span class="string">"-256"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; HSTRLEN myhash f1</span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line"></span><br><span class="line">redis&gt; HSTRLEN myhash f2</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; HSTRLEN myhash f3</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br></pre></td></tr></table></figure><h3 id="HINCRBY"><a href="#HINCRBY" class="headerlink" title="HINCRBY"></a>HINCRBY</h3><h4 id="HINCRBY-key-field-increment"><a href="#HINCRBY-key-field-increment" class="headerlink" title="HINCRBY key field increment"></a>HINCRBY key field increment</h4><pre><code>可用版本：&gt;= 2.0.0时间复杂度：O(1)</code></pre><p>为哈希表 key 中的域 field 的值加上增量 increment 。</p><p>增量也可以为负数，相当于对给定域进行减法操作。</p><p>如果 key 不存在，一个新的哈希表被创建并执行 HINCRBY 命令。</p><p>如果域 field 不存在，那么在执行命令前，域的值被初始化为 0 。</p><p>对一个储存字符串值的域 field 执行 HINCRBY 命令将造成一个错误。</p><p>本操作的值被限制在 64 位(bit)有符号数字表示之内。</p><h4 id="返回值-24"><a href="#返回值-24" class="headerlink" title="返回值"></a>返回值</h4><p>执行 HINCRBY 命令之后，哈希表 key 中域 field 的值。</p><h4 id="代码示例-23"><a href="#代码示例-23" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># increment 为正数</span></span><br><span class="line">redis&gt; HEXISTS counter page_view    <span class="comment"># 对空域进行设置</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; HINCRBY counter page_view 200</span><br><span class="line">(<span class="built_in">integer</span>) 200</span><br><span class="line"></span><br><span class="line">redis&gt; HGET counter page_view</span><br><span class="line"><span class="string">"200"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># increment 为负数</span></span><br><span class="line">redis&gt; HGET counter page_view</span><br><span class="line"><span class="string">"200"</span></span><br><span class="line"></span><br><span class="line">redis&gt; HINCRBY counter page_view -50</span><br><span class="line">(<span class="built_in">integer</span>) 150</span><br><span class="line"></span><br><span class="line">redis&gt; HGET counter page_view</span><br><span class="line"><span class="string">"150"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 尝试对字符串值的域执行HINCRBY命令</span></span><br><span class="line">redis&gt; HSET myhash string hello,world       <span class="comment"># 设定一个字符串值</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HGET myhash string</span><br><span class="line"><span class="string">"hello,world"</span></span><br><span class="line"></span><br><span class="line">redis&gt; HINCRBY myhash string 1              <span class="comment"># 命令执行失败，错误。</span></span><br><span class="line">(error) ERR <span class="built_in">hash</span> value is not an <span class="built_in">integer</span></span><br><span class="line"></span><br><span class="line">redis&gt; HGET myhash string                   <span class="comment"># 原值不变</span></span><br><span class="line"><span class="string">"hello,world"</span></span><br></pre></td></tr></table></figure><h3 id="HINCRBYFLOAT"><a href="#HINCRBYFLOAT" class="headerlink" title="HINCRBYFLOAT"></a>HINCRBYFLOAT</h3><h4 id="HINCRBYFLOAT-key-field-increment"><a href="#HINCRBYFLOAT-key-field-increment" class="headerlink" title="HINCRBYFLOAT key field increment"></a>HINCRBYFLOAT key field increment</h4><pre><code>可用版本：&gt;= 2.6.0时间复杂度：O(1)</code></pre><p>为哈希表 key 中的域 field 加上浮点数增量 increment 。</p><p>如果哈希表中没有域 field ，那么 HINCRBYFLOAT 会先将域 field 的值设为 0 ，然后再执行加法操作。</p><p>如果键 key 不存在，那么 HINCRBYFLOAT 会先创建一个哈希表，再创建域 field ，最后再执行加法操作。</p><p>当以下任意一个条件发生时，返回一个错误：</p><ul><li>域 field 的值不是字符串类型(因为 redis 中的数字和浮点数都以字符串的形式保存，所以它们都属于字符串类型）</li><li>域 field 当前的值或给定的增量 increment 不能解释(parse)为双精度浮点数(double precision floating point number)</li></ul><h4 id="返回值-25"><a href="#返回值-25" class="headerlink" title="返回值"></a>返回值</h4><p>执行加法操作之后 field 域的值。</p><h4 id="代码示例-24"><a href="#代码示例-24" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 值和增量都是普通小数</span></span><br><span class="line">redis&gt; HSET mykey field 10.50</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; HINCRBYFLOAT mykey field 0.1</span><br><span class="line"><span class="string">"10.6"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 值和增量都是指数符号</span></span><br><span class="line">redis&gt; HSET mykey field 5.0e3</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; HINCRBYFLOAT mykey field 2.0e2</span><br><span class="line"><span class="string">"5200"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对不存在的键执行 HINCRBYFLOAT</span></span><br><span class="line">redis&gt; EXISTS price</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; HINCRBYFLOAT price milk 3.5</span><br><span class="line"><span class="string">"3.5"</span></span><br><span class="line">redis&gt; HGETALL price</span><br><span class="line">1) <span class="string">"milk"</span></span><br><span class="line">2) <span class="string">"3.5"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对不存在的域进行 HINCRBYFLOAT</span></span><br><span class="line">redis&gt; HGETALL price</span><br><span class="line">1) <span class="string">"milk"</span></span><br><span class="line">2) <span class="string">"3.5"</span></span><br><span class="line">redis&gt; HINCRBYFLOAT price coffee 4.5   <span class="comment"># 新增 coffee 域</span></span><br><span class="line"><span class="string">"4.5"</span></span><br><span class="line">redis&gt; HGETALL price</span><br><span class="line">1) <span class="string">"milk"</span></span><br><span class="line">2) <span class="string">"3.5"</span></span><br><span class="line">3) <span class="string">"coffee"</span></span><br><span class="line">4) <span class="string">"4.5"</span></span><br></pre></td></tr></table></figure><h3 id="HMSET"><a href="#HMSET" class="headerlink" title="HMSET"></a>HMSET</h3><h4 id="HMSET-key-field-value-field-value-…"><a href="#HMSET-key-field-value-field-value-…" class="headerlink" title="HMSET key field value [field value …]"></a>HMSET key field value [field value …]</h4><pre><code>可用版本：&gt;= 2.0.0时间复杂度：O(N)， N 为 field-value 对的数量。</code></pre><p>同时将多个 field-value (域-值)对设置到哈希表 key 中。</p><p>此命令会覆盖哈希表中已存在的域。</p><p>如果 key 不存在，一个空哈希表被创建并执行 HMSET 操作。</p><h4 id="返回值-26"><a href="#返回值-26" class="headerlink" title="返回值"></a>返回值</h4><p>如果命令执行成功，返回 OK 。</p><p>当 key 不是哈希表(hash)类型时，返回一个错误。</p><h4 id="代码示例-25"><a href="#代码示例-25" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HMSET website google www.google.com yahoo www.yahoo.com</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; HGET website google</span><br><span class="line"><span class="string">"www.google.com"</span></span><br><span class="line"></span><br><span class="line">redis&gt; HGET website yahoo</span><br><span class="line"><span class="string">"www.yahoo.com"</span></span><br></pre></td></tr></table></figure><h3 id="HMGET"><a href="#HMGET" class="headerlink" title="HMGET"></a>HMGET</h3><h4 id="HMGET-key-field-field-…"><a href="#HMGET-key-field-field-…" class="headerlink" title="HMGET key field [field …]"></a>HMGET key field [field …]</h4><pre><code>可用版本：&gt;= 2.0.0时间复杂度：O(N)， N 为给定域的数量。</code></pre><p>返回哈希表 key 中，一个或多个给定域的值。</p><p>如果给定的域不存在于哈希表，那么返回一个 nil 值。</p><p>因为不存在的 key 被当作一个空哈希表来处理，所以对一个不存在的 key 进行 HMGET 操作将返回一个只带有 nil 值的表。</p><h4 id="返回值-27"><a href="#返回值-27" class="headerlink" title="返回值"></a>返回值</h4><p>一个包含多个给定域的关联值的表，表值的排列顺序和给定域参数的请求顺序一样。</p><h4 id="代码示例-26"><a href="#代码示例-26" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HMSET pet dog <span class="string">"doudou"</span> cat <span class="string">"nounou"</span>    <span class="comment"># 一次设置多个域</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; HMGET pet dog cat fake_pet             <span class="comment"># 返回值的顺序和传入参数的顺序一样</span></span><br><span class="line">1) <span class="string">"doudou"</span></span><br><span class="line">2) <span class="string">"nounou"</span></span><br><span class="line">3) (nil)</span><br></pre></td></tr></table></figure><h3 id="HKEYS"><a href="#HKEYS" class="headerlink" title="HKEYS"></a>HKEYS</h3><h4 id="HKEYS-key"><a href="#HKEYS-key" class="headerlink" title="HKEYS key"></a>HKEYS key</h4><pre><code>可用版本：&gt;= 2.0.0时间复杂度：O(N)， N 为哈希表的大小。</code></pre><p>返回哈希表 key 中的所有域。</p><h4 id="返回值-28"><a href="#返回值-28" class="headerlink" title="返回值"></a>返回值</h4><p>一个包含哈希表中所有域的表。<br>当 key 不存在时，返回一个空表。</p><h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 哈希表非空</span></span><br><span class="line">redis&gt; HMSET website google www.google.com yahoo www.yahoo.com</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; HKEYS website</span><br><span class="line">1) <span class="string">"google"</span></span><br><span class="line">2) <span class="string">"yahoo"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 空哈希表/key不存在</span></span><br><span class="line">redis&gt; EXISTS fake_key</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; HKEYS fake_key</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br></pre></td></tr></table></figure><h3 id="HVALS"><a href="#HVALS" class="headerlink" title="HVALS"></a>HVALS</h3><h4 id="HVALS-key"><a href="#HVALS-key" class="headerlink" title="HVALS key"></a>HVALS key</h4><pre><code>可用版本：&gt;= 2.0.0时间复杂度：O(N)， N 为哈希表的大小。</code></pre><p>返回哈希表 key 中所有域的值。</p><h4 id="返回值-29"><a href="#返回值-29" class="headerlink" title="返回值"></a>返回值</h4><p>一个包含哈希表中所有值的表。</p><p>当 key 不存在时，返回一个空表。</p><h4 id="代码示例-27"><a href="#代码示例-27" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 非空哈希表</span></span><br><span class="line">redis&gt; HMSET website google www.google.com yahoo www.yahoo.com</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; HVALS website</span><br><span class="line">1) <span class="string">"www.google.com"</span></span><br><span class="line">2) <span class="string">"www.yahoo.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 空哈希表/不存在的key</span></span><br><span class="line">redis&gt; EXISTS not_exists</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; HVALS not_exists</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br></pre></td></tr></table></figure><h3 id="HGETALL"><a href="#HGETALL" class="headerlink" title="HGETALL"></a>HGETALL</h3><h4 id="HGETALL-key"><a href="#HGETALL-key" class="headerlink" title="HGETALL key"></a>HGETALL key</h4><pre><code>可用版本：&gt;= 2.0.0时间复杂度：O(N)， N 为哈希表的大小。</code></pre><p>返回哈希表 key 中，所有的域和值。</p><p>在返回值里，紧跟每个域名(field name)之后是域的值(value)，所以返回值的长度是哈希表大小的两倍。</p><h4 id="返回值-30"><a href="#返回值-30" class="headerlink" title="返回值"></a>返回值</h4><p>以列表形式返回哈希表的域和域的值。</p><p>若 key 不存在，返回空列表。</p><h4 id="代码示例-28"><a href="#代码示例-28" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSET people jack <span class="string">"Jack Sparrow"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HSET people gump <span class="string">"Forrest Gump"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HGETALL people</span><br><span class="line">1) <span class="string">"jack"</span>          <span class="comment"># 域</span></span><br><span class="line">2) <span class="string">"Jack Sparrow"</span>  <span class="comment"># 值</span></span><br><span class="line">3) <span class="string">"gump"</span></span><br><span class="line">4) <span class="string">"Forrest Gump"</span></span><br></pre></td></tr></table></figure><h3 id="HSCAN"><a href="#HSCAN" class="headerlink" title="HSCAN"></a>HSCAN</h3><h4 id="HSCAN-key-cursor-MATCH-pattern-COUNT-count"><a href="#HSCAN-key-cursor-MATCH-pattern-COUNT-count" class="headerlink" title="HSCAN key cursor [MATCH pattern] [COUNT count]"></a>HSCAN key cursor [MATCH pattern] [COUNT count]</h4><p>具体信息请参考 SCAN cursor [MATCH pattern] [COUNT count] 命令。</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a><a name="列表">列表</a></h2><h3 id="LPUSH"><a href="#LPUSH" class="headerlink" title="LPUSH"></a>LPUSH</h3><h4 id="LPUSH-key-value-value-…"><a href="#LPUSH-key-value-value-…" class="headerlink" title="LPUSH key value [value …]"></a>LPUSH key value [value …]</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>将一个或多个值 value 插入到列表 key 的表头</p><p>如果有多个 value 值，那么各个 value 值按从左到右的顺序依次插入到表头： 比如说，对空列表 mylist 执行命令 LPUSH mylist a b c ，列表的值将是 c b a ，这等同于原子性地执行 LPUSH mylist a 、 LPUSH mylist b 和 LPUSH mylist c 三个命令。</p><p>如果 key 不存在，一个空列表会被创建并执行 LPUSH 操作。</p><p>当 key 存在但不是列表类型时，返回一个错误。</p><font color="red"><strong>Note</strong></font><pre><code>在Redis 2.4版本以前的 LPUSH 命令，都只接受单个 value 值。</code></pre><h4 id="返回值-31"><a href="#返回值-31" class="headerlink" title="返回值"></a>返回值</h4><p>执行 LPUSH 命令后，列表的长度。</p><h4 id="代码示例-29"><a href="#代码示例-29" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加入单个元素</span></span><br><span class="line">redis&gt; LPUSH languages python</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入重复元素</span></span><br><span class="line">redis&gt; LPUSH languages python</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE languages 0 -1     <span class="comment"># 列表允许重复元素</span></span><br><span class="line">1) <span class="string">"python"</span></span><br><span class="line">2) <span class="string">"python"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入多个元素</span></span><br><span class="line">redis&gt; LPUSH mylist a b c</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">"c"</span></span><br><span class="line">2) <span class="string">"b"</span></span><br><span class="line">3) <span class="string">"a"</span></span><br></pre></td></tr></table></figure><h3 id="LPUSHX"><a href="#LPUSHX" class="headerlink" title="LPUSHX"></a>LPUSHX</h3><h4 id="LPUSHX-key-value"><a href="#LPUSHX-key-value" class="headerlink" title="LPUSHX key value"></a>LPUSHX key value</h4><pre><code>可用版本： &gt;= 2.2.0时间复杂度： O(1)</code></pre><p>将值 value 插入到列表 key 的表头，当且仅当 key 存在并且是一个列表。</p><p>和 LPUSH key value [value …] 命令相反，当 key 不存在时， LPUSHX 命令什么也不做。</p><h4 id="返回值-32"><a href="#返回值-32" class="headerlink" title="返回值"></a>返回值</h4><p>LPUSHX 命令执行之后，表的长度。</p><h4 id="代码示例-30"><a href="#代码示例-30" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对空列表执行 LPUSHX</span></span><br><span class="line">redis&gt; LLEN greet                       <span class="comment"># greet 是一个空列表</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; LPUSHX greet <span class="string">"hello"</span>             <span class="comment"># 尝试 LPUSHX，失败，因为列表为空</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对非空列表执行 LPUSHX</span></span><br><span class="line">redis&gt; LPUSH greet <span class="string">"hello"</span>              <span class="comment"># 先用 LPUSH 创建一个有一个元素的列表</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; LPUSHX greet <span class="string">"good morning"</span>      <span class="comment"># 这次 LPUSHX 执行成功</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE greet 0 -1</span><br><span class="line">1) <span class="string">"good morning"</span></span><br><span class="line">2) <span class="string">"hello"</span></span><br></pre></td></tr></table></figure><h3 id="RPUSH"><a href="#RPUSH" class="headerlink" title="RPUSH"></a>RPUSH</h3><h4 id="RPUSH-key-value-value-…"><a href="#RPUSH-key-value-value-…" class="headerlink" title="RPUSH key value [value …]"></a>RPUSH key value [value …]</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>将一个或多个值 value 插入到列表 key 的表尾(最右边)。</p><p>如果有多个 value 值，那么各个 value 值按从左到右的顺序依次插入到表尾：比如对一个空列表 mylist 执行 RPUSH mylist a b c ，得出的结果列表为 a b c ，等同于执行命令 RPUSH mylist a 、 RPUSH mylist b 、 RPUSH mylist c 。</p><p>如果 key 不存在，一个空列表会被创建并执行 RPUSH 操作。</p><p>当 key 存在但不是列表类型时，返回一个错误。</p><font color="red"><strong>Note</strong></font><pre><code>在 Redis 2.4 版本以前的 RPUSH 命令，都只接受单个 value 值。</code></pre><h4 id="返回值-33"><a href="#返回值-33" class="headerlink" title="返回值"></a>返回值</h4><p>执行 RPUSH 操作后，表的长度。</p><h4 id="代码示例-31"><a href="#代码示例-31" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加单个元素</span></span><br><span class="line">redis&gt; RPUSH languages c</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加重复元素</span></span><br><span class="line">redis&gt; RPUSH languages c</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE languages 0 -1 <span class="comment"># 列表允许重复元素</span></span><br><span class="line">1) <span class="string">"c"</span></span><br><span class="line">2) <span class="string">"c"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加多个元素</span></span><br><span class="line">redis&gt; RPUSH mylist a b c</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">"a"</span></span><br><span class="line">2) <span class="string">"b"</span></span><br><span class="line">3) <span class="string">"c"</span></span><br></pre></td></tr></table></figure><h3 id="RPUSHX"><a href="#RPUSHX" class="headerlink" title="RPUSHX"></a>RPUSHX</h3><h4 id="RPUSHX-key-value"><a href="#RPUSHX-key-value" class="headerlink" title="RPUSHX key value"></a>RPUSHX key value</h4><pre><code>可用版本： &gt;= 2.2.0时间复杂度： O(1)</code></pre><p>将值 value 插入到列表 key 的表尾，当且仅当 key 存在并且是一个列表。</p><p>和 RPUSH key value [value …] 命令相反，当 key 不存在时， RPUSHX 命令什么也不做。</p><h4 id="返回值-34"><a href="#返回值-34" class="headerlink" title="返回值"></a>返回值</h4><p>RPUSHX 命令执行之后，表的长度。</p><h4 id="代码示例-32"><a href="#代码示例-32" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># key不存在</span></span><br><span class="line">redis&gt; LLEN greet</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSHX greet <span class="string">"hello"</span>     <span class="comment"># 对不存在的 key 进行 RPUSHX，PUSH 失败。</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># key 存在且是一个非空列表</span></span><br><span class="line">redis&gt; RPUSH greet <span class="string">"hi"</span>         <span class="comment"># 先用 RPUSH 插入一个元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSHX greet <span class="string">"hello"</span>     <span class="comment"># greet 现在是一个列表类型，RPUSHX 操作成功。</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE greet 0 -1</span><br><span class="line">1) <span class="string">"hi"</span></span><br><span class="line">2) <span class="string">"hello"</span></span><br></pre></td></tr></table></figure><h3 id="LPOP"><a href="#LPOP" class="headerlink" title="LPOP"></a>LPOP</h3><h4 id="LPOP-key"><a href="#LPOP-key" class="headerlink" title="LPOP key"></a>LPOP key</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>移除并返回列表 key 的头元素。</p><h4 id="返回值-35"><a href="#返回值-35" class="headerlink" title="返回值"></a>返回值</h4><p>列表的头元素。 当 key 不存在时，返回 nil 。</p><h4 id="代码示例-33"><a href="#代码示例-33" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; LLEN course</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH course algorithm001</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH course c++101</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; LPOP course  <span class="comment"># 移除头元素</span></span><br><span class="line"><span class="string">"algorithm001"</span></span><br></pre></td></tr></table></figure><h3 id="RPOP"><a href="#RPOP" class="headerlink" title="RPOP"></a>RPOP</h3><h4 id="RPOP-key"><a href="#RPOP-key" class="headerlink" title="RPOP key"></a>RPOP key</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>移除并返回列表 key 的尾元素。</p><h4 id="返回值-36"><a href="#返回值-36" class="headerlink" title="返回值"></a>返回值</h4><p>列表的尾元素。 当 key 不存在时，返回 nil 。</p><h4 id="代码示例-34"><a href="#代码示例-34" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; RPUSH mylist <span class="string">"one"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH mylist <span class="string">"two"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH mylist <span class="string">"three"</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis&gt; RPOP mylist           <span class="comment"># 返回被弹出的元素</span></span><br><span class="line"><span class="string">"three"</span></span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE mylist 0 -1    <span class="comment"># 列表剩下的元素</span></span><br><span class="line">1) <span class="string">"one"</span></span><br><span class="line">2) <span class="string">"two"</span></span><br></pre></td></tr></table></figure><h3 id="RPOPLPUSH"><a href="#RPOPLPUSH" class="headerlink" title="RPOPLPUSH"></a>RPOPLPUSH</h3><h4 id="RPOPLPUSH-source-destination"><a href="#RPOPLPUSH-source-destination" class="headerlink" title="RPOPLPUSH source destination"></a>RPOPLPUSH source destination</h4><pre><code>可用版本： &gt;= 1.2.0时间复杂度： O(1)</code></pre><p>命令 RPOPLPUSH 在一个原子时间内，执行以下两个动作：</p><p>将列表 source 中的最后一个元素(尾元素)弹出，并返回给客户端。</p><p>将 source 弹出的元素插入到列表 destination ，作为 destination 列表的的头元素。</p><p>举个例子，你有两个列表 source 和 destination ， source 列表有元素 a, b, c ， destination 列表有元素 x, y, z ，执行 RPOPLPUSH source destination 之后， source 列表包含元素 a, b ， destination 列表包含元素 c, x, y, z ，并且元素 c 会被返回给客户端。</p><p>如果 source 不存在，值 nil 被返回，并且不执行其他动作。</p><p>如果 source 和 destination 相同，则列表中的表尾元素被移动到表头，并返回该元素，可以把这种特殊情况视作列表的旋转(rotation)操作。</p><h4 id="返回值-37"><a href="#返回值-37" class="headerlink" title="返回值"></a>返回值</h4><p>被弹出的元素。</p><h4 id="代码示例-35"><a href="#代码示例-35" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># source 和 destination 不同</span></span><br><span class="line">redis&gt; LRANGE alpha 0 -1         <span class="comment"># 查看所有元素</span></span><br><span class="line">1) <span class="string">"a"</span></span><br><span class="line">2) <span class="string">"b"</span></span><br><span class="line">3) <span class="string">"c"</span></span><br><span class="line">4) <span class="string">"d"</span></span><br><span class="line"></span><br><span class="line">redis&gt; RPOPLPUSH alpha reciver   <span class="comment"># 执行一次 RPOPLPUSH 看看</span></span><br><span class="line"><span class="string">"d"</span></span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE alpha 0 -1</span><br><span class="line">1) <span class="string">"a"</span></span><br><span class="line">2) <span class="string">"b"</span></span><br><span class="line">3) <span class="string">"c"</span></span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE reciver 0 -1</span><br><span class="line">1) <span class="string">"d"</span></span><br><span class="line"></span><br><span class="line">redis&gt; RPOPLPUSH alpha reciver   <span class="comment"># 再执行一次，证实 RPOP 和 LPUSH 的位置正确</span></span><br><span class="line"><span class="string">"c"</span></span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE alpha 0 -1</span><br><span class="line">1) <span class="string">"a"</span></span><br><span class="line">2) <span class="string">"b"</span></span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE reciver 0 -1</span><br><span class="line">1) <span class="string">"c"</span></span><br><span class="line">2) <span class="string">"d"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># source 和 destination 相同</span></span><br><span class="line">redis&gt; LRANGE number 0 -1</span><br><span class="line">1) <span class="string">"1"</span></span><br><span class="line">2) <span class="string">"2"</span></span><br><span class="line">3) <span class="string">"3"</span></span><br><span class="line">4) <span class="string">"4"</span></span><br><span class="line"></span><br><span class="line">redis&gt; RPOPLPUSH number number</span><br><span class="line"><span class="string">"4"</span></span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE number 0 -1           <span class="comment"># 4 被旋转到了表头</span></span><br><span class="line">1) <span class="string">"4"</span></span><br><span class="line">2) <span class="string">"1"</span></span><br><span class="line">3) <span class="string">"2"</span></span><br><span class="line">4) <span class="string">"3"</span></span><br><span class="line"></span><br><span class="line">redis&gt; RPOPLPUSH number number</span><br><span class="line"><span class="string">"3"</span></span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE number 0 -1           <span class="comment"># 这次是 3 被旋转到了表头</span></span><br><span class="line">1) <span class="string">"3"</span></span><br><span class="line">2) <span class="string">"4"</span></span><br><span class="line">3) <span class="string">"1"</span></span><br><span class="line">4) <span class="string">"2"</span></span><br></pre></td></tr></table></figure><h4 id="模式：-安全的队列"><a href="#模式：-安全的队列" class="headerlink" title="模式： 安全的队列"></a>模式： 安全的队列</h4><p>Redis的列表经常被用作队列(queue)，用于在不同程序之间有序地交换消息(message)。一个客户端通过 LPUSH key value [value …] 命令将消息放入队列中，而另一个客户端通过 RPOP key 或者 BRPOP key [key …] timeout 命令取出队列中等待时间最长的消息。</p><p>不幸的是，上面的队列方法是『不安全』的，因为在这个过程中，一个客户端可能在取出一个消息之后崩溃，而未处理完的消息也就因此丢失。</p><p>使用 RPOPLPUSH 命令(或者它的阻塞版本 BRPOPLPUSH source destination timeout )可以解决这个问题：因为它不仅返回一个消息，同时还将这个消息添加到另一个备份列表当中，如果一切正常的话，当一个客户端完成某个消息的处理之后，可以用 LREM key count value 命令将这个消息从备份表删除。</p><p>最后，还可以添加一个客户端专门用于监视备份表，它自动地将超过一定处理时限的消息重新放入队列中去(负责处理该消息的客户端可能已经崩溃)，这样就不会丢失任何消息了。</p><h4 id="模式：循环列表"><a href="#模式：循环列表" class="headerlink" title="模式：循环列表"></a>模式：循环列表</h4><p>通过使用相同的 key 作为 RPOPLPUSH 命令的两个参数，客户端可以用一个接一个地获取列表元素的方式，取得列表的所有元素，而不必像 LRANGE key start stop 命令那样一下子将所有列表元素都从服务器传送到客户端中(两种方式的总复杂度都是 O(N))。</p><p>以上的模式甚至在以下的两个情况下也能正常工作：</p><ul><li>有多个客户端同时对同一个列表进行旋转(rotating)，它们获取不同的元素，直到所有元素都被读取完，之后又从头开始。</li><li>有客户端在向列表尾部(右边)添加新元素。</li></ul><p>这个模式使得我们可以很容易实现这样一类系统：有 N 个客户端，需要连续不断地对一些元素进行处理，而且处理的过程必须尽可能地快。一个典型的例子就是服务器的监控程序：它们需要在尽可能短的时间内，并行地检查一组网站，确保它们的可访问性。</p><p>注意，使用这个模式的客户端是易于扩展(scala)且安全(reliable)的，因为就算接收到元素的客户端失败，元素还是保存在列表里面，不会丢失，等到下个迭代来临的时候，别的客户端又可以继续处理这些元素了。</p><h3 id="LREM"><a href="#LREM" class="headerlink" title="LREM"></a>LREM</h3><h4 id="LREM-key-count-value"><a href="#LREM-key-count-value" class="headerlink" title="LREM key count value"></a>LREM key count value</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(N)， N 为列表的长度。</code></pre><p>根据参数 count 的值，移除列表中与参数 value 相等的元素。</p><p>count 的值可以是以下几种：</p><ul><li>count &gt; 0 : 从表头开始向表尾搜索，移除与 value 相等的元素，数量为 count 。</li><li>count &lt; 0 : 从表尾开始向表头搜索，移除与 value 相等的元素，数量为 count 的绝对值。</li><li>count = 0 : 移除表中所有与 value 相等的值。</li></ul><h4 id="返回值-38"><a href="#返回值-38" class="headerlink" title="返回值"></a>返回值</h4><p>被移除元素的数量。 因为不存在的 key 被视作空表(empty list)，所以当 key 不存在时， LREM 命令总是返回 0 。</p><h4 id="代码示例-36"><a href="#代码示例-36" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先创建一个表，内容排列是</span></span><br><span class="line"><span class="comment"># morning hello morning helllo morning</span></span><br><span class="line">redis&gt; LPUSH greet <span class="string">"morning"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; LPUSH greet <span class="string">"hello"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis&gt; LPUSH greet <span class="string">"morning"</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">redis&gt; LPUSH greet <span class="string">"hello"</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">redis&gt; LPUSH greet <span class="string">"morning"</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE greet 0 4         <span class="comment"># 查看所有元素</span></span><br><span class="line">1) <span class="string">"morning"</span></span><br><span class="line">2) <span class="string">"hello"</span></span><br><span class="line">3) <span class="string">"morning"</span></span><br><span class="line">4) <span class="string">"hello"</span></span><br><span class="line">5) <span class="string">"morning"</span></span><br><span class="line"></span><br><span class="line">redis&gt; LREM greet 2 morning     <span class="comment"># 移除从表头到表尾，最先发现的两个 morning</span></span><br><span class="line">(<span class="built_in">integer</span>) 2                     <span class="comment"># 两个元素被移除</span></span><br><span class="line"></span><br><span class="line">redis&gt; LLEN greet               <span class="comment"># 还剩 3 个元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE greet 0 2</span><br><span class="line">1) <span class="string">"hello"</span></span><br><span class="line">2) <span class="string">"hello"</span></span><br><span class="line">3) <span class="string">"morning"</span></span><br><span class="line"></span><br><span class="line">redis&gt; LREM greet -1 morning    <span class="comment"># 移除从表尾到表头，第一个 morning</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; LLEN greet               <span class="comment"># 剩下两个元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE greet 0 1</span><br><span class="line">1) <span class="string">"hello"</span></span><br><span class="line">2) <span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line">redis&gt; LREM greet 0 hello      <span class="comment"># 移除表中所有 hello</span></span><br><span class="line">(<span class="built_in">integer</span>) 2                    <span class="comment"># 两个 hello 被移除</span></span><br><span class="line"></span><br><span class="line">redis&gt; LLEN greet</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><h3 id="LLEN"><a href="#LLEN" class="headerlink" title="LLEN"></a>LLEN</h3><h4 id="LLEN-key"><a href="#LLEN-key" class="headerlink" title="LLEN key"></a>LLEN key</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>返回列表 key 的长度。</p><p>如果 key 不存在，则 key 被解释为一个空列表，返回 0 .</p><p>如果 key 不是列表类型，返回一个错误。</p><h4 id="返回值-39"><a href="#返回值-39" class="headerlink" title="返回值"></a>返回值</h4><p>列表 key 的长度。</p><h4 id="代码示例-37"><a href="#代码示例-37" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 空列表</span></span><br><span class="line">redis&gt; LLEN job</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 非空列表</span></span><br><span class="line">redis&gt; LPUSH job <span class="string">"cook food"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; LPUSH job <span class="string">"have lunch"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; LLEN job</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure><h3 id="LINDEX"><a href="#LINDEX" class="headerlink" title="LINDEX"></a>LINDEX</h3><h4 id="LINDEX-key-index"><a href="#LINDEX-key-index" class="headerlink" title="LINDEX key index"></a>LINDEX key index</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度：O(N)， N 为到达下标 index 过程中经过的元素数量。因此，对列表的头元素和尾元素执行 LINDEX 命令，复杂度为O(1)。</code></pre><p>返回列表 key 中，下标为 index 的元素。</p><p>下标(index)参数 start 和 stop 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。</p><p>你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</p><p>如果 key 不是列表类型，返回一个错误。</p><h4 id="返回值-40"><a href="#返回值-40" class="headerlink" title="返回值"></a>返回值</h4><p>列表中下标为 index 的元素。 如果 index 参数的值不在列表的区间范围内(out of range)，返回 nil 。</p><h4 id="代码示例-38"><a href="#代码示例-38" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; LPUSH mylist <span class="string">"World"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; LPUSH mylist <span class="string">"Hello"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; LINDEX mylist 0</span><br><span class="line"><span class="string">"Hello"</span></span><br><span class="line"></span><br><span class="line">redis&gt; LINDEX mylist -1</span><br><span class="line"><span class="string">"World"</span></span><br><span class="line"></span><br><span class="line">redis&gt; LINDEX mylist 3        <span class="comment"># index不在 mylist 的区间范围内</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h3 id="LINSERT"><a href="#LINSERT" class="headerlink" title="LINSERT"></a>LINSERT</h3><h4 id="LINSERT-key-BEFORE-AFTER-pivot-value"><a href="#LINSERT-key-BEFORE-AFTER-pivot-value" class="headerlink" title="LINSERT key BEFORE|AFTER pivot value"></a>LINSERT key BEFORE|AFTER pivot value</h4><pre><code>可用版本： &gt;= 2.2.0时间复杂度: O(N)， N 为寻找 pivot 过程中经过的元素数量。</code></pre><p>将值 value 插入到列表 key 当中，位于值 pivot 之前或之后。</p><p>当 pivot 不存在于列表 key 时，不执行任何操作。</p><p>当 key 不存在时， key 被视为空列表，不执行任何操作。</p><p>如果 key 不是列表类型，返回一个错误。</p><h4 id="返回值-41"><a href="#返回值-41" class="headerlink" title="返回值"></a>返回值</h4><p>如果命令执行成功，返回插入操作完成之后，列表的长度。 如果没有找到 pivot ，返回 -1 。 如果 key 不存在或为空列表，返回 0 。</p><h4 id="代码示例-39"><a href="#代码示例-39" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; RPUSH mylist <span class="string">"Hello"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH mylist <span class="string">"World"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; LINSERT mylist BEFORE <span class="string">"World"</span> <span class="string">"There"</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">"Hello"</span></span><br><span class="line">2) <span class="string">"There"</span></span><br><span class="line">3) <span class="string">"World"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对一个非空列表插入，查找一个不存在的 pivot</span></span><br><span class="line">redis&gt; LINSERT mylist BEFORE <span class="string">"go"</span> <span class="string">"let's"</span></span><br><span class="line">(<span class="built_in">integer</span>) -1                                    <span class="comment"># 失败</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对一个空列表执行 LINSERT 命令</span></span><br><span class="line">redis&gt; EXISTS fake_list</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; LINSERT fake_list BEFORE <span class="string">"nono"</span> <span class="string">"gogogog"</span></span><br><span class="line">(<span class="built_in">integer</span>) 0                                      <span class="comment"># 失败</span></span><br></pre></td></tr></table></figure><h3 id="LSET"><a href="#LSET" class="headerlink" title="LSET"></a>LSET</h3><h4 id="LSET-key-index-value"><a href="#LSET-key-index-value" class="headerlink" title="LSET key index value"></a>LSET key index value</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度：对头元素或尾元素进行 LSET 操作，复杂度为 O(1)。其他情况下，为 O(N)， N 为列表的长度。</code></pre><p>将列表 key 下标为 index 的元素的值设置为 value 。</p><p>当 index 参数超出范围，或对一个空列表( key 不存在)进行 LSET 时，返回一个错误。</p><p>关于列表下标的更多信息，请参考 LINDEX key index 命令。</p><h4 id="返回值-42"><a href="#返回值-42" class="headerlink" title="返回值"></a>返回值</h4><p>操作成功返回 ok ，否则返回错误信息。</p><h4 id="代码示例-40"><a href="#代码示例-40" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对空列表(key 不存在)进行 LSET</span></span><br><span class="line">redis&gt; EXISTS list</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; LSET list 0 item</span><br><span class="line">(error) ERR no such key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对非空列表进行 LSET</span></span><br><span class="line">redis&gt; LPUSH job <span class="string">"cook food"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE job 0 0</span><br><span class="line">1) <span class="string">"cook food"</span></span><br><span class="line"></span><br><span class="line">redis&gt; LSET job 0 <span class="string">"play game"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE job  0 0</span><br><span class="line">1) <span class="string">"play game"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># index 超出范围</span></span><br><span class="line">redis&gt; LLEN list                    <span class="comment"># 列表长度为 1</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; LSET list 3 <span class="string">'out of range'</span></span><br><span class="line">(error) ERR index out of range</span><br></pre></td></tr></table></figure><h3 id="LRANGE"><a href="#LRANGE" class="headerlink" title="LRANGE"></a>LRANGE</h3><h4 id="LRANGE-key-start-stop"><a href="#LRANGE-key-start-stop" class="headerlink" title="LRANGE key start stop"></a>LRANGE key start stop</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度: O(S+N)， S 为偏移量 start ， N 为指定区间内元素的数量。</code></pre><p>返回列表 key 中指定区间内的元素，区间以偏移量 start 和 stop 指定。</p><p>下标(index)参数 start 和 stop 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。</p><p>你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</p><p><strong>注意LRANGE命令和编程语言区间函数的区别</strong></p><pre><code>假如你有一个包含一百个元素的列表，对该列表执行 LRANGE list 0 10 ，结果是一个包含11个元素的列表，这表明 stop 下标也在 LRANGE 命令的取值范围之内(闭区间)，这和某些语言的区间函数可能不一致，比如Ruby的 Range.new 、 Array#slice 和Python的 range() 函数。</code></pre><p><strong>超出范围的下标</strong></p><pre><code>超出范围的下标值不会引起错误。</code></pre><p>如果 start 下标比列表的最大下标 end ( LLEN list 减去 1 )还要大，那么 LRANGE 返回一个空列表。</p><p>如果 stop 下标比 end 下标还要大，Redis将 stop 的值设置为 end 。</p><h4 id="返回值-43"><a href="#返回值-43" class="headerlink" title="返回值"></a>返回值</h4><p>一个列表，包含指定区间内的元素。</p><h4 id="代码示例-41"><a href="#代码示例-41" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; RPUSH fp-language lisp</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE fp-language 0 0</span><br><span class="line">1) <span class="string">"lisp"</span></span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH fp-language scheme</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE fp-language 0 1</span><br><span class="line">1) <span class="string">"lisp"</span></span><br><span class="line">2) <span class="string">"scheme"</span></span><br></pre></td></tr></table></figure><h3 id="LTRIM"><a href="#LTRIM" class="headerlink" title="LTRIM"></a>LTRIM</h3><h4 id="LTRIM-key-start-stop"><a href="#LTRIM-key-start-stop" class="headerlink" title="LTRIM key start stop"></a>LTRIM key start stop</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度: O(N)， N 为被移除的元素的数量。</code></pre><p>对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</p><pre><code>举个例子，执行命令 LTRIM list 0 2 ，表示只保留列表 list 的前三个元素，其余元素全部删除。</code></pre><p>下标(index)参数 start 和 stop 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。</p><p>你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</p><p>当 key 不是列表类型时，返回一个错误。</p><p>LTRIM 命令通常和 LPUSH key value [value …] 命令或 RPUSH key value [value …] 命令配合使用，举个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">LPUSH <span class="built_in">log</span> newest_log</span><br><span class="line">LTRIM <span class="built_in">log</span> 0 99</span><br><span class="line">```bash</span><br><span class="line"></span><br><span class="line">这个例子模拟了一个日志程序，每次将最新日志 newest_log 放到 <span class="built_in">log</span> 列表中，并且只保留最新的 100 项。注意当这样使用 LTRIM 命令时，时间复杂度是O(1)，因为平均情况下，每次只有一个元素被移除。</span><br><span class="line"></span><br><span class="line">**注意LTRIM命令和编程语言区间函数的区别**</span><br><span class="line"></span><br><span class="line">    假如你有一个包含一百个元素的列表 list ，对该列表执行 LTRIM list 0 10 ，结果是一个包含11个元素的列表，这表明 stop 下标也在 LTRIM 命令的取值范围之内(闭区间)，这和某些语言的区间函数可能不一致，比如Ruby的 Range.new 、 Array<span class="comment">#slice 和Python的 range() 函数。</span></span><br><span class="line"></span><br><span class="line">**超出范围的下标**</span><br><span class="line"></span><br><span class="line">    超出范围的下标值不会引起错误。</span><br><span class="line"></span><br><span class="line">如果 start 下标比列表的最大下标 end ( LLEN list 减去 1 )还要大，或者 start &gt; stop ， LTRIM 返回一个空列表(因为 LTRIM 已经将整个列表清空)。</span><br><span class="line"></span><br><span class="line">如果 stop 下标比 end 下标还要大，Redis将 stop 的值设置为 end 。</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 返回值</span></span><br><span class="line">命令执行成功时，返回 ok 。</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 代码示例</span></span><br><span class="line">```bash</span><br><span class="line"><span class="comment"># 情况 1： 常见情况， start 和 stop 都在列表的索引范围之内</span></span><br><span class="line">redis&gt; LRANGE alpha 0 -1       <span class="comment"># alpha 是一个包含 5 个字符串的列表</span></span><br><span class="line">1) <span class="string">"h"</span></span><br><span class="line">2) <span class="string">"e"</span></span><br><span class="line">3) <span class="string">"l"</span></span><br><span class="line">4) <span class="string">"l"</span></span><br><span class="line">5) <span class="string">"o"</span></span><br><span class="line"></span><br><span class="line">redis&gt; LTRIM alpha 1 -1        <span class="comment"># 删除 alpha 列表索引为 0 的元素</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE alpha 0 -1       <span class="comment"># "h" 被删除了</span></span><br><span class="line">1) <span class="string">"e"</span></span><br><span class="line">2) <span class="string">"l"</span></span><br><span class="line">3) <span class="string">"l"</span></span><br><span class="line">4) <span class="string">"o"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 情况 2： stop 比列表的最大下标还要大</span></span><br><span class="line">redis&gt; LTRIM alpha 1 10086     <span class="comment"># 保留 alpha 列表索引 1 至索引 10086 上的元素</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE alpha 0 -1       <span class="comment"># 只有索引 0 上的元素 "e" 被删除了，其他元素还在</span></span><br><span class="line">1) <span class="string">"l"</span></span><br><span class="line">2) <span class="string">"l"</span></span><br><span class="line">3) <span class="string">"o"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 情况 3： start 和 stop 都比列表的最大下标要大，并且 start &lt; stop</span></span><br><span class="line">redis&gt; LTRIM alpha 10086 123321</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE alpha 0 -1        <span class="comment"># 列表被清空</span></span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 情况 4： start 和 stop 都比列表的最大下标要大，并且 start &gt; stop</span></span><br><span class="line">redis&gt; RPUSH new-alpha <span class="string">"h"</span> <span class="string">"e"</span> <span class="string">"l"</span> <span class="string">"l"</span> <span class="string">"o"</span>     <span class="comment"># 重新建立一个新列表</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE new-alpha 0 -1</span><br><span class="line">1) <span class="string">"h"</span></span><br><span class="line">2) <span class="string">"e"</span></span><br><span class="line">3) <span class="string">"l"</span></span><br><span class="line">4) <span class="string">"l"</span></span><br><span class="line">5) <span class="string">"o"</span></span><br><span class="line"></span><br><span class="line">redis&gt; LTRIM new-alpha 123321 10086    <span class="comment"># 执行 LTRIM</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE new-alpha 0 -1           <span class="comment"># 同样被清空</span></span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br></pre></td></tr></table></figure><h3 id="BLPOP"><a href="#BLPOP" class="headerlink" title="BLPOP"></a>BLPOP</h3><h4 id="BLPOP-key-key-…-timeout"><a href="#BLPOP-key-key-…-timeout" class="headerlink" title="BLPOP key [key …] timeout"></a>BLPOP key [key …] timeout</h4><pre><code>可用版本： &gt;= 2.0.0时间复杂度： O(1)</code></pre><p>BLPOP 是列表的阻塞式(blocking)弹出原语。</p><p>它是 LPOP key 命令的阻塞版本，当给定列表内没有任何元素可供弹出的时候，连接将被 BLPOP 命令阻塞，直到等待超时或发现可弹出元素为止。</p><p>当给定多个 key 参数时，按参数 key 的先后顺序依次检查各个列表，弹出第一个非空列表的头元素。</p><h4 id="非阻塞行为"><a href="#非阻塞行为" class="headerlink" title="非阻塞行为"></a>非阻塞行为</h4><p>当 BLPOP 被调用时，如果给定 key 内至少有一个非空列表，那么弹出遇到的第一个非空列表的头元素，并和被弹出元素所属的列表的名字一起，组成结果返回给调用者。</p><p>当存在多个给定 key 时， BLPOP 按给定 key 参数排列的先后顺序，依次检查各个列表。</p><p>假设现在有 job 、 command 和 request 三个列表，其中 job 不存在， command 和 request 都持有非空列表。考虑以下命令：</p><p>BLPOP job command request 0</p><p>BLPOP 保证返回的元素来自 command ，因为它是按”查找 job -&gt; 查找 command -&gt; 查找 request “这样的顺序，第一个找到的非空列表。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; DEL job <span class="built_in">command</span> request           <span class="comment"># 确保key都被删除</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; LPUSH <span class="built_in">command</span> <span class="string">"update system..."</span>  <span class="comment"># 为command列表增加一个值</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; LPUSH request <span class="string">"visit page"</span>        <span class="comment"># 为request列表增加一个值</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; BLPOP job <span class="built_in">command</span> request 0       <span class="comment"># job 列表为空，被跳过，紧接着 command 列表的第一个元素被弹出。</span></span><br><span class="line">1) <span class="string">"command"</span>                             <span class="comment"># 弹出元素所属的列表</span></span><br><span class="line">2) <span class="string">"update system..."</span>                    <span class="comment"># 弹出元素所属的值</span></span><br></pre></td></tr></table></figure><h4 id="阻塞行为"><a href="#阻塞行为" class="headerlink" title="阻塞行为"></a>阻塞行为</h4><p>如果所有给定 key 都不存在或包含空列表，那么 BLPOP 命令将阻塞连接，直到等待超时，或有另一个客户端对给定 key 的任意一个执行 LPUSH key value [value …] 或 RPUSH key value [value …] 命令为止。</p><p>超时参数 timeout 接受一个以秒为单位的数字作为值。超时参数设为 0 表示阻塞时间可以无限期延长(block indefinitely) 。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; EXISTS job                <span class="comment"># 确保两个 key 都不存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; EXISTS <span class="built_in">command</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; BLPOP job <span class="built_in">command</span> 300     <span class="comment"># 因为key一开始不存在，所以操作会被阻塞，直到另一客户端对 job 或者 command 列表进行 PUSH 操作。</span></span><br><span class="line">1) <span class="string">"job"</span>                         <span class="comment"># 这里被 push 的是 job</span></span><br><span class="line">2) <span class="string">"do my home work"</span>             <span class="comment"># 被弹出的值</span></span><br><span class="line">(26.26s)                         <span class="comment"># 等待的秒数</span></span><br><span class="line"></span><br><span class="line">redis&gt; BLPOP job <span class="built_in">command</span> 5       <span class="comment"># 等待超时的情况</span></span><br><span class="line">(nil)</span><br><span class="line">(5.66s)                          <span class="comment"># 等待的秒数</span></span><br></pre></td></tr></table></figure></p><p>相同的key被多个客户端同时阻塞</p><pre><code>相同的 key 可以被多个客户端同时阻塞。</code></pre><p>不同的客户端被放进一个队列中，按『先阻塞先服务』(first-BLPOP，first-served)的顺序为 key 执行 BLPOP 命令。</p><h4 id="在MULTI-EXEC事务中的BLPOP"><a href="#在MULTI-EXEC事务中的BLPOP" class="headerlink" title="在MULTI/EXEC事务中的BLPOP"></a>在MULTI/EXEC事务中的BLPOP</h4><p>BLPOP 可以用于流水线(pipline,批量地发送多个命令并读入多个回复)，但把它用在 MULTI / EXEC 块当中没有意义。因为这要求整个服务器被阻塞以保证块执行时的原子性，该行为阻止了其他客户端执行 LPUSH key value [value …] 或 RPUSH key value [value …] 命令。</p><p>因此，一个被包裹在 MULTI / EXEC 块内的 BLPOP 命令，行为表现得就像 LPOP key 一样，对空列表返回 nil ，对非空列表弹出列表元素，不进行任何阻塞操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对非空列表进行操作</span></span><br><span class="line">redis&gt; RPUSH job programming</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; BLPOP job 30</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; EXEC           <span class="comment"># 不阻塞，立即返回</span></span><br><span class="line">1) 1) <span class="string">"job"</span></span><br><span class="line">   2) <span class="string">"programming"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对空列表进行操作</span></span><br><span class="line">redis&gt; LLEN job      <span class="comment"># 空列表</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; BLPOP job 30</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; EXEC         <span class="comment"># 不阻塞，立即返回</span></span><br><span class="line">1) (nil)</span><br></pre></td></tr></table></figure><h4 id="返回值-44"><a href="#返回值-44" class="headerlink" title="返回值"></a>返回值</h4><p>如果列表为空，返回一个 nil 。 否则，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 key ，第二个元素是被弹出元素的值。</p><h4 id="模式：事件提醒"><a href="#模式：事件提醒" class="headerlink" title="模式：事件提醒"></a>模式：事件提醒</h4><p>有时候，为了等待一个新元素到达数据中，需要使用轮询的方式对数据进行探查。</p><p>另一种更好的方式是，使用系统提供的阻塞原语，在新元素到达时立即进行处理，而新元素还没到达时，就一直阻塞住，避免轮询占用资源。</p><p>对于 Redis ，我们似乎需要一个阻塞版的 SPOP key 命令，但实际上，使用 BLPOP 或者 BRPOP key [key …] timeout 就能很好地解决这个问题。</p><p>使用元素的客户端(消费者)可以执行类似以下的代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LOOP forever</span><br><span class="line">    WHILE SPOP(key) returns elements</span><br><span class="line">        ... process elements ...</span><br><span class="line">    END</span><br><span class="line">    BRPOP helper_key</span><br><span class="line">END</span><br></pre></td></tr></table></figure></p><p>添加元素的客户端(生产者)则执行以下代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MULTI</span><br><span class="line">    SADD key element</span><br><span class="line">    LPUSH helper_key x</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure></p><h3 id="BRPOP"><a href="#BRPOP" class="headerlink" title="BRPOP"></a>BRPOP</h3><h4 id="BRPOP-key-key-…-timeout"><a href="#BRPOP-key-key-…-timeout" class="headerlink" title="BRPOP key [key …] timeout"></a>BRPOP key [key …] timeout</h4><pre><code>可用版本： &gt;= 2.0.0时间复杂度： O(1)</code></pre><p>BRPOP 是列表的阻塞式(blocking)弹出原语。</p><p>它是 RPOP key 命令的阻塞版本，当给定列表内没有任何元素可供弹出的时候，连接将被 BRPOP 命令阻塞，直到等待超时或发现可弹出元素为止。</p><p>当给定多个 key 参数时，按参数 key 的先后顺序依次检查各个列表，弹出第一个非空列表的尾部元素。</p><p>关于阻塞操作的更多信息，请查看 BLPOP key [key …] timeout 命令， BRPOP 除了弹出元素的位置和 BLPOP key [key …] timeout 不同之外，其他表现一致。</p><h4 id="返回值-45"><a href="#返回值-45" class="headerlink" title="返回值"></a>返回值</h4><p>假如在指定时间内没有任何元素被弹出，则返回一个 nil 和等待时长。 反之，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 key ，第二个元素是被弹出元素的值。</p><h4 id="代码示例-42"><a href="#代码示例-42" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; LLEN course</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH course algorithm001</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH course c++101</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; BRPOP course 30</span><br><span class="line">1) <span class="string">"course"</span>             <span class="comment"># 被弹出元素所属的列表键</span></span><br><span class="line">2) <span class="string">"c++101"</span>             <span class="comment"># 被弹出的元素</span></span><br></pre></td></tr></table></figure><h3 id="BRPOPLPUSH"><a href="#BRPOPLPUSH" class="headerlink" title="BRPOPLPUSH"></a>BRPOPLPUSH</h3><h4 id="BRPOPLPUSH-source-destination-timeout"><a href="#BRPOPLPUSH-source-destination-timeout" class="headerlink" title="BRPOPLPUSH source destination timeout"></a>BRPOPLPUSH source destination timeout</h4><pre><code>可用版本： &gt;= 2.2.0时间复杂度： O(1)</code></pre><p>BRPOPLPUSH 是 RPOPLPUSH source destination 的阻塞版本，当给定列表 source 不为空时， BRPOPLPUSH 的表现和 RPOPLPUSH source destination 一样。</p><p>当列表 source 为空时， BRPOPLPUSH 命令将阻塞连接，直到等待超时，或有另一个客户端对 source 执行 LPUSH key value [value …] 或 RPUSH key value [value …] 命令为止。</p><p>超时参数 timeout 接受一个以秒为单位的数字作为值。超时参数设为 0 表示阻塞时间可以无限期延长(block indefinitely) 。</p><p>更多相关信息，请参考 RPOPLPUSH source destination 命令。</p><h4 id="返回值-46"><a href="#返回值-46" class="headerlink" title="返回值"></a>返回值</h4><p>假如在指定时间内没有任何元素被弹出，则返回一个 nil 和等待时长。 反之，返回一个含有两个元素的列表，第一个元素是被弹出元素的值，第二个元素是等待时长。</p><h4 id="代码示例-43"><a href="#代码示例-43" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 非空列表</span></span><br><span class="line">redis&gt; BRPOPLPUSH msg reciver 500</span><br><span class="line"><span class="string">"hello moto"</span>                        <span class="comment"># 弹出元素的值</span></span><br><span class="line">(3.38s)                             <span class="comment"># 等待时长</span></span><br><span class="line"></span><br><span class="line">redis&gt; LLEN reciver</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE reciver 0 0</span><br><span class="line">1) <span class="string">"hello moto"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 空列表</span></span><br><span class="line">redis&gt; BRPOPLPUSH msg reciver 1</span><br><span class="line">(nil)</span><br><span class="line">(1.34s)</span><br></pre></td></tr></table></figure><h4 id="模式：安全队列"><a href="#模式：安全队列" class="headerlink" title="模式：安全队列"></a>模式：安全队列</h4><p>参考 RPOPLPUSH source destination 命令的《安全队列》一节。</p><h4 id="模式：循环列表-1"><a href="#模式：循环列表-1" class="headerlink" title="模式：循环列表"></a>模式：循环列表</h4><p>参考 RPOPLPUSH source destination 命令的《循环列表》一节。</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a><a name="集合">集合</a></h2><h3 id="SADD"><a href="#SADD" class="headerlink" title="SADD"></a>SADD</h3><h4 id="SADD-key-member-member-…"><a href="#SADD-key-member-member-…" class="headerlink" title="SADD key member [member …]"></a>SADD key member [member …]</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度: O(N)， N 是被添加的元素的数量。</code></pre><p>将一个或多个 member 元素加入到集合 key 当中，已经存在于集合的 member 元素将被忽略。</p><p>假如 key 不存在，则创建一个只包含 member 元素作成员的集合。</p><p>当 key 不是集合类型时，返回一个错误。</p><h4 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h4><p>在Redis2.4版本以前， SADD 只接受单个 member 值。</p><h4 id="返回值-47"><a href="#返回值-47" class="headerlink" title="返回值"></a>返回值</h4><p>被添加到集合中的新元素的数量，不包括被忽略的元素。</p><h4 id="代码示例-44"><a href="#代码示例-44" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加单个元素</span></span><br><span class="line">redis&gt; SADD bbs <span class="string">"discuz.net"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加重复元素</span></span><br><span class="line">redis&gt; SADD bbs <span class="string">"discuz.net"</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加多个元素</span></span><br><span class="line">redis&gt; SADD bbs <span class="string">"tianya.cn"</span> <span class="string">"groups.google.com"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS bbs</span><br><span class="line">1) <span class="string">"discuz.net"</span></span><br><span class="line">2) <span class="string">"groups.google.com"</span></span><br><span class="line">3) <span class="string">"tianya.cn"</span></span><br></pre></td></tr></table></figure><h3 id="SISMEMBER"><a href="#SISMEMBER" class="headerlink" title="SISMEMBER"></a>SISMEMBER</h3><h4 id="SISMEMBER-key-member"><a href="#SISMEMBER-key-member" class="headerlink" title="SISMEMBER key member"></a>SISMEMBER key member</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度: O(1)</code></pre><p>判断 member 元素是否集合 key 的成员。</p><h4 id="返回值-48"><a href="#返回值-48" class="headerlink" title="返回值"></a>返回值</h4><p>如果 member 元素是集合的成员，返回 1 。 如果 member 元素不是集合的成员，或 key 不存在，返回 0 。</p><h4 id="代码示例-45"><a href="#代码示例-45" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SMEMBERS joe<span class="string">'s_movies</span></span><br><span class="line"><span class="string">1) "hi, lady"</span></span><br><span class="line"><span class="string">2) "Fast Five"</span></span><br><span class="line"><span class="string">3) "2012"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">redis&gt; SISMEMBER joe'</span>s_movies <span class="string">"bet man"</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; SISMEMBER joe<span class="string">'s_movies "Fast Five"</span></span><br><span class="line"><span class="string">(integer) 1</span></span><br></pre></td></tr></table></figure><h3 id="SPOP"><a href="#SPOP" class="headerlink" title="SPOP"></a>SPOP</h3><h4 id="SPOP-key"><a href="#SPOP-key" class="headerlink" title="SPOP key"></a>SPOP key</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度: O(1)</code></pre><p>移除并返回集合中的一个随机元素。</p><p>如果只想获取一个随机元素，但不想该元素从集合中被移除的话，可以使用 SRANDMEMBER key [count] 命令。</p><h4 id="返回值-49"><a href="#返回值-49" class="headerlink" title="返回值"></a>返回值</h4><p>被移除的随机元素。 当 key 不存在或 key 是空集时，返回 nil 。</p><h4 id="代码示例-46"><a href="#代码示例-46" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SMEMBERS db</span><br><span class="line">1) <span class="string">"MySQL"</span></span><br><span class="line">2) <span class="string">"MongoDB"</span></span><br><span class="line">3) <span class="string">"Redis"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SPOP db</span><br><span class="line"><span class="string">"Redis"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS db</span><br><span class="line">1) <span class="string">"MySQL"</span></span><br><span class="line">2) <span class="string">"MongoDB"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SPOP db</span><br><span class="line"><span class="string">"MySQL"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS db</span><br><span class="line">1) <span class="string">"MongoDB"</span></span><br></pre></td></tr></table></figure><h3 id="SRANDMEMBER"><a href="#SRANDMEMBER" class="headerlink" title="SRANDMEMBER"></a>SRANDMEMBER</h3><h4 id="SRANDMEMBER-key-count"><a href="#SRANDMEMBER-key-count" class="headerlink" title="SRANDMEMBER key [count]"></a>SRANDMEMBER key [count]</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度: 只提供 key 参数时为 O(1) 。如果提供了 count 参数，那么为 O(N) ，N 为返回数组的元素个数。</code></pre><p>如果命令执行时，只提供了 key 参数，那么返回集合中的一个随机元素。</p><p>从 Redis 2.6 版本开始， SRANDMEMBER 命令接受可选的 count 参数：</p><p>如果 count 为正数，且小于集合基数，那么命令返回一个包含 count 个元素的数组，数组中的元素各不相同。如果 count 大于等于集合基数，那么返回整个集合。<br>如果 count 为负数，那么命令返回一个数组，数组中的元素可能会重复出现多次，而数组的长度为 count 的绝对值。<br>该操作和 SPOP key 相似，但 SPOP key 将随机元素从集合中移除并返回，而 SRANDMEMBER 则仅仅返回随机元素，而不对集合进行任何改动。</p><h4 id="返回值-50"><a href="#返回值-50" class="headerlink" title="返回值"></a>返回值</h4><p>只提供 key 参数时，返回一个元素；如果集合为空，返回 nil 。 如果提供了 count 参数，那么返回一个数组；如果集合为空，返回空数组。</p><h4 id="代码示例-47"><a href="#代码示例-47" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加元素</span></span><br><span class="line">redis&gt; SADD fruit apple banana cherry</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只给定 key 参数，返回一个随机元素</span></span><br><span class="line">redis&gt; SRANDMEMBER fruit</span><br><span class="line"><span class="string">"cherry"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SRANDMEMBER fruit</span><br><span class="line"><span class="string">"apple"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给定 3 为 count 参数，返回 3 个随机元素</span></span><br><span class="line"><span class="comment"># 每个随机元素都不相同</span></span><br><span class="line">redis&gt; SRANDMEMBER fruit 3</span><br><span class="line">1) <span class="string">"apple"</span></span><br><span class="line">2) <span class="string">"banana"</span></span><br><span class="line">3) <span class="string">"cherry"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给定 -3 为 count 参数，返回 3 个随机元素</span></span><br><span class="line"><span class="comment"># 元素可能会重复出现多次</span></span><br><span class="line">redis&gt; SRANDMEMBER fruit -3</span><br><span class="line">1) <span class="string">"banana"</span></span><br><span class="line">2) <span class="string">"cherry"</span></span><br><span class="line">3) <span class="string">"apple"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SRANDMEMBER fruit -3</span><br><span class="line">1) <span class="string">"apple"</span></span><br><span class="line">2) <span class="string">"apple"</span></span><br><span class="line">3) <span class="string">"cherry"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果 count 是整数，且大于等于集合基数，那么返回整个集合</span></span><br><span class="line">redis&gt; SRANDMEMBER fruit 10</span><br><span class="line">1) <span class="string">"apple"</span></span><br><span class="line">2) <span class="string">"banana"</span></span><br><span class="line">3) <span class="string">"cherry"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果 count 是负数，且 count 的绝对值大于集合的基数</span></span><br><span class="line"><span class="comment"># 那么返回的数组的长度为 count 的绝对值</span></span><br><span class="line">redis&gt; SRANDMEMBER fruit -10</span><br><span class="line">1) <span class="string">"banana"</span></span><br><span class="line">2) <span class="string">"apple"</span></span><br><span class="line">3) <span class="string">"banana"</span></span><br><span class="line">4) <span class="string">"cherry"</span></span><br><span class="line">5) <span class="string">"apple"</span></span><br><span class="line">6) <span class="string">"apple"</span></span><br><span class="line">7) <span class="string">"cherry"</span></span><br><span class="line">8) <span class="string">"apple"</span></span><br><span class="line">9) <span class="string">"apple"</span></span><br><span class="line">10) <span class="string">"banana"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SRANDMEMBER 并不会修改集合内容</span></span><br><span class="line">redis&gt; SMEMBERS fruit</span><br><span class="line">1) <span class="string">"apple"</span></span><br><span class="line">2) <span class="string">"cherry"</span></span><br><span class="line">3) <span class="string">"banana"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 集合为空时返回 nil 或者空数组</span></span><br><span class="line">redis&gt; SRANDMEMBER not-exists</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line">redis&gt; SRANDMEMBER not-eixsts 10</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br></pre></td></tr></table></figure><h3 id="SREM"><a href="#SREM" class="headerlink" title="SREM"></a>SREM</h3><h4 id="SREM-key-member-member-…"><a href="#SREM-key-member-member-…" class="headerlink" title="SREM key member [member …]"></a>SREM key member [member …]</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度: O(N)， N 为给定 member 元素的数量。</code></pre><p>移除集合 key 中的一个或多个 member 元素，不存在的 member 元素会被忽略。</p><p>当 key 不是集合类型，返回一个错误。</p><h4 id="Note-1"><a href="#Note-1" class="headerlink" title="Note"></a>Note</h4><p>在 Redis 2.4 版本以前， SREM 只接受单个 member 值。</p><h4 id="返回值-51"><a href="#返回值-51" class="headerlink" title="返回值"></a>返回值</h4><p>被成功移除的元素的数量，不包括被忽略的元素。</p><h4 id="代码示例-48"><a href="#代码示例-48" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试数据</span></span><br><span class="line">redis&gt; SMEMBERS languages</span><br><span class="line">1) <span class="string">"c"</span></span><br><span class="line">2) <span class="string">"lisp"</span></span><br><span class="line">3) <span class="string">"python"</span></span><br><span class="line">4) <span class="string">"ruby"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除单个元素</span></span><br><span class="line">redis&gt; SREM languages ruby</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除不存在元素</span></span><br><span class="line">redis&gt; SREM languages non-exists-language</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除多个元素</span></span><br><span class="line">redis&gt; SREM languages lisp python c</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS languages</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br></pre></td></tr></table></figure><h3 id="SMOVE"><a href="#SMOVE" class="headerlink" title="SMOVE"></a>SMOVE</h3><h4 id="SMOVE-source-destination-member"><a href="#SMOVE-source-destination-member" class="headerlink" title="SMOVE source destination member"></a>SMOVE source destination member</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度: O(1)</code></pre><p>将 member 元素从 source 集合移动到 destination 集合。</p><p>SMOVE 是原子性操作。</p><p>如果 source 集合不存在或不包含指定的 member 元素，则 SMOVE 命令不执行任何操作，仅返回 0 。否则， member 元素从 source 集合中被移除，并添加到 destination 集合中去。</p><p>当 destination 集合已经包含 member 元素时， SMOVE 命令只是简单地将 source 集合中的 member 元素删除。</p><p>当 source 或 destination 不是集合类型时，返回一个错误。</p><h4 id="返回值-52"><a href="#返回值-52" class="headerlink" title="返回值"></a>返回值</h4><p>如果 member 元素被成功移除，返回 1 。 如果 member 元素不是 source 集合的成员，并且没有任何操作对 destination 集合执行，那么返回 0 。</p><h4 id="代码示例-49"><a href="#代码示例-49" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SMEMBERS songs</span><br><span class="line">1) <span class="string">"Billie Jean"</span></span><br><span class="line">2) <span class="string">"Believe Me"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS my_songs</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line"></span><br><span class="line">redis&gt; SMOVE songs my_songs <span class="string">"Believe Me"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS songs</span><br><span class="line">1) <span class="string">"Billie Jean"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS my_songs</span><br><span class="line">1) <span class="string">"Believe Me"</span></span><br></pre></td></tr></table></figure><h3 id="SCARD"><a href="#SCARD" class="headerlink" title="SCARD"></a>SCARD</h3><h4 id="SCARD-key"><a href="#SCARD-key" class="headerlink" title="SCARD key"></a>SCARD key</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度: O(1)</code></pre><p>返回集合 key 的基数(集合中元素的数量)。</p><h4 id="返回值-53"><a href="#返回值-53" class="headerlink" title="返回值"></a>返回值</h4><p>集合的基数。 当 key 不存在时，返回 0 。</p><h4 id="代码示例-50"><a href="#代码示例-50" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SADD tool pc printer phone</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis&gt; SCARD tool   <span class="comment"># 非空集合</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis&gt; DEL tool</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; SCARD tool   <span class="comment"># 空集合</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><h3 id="SMEMBERS"><a href="#SMEMBERS" class="headerlink" title="SMEMBERS"></a>SMEMBERS</h3><h4 id="SMEMBERS-key"><a href="#SMEMBERS-key" class="headerlink" title="SMEMBERS key"></a>SMEMBERS key</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度: O(N)， N 为集合的基数。</code></pre><p>返回集合 key 中的所有成员。</p><p>不存在的 key 被视为空集合。</p><h4 id="返回值-54"><a href="#返回值-54" class="headerlink" title="返回值"></a>返回值</h4><p>集合中的所有成员。</p><h4 id="代码示例-51"><a href="#代码示例-51" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># key 不存在或集合为空</span></span><br><span class="line">redis&gt; EXISTS not_exists_key</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS not_exists_key</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 非空集合</span></span><br><span class="line">redis&gt; SADD language Ruby Python Clojure</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS language</span><br><span class="line">1) <span class="string">"Python"</span></span><br><span class="line">2) <span class="string">"Ruby"</span></span><br><span class="line">3) <span class="string">"Clojure"</span></span><br></pre></td></tr></table></figure><h3 id="SSCAN"><a href="#SSCAN" class="headerlink" title="SSCAN"></a>SSCAN</h3><h4 id="SSCAN-key-cursor-MATCH-pattern-COUNT-count"><a href="#SSCAN-key-cursor-MATCH-pattern-COUNT-count" class="headerlink" title="SSCAN key cursor [MATCH pattern] [COUNT count]"></a>SSCAN key cursor [MATCH pattern] [COUNT count]</h4><p>详细信息请参考 SCAN cursor [MATCH pattern] [COUNT count] 命令。</p><h3 id="SINTER"><a href="#SINTER" class="headerlink" title="SINTER"></a>SINTER</h3><h4 id="SINTER-key-key-…"><a href="#SINTER-key-key-…" class="headerlink" title="SINTER key [key …]"></a>SINTER key [key …]</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度: O(N * M)， N 为给定集合当中基数最小的集合， M 为给定集合的个数。</code></pre><p>返回一个集合的全部成员，该集合是所有给定集合的交集。</p><p>不存在的 key 被视为空集。</p><p>当给定集合当中有一个空集时，结果也为空集(根据集合运算定律)。</p><h4 id="返回值-55"><a href="#返回值-55" class="headerlink" title="返回值"></a>返回值</h4><p>交集成员的列表。</p><h4 id="代码示例-52"><a href="#代码示例-52" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SMEMBERS group_1</span><br><span class="line">1) <span class="string">"LI LEI"</span></span><br><span class="line">2) <span class="string">"TOM"</span></span><br><span class="line">3) <span class="string">"JACK"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS group_2</span><br><span class="line">1) <span class="string">"HAN MEIMEI"</span></span><br><span class="line">2) <span class="string">"JACK"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SINTER group_1 group_2</span><br><span class="line">1) <span class="string">"JACK"</span></span><br></pre></td></tr></table></figure><h3 id="SINTERSTORE"><a href="#SINTERSTORE" class="headerlink" title="SINTERSTORE"></a>SINTERSTORE</h3><h4 id="SINTERSTORE-destination-key-key-…"><a href="#SINTERSTORE-destination-key-key-…" class="headerlink" title="SINTERSTORE destination key [key …]"></a>SINTERSTORE destination key [key …]</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度: O(N * M)， N 为给定集合当中基数最小的集合， M 为给定集合的个数。</code></pre><p>这个命令类似于 SINTER key [key …] 命令，但它将结果保存到 destination 集合，而不是简单地返回结果集。</p><p>如果 destination 集合已经存在，则将其覆盖。</p><p>destination 可以是 key 本身。</p><h4 id="返回值-56"><a href="#返回值-56" class="headerlink" title="返回值"></a>返回值</h4><p>结果集中的成员数量。</p><h4 id="代码示例-53"><a href="#代码示例-53" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SMEMBERS songs</span><br><span class="line">1) <span class="string">"good bye joe"</span></span><br><span class="line">2) <span class="string">"hello,peter"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS my_songs</span><br><span class="line">1) <span class="string">"good bye joe"</span></span><br><span class="line">2) <span class="string">"falling"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SINTERSTORE song_interset songs my_songs</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS song_interset</span><br><span class="line">1) <span class="string">"good bye joe"</span></span><br></pre></td></tr></table></figure><h3 id="SUNION"><a href="#SUNION" class="headerlink" title="SUNION"></a>SUNION</h3><h4 id="SUNION-key-key-…"><a href="#SUNION-key-key-…" class="headerlink" title="SUNION key [key …]"></a>SUNION key [key …]</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度: O(N)， N 是所有给定集合的成员数量之和。</code></pre><p>返回一个集合的全部成员，该集合是所有给定集合的并集。</p><p>不存在的 key 被视为空集。</p><h4 id="返回值-57"><a href="#返回值-57" class="headerlink" title="返回值"></a>返回值</h4><p>并集成员的列表。</p><h4 id="代码示例-54"><a href="#代码示例-54" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SMEMBERS songs</span><br><span class="line">1) <span class="string">"Billie Jean"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS my_songs</span><br><span class="line">1) <span class="string">"Believe Me"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SUNION songs my_songs</span><br><span class="line">1) <span class="string">"Billie Jean"</span></span><br><span class="line">2) <span class="string">"Believe Me"</span></span><br></pre></td></tr></table></figure><h3 id="SUNIONSTORE"><a href="#SUNIONSTORE" class="headerlink" title="SUNIONSTORE"></a>SUNIONSTORE</h3><h4 id="SUNIONSTORE-destination-key-key-…"><a href="#SUNIONSTORE-destination-key-key-…" class="headerlink" title="SUNIONSTORE destination key [key …]"></a>SUNIONSTORE destination key [key …]</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度: O(N)， N 是所有给定集合的成员数量之和。</code></pre><p>这个命令类似于 SUNION key [key …] 命令，但它将结果保存到 destination 集合，而不是简单地返回结果集。</p><p>如果 destination 已经存在，则将其覆盖。</p><p>destination 可以是 key 本身。</p><h4 id="返回值-58"><a href="#返回值-58" class="headerlink" title="返回值"></a>返回值</h4><p>结果集中的元素数量。</p><h4 id="代码示例-55"><a href="#代码示例-55" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SMEMBERS NoSQL</span><br><span class="line">1) <span class="string">"MongoDB"</span></span><br><span class="line">2) <span class="string">"Redis"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS SQL</span><br><span class="line">1) <span class="string">"sqlite"</span></span><br><span class="line">2) <span class="string">"MySQL"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SUNIONSTORE db NoSQL SQL</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS db</span><br><span class="line">1) <span class="string">"MySQL"</span></span><br><span class="line">2) <span class="string">"sqlite"</span></span><br><span class="line">3) <span class="string">"MongoDB"</span></span><br><span class="line">4) <span class="string">"Redis"</span></span><br></pre></td></tr></table></figure><h3 id="SDIFF"><a href="#SDIFF" class="headerlink" title="SDIFF"></a>SDIFF</h3><h4 id="SDIFF-key-key-…"><a href="#SDIFF-key-key-…" class="headerlink" title="SDIFF key [key …]"></a>SDIFF key [key …]</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度: O(N)， N 是所有给定集合的成员数量之和。</code></pre><p>返回一个集合的全部成员，该集合是所有给定集合之间的差集。</p><p>不存在的 key 被视为空集。</p><h4 id="返回值-59"><a href="#返回值-59" class="headerlink" title="返回值"></a>返回值</h4><p>一个包含差集成员的列表。</p><h4 id="代码示例-56"><a href="#代码示例-56" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SMEMBERS peter<span class="string">'s_movies</span></span><br><span class="line"><span class="string">1) "bet man"</span></span><br><span class="line"><span class="string">2) "start war"</span></span><br><span class="line"><span class="string">3) "2012"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">redis&gt; SMEMBERS joe'</span>s_movies</span><br><span class="line">1) <span class="string">"hi, lady"</span></span><br><span class="line">2) <span class="string">"Fast Five"</span></span><br><span class="line">3) <span class="string">"2012"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SDIFF peter<span class="string">'s_movies joe'</span>s_movies</span><br><span class="line">1) <span class="string">"bet man"</span></span><br><span class="line">2) <span class="string">"start war"</span></span><br></pre></td></tr></table></figure><h3 id="SDIFFSTORE"><a href="#SDIFFSTORE" class="headerlink" title="SDIFFSTORE"></a>SDIFFSTORE</h3><h4 id="SDIFFSTORE-destination-key-key-…"><a href="#SDIFFSTORE-destination-key-key-…" class="headerlink" title="SDIFFSTORE destination key [key …]"></a>SDIFFSTORE destination key [key …]</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度: O(N)， N 是所有给定集合的成员数量之和。</code></pre><p>这个命令的作用和 SDIFF key [key …] 类似，但它将结果保存到 destination 集合，而不是简单地返回结果集。</p><p>如果 destination 集合已经存在，则将其覆盖。</p><p>destination 可以是 key 本身。</p><h4 id="返回值-60"><a href="#返回值-60" class="headerlink" title="返回值"></a>返回值</h4><p>结果集中的元素数量。</p><h4 id="代码示例-57"><a href="#代码示例-57" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SMEMBERS joe<span class="string">'s_movies</span></span><br><span class="line"><span class="string">1) "hi, lady"</span></span><br><span class="line"><span class="string">2) "Fast Five"</span></span><br><span class="line"><span class="string">3) "2012"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">redis&gt; SMEMBERS peter'</span>s_movies</span><br><span class="line">1) <span class="string">"bet man"</span></span><br><span class="line">2) <span class="string">"start war"</span></span><br><span class="line">3) <span class="string">"2012"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SDIFFSTORE joe_diff_peter joe<span class="string">'s_movies peter'</span>s_movies</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS joe_diff_peter</span><br><span class="line">1) <span class="string">"hi, lady"</span></span><br><span class="line">2) <span class="string">"Fast Five"</span></span><br></pre></td></tr></table></figure><h2 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a><a name="有序集合">有序集合</a></h2><h3 id="ZADD"><a href="#ZADD" class="headerlink" title="ZADD"></a>ZADD</h3><h4 id="ZADD-key-score-member-score-member-score-member-…"><a href="#ZADD-key-score-member-score-member-score-member-…" class="headerlink" title="ZADD key score member [[score member] [score member] …]"></a>ZADD key score member [[score member] [score member] …]</h4><pre><code>可用版本： &gt;= 1.2.0时间复杂度: O(M*log(N))， N 是有序集的基数， M 为成功添加的新成员的数量。</code></pre><p>将一个或多个 member 元素及其 score 值加入到有序集 key 当中。</p><p>如果某个 member 已经是有序集的成员，那么更新这个 member 的 score 值，并通过重新插入这个 member 元素，来保证该 member 在正确的位置上。</p><p>score 值可以是整数值或双精度浮点数。</p><p>如果 key 不存在，则创建一个空的有序集并执行 ZADD 操作。</p><p>当 key 存在但不是有序集类型时，返回一个错误。</p><h4 id="Note-2"><a href="#Note-2" class="headerlink" title="Note"></a>Note</h4><p>在 Redis 2.4 版本以前， ZADD 每次只能添加一个元素。</p><h4 id="返回值-61"><a href="#返回值-61" class="headerlink" title="返回值"></a>返回值</h4><p>被成功添加的新成员的数量，不包括那些被更新的、已经存在的成员。</p><h4 id="代码示例-58"><a href="#代码示例-58" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加单个元素</span></span><br><span class="line">redis&gt; ZADD page_rank 10 google.com</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加多个元素</span></span><br><span class="line">redis&gt; ZADD page_rank 9 baidu.com 8 bing.com</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES</span><br><span class="line">1) <span class="string">"bing.com"</span></span><br><span class="line">2) <span class="string">"8"</span></span><br><span class="line">3) <span class="string">"baidu.com"</span></span><br><span class="line">4) <span class="string">"9"</span></span><br><span class="line">5) <span class="string">"google.com"</span></span><br><span class="line">6) <span class="string">"10"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加已存在元素，且 score 值不变</span></span><br><span class="line">redis&gt; ZADD page_rank 10 google.com</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES  <span class="comment"># 没有改变</span></span><br><span class="line">1) <span class="string">"bing.com"</span></span><br><span class="line">2) <span class="string">"8"</span></span><br><span class="line">3) <span class="string">"baidu.com"</span></span><br><span class="line">4) <span class="string">"9"</span></span><br><span class="line">5) <span class="string">"google.com"</span></span><br><span class="line">6) <span class="string">"10"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加已存在元素，但是改变 score 值</span></span><br><span class="line">redis&gt; ZADD page_rank 6 bing.com</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES  <span class="comment"># bing.com 元素的 score 值被改变</span></span><br><span class="line">1) <span class="string">"bing.com"</span></span><br><span class="line">2) <span class="string">"6"</span></span><br><span class="line">3) <span class="string">"baidu.com"</span></span><br><span class="line">4) <span class="string">"9"</span></span><br><span class="line">5) <span class="string">"google.com"</span></span><br><span class="line">6) <span class="string">"10"</span></span><br></pre></td></tr></table></figure><h3 id="ZSCORE"><a href="#ZSCORE" class="headerlink" title="ZSCORE"></a>ZSCORE</h3><h4 id="ZSCORE-key-member"><a href="#ZSCORE-key-member" class="headerlink" title="ZSCORE key member"></a>ZSCORE key member</h4><pre><code>可用版本： &gt;= 1.2.0时间复杂度: O(1)</code></pre><p>返回有序集 key 中，成员 member 的 score 值。</p><p>如果 member 元素不是有序集 key 的成员，或 key 不存在，返回 nil 。</p><h4 id="返回值-62"><a href="#返回值-62" class="headerlink" title="返回值"></a>返回值</h4><p>member 成员的 score 值，以字符串形式表示。</p><h4 id="代码示例-59"><a href="#代码示例-59" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZRANGE salary 0 -1 WITHSCORES    <span class="comment"># 测试数据</span></span><br><span class="line">1) <span class="string">"tom"</span></span><br><span class="line">2) <span class="string">"2000"</span></span><br><span class="line">3) <span class="string">"peter"</span></span><br><span class="line">4) <span class="string">"3500"</span></span><br><span class="line">5) <span class="string">"jack"</span></span><br><span class="line">6) <span class="string">"5000"</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZSCORE salary peter              <span class="comment"># 注意返回值是字符串</span></span><br><span class="line"><span class="string">"3500"</span></span><br></pre></td></tr></table></figure><h3 id="ZINCRBY"><a href="#ZINCRBY" class="headerlink" title="ZINCRBY"></a>ZINCRBY</h3><h4 id="ZINCRBY-key-increment-member"><a href="#ZINCRBY-key-increment-member" class="headerlink" title="ZINCRBY key increment member"></a>ZINCRBY key increment member</h4><pre><code>可用版本： &gt;= 1.2.0时间复杂度: O(log(N))</code></pre><p>为有序集 key 的成员 member 的 score 值加上增量 increment 。</p><p>可以通过传递一个负数值 increment ，让 score 减去相应的值，比如 ZINCRBY key -5 member ，就是让 member 的 score 值减去 5 。</p><p>当 key 不存在，或 member 不是 key 的成员时， ZINCRBY key increment member 等同于 ZADD key increment member 。</p><p>当 key 不是有序集类型时，返回一个错误。</p><p>score 值可以是整数值或双精度浮点数。</p><h4 id="返回值-63"><a href="#返回值-63" class="headerlink" title="返回值"></a>返回值</h4><p>member 成员的新 score 值，以字符串形式表示。</p><h4 id="代码示例-60"><a href="#代码示例-60" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZSCORE salary tom</span><br><span class="line"><span class="string">"2000"</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZINCRBY salary 2000 tom   <span class="comment"># tom 加薪啦！</span></span><br><span class="line"><span class="string">"4000"</span></span><br></pre></td></tr></table></figure><h3 id="ZCARD"><a href="#ZCARD" class="headerlink" title="ZCARD"></a>ZCARD</h3><h4 id="ZCARD-key"><a href="#ZCARD-key" class="headerlink" title="ZCARD key"></a>ZCARD key</h4><pre><code>可用版本： &gt;= 1.2.0时间复杂度: O(1)</code></pre><p>返回有序集 key 的基数。</p><h4 id="返回值-64"><a href="#返回值-64" class="headerlink" title="返回值"></a>返回值</h4><p>当 key 存在且是有序集类型时，返回有序集的基数。 当 key 不存在时，返回 0 。</p><h4 id="代码示例-61"><a href="#代码示例-61" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">redis &gt; ZADD salary 2000 tom    <span class="comment"># 添加一个成员</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis &gt; ZCARD salary</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis &gt; ZADD salary 5000 jack   <span class="comment"># 再添加一个成员</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis &gt; ZCARD salary</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis &gt; EXISTS non_exists_key   <span class="comment"># 对不存在的 key 进行 ZCARD 操作</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis &gt; ZCARD non_exists_key</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><h3 id="ZCOUNT"><a href="#ZCOUNT" class="headerlink" title="ZCOUNT"></a>ZCOUNT</h3><h4 id="ZCOUNT-key-min-max"><a href="#ZCOUNT-key-min-max" class="headerlink" title="ZCOUNT key min max"></a>ZCOUNT key min max</h4><pre><code>可用版本： &gt;= 2.0.0时间复杂度: O(log(N))， N 为有序集的基数。</code></pre><p>返回有序集 key 中， score 值在 min 和 max 之间(默认包括 score 值等于 min 或 max )的成员的数量。</p><p>关于参数 min 和 max 的详细使用方法，请参考 ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] 命令。</p><h4 id="返回值-65"><a href="#返回值-65" class="headerlink" title="返回值"></a>返回值</h4><p>score 值在 min 和 max 之间的成员的数量。</p><h4 id="代码示例-62"><a href="#代码示例-62" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZRANGE salary 0 -1 WITHSCORES    <span class="comment"># 测试数据</span></span><br><span class="line">1) <span class="string">"jack"</span></span><br><span class="line">2) <span class="string">"2000"</span></span><br><span class="line">3) <span class="string">"peter"</span></span><br><span class="line">4) <span class="string">"3500"</span></span><br><span class="line">5) <span class="string">"tom"</span></span><br><span class="line">6) <span class="string">"5000"</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZCOUNT salary 2000 5000          <span class="comment"># 计算薪水在 2000-5000 之间的人数</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis&gt; ZCOUNT salary 3000 5000          <span class="comment"># 计算薪水在 3000-5000 之间的人数</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure><h3 id="ZRANGE"><a href="#ZRANGE" class="headerlink" title="ZRANGE"></a>ZRANGE</h3><h4 id="ZRANGE-key-start-stop-WITHSCORES"><a href="#ZRANGE-key-start-stop-WITHSCORES" class="headerlink" title="ZRANGE key start stop [WITHSCORES]"></a>ZRANGE key start stop [WITHSCORES]</h4><pre><code>可用版本： &gt;= 1.2.0时间复杂度: O(log(N)+M)， N 为有序集的基数，而 M 为结果集的基数。</code></pre><p>返回有序集 key 中，指定区间内的成员。</p><p>其中成员的位置按 score 值递增(从小到大)来排序。</p><p>具有相同 score 值的成员按字典序(lexicographical order )来排列。</p><p>如果你需要成员按 score 值递减(从大到小)来排列，请使用 ZREVRANGE key start stop [WITHSCORES] 命令。</p><p>下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。 你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。</p><p>超出范围的下标并不会引起错误。 比如说，当 start 的值比有序集的最大下标还要大，或是 start &gt; stop 时， ZRANGE 命令只是简单地返回一个空列表。 另一方面，假如 stop 参数的值比有序集的最大下标还要大，那么 Redis 将 stop 当作最大下标来处理。</p><p>可以通过使用 WITHSCORES 选项，来让成员和它的 score 值一并返回，返回列表以 value1,score1, …, valueN,scoreN 的格式表示。 客户端库可能会返回一些更复杂的数据类型，比如数组、元组等。</p><h4 id="返回值-66"><a href="#返回值-66" class="headerlink" title="返回值"></a>返回值</h4><p>指定区间内，带有 score 值(可选)的有序集成员的列表。</p><h4 id="代码示例-63"><a href="#代码示例-63" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">redis &gt; ZRANGE salary 0 -1 WITHSCORES             <span class="comment"># 显示整个有序集成员</span></span><br><span class="line">1) <span class="string">"jack"</span></span><br><span class="line">2) <span class="string">"3500"</span></span><br><span class="line">3) <span class="string">"tom"</span></span><br><span class="line">4) <span class="string">"5000"</span></span><br><span class="line">5) <span class="string">"boss"</span></span><br><span class="line">6) <span class="string">"10086"</span></span><br><span class="line"></span><br><span class="line">redis &gt; ZRANGE salary 1 2 WITHSCORES              <span class="comment"># 显示有序集下标区间 1 至 2 的成员</span></span><br><span class="line">1) <span class="string">"tom"</span></span><br><span class="line">2) <span class="string">"5000"</span></span><br><span class="line">3) <span class="string">"boss"</span></span><br><span class="line">4) <span class="string">"10086"</span></span><br><span class="line"></span><br><span class="line">redis &gt; ZRANGE salary 0 200000 WITHSCORES         <span class="comment"># 测试 end 下标超出最大下标时的情况</span></span><br><span class="line">1) <span class="string">"jack"</span></span><br><span class="line">2) <span class="string">"3500"</span></span><br><span class="line">3) <span class="string">"tom"</span></span><br><span class="line">4) <span class="string">"5000"</span></span><br><span class="line">5) <span class="string">"boss"</span></span><br><span class="line">6) <span class="string">"10086"</span></span><br><span class="line"></span><br><span class="line">redis &gt; ZRANGE salary 200000 3000000 WITHSCORES   <span class="comment"># 测试当给定区间不存在于有序集时的情况</span></span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br></pre></td></tr></table></figure><h3 id="ZREVRANGE"><a href="#ZREVRANGE" class="headerlink" title="ZREVRANGE"></a>ZREVRANGE</h3><h4 id="ZREVRANGE-key-start-stop-WITHSCORES"><a href="#ZREVRANGE-key-start-stop-WITHSCORES" class="headerlink" title="ZREVRANGE key start stop [WITHSCORES]"></a>ZREVRANGE key start stop [WITHSCORES]</h4><pre><code>可用版本： &gt;= 1.2.0时间复杂度: O(log(N)+M)， N 为有序集的基数，而 M 为结果集的基数。</code></pre><p>返回有序集 key 中，指定区间内的成员。</p><p>其中成员的位置按 score 值递减(从大到小)来排列。 具有相同 score 值的成员按字典序的逆序(reverse lexicographical order)排列。</p><p>除了成员按 score 值递减的次序排列这一点外， ZREVRANGE 命令的其他方面和 ZRANGE key start stop [WITHSCORES] 命令一样。</p><h4 id="返回值-67"><a href="#返回值-67" class="headerlink" title="返回值"></a>返回值</h4><p>指定区间内，带有 score 值(可选)的有序集成员的列表。</p><h4 id="代码示例-64"><a href="#代码示例-64" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZRANGE salary 0 -1 WITHSCORES        <span class="comment"># 递增排列</span></span><br><span class="line">1) <span class="string">"peter"</span></span><br><span class="line">2) <span class="string">"3500"</span></span><br><span class="line">3) <span class="string">"tom"</span></span><br><span class="line">4) <span class="string">"4000"</span></span><br><span class="line">5) <span class="string">"jack"</span></span><br><span class="line">6) <span class="string">"5000"</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZREVRANGE salary 0 -1 WITHSCORES     <span class="comment"># 递减排列</span></span><br><span class="line">1) <span class="string">"jack"</span></span><br><span class="line">2) <span class="string">"5000"</span></span><br><span class="line">3) <span class="string">"tom"</span></span><br><span class="line">4) <span class="string">"4000"</span></span><br><span class="line">5) <span class="string">"peter"</span></span><br><span class="line">6) <span class="string">"3500"</span></span><br></pre></td></tr></table></figure><h3 id="ZRANGEBYSCORE"><a href="#ZRANGEBYSCORE" class="headerlink" title="ZRANGEBYSCORE"></a>ZRANGEBYSCORE</h3><h4 id="ZRANGEBYSCORE-key-min-max-WITHSCORES-LIMIT-offset-count"><a href="#ZRANGEBYSCORE-key-min-max-WITHSCORES-LIMIT-offset-count" class="headerlink" title="ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]"></a>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</h4><pre><code>可用版本： &gt;= 1.0.5时间复杂度: O(log(N)+M)， N 为有序集的基数， M 为被结果集的基数。</code></pre><p>返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。</p><p>具有相同 score 值的成员按字典序(lexicographical order)来排列(该属性是有序集提供的，不需要额外的计算)。</p><p>可选的 LIMIT 参数指定返回结果的数量及区间(就像SQL中的 SELECT LIMIT offset, count )，注意当 offset 很大时，定位 offset 的操作可能需要遍历整个有序集，此过程最坏复杂度为 O(N) 时间。</p><p>可选的 WITHSCORES 参数决定结果集是单单返回有序集的成员，还是将有序集成员及其 score 值一起返回。 该选项自 Redis 2.0 版本起可用。</p><h4 id="区间及无限"><a href="#区间及无限" class="headerlink" title="区间及无限"></a>区间及无限</h4><p>min 和 max 可以是 -inf 和 +inf ，这样一来，你就可以在不知道有序集的最低和最高 score 值的情况下，使用 ZRANGEBYSCORE 这类命令。</p><p>默认情况下，区间的取值使用闭区间 (小于等于或大于等于)，你也可以通过给参数前增加 ( 符号来使用可选的开区间 (小于或大于)。</p><h4 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a>举个例子：</h4><p>ZRANGEBYSCORE zset (1 5<br>返回所有符合条件 1 &lt; score &lt;= 5 的成员，而</p><p>ZRANGEBYSCORE zset (5 (10<br>则返回所有符合条件 5 &lt; score &lt; 10 的成员。</p><h4 id="返回值-68"><a href="#返回值-68" class="headerlink" title="返回值"></a>返回值</h4><p>指定区间内，带有 score 值(可选)的有序集成员的列表。</p><h4 id="代码示例-65"><a href="#代码示例-65" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD salary 2500 jack                        <span class="comment"># 测试数据</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; ZADD salary 5000 tom</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; ZADD salary 12000 peter</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGEBYSCORE salary -inf +inf               <span class="comment"># 显示整个有序集</span></span><br><span class="line">1) <span class="string">"jack"</span></span><br><span class="line">2) <span class="string">"tom"</span></span><br><span class="line">3) <span class="string">"peter"</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGEBYSCORE salary -inf +inf WITHSCORES    <span class="comment"># 显示整个有序集及成员的 score 值</span></span><br><span class="line">1) <span class="string">"jack"</span></span><br><span class="line">2) <span class="string">"2500"</span></span><br><span class="line">3) <span class="string">"tom"</span></span><br><span class="line">4) <span class="string">"5000"</span></span><br><span class="line">5) <span class="string">"peter"</span></span><br><span class="line">6) <span class="string">"12000"</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGEBYSCORE salary -inf 5000 WITHSCORES    <span class="comment"># 显示工资 &lt;=5000 的所有成员</span></span><br><span class="line">1) <span class="string">"jack"</span></span><br><span class="line">2) <span class="string">"2500"</span></span><br><span class="line">3) <span class="string">"tom"</span></span><br><span class="line">4) <span class="string">"5000"</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGEBYSCORE salary (5000 400000            <span class="comment"># 显示工资大于 5000 小于等于 400000 的成员</span></span><br><span class="line">1) <span class="string">"peter"</span></span><br></pre></td></tr></table></figure><h3 id="ZREVRANGEBYSCORE"><a href="#ZREVRANGEBYSCORE" class="headerlink" title="ZREVRANGEBYSCORE"></a>ZREVRANGEBYSCORE</h3><h4 id="ZREVRANGEBYSCORE-key-max-min-WITHSCORES-LIMIT-offset-count"><a href="#ZREVRANGEBYSCORE-key-max-min-WITHSCORES-LIMIT-offset-count" class="headerlink" title="ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]"></a>ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</h4><pre><code>可用版本： &gt;= 2.2.0时间复杂度: O(log(N)+M)， N 为有序集的基数， M 为结果集的基数。</code></pre><p>返回有序集 key 中， score 值介于 max 和 min 之间(默认包括等于 max 或 min )的所有的成员。有序集成员按 score 值递减(从大到小)的次序排列。</p><p>具有相同 score 值的成员按字典序的逆序(reverse lexicographical order )排列。</p><p>除了成员按 score 值递减的次序排列这一点外， ZREVRANGEBYSCORE 命令的其他方面和 ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] 命令一样。</p><h4 id="返回值-69"><a href="#返回值-69" class="headerlink" title="返回值"></a>返回值</h4><p>指定区间内，带有 score 值(可选)的有序集成员的列表。</p><h4 id="代码示例-66"><a href="#代码示例-66" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">redis &gt; ZADD salary 10086 jack</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis &gt; ZADD salary 5000 tom</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis &gt; ZADD salary 7500 peter</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis &gt; ZADD salary 3500 joe</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis &gt; ZREVRANGEBYSCORE salary +inf -inf   <span class="comment"># 逆序排列所有成员</span></span><br><span class="line">1) <span class="string">"jack"</span></span><br><span class="line">2) <span class="string">"peter"</span></span><br><span class="line">3) <span class="string">"tom"</span></span><br><span class="line">4) <span class="string">"joe"</span></span><br><span class="line"></span><br><span class="line">redis &gt; ZREVRANGEBYSCORE salary 10000 2000  <span class="comment"># 逆序排列薪水介于 10000 和 2000 之间的成员</span></span><br><span class="line">1) <span class="string">"peter"</span></span><br><span class="line">2) <span class="string">"tom"</span></span><br><span class="line">3) <span class="string">"joe"</span></span><br></pre></td></tr></table></figure><h3 id="ZRANK"><a href="#ZRANK" class="headerlink" title="ZRANK"></a>ZRANK</h3><h4 id="ZRANK-key-member"><a href="#ZRANK-key-member" class="headerlink" title="ZRANK key member"></a>ZRANK key member</h4><pre><code>可用版本： &gt;= 2.0.0时间复杂度: O(log(N))</code></pre><p>返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递增(从小到大)顺序排列。</p><p>排名以 0 为底，也就是说， score 值最小的成员排名为 0 。</p><p>使用 ZREVRANK key member 命令可以获得成员按 score 值递减(从大到小)排列的排名。</p><h4 id="返回值-70"><a href="#返回值-70" class="headerlink" title="返回值"></a>返回值</h4><p>如果 member 是有序集 key 的成员，返回 member 的排名。 如果 member 不是有序集 key 的成员，返回 nil 。</p><h4 id="代码示例-67"><a href="#代码示例-67" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZRANGE salary 0 -1 WITHSCORES        <span class="comment"># 显示所有成员及其 score 值</span></span><br><span class="line">1) <span class="string">"peter"</span></span><br><span class="line">2) <span class="string">"3500"</span></span><br><span class="line">3) <span class="string">"tom"</span></span><br><span class="line">4) <span class="string">"4000"</span></span><br><span class="line">5) <span class="string">"jack"</span></span><br><span class="line">6) <span class="string">"5000"</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZRANK salary tom                     <span class="comment"># 显示 tom 的薪水排名，第二</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><h3 id="ZREVRANK"><a href="#ZREVRANK" class="headerlink" title="ZREVRANK"></a>ZREVRANK</h3><h4 id="ZREVRANK-key-member"><a href="#ZREVRANK-key-member" class="headerlink" title="ZREVRANK key member"></a>ZREVRANK key member</h4><pre><code>可用版本： &gt;= 2.0.0时间复杂度: O(log(N))</code></pre><p>返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递减(从大到小)排序。</p><p>排名以 0 为底，也就是说， score 值最大的成员排名为 0 。</p><p>使用 ZRANK key member 命令可以获得成员按 score 值递增(从小到大)排列的排名。</p><h4 id="返回值-71"><a href="#返回值-71" class="headerlink" title="返回值"></a>返回值</h4><p>如果 member 是有序集 key 的成员，返回 member 的排名。 如果 member 不是有序集 key 的成员，返回 nil 。</p><h4 id="代码示例-68"><a href="#代码示例-68" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; ZRANGE salary 0 -1 WITHSCORES     <span class="comment"># 测试数据</span></span><br><span class="line">1) <span class="string">"jack"</span></span><br><span class="line">2) <span class="string">"2000"</span></span><br><span class="line">3) <span class="string">"peter"</span></span><br><span class="line">4) <span class="string">"3500"</span></span><br><span class="line">5) <span class="string">"tom"</span></span><br><span class="line">6) <span class="string">"5000"</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZREVRANK salary peter     <span class="comment"># peter 的工资排第二</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; ZREVRANK salary tom       <span class="comment"># tom 的工资最高</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><h3 id="ZREM"><a href="#ZREM" class="headerlink" title="ZREM"></a>ZREM</h3><h4 id="ZREM-key-member-member-…"><a href="#ZREM-key-member-member-…" class="headerlink" title="ZREM key member [member …]"></a>ZREM key member [member …]</h4><pre><code>可用版本： &gt;= 1.2.0时间复杂度: O(M*log(N))， N 为有序集的基数， M 为被成功移除的成员的数量。</code></pre><p>移除有序集 key 中的一个或多个成员，不存在的成员将被忽略。</p><p>当 key 存在但不是有序集类型时，返回一个错误。</p><h4 id="Note-3"><a href="#Note-3" class="headerlink" title="Note"></a>Note</h4><p>在 Redis 2.4 版本以前， ZREM 每次只能删除一个元素。</p><h4 id="返回值-72"><a href="#返回值-72" class="headerlink" title="返回值"></a>返回值</h4><p>被成功移除的成员的数量，不包括被忽略的成员。</p><h4 id="代码示例-69"><a href="#代码示例-69" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试数据</span></span><br><span class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES</span><br><span class="line">1) <span class="string">"bing.com"</span></span><br><span class="line">2) <span class="string">"8"</span></span><br><span class="line">3) <span class="string">"baidu.com"</span></span><br><span class="line">4) <span class="string">"9"</span></span><br><span class="line">5) <span class="string">"google.com"</span></span><br><span class="line">6) <span class="string">"10"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除单个元素</span></span><br><span class="line">redis&gt; ZREM page_rank google.com</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES</span><br><span class="line">1) <span class="string">"bing.com"</span></span><br><span class="line">2) <span class="string">"8"</span></span><br><span class="line">3) <span class="string">"baidu.com"</span></span><br><span class="line">4) <span class="string">"9"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除多个元素</span></span><br><span class="line">redis&gt; ZREM page_rank baidu.com bing.com</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除不存在元素</span></span><br><span class="line">redis&gt; ZREM page_rank non-exists-element</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><h3 id="ZREMRANGEBYRANK"><a href="#ZREMRANGEBYRANK" class="headerlink" title="ZREMRANGEBYRANK"></a>ZREMRANGEBYRANK</h3><h4 id="ZREMRANGEBYRANK-key-start-stop"><a href="#ZREMRANGEBYRANK-key-start-stop" class="headerlink" title="ZREMRANGEBYRANK key start stop"></a>ZREMRANGEBYRANK key start stop</h4><pre><code>可用版本： &gt;= 2.0.0时间复杂度: O(log(N)+M)， N 为有序集的基数，而 M 为被移除成员的数量。</code></pre><p>移除有序集 key 中，指定排名(rank)区间内的所有成员。</p><p>区间分别以下标参数 start 和 stop 指出，包含 start 和 stop 在内。</p><p>下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。 你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。</p><h4 id="返回值-73"><a href="#返回值-73" class="headerlink" title="返回值"></a>返回值</h4><p>被移除成员的数量。</p><h4 id="代码示例-70"><a href="#代码示例-70" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD salary 2000 jack</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZADD salary 5000 tom</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZADD salary 3500 peter</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; ZREMRANGEBYRANK salary 0 1       <span class="comment"># 移除下标 0 至 1 区间内的成员</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE salary 0 -1 WITHSCORES    <span class="comment"># 有序集只剩下一个成员</span></span><br><span class="line">1) <span class="string">"tom"</span></span><br><span class="line">2) <span class="string">"5000"</span></span><br></pre></td></tr></table></figure><h3 id="ZREMRANGEBYSCORE"><a href="#ZREMRANGEBYSCORE" class="headerlink" title="ZREMRANGEBYSCORE"></a>ZREMRANGEBYSCORE</h3><h4 id="ZREMRANGEBYSCORE-key-min-max"><a href="#ZREMRANGEBYSCORE-key-min-max" class="headerlink" title="ZREMRANGEBYSCORE key min max"></a>ZREMRANGEBYSCORE key min max</h4><pre><code>可用版本： &gt;= 1.2.0时间复杂度： O(log(N)+M)， N 为有序集的基数，而 M 为被移除成员的数量。</code></pre><p>移除有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。</p><p>自版本2.1.6开始， score 值等于 min 或 max 的成员也可以不包括在内，详情请参见 ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] 命令。</p><h4 id="返回值-74"><a href="#返回值-74" class="headerlink" title="返回值"></a>返回值</h4><p>被移除成员的数量。</p><h4 id="代码示例-71"><a href="#代码示例-71" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZRANGE salary 0 -1 WITHSCORES          <span class="comment"># 显示有序集内所有成员及其 score 值</span></span><br><span class="line">1) <span class="string">"tom"</span></span><br><span class="line">2) <span class="string">"2000"</span></span><br><span class="line">3) <span class="string">"peter"</span></span><br><span class="line">4) <span class="string">"3500"</span></span><br><span class="line">5) <span class="string">"jack"</span></span><br><span class="line">6) <span class="string">"5000"</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZREMRANGEBYSCORE salary 1500 3500      <span class="comment"># 移除所有薪水在 1500 到 3500 内的员工</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE salary 0 -1 WITHSCORES          <span class="comment"># 剩下的有序集成员</span></span><br><span class="line">1) <span class="string">"jack"</span></span><br><span class="line">2) <span class="string">"5000"</span></span><br></pre></td></tr></table></figure><h3 id="ZRANGEBYLEX"><a href="#ZRANGEBYLEX" class="headerlink" title="ZRANGEBYLEX"></a>ZRANGEBYLEX</h3><h4 id="ZRANGEBYLEX-key-min-max-LIMIT-offset-count"><a href="#ZRANGEBYLEX-key-min-max-LIMIT-offset-count" class="headerlink" title="ZRANGEBYLEX key min max [LIMIT offset count]"></a>ZRANGEBYLEX key min max [LIMIT offset count]</h4><pre><code>可用版本： &gt;= 2.8.9时间复杂度：O(log(N)+M)， 其中 N 为有序集合的元素数量， 而 M 则是命令返回的元素数量。 如果 M 是一个常数（比如说，用户总是使用 LIMIT 参数来返回最先的 10 个元素）， 那么命令的复杂度也可以看作是 O(log(N)) 。</code></pre><p>当有序集合的所有成员都具有相同的分值时， 有序集合的元素会根据成员的字典序（lexicographical ordering）来进行排序， 而这个命令则可以返回给定的有序集合键 key 中， 值介于 min 和 max 之间的成员。</p><p>如果有序集合里面的成员带有不同的分值， 那么命令返回的结果是未指定的（unspecified）。</p><p>命令会使用 C 语言的 memcmp() 函数， 对集合中的每个成员进行逐个字节的对比（byte-by-byte compare）， 并按照从低到高的顺序， 返回排序后的集合成员。 如果两个字符串有一部分内容是相同的话， 那么命令会认为较长的字符串比较短的字符串要大。</p><p>可选的 LIMIT offset count 参数用于获取指定范围内的匹配元素 （就像 SQL 中的 SELECT LIMIT offset count 语句）。 需要注意的一点是， 如果 offset 参数的值非常大的话， 那么命令在返回结果之前， 需要先遍历至 offset 所指定的位置， 这个操作会为命令加上最多 O(N) 复杂度。</p><h4 id="如何指定范围区间"><a href="#如何指定范围区间" class="headerlink" title="如何指定范围区间"></a>如何指定范围区间</h4><p>合法的 min 和 max 参数必须包含 ( 或者 [ ， 其中 ( 表示开区间（指定的值不会被包含在范围之内）， 而 [ 则表示闭区间（指定的值会被包含在范围之内）。</p><p>特殊值 + 和 - 在 min 参数以及 max 参数中具有特殊的意义， 其中 + 表示正无限， 而 - 表示负无限。 因此， 向一个所有成员的分值都相同的有序集合发送命令 ZRANGEBYLEX \&lt;zset> - + ， 命令将返回有序集合中的所有元素。</p><h4 id="返回值-75"><a href="#返回值-75" class="headerlink" title="返回值"></a>返回值</h4><p>数组回复：一个列表，列表里面包含了有序集合在指定范围内的成员。</p><h4 id="代码示例-72"><a href="#代码示例-72" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD myzset 0 a 0 b 0 c 0 d 0 e 0 f 0 g</span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGEBYLEX myzset - [c</span><br><span class="line">1) <span class="string">"a"</span></span><br><span class="line">2) <span class="string">"b"</span></span><br><span class="line">3) <span class="string">"c"</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGEBYLEX myzset - (c</span><br><span class="line">1) <span class="string">"a"</span></span><br><span class="line">2) <span class="string">"b"</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGEBYLEX myzset [aaa (g</span><br><span class="line">1) <span class="string">"b"</span></span><br><span class="line">2) <span class="string">"c"</span></span><br><span class="line">3) <span class="string">"d"</span></span><br><span class="line">4) <span class="string">"e"</span></span><br><span class="line">5) <span class="string">"f"</span></span><br></pre></td></tr></table></figure><h3 id="ZLEXCOUNT"><a href="#ZLEXCOUNT" class="headerlink" title="ZLEXCOUNT"></a>ZLEXCOUNT</h3><h4 id="ZLEXCOUNT-key-min-max"><a href="#ZLEXCOUNT-key-min-max" class="headerlink" title="ZLEXCOUNT key min max"></a>ZLEXCOUNT key min max</h4><pre><code>可用版本： &gt;= 2.8.9时间复杂度： O(log(N))，其中 N 为有序集合包含的元素数量。</code></pre><p>对于一个所有成员的分值都相同的有序集合键 key 来说， 这个命令会返回该集合中， 成员介于 min 和 max 范围内的元素数量。</p><p>这个命令的 min 参数和 max 参数的意义和 ZRANGEBYLEX key min max [LIMIT offset count] 命令的 min 参数和 max 参数的意义一样。</p><h4 id="返回值-76"><a href="#返回值-76" class="headerlink" title="返回值"></a>返回值</h4><p>整数回复：指定范围内的元素数量。</p><h4 id="代码示例-73"><a href="#代码示例-73" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD myzset 0 a 0 b 0 c 0 d 0 e</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line"></span><br><span class="line">redis&gt; ZADD myzset 0 f 0 g</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; ZLEXCOUNT myzset - +</span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line"></span><br><span class="line">redis&gt; ZLEXCOUNT myzset [b [f</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br></pre></td></tr></table></figure><h3 id="ZREMRANGEBYLEX"><a href="#ZREMRANGEBYLEX" class="headerlink" title="ZREMRANGEBYLEX"></a>ZREMRANGEBYLEX</h3><h4 id="ZREMRANGEBYLEX-key-min-max"><a href="#ZREMRANGEBYLEX-key-min-max" class="headerlink" title="ZREMRANGEBYLEX key min max"></a>ZREMRANGEBYLEX key min max</h4><pre><code>可用版本： &gt;= 2.8.9时间复杂度： O(log(N)+M)， 其中 N 为有序集合的元素数量， 而 M 则为被移除的元素数量。</code></pre><p>对于一个所有成员的分值都相同的有序集合键 key 来说， 这个命令会移除该集合中， 成员介于 min 和 max 范围内的所有元素。</p><p>这个命令的 min 参数和 max 参数的意义和 ZRANGEBYLEX key min max [LIMIT offset count] 命令的 min 参数和 max 参数的意义一样。</p><h4 id="返回值-77"><a href="#返回值-77" class="headerlink" title="返回值"></a>返回值</h4><p>整数回复：被移除的元素数量。</p><h4 id="代码示例-74"><a href="#代码示例-74" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD myzset 0 aaaa 0 b 0 c 0 d 0 e</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line"></span><br><span class="line">redis&gt; ZADD myzset 0 foo 0 zap 0 zip 0 ALPHA 0 alpha</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE myzset 0 -1</span><br><span class="line">1) <span class="string">"ALPHA"</span></span><br><span class="line">2) <span class="string">"aaaa"</span></span><br><span class="line">3) <span class="string">"alpha"</span></span><br><span class="line">4) <span class="string">"b"</span></span><br><span class="line">5) <span class="string">"c"</span></span><br><span class="line">6) <span class="string">"d"</span></span><br><span class="line">7) <span class="string">"e"</span></span><br><span class="line">8) <span class="string">"foo"</span></span><br><span class="line">9) <span class="string">"zap"</span></span><br><span class="line">10) <span class="string">"zip"</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZREMRANGEBYLEX myzset [alpha [omega</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE myzset 0 -1</span><br><span class="line">1) <span class="string">"ALPHA"</span></span><br><span class="line">2) <span class="string">"aaaa"</span></span><br><span class="line">3) <span class="string">"zap"</span></span><br><span class="line">4) <span class="string">"zip"</span></span><br></pre></td></tr></table></figure><h3 id="ZSCAN"><a href="#ZSCAN" class="headerlink" title="ZSCAN"></a>ZSCAN</h3><h4 id="ZSCAN-key-cursor-MATCH-pattern-COUNT-count"><a href="#ZSCAN-key-cursor-MATCH-pattern-COUNT-count" class="headerlink" title="ZSCAN key cursor [MATCH pattern] [COUNT count]"></a>ZSCAN key cursor [MATCH pattern] [COUNT count]</h4><p>详细信息请参考 SCAN cursor [MATCH pattern] [COUNT count] 命令。</p><h3 id="ZUNIONSTORE"><a href="#ZUNIONSTORE" class="headerlink" title="ZUNIONSTORE"></a>ZUNIONSTORE</h3><h4 id="ZUNIONSTORE-destination-numkeys-key-key-…-WEIGHTS-weight-weight-…-AGGREGATE-SUM-MIN-MAX"><a href="#ZUNIONSTORE-destination-numkeys-key-key-…-WEIGHTS-weight-weight-…-AGGREGATE-SUM-MIN-MAX" class="headerlink" title="ZUNIONSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX]"></a>ZUNIONSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX]</h4><pre><code>可用版本：&gt;= 2.0.0时间复杂度: O(N)+O(M log(M))， N 为给定有序集基数的总和， M 为结果集的基数。</code></pre><p>计算给定的一个或多个有序集的并集，其中给定 key 的数量必须以 numkeys 参数指定，并将该并集(结果集)储存到 destination 。</p><p>默认情况下，结果集中某个成员的 score 值是所有给定集下该成员 score 值之 和 。</p><h4 id="WEIGHTS"><a href="#WEIGHTS" class="headerlink" title="WEIGHTS"></a>WEIGHTS</h4><p>使用 WEIGHTS 选项，你可以为 每个 给定有序集 分别 指定一个乘法因子(multiplication factor)，每个给定有序集的所有成员的 score 值在传递给聚合函数(aggregation function)之前都要先乘以该有序集的因子。</p><p>如果没有指定 WEIGHTS 选项，乘法因子默认设置为 1 。</p><h4 id="AGGREGATE"><a href="#AGGREGATE" class="headerlink" title="AGGREGATE"></a>AGGREGATE</h4><p>使用 AGGREGATE 选项，你可以指定并集的结果集的聚合方式。</p><p>默认使用的参数 SUM ，可以将所有集合中某个成员的 score 值之 和 作为结果集中该成员的 score 值；使用参数 MIN ，可以将所有集合中某个成员的 最小 score 值作为结果集中该成员的 score 值；而参数 MAX 则是将所有集合中某个成员的 最大 score 值作为结果集中该成员的 score 值。</p><h4 id="返回值-78"><a href="#返回值-78" class="headerlink" title="返回值"></a>返回值</h4><p>保存到 destination 的结果集的基数。</p><h4 id="代码示例-75"><a href="#代码示例-75" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZRANGE programmer 0 -1 WITHSCORES</span><br><span class="line">1) <span class="string">"peter"</span></span><br><span class="line">2) <span class="string">"2000"</span></span><br><span class="line">3) <span class="string">"jack"</span></span><br><span class="line">4) <span class="string">"3500"</span></span><br><span class="line">5) <span class="string">"tom"</span></span><br><span class="line">6) <span class="string">"5000"</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE manager 0 -1 WITHSCORES</span><br><span class="line">1) <span class="string">"herry"</span></span><br><span class="line">2) <span class="string">"2000"</span></span><br><span class="line">3) <span class="string">"mary"</span></span><br><span class="line">4) <span class="string">"3500"</span></span><br><span class="line">5) <span class="string">"bob"</span></span><br><span class="line">6) <span class="string">"4000"</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZUNIONSTORE salary 2 programmer manager WEIGHTS 1 3   <span class="comment"># 公司决定加薪。。。除了程序员。。。</span></span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE salary 0 -1 WITHSCORES</span><br><span class="line">1) <span class="string">"peter"</span></span><br><span class="line">2) <span class="string">"2000"</span></span><br><span class="line">3) <span class="string">"jack"</span></span><br><span class="line">4) <span class="string">"3500"</span></span><br><span class="line">5) <span class="string">"tom"</span></span><br><span class="line">6) <span class="string">"5000"</span></span><br><span class="line">7) <span class="string">"herry"</span></span><br><span class="line">8) <span class="string">"6000"</span></span><br><span class="line">9) <span class="string">"mary"</span></span><br><span class="line">10) <span class="string">"10500"</span></span><br><span class="line">11) <span class="string">"bob"</span></span><br><span class="line">12) <span class="string">"12000"</span></span><br></pre></td></tr></table></figure><h3 id="ZINTERSTORE"><a href="#ZINTERSTORE" class="headerlink" title="ZINTERSTORE"></a>ZINTERSTORE</h3><h4 id="ZINTERSTORE-destination-numkeys-key-key-…-WEIGHTS-weight-weight-…-AGGREGATE-SUM-MIN-MAX"><a href="#ZINTERSTORE-destination-numkeys-key-key-…-WEIGHTS-weight-weight-…-AGGREGATE-SUM-MIN-MAX" class="headerlink" title="ZINTERSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX]"></a>ZINTERSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX]</h4><pre><code>可用版本： &gt;= 2.0.0时间复杂度: O(N*K)+O(M*log(M))， N 为给定 key 中基数最小的有序集， K 为给定有序集的数量， M 为结果集的基数。</code></pre><p>计算给定的一个或多个有序集的交集，其中给定 key 的数量必须以 numkeys 参数指定，并将该交集(结果集)储存到 destination 。</p><p>默认情况下，结果集中某个成员的 score 值是所有给定集下该成员 score 值之和.</p><p>关于 WEIGHTS 和 AGGREGATE 选项的描述，参见 ZUNIONSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX] 命令。</p><h4 id="返回值-79"><a href="#返回值-79" class="headerlink" title="返回值"></a>返回值</h4><p>保存到 destination 的结果集的基数。</p><h4 id="代码示例-76"><a href="#代码示例-76" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">redis &gt; ZADD mid_test 70 <span class="string">"Li Lei"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis &gt; ZADD mid_test 70 <span class="string">"Han Meimei"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis &gt; ZADD mid_test 99.5 <span class="string">"Tom"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis &gt; ZADD fin_test 88 <span class="string">"Li Lei"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis &gt; ZADD fin_test 75 <span class="string">"Han Meimei"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis &gt; ZADD fin_test 99.5 <span class="string">"Tom"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis &gt; ZINTERSTORE sum_point 2 mid_test fin_test</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis &gt; ZRANGE sum_point 0 -1 WITHSCORES     <span class="comment"># 显示有序集内所有成员及其 score 值</span></span><br><span class="line">1) <span class="string">"Han Meimei"</span></span><br><span class="line">2) <span class="string">"145"</span></span><br><span class="line">3) <span class="string">"Li Lei"</span></span><br><span class="line">4) <span class="string">"158"</span></span><br><span class="line">5) <span class="string">"Tom"</span></span><br><span class="line">6) <span class="string">"199"</span></span><br></pre></td></tr></table></figure><h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><h3 id="PFADD"><a href="#PFADD" class="headerlink" title="PFADD"></a>PFADD</h3><h4 id="PFADD-key-element-element-…"><a href="#PFADD-key-element-element-…" class="headerlink" title="PFADD key element [element …]"></a>PFADD key element [element …]</h4><pre><code>可用版本： &gt;= 2.8.9时间复杂度： 每添加一个元素的复杂度为 O(1) 。</code></pre><p>将任意数量的元素添加到指定的 HyperLogLog 里面。</p><p>作为这个命令的副作用， HyperLogLog 内部可能会被更新， 以便反映一个不同的唯一元素估计数量（也即是集合的基数）。</p><p>如果 HyperLogLog 估计的近似基数（approximated cardinality）在命令执行之后出现了变化， 那么命令返回 1 ， 否则返回 0 。 如果命令执行时给定的键不存在， 那么程序将先创建一个空的 HyperLogLog 结构， 然后再执行命令。</p><p>调用 PFADD key element [element …] 命令时可以只给定键名而不给定元素：</p><p>如果给定键已经是一个 HyperLogLog ， 那么这种调用不会产生任何效果；<br>但如果给定的键不存在， 那么命令会创建一个空的 HyperLogLog ， 并向客户端返回 1 。<br>要了解更多关于 HyperLogLog 数据结构的介绍知识， 请查阅 PFCOUNT key [key …] 命令的文档。</p><h4 id="返回值-80"><a href="#返回值-80" class="headerlink" title="返回值"></a>返回值</h4><p>整数回复： 如果 HyperLogLog 的内部储存被修改了， 那么返回 1 ， 否则返回 0 。</p><h4 id="代码示例-77"><a href="#代码示例-77" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; PFADD  databases  <span class="string">"Redis"</span>  <span class="string">"MongoDB"</span>  <span class="string">"MySQL"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; PFCOUNT  databases</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis&gt; PFADD  databases  <span class="string">"Redis"</span>    <span class="comment"># Redis 已经存在，不必对估计数量进行更新</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; PFCOUNT  databases    <span class="comment"># 元素估计数量没有变化</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis&gt; PFADD  databases  <span class="string">"PostgreSQL"</span>    <span class="comment"># 添加一个不存在的元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; PFCOUNT  databases    <span class="comment"># 估计数量增一</span></span><br><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="PFCOUNT"><a href="#PFCOUNT" class="headerlink" title="PFCOUNT"></a>PFCOUNT</h3><h4 id="PFCOUNT-key-key-…"><a href="#PFCOUNT-key-key-…" class="headerlink" title="PFCOUNT key [key …]"></a>PFCOUNT key [key …]</h4><pre><code>可用版本： &gt;= 2.8.9时间复杂度： 当命令作用于单个 HyperLogLog 时， 复杂度为 O(1) ， 并且具有非常低的平均常数时间。 当命令作用于 N 个 HyperLogLog 时， 复杂度为 O(N) ， 常数时间也比处理单个 HyperLogLog 时要大得多。</code></pre><p>当 PFCOUNT key [key …] 命令作用于单个键时， 返回储存在给定键的 HyperLogLog 的近似基数， 如果键不存在， 那么返回 0 。</p><p>当 PFCOUNT key [key …] 命令作用于多个键时， 返回所有给定 HyperLogLog 的并集的近似基数， 这个近似基数是通过将所有给定 HyperLogLog 合并至一个临时 HyperLogLog 来计算得出的。</p><p>通过 HyperLogLog 数据结构， 用户可以使用少量固定大小的内存， 来储存集合中的唯一元素 （每个 HyperLogLog 只需使用 12k 字节内存，以及几个字节的内存来储存键本身）。</p><p>命令返回的可见集合（observed set）基数并不是精确值， 而是一个带有 0.81% 标准错误（standard error）的近似值。</p><p>举个例子， 为了记录一天会执行多少次各不相同的搜索查询， 一个程序可以在每次执行搜索查询时调用一次 PFADD key element [element …] ， 并通过调用 PFCOUNT key [key …] 命令来获取这个记录的近似结果。</p><h4 id="返回值-81"><a href="#返回值-81" class="headerlink" title="返回值"></a>返回值</h4><p>整数回复： 给定 HyperLogLog 包含的唯一元素的近似数量。</p><h4 id="代码示例-78"><a href="#代码示例-78" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; PFADD  databases  <span class="string">"Redis"</span>  <span class="string">"MongoDB"</span>  <span class="string">"MySQL"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; PFCOUNT  databases</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis&gt; PFADD  databases  <span class="string">"Redis"</span>    <span class="comment"># Redis 已经存在，不必对估计数量进行更新</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; PFCOUNT  databases    <span class="comment"># 元素估计数量没有变化</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis&gt; PFADD  databases  <span class="string">"PostgreSQL"</span>    <span class="comment"># 添加一个不存在的元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; PFCOUNT  databases    <span class="comment"># 估计数量增一</span></span><br><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="PFMERGE"><a href="#PFMERGE" class="headerlink" title="PFMERGE"></a>PFMERGE</h3><h4 id="PFMERGE-destkey-sourcekey-sourcekey-…"><a href="#PFMERGE-destkey-sourcekey-sourcekey-…" class="headerlink" title="PFMERGE destkey sourcekey [sourcekey …]"></a>PFMERGE destkey sourcekey [sourcekey …]</h4><pre><code>可用版本： &gt;= 2.8.9时间复杂度： O(N) ， 其中 N 为被合并的 HyperLogLog 数量， 不过这个命令的常数复杂度比较高。</code></pre><p>将多个 HyperLogLog 合并（merge）为一个 HyperLogLog ， 合并后的 HyperLogLog 的基数接近于所有输入 HyperLogLog 的可见集合（observed set）的并集。</p><p>合并得出的 HyperLogLog 会被储存在 destkey 键里面， 如果该键并不存在， 那么命令在执行之前， 会先为该键创建一个空的 HyperLogLog 。</p><h4 id="返回值-82"><a href="#返回值-82" class="headerlink" title="返回值"></a>返回值</h4><p>字符串回复：返回 OK 。</p><h4 id="代码示例-79"><a href="#代码示例-79" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; PFADD  nosql  <span class="string">"Redis"</span>  <span class="string">"MongoDB"</span>  <span class="string">"Memcached"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; PFADD  RDBMS  <span class="string">"MySQL"</span> <span class="string">"MSSQL"</span> <span class="string">"PostgreSQL"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; PFMERGE  databases  nosql  RDBMS</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; PFCOUNT  databases</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br></pre></td></tr></table></figure><h2 id="地理位置"><a href="#地理位置" class="headerlink" title="地理位置"></a>地理位置</h2><h3 id="GEOADD"><a href="#GEOADD" class="headerlink" title="GEOADD"></a>GEOADD</h3><h4 id="GEOADD-key-longitude-latitude-member-longitude-latitude-member-…"><a href="#GEOADD-key-longitude-latitude-member-longitude-latitude-member-…" class="headerlink" title="GEOADD key longitude latitude member [longitude latitude member …]"></a>GEOADD key longitude latitude member [longitude latitude member …]</h4><pre><code>可用版本： &gt;= 3.2.0时间复杂度： 每添加一个元素的复杂度为 O(log(N)) ， 其中 N 为键里面包含的位置元素数量。</code></pre><p>将给定的空间元素（纬度、经度、名字）添加到指定的键里面。 这些数据会以有序集合的形式被储存在键里面， 从而使得像 GEORADIUS 和 GEORADIUSBYMEMBER 这样的命令可以在之后通过位置查询取得这些元素。</p><p>GEOADD 命令以标准的 x,y 格式接受参数， 所以用户必须先输入经度， 然后再输入纬度。 GEOADD 能够记录的坐标是有限的： 非常接近两极的区域是无法被索引的。 精确的坐标限制由 EPSG:900913 / EPSG:3785 / OSGEO:41001 等坐标系统定义， 具体如下：</p><p>有效的经度介于 -180 度至 180 度之间。<br>有效的纬度介于 -85.05112878 度至 85.05112878 度之间。<br>当用户尝试输入一个超出范围的经度或者纬度时， GEOADD 命令将返回一个错误。</p><h4 id="返回值-83"><a href="#返回值-83" class="headerlink" title="返回值"></a>返回值</h4><p>新添加到键里面的空间元素数量， 不包括那些已经存在但是被更新的元素。</p><h4 id="代码示例-80"><a href="#代码示例-80" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GEOADD Sicily 13.361389 38.115556 <span class="string">"Palermo"</span> 15.087269 37.502669 <span class="string">"Catania"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; GEODIST Sicily Palermo Catania</span><br><span class="line"><span class="string">"166274.15156960039"</span></span><br><span class="line"></span><br><span class="line">redis&gt; GEORADIUS Sicily 15 37 100 km</span><br><span class="line">1) <span class="string">"Catania"</span></span><br><span class="line"></span><br><span class="line">redis&gt; GEORADIUS Sicily 15 37 200 km</span><br><span class="line">1) <span class="string">"Palermo"</span></span><br><span class="line">2) <span class="string">"Catania"</span></span><br></pre></td></tr></table></figure><h3 id="GEOPOS"><a href="#GEOPOS" class="headerlink" title="GEOPOS"></a>GEOPOS</h3><h4 id="GEOPOS-key-member-member-…"><a href="#GEOPOS-key-member-member-…" class="headerlink" title="GEOPOS key member [member …]"></a>GEOPOS key member [member …]</h4><pre><code>可用版本： &gt;= 3.2.0时间复杂度： 获取每个位置元素的复杂度为 O(log(N)) ， 其中 N 为键里面包含的位置元素数量。</code></pre><p>从键里面返回所有给定位置元素的位置（经度和纬度）。</p><p>因为 GEOPOS 命令接受可变数量的位置元素作为输入， 所以即使用户只给定了一个位置元素， 命令也会返回数组回复。</p><h4 id="返回值-84"><a href="#返回值-84" class="headerlink" title="返回值"></a>返回值</h4><p>GEOPOS 命令返回一个数组， 数组中的每个项都由两个元素组成： 第一个元素为给定位置元素的经度， 而第二个元素则为给定位置元素的纬度。 当给定的位置元素不存在时， 对应的数组项为空值。</p><h4 id="代码示例-81"><a href="#代码示例-81" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GEOADD Sicily 13.361389 38.115556 <span class="string">"Palermo"</span> 15.087269 37.502669 <span class="string">"Catania"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; GEOPOS Sicily Palermo Catania NonExisting</span><br><span class="line">1) 1) <span class="string">"13.361389338970184"</span></span><br><span class="line">   2) <span class="string">"38.115556395496299"</span></span><br><span class="line">2) 1) <span class="string">"15.087267458438873"</span></span><br><span class="line">   2) <span class="string">"37.50266842333162"</span></span><br><span class="line">3) (nil)</span><br></pre></td></tr></table></figure><h3 id="GEODIST"><a href="#GEODIST" class="headerlink" title="GEODIST"></a>GEODIST</h3><h4 id="GEODIST-key-member1-member2-unit"><a href="#GEODIST-key-member1-member2-unit" class="headerlink" title="GEODIST key member1 member2 [unit]"></a>GEODIST key member1 member2 [unit]</h4><pre><code>可用版本： &gt;= 3.2.0复杂度： O(log(N))</code></pre><p>返回两个给定位置之间的距离。</p><p>如果两个位置之间的其中一个不存在， 那么命令返回空值。</p><p>指定单位的参数 unit 必须是以下单位的其中一个：</p><pre><code>m 表示单位为米。km 表示单位为千米。mi 表示单位为英里。ft 表示单位为英尺。</code></pre><p>如果用户没有显式地指定单位参数， 那么 GEODIST 默认使用米作为单位。</p><p>GEODIST 命令在计算距离时会假设地球为完美的球形， 在极限情况下， 这一假设最大会造成 0.5% 的误差。</p><h4 id="返回值-85"><a href="#返回值-85" class="headerlink" title="返回值"></a>返回值</h4><p>计算出的距离会以双精度浮点数的形式被返回。 如果给定的位置元素不存在， 那么命令返回空值。</p><h4 id="代码示例-82"><a href="#代码示例-82" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GEOADD Sicily 13.361389 38.115556 <span class="string">"Palermo"</span> 15.087269 37.502669 <span class="string">"Catania"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; GEODIST Sicily Palermo Catania</span><br><span class="line"><span class="string">"166274.15156960039"</span></span><br><span class="line"></span><br><span class="line">redis&gt; GEODIST Sicily Palermo Catania km</span><br><span class="line"><span class="string">"166.27415156960038"</span></span><br><span class="line"></span><br><span class="line">redis&gt; GEODIST Sicily Palermo Catania mi</span><br><span class="line"><span class="string">"103.31822459492736"</span></span><br><span class="line"></span><br><span class="line">redis&gt; GEODIST Sicily Foo Bar</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h3 id="GEORADIUS"><a href="#GEORADIUS" class="headerlink" title="GEORADIUS"></a>GEORADIUS</h3><h4 id="GEORADIUS-key-longitude-latitude-radius-m-km-ft-mi-WITHCOORD-WITHDIST-WITHHASH-ASC-DESC-COUNT-count"><a href="#GEORADIUS-key-longitude-latitude-radius-m-km-ft-mi-WITHCOORD-WITHDIST-WITHHASH-ASC-DESC-COUNT-count" class="headerlink" title="GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [ASC|DESC] [COUNT count]"></a>GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [ASC|DESC] [COUNT count]</h4><pre><code>可用版本： &gt;= 3.2.0时间复杂度： O(N+log(M))， 其中 N 为指定半径范围内的位置元素数量， 而 M 则是被返回位置元素的数量。</code></pre><p>以给定的经纬度为中心， 返回键包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素。</p><p>范围可以使用以下其中一个单位：</p><pre><code>m 表示单位为米。km 表示单位为千米。mi 表示单位为英里。ft 表示单位为英尺。</code></pre><p>在给定以下可选项时， 命令会返回额外的信息：</p><pre><code>WITHDIST ： 在返回位置元素的同时， 将位置元素与中心之间的距离也一并返回。 距离的单位和用户给定的范围单位保持一致。WITHCOORD ： 将位置元素的经度和维度也一并返回。WITHHASH ： 以 52 位有符号整数的形式， 返回位置元素经过原始 geohash 编码的有序集合分值。 这个选项主要用于底层应用或者调试， 实际中的作用并不大。</code></pre><p>命令默认返回未排序的位置元素。 通过以下两个参数， 用户可以指定被返回位置元素的排序方式：</p><pre><code>ASC ： 根据中心的位置， 按照从近到远的方式返回位置元素。DESC ： 根据中心的位置， 按照从远到近的方式返回位置元素。</code></pre><p>在默认情况下， GEORADIUS 命令会返回所有匹配的位置元素。 虽然用户可以使用 COUNT \&lt;count> 选项去获取前 N 个匹配元素， 但是因为命令在内部可能会需要对所有被匹配的元素进行处理， 所以在对一个非常大的区域进行搜索时， 即使只使用 COUNT 选项去获取少量元素， 命令的执行速度也可能会非常慢。 但是从另一方面来说， 使用 COUNT 选项去减少需要返回的元素数量， 对于减少带宽来说仍然是非常有用的。</p><h4 id="返回值-86"><a href="#返回值-86" class="headerlink" title="返回值"></a>返回值</h4><p>GEORADIUS 命令返回一个数组， 具体来说：</p><ol><li><p>在没有给定任何 WITH 选项的情况下， 命令只会返回一个像 [“New York”,”Milan”,”Paris”] 这样的线性（linear）列表。</p></li><li><p>在指定了 WITHCOORD 、 WITHDIST 、 WITHHASH 等选项的情况下， 命令返回一个二层嵌套数组， 内层的每个子数组就表示一个元素。</p></li></ol><p>在返回嵌套数组时， 子数组的第一个元素总是位置元素的名字。 至于额外的信息， 则会作为子数组的后续元素， 按照以下顺序被返回：</p><ol><li>以浮点数格式返回的中心与位置元素之间的距离， 单位与用户指定范围时的单位一致。</li><li>geohash 整数。</li><li>由两个元素组成的坐标，分别为经度和纬度。</li></ol><p>举个例子， GEORADIUS Sicily 15 37 200 km withcoord withdist 这样的命令返回的每个子数组都是类似以下格式的：</p><p>[“Palermo”,”190.4424”,[“13.361389338970184”,”38.115556395496299”]]</p><h4 id="代码示例-83"><a href="#代码示例-83" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GEOADD Sicily 13.361389 38.115556 <span class="string">"Palermo"</span> 15.087269 37.502669 <span class="string">"Catania"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; GEORADIUS Sicily 15 37 200 km WITHDIST</span><br><span class="line">1) 1) <span class="string">"Palermo"</span></span><br><span class="line">   2) <span class="string">"190.4424"</span></span><br><span class="line">2) 1) <span class="string">"Catania"</span></span><br><span class="line">   2) <span class="string">"56.4413"</span></span><br><span class="line"></span><br><span class="line">redis&gt; GEORADIUS Sicily 15 37 200 km WITHCOORD</span><br><span class="line">1) 1) <span class="string">"Palermo"</span></span><br><span class="line">   2) 1) <span class="string">"13.361389338970184"</span></span><br><span class="line">      2) <span class="string">"38.115556395496299"</span></span><br><span class="line">2) 1) <span class="string">"Catania"</span></span><br><span class="line">   2) 1) <span class="string">"15.087267458438873"</span></span><br><span class="line">      2) <span class="string">"37.50266842333162"</span></span><br><span class="line"></span><br><span class="line">redis&gt; GEORADIUS Sicily 15 37 200 km WITHDIST WITHCOORD</span><br><span class="line">1) 1) <span class="string">"Palermo"</span></span><br><span class="line">   2) <span class="string">"190.4424"</span></span><br><span class="line">   3) 1) <span class="string">"13.361389338970184"</span></span><br><span class="line">      2) <span class="string">"38.115556395496299"</span></span><br><span class="line">2) 1) <span class="string">"Catania"</span></span><br><span class="line">   2) <span class="string">"56.4413"</span></span><br><span class="line">   3) 1) <span class="string">"15.087267458438873"</span></span><br><span class="line">      2) <span class="string">"37.50266842333162"</span></span><br></pre></td></tr></table></figure><h3 id="GEORADIUSBYMEMBER"><a href="#GEORADIUSBYMEMBER" class="headerlink" title="GEORADIUSBYMEMBER"></a>GEORADIUSBYMEMBER</h3><h4 id="GEORADIUSBYMEMBER-key-member-radius-m-km-ft-mi-WITHCOORD-WITHDIST-WITHHASH-ASC-DESC-COUNT-count"><a href="#GEORADIUSBYMEMBER-key-member-radius-m-km-ft-mi-WITHCOORD-WITHDIST-WITHHASH-ASC-DESC-COUNT-count" class="headerlink" title="GEORADIUSBYMEMBER key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [ASC|DESC] [COUNT count]"></a>GEORADIUSBYMEMBER key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [ASC|DESC] [COUNT count]</h4><pre><code>可用版本： &gt;= 3.2.0时间复杂度： O(log(N)+M)， 其中 N 为指定范围之内的元素数量， 而 M 则是被返回的元素数量。</code></pre><p>这个命令和 GEORADIUS 命令一样， 都可以找出位于指定范围内的元素， 但是 GEORADIUSBYMEMBER 的中心点是由给定的位置元素决定的， 而不是像 GEORADIUS 那样， 使用输入的经度和纬度来决定中心点。</p><h4 id="返回值-87"><a href="#返回值-87" class="headerlink" title="返回值"></a>返回值</h4><p>一个数组， 数组中的每个项表示一个范围之内的位置元素。</p><h4 id="代码示例-84"><a href="#代码示例-84" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GEOADD Sicily 13.583333 37.316667 <span class="string">"Agrigento"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; GEOADD Sicily 13.361389 38.115556 <span class="string">"Palermo"</span> 15.087269 37.502669 <span class="string">"Catania"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; GEORADIUSBYMEMBER Sicily Agrigento 100 km</span><br><span class="line">1) <span class="string">"Agrigento"</span></span><br><span class="line">2) <span class="string">"Palermo"</span></span><br></pre></td></tr></table></figure><h3 id="GEOHASH"><a href="#GEOHASH" class="headerlink" title="GEOHASH"></a>GEOHASH</h3><h4 id="GEOHASH-key-member-member-…"><a href="#GEOHASH-key-member-member-…" class="headerlink" title="GEOHASH key member [member …]"></a>GEOHASH key member [member …]</h4><pre><code>可用版本： &gt;= 3.2.0时间复杂度： 寻找每个位置元素的复杂度为 O(log(N)) ， 其中 N 为给定键包含的位置元素数量。</code></pre><p>返回一个或多个位置元素的 Geohash 表示。</p><h4 id="返回值-88"><a href="#返回值-88" class="headerlink" title="返回值"></a>返回值</h4><p>一个数组， 数组的每个项都是一个 geohash 。 命令返回的 geohash 的位置与用户给定的位置元素的位置一一对应。</p><h4 id="代码示例-85"><a href="#代码示例-85" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GEOADD Sicily 13.361389 38.115556 <span class="string">"Palermo"</span> 15.087269 37.502669 <span class="string">"Catania"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; GEOHASH Sicily Palermo Catania</span><br><span class="line">1) <span class="string">"sqc8b49rny0"</span></span><br><span class="line">2) <span class="string">"sqdtr74hyu0"</span></span><br></pre></td></tr></table></figure><h2 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h2><h3 id="SETBIT"><a href="#SETBIT" class="headerlink" title="SETBIT"></a>SETBIT</h3><h4 id="SETBIT-key-offset-value"><a href="#SETBIT-key-offset-value" class="headerlink" title="SETBIT key offset value"></a>SETBIT key offset value</h4><pre><code>可用版本： &gt;= 2.2.0时间复杂度: O(1)</code></pre><p>对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。</p><p>位的设置或清除取决于 value 参数，可以是 0 也可以是 1 。</p><p>当 key 不存在时，自动生成一个新的字符串值。</p><p>字符串会进行伸展(grown)以确保它可以将 value 保存在指定的偏移量上。当字符串值进行伸展时，空白位置以 0 填充。</p><p>offset 参数必须大于或等于 0 ，小于 2^32 (bit 映射被限制在 512 MB 之内)。</p><h4 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h4><p>对使用大的 offset 的 SETBIT 操作来说，内存分配可能造成 Redis 服务器被阻塞。具体参考 SETRANGE key offset value 命令，warning(警告)部分。</p><h4 id="返回值-89"><a href="#返回值-89" class="headerlink" title="返回值"></a>返回值</h4><p>指定偏移量原来储存的位。</p><h4 id="代码示例-86"><a href="#代码示例-86" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SETBIT bit 10086 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; GETBIT bit 10086</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; GETBIT bit 100   <span class="comment"># bit 默认被初始化为 0</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><h3 id="GETBIT"><a href="#GETBIT" class="headerlink" title="GETBIT"></a>GETBIT</h3><h4 id="GETBIT-key-offset"><a href="#GETBIT-key-offset" class="headerlink" title="GETBIT key offset"></a>GETBIT key offset</h4><pre><code>可用版本： &gt;= 2.2.0时间复杂度： O(1)</code></pre><p>对 key 所储存的字符串值，获取指定偏移量上的位(bit)。</p><p>当 offset 比字符串值的长度大，或者 key 不存在时，返回 0 。</p><h4 id="返回值-90"><a href="#返回值-90" class="headerlink" title="返回值"></a>返回值</h4><p>字符串值指定偏移量上的位(bit)。</p><h4 id="代码示例-87"><a href="#代码示例-87" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对不存在的 key 或者不存在的 offset 进行 GETBIT， 返回 0</span></span><br><span class="line">redis&gt; EXISTS bit</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; GETBIT bit 10086</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对已存在的 offset 进行 GETBIT</span></span><br><span class="line">redis&gt; SETBIT bit 10086 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; GETBIT bit 10086</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><h3 id="BITCOUNT"><a href="#BITCOUNT" class="headerlink" title="BITCOUNT"></a>BITCOUNT</h3><h4 id="BITCOUNT-key-start-end"><a href="#BITCOUNT-key-start-end" class="headerlink" title="BITCOUNT key [start] [end]"></a>BITCOUNT key [start] [end]</h4><pre><code>可用版本： &gt;= 2.6.0时间复杂度： O(N)</code></pre><p>计算给定字符串中，被设置为 1 的比特位的数量。</p><p>一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。</p><p>start 和 end 参数的设置和 GETRANGE key start end 命令类似，都可以使用负数值： 比如 -1 表示最后一个字节， -2 表示倒数第二个字节，以此类推。</p><p>不存在的 key 被当成是空字符串来处理，因此对一个不存在的 key 进行 BITCOUNT 操作，结果为 0 。</p><h4 id="返回值-91"><a href="#返回值-91" class="headerlink" title="返回值"></a>返回值</h4><p>被设置为 1 的位的数量。</p><h4 id="代码示例-88"><a href="#代码示例-88" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; BITCOUNT bits</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; SETBIT bits 0 1          <span class="comment"># 0001</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; BITCOUNT bits</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; SETBIT bits 3 1          <span class="comment"># 1001</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; BITCOUNT bits</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure><h4 id="模式：使用-bitmap-实现用户上线次数统计"><a href="#模式：使用-bitmap-实现用户上线次数统计" class="headerlink" title="模式：使用 bitmap 实现用户上线次数统计"></a>模式：使用 bitmap 实现用户上线次数统计</h4><p>Bitmap 对于一些特定类型的计算非常有效。</p><p>假设现在我们希望记录自己网站上的用户的上线频率，比如说，计算用户 A 上线了多少天，用户 B 上线了多少天，诸如此类，以此作为数据，从而决定让哪些用户参加 beta 测试等活动 —— 这个模式可以使用 SETBIT key offset value 和 BITCOUNT key [start] [end] 来实现。</p><p>比如说，每当用户在某一天上线的时候，我们就使用 SETBIT key offset value ，以用户名作为 key ，将那天所代表的网站的上线日作为 offset 参数，并将这个 offset 上的为设置为 1 。</p><p>举个例子，如果今天是网站上线的第 100 天，而用户 peter 在今天阅览过网站，那么执行命令 SETBIT peter 100 1 ；如果明天 peter 也继续阅览网站，那么执行命令 SETBIT peter 101 1 ，以此类推。</p><p>当要计算 peter 总共以来的上线次数时，就使用 BITCOUNT key [start] [end] 命令：执行 BITCOUNT peter ，得出的结果就是 peter 上线的总天数。</p><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>前面的上线次数统计例子，即使运行 10 年，占用的空间也只是每个用户 10*365 比特位(bit)，也即是每个用户 456 字节。对于这种大小的数据来说， BITCOUNT key [start] [end] 的处理速度就像 GET key 和 INCR key 这种 O(1) 复杂度的操作一样快。</p><p>如果你的 bitmap 数据非常大，那么可以考虑使用以下两种方法：</p><ol><li>将一个大的 bitmap 分散到不同的 key 中，作为小的 bitmap 来处理。使用 Lua 脚本可以很方便地完成这一工作。</li><li>使用 BITCOUNT key [start] [end] 的 start 和 end 参数，每次只对所需的部分位进行计算，将位的累积工作(accumulating)放到客户端进行，并且对结果进行缓存 (caching)。</li></ol><h3 id="BITPOS"><a href="#BITPOS" class="headerlink" title="BITPOS"></a>BITPOS</h3><h4 id="BITPOS-key-bit-start-end"><a href="#BITPOS-key-bit-start-end" class="headerlink" title="BITPOS key bit [start] [end]"></a>BITPOS key bit [start] [end]</h4><pre><code>可用版本： &gt;= 2.8.7时间复杂度： O(N)，其中 N 为位图包含的二进制位数量</code></pre><p>返回位图中第一个值为 bit 的二进制位的位置。</p><p>在默认情况下， 命令将检测整个位图， 但用户也可以通过可选的 start 参数和 end 参数指定要检测的范围。</p><h4 id="返回值-92"><a href="#返回值-92" class="headerlink" title="返回值"></a>返回值</h4><p>整数回复。</p><h4 id="代码示例-89"><a href="#代码示例-89" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SETBIT bits 3 1    <span class="comment"># 1000</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; BITPOS bits 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; BITPOS bits 1</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure><h3 id="BITOP"><a href="#BITOP" class="headerlink" title="BITOP"></a>BITOP</h3><h4 id="BITOP-operation-destkey-key-key-…"><a href="#BITOP-operation-destkey-key-key-…" class="headerlink" title="BITOP operation destkey key [key …]"></a>BITOP operation destkey key [key …]</h4><p>   可用版本： &gt;= 2.6.0<br>    时间复杂度： O(N)<br>对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。</p><p>operation 可以是 AND 、 OR 、 NOT 、 XOR 这四种操作中的任意一种：</p><pre><code>BITOP AND destkey key [key ...] ，对一个或多个 key 求逻辑并，并将结果保存到 destkey 。BITOP OR destkey key [key ...] ，对一个或多个 key 求逻辑或，并将结果保存到 destkey 。BITOP XOR destkey key [key ...] ，对一个或多个 key 求逻辑异或，并将结果保存到 destkey 。BITOP NOT destkey key ，对给定 key 求逻辑非，并将结果保存到 destkey 。</code></pre><p>除了 NOT 操作之外，其他操作都可以接受一个或多个 key 作为输入。</p><p>处理不同长度的字符串</p><pre><code>当 BITOP 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 0 。空的 key 也被看作是包含 0 的字符串序列。</code></pre><h4 id="返回值-93"><a href="#返回值-93" class="headerlink" title="返回值"></a>返回值</h4><p>保存到 destkey 的字符串的长度，和输入 key 中最长的字符串长度相等。</p><h4 id="Note-4"><a href="#Note-4" class="headerlink" title="Note"></a>Note</h4><p>BITOP 的复杂度为 O(N) ，当处理大型矩阵(matrix)或者进行大数据量的统计时，最好将任务指派到附属节点(slave)进行，避免阻塞主节点。</p><h4 id="代码示例-90"><a href="#代码示例-90" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SETBIT bits-1 0 1        <span class="comment"># bits-1 = 1001</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; SETBIT bits-1 3 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; SETBIT bits-2 0 1        <span class="comment"># bits-2 = 1011</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; SETBIT bits-2 1 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; SETBIT bits-2 3 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; BITOP AND and-result bits-1 bits-2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; GETBIT and-result 0      <span class="comment"># and-result = 1001</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; GETBIT and-result 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; GETBIT and-result 2</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; GETBIT and-result 3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><h3 id="BITFIELD"><a href="#BITFIELD" class="headerlink" title="BITFIELD"></a>BITFIELD</h3><h4 id="BITFIELD-key-GET-type-offset-SET-type-offset-value-INCRBY-type-offset-increment-OVERFLOW-WRAP-SAT-FAIL"><a href="#BITFIELD-key-GET-type-offset-SET-type-offset-value-INCRBY-type-offset-increment-OVERFLOW-WRAP-SAT-FAIL" class="headerlink" title="BITFIELD key [GET type offset] [SET type offset value] [INCRBY type offset increment] [OVERFLOW WRAP|SAT|FAIL]"></a>BITFIELD key [GET type offset] [SET type offset value] [INCRBY type offset increment] [OVERFLOW WRAP|SAT|FAIL]</h4><pre><code>可用版本： &gt;= 3.2.0时间复杂度： 每个子命令的复杂度为 O(1) 。</code></pre><p>BITFIELD 命令可以将一个 Redis 字符串看作是一个由二进制位组成的数组， 并对这个数组中储存的长度不同的整数进行访问 （被储存的整数无需进行对齐）。 换句话说， 通过这个命令， 用户可以执行诸如 “对偏移量 1234 上的 5 位长有符号整数进行设置”、 “获取偏移量 4567 上的 31 位长无符号整数”等操作。 此外， BITFIELD 命令还可以对指定的整数执行加法操作和减法操作， 并且这些操作可以通过设置妥善地处理计算时出现的溢出情况。</p><p>BITFIELD 命令可以在一次调用中同时对多个位范围进行操作： 它接受一系列待执行的操作作为参数， 并返回一个数组作为回复， 数组中的每个元素就是对应操作的执行结果。</p><p>比如以下命令就展示了如何对位于偏移量 100 的 8 位长有符号整数执行加法操作， 并获取位于偏移量 0 上的 4 位长无符号整数：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; BITFIELD mykey INCRBY i8 100 1 GET u4 0</span><br><span class="line">1) (<span class="built_in">integer</span>) 1</span><br><span class="line">2) (<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure></p><p>注意：</p><pre><code>使用 GET 子命令对超出字符串当前范围的二进制位进行访问（包括键不存在的情况）， 超出部分的二进制位的值将被当做是 0 。使用 SET 子命令或者 INCRBY 子命令对超出字符串当前范围的二进制位进行访问将导致字符串被扩大， 被扩大的部分会使用值为 0 的二进制位进行填充。 在对字符串进行扩展时， 命令会根据字符串目前已有的最远端二进制位， 计算出执行操作所需的最小长度。</code></pre><h4 id="支持的子命令以及数字类型"><a href="#支持的子命令以及数字类型" class="headerlink" title="支持的子命令以及数字类型"></a>支持的子命令以及数字类型</h4><p>以下是 BITFIELD 命令支持的子命令：</p><pre><code>GET &lt;type&gt; &lt;offset&gt; —— 返回指定的二进制位范围。SET &lt;type&gt; &lt;offset&gt; &lt;value&gt; —— 对指定的二进制位范围进行设置，并返回它的旧值。INCRBY &lt;type&gt; &lt;offset&gt; &lt;increment&gt; —— 对指定的二进制位范围执行加法操作，并返回它的旧值。用户可以通过向 increment 参数传入负值来实现相应的减法操作。</code></pre><p>除了以上三个子命令之外， 还有一个子命令， 它可以改变之后执行的 INCRBY 子命令在发生溢出情况时的行为：</p><pre><code>OVERFLOW [WRAP|SAT|FAIL]</code></pre><p>当被设置的二进制位范围值为整数时， 用户可以在类型参数的前面添加 i 来表示有符号整数， 或者使用 u 来表示无符号整数。 比如说， 我们可以使用 u8 来表示 8 位长的无符号整数， 也可以使用 i16 来表示 16 位长的有符号整数。</p><p>BITFIELD 命令最大支持 64 位长的有符号整数以及 63 位长的无符号整数， 其中无符号整数的 63 位长度限制是由于 Redis 协议目前还无法返回 64 位长的无符号整数而导致的。</p><h4 id="二进制位和位置偏移量"><a href="#二进制位和位置偏移量" class="headerlink" title="二进制位和位置偏移量"></a>二进制位和位置偏移量</h4><p>在二进制位范围命令中， 用户有两种方法来设置偏移量：</p><pre><code>如果用户给定的是一个没有任何前缀的数字， 那么这个数字指示的就是字符串以零为开始（zero-base）的偏移量。另一方面， 如果用户给定的是一个带有 # 前缀的偏移量， 那么命令将使用这个偏移量与被设置的数字类型的位长度相乘， 从而计算出真正的偏移量。</code></pre><p>比如说， 对于以下这个命令来说：</p><pre><code>BITFIELD mystring SET i8 #0 100 i8 #1 200</code></pre><p>命令会把 mystring 键里面， 第一个 i8 长度的二进制位的值设置为 100 ， 并把第二个 i8 长度的二进制位的值设置为 200 。 当我们把一个字符串键当成数组来使用， 并且数组中储存的都是同等长度的整数时， 使用 # 前缀可以让我们免去手动计算被设置二进制位所在位置的麻烦。</p><h4 id="溢出控制"><a href="#溢出控制" class="headerlink" title="溢出控制"></a>溢出控制</h4><p>用户可以通过 OVERFLOW 命令以及以下展示的三个参数， 指定 BITFIELD 命令在执行自增或者自减操作时， 碰上向上溢出（overflow）或者向下溢出（underflow）情况时的行为：</p><pre><code>WRAP ： 使用回绕（wrap around）方法处理有符号整数和无符号整数的溢出情况。 对于无符号整数来说， 回绕就像使用数值本身与能够被储存的最大无符号整数执行取模计算， 这也是 C 语言的标准行为。 对于有符号整数来说， 上溢将导致数字重新从最小的负数开始计算， 而下溢将导致数字重新从最大的正数开始计算。 比如说， 如果我们对一个值为 127 的 i8 整数执行加一操作， 那么将得到结果 -128 。SAT ： 使用饱和计算（saturation arithmetic）方法处理溢出， 也即是说， 下溢计算的结果为最小的整数值， 而上溢计算的结果为最大的整数值。 举个例子， 如果我们对一个值为 120 的 i8 整数执行加 10 计算， 那么命令的结果将为 i8 类型所能储存的最大整数值 127 。 与此相反， 如果一个针对 i8 值的计算造成了下溢， 那么这个 i8 值将被设置为 -127 。FAIL ： 在这一模式下， 命令将拒绝执行那些会导致上溢或者下溢情况出现的计算， 并向用户返回空值表示计算未被执行。</code></pre><p>需要注意的是， OVERFLOW 子命令只会对紧随着它之后被执行的 INCRBY 命令产生效果， 这一效果将一直持续到与它一同被执行的下一个 OVERFLOW 命令为止。 在默认情况下， INCRBY 命令使用 WRAP 方式来处理溢出计算。</p><p>以下是一个使用 OVERFLOW 子命令来控制溢出行为的例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1</span><br><span class="line">1) (<span class="built_in">integer</span>) 1</span><br><span class="line">2) (<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">&gt; BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1</span><br><span class="line">1) (<span class="built_in">integer</span>) 2</span><br><span class="line">2) (<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">&gt; BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1</span><br><span class="line">1) (<span class="built_in">integer</span>) 3</span><br><span class="line">2) (<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">&gt; BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1</span><br><span class="line">1) (<span class="built_in">integer</span>) 0  -- 使用默认的 WRAP 方式处理溢出</span><br><span class="line">2) (<span class="built_in">integer</span>) 3  -- 使用 SAT 方式处理溢出</span><br></pre></td></tr></table></figure></p><p>而以下则是一个因为 OVERFLOW FAIL 行为而导致子命令返回空值的例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; BITFIELD mykey OVERFLOW FAIL incrby u2 102 1</span><br><span class="line">1) (nil)</span><br></pre></td></tr></table></figure></p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>BITFIELD 命令的作用在于它能够将很多小的整数储存到一个长度较大的位图中， 又或者将一个非常庞大的键分割为多个较小的键来进行储存， 从而非常高效地使用内存， 使得 Redis 能够得到更多不同的应用 —— 特别是在实时分析领域： BITFIELD 能够以指定的方式对计算溢出进行控制的能力， 使得它可以被应用于这一领域。</p><h4 id="性能注意事项"><a href="#性能注意事项" class="headerlink" title="性能注意事项"></a>性能注意事项</h4><p>BITFIELD 在一般情况下都是一个快速的命令， 需要注意的是， 访问一个长度较短的字符串的远端二进制位将引发一次内存分配操作， 这一操作花费的时间可能会比命令访问已有的字符串花费的时间要长。</p><h4 id="二进制位的排列"><a href="#二进制位的排列" class="headerlink" title="二进制位的排列"></a>二进制位的排列</h4><p>BITFIELD 把位图第一个字节偏移量 0 上的二进制位看作是 most significant 位， 以此类推。 举个例子， 如果我们对一个已经预先被全部设置为 0 的位图进行设置， 将它在偏移量 7 的值设置为 5 位无符号整数值 23 （二进制位为 10111 ）， 那么命令将生产出以下这个位图表示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+--------+--------+</span><br><span class="line">|00000001|01110000|</span><br><span class="line">+--------+--------+</span><br></pre></td></tr></table></figure></p><p>当偏移量和整数长度与字节边界进行对齐时， BITFIELD 表示二进制位的方式跟大端表示法（big endian）一致， 但是在没有对齐的情况下， 理解这些二进制位是如何进行排列也是非常重要的。</p><h4 id="返回值-94"><a href="#返回值-94" class="headerlink" title="返回值"></a>返回值</h4><p>BITFIELD 命令的返回值是一个数组， 数组中的每个元素对应一个被执行的子命令。 需要注意的是， OVERFLOW 子命令本身并不产生任何回复。</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="EXISTS"><a href="#EXISTS" class="headerlink" title="EXISTS"></a>EXISTS</h3><h4 id="EXISTS-key"><a href="#EXISTS-key" class="headerlink" title="EXISTS key"></a>EXISTS key</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>检查给定 key 是否存在。</p><h4 id="返回值-95"><a href="#返回值-95" class="headerlink" title="返回值"></a>返回值</h4><p>若 key 存在，返回 1 ，否则返回 0 。</p><h4 id="代码示例-91"><a href="#代码示例-91" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET db <span class="string">"redis"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; EXISTS db</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; DEL db</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; EXISTS db</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><h3 id="TYPE"><a href="#TYPE" class="headerlink" title="TYPE"></a>TYPE</h3><h4 id="TYPE-key"><a href="#TYPE-key" class="headerlink" title="TYPE key"></a>TYPE key</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>返回 key 所储存的值的类型。</p><h4 id="返回值-96"><a href="#返回值-96" class="headerlink" title="返回值"></a>返回值</h4><pre><code>none (key不存在)string (字符串)list (列表)set (集合)zset (有序集)hash (哈希表)stream （流）</code></pre><h4 id="代码示例-92"><a href="#代码示例-92" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字符串</span></span><br><span class="line">redis&gt; SET weather <span class="string">"sunny"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; TYPE weather</span><br><span class="line">string</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表</span></span><br><span class="line">redis&gt; LPUSH book_list <span class="string">"programming in scala"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; TYPE book_list</span><br><span class="line">list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 集合</span></span><br><span class="line">redis&gt; SADD pat <span class="string">"dog"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; TYPE pat</span><br><span class="line"><span class="built_in">set</span></span><br></pre></td></tr></table></figure><h3 id="RENAME"><a href="#RENAME" class="headerlink" title="RENAME"></a>RENAME</h3><h4 id="RENAME-key-newkey"><a href="#RENAME-key-newkey" class="headerlink" title="RENAME key newkey"></a>RENAME key newkey</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>将 key 改名为 newkey 。</p><p>当 key 和 newkey 相同，或者 key 不存在时，返回一个错误。</p><p>当 newkey 已经存在时， RENAME 命令将覆盖旧值。</p><h4 id="返回值-97"><a href="#返回值-97" class="headerlink" title="返回值"></a>返回值</h4><p>改名成功时提示 OK ，失败时候返回一个错误。</p><h4 id="代码示例-93"><a href="#代码示例-93" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># key 存在且 newkey 不存在</span></span><br><span class="line">redis&gt; SET message <span class="string">"hello world"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; RENAME message greeting</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; EXISTS message               <span class="comment"># message 不复存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; EXISTS greeting              <span class="comment"># greeting 取而代之</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当 key 不存在时，返回错误</span></span><br><span class="line">redis&gt; RENAME fake_key never_exists</span><br><span class="line">(error) ERR no such key</span><br><span class="line"></span><br><span class="line"><span class="comment"># newkey 已存在时， RENAME 会覆盖旧 newkey</span></span><br><span class="line">redis&gt; SET pc <span class="string">"lenovo"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SET personal_computer <span class="string">"dell"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; RENAME pc personal_computer</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET pc</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line">redis:1&gt; GET personal_computer      <span class="comment"># 原来的值 dell 被覆盖了</span></span><br><span class="line"><span class="string">"lenovo"</span></span><br></pre></td></tr></table></figure><h3 id="RENAMENX"><a href="#RENAMENX" class="headerlink" title="RENAMENX"></a>RENAMENX</h3><h4 id="RENAMENX-key-newkey"><a href="#RENAMENX-key-newkey" class="headerlink" title="RENAMENX key newkey"></a>RENAMENX key newkey</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>当且仅当 newkey 不存在时，将 key 改名为 newkey 。</p><p>当 key 不存在时，返回一个错误。</p><h4 id="返回值-98"><a href="#返回值-98" class="headerlink" title="返回值"></a>返回值</h4><p>修改成功时，返回 1 ； 如果 newkey 已经存在，返回 0 。</p><h4 id="代码示例-94"><a href="#代码示例-94" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># newkey 不存在，改名成功</span></span><br><span class="line">redis&gt; SET player <span class="string">"MPlyaer"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; EXISTS best_player</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; RENAMENX player best_player</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># newkey存在时，失败</span></span><br><span class="line">redis&gt; SET animal <span class="string">"bear"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SET favorite_animal <span class="string">"butterfly"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; RENAMENX animal favorite_animal</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; get animal</span><br><span class="line"><span class="string">"bear"</span></span><br><span class="line"></span><br><span class="line">redis&gt; get favorite_animal</span><br><span class="line"><span class="string">"butterfly"</span></span><br></pre></td></tr></table></figure><h3 id="MOVE"><a href="#MOVE" class="headerlink" title="MOVE"></a>MOVE</h3><h4 id="MOVE-key-db"><a href="#MOVE-key-db" class="headerlink" title="MOVE key db"></a>MOVE key db</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>将当前数据库的 key 移动到给定的数据库 db 当中。</p><p>如果当前数据库(源数据库)和给定数据库(目标数据库)有相同名字的给定 key ，或者 key 不存在于当前数据库，那么 MOVE 没有任何效果。</p><p>因此，也可以利用这一特性，将 MOVE 当作锁(locking)原语(primitive)。</p><h4 id="返回值-99"><a href="#返回值-99" class="headerlink" title="返回值"></a>返回值</h4><p>移动成功返回 1 ，失败则返回 0 。</p><h4 id="代码示例-95"><a href="#代码示例-95" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># key 存在于当前数据库</span></span><br><span class="line">redis&gt; SELECT 0                             <span class="comment"># redis默认使用数据库 0，为了清晰起见，这里再显式指定一次。</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SET song <span class="string">"secret base - Zone"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; MOVE song 1                          <span class="comment"># 将 song 移动到数据库 1</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; EXISTS song                          <span class="comment"># song 已经被移走</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; SELECT 1                             <span class="comment"># 使用数据库 1</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis:1&gt; EXISTS song                        <span class="comment"># 证实 song 被移到了数据库 1 (注意命令提示符变成了"redis:1"，表明正在使用数据库 1)</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当 key 不存在的时候</span></span><br><span class="line">redis:1&gt; EXISTS fake_key</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis:1&gt; MOVE fake_key 0                    <span class="comment"># 试图从数据库 1 移动一个不存在的 key 到数据库 0，失败</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis:1&gt; select 0                           <span class="comment"># 使用数据库0</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; EXISTS fake_key                      <span class="comment"># 证实 fake_key 不存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当源数据库和目标数据库有相同的 key 时</span></span><br><span class="line">redis&gt; SELECT 0                             <span class="comment"># 使用数据库0</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; SET favorite_fruit <span class="string">"banana"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SELECT 1                             <span class="comment"># 使用数据库1</span></span><br><span class="line">OK</span><br><span class="line">redis:1&gt; SET favorite_fruit <span class="string">"apple"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis:1&gt; SELECT 0                           <span class="comment"># 使用数据库0，并试图将 favorite_fruit 移动到数据库 1</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; MOVE favorite_fruit 1                <span class="comment"># 因为两个数据库有相同的 key，MOVE 失败</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; GET favorite_fruit                   <span class="comment"># 数据库 0 的 favorite_fruit 没变</span></span><br><span class="line"><span class="string">"banana"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SELECT 1</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis:1&gt; GET favorite_fruit                 <span class="comment"># 数据库 1 的 favorite_fruit 也是</span></span><br><span class="line"><span class="string">"apple"</span></span><br></pre></td></tr></table></figure><h3 id="DEL"><a href="#DEL" class="headerlink" title="DEL"></a>DEL</h3><h4 id="DEL-key-key-…"><a href="#DEL-key-key-…" class="headerlink" title="DEL key [key …]"></a>DEL key [key …]</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度：O(N)， N 为被删除的 key 的数量，其中删除单个字符串类型的 key ，时间复杂度为O(1)；删除单个列表、集合、有序集合或哈希表类型的 key ，时间复杂度为O(M)， M 为以上数据结构内的元素数量。</code></pre><p>删除给定的一个或多个 key 。</p><p>不存在的 key 会被忽略。</p><h4 id="返回值-100"><a href="#返回值-100" class="headerlink" title="返回值"></a>返回值</h4><p>被删除 key 的数量。</p><h4 id="代码示例-96"><a href="#代码示例-96" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  删除单个 key</span></span><br><span class="line">redis&gt; SET name huangz</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; DEL name</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除一个不存在的 key</span></span><br><span class="line">redis&gt; EXISTS phone</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; DEL phone <span class="comment"># 失败，没有 key 被删除</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时删除多个 key</span></span><br><span class="line">redis&gt; SET name <span class="string">"redis"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SET <span class="built_in">type</span> <span class="string">"key-value store"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SET website <span class="string">"redis.com"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; DEL name <span class="built_in">type</span> website</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure><h3 id="RANDOMKEY"><a href="#RANDOMKEY" class="headerlink" title="RANDOMKEY"></a>RANDOMKEY</h3><h4 id="RANDOMKEY-1"><a href="#RANDOMKEY-1" class="headerlink" title="RANDOMKEY"></a>RANDOMKEY</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>从当前数据库中随机返回(不删除)一个 key 。</p><h4 id="返回值-101"><a href="#返回值-101" class="headerlink" title="返回值"></a>返回值</h4><p>当数据库不为空时，返回一个 key 。 当数据库为空时，返回 nil 。</p><h4 id="代码示例-97"><a href="#代码示例-97" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据库不为空</span></span><br><span class="line">redis&gt; MSET fruit <span class="string">"apple"</span> drink <span class="string">"beer"</span> food <span class="string">"cookies"</span>   <span class="comment"># 设置多个 key</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; RANDOMKEY</span><br><span class="line"><span class="string">"fruit"</span></span><br><span class="line"></span><br><span class="line">redis&gt; RANDOMKEY</span><br><span class="line"><span class="string">"food"</span></span><br><span class="line"></span><br><span class="line">redis&gt; KEYS *    <span class="comment"># 查看数据库内所有key，证明 RANDOMKEY 并不删除 key</span></span><br><span class="line">1) <span class="string">"food"</span></span><br><span class="line">2) <span class="string">"drink"</span></span><br><span class="line">3) <span class="string">"fruit"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库为空</span></span><br><span class="line">redis&gt; FLUSHDB  <span class="comment"># 删除当前数据库所有 key</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; RANDOMKEY</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h3 id="DBSIZE"><a href="#DBSIZE" class="headerlink" title="DBSIZE"></a>DBSIZE</h3><h4 id="DBSIZE-1"><a href="#DBSIZE-1" class="headerlink" title="DBSIZE"></a>DBSIZE</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>返回当前数据库的 key 的数量。</p><h4 id="返回值-102"><a href="#返回值-102" class="headerlink" title="返回值"></a>返回值</h4><p>当前数据库的 key 的数量。</p><h4 id="代码示例-98"><a href="#代码示例-98" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; DBSIZE</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line"></span><br><span class="line">redis&gt; SET new_key <span class="string">"hello_moto"</span>     <span class="comment"># 增加一个 key 试试</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; DBSIZE</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br></pre></td></tr></table></figure><h3 id="KEYS"><a href="#KEYS" class="headerlink" title="KEYS"></a>KEYS</h3><h4 id="KEYS-pattern"><a href="#KEYS-pattern" class="headerlink" title="KEYS pattern"></a>KEYS pattern</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(N)， N 为数据库中 key 的数量。</code></pre><p>查找所有符合给定模式 pattern 的 key ， 比如说：</p><pre><code>KEYS * 匹配数据库中所有 key 。KEYS h?llo 匹配 hello ， hallo 和 hxllo 等。KEYS h*llo 匹配 hllo 和 heeeeello 等。KEYS h[ae]llo 匹配 hello 和 hallo ，但不匹配 hillo 。</code></pre><p>特殊符号用 \ 隔开。</p><h4 id="Warning-1"><a href="#Warning-1" class="headerlink" title="Warning"></a>Warning</h4><p>KEYS 的速度非常快，但在一个大的数据库中使用它仍然可能造成性能问题，如果你需要从一个数据集中查找特定的 key ，你最好还是用 Redis 的集合结构(set)来代替。</p><h4 id="返回值-103"><a href="#返回值-103" class="headerlink" title="返回值"></a>返回值</h4><p>符合给定模式的 key 列表。</p><h4 id="代码示例-99"><a href="#代码示例-99" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MSET one 1 two 2 three 3 four 4  <span class="comment"># 一次设置 4 个 key</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; KEYS *o*</span><br><span class="line">1) <span class="string">"four"</span></span><br><span class="line">2) <span class="string">"two"</span></span><br><span class="line">3) <span class="string">"one"</span></span><br><span class="line"></span><br><span class="line">redis&gt; KEYS t??</span><br><span class="line">1) <span class="string">"two"</span></span><br><span class="line"></span><br><span class="line">redis&gt; KEYS t[w]*</span><br><span class="line">1) <span class="string">"two"</span></span><br><span class="line"></span><br><span class="line">redis&gt; KEYS *  <span class="comment"># 匹配数据库内所有 key</span></span><br><span class="line">1) <span class="string">"four"</span></span><br><span class="line">2) <span class="string">"three"</span></span><br><span class="line">3) <span class="string">"two"</span></span><br><span class="line">4) <span class="string">"one"</span></span><br></pre></td></tr></table></figure><h3 id="SCAN"><a href="#SCAN" class="headerlink" title="SCAN"></a>SCAN</h3><h4 id="SCAN-cursor-MATCH-pattern-COUNT-count"><a href="#SCAN-cursor-MATCH-pattern-COUNT-count" class="headerlink" title="SCAN cursor [MATCH pattern] [COUNT count]"></a>SCAN cursor [MATCH pattern] [COUNT count]</h4><pre><code>可用版本： &gt;= 2.8.0时间复杂度：增量式迭代命令每次执行的复杂度为 O(1) ， 对数据集进行一次完整迭代的复杂度为 O(N) ， 其中 N 为数据集中的元素数量。</code></pre><p>SCAN 命令及其相关的 SSCAN 命令、 HSCAN 命令和 ZSCAN 命令都用于增量地迭代（incrementally iterate）一集元素（a collection of elements）：</p><pre><code>SCAN 命令用于迭代当前数据库中的数据库键。SSCAN 命令用于迭代集合键中的元素。HSCAN 命令用于迭代哈希键中的键值对。ZSCAN 命令用于迭代有序集合中的元素（包括元素成员和元素分值）。</code></pre><p>以上列出的四个命令都支持增量式迭代， 它们每次执行都只会返回少量元素， 所以这些命令可以用于生产环境， 而不会出现像 KEYS 命令、 SMEMBERS 命令带来的问题 —— 当 KEYS 命令被用于处理一个大的数据库时， 又或者 SMEMBERS 命令被用于处理一个大的集合键时， 它们可能会阻塞服务器达数秒之久。</p><p>不过， 增量式迭代命令也不是没有缺点的： 举个例子， 使用 SMEMBERS 命令可以返回集合键当前包含的所有元素， 但是对于 SCAN 这类增量式迭代命令来说， 因为在对键进行增量式迭代的过程中， 键可能会被修改， 所以增量式迭代命令只能对被返回的元素提供有限的保证 （offer limited guarantees about the returned elements）。</p><p>因为 SCAN 、 SSCAN 、 HSCAN 和 ZSCAN 四个命令的工作方式都非常相似， 所以这个文档会一并介绍这四个命令， 但是要记住：</p><ul><li>SSCAN 命令、 HSCAN 命令和 ZSCAN 命令的第一个参数总是一个数据库键。</li><li>而 SCAN 命令则不需要在第一个参数提供任何数据库键 —— 因为它迭代的是当前数据库中的所有数据库键。<h4 id="SCAN-命令的基本用法"><a href="#SCAN-命令的基本用法" class="headerlink" title="SCAN 命令的基本用法"></a>SCAN 命令的基本用法</h4>SCAN 命令是一个基于游标的迭代器（cursor based iterator）： SCAN 命令每次被调用之后， 都会向用户返回一个新的游标， 用户在下次迭代时需要使用这个新游标作为 SCAN 命令的游标参数， 以此来延续之前的迭代过程。</li></ul><p>当 SCAN 命令的游标参数被设置为 0 时， 服务器将开始一次新的迭代， 而当服务器向用户返回值为 0 的游标时， 表示迭代已结束。</p><p>以下是一个 SCAN 命令的迭代过程示例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; scan 0</span><br><span class="line">1) <span class="string">"17"</span></span><br><span class="line">2)  1) <span class="string">"key:12"</span></span><br><span class="line">    2) <span class="string">"key:8"</span></span><br><span class="line">    3) <span class="string">"key:4"</span></span><br><span class="line">    4) <span class="string">"key:14"</span></span><br><span class="line">    5) <span class="string">"key:16"</span></span><br><span class="line">    6) <span class="string">"key:17"</span></span><br><span class="line">    7) <span class="string">"key:15"</span></span><br><span class="line">    8) <span class="string">"key:10"</span></span><br><span class="line">    9) <span class="string">"key:3"</span></span><br><span class="line">    10) <span class="string">"key:7"</span></span><br><span class="line">    11) <span class="string">"key:1"</span></span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; scan 17</span><br><span class="line">1) <span class="string">"0"</span></span><br><span class="line">2) 1) <span class="string">"key:5"</span></span><br><span class="line">   2) <span class="string">"key:18"</span></span><br><span class="line">   3) <span class="string">"key:0"</span></span><br><span class="line">   4) <span class="string">"key:2"</span></span><br><span class="line">   5) <span class="string">"key:19"</span></span><br><span class="line">   6) <span class="string">"key:13"</span></span><br><span class="line">   7) <span class="string">"key:6"</span></span><br><span class="line">   8) <span class="string">"key:9"</span></span><br><span class="line">   9) <span class="string">"key:11"</span></span><br></pre></td></tr></table></figure></p><p>在上面这个例子中， 第一次迭代使用 0 作为游标， 表示开始一次新的迭代。</p><p>第二次迭代使用的是第一次迭代时返回的游标， 也即是命令回复第一个元素的值 —— 17 。</p><p>从上面的示例可以看到， SCAN 命令的回复是一个包含两个元素的数组， 第一个数组元素是用于进行下一次迭代的新游标， 而第二个数组元素则是一个数组， 这个数组中包含了所有被迭代的元素。</p><p>在第二次调用 SCAN 命令时， 命令返回了游标 0 ， 这表示迭代已经结束， 整个数据集（collection）已经被完整遍历过了。</p><p>以 0 作为游标开始一次新的迭代， 一直调用 SCAN 命令， 直到命令返回游标 0 ， 我们称这个过程为一次完整遍历（full iteration）。</p><h4 id="SCAN-命令的保证（guarantees）"><a href="#SCAN-命令的保证（guarantees）" class="headerlink" title="SCAN 命令的保证（guarantees）"></a>SCAN 命令的保证（guarantees）</h4><p>SCAN 命令， 以及其他增量式迭代命令， 在进行完整遍历的情况下可以为用户带来以下保证： 从完整遍历开始直到完整遍历结束期间， 一直存在于数据集内的所有元素都会被完整遍历返回； 这意味着， 如果有一个元素， 它从遍历开始直到遍历结束期间都存在于被遍历的数据集当中， 那么 SCAN 命令总会在某次迭代中将这个元素返回给用户。</p><p>然而因为增量式命令仅仅使用游标来记录迭代状态， 所以这些命令带有以下缺点：</p><ul><li>同一个元素可能会被返回多次。 处理重复元素的工作交由应用程序负责， 比如说， 可以考虑将迭代返回的元素仅仅用于可以安全地重复执行多次的操作上。</li><li>如果一个元素是在迭代过程中被添加到数据集的， 又或者是在迭代过程中从数据集中被删除的， 那么这个元素可能会被返回， 也可能不会， 这是未定义的（undefined）。<br>SCAN 命令每次执行返回的元素数量<br>增量式迭代命令并不保证每次执行都返回某个给定数量的元素。</li></ul><p>增量式命令甚至可能会返回零个元素， 但只要命令返回的游标不是 0 ， 应用程序就不应该将迭代视作结束。</p><p>不过命令返回的元素数量总是符合一定规则的， 在实际中：</p><ul><li>对于一个大数据集来说， 增量式迭代命令每次最多可能会返回数十个元素；</li><li>而对于一个足够小的数据集来说， 如果这个数据集的底层表示为编码数据结构（encoded data structure，适用于是小集合键、小哈希键和小有序集合键）， 那么增量迭代命令将在一次调用中返回数据集中的所有元素。<br>最后， 用户可以通过增量式迭代命令提供的 COUNT 选项来指定每次迭代返回元素的最大值。</li></ul><h4 id="COUNT-选项"><a href="#COUNT-选项" class="headerlink" title="COUNT 选项"></a>COUNT 选项</h4><p>虽然增量式迭代命令不保证每次迭代所返回的元素数量， 但我们可以使用 COUNT 选项， 对命令的行为进行一定程度上的调整。</p><p>基本上， COUNT 选项的作用就是让用户告知迭代命令， 在每次迭代中应该从数据集里返回多少元素。</p><p>虽然 COUNT 选项只是对增量式迭代命令的一种提示（hint）， 但是在大多数情况下， 这种提示都是有效的。</p><ul><li>COUNT 参数的默认值为 10 。</li><li>在迭代一个足够大的、由哈希表实现的数据库、集合键、哈希键或者有序集合键时， 如果用户没有使用 MATCH 选项， 那么命令返回的元素数量通常和 COUNT 选项指定的一样， 或者比 COUNT 选项指定的数量稍多一些。</li><li>在迭代一个编码为整数集合（intset，一个只由整数值构成的小集合）、 或者编码为压缩列表（ziplist，由不同值构成的一个小哈希或者一个小有序集合）时， 增量式迭代命令通常会无视 COUNT 选项指定的值， 在第一次迭代就将数据集包含的所有元素都返回给用户。<h4 id="Note-5"><a href="#Note-5" class="headerlink" title="Note"></a>Note</h4></li></ul><p>并非每次迭代都要使用相同的 COUNT 值。</p><p>用户可以在每次迭代中按自己的需要随意改变 COUNT 值， 只要记得将上次迭代返回的游标用到下次迭代里面就可以了。</p><h4 id="MATCH-选项"><a href="#MATCH-选项" class="headerlink" title="MATCH 选项"></a>MATCH 选项</h4><p>和 KEYS 命令一样， 增量式迭代命令也可以通过提供一个 glob 风格的模式参数， 让命令只返回和给定模式相匹配的元素， 这一点可以通过在执行增量式迭代命令时， 通过给定 MATCH \&lt;pattern> 参数来实现。</p><p>以下是一个使用 MATCH 选项进行迭代的示例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; sadd myset 1 2 3 foo foobar feelsgood</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; sscan myset 0 match f*</span><br><span class="line">1) <span class="string">"0"</span></span><br><span class="line">2) 1) <span class="string">"foo"</span></span><br><span class="line">   2) <span class="string">"feelsgood"</span></span><br><span class="line">   3) <span class="string">"foobar"</span></span><br></pre></td></tr></table></figure></p><p>需要注意的是， 对元素的模式匹配工作是在命令从数据集中取出元素之后， 向客户端返回元素之前的这段时间内进行的， 所以如果被迭代的数据集中只有少量元素和模式相匹配， 那么迭代命令或许会在多次执行中都不返回任何元素。</p><p>以下是这种情况的一个例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; scan 0 MATCH *11*</span><br><span class="line">1) <span class="string">"288"</span></span><br><span class="line">2) 1) <span class="string">"key:911"</span></span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; scan 288 MATCH *11*</span><br><span class="line">1) <span class="string">"224"</span></span><br><span class="line">2) (empty list or <span class="built_in">set</span>)</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; scan 224 MATCH *11*</span><br><span class="line">1) <span class="string">"80"</span></span><br><span class="line">2) (empty list or <span class="built_in">set</span>)</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; scan 80 MATCH *11*</span><br><span class="line">1) <span class="string">"176"</span></span><br><span class="line">2) (empty list or <span class="built_in">set</span>)</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; scan 176 MATCH *11* COUNT 1000</span><br><span class="line">1) <span class="string">"0"</span></span><br><span class="line">2)  1) <span class="string">"key:611"</span></span><br><span class="line">    2) <span class="string">"key:711"</span></span><br><span class="line">    3) <span class="string">"key:118"</span></span><br><span class="line">    4) <span class="string">"key:117"</span></span><br><span class="line">    5) <span class="string">"key:311"</span></span><br><span class="line">    6) <span class="string">"key:112"</span></span><br><span class="line">    7) <span class="string">"key:111"</span></span><br><span class="line">    8) <span class="string">"key:110"</span></span><br><span class="line">    9) <span class="string">"key:113"</span></span><br><span class="line">   10) <span class="string">"key:211"</span></span><br><span class="line">   11) <span class="string">"key:411"</span></span><br><span class="line">   12) <span class="string">"key:115"</span></span><br><span class="line">   13) <span class="string">"key:116"</span></span><br><span class="line">   14) <span class="string">"key:114"</span></span><br><span class="line">   15) <span class="string">"key:119"</span></span><br><span class="line">   16) <span class="string">"key:811"</span></span><br><span class="line">   17) <span class="string">"key:511"</span></span><br><span class="line">   18) <span class="string">"key:11"</span></span><br></pre></td></tr></table></figure></p><p>如你所见， 以上的大部分迭代都不返回任何元素。</p><p>在最后一次迭代， 我们通过将 COUNT 选项的参数设置为 1000 ， 强制命令为本次迭代扫描更多元素， 从而使得命令返回的元素也变多了。</p><h4 id="并发执行多个迭代"><a href="#并发执行多个迭代" class="headerlink" title="并发执行多个迭代"></a>并发执行多个迭代</h4><p>在同一时间， 可以有任意多个客户端对同一数据集进行迭代， 客户端每次执行迭代都需要传入一个游标， 并在迭代执行之后获得一个新的游标， 而这个游标就包含了迭代的所有状态， 因此， 服务器无须为迭代记录任何状态。</p><h4 id="中途停止迭代"><a href="#中途停止迭代" class="headerlink" title="中途停止迭代"></a>中途停止迭代</h4><p>因为迭代的所有状态都保存在游标里面， 而服务器无须为迭代保存任何状态， 所以客户端可以在中途停止一个迭代， 而无须对服务器进行任何通知。</p><p>即使有任意数量的迭代在中途停止， 也不会产生任何问题。</p><h4 id="使用错误的游标进行增量式迭代"><a href="#使用错误的游标进行增量式迭代" class="headerlink" title="使用错误的游标进行增量式迭代"></a>使用错误的游标进行增量式迭代</h4><p>使用间断的（broken）、负数、超出范围或者其他非正常的游标来执行增量式迭代并不会造成服务器崩溃， 但可能会让命令产生未定义的行为。</p><p>未定义行为指的是， 增量式命令对返回值所做的保证可能会不再为真。</p><p>只有两种游标是合法的：</p><ol><li>在开始一个新的迭代时， 游标必须为 0 。</li><li>增量式迭代命令在执行之后返回的， 用于延续（continue）迭代过程的游标。<h4 id="迭代终结的保证"><a href="#迭代终结的保证" class="headerlink" title="迭代终结的保证"></a>迭代终结的保证</h4>增量式迭代命令所使用的算法只保证在数据集的大小有界（bounded）的情况下， 迭代才会停止， 换句话说， 如果被迭代数据集的大小不断地增长的话， 增量式迭代命令可能永远也无法完成一次完整迭代。</li></ol><p>从直觉上可以看出， 当一个数据集不断地变大时， 想要访问这个数据集中的所有元素就需要做越来越多的工作， 能否结束一个迭代取决于用户执行迭代的速度是否比数据集增长的速度更快。</p><h4 id="返回值-104"><a href="#返回值-104" class="headerlink" title="返回值"></a>返回值</h4><p>SCAN 命令、 SSCAN 命令、 HSCAN 命令和 ZSCAN 命令都返回一个包含两个元素的 multi-bulk 回复： 回复的第一个元素是字符串表示的无符号 64 位整数（游标）， 回复的第二个元素是另一个 multi-bulk 回复， 这个 multi-bulk 回复包含了本次被迭代的元素。</p><pre><code>SCAN 命令返回的每个元素都是一个数据库键。SSCAN 命令返回的每个元素都是一个集合成员。HSCAN 命令返回的每个元素都是一个键值对，一个键值对由一个键和一个值组成。ZSCAN 命令返回的每个元素都是一个有序集合元素，一个有序集合元素由一个成员（member）和一个分值（score）组成。</code></pre><h3 id="SORT"><a href="#SORT" class="headerlink" title="SORT"></a>SORT</h3><h4 id="SORT-key-BY-pattern-LIMIT-offset-count-GET-pattern-GET-pattern-…-ASC-DESC-ALPHA-STORE-destination"><a href="#SORT-key-BY-pattern-LIMIT-offset-count-GET-pattern-GET-pattern-…-ASC-DESC-ALPHA-STORE-destination" class="headerlink" title="SORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern …]] [ASC | DESC] [ALPHA] [STORE destination]"></a>SORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern …]] [ASC | DESC] [ALPHA] [STORE destination]</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(N+M*log(M))， N 为要排序的列表或集合内的元素数量， M 为要返回的元素数量。如果只是使用 SORT 命令的 GET 选项获取数据而没有进行排序，时间复杂度 O(N)。</code></pre><p>返回或保存给定列表、集合、有序集合 key 中经过排序的元素。</p><p>排序默认以数字作为对象，值被解释为双精度浮点数，然后进行比较。</p><h4 id="一般-SORT-用法"><a href="#一般-SORT-用法" class="headerlink" title="一般 SORT 用法"></a>一般 SORT 用法</h4><p>最简单的 SORT 使用方法是 SORT key 和 SORT key DESC ：</p><ul><li>SORT key 返回键值从小到大排序的结果。</li><li>SORT key DESC 返回键值从大到小排序的结果。<br>假设 today_cost 列表保存了今日的开销金额， 那么可以用 SORT 命令对它进行排序：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开销金额列表</span></span><br><span class="line">redis&gt; LPUSH today_cost 30 1.5 10 8</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 排序</span></span><br><span class="line">redis&gt; SORT today_cost</span><br><span class="line">1) <span class="string">"1.5"</span></span><br><span class="line">2) <span class="string">"8"</span></span><br><span class="line">3) <span class="string">"10"</span></span><br><span class="line">4) <span class="string">"30"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 逆序排序</span></span><br><span class="line">redis 127.0.0.1:6379&gt; SORT today_cost DESC</span><br><span class="line">1) <span class="string">"30"</span></span><br><span class="line">2) <span class="string">"10"</span></span><br><span class="line">3) <span class="string">"8"</span></span><br><span class="line">4) <span class="string">"1.5"</span></span><br></pre></td></tr></table></figure><h4 id="使用-ALPHA-修饰符对字符串进行排序"><a href="#使用-ALPHA-修饰符对字符串进行排序" class="headerlink" title="使用 ALPHA 修饰符对字符串进行排序"></a>使用 ALPHA 修饰符对字符串进行排序</h4><p>因为 SORT 命令默认排序对象为数字， 当需要对字符串进行排序时， 需要显式地在 SORT 命令之后添加 ALPHA 修饰符：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 网址</span></span><br><span class="line">redis&gt; LPUSH website <span class="string">"www.reddit.com"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; LPUSH website <span class="string">"www.slashdot.com"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; LPUSH website <span class="string">"www.infoq.com"</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认（按数字）排序</span></span><br><span class="line">redis&gt; SORT website</span><br><span class="line">1) <span class="string">"www.infoq.com"</span></span><br><span class="line">2) <span class="string">"www.slashdot.com"</span></span><br><span class="line">3) <span class="string">"www.reddit.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按字符排序</span></span><br><span class="line">redis&gt; SORT website ALPHA</span><br><span class="line">1) <span class="string">"www.infoq.com"</span></span><br><span class="line">2) <span class="string">"www.reddit.com"</span></span><br><span class="line">3) <span class="string">"www.slashdot.com"</span></span><br></pre></td></tr></table></figure></p><p>如果系统正确地设置了 LC_COLLATE 环境变量的话，Redis能识别 UTF-8 编码。</p><h4 id="使用-LIMIT-修饰符限制返回结果"><a href="#使用-LIMIT-修饰符限制返回结果" class="headerlink" title="使用 LIMIT 修饰符限制返回结果"></a>使用 LIMIT 修饰符限制返回结果</h4><p>排序之后返回元素的数量可以通过 LIMIT 修饰符进行限制， 修饰符接受 offset 和 count 两个参数：</p><ul><li>offset 指定要跳过的元素数量。</li><li>count 指定跳过 offset 个指定的元素之后，要返回多少个对象。<br>以下例子返回排序结果的前 5 个对象( offset 为 0 表示没有元素被跳过)。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加测试数据，列表值为 1 指 10</span></span><br><span class="line">redis 127.0.0.1:6379&gt; RPUSH rank 1 3 5 7 9</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; RPUSH rank 2 4 6 8 10</span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回列表中最小的 5 个值</span></span><br><span class="line">redis 127.0.0.1:6379&gt; SORT rank LIMIT 0 5</span><br><span class="line">1) <span class="string">"1"</span></span><br><span class="line">2) <span class="string">"2"</span></span><br><span class="line">3) <span class="string">"3"</span></span><br><span class="line">4) <span class="string">"4"</span></span><br><span class="line">5) <span class="string">"5"</span></span><br></pre></td></tr></table></figure></li></ul><p>可以组合使用多个修饰符。以下例子返回从大到小排序的前 5 个对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SORT rank LIMIT 0 5 DESC</span><br><span class="line">1) <span class="string">"10"</span></span><br><span class="line">2) <span class="string">"9"</span></span><br><span class="line">3) <span class="string">"8"</span></span><br><span class="line">4) <span class="string">"7"</span></span><br><span class="line">5) <span class="string">"6"</span></span><br></pre></td></tr></table></figure></p><h4 id="使用外部-key-进行排序"><a href="#使用外部-key-进行排序" class="headerlink" title="使用外部 key 进行排序"></a>使用外部 key 进行排序</h4><p>可以使用外部 key 的数据作为权重，代替默认的直接对比键值的方式来进行排序。</p><p>假设现在有用户数据如下：</p><p>以下代码将数据输入到 Redis 中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># admin</span></span><br><span class="line">redis 127.0.0.1:6379&gt; LPUSH uid 1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SET user_name_1 admin</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SET user_level_1 9999</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># jack</span></span><br><span class="line">redis 127.0.0.1:6379&gt; LPUSH uid 2</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SET user_name_2 jack</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SET user_level_2 10</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># peter</span></span><br><span class="line">redis 127.0.0.1:6379&gt; LPUSH uid 3</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SET user_name_3 peter</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SET user_level_3 25</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># mary</span></span><br><span class="line">redis 127.0.0.1:6379&gt; LPUSH uid 4</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SET user_name_4 mary</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SET user_level_4 70</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p><h5 id="BY-选项"><a href="#BY-选项" class="headerlink" title="BY 选项"></a>BY 选项</h5><p>默认情况下， SORT uid 直接按 uid 中的值排序：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SORT uid</span><br><span class="line">1) <span class="string">"1"</span>      <span class="comment"># admin</span></span><br><span class="line">2) <span class="string">"2"</span>      <span class="comment"># jack</span></span><br><span class="line">3) <span class="string">"3"</span>      <span class="comment"># peter</span></span><br><span class="line">4) <span class="string">"4"</span>      <span class="comment"># mary</span></span><br></pre></td></tr></table></figure></p><p>通过使用 BY 选项，可以让 uid 按其他键的元素来排序。</p><p>比如说， 以下代码让 uid 键按照 user_level_{uid} 的大小来排序：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SORT uid BY user_level_*</span><br><span class="line">1) <span class="string">"2"</span>      <span class="comment"># jack , level = 10</span></span><br><span class="line">2) <span class="string">"3"</span>      <span class="comment"># peter, level = 25</span></span><br><span class="line">3) <span class="string">"4"</span>      <span class="comment"># mary, level = 70</span></span><br><span class="line">4) <span class="string">"1"</span>      <span class="comment"># admin, level = 9999</span></span><br></pre></td></tr></table></figure></p><p>user_level_* 是一个占位符， 它先取出 uid 中的值， 然后再用这个值来查找相应的键。</p><p>比如在对 uid 列表进行排序时， 程序就会先取出 uid 的值 1 、 2 、 3 、 4 ， 然后使用 user_level_1 、 user_level_2 、 user_level_3 和 user_level_4 的值作为排序 uid 的权重。</p><h5 id="GET-选项"><a href="#GET-选项" class="headerlink" title="GET 选项"></a>GET 选项</h5><p>使用 GET 选项， 可以根据排序的结果来取出相应的键值。</p><p>比如说， 以下代码先排序 uid ， 再取出键 user_name_{uid} 的值：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SORT uid GET user_name_*</span><br><span class="line">1) <span class="string">"admin"</span></span><br><span class="line">2) <span class="string">"jack"</span></span><br><span class="line">3) <span class="string">"peter"</span></span><br><span class="line">4) <span class="string">"mary"</span></span><br></pre></td></tr></table></figure></p><h5 id="组合使用-BY-和-GET"><a href="#组合使用-BY-和-GET" class="headerlink" title="组合使用 BY 和 GET"></a>组合使用 BY 和 GET</h5><p>通过组合使用 BY 和 GET ， 可以让排序结果以更直观的方式显示出来。</p><p>比如说， 以下代码先按 user_level_{uid} 来排序 uid 列表， 再取出相应的 user_name_{uid} 的值：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SORT uid BY user_level_* GET user_name_*</span><br><span class="line">1) <span class="string">"jack"</span>       <span class="comment"># level = 10</span></span><br><span class="line">2) <span class="string">"peter"</span>      <span class="comment"># level = 25</span></span><br><span class="line">3) <span class="string">"mary"</span>       <span class="comment"># level = 70</span></span><br><span class="line">4) <span class="string">"admin"</span>      <span class="comment"># level = 9999</span></span><br></pre></td></tr></table></figure></p><p>现在的排序结果要比只使用 SORT uid BY user_level_* 要直观得多。</p><h5 id="获取多个外部键"><a href="#获取多个外部键" class="headerlink" title="获取多个外部键"></a>获取多个外部键</h5><p>可以同时使用多个 GET 选项， 获取多个外部键的值。</p><p>以下代码就按 uid 分别获取 user_level_{uid} 和 user_name_{uid} ：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SORT uid GET user_level_* GET user_name_*</span><br><span class="line">1) <span class="string">"9999"</span>       <span class="comment"># level</span></span><br><span class="line">2) <span class="string">"admin"</span>      <span class="comment"># name</span></span><br><span class="line">3) <span class="string">"10"</span></span><br><span class="line">4) <span class="string">"jack"</span></span><br><span class="line">5) <span class="string">"25"</span></span><br><span class="line">6) <span class="string">"peter"</span></span><br><span class="line">7) <span class="string">"70"</span></span><br><span class="line">8) <span class="string">"mary"</span></span><br></pre></td></tr></table></figure></p><p>GET 有一个额外的参数规则，那就是 —— 可以用 # 获取被排序键的值。</p><p>以下代码就将 uid 的值、及其相应的 user_level_<em> 和 user_name_</em> 都返回为结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SORT uid GET <span class="comment"># GET user_level_* GET user_name_*</span></span><br><span class="line">1) <span class="string">"1"</span>          <span class="comment"># uid</span></span><br><span class="line">2) <span class="string">"9999"</span>       <span class="comment"># level</span></span><br><span class="line">3) <span class="string">"admin"</span>      <span class="comment"># name</span></span><br><span class="line">4) <span class="string">"2"</span></span><br><span class="line">5) <span class="string">"10"</span></span><br><span class="line">6) <span class="string">"jack"</span></span><br><span class="line">7) <span class="string">"3"</span></span><br><span class="line">8) <span class="string">"25"</span></span><br><span class="line">9) <span class="string">"peter"</span></span><br><span class="line">10) <span class="string">"4"</span></span><br><span class="line">11) <span class="string">"70"</span></span><br><span class="line">12) <span class="string">"mary"</span></span><br></pre></td></tr></table></figure></p><h5 id="获取外部键，但不进行排序"><a href="#获取外部键，但不进行排序" class="headerlink" title="获取外部键，但不进行排序"></a>获取外部键，但不进行排序</h5><p>通过将一个不存在的键作为参数传给 BY 选项， 可以让 SORT 跳过排序操作， 直接返回结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SORT uid BY not-exists-key</span><br><span class="line">1) <span class="string">"4"</span></span><br><span class="line">2) <span class="string">"3"</span></span><br><span class="line">3) <span class="string">"2"</span></span><br><span class="line">4) <span class="string">"1"</span></span><br></pre></td></tr></table></figure></p><p>这种用法在单独使用时，没什么实际用处。</p><p>不过，通过将这种用法和 GET 选项配合， 就可以在不排序的情况下， 获取多个外部键， 相当于执行一个整合的获取操作（类似于 SQL 数据库的 join 关键字）。</p><p>以下代码演示了，如何在不引起排序的情况下，使用 SORT 、 BY 和 GET 获取多个外部键：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SORT uid BY not-exists-key GET <span class="comment"># GET user_level_* GET user_name_*</span></span><br><span class="line">1) <span class="string">"4"</span>      <span class="comment"># id</span></span><br><span class="line">2) <span class="string">"70"</span>     <span class="comment"># level</span></span><br><span class="line">3) <span class="string">"mary"</span>   <span class="comment"># name</span></span><br><span class="line">4) <span class="string">"3"</span></span><br><span class="line">5) <span class="string">"25"</span></span><br><span class="line">6) <span class="string">"peter"</span></span><br><span class="line">7) <span class="string">"2"</span></span><br><span class="line">8) <span class="string">"10"</span></span><br><span class="line">9) <span class="string">"jack"</span></span><br><span class="line">10) <span class="string">"1"</span></span><br><span class="line">11) <span class="string">"9999"</span></span><br><span class="line">12) <span class="string">"admin"</span></span><br></pre></td></tr></table></figure></p><h5 id="将哈希表作为-GET-或-BY-的参数"><a href="#将哈希表作为-GET-或-BY-的参数" class="headerlink" title="将哈希表作为 GET 或 BY 的参数"></a>将哈希表作为 GET 或 BY 的参数</h5><p>除了可以将字符串键之外， 哈希表也可以作为 GET 或 BY 选项的参数来使用。</p><p>比如说，对于前面给出的用户信息表：</p><p>我们可以不将用户的名字和级别保存在 user_name_{uid} 和 user_level_{uid} 两个字符串键中， 而是用一个带有 name 域和 level 域的哈希表 user_info_{uid} 来保存用户的名字和级别信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; HMSET user_info_1 name admin level 9999</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; HMSET user_info_2 name jack level 10</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; HMSET user_info_3 name peter level 25</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; HMSET user_info_4 name mary level 70</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p><p>之后， BY 和 GET 选项都可以用 key-&gt;field 的格式来获取哈希表中的域的值， 其中 key 表示哈希表键， 而 field 则表示哈希表的域：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SORT uid BY user_info_*-&gt;level</span><br><span class="line">1) <span class="string">"2"</span></span><br><span class="line">2) <span class="string">"3"</span></span><br><span class="line">3) <span class="string">"4"</span></span><br><span class="line">4) <span class="string">"1"</span></span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SORT uid BY user_info_*-&gt;level GET user_info_*-&gt;name</span><br><span class="line">1) <span class="string">"jack"</span></span><br><span class="line">2) <span class="string">"peter"</span></span><br><span class="line">3) <span class="string">"mary"</span></span><br><span class="line">4) <span class="string">"admin"</span></span><br></pre></td></tr></table></figure></p><h4 id="保存排序结果"><a href="#保存排序结果" class="headerlink" title="保存排序结果"></a>保存排序结果</h4><p>默认情况下， SORT 操作只是简单地返回排序结果，并不进行任何保存操作。</p><p>通过给 STORE 选项指定一个 key 参数，可以将排序结果保存到给定的键上。</p><p>如果被指定的 key 已存在，那么原有的值将被排序结果覆盖。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试数据</span></span><br><span class="line">redis 127.0.0.1:6379&gt; RPUSH numbers 1 3 5 7 9</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; RPUSH numbers 2 4 6 8 10</span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; LRANGE numbers 0 -1</span><br><span class="line">1) <span class="string">"1"</span></span><br><span class="line">2) <span class="string">"3"</span></span><br><span class="line">3) <span class="string">"5"</span></span><br><span class="line">4) <span class="string">"7"</span></span><br><span class="line">5) <span class="string">"9"</span></span><br><span class="line">6) <span class="string">"2"</span></span><br><span class="line">7) <span class="string">"4"</span></span><br><span class="line">8) <span class="string">"6"</span></span><br><span class="line">9) <span class="string">"8"</span></span><br><span class="line">10) <span class="string">"10"</span></span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SORT numbers STORE sorted-numbers</span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 排序后的结果</span></span><br><span class="line">redis 127.0.0.1:6379&gt; LRANGE sorted-numbers 0 -1</span><br><span class="line">1) <span class="string">"1"</span></span><br><span class="line">2) <span class="string">"2"</span></span><br><span class="line">3) <span class="string">"3"</span></span><br><span class="line">4) <span class="string">"4"</span></span><br><span class="line">5) <span class="string">"5"</span></span><br><span class="line">6) <span class="string">"6"</span></span><br><span class="line">7) <span class="string">"7"</span></span><br><span class="line">8) <span class="string">"8"</span></span><br><span class="line">9) <span class="string">"9"</span></span><br><span class="line">10) <span class="string">"10"</span></span><br></pre></td></tr></table></figure></p><p>可以通过将 SORT 命令的执行结果保存，并用 EXPIRE key seconds 为结果设置生存时间，以此来产生一个 SORT 操作的结果缓存。</p><p>这样就可以避免对 SORT 操作的频繁调用：只有当结果集过期时，才需要再调用一次 SORT 操作。</p><p>另外，为了正确实现这一用法，你可能需要加锁以避免多个客户端同时进行缓存重建(也就是多个客户端，同一时间进行 SORT 操作，并保存为结果集)，具体参见 SETNX key value 命令。</p><h4 id="返回值-105"><a href="#返回值-105" class="headerlink" title="返回值"></a>返回值</h4><p>没有使用 STORE 参数，返回列表形式的排序结果。 使用 STORE 参数，返回排序结果的元素数量。</p><h3 id="FLUSHDB"><a href="#FLUSHDB" class="headerlink" title="FLUSHDB"></a>FLUSHDB</h3><h4 id="FLUSHDB-1"><a href="#FLUSHDB-1" class="headerlink" title="FLUSHDB"></a>FLUSHDB</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>清空当前数据库中的所有 key。</p><p>此命令从不失败。</p><h4 id="返回值-106"><a href="#返回值-106" class="headerlink" title="返回值"></a>返回值</h4><p>总是返回 OK 。</p><h4 id="代码示例-100"><a href="#代码示例-100" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; DBSIZE    <span class="comment"># 清空前的 key 数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line"></span><br><span class="line">redis&gt; FLUSHDB</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; DBSIZE    <span class="comment"># 清空后的 key 数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><h3 id="FLUSHALL"><a href="#FLUSHALL" class="headerlink" title="FLUSHALL"></a>FLUSHALL</h3><h4 id="FLUSHALL-1"><a href="#FLUSHALL-1" class="headerlink" title="FLUSHALL"></a>FLUSHALL</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(N)</code></pre><p>清空整个 Redis 服务器的数据(删除所有数据库的所有 key )。</p><p>此命令从不失败。</p><h4 id="返回值-107"><a href="#返回值-107" class="headerlink" title="返回值"></a>返回值</h4><p>总是返回 OK 。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; DBSIZE            <span class="comment"># 0 号数据库的 key 数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 9</span><br><span class="line"></span><br><span class="line">redis&gt; SELECT 1          <span class="comment"># 切换到 1 号数据库</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis[1]&gt; DBSIZE         <span class="comment"># 1 号数据库的 key 数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line"></span><br><span class="line">redis[1]&gt; flushall       <span class="comment"># 清空所有数据库的所有 key</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis[1]&gt; DBSIZE         <span class="comment"># 不但 1 号数据库被清空了</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis[1]&gt; SELECT 0       <span class="comment"># 0 号数据库(以及其他所有数据库)也一样</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; DBSIZE</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure></p><h3 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h3><h4 id="SELECT-index"><a href="#SELECT-index" class="headerlink" title="SELECT index"></a>SELECT index</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>切换到指定的数据库，数据库索引号 index 用数字值指定，以 0 作为起始索引值。</p><p>默认使用 0 号数据库。</p><h4 id="返回值-108"><a href="#返回值-108" class="headerlink" title="返回值"></a>返回值</h4><p>OK</p><h4 id="代码示例-101"><a href="#代码示例-101" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET db_number 0         <span class="comment"># 默认使用 0 号数据库</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SELECT 1                <span class="comment"># 使用 1 号数据库</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis[1]&gt; GET db_number        <span class="comment"># 已经切换到 1 号数据库，注意 Redis 现在的命令提示符多了个 [1]</span></span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line">redis[1]&gt; SET db_number 1</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis[1]&gt; GET db_number</span><br><span class="line"><span class="string">"1"</span></span><br><span class="line"></span><br><span class="line">redis[1]&gt; SELECT 3             <span class="comment"># 再切换到 3 号数据库</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis[3]&gt;                      <span class="comment"># 提示符从 [1] 改变成了 [3]</span></span><br></pre></td></tr></table></figure><h3 id="SWAPDB"><a href="#SWAPDB" class="headerlink" title="SWAPDB"></a>SWAPDB</h3><h4 id="SWAPDB-db1-db2"><a href="#SWAPDB-db1-db2" class="headerlink" title="SWAPDB db1 db2"></a>SWAPDB db1 db2</h4><pre><code>版本要求： &gt;= 4.0.0时间复杂度： O(1)</code></pre><p>对换指定的两个数据库， 使得两个数据库的数据立即互换。</p><h4 id="返回值-109"><a href="#返回值-109" class="headerlink" title="返回值"></a>返回值</h4><p>OK</p><h4 id="代码示例-102"><a href="#代码示例-102" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对换数据库 0 和数据库 1</span></span><br><span class="line">redis&gt; SWAPDB 0 1</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h2 id="自动过期"><a href="#自动过期" class="headerlink" title="自动过期"></a>自动过期</h2><h3 id="EXPIRE"><a href="#EXPIRE" class="headerlink" title="EXPIRE"></a>EXPIRE</h3><h4 id="EXPIRE-key-seconds"><a href="#EXPIRE-key-seconds" class="headerlink" title="EXPIRE key seconds"></a>EXPIRE key seconds</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>为给定 key 设置生存时间，当 key 过期时(生存时间为 0 )，它会被自动删除。</p><p>在 Redis 中，带有生存时间的 key 被称为『易失的』(volatile)。</p><p>生存时间可以通过使用 DEL 命令来删除整个 key 来移除，或者被 SET 和 GETSET 命令覆写(overwrite)，这意味着，如果一个命令只是修改(alter)一个带生存时间的 key 的值而不是用一个新的 key 值来代替(replace)它的话，那么生存时间不会被改变。</p><p>比如说，对一个 key 执行 INCR 命令，对一个列表进行 LPUSH 命令，或者对一个哈希表执行 HSET 命令，这类操作都不会修改 key 本身的生存时间。</p><p>另一方面，如果使用 RENAME 对一个 key 进行改名，那么改名后的 key 的生存时间和改名前一样。</p><p>RENAME 命令的另一种可能是，尝试将一个带生存时间的 key 改名成另一个带生存时间的 another_key ，这时旧的 another_key (以及它的生存时间)会被删除，然后旧的 key 会改名为 another_key ，因此，新的 another_key 的生存时间也和原本的 key 一样。</p><p>使用 PERSIST 命令可以在不删除 key 的情况下，移除 key 的生存时间，让 key 重新成为一个『持久的』(persistent) key 。</p><h4 id="更新生存时间"><a href="#更新生存时间" class="headerlink" title="更新生存时间"></a>更新生存时间</h4><p>可以对一个已经带有生存时间的 key 执行 EXPIRE 命令，新指定的生存时间会取代旧的生存时间。</p><h4 id="过期时间的精确度"><a href="#过期时间的精确度" class="headerlink" title="过期时间的精确度"></a>过期时间的精确度</h4><p>在 Redis 2.4 版本中，过期时间的延迟在 1 秒钟之内 —— 也即是，就算 key 已经过期，但它还是可能在过期之后一秒钟之内被访问到，而在新的 Redis 2.6 版本中，延迟被降低到 1 毫秒之内。</p><h4 id="Redis-2-1-3-之前的不同之处"><a href="#Redis-2-1-3-之前的不同之处" class="headerlink" title="Redis 2.1.3 之前的不同之处"></a>Redis 2.1.3 之前的不同之处</h4><p>在 Redis 2.1.3 之前的版本中，修改一个带有生存时间的 key 会导致整个 key 被删除，这一行为是受当时复制(replication)层的限制而作出的，现在这一限制已经被修复。</p><h4 id="返回值-110"><a href="#返回值-110" class="headerlink" title="返回值"></a>返回值</h4><p>设置成功返回 1 。 当 key 不存在或者不能为 key 设置生存时间时(比如在低于 2.1.3 版本的 Redis 中你尝试更新 key 的生存时间)，返回 0 。</p><h4 id="代码示例-103"><a href="#代码示例-103" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET cache_page <span class="string">"www.google.com"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; EXPIRE cache_page 30  <span class="comment"># 设置过期时间为 30 秒</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; TTL cache_page    <span class="comment"># 查看剩余生存时间</span></span><br><span class="line">(<span class="built_in">integer</span>) 23</span><br><span class="line"></span><br><span class="line">redis&gt; EXPIRE cache_page 30000   <span class="comment"># 更新过期时间</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; TTL cache_page</span><br><span class="line">(<span class="built_in">integer</span>) 29996</span><br></pre></td></tr></table></figure><h4 id="模式：导航会话"><a href="#模式：导航会话" class="headerlink" title="模式：导航会话"></a>模式：导航会话</h4><p>假设你有一项 web 服务，打算根据用户最近访问的 N 个页面来进行物品推荐，并且假设用户停止阅览超过 60 秒，那么就清空阅览记录(为了减少物品推荐的计算量，并且保持推荐物品的新鲜度)。</p><p>这些最近访问的页面记录，我们称之为『导航会话』(Navigation session)，可以用 INCR 和 RPUSH 命令在 Redis 中实现它：每当用户阅览一个网页的时候，执行以下代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MULTI</span><br><span class="line">    RPUSH pagewviews.user:&lt;userid&gt; http://.....</span><br><span class="line">    EXPIRE pagewviews.user:&lt;userid&gt; 60</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure></p><p>如果用户停止阅览超过 60 秒，那么它的导航会话就会被清空，当用户重新开始阅览的时候，系统又会重新记录导航会话，继续进行物品推荐。</p><h3 id="EXPIREAT"><a href="#EXPIREAT" class="headerlink" title="EXPIREAT"></a>EXPIREAT</h3><h4 id="EXPIREAT-key-timestamp"><a href="#EXPIREAT-key-timestamp" class="headerlink" title="EXPIREAT key timestamp"></a>EXPIREAT key timestamp</h4><pre><code>可用版本： &gt;= 1.2.0时间复杂度： O(1)</code></pre><p>EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置生存时间。</p><p>不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。</p><h4 id="返回值-111"><a href="#返回值-111" class="headerlink" title="返回值"></a>返回值</h4><p>如果生存时间设置成功，返回 1 ； 当 key 不存在或没办法设置生存时间，返回 0 。</p><h4 id="代码示例-104"><a href="#代码示例-104" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET cache www.google.com</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; EXPIREAT cache 1355292000     <span class="comment"># 这个 key 将在 2012.12.12 过期</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; TTL cache</span><br><span class="line">(<span class="built_in">integer</span>) 45081860</span><br></pre></td></tr></table></figure><h3 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h3><h4 id="TTL-key"><a href="#TTL-key" class="headerlink" title="TTL key"></a>TTL key</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。</p><h4 id="返回值-112"><a href="#返回值-112" class="headerlink" title="返回值"></a>返回值</h4><p>当 key 不存在时，返回 -2 。 当 key 存在但没有设置剩余生存时间时，返回 -1 。 否则，以秒为单位，返回 key 的剩余生存时间。</p><h4 id="Note-6"><a href="#Note-6" class="headerlink" title="Note"></a>Note</h4><p>在 Redis 2.8 以前，当 key 不存在，或者 key 没有设置剩余生存时间时，命令都返回 -1 。</p><h4 id="代码示例-105"><a href="#代码示例-105" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不存在的 key</span></span><br><span class="line">redis&gt; FLUSHDB</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; TTL key</span><br><span class="line">(<span class="built_in">integer</span>) -2</span><br><span class="line"></span><br><span class="line"><span class="comment"># key 存在，但没有设置剩余生存时间</span></span><br><span class="line">redis&gt; SET key value</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; TTL key</span><br><span class="line">(<span class="built_in">integer</span>) -1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有剩余生存时间的 key</span></span><br><span class="line">redis&gt; EXPIRE key 10086</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; TTL key</span><br><span class="line">(<span class="built_in">integer</span>) 10084</span><br></pre></td></tr></table></figure><h3 id="PERSIST"><a href="#PERSIST" class="headerlink" title="PERSIST"></a>PERSIST</h3><h4 id="PERSIST-key"><a href="#PERSIST-key" class="headerlink" title="PERSIST key"></a>PERSIST key</h4><pre><code>可用版本： &gt;= 2.2.0时间复杂度： O(1)</code></pre><p>移除给定 key 的生存时间，将这个 key 从“易失的”(带生存时间 key )转换成“持久的”(一个不带生存时间、永不过期的 key )。</p><h4 id="返回值-113"><a href="#返回值-113" class="headerlink" title="返回值"></a>返回值</h4><p>当生存时间移除成功时，返回 1 . 如果 key 不存在或 key 没有设置生存时间，返回 0 。</p><h4 id="代码示例-106"><a href="#代码示例-106" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET mykey <span class="string">"Hello"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; EXPIRE mykey 10  <span class="comment"># 为 key 设置生存时间</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; TTL mykey</span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line"></span><br><span class="line">redis&gt; PERSIST mykey    <span class="comment"># 移除 key 的生存时间</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; TTL mykey</span><br><span class="line">(<span class="built_in">integer</span>) -1</span><br></pre></td></tr></table></figure><h3 id="PEXPIRE"><a href="#PEXPIRE" class="headerlink" title="PEXPIRE"></a>PEXPIRE</h3><h4 id="PEXPIRE-key-milliseconds"><a href="#PEXPIRE-key-milliseconds" class="headerlink" title="PEXPIRE key milliseconds"></a>PEXPIRE key milliseconds</h4><pre><code>可用版本： &gt;= 2.6.0时间复杂度： O(1)</code></pre><p>这个命令和 EXPIRE 命令的作用类似，但是它以毫秒为单位设置 key 的生存时间，而不像 EXPIRE 命令那样，以秒为单位。</p><h4 id="返回值-114"><a href="#返回值-114" class="headerlink" title="返回值"></a>返回值</h4><p>设置成功，返回 1 key 不存在或设置失败，返回 0</p><h4 id="代码示例-107"><a href="#代码示例-107" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET mykey <span class="string">"Hello"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; PEXPIRE mykey 1500</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; TTL mykey    <span class="comment"># TTL 的返回值以秒为单位</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; PTTL mykey   <span class="comment"># PTTL 可以给出准确的毫秒数</span></span><br><span class="line">(<span class="built_in">integer</span>) 1499</span><br></pre></td></tr></table></figure><h3 id="PEXPIREAT"><a href="#PEXPIREAT" class="headerlink" title="PEXPIREAT"></a>PEXPIREAT</h3><h4 id="PEXPIREAT-key-milliseconds-timestamp"><a href="#PEXPIREAT-key-milliseconds-timestamp" class="headerlink" title="PEXPIREAT key milliseconds-timestamp"></a>PEXPIREAT key milliseconds-timestamp</h4><pre><code>可用版本： &gt;= 2.6.0时间复杂度： O(1)</code></pre><p>这个命令和 expireat 命令类似，但它以毫秒为单位设置 key 的过期 unix 时间戳，而不是像 expireat 那样，以秒为单位。</p><h4 id="返回值-115"><a href="#返回值-115" class="headerlink" title="返回值"></a>返回值</h4><p>如果生存时间设置成功，返回 1 。 当 key 不存在或没办法设置生存时间时，返回 0 。(查看 EXPIRE key seconds 命令获取更多信息)</p><h4 id="代码示例-108"><a href="#代码示例-108" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET mykey <span class="string">"Hello"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; PEXPIREAT mykey 1555555555005</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; TTL mykey           <span class="comment"># TTL 返回秒</span></span><br><span class="line">(<span class="built_in">integer</span>) 223157079</span><br><span class="line"></span><br><span class="line">redis&gt; PTTL mykey          <span class="comment"># PTTL 返回毫秒</span></span><br><span class="line">(<span class="built_in">integer</span>) 223157079318</span><br></pre></td></tr></table></figure><h3 id="PTTL"><a href="#PTTL" class="headerlink" title="PTTL"></a>PTTL</h3><h4 id="PTTL-key"><a href="#PTTL-key" class="headerlink" title="PTTL key"></a>PTTL key</h4><pre><code>可用版本： &gt;= 2.6.0复杂度： O(1)</code></pre><p>这个命令类似于 TTL 命令，但它以毫秒为单位返回 key 的剩余生存时间，而不是像 TTL 命令那样，以秒为单位。</p><h4 id="返回值-116"><a href="#返回值-116" class="headerlink" title="返回值"></a>返回值</h4><ul><li>当 key 不存在时，返回 -2 。</li><li>当 key 存在但没有设置剩余生存时间时，返回 -1 。</li><li>否则，以毫秒为单位，返回 key 的剩余生存时间。<h4 id="Note-7"><a href="#Note-7" class="headerlink" title="Note"></a>Note</h4></li></ul><p>在 Redis 2.8 以前，当 key 不存在，或者 key 没有设置剩余生存时间时，命令都返回 -1 。</p><h4 id="代码示例-109"><a href="#代码示例-109" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不存在的 key</span></span><br><span class="line">redis&gt; FLUSHDB</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; PTTL key</span><br><span class="line">(<span class="built_in">integer</span>) -2</span><br><span class="line"></span><br><span class="line"><span class="comment"># key 存在，但没有设置剩余生存时间</span></span><br><span class="line">redis&gt; SET key value</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; PTTL key</span><br><span class="line">(<span class="built_in">integer</span>) -1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有剩余生存时间的 key</span></span><br><span class="line">redis&gt; PEXPIRE key 10086</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; PTTL key</span><br><span class="line">(<span class="built_in">integer</span>) 6179</span><br></pre></td></tr></table></figure><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="MULTI"><a href="#MULTI" class="headerlink" title="MULTI"></a>MULTI</h3><h4 id="MULTI-1"><a href="#MULTI-1" class="headerlink" title="MULTI"></a>MULTI</h4><pre><code>可用版本：&gt;= 1.2.0时间复杂度：O(1)。</code></pre><p>标记一个事务块的开始。</p><p>事务块内的多条命令会按照先后顺序被放进一个队列当中，最后由 EXEC 命令原子性(atomic)地执行。</p><h4 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a>返回值：</h4><p>总是返回 OK 。</p><h4 id="代码示例-110"><a href="#代码示例-110" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MULTI            <span class="comment"># 标记事务开始</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; INCR user_id     <span class="comment"># 多条命令按顺序入队</span></span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; INCR user_id</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; INCR user_id</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; PING</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; EXEC             <span class="comment"># 执行</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 1</span><br><span class="line">2) (<span class="built_in">integer</span>) 2</span><br><span class="line">3) (<span class="built_in">integer</span>) 3</span><br><span class="line">4) PONG</span><br></pre></td></tr></table></figure><h3 id="EXEC"><a href="#EXEC" class="headerlink" title="EXEC"></a>EXEC</h3><h4 id="EXEC-1"><a href="#EXEC-1" class="headerlink" title="EXEC"></a>EXEC</h4><pre><code>可用版本：&gt;= 1.2.0时间复杂度：事务块内所有命令的时间复杂度的总和。</code></pre><p>执行所有事务块内的命令。</p><p>假如某个(或某些) key 正处于 WATCH 命令的监视之下，且事务块中有和这个(或这些) key 相关的命令，那么 EXEC 命令只在这个(或这些) key 没有被其他命令所改动的情况下执行并生效，否则该事务被打断(abort)。</p><h4 id="返回值：-1"><a href="#返回值：-1" class="headerlink" title="返回值："></a>返回值：</h4><p>事务块内所有命令的返回值，按命令执行的先后顺序排列。<br>当操作被打断时，返回空值 nil 。</p><h4 id="代码示例-111"><a href="#代码示例-111" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 事务被成功执行</span></span><br><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; INCR user_id</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; INCR user_id</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; INCR user_id</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; PING</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; EXEC</span><br><span class="line">1) (<span class="built_in">integer</span>) 1</span><br><span class="line">2) (<span class="built_in">integer</span>) 2</span><br><span class="line">3) (<span class="built_in">integer</span>) 3</span><br><span class="line">4) PONG</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监视 key ，且事务成功执行</span></span><br><span class="line">redis&gt; WATCH lock lock_times</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SET lock <span class="string">"huangz"</span></span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; INCR lock_times</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; EXEC</span><br><span class="line">1) OK</span><br><span class="line">2) (<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监视 key ，且事务被打断</span></span><br><span class="line">redis&gt; WATCH lock lock_times</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SET lock <span class="string">"joe"</span>        <span class="comment"># 就在这时，另一个客户端修改了 lock_times 的值</span></span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; INCR lock_times</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; EXEC                  <span class="comment"># 因为 lock_times 被修改， joe 的事务执行失败</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h3 id="DISCARD"><a href="#DISCARD" class="headerlink" title="DISCARD"></a>DISCARD</h3><h4 id="DISCARD-1"><a href="#DISCARD-1" class="headerlink" title="DISCARD"></a>DISCARD</h4><pre><code>可用版本： &gt;= 2.0.0时间复杂度： O(1)。</code></pre><p>取消事务，放弃执行事务块内的所有命令。</p><p>如果正在使用 WATCH 命令监视某个(或某些) key，那么取消所有监视，等同于执行命令 UNWATCH 。</p><h4 id="返回值-117"><a href="#返回值-117" class="headerlink" title="返回值"></a>返回值</h4><p>总是返回 OK 。</p><h4 id="代码示例-112"><a href="#代码示例-112" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; PING</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; SET greeting <span class="string">"hello"</span></span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; DISCARD</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h3 id="WATCH"><a href="#WATCH" class="headerlink" title="WATCH"></a>WATCH</h3><h4 id="WATCH-key-key-…"><a href="#WATCH-key-key-…" class="headerlink" title="WATCH key [key …]"></a>WATCH key [key …]</h4><pre><code>可用版本：&gt;= 2.2.0时间复杂度：O(1)。</code></pre><p>监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</p><h4 id="返回值：-2"><a href="#返回值：-2" class="headerlink" title="返回值："></a>返回值：</h4><p>总是返回 OK 。</p><h4 id="代码示例-113"><a href="#代码示例-113" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; WATCH lock lock_times</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h3 id="UNWATCH"><a href="#UNWATCH" class="headerlink" title="UNWATCH"></a>UNWATCH</h3><h4 id="UNWATCH-1"><a href="#UNWATCH-1" class="headerlink" title="UNWATCH"></a>UNWATCH</h4><pre><code>可用版本：&gt;= 2.2.0时间复杂度：O(1)</code></pre><p>取消 WATCH 命令对所有 key 的监视。</p><p>如果在执行 WATCH 命令之后， EXEC 命令或 DISCARD 命令先被执行了的话，那么就不需要再执行 UNWATCH 了。</p><p>因为 EXEC 命令会执行事务，因此 WATCH 命令的效果已经产生了；而 DISCARD 命令在取消事务的同时也会取消所有对 key 的监视，因此这两个命令执行之后，就没有必要执行 UNWATCH 了。</p><h4 id="返回值：-3"><a href="#返回值：-3" class="headerlink" title="返回值："></a>返回值：</h4><p>总是 OK 。</p><h4 id="代码示例-114"><a href="#代码示例-114" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; WATCH lock lock_times</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; UNWATCH</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h2 id="Lua-脚本"><a href="#Lua-脚本" class="headerlink" title="Lua 脚本"></a>Lua 脚本</h2><h3 id="EVAL"><a href="#EVAL" class="headerlink" title="EVAL"></a>EVAL</h3><h4 id="EVAL-script-numkeys-key-key-…-arg-arg-…"><a href="#EVAL-script-numkeys-key-key-…-arg-arg-…" class="headerlink" title="EVAL script numkeys key [key …] arg [arg …]"></a>EVAL script numkeys key [key …] arg [arg …]</h4><pre><code>可用版本： &gt;= 2.6.0时间复杂度： EVAL 和 EVALSHA 可以在 O(1) 复杂度内找到要被执行的脚本，其余的复杂度取决于执行的脚本本身。</code></pre><p>从 Redis 2.6.0 版本开始，通过内置的 Lua 解释器，可以使用 EVAL 命令对 Lua 脚本进行求值。</p><p>script 参数是一段 Lua 5.1 脚本程序，它会被运行在 Redis 服务器上下文中，这段脚本不必(也不应该)定义为一个 Lua 函数。</p><p>numkeys 参数用于指定键名参数的个数。</p><p>键名参数 key [key …] 从 EVAL 的第三个参数开始算起，表示在脚本中所用到的那些 Redis 键(key)，这些键名参数可以在 Lua 中通过全局变量 KEYS 数组，用 1 为基址的形式访问( KEYS[1] ， KEYS[2] ，以此类推)。</p><p>在命令的最后，那些不是键名参数的附加参数 arg [arg …] ，可以在 Lua 中通过全局变量 ARGV 数组访问，访问的形式和 KEYS 变量类似( ARGV[1] 、 ARGV[2] ，诸如此类)。</p><p>上面这几段长长的说明可以用一个简单的例子来概括：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">eval</span> <span class="string">"return &#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;"</span> 2 key1 key2 first second</span><br><span class="line">1) <span class="string">"key1"</span></span><br><span class="line">2) <span class="string">"key2"</span></span><br><span class="line">3) <span class="string">"first"</span></span><br><span class="line">4) <span class="string">"second"</span></span><br></pre></td></tr></table></figure></p><p>其中 “return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}” 是被求值的 Lua 脚本，数字 2 指定了键名参数的数量， key1 和 key2 是键名参数，分别使用 KEYS[1] 和 KEYS[2] 访问，而最后的 first 和 second 则是附加参数，可以通过 ARGV[1] 和 ARGV[2] 访问它们。</p><p>在 Lua 脚本中，可以使用两个不同函数来执行 Redis 命令，它们分别是：</p><ul><li>redis.call()</li><li>redis.pcall()<br>这两个函数的唯一区别在于它们使用不同的方式处理执行命令所产生的错误，在后面的『错误处理』部分会讲到这一点。</li></ul><p>redis.call() 和 redis.pcall() 两个函数的参数可以是任何格式良好(well formed)的 Redis 命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">eval</span> <span class="string">"return redis.call('set','foo','bar')"</span> 0</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p><p>需要注意的是，上面这段脚本的确实现了将键 foo 的值设为 bar 的目的，但是，它违反了 EVAL 命令的语义，因为脚本里使用的所有键都应该由 KEYS 数组来传递，就像这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">eval</span> <span class="string">"return redis.call('set',KEYS[1],'bar')"</span> 1 foo</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p><p>要求使用正确的形式来传递键(key)是有原因的，因为不仅仅是 EVAL 这个命令，所有的 Redis 命令，在执行之前都会被分析，籍此来确定命令会对哪些键进行操作。</p><p>因此，对于 EVAL 命令来说，必须使用正确的形式来传递键，才能确保分析工作正确地执行。除此之外，使用正确的形式来传递键还有很多其他好处，它的一个特别重要的用途就是确保 Redis 集群可以将你的请求发送到正确的集群节点。(对 Redis 集群的工作还在进行当中，但是脚本功能被设计成可以与集群功能保持兼容。)不过，这条规矩并不是强制性的，从而使得用户有机会滥用(abuse) Redis 单实例配置(single instance configuration)，代价是这样写出的脚本不能被 Redis 集群所兼容。</p><h4 id="在-Lua-数据类型和-Redis-数据类型之间转换"><a href="#在-Lua-数据类型和-Redis-数据类型之间转换" class="headerlink" title="在 Lua 数据类型和 Redis 数据类型之间转换"></a>在 Lua 数据类型和 Redis 数据类型之间转换</h4><p>当 Lua 通过 call() 或 pcall() 函数执行 Redis 命令的时候，命令的返回值会被转换成 Lua 数据结构。同样地，当 Lua 脚本在 Redis 内置的解释器里运行时，Lua 脚本的返回值也会被转换成 Redis 协议(protocol)，然后由 EVAL 将值返回给客户端。</p><p>数据类型之间的转换遵循这样一个设计原则：如果将一个 Redis 值转换成 Lua 值，之后再将转换所得的 Lua 值转换回 Redis 值，那么这个转换所得的 Redis 值应该和最初时的 Redis 值一样。</p><p>换句话说， Lua 类型和 Redis 类型之间存在着一一对应的转换关系。</p><p>以下列出的是详细的转换规则：</p><p>从 Redis 转换到 Lua ：</p><ul><li>Redis integer reply -&gt; Lua number / Redis 整数转换成 Lua 数字</li><li>Redis bulk reply -&gt; Lua string / Redis bulk 回复转换成 Lua 字符串</li><li>Redis multi bulk reply -&gt; Lua table (may have other Redis data types nested) / Redis 多条 bulk 回复转换成 Lua 表，表内可能有其他别的 Redis 数据类型</li><li>Redis status reply -&gt; Lua table with a single ok field containing the status / Redis 状态回复转换成 Lua 表，表内的 ok 域包含了状态信息</li><li>Redis error reply -&gt; Lua table with a single err field containing the error / Redis 错误回复转换成 Lua 表，表内的 err 域包含了错误信息</li><li><p>Redis Nil bulk reply and Nil multi bulk reply -&gt; Lua false boolean type / Redis 的 Nil 回复和 Nil 多条回复转换成 Lua 的布尔值 false<br>从 Lua 转换到 Redis：</p></li><li><p>Lua number -&gt; Redis integer reply / Lua 数字转换成 Redis 整数</p></li><li>Lua string -&gt; Redis bulk reply / Lua 字符串转换成 Redis bulk 回复</li><li>Lua table (array) -&gt; Redis multi bulk reply / Lua 表(数组)转换成 Redis 多条 bulk 回复</li><li>Lua table with a single ok field -&gt; Redis status reply / 一个带单个 ok 域的 Lua 表，转换成 Redis 状态回复</li><li>Lua table with a single err field -&gt; Redis error reply / 一个带单个 err 域的 Lua 表，转换成 Redis 错误回复</li><li><p>Lua boolean false -&gt; Redis Nil bulk reply / Lua 的布尔值 false 转换成 Redis 的 Nil bulk 回复<br>从 Lua 转换到 Redis 有一条额外的规则，这条规则没有和它对应的从 Redis 转换到 Lua 的规则：</p></li><li><p>Lua boolean true -&gt; Redis integer reply with value of 1 / Lua 布尔值 true 转换成 Redis 整数回复中的 1<br>以下是几个类型转换的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">eval</span> <span class="string">"return 10"</span> 0</span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line"></span><br><span class="line">&gt; <span class="built_in">eval</span> <span class="string">"return &#123;1,2,&#123;3,'Hello World!'&#125;&#125;"</span> 0</span><br><span class="line">1) (<span class="built_in">integer</span>) 1</span><br><span class="line">2) (<span class="built_in">integer</span>) 2</span><br><span class="line">3) 1) (<span class="built_in">integer</span>) 3</span><br><span class="line">   2) <span class="string">"Hello World!"</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="built_in">eval</span> <span class="string">"return redis.call('get','foo')"</span> 0</span><br><span class="line"><span class="string">"bar"</span></span><br></pre></td></tr></table></figure></li></ul><p>在上面的三个代码示例里，前两个演示了如何将 Lua 值转换成 Redis 值，最后一个例子更复杂一些，它演示了一个将 Redis 值转换成 Lua 值，然后再将 Lua 值转换成 Redis 值的类型转过程。</p><h4 id="脚本的原子性"><a href="#脚本的原子性" class="headerlink" title="脚本的原子性"></a>脚本的原子性</h4><p>Redis 使用单个 Lua 解释器去运行所有脚本，并且， Redis 也保证脚本会以原子性(atomic)的方式执行：当某个脚本正在运行的时候，不会有其他脚本或 Redis 命令被执行。这和使用 MULTI / EXEC 包围的事务很类似。在其他别的客户端看来，脚本的效果(effect)要么是不可见的(not visible)，要么就是已完成的(already completed)。</p><p>另一方面，这也意味着，执行一个运行缓慢的脚本并不是一个好主意。写一个跑得很快很顺溜的脚本并不难，因为脚本的运行开销(overhead)非常少，但是当你不得不使用一些跑得比较慢的脚本时，请小心，因为当这些蜗牛脚本在慢吞吞地运行的时候，其他客户端会因为服务器正忙而无法执行命令。</p><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>前面的命令介绍部分说过， redis.call() 和 redis.pcall() 的唯一区别在于它们对错误处理的不同。</p><p>当 redis.call() 在执行命令的过程中发生错误时，脚本会停止执行，并返回一个脚本错误，错误的输出信息会说明错误造成的原因：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; lpush foo a</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; <span class="built_in">eval</span> <span class="string">"return redis.call('get', 'foo')"</span> 0</span><br><span class="line">(error) ERR Error running script (call to f_282297a0228f48cd3fc6a55de6316f31422f5d17): ERR Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure></p><p>和 redis.call() 不同， redis.pcall() 出错时并不引发(raise)错误，而是返回一个带 err 域的 Lua 表(table)，用于表示错误：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; EVAL <span class="string">"return redis.pcall('get', 'foo')"</span> 0</span><br><span class="line">(error) ERR Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure></p><h4 id="带宽和-EVALSHA"><a href="#带宽和-EVALSHA" class="headerlink" title="带宽和 EVALSHA"></a>带宽和 EVALSHA</h4><p>EVAL 命令要求你在每次执行脚本的时候都发送一次脚本主体(script body)。Redis 有一个内部的缓存机制，因此它不会每次都重新编译脚本，不过在很多场合，付出无谓的带宽来传送脚本主体并不是最佳选择。</p><p>为了减少带宽的消耗， Redis 实现了 EVALSHA 命令，它的作用和 EVAL 一样，都用于对脚本求值，但它接受的第一个参数不是脚本，而是脚本的 SHA1 校验和(sum)。</p><h4 id="EVALSHA-命令的表现如下："><a href="#EVALSHA-命令的表现如下：" class="headerlink" title="EVALSHA 命令的表现如下："></a>EVALSHA 命令的表现如下：</h4><ul><li>如果服务器还记得给定的 SHA1 校验和所指定的脚本，那么执行这个脚本</li><li>如果服务器不记得给定的 SHA1 校验和所指定的脚本，那么它返回一个特殊的错误，提醒用户使用 EVAL 代替 EVALSHA<br>以下是示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">set</span> foo bar</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">&gt; <span class="built_in">eval</span> <span class="string">"return redis.call('get','foo')"</span> 0</span><br><span class="line"><span class="string">"bar"</span></span><br><span class="line"></span><br><span class="line">&gt; evalsha 6b1bf486c81ceb7edf3c093f4c48582e38c0e791 0</span><br><span class="line"><span class="string">"bar"</span></span><br><span class="line"></span><br><span class="line">&gt; evalsha ffffffffffffffffffffffffffffffffffffffff 0</span><br><span class="line">(error) `NOSCRIPT` No matching script. Please use [EVAL](/commands/<span class="built_in">eval</span>).</span><br></pre></td></tr></table></figure></li></ul><p>客户端库的底层实现可以一直乐观地使用 EVALSHA 来代替 EVAL ，并期望着要使用的脚本已经保存在服务器上了，只有当 NOSCRIPT 错误发生时，才使用 EVAL 命令重新发送脚本，这样就可以最大限度地节省带宽。</p><p>这也说明了执行 EVAL 命令时，使用正确的格式来传递键名参数和附加参数的重要性：因为如果将参数硬写在脚本中，那么每次当参数改变的时候，都要重新发送脚本，即使脚本的主体并没有改变，相反，通过使用正确的格式来传递键名参数和附加参数，就可以在脚本主体不变的情况下，直接使用 EVALSHA 命令对脚本进行复用，免去了无谓的带宽消耗。</p><h4 id="脚本缓存"><a href="#脚本缓存" class="headerlink" title="脚本缓存"></a>脚本缓存</h4><p>Redis 保证所有被运行过的脚本都会被永久保存在脚本缓存当中，这意味着，当 EVAL 命令在一个 Redis 实例上成功执行某个脚本之后，随后针对这个脚本的所有 EVALSHA 命令都会成功执行。</p><p>刷新脚本缓存的唯一办法是显式地调用 SCRIPT FLUSH 命令，这个命令会清空运行过的所有脚本的缓存。通常只有在云计算环境中，Redis 实例被改作其他客户或者别的应用程序的实例时，才会执行这个命令。</p><p>缓存可以长时间储存而不产生内存问题的原因是，它们的体积非常小，而且数量也非常少，即使脚本在概念上类似于实现一个新命令，即使在一个大规模的程序里有成百上千的脚本，即使这些脚本会经常修改，即便如此，储存这些脚本的内存仍然是微不足道的。</p><p>事实上，用户会发现 Redis 不移除缓存中的脚本实际上是一个好主意。比如说，对于一个和 Redis 保持持久化链接(persistent connection)的程序来说，它可以确信，执行过一次的脚本会一直保留在内存当中，因此它可以在流水线中使用 EVALSHA 命令而不必担心因为找不到所需的脚本而产生错误(稍候我们会看到在流水线中执行脚本的相关问题)。</p><h4 id="SCRIPT-命令"><a href="#SCRIPT-命令" class="headerlink" title="SCRIPT 命令"></a>SCRIPT 命令</h4><p>Redis 提供了以下几个 SCRIPT 命令，用于对脚本子系统(scripting subsystem)进行控制：</p><ul><li>SCRIPT FLUSH ：清除所有脚本缓存</li><li>SCRIPT EXISTS sha1 [sha1 …] ：根据给定的脚本校验和，检查指定的脚本是否存在于脚本缓存</li><li>SCRIPT LOAD script ：将一个脚本装入脚本缓存，但并不立即运行它</li><li>SCRIPT KILL ：杀死当前正在运行的脚本<h4 id="纯函数脚本"><a href="#纯函数脚本" class="headerlink" title="纯函数脚本"></a>纯函数脚本</h4>在编写脚本方面，一个重要的要求就是，脚本应该被写成纯函数(pure function)。</li></ul><p>也就是说，脚本应该具有以下属性：</p><ul><li>对于同样的数据集输入，给定相同的参数，脚本执行的 Redis 写命令总是相同的。脚本执行的操作不能依赖于任何隐藏(非显式)数据，不能依赖于脚本在执行过程中、或脚本在不同执行时期之间可能变更的状态，并且它也不能依赖于任何来自 I/O 设备的外部输入。</li></ul><p>使用系统时间(system time)，调用像 RANDOMKEY 那样的随机命令，或者使用 Lua 的随机数生成器，类似以上的这些操作，都会造成脚本的求值无法每次都得出同样的结果。</p><p>为了确保脚本符合上面所说的属性， Redis 做了以下工作：</p><ul><li>Lua 没有访问系统时间或者其他内部状态的命令</li><li>Redis 会返回一个错误，阻止这样的脚本运行： 这些脚本在执行随机命令之后(比如 RANDOMKEY 、 SRANDMEMBER key [count] 或 TIME 等)，还会执行可以修改数据集的 Redis 命令。如果脚本只是执行只读操作，那么就没有这一限制。注意，随机命令并不一定就指那些带 RAND 字眼的命令，任何带有非确定性的命令都会被认为是随机命令，比如 TIME 命令就是这方面的一个很好的例子。</li><li>每当从 Lua 脚本中调用那些返回无序元素的命令时，执行命令所得的数据在返回给 Lua 之前会先执行一个静默(slient)的字典序排序(lexicographical sorting)。举个例子，因为 Redis 的 Set 保存的是无序的元素，所以在 Redis 命令行客户端中直接执行 SMEMBERS key ，返回的元素是无序的，但是，假如在脚本中执行 redis.call(“smembers”, KEYS[1]) ，那么返回的总是排过序的元素。</li><li>对 Lua 的伪随机数生成函数 math.random 和 math.randomseed 进行修改，使得每次在运行新脚本的时候，总是拥有同样的 seed 值。这意味着，每次运行脚本时，只要不使用 math.randomseed ，那么 math.random 产生的随机数序列总是相同的。</li><li>尽管有那么多的限制，但用户还是可以用一个简单的技巧写出带随机行为的脚本(如果他们需要的话)。</li></ul><p>假设现在我们要编写一个 Redis 脚本，这个脚本从列表中弹出 N 个随机数。一个 Ruby 写的例子如下：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'rubygems'</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'redis'</span></span><br><span class="line"></span><br><span class="line">r = Redis.new</span><br><span class="line"></span><br><span class="line">RandomPushScript = <span class="string">&lt;&lt;EOF</span></span><br><span class="line"><span class="string">    local i = tonumber(ARGV[1])</span></span><br><span class="line"><span class="string">    local res</span></span><br><span class="line"><span class="string">    while (i &gt; 0) do</span></span><br><span class="line"><span class="string">        res = redis.call('lpush',KEYS[1],math.random())</span></span><br><span class="line"><span class="string">        i = i-1</span></span><br><span class="line"><span class="string">    end</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">r.del(<span class="symbol">:mylist</span>)</span><br><span class="line">puts r.eval(RandomPushScript,[<span class="symbol">:mylist</span>],[<span class="number">10</span>,rand(<span class="number">2</span>**<span class="number">32</span>)])</span><br></pre></td></tr></table></figure></p><p>这个程序每次运行都会生成带有以下元素的列表：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; lrange mylist 0 -1</span><br><span class="line">1) <span class="string">"0.74509509873814"</span></span><br><span class="line">2) <span class="string">"0.87390407681181"</span></span><br><span class="line">3) <span class="string">"0.36876626981831"</span></span><br><span class="line">4) <span class="string">"0.6921941534114"</span></span><br><span class="line">5) <span class="string">"0.7857992587545"</span></span><br><span class="line">6) <span class="string">"0.57730350670279"</span></span><br><span class="line">7) <span class="string">"0.87046522734243"</span></span><br><span class="line">8) <span class="string">"0.09637165539729"</span></span><br><span class="line">9) <span class="string">"0.74990198051087"</span></span><br><span class="line">10) <span class="string">"0.17082803611217"</span></span><br></pre></td></tr></table></figure></p><p>上面的 Ruby 程序每次都只生成同样的列表，用途并不是太大。那么，该怎样修改这个脚本，使得它仍然是一个纯函数(符合 Redis 的要求)，但是每次调用都可以产生不同的随机元素呢？</p><p>一个简单的办法是，为脚本添加一个额外的参数，让这个参数作为 Lua 的随机数生成器的 seed 值，这样的话，只要给脚本传入不同的 seed ，脚本就会生成不同的列表元素。</p><p>以下是修改后的脚本：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RandomPushScript = &lt;&lt;EOF</span><br><span class="line">    <span class="built_in">local</span> i = tonumber(ARGV[1])</span><br><span class="line">    <span class="built_in">local</span> res</span><br><span class="line">    math.randomseed(tonumber(ARGV[2]))</span><br><span class="line">    <span class="keyword">while</span> (i &gt; 0) <span class="keyword">do</span></span><br><span class="line">        res = redis.call(<span class="string">'lpush'</span>,KEYS[1],math.random())</span><br><span class="line">        i = i-1</span><br><span class="line">    end</span><br><span class="line">    <span class="built_in">return</span> res</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">r.del(:mylist)</span><br><span class="line">puts r.eval(RandomPushScript,1,:mylist,10,rand(2**32))</span><br></pre></td></tr></table></figure></p><p>尽管对于同样的 seed ，上面的脚本产生的列表元素是一样的(因为它是一个纯函数)，但是只要每次在执行脚本的时候传入不同的 seed ，我们就可以得到带有不同随机元素的列表。</p><p>Seed 会在复制(replication link)和写 AOF 文件时作为一个参数来传播，保证在载入 AOF 文件或附属节点(slave)处理脚本时， seed 仍然可以及时得到更新。</p><p>注意，Redis 实现保证 math.random 和 math.randomseed 的输出和运行 Redis 的系统架构无关，无论是 32 位还是 64 位系统，无论是小端(little endian)还是大端(big endian)系统，这两个函数的输出总是相同的。</p><h4 id="全局变量保护"><a href="#全局变量保护" class="headerlink" title="全局变量保护"></a>全局变量保护</h4><p>为了防止不必要的数据泄漏进 Lua 环境， Redis 脚本不允许创建全局变量。如果一个脚本需要在多次执行之间维持某种状态，它应该使用 Redis key 来进行状态保存。</p><p>企图在脚本中访问一个全局变量(不论这个变量是否存在)将引起脚本停止， EVAL 命令会返回一个错误：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; <span class="built_in">eval</span> <span class="string">'a=10'</span> 0</span><br><span class="line">(error) ERR Error running script (call to f_933044db579a2f8fd45d8065f04a8d0249383e57): user_script:1: Script attempted to create global variable <span class="string">'a'</span></span><br></pre></td></tr></table></figure></p><p>Lua 的 debug 工具，或者其他设施，比如打印（alter）用于实现全局保护的 meta table ，都可以用于实现全局变量保护。</p><p>实现全局变量保护并不难，不过有时候还是会不小心而为之。一旦用户在脚本中混入了 Lua 全局状态，那么 AOF 持久化和复制（replication）都会无法保证，所以，请不要使用全局变量。</p><p>避免引入全局变量的一个诀窍是：将脚本中用到的所有变量都使用 local 关键字定义为局部变量。</p><h4 id="库"><a href="#库" class="headerlink" title="库"></a>库</h4><p>Redis 内置的 Lua 解释器加载了以下 Lua 库：</p><ul><li>base</li><li>table</li><li>string</li><li>math</li><li>debug</li><li>cjson</li><li>cmsgpack<br>其中 cjson 库可以让 Lua 以非常快的速度处理 JSON 数据，除此之外，其他别的都是 Lua 的标准库。</li></ul><p>每个 Redis 实例都保证会加载上面列举的库，从而确保每个 Redis 脚本的运行环境都是相同的。</p><h4 id="使用脚本散发-Redis-日志"><a href="#使用脚本散发-Redis-日志" class="headerlink" title="使用脚本散发 Redis 日志"></a>使用脚本散发 Redis 日志</h4><p>在 Lua 脚本中，可以通过调用 redis.log 函数来写 Redis 日志(log)：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis.log(loglevel, message)</span><br></pre></td></tr></table></figure></p><p>其中， message 参数是一个字符串，而 loglevel 参数可以是以下任意一个值：</p><ul><li>redis.LOG_DEBUG</li><li>redis.LOG_VERBOSE</li><li>redis.LOG_NOTICE</li><li>redis.LOG_WARNING<br>上面的这些等级(level)和标准 Redis 日志的等级相对应。</li></ul><p>对于脚本散发(emit)的日志，只有那些和当前 Redis 实例所设置的日志等级相同或更高级的日志才会被散发。</p><p>以下是一个日志示例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis.log(redis.LOG_WARNING, <span class="string">"Something is wrong with this script."</span>)</span><br></pre></td></tr></table></figure></p><p>执行上面的函数会产生这样的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[32343] 22 Mar 15:21:39 # Something is wrong with this script.</span><br></pre></td></tr></table></figure></p><h4 id="沙箱-sandbox-和最大执行时间"><a href="#沙箱-sandbox-和最大执行时间" class="headerlink" title="沙箱(sandbox)和最大执行时间"></a>沙箱(sandbox)和最大执行时间</h4><p>脚本应该仅仅用于传递参数和对 Redis 数据进行处理，它不应该尝试去访问外部系统(比如文件系统)，或者执行任何系统调用。</p><p>除此之外，脚本还有一个最大执行时间限制，它的默认值是 5 秒钟，一般正常运作的脚本通常可以在几分之几毫秒之内完成，花不了那么多时间，这个限制主要是为了防止因编程错误而造成的无限循环而设置的。</p><p>最大执行时间的长短由 lua-time-limit 选项来控制(以毫秒为单位)，可以通过编辑 redis.conf 文件或者使用 CONFIG GET parameter 和 CONFIG SET parameter value 命令来修改它。</p><p>当一个脚本达到最大执行时间的时候，它并不会自动被 Redis 结束，因为 Redis 必须保证脚本执行的原子性，而中途停止脚本的运行意味着可能会留下未处理完的数据在数据集(data set)里面。</p><p>因此，当脚本运行的时间超过最大执行时间后，以下动作会被执行：</p><ul><li>Redis 记录一个脚本正在超时运行</li><li>Redis 开始重新接受其他客户端的命令请求，但是只有 SCRIPT KILL 和 SHUTDOWN NOSAVE 两个命令会被处理，对于其他命令请求， Redis 服务器只是简单地返回 BUSY 错误。</li><li>可以使用 SCRIPT KILL 命令将一个仅执行只读命令的脚本杀死，因为只读命令并不修改数据，因此杀死这个脚本并不破坏数据的完整性</li><li>如果脚本已经执行过写命令，那么唯一允许执行的操作就是 SHUTDOWN NOSAVE ，它通过停止服务器来阻止当前数据集写入磁盘<h4 id="流水线-pipeline-上下文-context-中的-EVALSHA"><a href="#流水线-pipeline-上下文-context-中的-EVALSHA" class="headerlink" title="流水线(pipeline)上下文(context)中的 EVALSHA"></a>流水线(pipeline)上下文(context)中的 EVALSHA</h4>在流水线请求的上下文中使用 EVALSHA 命令时，要特别小心，因为在流水线中，必须保证命令的执行顺序。</li></ul><p>一旦在流水线中因为 EVALSHA 命令而发生 NOSCRIPT 错误，那么这个流水线就再也没有办法重新执行了，否则的话，命令的执行顺序就会被打乱。</p><p>为了防止出现以上所说的问题，客户端库实现应该实施以下的其中一项措施：</p><ul><li>总是在流水线中使用 EVAL 命令</li><li>检查流水线中要用到的所有命令，找到其中的 EVAL 命令，并使用 SCRIPT EXISTS sha1 [sha1 …] 命令检查要用到的脚本是不是全都已经保存在缓存里面了。如果所需的全部脚本都可以在缓存里找到，那么就可以放心地将所有 EVAL 命令改成 EVALSHA 命令，否则的话，就要在流水线的顶端(top)将缺少的脚本用 SCRIPT LOAD script 命令加上去。</li></ul><h3 id="EVALSHA"><a href="#EVALSHA" class="headerlink" title="EVALSHA"></a>EVALSHA</h3><h4 id="EVALSHA-sha1-numkeys-key-key-…-arg-arg-…"><a href="#EVALSHA-sha1-numkeys-key-key-…-arg-arg-…" class="headerlink" title="EVALSHA sha1 numkeys key [key …] arg [arg …]"></a>EVALSHA sha1 numkeys key [key …] arg [arg …]</h4><pre><code>可用版本： &gt;= 2.6.0时间复杂度： 根据脚本的复杂度而定。</code></pre><p>根据给定的 sha1 校验码，对缓存在服务器中的脚本进行求值。</p><p>将脚本缓存到服务器的操作可以通过 SCRIPT LOAD script 命令进行。</p><p>这个命令的其他地方，比如参数的传入方式，都和 EVAL script numkeys key [key …] arg [arg …] 命令一样。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SCRIPT LOAD <span class="string">"return 'hello moto'"</span></span><br><span class="line"><span class="string">"232fd51614574cf0867b83d384a5e898cfd24e5a"</span></span><br><span class="line"></span><br><span class="line">redis&gt; EVALSHA <span class="string">"232fd51614574cf0867b83d384a5e898cfd24e5a"</span> 0</span><br><span class="line"><span class="string">"hello moto"</span></span><br></pre></td></tr></table></figure></p><h3 id="SCRIPT-LOAD"><a href="#SCRIPT-LOAD" class="headerlink" title="SCRIPT LOAD"></a>SCRIPT LOAD</h3><h4 id="SCRIPT-LOAD-script"><a href="#SCRIPT-LOAD-script" class="headerlink" title="SCRIPT LOAD script"></a>SCRIPT LOAD script</h4><pre><code>可用版本： &gt;= 2.6.0时间复杂度： O(N) , N 为脚本的长度(以字节为单位)。</code></pre><p>将脚本 script 添加到脚本缓存中，但并不立即执行这个脚本。</p><p>EVAL script numkeys key [key …] arg [arg …] 命令也会将脚本添加到脚本缓存中，但是它会立即对输入的脚本进行求值。</p><p>如果给定的脚本已经在缓存里面了，那么不做动作。</p><p>在脚本被加入到缓存之后，通过 EVALSHA 命令，可以使用脚本的 SHA1 校验和来调用这个脚本。</p><p>脚本可以在缓存中保留无限长的时间，直到执行 SCRIPT FLUSH 为止。</p><p>关于使用 Redis 对 Lua 脚本进行求值的更多信息，请参见 EVAL script numkeys key [key …] arg [arg …] 命令。</p><h4 id="返回值-118"><a href="#返回值-118" class="headerlink" title="返回值"></a>返回值</h4><p>给定 script 的 SHA1 校验和。</p><h4 id="代码示例-115"><a href="#代码示例-115" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SCRIPT LOAD <span class="string">"return 'hello moto'"</span></span><br><span class="line"><span class="string">"232fd51614574cf0867b83d384a5e898cfd24e5a"</span></span><br><span class="line"></span><br><span class="line">redis&gt; EVALSHA 232fd51614574cf0867b83d384a5e898cfd24e5a 0</span><br><span class="line"><span class="string">"hello moto"</span></span><br></pre></td></tr></table></figure><h3 id="SCRIPT-EXISTS"><a href="#SCRIPT-EXISTS" class="headerlink" title="SCRIPT EXISTS"></a>SCRIPT EXISTS</h3><h4 id="SCRIPT-EXISTS-sha1-sha1-…"><a href="#SCRIPT-EXISTS-sha1-sha1-…" class="headerlink" title="SCRIPT EXISTS sha1 [sha1 …]"></a>SCRIPT EXISTS sha1 [sha1 …]</h4><pre><code>可用版本： &gt;= 2.6.0时间复杂度： O(N) , N 为给定的 SHA1 校验和的数量。</code></pre><p>给定一个或多个脚本的 SHA1 校验和，返回一个包含 0 和 1 的列表，表示校验和所指定的脚本是否已经被保存在缓存当中。</p><p>关于使用 Redis 对 Lua 脚本进行求值的更多信息，请参见 EVAL script numkeys key [key …] arg [arg …] 命令。</p><h4 id="返回值-119"><a href="#返回值-119" class="headerlink" title="返回值"></a>返回值</h4><p>一个列表，包含 0 和 1 ，前者表示脚本不存在于缓存，后者表示脚本已经在缓存里面了。 列表中的元素和给定的 SHA1 校验和保持对应关系，比如列表的第三个元素的值就表示第三个 SHA1 校验和所指定的脚本在缓存中的状态。</p><h4 id="代码示例-116"><a href="#代码示例-116" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SCRIPT LOAD <span class="string">"return 'hello moto'"</span>    <span class="comment"># 载入一个脚本</span></span><br><span class="line"><span class="string">"232fd51614574cf0867b83d384a5e898cfd24e5a"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SCRIPT EXISTS 232fd51614574cf0867b83d384a5e898cfd24e5a</span><br><span class="line">1) (<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; SCRIPT FLUSH     <span class="comment"># 清空缓存</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SCRIPT EXISTS 232fd51614574cf0867b83d384a5e898cfd24e5a</span><br><span class="line">1) (<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><h3 id="SCRIPT-FLUSH"><a href="#SCRIPT-FLUSH" class="headerlink" title="SCRIPT FLUSH"></a>SCRIPT FLUSH</h3><h4 id="SCRIPT-FLUSH-1"><a href="#SCRIPT-FLUSH-1" class="headerlink" title="SCRIPT FLUSH"></a>SCRIPT FLUSH</h4><pre><code>可用版本： &gt;= 2.6.0复杂度： O(N) ， N 为缓存中脚本的数量。</code></pre><p>清除所有 Lua 脚本缓存。</p><p>关于使用 Redis 对 Lua 脚本进行求值的更多信息，请参见 EVAL script numkeys key [key …] arg [arg …] 命令。</p><h4 id="返回值-120"><a href="#返回值-120" class="headerlink" title="返回值"></a>返回值</h4><p>总是返回 OK</p><h4 id="代码示例-117"><a href="#代码示例-117" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SCRIPT FLUSH</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h3 id="SCRIPT-KILL"><a href="#SCRIPT-KILL" class="headerlink" title="SCRIPT KILL"></a>SCRIPT KILL</h3><h4 id="SCRIPT-KILL-1"><a href="#SCRIPT-KILL-1" class="headerlink" title="SCRIPT KILL"></a>SCRIPT KILL</h4><pre><code>可用版本： &gt;= 2.6.0时间复杂度： O(1)</code></pre><p>杀死当前正在运行的 Lua 脚本，当且仅当这个脚本没有执行过任何写操作时，这个命令才生效。</p><p>这个命令主要用于终止运行时间过长的脚本，比如一个因为 BUG 而发生无限 loop 的脚本，诸如此类。</p><p>SCRIPT KILL 执行之后，当前正在运行的脚本会被杀死，执行这个脚本的客户端会从 EVAL script numkeys key [key …] arg [arg …] 命令的阻塞当中退出，并收到一个错误作为返回值。</p><p>另一方面，假如当前正在运行的脚本已经执行过写操作，那么即使执行 SCRIPT KILL ，也无法将它杀死，因为这是违反 Lua 脚本的原子性执行原则的。在这种情况下，唯一可行的办法是使用 SHUTDOWN NOSAVE 命令，通过停止整个 Redis 进程来停止脚本的运行，并防止不完整(half-written)的信息被写入数据库中。</p><p>关于使用 Redis 对 Lua 脚本进行求值的更多信息，请参见 EVAL script numkeys key [key …] arg [arg …] 命令。</p><h4 id="返回值-121"><a href="#返回值-121" class="headerlink" title="返回值"></a>返回值</h4><p>执行成功返回 OK ，否则返回一个错误。</p><h4 id="代码示例-118"><a href="#代码示例-118" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 没有脚本在执行时</span></span><br><span class="line">redis&gt; SCRIPT KILL</span><br><span class="line">(error) ERR No scripts <span class="keyword">in</span> execution right now.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 成功杀死脚本时</span></span><br><span class="line">redis&gt; SCRIPT KILL</span><br><span class="line">OK</span><br><span class="line">(1.30s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 尝试杀死一个已经执行过写操作的脚本，失败</span></span><br><span class="line">redis&gt; SCRIPT KILL</span><br><span class="line">(error) ERR Sorry the script already executed write commands against the dataset. You can either <span class="built_in">wait</span> the script termination or <span class="built_in">kill</span> the server <span class="keyword">in</span> an hard way using the SHUTDOWN NOSAVE <span class="built_in">command</span>.</span><br><span class="line">(1.69s)</span><br></pre></td></tr></table></figure><p>以下是脚本被杀死之后，返回给执行脚本的客户端的错误：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; EVAL <span class="string">"while true do end"</span> 0</span><br><span class="line">(error) ERR Error running script (call to f_694a5fe1ddb97a4c6a1bf299d9537c7d3d0f84e7): Script killed by user with SCRIPT KILL...</span><br><span class="line">(5.00s)</span><br></pre></td></tr></table></figure></p><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h3 id="SAVE"><a href="#SAVE" class="headerlink" title="SAVE"></a>SAVE</h3><h4 id="SAVE-1"><a href="#SAVE-1" class="headerlink" title="SAVE"></a>SAVE</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(N)， N 为要保存到数据库中的 key 的数量。</code></pre><p>SAVE 命令执行一个同步保存操作，将当前 Redis 实例的所有数据快照(snapshot)以 RDB 文件的形式保存到硬盘。</p><p>一般来说，在生产环境很少执行 SAVE 操作，因为它会阻塞所有客户端，保存数据库的任务通常由 BGSAVE 命令异步地执行。然而，如果负责保存数据的后台子进程不幸出现问题时， SAVE 可以作为保存数据的最后手段来使用。</p><h4 id="返回值-122"><a href="#返回值-122" class="headerlink" title="返回值"></a>返回值</h4><p>保存成功时返回 OK 。</p><h4 id="代码示例-119"><a href="#代码示例-119" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SAVE</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h3 id="BGSAVE"><a href="#BGSAVE" class="headerlink" title="BGSAVE"></a>BGSAVE</h3><h4 id="BGSAVE-1"><a href="#BGSAVE-1" class="headerlink" title="BGSAVE"></a>BGSAVE</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(N)， N 为要保存到数据库中的 key 的数量。</code></pre><p>在后台异步(Asynchronously)保存当前数据库的数据到磁盘。</p><p>BGSAVE 命令执行之后立即返回 OK ，然后 Redis fork 出一个新子进程，原来的 Redis 进程(父进程)继续处理客户端请求，而子进程则负责将数据保存到磁盘，然后退出。</p><p>客户端可以通过 LASTSAVE 命令查看相关信息，判断 BGSAVE 命令是否执行成功。</p><p>请移步 持久化文档 查看更多相关细节。</p><h4 id="返回值-123"><a href="#返回值-123" class="headerlink" title="返回值"></a>返回值</h4><p>反馈信息。</p><h4 id="代码示例-120"><a href="#代码示例-120" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; BGSAVE</span><br><span class="line">Background saving started</span><br></pre></td></tr></table></figure><h3 id="BGREWRITEAOF"><a href="#BGREWRITEAOF" class="headerlink" title="BGREWRITEAOF"></a>BGREWRITEAOF</h3><h4 id="BGREWRITEAOF-1"><a href="#BGREWRITEAOF-1" class="headerlink" title="BGREWRITEAOF"></a>BGREWRITEAOF</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(N)， N 为要追加到 AOF 文件中的数据数量。</code></pre><p>执行一个 AOF文件 重写操作。重写会创建一个当前 AOF 文件的体积优化版本。</p><p>即使 BGREWRITEAOF 执行失败，也不会有任何数据丢失，因为旧的 AOF 文件在 BGREWRITEAOF 成功之前不会被修改。</p><p>重写操作只会在没有其他持久化工作在后台执行时被触发，也就是说：</p><p>如果 Redis 的子进程正在执行快照的保存工作，那么 AOF 重写的操作会被预定(scheduled)，等到保存工作完成之后再执行 AOF 重写。在这种情况下， BGREWRITEAOF 的返回值仍然是 OK ，但还会加上一条额外的信息，说明 BGREWRITEAOF 要等到保存操作完成之后才能执行。在 Redis 2.6 或以上的版本，可以使用 INFO [section] 命令查看 BGREWRITEAOF 是否被预定。<br>如果已经有别的 AOF 文件重写在执行，那么 BGREWRITEAOF 返回一个错误，并且这个新的 BGREWRITEAOF 请求也不会被预定到下次执行。<br>从 Redis 2.4 开始， AOF 重写由 Redis 自行触发， BGREWRITEAOF 仅仅用于手动触发重写操作。</p><p>请移步 持久化文档(英文) 查看更多相关细节。</p><h4 id="返回值-124"><a href="#返回值-124" class="headerlink" title="返回值"></a>返回值</h4><p>反馈信息。</p><h4 id="代码示例-121"><a href="#代码示例-121" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; BGREWRITEAOF</span><br><span class="line">Background append only file rewriting started</span><br></pre></td></tr></table></figure><h3 id="LASTSAVE"><a href="#LASTSAVE" class="headerlink" title="LASTSAVE"></a>LASTSAVE</h3><h4 id="LASTSAVE-1"><a href="#LASTSAVE-1" class="headerlink" title="LASTSAVE"></a>LASTSAVE</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>返回最近一次 Redis 成功将数据保存到磁盘上的时间，以 UNIX 时间戳格式表示。</p><h4 id="返回值-125"><a href="#返回值-125" class="headerlink" title="返回值"></a>返回值</h4><p>一个 UNIX 时间戳。</p><h4 id="代码示例-122"><a href="#代码示例-122" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; LASTSAVE</span><br><span class="line">(<span class="built_in">integer</span>) 1324043588</span><br></pre></td></tr></table></figure><h2 id="发布与订阅"><a href="#发布与订阅" class="headerlink" title="发布与订阅"></a>发布与订阅</h2><h3 id="PUBLISH"><a href="#PUBLISH" class="headerlink" title="PUBLISH"></a>PUBLISH</h3><h4 id="PUBLISH-channel-message"><a href="#PUBLISH-channel-message" class="headerlink" title="PUBLISH channel message"></a>PUBLISH channel message</h4><pre><code>可用版本： &gt;= 2.0.0时间复杂度： O(N+M)，其中 N 是频道 channel 的订阅者数量，而 M 则是使用模式订阅(subscribed patterns)的客户端的数量。</code></pre><p>将信息 message 发送到指定的频道 channel 。</p><h4 id="返回值-126"><a href="#返回值-126" class="headerlink" title="返回值"></a>返回值</h4><p>接收到信息 message 的订阅者数量。</p><h4 id="代码示例-123"><a href="#代码示例-123" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对没有订阅者的频道发送信息</span></span><br><span class="line">redis&gt; publish bad_channel <span class="string">"can any body hear me?"</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向有一个订阅者的频道发送信息</span></span><br><span class="line">redis&gt; publish msg <span class="string">"good morning"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向有多个订阅者的频道发送信息</span></span><br><span class="line">redis&gt; publish chat_room <span class="string">"hello~ everyone"</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure><h3 id="SUBSCRIBE"><a href="#SUBSCRIBE" class="headerlink" title="SUBSCRIBE"></a>SUBSCRIBE</h3><h4 id="SUBSCRIBE-channel-channel-…"><a href="#SUBSCRIBE-channel-channel-…" class="headerlink" title="SUBSCRIBE channel [channel …]"></a>SUBSCRIBE channel [channel …]</h4><pre><code>可用版本： &gt;= 2.0.0时间复杂度： O(N)，其中 N 是订阅的频道的数量。</code></pre><p>订阅给定的一个或多个频道的信息。</p><h4 id="返回值-127"><a href="#返回值-127" class="headerlink" title="返回值"></a>返回值</h4><p>接收到的信息(请参见下面的代码说明)。</p><h4 id="代码示例-124"><a href="#代码示例-124" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 订阅 msg 和 chat_room 两个频道</span></span><br><span class="line"><span class="comment"># 1 - 6 行是执行 subscribe 之后的反馈信息</span></span><br><span class="line"><span class="comment"># 第 7 - 9 行才是接收到的第一条信息</span></span><br><span class="line"><span class="comment"># 第 10 - 12 行是第二条</span></span><br><span class="line">redis&gt; subscribe msg chat_room</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">"subscribe"</span>       <span class="comment"># 返回值的类型：显示订阅成功</span></span><br><span class="line">2) <span class="string">"msg"</span>             <span class="comment"># 订阅的频道名字</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1       <span class="comment"># 目前已订阅的频道数量</span></span><br><span class="line"></span><br><span class="line">1) <span class="string">"subscribe"</span></span><br><span class="line">2) <span class="string">"chat_room"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">1) <span class="string">"message"</span>         <span class="comment"># 返回值的类型：信息</span></span><br><span class="line">2) <span class="string">"msg"</span>             <span class="comment"># 来源(从那个频道发送过来)</span></span><br><span class="line">3) <span class="string">"hello moto"</span>      <span class="comment"># 信息内容</span></span><br><span class="line"></span><br><span class="line">1) <span class="string">"message"</span></span><br><span class="line">2) <span class="string">"chat_room"</span></span><br><span class="line">3) <span class="string">"testing...haha"</span></span><br></pre></td></tr></table></figure><h3 id="PSUBSCRIBE"><a href="#PSUBSCRIBE" class="headerlink" title="PSUBSCRIBE"></a>PSUBSCRIBE</h3><h4 id="PSUBSCRIBE-pattern-pattern-…"><a href="#PSUBSCRIBE-pattern-pattern-…" class="headerlink" title="PSUBSCRIBE pattern [pattern …]"></a>PSUBSCRIBE pattern [pattern …]</h4><pre><code>可用版本： &gt;= 2.0.0时间复杂度： O(N)， N 是订阅的模式的数量。</code></pre><p>订阅一个或多个符合给定模式的频道。</p><p>每个模式以 <em> 作为匹配符，比如 it</em> 匹配所有以 it 开头的频道( it.news 、 it.blog 、 it.tweets 等等)， news.* 匹配所有以 news. 开头的频道( news.it 、 news.global.today 等等)，诸如此类。</p><h4 id="返回值-128"><a href="#返回值-128" class="headerlink" title="返回值"></a>返回值</h4><p>接收到的信息(请参见下面的代码说明)。</p><h4 id="代码示例-125"><a href="#代码示例-125" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 订阅 news.* 和 tweet.* 两个模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第 1 - 6 行是执行 psubscribe 之后的反馈信息</span></span><br><span class="line"><span class="comment"># 第 7 - 10 才是接收到的第一条信息</span></span><br><span class="line"><span class="comment"># 第 11 - 14 是第二条</span></span><br><span class="line"><span class="comment"># 以此类推。。。</span></span><br><span class="line">redis&gt; psubscribe news.* tweet.*</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">"psubscribe"</span>                  <span class="comment"># 返回值的类型：显示订阅成功</span></span><br><span class="line">2) <span class="string">"news.*"</span>                      <span class="comment"># 订阅的模式</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1                   <span class="comment"># 目前已订阅的模式的数量</span></span><br><span class="line"></span><br><span class="line">1) <span class="string">"psubscribe"</span></span><br><span class="line">2) <span class="string">"tweet.*"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">1) <span class="string">"pmessage"</span>                    <span class="comment"># 返回值的类型：信息</span></span><br><span class="line">2) <span class="string">"news.*"</span>                      <span class="comment"># 信息匹配的模式</span></span><br><span class="line">3) <span class="string">"news.it"</span>                     <span class="comment"># 信息本身的目标频道</span></span><br><span class="line">4) <span class="string">"Google buy Motorola"</span>         <span class="comment"># 信息的内容</span></span><br><span class="line"></span><br><span class="line">1) <span class="string">"pmessage"</span></span><br><span class="line">2) <span class="string">"tweet.*"</span></span><br><span class="line">3) <span class="string">"tweet.huangz"</span></span><br><span class="line">4) <span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line">1) <span class="string">"pmessage"</span></span><br><span class="line">2) <span class="string">"tweet.*"</span></span><br><span class="line">3) <span class="string">"tweet.joe"</span></span><br><span class="line">4) <span class="string">"@huangz morning"</span></span><br><span class="line"></span><br><span class="line">1) <span class="string">"pmessage"</span></span><br><span class="line">2) <span class="string">"news.*"</span></span><br><span class="line">3) <span class="string">"news.life"</span></span><br><span class="line">4) <span class="string">"An apple a day, keep doctors away"</span></span><br></pre></td></tr></table></figure><h3 id="UNSUBSCRIBE"><a href="#UNSUBSCRIBE" class="headerlink" title="UNSUBSCRIBE"></a>UNSUBSCRIBE</h3><h4 id="UNSUBSCRIBE-channel-channel-…"><a href="#UNSUBSCRIBE-channel-channel-…" class="headerlink" title="UNSUBSCRIBE [channel [channel …]]"></a>UNSUBSCRIBE [channel [channel …]]</h4><pre><code>可用版本： &gt;= 2.0.0时间复杂度： O(N) ， N 是客户端已订阅的频道的数量。</code></pre><p>指示客户端退订给定的频道。</p><p>如果没有频道被指定，也即是，一个无参数的 UNSUBSCRIBE 调用被执行，那么客户端使用 SUBSCRIBE 命令订阅的所有频道都会被退订。在这种情况下，命令会返回一个信息，告知客户端所有被退订的频道。</p><h4 id="返回值-129"><a href="#返回值-129" class="headerlink" title="返回值"></a>返回值</h4><p>这个命令在不同的客户端中有不同的表现。</p><h3 id="PUNSUBSCRIBE"><a href="#PUNSUBSCRIBE" class="headerlink" title="PUNSUBSCRIBE"></a>PUNSUBSCRIBE</h3><h4 id="PUNSUBSCRIBE-pattern-pattern-…"><a href="#PUNSUBSCRIBE-pattern-pattern-…" class="headerlink" title="PUNSUBSCRIBE [pattern [pattern …]]"></a>PUNSUBSCRIBE [pattern [pattern …]]</h4><pre><code>可用版本： &gt;= 2.0.0时间复杂度： O(N+M) ，其中 N 是客户端已订阅的模式的数量， M 则是系统中所有客户端订阅的模式的数量。</code></pre><p>指示客户端退订所有给定模式。</p><p>如果没有模式被指定，也即是，一个无参数的 PUNSUBSCRIBE 调用被执行，那么客户端使用 PSUBSCRIBE pattern [pattern …] 命令订阅的所有模式都会被退订。在这种情况下，命令会返回一个信息，告知客户端所有被退订的模式。</p><h4 id="返回值-130"><a href="#返回值-130" class="headerlink" title="返回值"></a>返回值</h4><p>这个命令在不同的客户端中有不同的表现。</p><h3 id="PUBSUB"><a href="#PUBSUB" class="headerlink" title="PUBSUB"></a>PUBSUB</h3><h4 id="PUBSUB-argument-argument-…"><a href="#PUBSUB-argument-argument-…" class="headerlink" title="PUBSUB  [argument [argument …]]"></a>PUBSUB <subcommand> [argument [argument …]]</subcommand></h4><pre><code>可用版本：&gt;= 2.8.0</code></pre><p>PUBSUB 是一个查看订阅与发布系统状态的内省命令， 它由数个不同格式的子命令组成， 以下将分别对这些子命令进行介绍。</p><h4 id="PUBSUB-CHANNELS-pattern"><a href="#PUBSUB-CHANNELS-pattern" class="headerlink" title="PUBSUB CHANNELS [pattern]"></a>PUBSUB CHANNELS [pattern]</h4><p>复杂度： O(N) ， N 为活跃频道的数量（对于长度较短的频道和模式来说，将进行模式匹配的复杂度视为常数）。<br>列出当前的活跃频道。</p><p>活跃频道指的是那些至少有一个订阅者的频道， 订阅模式的客户端不计算在内。</p><p>pattern 参数是可选的：</p><ul><li>如果不给出 pattern 参数，那么列出订阅与发布系统中的所有活跃频道。</li><li>如果给出 pattern 参数，那么只列出和给定模式 pattern 相匹配的那些活跃频道。<h5 id="返回值-131"><a href="#返回值-131" class="headerlink" title="返回值"></a>返回值</h5>一个由活跃频道组成的列表。</li></ul><h5 id="代码示例-126"><a href="#代码示例-126" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># client-1 订阅 news.it 和 news.sport 两个频道</span></span><br><span class="line">client-1&gt; SUBSCRIBE news.it news.sport</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">"subscribe"</span></span><br><span class="line">2) <span class="string">"news.it"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line">1) <span class="string">"subscribe"</span></span><br><span class="line">2) <span class="string">"news.sport"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># client-2 订阅 news.it 和 news.internet 两个频道</span></span><br><span class="line">client-2&gt; SUBSCRIBE news.it news.internet</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">"subscribe"</span></span><br><span class="line">2) <span class="string">"news.it"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line">1) <span class="string">"subscribe"</span></span><br><span class="line">2) <span class="string">"news.internet"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先， client-3 打印所有活跃频道</span></span><br><span class="line"><span class="comment"># 注意，即使一个频道有多个订阅者，它也只输出一次，比如 news.it</span></span><br><span class="line">client-3&gt; PUBSUB CHANNELS</span><br><span class="line">1) <span class="string">"news.sport"</span></span><br><span class="line">2) <span class="string">"news.internet"</span></span><br><span class="line">3) <span class="string">"news.it"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来， client-3 打印那些与模式 news.i* 相匹配的活跃频道</span></span><br><span class="line"><span class="comment"># 因为 news.sport 不匹配 news.i* ，所以它没有被打印</span></span><br><span class="line">redis&gt; PUBSUB CHANNELS news.i*</span><br><span class="line">1) <span class="string">"news.internet"</span></span><br><span class="line">2) <span class="string">"news.it"</span></span><br></pre></td></tr></table></figure><h4 id="PUBSUB-NUMSUB-channel-1-…-channel-N"><a href="#PUBSUB-NUMSUB-channel-1-…-channel-N" class="headerlink" title="PUBSUB NUMSUB [channel-1 … channel-N]"></a>PUBSUB NUMSUB [channel-1 … channel-N]</h4><pre><code>复杂度： O(N) ， N 为给定频道的数量。</code></pre><p>返回给定频道的订阅者数量， 订阅模式的客户端不计算在内。</p><h5 id="返回值-132"><a href="#返回值-132" class="headerlink" title="返回值"></a>返回值</h5><p>一个多条批量回复（Multi-bulk reply），回复中包含给定的频道，以及频道的订阅者数量。 格式为：频道 channel-1 ， channel-1 的订阅者数量，频道 channel-2 ， channel-2 的订阅者数量，诸如此类。 回复中频道的排列顺序和执行命令时给定频道的排列顺序一致。 不给定任何频道而直接调用这个命令也是可以的， 在这种情况下， 命令只返回一个空列表。</p><h5 id="代码示例-127"><a href="#代码示例-127" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># client-1 订阅 news.it 和 news.sport 两个频道</span></span><br><span class="line">client-1&gt; SUBSCRIBE news.it news.sport</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">"subscribe"</span></span><br><span class="line">2) <span class="string">"news.it"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line">1) <span class="string">"subscribe"</span></span><br><span class="line">2) <span class="string">"news.sport"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># client-2 订阅 news.it 和 news.internet 两个频道</span></span><br><span class="line">client-2&gt; SUBSCRIBE news.it news.internet</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">"subscribe"</span></span><br><span class="line">2) <span class="string">"news.it"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line">1) <span class="string">"subscribe"</span></span><br><span class="line">2) <span class="string">"news.internet"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># client-3 打印各个频道的订阅者数量</span></span><br><span class="line">client-3&gt; PUBSUB NUMSUB news.it news.internet news.sport news.music</span><br><span class="line">1) <span class="string">"news.it"</span>    <span class="comment"># 频道</span></span><br><span class="line">2) <span class="string">"2"</span>          <span class="comment"># 订阅该频道的客户端数量</span></span><br><span class="line">3) <span class="string">"news.internet"</span></span><br><span class="line">4) <span class="string">"1"</span></span><br><span class="line">5) <span class="string">"news.sport"</span></span><br><span class="line">6) <span class="string">"1"</span></span><br><span class="line">7) <span class="string">"news.music"</span> <span class="comment"># 没有任何订阅者</span></span><br><span class="line">8) <span class="string">"0"</span></span><br></pre></td></tr></table></figure><h4 id="PUBSUB-NUMPAT"><a href="#PUBSUB-NUMPAT" class="headerlink" title="PUBSUB NUMPAT"></a>PUBSUB NUMPAT</h4><pre><code>复杂度： O(1) 。</code></pre><p>返回订阅模式的数量。</p><p>注意， 这个命令返回的不是订阅模式的客户端的数量， 而是客户端订阅的所有模式的数量总和。</p><h5 id="返回值-133"><a href="#返回值-133" class="headerlink" title="返回值"></a>返回值</h5><p>一个整数回复（Integer reply）。</p><h5 id="代码示例-128"><a href="#代码示例-128" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># client-1 订阅 news.* 和 discount.* 两个模式</span></span><br><span class="line">client-1&gt; PSUBSCRIBE news.* discount.*</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">"psubscribe"</span></span><br><span class="line">2) <span class="string">"news.*"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line">1) <span class="string">"psubscribe"</span></span><br><span class="line">2) <span class="string">"discount.*"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># client-2 订阅 tweet.* 一个模式</span></span><br><span class="line">client-2&gt; PSUBSCRIBE tweet.*</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">"psubscribe"</span></span><br><span class="line">2) <span class="string">"tweet.*"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># client-3 返回当前订阅模式的数量为 3</span></span><br><span class="line">client-3&gt; PUBSUB NUMPAT</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意，当有多个客户端订阅相同的模式时，相同的订阅也被计算在 PUBSUB NUMPAT 之内</span></span><br><span class="line"><span class="comment"># 比如说，再新建一个客户端 client-4 ，让它也订阅 news.* 频道</span></span><br><span class="line">client-4&gt; PSUBSCRIBE news.*</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">"psubscribe"</span></span><br><span class="line">2) <span class="string">"news.*"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这时再计算被订阅模式的数量，就会得到数量为 4</span></span><br><span class="line">client-3&gt; PUBSUB NUMPAT</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br></pre></td></tr></table></figure><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><h3 id="SLAVEOF"><a href="#SLAVEOF" class="headerlink" title="SLAVEOF"></a>SLAVEOF</h3><h4 id="SLAVEOF-host-port"><a href="#SLAVEOF-host-port" class="headerlink" title="SLAVEOF host port"></a>SLAVEOF host port</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： SLAVEOF host port 的复杂度为 O(N)，其中 N 为要同步的数据数量； SLAVEOF NO ONE 命令的复杂度为 O(1) 。</code></pre><p>SLAVEOF 命令用于在 Redis 运行时动态地修改复制(replication)功能的行为。</p><p>通过执行 SLAVEOF host port 命令，可以将当前服务器转变为指定服务器的从属服务器(slave server)。</p><p>如果当前服务器已经是某个主服务器(master server)的从属服务器，那么执行 SLAVEOF host port 将使当前服务器停止对旧主服务器的同步，丢弃旧数据集，转而开始对新主服务器进行同步。</p><p>另外，对一个从属服务器执行命令 SLAVEOF NO ONE 将使得这个从属服务器关闭复制功能，并从从属服务器转变回主服务器，原来同步所得的数据集不会被丢弃。</p><p>利用“SLAVEOF NO ONE 不会丢弃同步所得数据集”这个特性，可以在主服务器失败的时候，将从属服务器用作新的主服务器，从而实现无间断运行。</p><h4 id="返回值-134"><a href="#返回值-134" class="headerlink" title="返回值"></a>返回值</h4><p>总是返回 OK 。</p><h4 id="代码示例-129"><a href="#代码示例-129" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SLAVEOF 127.0.0.1 6379</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SLAVEOF NO ONE</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h3 id="ROLE"><a href="#ROLE" class="headerlink" title="ROLE"></a>ROLE</h3><h4 id="ROLE-1"><a href="#ROLE-1" class="headerlink" title="ROLE"></a>ROLE</h4><pre><code>可用版本： &gt;= 2.8.12时间复杂度： O(1)</code></pre><p>返回实例在复制中担任的角色， 这个角色可以是 master 、 slave 或者 sentinel 。 除了角色之外， 命令还会返回与该角色相关的其他信息， 其中：</p><ul><li>主服务器将返回属下从服务器的 IP 地址和端口。</li><li>从服务器将返回自己正在复制的主服务器的 IP 地址、端口、连接状态以及复制偏移量。</li><li>Sentinel 将返回自己正在监视的主服务器列表。<h3 id="返回值-135"><a href="#返回值-135" class="headerlink" title="返回值"></a>返回值</h3>ROLE 命令将返回一个数组。</li></ul><h3 id="代码示例-130"><a href="#代码示例-130" class="headerlink" title="代码示例"></a>代码示例</h3><p>主服务器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1) <span class="string">"master"</span></span><br><span class="line">2) (<span class="built_in">integer</span>) 3129659</span><br><span class="line">3) 1) 1) <span class="string">"127.0.0.1"</span></span><br><span class="line">      2) <span class="string">"9001"</span></span><br><span class="line">      3) <span class="string">"3129242"</span></span><br><span class="line">   2) 1) <span class="string">"127.0.0.1"</span></span><br><span class="line">      2) <span class="string">"9002"</span></span><br><span class="line">      3) <span class="string">"3129543"</span></span><br></pre></td></tr></table></figure></p><p>从服务器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1) <span class="string">"slave"</span></span><br><span class="line">2) <span class="string">"127.0.0.1"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 9000</span><br><span class="line">4) <span class="string">"connected"</span></span><br><span class="line">5) (<span class="built_in">integer</span>) 3167038</span><br></pre></td></tr></table></figure></p><p>Sentinel<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1) <span class="string">"sentinel"</span></span><br><span class="line">2) 1) <span class="string">"resque-master"</span></span><br><span class="line">   2) <span class="string">"html-fragments-master"</span></span><br><span class="line">   3) <span class="string">"stats-master"</span></span><br><span class="line">   4) <span class="string">"metadata-master"</span></span><br></pre></td></tr></table></figure></p><h2 id="客户端与服务器"><a href="#客户端与服务器" class="headerlink" title="客户端与服务器"></a>客户端与服务器</h2><h3 id="AUTH"><a href="#AUTH" class="headerlink" title="AUTH"></a>AUTH</h3><h4 id="AUTH-password"><a href="#AUTH-password" class="headerlink" title="AUTH password"></a>AUTH password</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>通过设置配置文件中 requirepass 项的值(使用命令 CONFIG SET requirepass password )，可以使用密码来保护 Redis 服务器。</p><p>如果开启了密码保护的话，在每次连接 Redis 服务器之后，就要使用 AUTH 命令解锁，解锁之后才能使用其他 Redis 命令。</p><p>如果 AUTH 命令给定的密码 password 和配置文件中的密码相符的话，服务器会返回 OK 并开始接受命令输入。</p><p>另一方面，假如密码不匹配的话，服务器将返回一个错误，并要求客户端需重新输入密码。</p><h4 id="Warning-2"><a href="#Warning-2" class="headerlink" title="Warning"></a>Warning</h4><p>因为 Redis 高性能的特点，在很短时间内尝试猜测非常多个密码是有可能的，因此请确保使用的密码足够复杂和足够长，以免遭受密码猜测攻击。</p><h4 id="返回值-136"><a href="#返回值-136" class="headerlink" title="返回值"></a>返回值</h4><p>密码匹配时返回 OK ，否则返回一个错误。</p><h4 id="代码示例-131"><a href="#代码示例-131" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置密码</span></span><br><span class="line">redis&gt; CONFIG SET requirepass secret_password   <span class="comment"># 将密码设置为 secret_password</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; QUIT                                     <span class="comment"># 退出再连接，让新密码对客户端生效</span></span><br><span class="line"></span><br><span class="line">[huangz@mypad]$ redis</span><br><span class="line"></span><br><span class="line">redis&gt; PING                                     <span class="comment"># 未验证密码，操作被拒绝</span></span><br><span class="line">(error) ERR operation not permitted</span><br><span class="line"></span><br><span class="line">redis&gt; AUTH wrong_password_testing              <span class="comment"># 尝试输入错误的密码</span></span><br><span class="line">(error) ERR invalid password</span><br><span class="line"></span><br><span class="line">redis&gt; AUTH secret_password                     <span class="comment"># 输入正确的密码</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; PING                                     <span class="comment"># 密码验证成功，可以正常操作命令了</span></span><br><span class="line">PONG</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空密码</span></span><br><span class="line">redis&gt; CONFIG SET requirepass <span class="string">""</span>   <span class="comment"># 通过将密码设为空字符来清空密码</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; QUIT</span><br><span class="line">$ redis                            <span class="comment"># 重新进入客户端</span></span><br><span class="line">redis&gt; PING                        <span class="comment"># 执行命令不再需要密码，清空密码操作成功</span></span><br><span class="line">PONG</span><br></pre></td></tr></table></figure><h3 id="QUIT"><a href="#QUIT" class="headerlink" title="QUIT"></a>QUIT</h3><h4 id="QUIT-1"><a href="#QUIT-1" class="headerlink" title="QUIT"></a>QUIT</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>请求服务器关闭与当前客户端的连接。</p><p>一旦所有等待中的回复(如果有的话)顺利写入到客户端，连接就会被关闭。</p><h4 id="返回值-137"><a href="#返回值-137" class="headerlink" title="返回值"></a>返回值</h4><p>总是返回 OK (但是不会被打印显示，因为当时 Redis-cli 已经退出)。</p><h4 id="代码示例-132"><a href="#代码示例-132" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ redis</span><br><span class="line">redis&gt; QUIT</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h3 id="INFO"><a href="#INFO" class="headerlink" title="INFO"></a>INFO</h3><h4 id="INFO-section"><a href="#INFO-section" class="headerlink" title="INFO [section]"></a>INFO [section]</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>以一种易于解释（parse）且易于阅读的格式，返回关于 Redis 服务器的各种信息和统计数值。</p><p>通过给定可选的参数 section ，可以让命令只返回某一部分的信息：</p><ul><li><p>server 部分记录了 Redis 服务器的信息，它包含以下域：</p><ul><li>redis_version : Redis 服务器版本</li><li>redis_git_sha1 : Git SHA1</li><li>redis_git_dirty : Git dirty flag</li><li>os : Redis 服务器的宿主操作系统</li><li>arch_bits : 架构（32 或 64 位）</li><li>multiplexing_api : Redis 所使用的事件处理机制</li><li>gcc_version : 编译 Redis 时所使用的 GCC 版本</li><li>process_id : 服务器进程的 PID</li><li>run_id : Redis 服务器的随机标识符（用于 Sentinel 和集群）</li><li>tcp_port : TCP/IP 监听端口</li><li>uptime_in_seconds : 自 Redis 服务器启动以来，经过的秒数</li><li>uptime_in_days : 自 Redis 服务器启动以来，经过的天数</li><li>lru_clock : 以分钟为单位进行自增的时钟，用于 LRU 管理</li></ul></li><li><p>clients 部分记录了已连接客户端的信息，它包含以下域：</p><ul><li>connected_clients : 已连接客户端的数量（不包括通过从属服务器连接的客户端）</li><li>client_longest_output_list : 当前连接的客户端当中，最长的输出列表</li><li>client_longest_input_buf : 当前连接的客户端当中，最大输入缓存</li><li>blocked_clients : 正在等待阻塞命令（BLPOP、BRPOP、BRPOPLPUSH）的客户端的数量</li></ul></li><li><p>memory 部分记录了服务器的内存信息，它包含以下域：</p><ul><li>used_memory : 由 Redis 分配器分配的内存总量，以字节（byte）为单位</li><li>used_memory_human : 以人类可读的格式返回 Redis 分配的内存总量</li><li>used_memory_rss : 从操作系统的角度，返回 Redis 已分配的内存总量（俗称常驻集大小）。这个值和 top 、 ps 等命令的输出一致。</li><li>used_memory_peak : Redis 的内存消耗峰值（以字节为单位）</li><li>used_memory_peak_human : 以人类可读的格式返回 Redis 的内存消耗峰值</li><li>used_memory_lua : Lua 引擎所使用的内存大小（以字节为单位）</li><li>mem_fragmentation_ratio : used_memory_rss 和 used_memory 之间的比率</li><li><p>mem_allocator : 在编译时指定的， Redis 所使用的内存分配器。可以是 libc 、 jemalloc 或者 tcmalloc 。</p><p>在理想情况下， used_memory_rss 的值应该只比 used_memory 稍微高一点儿。</p><p>当 rss &gt; used ，且两者的值相差较大时，表示存在（内部或外部的）内存碎片。</p><p>内存碎片的比率可以通过 mem_fragmentation_ratio 的值看出。</p><p>当 used &gt; rss 时，表示 Redis 的部分内存被操作系统换出到交换空间了，在这种情况下，操作可能会产生明显的延迟。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Because Redis does not have control over how its allocations are mapped to memory pages, high used_memory_rss is often the result of a spike in memory usage.</span><br></pre></td></tr></table></figure><p>当 Redis 释放内存时，分配器可能会，也可能不会，将内存返还给操作系统。</p><p>如果 Redis 释放了内存，却没有将内存返还给操作系统，那么 used_memory 的值可能和操作系统显示的 Redis 内存占用并不一致。</p><p>查看 used_memory_peak 的值可以验证这种情况是否发生。</p></li></ul></li><li><p>persistence 部分记录了跟 RDB 持久化和 AOF 持久化有关的信息，它包含以下域：</p><ul><li>loading : 一个标志值，记录了服务器是否正在载入持久化文件。</li><li>rdb_changes_since_last_save : 距离最近一次成功创建持久化文件之后，经过了多少秒。</li><li>rdb_bgsave_in_progress : 一个标志值，记录了服务器是否正在创建 RDB 文件。</li><li>rdb_last_save_time : 最近一次成功创建 RDB 文件的 UNIX 时间戳。</li><li>rdb_last_bgsave_status : 一个标志值，记录了最近一次创建 RDB 文件的结果是成功还是失败。</li><li>rdb_last_bgsave_time_sec : 记录了最近一次创建 RDB 文件耗费的秒数。</li><li>rdb_current_bgsave_time_sec : 如果服务器正在创建 RDB 文件，那么这个域记录的就是当前的创建操作已经耗费的秒数。</li><li>aof_enabled : 一个标志值，记录了 AOF 是否处于打开状态。</li><li>aof_rewrite_in_progress : 一个标志值，记录了服务器是否正在创建 AOF 文件。</li><li>aof_rewrite_scheduled : 一个标志值，记录了在 RDB 文件创建完毕之后，是否需要执行预约的 AOF 重写操作。</li><li>aof_last_rewrite_time_sec : 最近一次创建 AOF 文件耗费的时长。</li><li>aof_current_rewrite_time_sec : 如果服务器正在创建 AOF 文件，那么这个域记录的就是当前的创建操作已经耗费的秒数。</li><li><p>aof_last_bgrewrite_status : 一个标志值，记录了最近一次创建 AOF 文件的结果是成功还是失败。</p><p>如果 AOF 持久化功能处于开启状态，那么这个部分还会加上以下域：</p></li><li><p>aof_current_size : AOF 文件目前的大小。</p></li><li>aof_base_size : 服务器启动时或者 AOF 重写最近一次执行之后，AOF 文件的大小。</li><li>aof_pending_rewrite : 一个标志值，记录了是否有 AOF 重写操作在等待 RDB 文件创建完毕之后执行。</li><li>aof_buffer_length : AOF 缓冲区的大小。</li><li>aof_rewrite_buffer_length : AOF 重写缓冲区的大小。</li><li>aof_pending_bio_fsync : 后台 I/O 队列里面，等待执行的 fsync 调用数量。</li><li>aof_delayed_fsync : 被延迟的 fsync 调用数量。</li><li></li></ul></li><li><p>stats 部分记录了一般统计信息，它包含以下域：</p><ul><li>total_connections_received : 服务器已接受的连接请求数量。</li><li>total_commands_processed : 服务器已执行的命令数量。</li><li>instantaneous_ops_per_sec : 服务器每秒钟执行的命令数量。</li><li>rejected_connections : 因为最大客户端数量限制而被拒绝的连接请求数量。</li><li>expired_keys : 因为过期而被自动删除的数据库键数量。</li><li>evicted_keys : 因为最大内存容量限制而被驱逐（evict）的键数量。</li><li>keyspace_hits : 查找数据库键成功的次数。</li><li>keyspace_misses : 查找数据库键失败的次数。</li><li>pubsub_channels : 目前被订阅的频道数量。</li><li>pubsub_patterns : 目前被订阅的模式数量。</li><li>latest_fork_usec : 最近一次 fork() 操作耗费的毫秒数。</li><li>replication : 主/从复制信息</li></ul></li><li><p>role : 如果当前服务器没有在复制任何其他服务器，那么这个域的值就是 master ；否则的话，这个域的值就是 slave 。注意，在创建复制链的时候，一个从服务器也可能是另一个服务器的主服务器。</p><p>  如果当前服务器是一个从服务器的话，那么这个部分还会加上以下域：</p><ul><li>master_host : 主服务器的 IP 地址。</li><li>master_port : 主服务器的 TCP 监听端口号。</li><li>master_link_status : 复制连接当前的状态， up 表示连接正常， down 表示连接断开。</li><li>master_last_io_seconds_ago : 距离最近一次与主服务器进行通信已经过去了多少秒钟。</li><li><p>master_sync_in_progress : 一个标志值，记录了主服务器是否正在与这个从服务器进行同步。</p><p>如果同步操作正在进行，那么这个部分还会加上以下域：</p></li><li><p>master_sync_left_bytes : 距离同步完成还缺少多少字节数据。</p></li><li><p>master_sync_last_io_seconds_ago : 距离最近一次因为 SYNC 操作而进行 I/O 已经过去了多少秒。</p><p>如果主从服务器之间的连接处于断线状态，那么这个部分还会加上以下域：</p></li><li><p>master_link_down_since_seconds : 主从服务器连接断开了多少秒。</p><p>以下是一些总会出现的域：</p></li><li><p>connected_slaves : 已连接的从服务器数量。</p><p>对于每个从服务器，都会添加以下一行信息：</p></li><li><p>slaveXXX : ID、IP 地址、端口号、连接状态</p></li></ul></li><li><p>cpu 部分记录了 CPU 的计算量统计信息，它包含以下域：</p><ul><li>used_cpu_sys : Redis 服务器耗费的系统 CPU 。</li><li>used_cpu_user : Redis 服务器耗费的用户 CPU 。</li><li>used_cpu_sys_children : 后台进程耗费的系统 CPU 。</li><li>used_cpu_user_children : 后台进程耗费的用户 CPU 。</li></ul></li><li><p>commandstats 部分记录了各种不同类型的命令的执行统计信息，比如命令执行的次数、命令耗费的 CPU 时间、执行每个命令耗费的平均 CPU 时间等等。对于每种类型的命令，这个部分都会添加一行以下格式的信息：</p><ul><li>cmdstat_XXX:calls=XXX,usec=XXX,usecpercall=XXX</li><li><p>cluster 部分记录了和集群有关的信息，它包含以下域：</p></li><li><p>cluster_enabled : 一个标志值，记录集群功能是否已经开启。</p></li></ul></li><li><p>keyspace 部分记录了数据库相关的统计信息，比如数据库的键数量、数据库已经被删除的过期键数量等。对于每个数据库，这个部分都会添加一行以下格式的信息：</p><ul><li>dbXXX:keys=XXX,expires=XXX</li></ul></li></ul><p>除上面给出的这些值以外， section 参数的值还可以是下面这两个：</p><ul><li>all : 返回所有信息</li><li>default : 返回默认选择的信息</li></ul><p>当不带参数直接调用 INFO 命令时，使用 default 作为默认参数。</p><h4 id="Note-8"><a href="#Note-8" class="headerlink" title="Note"></a>Note</h4><p>不同版本的 Redis 可能对返回的一些域进行了增加或删减。</p><p>因此，一个健壮的客户端程序在对 INFO [section] 命令的输出进行分析时，应该能够跳过不认识的域，并且妥善地处理丢失不见的域。</p><h4 id="返回值-138"><a href="#返回值-138" class="headerlink" title="返回值"></a>返回值</h4><p>具体请参见下面的测试代码。</p><h4 id="代码示例-133"><a href="#代码示例-133" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; INFO</span><br><span class="line"><span class="comment"># Server</span></span><br><span class="line">redis_version:2.9.11</span><br><span class="line">redis_git_sha1:937384d0</span><br><span class="line">redis_git_dirty:0</span><br><span class="line">redis_build_id:8e9509442863f22</span><br><span class="line">redis_mode:standalone</span><br><span class="line">os:Linux 3.13.0-35-generic x86_64</span><br><span class="line">arch_bits:64</span><br><span class="line">multiplexing_api:epoll</span><br><span class="line">gcc_version:4.8.2</span><br><span class="line">process_id:4716</span><br><span class="line">run_id:26186aac3f2380aaee9eef21cc50aecd542d97dc</span><br><span class="line">tcp_port:6379</span><br><span class="line">uptime_in_seconds:362</span><br><span class="line">uptime_in_days:0</span><br><span class="line">hz:10</span><br><span class="line">lru_clock:1725349</span><br><span class="line">config_file:</span><br><span class="line"></span><br><span class="line"><span class="comment"># Clients</span></span><br><span class="line">connected_clients:1</span><br><span class="line">client_longest_output_list:0</span><br><span class="line">client_biggest_input_buf:0</span><br><span class="line">blocked_clients:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Memory</span></span><br><span class="line">used_memory:508536</span><br><span class="line">used_memory_human:496.62K</span><br><span class="line">used_memory_rss:7974912</span><br><span class="line">used_memory_peak:508536</span><br><span class="line">used_memory_peak_human:496.62K</span><br><span class="line">used_memory_lua:33792</span><br><span class="line">mem_fragmentation_ratio:15.68</span><br><span class="line">mem_allocator:jemalloc-3.2.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Persistence</span></span><br><span class="line">loading:0</span><br><span class="line">rdb_changes_since_last_save:6</span><br><span class="line">rdb_bgsave_in_progress:0</span><br><span class="line">rdb_last_save_time:1411011131</span><br><span class="line">rdb_last_bgsave_status:ok</span><br><span class="line">rdb_last_bgsave_time_sec:-1</span><br><span class="line">rdb_current_bgsave_time_sec:-1</span><br><span class="line">aof_enabled:0</span><br><span class="line">aof_rewrite_in_progress:0</span><br><span class="line">aof_rewrite_scheduled:0</span><br><span class="line">aof_last_rewrite_time_sec:-1</span><br><span class="line">aof_current_rewrite_time_sec:-1</span><br><span class="line">aof_last_bgrewrite_status:ok</span><br><span class="line">aof_last_write_status:ok</span><br><span class="line"></span><br><span class="line"><span class="comment"># Stats</span></span><br><span class="line">total_connections_received:2</span><br><span class="line">total_commands_processed:4</span><br><span class="line">instantaneous_ops_per_sec:0</span><br><span class="line">rejected_connections:0</span><br><span class="line">sync_full:0</span><br><span class="line">sync_partial_ok:0</span><br><span class="line">sync_partial_err:0</span><br><span class="line">expired_keys:0</span><br><span class="line">evicted_keys:0</span><br><span class="line">keyspace_hits:0</span><br><span class="line">keyspace_misses:0</span><br><span class="line">pubsub_channels:0</span><br><span class="line">pubsub_patterns:0</span><br><span class="line">latest_fork_usec:0</span><br><span class="line">migrate_cached_sockets:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_repl_offset:0</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># CPU</span></span><br><span class="line">used_cpu_sys:0.21</span><br><span class="line">used_cpu_user:0.17</span><br><span class="line">used_cpu_sys_children:0.00</span><br><span class="line">used_cpu_user_children:0.00</span><br><span class="line"></span><br><span class="line"><span class="comment"># Cluster</span></span><br><span class="line">cluster_enabled:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Keyspace</span></span><br><span class="line">db0:keys=2,expires=0,avg_ttl=0</span><br></pre></td></tr></table></figure><h3 id="SHUTDOWN"><a href="#SHUTDOWN" class="headerlink" title="SHUTDOWN"></a>SHUTDOWN</h3><h4 id="SHUTDOWN-SAVE-NOSAVE"><a href="#SHUTDOWN-SAVE-NOSAVE" class="headerlink" title="SHUTDOWN [SAVE|NOSAVE]"></a>SHUTDOWN [SAVE|NOSAVE]</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(N)，其中 N 为关机时需要保存的数据库键数量。</code></pre><p>SHUTDOWN 命令执行以下操作：</p><h4 id="停止所有客户端"><a href="#停止所有客户端" class="headerlink" title="停止所有客户端"></a>停止所有客户端</h4><ul><li>如果有至少一个保存点在等待，执行 SAVE 命令</li><li>如果 AOF 选项被打开，更新 AOF 文件</li><li>关闭 redis 服务器(server)</li><li>如果持久化被打开的话， SHUTDOWN 命令会保证服务器正常关闭而不丢失任何数据。</li></ul><p>另一方面，假如只是单纯地执行 SAVE 命令，然后再执行 QUIT 命令，则没有这一保证 —— 因为在执行 SAVE 之后、执行 QUIT 之前的这段时间中间，其他客户端可能正在和服务器进行通讯，这时如果执行 QUIT 就会造成数据丢失。</p><h4 id="SAVE-和-NOSAVE-修饰符"><a href="#SAVE-和-NOSAVE-修饰符" class="headerlink" title="SAVE 和 NOSAVE 修饰符"></a>SAVE 和 NOSAVE 修饰符</h4><p>通过使用可选的修饰符，可以修改 SHUTDOWN 命令的表现。比如说：</p><ul><li>执行 SHUTDOWN SAVE 会强制让数据库执行保存操作，即使没有设定(configure)保存点</li><li>执行 SHUTDOWN NOSAVE 会阻止数据库执行保存操作，即使已经设定有一个或多个保存点(你可以将这一用法看作是强制停止服务器的一个假想的 ABORT 命令)<h4 id="返回值-139"><a href="#返回值-139" class="headerlink" title="返回值"></a>返回值</h4>执行失败时返回错误。 执行成功时不返回任何信息，服务器和客户端的连接断开，客户端自动退出。</li></ul><h4 id="代码示例-134"><a href="#代码示例-134" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; PING</span><br><span class="line">PONG</span><br><span class="line"></span><br><span class="line">redis&gt; SHUTDOWN</span><br><span class="line"></span><br><span class="line">$</span><br><span class="line">$ redis</span><br><span class="line">Could not connect to Redis at: Connection refused</span><br><span class="line">not connected&gt;</span><br></pre></td></tr></table></figure><h3 id="TIME"><a href="#TIME" class="headerlink" title="TIME"></a>TIME</h3><h4 id="TIME-1"><a href="#TIME-1" class="headerlink" title="TIME"></a>TIME</h4><pre><code>可用版本： &gt;= 2.6.0时间复杂度： O(1)</code></pre><p>返回当前服务器时间。</p><h4 id="返回值-140"><a href="#返回值-140" class="headerlink" title="返回值"></a>返回值</h4><p>一个包含两个字符串的列表： 第一个字符串是当前时间(以 UNIX 时间戳格式表示)，而第二个字符串是当前这一秒钟已经逝去的微秒数。</p><h4 id="代码示例-135"><a href="#代码示例-135" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; TIME</span><br><span class="line">1) <span class="string">"1332395997"</span></span><br><span class="line">2) <span class="string">"952581"</span></span><br><span class="line"></span><br><span class="line">redis&gt; TIME</span><br><span class="line">1) <span class="string">"1332395997"</span></span><br><span class="line">2) <span class="string">"953148"</span></span><br></pre></td></tr></table></figure><h3 id="CLIENT"><a href="#CLIENT" class="headerlink" title="CLIENT"></a>CLIENT</h3><h4 id="CLIENT-GETNAME"><a href="#CLIENT-GETNAME" class="headerlink" title="CLIENT GETNAME"></a>CLIENT GETNAME</h4><pre><code>可用版本： &gt;= 2.6.9时间复杂度： O(1)</code></pre><p>返回 CLIENT SETNAME 命令为连接设置的名字。</p><p>因为新创建的连接默认是没有名字的， 对于没有名字的连接， CLIENT GETNAME 返回空白回复。</p><h5 id="返回值-141"><a href="#返回值-141" class="headerlink" title="返回值"></a>返回值</h5><p>如果连接没有设置名字，那么返回空白回复； 如果有设置名字，那么返回名字。</p><h5 id="代码示例-136"><a href="#代码示例-136" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新连接默认没有名字</span></span><br><span class="line">redis 127.0.0.1:6379&gt; CLIENT GETNAME</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置名字</span></span><br><span class="line">redis 127.0.0.1:6379&gt; CLIENT SETNAME hello-world-connection</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回名字</span></span><br><span class="line">redis 127.0.0.1:6379&gt; CLIENT GETNAME</span><br><span class="line"><span class="string">"hello-world-connection"</span></span><br></pre></td></tr></table></figure><h4 id="CLIENT-KILL-ip-port"><a href="#CLIENT-KILL-ip-port" class="headerlink" title="CLIENT KILL ip:port"></a>CLIENT KILL ip:port</h4><pre><code>可用版本： &gt;= 2.4.0时间复杂度： O(N) ， N 为已连接的客户端数量。</code></pre><p>关闭地址为 ip:port 的客户端。</p><p>ip:port 应该和 CLIENT LIST 命令输出的其中一行匹配。</p><p>因为 Redis 使用单线程设计，所以当 Redis 正在执行命令的时候，不会有客户端被断开连接。</p><p>如果要被断开连接的客户端正在执行命令，那么当这个命令执行之后，在发送下一个命令的时候，它就会收到一个网络错误，告知它自身的连接已被关闭。</p><h5 id="返回值-142"><a href="#返回值-142" class="headerlink" title="返回值"></a>返回值</h5><p>当指定的客户端存在，且被成功关闭时，返回 OK 。</p><h5 id="代码示例-137"><a href="#代码示例-137" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有已连接客户端</span></span><br><span class="line">redis 127.0.0.1:6379&gt; CLIENT LIST</span><br><span class="line">addr=127.0.0.1:43501 fd=5 age=10 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=32768 obl=0 oll=0 omem=0 events=r cmd=client</span><br><span class="line"></span><br><span class="line"><span class="comment"># 杀死当前客户端的连接</span></span><br><span class="line">redis 127.0.0.1:6379&gt; CLIENT KILL 127.0.0.1:43501</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 之前的连接已经被关闭，CLI 客户端又重新建立了连接</span></span><br><span class="line"><span class="comment"># 之前的端口是 43501 ，现在是 43504</span></span><br><span class="line">redis 127.0.0.1:6379&gt; CLIENT LIST</span><br><span class="line">addr=127.0.0.1:43504 fd=5 age=0 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=32768 obl=0 oll=0 omem=0 events=r cmd=client</span><br></pre></td></tr></table></figure><h4 id="CLIENT-LIST"><a href="#CLIENT-LIST" class="headerlink" title="CLIENT LIST"></a>CLIENT LIST</h4><pre><code>可用版本： &gt;= 2.4.0时间复杂度： O(N) ， N 为连接到服务器的客户端数量。</code></pre><p>以人类可读的格式，返回所有连接到服务器的客户端信息和统计数据。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; CLIENT LIST</span><br><span class="line">addr=127.0.0.1:43143 fd=6 age=183 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=32768 obl=0 oll=0 omem=0 events=r cmd=client</span><br><span class="line">addr=127.0.0.1:43163 fd=5 age=35 idle=15 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=ping</span><br><span class="line">addr=127.0.0.1:43167 fd=7 age=24 idle=6 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=get</span><br></pre></td></tr></table></figure></p><h5 id="返回值-143"><a href="#返回值-143" class="headerlink" title="返回值"></a>返回值</h5><p>命令返回多行字符串，这些字符串按以下形式被格式化：</p><p>每个已连接客户端对应一行（以 LF 分割）</p><p>每行字符串由一系列 属性=值 形式的域组成，每个域之间以空格分开</p><p>以下是域的含义：</p><ul><li>addr ： 客户端的地址和端口</li><li>fd ： 套接字所使用的文件描述符</li><li>age ： 以秒计算的已连接时长</li><li>idle ： 以秒计算的空闲时长</li><li>flags ： 客户端 flag （见下文）</li><li>db ： 该客户端正在使用的数据库 ID</li><li>sub ： 已订阅频道的数量</li><li>psub ： 已订阅模式的数量</li><li>multi ： 在事务中被执行的命令数量</li><li>qbuf ： 查询缓冲区的长度（字节为单位， 0 表示没有分配查询缓冲区）</li><li>qbuf-free ： 查询缓冲区剩余空间的长度（字节为单位， 0 表示没有剩余空间）</li><li>obl ： 输出缓冲区的长度（字节为单位， 0 表示没有分配输出缓冲区）</li><li>oll ： 输出列表包含的对象数量（当输出缓冲区没有剩余空间时，命令回复会以字符串对象的形式被入队到这个队列里）</li><li>omem ： 输出缓冲区和输出列表占用的内存总量</li><li>events ： 文件描述符事件（见下文）</li><li>cmd ： 最近一次执行的命令</li></ul><p>客户端 flag 可以由以下部分组成：</p><ul><li>O ： 客户端是 MONITOR 模式下的附属节点（slave）</li><li>S ： 客户端是一般模式下（normal）的附属节点</li><li>M ： 客户端是主节点（master）</li><li>x ： 客户端正在执行事务</li><li>b ： 客户端正在等待阻塞事件</li><li>i ： 客户端正在等待 VM I/O 操作（已废弃）</li><li>d ： 一个受监视（watched）的键已被修改， EXEC 命令将失败</li><li>c : 在将回复完整地写出之后，关闭链接</li><li>u : 客户端未被阻塞（unblocked）</li><li>A : 尽可能快地关闭连接</li><li>N : 未设置任何 flag</li></ul><p>文件描述符事件可以是：</p><ul><li>r : 客户端套接字（在事件 loop 中）是可读的（readable）</li><li>w : 客户端套接字（在事件 loop 中）是可写的（writeable）<h5 id="Note-9"><a href="#Note-9" class="headerlink" title="Note"></a>Note</h5></li></ul><p>为了 debug 的需要，经常会对域进行添加和删除，一个安全的 Redis 客户端应该可以对 CLIENT LIST 的输出进行相应的处理（parse），比如忽略不存在的域，跳过未知域，诸如此类。</p><h4 id="CLIENT-SETNAME-connection-name"><a href="#CLIENT-SETNAME-connection-name" class="headerlink" title="CLIENT SETNAME connection-name"></a>CLIENT SETNAME connection-name</h4><pre><code>可用版本： &gt;= 2.6.9时间复杂度： O(1)</code></pre><p>为当前连接分配一个名字。</p><p>这个名字会显示在 CLIENT LIST 命令的结果中， 用于识别当前正在与服务器进行连接的客户端。</p><p>举个例子， 在使用 Redis 构建队列（queue）时， 可以根据连接负责的任务（role）， 为信息生产者（producer）和信息消费者（consumer）分别设置不同的名字。</p><p>名字使用 Redis 的字符串类型来保存， 最大可以占用 512 MB 。 另外， 为了避免和 CLIENT LIST 命令的输出格式发生冲突， 名字里不允许使用空格。</p><p>要移除一个连接的名字， 可以将连接的名字设为空字符串 “” 。</p><p>使用 CLIENT GETNAME 命令可以取出连接的名字。</p><p>新创建的连接默认是没有名字的。</p><h5 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h5><p>在 Redis 应用程序发生连接泄漏时，为连接设置名字是一种很好的 debug 手段。</p><h5 id="返回值-144"><a href="#返回值-144" class="headerlink" title="返回值"></a>返回值</h5><p>设置成功时返回 OK 。</p><h5 id="代码示例-138"><a href="#代码示例-138" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新连接默认没有名字</span></span><br><span class="line">redis 127.0.0.1:6379&gt; CLIENT GETNAME</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置名字</span></span><br><span class="line">redis 127.0.0.1:6379&gt; CLIENT SETNAME hello-world-connection</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回名字</span></span><br><span class="line">redis 127.0.0.1:6379&gt; CLIENT GETNAME</span><br><span class="line"><span class="string">"hello-world-connection"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在客户端列表中查看</span></span><br><span class="line">redis 127.0.0.1:6379&gt; CLIENT LIST</span><br><span class="line">addr=127.0.0.1:36851</span><br><span class="line">fd=5</span><br><span class="line">name=hello-world-connection     <span class="comment"># &lt;- 名字</span></span><br><span class="line">age=51</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除名字</span></span><br><span class="line">redis 127.0.0.1:6379&gt; CLIENT SETNAME        <span class="comment"># 只用空格是不行的！</span></span><br><span class="line">(error) ERR Syntax error, try CLIENT (LIST | KILL ip:port)</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; CLIENT SETNAME <span class="string">""</span>     <span class="comment"># 必须双引号显示包围</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; CLIENT GETNAME        <span class="comment"># 清除完毕</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h2 id="配置选项"><a href="#配置选项" class="headerlink" title="配置选项"></a>配置选项</h2><h3 id="CONFIG-SET"><a href="#CONFIG-SET" class="headerlink" title="CONFIG SET"></a>CONFIG SET</h3><h4 id="CONFIG-SET-parameter-value"><a href="#CONFIG-SET-parameter-value" class="headerlink" title="CONFIG SET parameter value"></a>CONFIG SET parameter value</h4><pre><code>可用版本： &gt;= 2.0.0时间复杂度：O(1)</code></pre><p>CONFIG SET 命令可以动态地调整 Redis 服务器的配置(configuration)而无须重启。</p><p>你可以使用它修改配置参数，或者改变 Redis 的持久化(Persistence)方式。</p><p>CONFIG SET 可以修改的配置参数可以使用命令 CONFIG GET * 来列出，所有被 CONFIG SET 修改的配置参数都会立即生效。</p><p>关于 CONFIG SET 命令的更多消息，请参见命令 CONFIG GET 的说明。</p><p>关于如何使用 CONFIG SET 命令修改 Redis 持久化方式，请参见 Redis Persistence 。</p><h4 id="返回值-145"><a href="#返回值-145" class="headerlink" title="返回值"></a>返回值</h4><p>当设置成功时返回 OK ，否则返回一个错误。</p><h4 id="代码示例-139"><a href="#代码示例-139" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; CONFIG GET slowlog-max-len</span><br><span class="line">1) <span class="string">"slowlog-max-len"</span></span><br><span class="line">2) <span class="string">"1024"</span></span><br><span class="line"></span><br><span class="line">redis&gt; CONFIG SET slowlog-max-len 10086</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; CONFIG GET slowlog-max-len</span><br><span class="line">1) <span class="string">"slowlog-max-len"</span></span><br><span class="line">2) <span class="string">"10086"</span></span><br></pre></td></tr></table></figure><h3 id="CONFIG-GET"><a href="#CONFIG-GET" class="headerlink" title="CONFIG GET"></a>CONFIG GET</h3><h4 id="CONFIG-GET-parameter"><a href="#CONFIG-GET-parameter" class="headerlink" title="CONFIG GET parameter"></a>CONFIG GET parameter</h4><pre><code>可用版本： &gt;= 2.0.0时间复杂度： O(N)，其中 N 为命令返回的配置选项数量。</code></pre><p>CONFIG GET 命令用于取得运行中的 Redis 服务器的配置参数(configuration parameters)，在 Redis 2.4 版本中， 有部分参数没有办法用 CONFIG GET 访问，但是在最新的 Redis 2.6 版本中，所有配置参数都已经可以用 CONFIG GET 访问了。</p><p>CONFIG GET 接受单个参数 parameter 作为搜索关键字，查找所有匹配的配置参数，其中参数和值以“键-值对”(key-value pairs)的方式排列。</p><p>比如执行 CONFIG GET s* 命令，服务器就会返回所有以 s 开头的配置参数及参数的值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; CONFIG GET s*</span><br><span class="line">1) <span class="string">"save"</span>                       <span class="comment"># 参数名：save</span></span><br><span class="line">2) <span class="string">"900 1 300 10 60 10000"</span>      <span class="comment"># save 参数的值</span></span><br><span class="line">3) <span class="string">"slave-serve-stale-data"</span>     <span class="comment"># 参数名： slave-serve-stale-data</span></span><br><span class="line">4) <span class="string">"yes"</span>                        <span class="comment"># slave-serve-stale-data 参数的值</span></span><br><span class="line">5) <span class="string">"set-max-intset-entries"</span>     <span class="comment"># ...</span></span><br><span class="line">6) <span class="string">"512"</span></span><br><span class="line">7) <span class="string">"slowlog-log-slower-than"</span></span><br><span class="line">8) <span class="string">"1000"</span></span><br><span class="line">9) <span class="string">"slowlog-max-len"</span></span><br><span class="line">10) <span class="string">"1000"</span></span><br></pre></td></tr></table></figure><p>如果你只是寻找特定的某个参数的话，你当然也可以直接指定参数的名字：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; CONFIG GET slowlog-max-len</span><br><span class="line">1) <span class="string">"slowlog-max-len"</span></span><br><span class="line">2) <span class="string">"1000"</span></span><br></pre></td></tr></table></figure><p>使用命令 CONFIG GET * ，可以列出 CONFIG GET 命令支持的所有参数：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; CONFIG GET *</span><br><span class="line">1) <span class="string">"dir"</span></span><br><span class="line">2) <span class="string">"/var/lib/redis"</span></span><br><span class="line">3) <span class="string">"dbfilename"</span></span><br><span class="line">4) <span class="string">"dump.rdb"</span></span><br><span class="line">5) <span class="string">"requirepass"</span></span><br><span class="line">6) (nil)</span><br><span class="line">7) <span class="string">"masterauth"</span></span><br><span class="line">8) (nil)</span><br><span class="line">9) <span class="string">"maxmemory"</span></span><br><span class="line">10) <span class="string">"0"</span></span><br><span class="line">11) <span class="string">"maxmemory-policy"</span></span><br><span class="line">12) <span class="string">"volatile-lru"</span></span><br><span class="line">13) <span class="string">"maxmemory-samples"</span></span><br><span class="line">14) <span class="string">"3"</span></span><br><span class="line">15) <span class="string">"timeout"</span></span><br><span class="line">16) <span class="string">"0"</span></span><br><span class="line">17) <span class="string">"appendonly"</span></span><br><span class="line">18) <span class="string">"no"</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line">49) <span class="string">"loglevel"</span></span><br><span class="line">50) <span class="string">"verbose"</span></span><br></pre></td></tr></table></figure></p><p>所有被 CONFIG SET 所支持的配置参数都可以在配置文件 redis.conf 中找到，不过 CONFIG GET 和 CONFIG SET 使用的格式和 redis.conf 文件所使用的格式有以下两点不同：</p><p>10kb 、 2gb 这些在配置文件中所使用的储存单位缩写，不可以用在 CONFIG 命令中， CONFIG SET 的值只能通过数字值显式地设定。</p><p>像 CONFIG SET xxx 1k 这样的命令是错误的，正确的格式是 CONFIG SET xxx 1000 。<br>save 选项在 redis.conf 中是用多行文字储存的，但在 CONFIG GET 命令中，它只打印一行文字。</p><p>以下是 save 选项在 redis.conf 文件中的表示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure></p><p>但是 CONFIG GET 命令的输出只有一行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; CONFIG GET save</span><br><span class="line">1) <span class="string">"save"</span></span><br><span class="line">2) <span class="string">"900 1 300 10 60 10000"</span></span><br></pre></td></tr></table></figure></p><p>上面 save 参数的三个值表示：在 900 秒内最少有 1 个 key 被改动，或者 300 秒内最少有 10 个 key 被改动，又或者 60 秒内最少有 1000 个 key 被改动，以上三个条件随便满足一个，就触发一次保存操作。</p><h4 id="返回值-146"><a href="#返回值-146" class="headerlink" title="返回值"></a>返回值</h4><p>给定配置参数的值。</p><h3 id="CONFIG-RESETSTAT"><a href="#CONFIG-RESETSTAT" class="headerlink" title="CONFIG RESETSTAT"></a>CONFIG RESETSTAT</h3><h4 id="CONFIG-RESETSTAT-1"><a href="#CONFIG-RESETSTAT-1" class="headerlink" title="CONFIG RESETSTAT"></a>CONFIG RESETSTAT</h4><pre><code>可用版本： &gt;= 2.0.0时间复杂度： O(1)</code></pre><p>重置 INFO 命令中的某些统计数据，包括：</p><ul><li>Keyspace hits (键空间命中次数)</li><li>Keyspace misses (键空间不命中次数)</li><li>Number of commands processed (执行命令的次数)</li><li>Number of connections received (连接服务器的次数)</li><li>Number of expired keys (过期key的数量)</li><li>Number of rejected connections (被拒绝的连接数量)</li><li>Latest fork(2) time(最后执行 fork(2) 的时间)</li><li>The aof_delayed_fsync counter(aof_delayed_fsync 计数器的值)<h4 id="返回值-147"><a href="#返回值-147" class="headerlink" title="返回值"></a>返回值</h4>总是返回 OK 。</li></ul><h4 id="代码示例-140"><a href="#代码示例-140" class="headerlink" title="代码示例"></a>代码示例</h4><p>重置前<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; INFO</span><br><span class="line"><span class="comment"># Server</span></span><br><span class="line">redis_version:2.5.3</span><br><span class="line">redis_git_sha1:d0407c2d</span><br><span class="line">redis_git_dirty:0</span><br><span class="line">arch_bits:32</span><br><span class="line">multiplexing_api:epoll</span><br><span class="line">gcc_version:4.6.3</span><br><span class="line">process_id:11095</span><br><span class="line">run_id:ef1f6b6c7392e52d6001eaf777acbe547d1192e2</span><br><span class="line">tcp_port:6379</span><br><span class="line">uptime_in_seconds:6</span><br><span class="line">uptime_in_days:0</span><br><span class="line">lru_clock:1205426</span><br><span class="line"></span><br><span class="line"><span class="comment"># Clients</span></span><br><span class="line">connected_clients:1</span><br><span class="line">client_longest_output_list:0</span><br><span class="line">client_biggest_input_buf:0</span><br><span class="line">blocked_clients:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Memory</span></span><br><span class="line">used_memory:331076</span><br><span class="line">used_memory_human:323.32K</span><br><span class="line">used_memory_rss:1568768</span><br><span class="line">used_memory_peak:293424</span><br><span class="line">used_memory_peak_human:286.55K</span><br><span class="line">used_memory_lua:16384</span><br><span class="line">mem_fragmentation_ratio:4.74</span><br><span class="line">mem_allocator:jemalloc-2.2.5</span><br><span class="line"></span><br><span class="line"><span class="comment"># Persistence</span></span><br><span class="line">loading:0</span><br><span class="line">aof_enabled:0</span><br><span class="line">changes_since_last_save:0</span><br><span class="line">bgsave_in_progress:0</span><br><span class="line">last_save_time:1333260015</span><br><span class="line">last_bgsave_status:ok</span><br><span class="line">bgrewriteaof_in_progress:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Stats</span></span><br><span class="line">total_connections_received:1</span><br><span class="line">total_commands_processed:0</span><br><span class="line">instantaneous_ops_per_sec:0</span><br><span class="line">rejected_connections:0</span><br><span class="line">expired_keys:0</span><br><span class="line">evicted_keys:0</span><br><span class="line">keyspace_hits:0</span><br><span class="line">keyspace_misses:0</span><br><span class="line">pubsub_channels:0</span><br><span class="line">pubsub_patterns:0</span><br><span class="line">latest_fork_usec:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># CPU</span></span><br><span class="line">used_cpu_sys:0.01</span><br><span class="line">used_cpu_user:0.00</span><br><span class="line">used_cpu_sys_children:0.00</span><br><span class="line">used_cpu_user_children:0.00</span><br><span class="line"></span><br><span class="line"><span class="comment"># Keyspace</span></span><br><span class="line">db0:keys=20,expires=0</span><br></pre></td></tr></table></figure></p><p>重置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; CONFIG RESETSTAT</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p><p>重置后<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; INFO</span><br><span class="line"><span class="comment"># Server</span></span><br><span class="line">redis_version:2.5.3</span><br><span class="line">redis_git_sha1:d0407c2d</span><br><span class="line">redis_git_dirty:0</span><br><span class="line">arch_bits:32</span><br><span class="line">multiplexing_api:epoll</span><br><span class="line">gcc_version:4.6.3</span><br><span class="line">process_id:11095</span><br><span class="line">run_id:ef1f6b6c7392e52d6001eaf777acbe547d1192e2</span><br><span class="line">tcp_port:6379</span><br><span class="line">uptime_in_seconds:134</span><br><span class="line">uptime_in_days:0</span><br><span class="line">lru_clock:1205438</span><br><span class="line"></span><br><span class="line"><span class="comment"># Clients</span></span><br><span class="line">connected_clients:1</span><br><span class="line">client_longest_output_list:0</span><br><span class="line">client_biggest_input_buf:0</span><br><span class="line">blocked_clients:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Memory</span></span><br><span class="line">used_memory:331076</span><br><span class="line">used_memory_human:323.32K</span><br><span class="line">used_memory_rss:1568768</span><br><span class="line">used_memory_peak:330280</span><br><span class="line">used_memory_peak_human:322.54K</span><br><span class="line">used_memory_lua:16384</span><br><span class="line">mem_fragmentation_ratio:4.74</span><br><span class="line">mem_allocator:jemalloc-2.2.5</span><br><span class="line"></span><br><span class="line"><span class="comment"># Persistence</span></span><br><span class="line">loading:0</span><br><span class="line">aof_enabled:0</span><br><span class="line">changes_since_last_save:0</span><br><span class="line">bgsave_in_progress:0</span><br><span class="line">last_save_time:1333260015</span><br><span class="line">last_bgsave_status:ok</span><br><span class="line">bgrewriteaof_in_progress:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Stats</span></span><br><span class="line">total_connections_received:0</span><br><span class="line">total_commands_processed:1</span><br><span class="line">instantaneous_ops_per_sec:0</span><br><span class="line">rejected_connections:0</span><br><span class="line">expired_keys:0</span><br><span class="line">evicted_keys:0</span><br><span class="line">keyspace_hits:0</span><br><span class="line">keyspace_misses:0</span><br><span class="line">pubsub_channels:0</span><br><span class="line">pubsub_patterns:0</span><br><span class="line">latest_fork_usec:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># CPU</span></span><br><span class="line">used_cpu_sys:0.05</span><br><span class="line">used_cpu_user:0.02</span><br><span class="line">used_cpu_sys_children:0.00</span><br><span class="line">used_cpu_user_children:0.00</span><br><span class="line"></span><br><span class="line"><span class="comment"># Keyspace</span></span><br><span class="line">db0:keys=20,expires=0</span><br></pre></td></tr></table></figure></p><h3 id="CONFIG-REWRITE"><a href="#CONFIG-REWRITE" class="headerlink" title="CONFIG REWRITE"></a>CONFIG REWRITE</h3><h4 id="CONFIG-REWRITE-1"><a href="#CONFIG-REWRITE-1" class="headerlink" title="CONFIG REWRITE"></a>CONFIG REWRITE</h4><pre><code>可用版本： &gt;= 2.8.0时间复杂度：O(N)，其中 N 为被重写的配置选项数量。</code></pre><p>CONFIG REWRITE 命令对启动 Redis 服务器时所指定的 redis.conf 文件进行改写： 因为 CONFIG_SET 命令可以对服务器的当前配置进行修改， 而修改后的配置可能和 redis.conf 文件中所描述的配置不一样， CONFIG REWRITE 的作用就是通过尽可能少的修改， 将服务器当前所使用的配置记录到 redis.conf 文件中。</p><p>重写会以非常保守的方式进行：</p><ul><li>原有 redis.conf 文件的整体结构和注释会被尽可能地保留。</li><li>如果一个选项已经存在于原有 redis.conf 文件中 ， 那么对该选项的重写会在选项原本所在的位置（行号）上进行。</li><li>如果一个选项不存在于原有 redis.conf 文件中， 并且该选项被设置为默认值， 那么重写程序不会将这个选项添加到重写后的 redis.conf 文件中。</li><li>如果一个选项不存在于原有 redis.conf 文件中， 并且该选项被设置为非默认值， 那么这个选项将被添加到重写后的 redis.conf 文件的末尾。</li><li>未使用的行会被留白。 比如说， 如果你在原有 redis.conf 文件上设置了数个关于 save 选项的参数， 但现在你将这些 save 参数的一个或全部都关闭了， 那么这些不再使用的参数原本所在的行就会变成空白的。</li></ul><p>即使启动服务器时所指定的 redis.conf 文件已经不再存在， CONFIG REWRITE 命令也可以重新构建并生成出一个新的 redis.conf 文件。</p><p>另一方面， 如果启动服务器时没有载入 redis.conf 文件， 那么执行 CONFIG REWRITE 命令将引发一个错误。</p><h4 id="原子性重写"><a href="#原子性重写" class="headerlink" title="原子性重写"></a>原子性重写</h4><p>对 redis.conf 文件的重写是原子性的， 并且是一致的： 如果重写出错或重写期间服务器崩溃， 那么重写失败， 原有 redis.conf 文件不会被修改。 如果重写成功， 那么 redis.conf 文件为重写后的新文件。</p><h4 id="返回值-148"><a href="#返回值-148" class="headerlink" title="返回值"></a>返回值</h4><p>一个状态值：如果配置重写成功则返回 OK ，失败则返回一个错误。</p><h4 id="代码示例-141"><a href="#代码示例-141" class="headerlink" title="代码示例"></a>代码示例</h4><p>以下是执行 CONFIG REWRITE 前， 被载入到 Redis 服务器的 redis.conf 文件中关于 appendonly 选项的设置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ... 其他选项</span></span><br><span class="line">appendonly no</span><br><span class="line"><span class="comment"># ... 其他选项</span></span><br><span class="line">在执行以下命令之后：</span><br><span class="line"></span><br><span class="line">redis&gt; CONFIG GET appendonly           <span class="comment"># appendonly 处于关闭状态</span></span><br><span class="line">1) <span class="string">"appendonly"</span></span><br><span class="line">2) <span class="string">"no"</span></span><br><span class="line"></span><br><span class="line">redis&gt; CONFIG SET appendonly yes       <span class="comment"># 打开 appendonly</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; CONFIG GET appendonly</span><br><span class="line">1) <span class="string">"appendonly"</span></span><br><span class="line">2) <span class="string">"yes"</span></span><br><span class="line"></span><br><span class="line">redis&gt; CONFIG REWRITE                  <span class="comment"># 将 appendonly 的修改写入到 redis.conf 中</span></span><br><span class="line">OK</span><br><span class="line">重写后的 redis.conf 文件中的 appendonly 选项将被改写：</span><br><span class="line"></span><br><span class="line"><span class="comment"># ... 其他选项</span></span><br><span class="line">appendonly yes</span><br><span class="line"><span class="comment"># ... 其他选项</span></span><br></pre></td></tr></table></figure></p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="PING"><a href="#PING" class="headerlink" title="PING"></a>PING</h3><h4 id="PING-1"><a href="#PING-1" class="headerlink" title="PING"></a>PING</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>使用客户端向 Redis 服务器发送一个 PING ，如果服务器运作正常的话，会返回一个 PONG 。</p><p>通常用于测试与服务器的连接是否仍然生效，或者用于测量延迟值。</p><h4 id="返回值-149"><a href="#返回值-149" class="headerlink" title="返回值"></a>返回值</h4><p>如果连接正常就返回一个 PONG ，否则返回一个连接错误。</p><h4 id="代码示例-142"><a href="#代码示例-142" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 客户端和服务器连接正常</span></span><br><span class="line">redis&gt; PING</span><br><span class="line">PONG</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端和服务器连接不正常(网络不正常或服务器未能正常运行)</span></span><br><span class="line">redis 127.0.0.1:6379&gt; PING</span><br><span class="line">Could not connect to Redis at 127.0.0.1:6379: Connection refused</span><br></pre></td></tr></table></figure><h3 id="ECHO"><a href="#ECHO" class="headerlink" title="ECHO"></a>ECHO</h3><h4 id="ECHO-message"><a href="#ECHO-message" class="headerlink" title="ECHO message"></a>ECHO message</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>打印一个特定的信息 message ，测试时使用。</p><h4 id="返回值-150"><a href="#返回值-150" class="headerlink" title="返回值"></a>返回值</h4><p>message 自身。</p><h4 id="代码示例-143"><a href="#代码示例-143" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ECHO <span class="string">"Hello Moto"</span></span><br><span class="line"><span class="string">"Hello Moto"</span></span><br><span class="line"></span><br><span class="line">redis&gt; ECHO <span class="string">"Goodbye Moto"</span></span><br><span class="line"><span class="string">"Goodbye Moto"</span></span><br></pre></td></tr></table></figure><h3 id="OBJECT"><a href="#OBJECT" class="headerlink" title="OBJECT"></a>OBJECT</h3><h4 id="OBJECT-subcommand-arguments-arguments"><a href="#OBJECT-subcommand-arguments-arguments" class="headerlink" title="OBJECT subcommand [arguments [arguments]]"></a>OBJECT subcommand [arguments [arguments]]</h4><pre><code>可用版本： &gt;= 2.2.3时间复杂度： O(1)</code></pre><p>OBJECT 命令允许从内部察看给定 key 的 Redis 对象， 它通常用在除错(debugging)或者了解为了节省空间而对 key 使用特殊编码的情况。 当将Redis用作缓存程序时，你也可以通过 OBJECT 命令中的信息，决定 key 的驱逐策略(eviction policies)。</p><p>OBJECT 命令有多个子命令：</p><ul><li>OBJECT REFCOUNT \&lt;key> 返回给定 key 引用所储存的值的次数。此命令主要用于除错。</li><li>OBJECT ENCODING \&lt;key> 返回给定 key 锁储存的值所使用的内部表示(representation)。</li><li><p>OBJECT IDLETIME \&lt;key> 返回给定 key 自储存以来的空闲时间(idle， 没有被读取也没有被写入)，以秒为单位。<br>对象可以以多种方式编码：</p></li><li><p>字符串可以被编码为 raw (一般字符串)或 int (为了节约内存，Redis 会将字符串表示的 64 位有符号整数编码为整数来进行储存）。</p></li><li>列表可以被编码为 ziplist 或 linkedlist 。 ziplist 是为节约大小较小的列表空间而作的特殊表示。</li><li>集合可以被编码为 intset 或者 hashtable 。 intset 是只储存数字的小集合的特殊表示。</li><li>哈希表可以编码为 zipmap 或者 hashtable 。 zipmap 是小哈希表的特殊表示。</li><li>有序集合可以被编码为 ziplist 或者 skiplist 格式。 ziplist 用于表示小的有序集合，而 skiplist 则用于表示任何大小的有序集合。</li></ul><p>假如你做了什么让 Redis 没办法再使用节省空间的编码时(比如将一个只有 1 个元素的集合扩展为一个有 100 万个元素的集合)，特殊编码类型(specially encoded types)会自动转换成通用类型(general type)。</p><h4 id="返回值-151"><a href="#返回值-151" class="headerlink" title="返回值"></a>返回值</h4><p>REFCOUNT 和 IDLETIME 返回数字。 ENCODING 返回相应的编码类型。</p><h4 id="代码示例-144"><a href="#代码示例-144" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET game <span class="string">"COD"</span>           <span class="comment"># 设置一个字符串</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT REFCOUNT game     <span class="comment"># 只有一个引用</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT IDLETIME game     <span class="comment"># 等待一阵。。。然后查看空闲时间</span></span><br><span class="line">(<span class="built_in">integer</span>) 90</span><br><span class="line"></span><br><span class="line">redis&gt; GET game                 <span class="comment"># 提取game， 让它处于活跃(active)状态</span></span><br><span class="line"><span class="string">"COD"</span></span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT IDLETIME game     <span class="comment"># 不再处于空闲状态</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING game     <span class="comment"># 字符串的编码方式</span></span><br><span class="line"><span class="string">"raw"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SET big-number 23102930128301091820391092019203810281029831092  <span class="comment"># 非常长的数字会被编码为字符串</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING big-number</span><br><span class="line"><span class="string">"raw"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SET small-number 12345  <span class="comment"># 而短的数字则会被编码为整数</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING small-number</span><br><span class="line"><span class="string">"int"</span></span><br></pre></td></tr></table></figure><h3 id="SLOWLOG"><a href="#SLOWLOG" class="headerlink" title="SLOWLOG"></a>SLOWLOG</h3><h4 id="SLOWLOG-subcommand-argument"><a href="#SLOWLOG-subcommand-argument" class="headerlink" title="SLOWLOG subcommand [argument]"></a>SLOWLOG subcommand [argument]</h4><pre><code>可用版本： &gt;= 2.2.12时间复杂度： O(1)</code></pre><h4 id="什么是-SLOWLOG"><a href="#什么是-SLOWLOG" class="headerlink" title="什么是 SLOWLOG"></a>什么是 SLOWLOG</h4><p>Slow log 是 Redis 用来记录查询执行时间的日志系统。</p><p>查询执行时间指的是不包括像客户端响应(talking)、发送回复等 IO 操作，而单单是执行一个查询命令所耗费的时间。</p><p>另外，slow log 保存在内存里面，读写速度非常快，因此你可以放心地使用它，不必担心因为开启 slow log 而损害 Redis 的速度。</p><h4 id="设置-SLOWLOG"><a href="#设置-SLOWLOG" class="headerlink" title="设置 SLOWLOG"></a>设置 SLOWLOG</h4><p>Slow log 的行为由两个配置参数(configuration parameter)指定，可以通过改写 redis.conf 文件或者用 CONFIG GET 和 CONFIG SET 命令对它们动态地进行修改。</p><p>第一个选项是 slowlog-log-slower-than ，它决定要对执行时间大于多少微秒(microsecond，1秒 = 1,000,000 微秒)的查询进行记录。</p><p>比如执行以下命令将让 slow log 记录所有查询时间大于等于 100 微秒的查询：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET slowlog-log-slower-than 100</span><br></pre></td></tr></table></figure></p><p>而以下命令记录所有查询时间大于 1000 微秒的查询：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET slowlog-log-slower-than 1000</span><br></pre></td></tr></table></figure></p><p>另一个选项是 slowlog-max-len ，它决定 slow log 最多能保存多少条日志， slow log 本身是一个 FIFO 队列，当队列大小超过 slowlog-max-len 时，最旧的一条日志将被删除，而最新的一条日志加入到 slow log ，以此类推。</p><p>以下命令让 slow log 最多保存 1000 条日志：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET slowlog-max-len 1000</span><br></pre></td></tr></table></figure></p><p>使用 CONFIG GET 命令可以查询两个选项的当前值：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; CONFIG GET slowlog-log-slower-than</span><br><span class="line">1) <span class="string">"slowlog-log-slower-than"</span></span><br><span class="line">2) <span class="string">"1000"</span></span><br><span class="line"></span><br><span class="line">redis&gt; CONFIG GET slowlog-max-len</span><br><span class="line">1) <span class="string">"slowlog-max-len"</span></span><br><span class="line">2) <span class="string">"1000"</span></span><br></pre></td></tr></table></figure></p><h4 id="查看-slow-log"><a href="#查看-slow-log" class="headerlink" title="查看 slow log"></a>查看 slow log</h4><p>要查看 slow log ，可以使用 SLOWLOG GET 或者 SLOWLOG GET number 命令，前者打印所有 slow log ，最大长度取决于 slowlog-max-len 选项的值，而 SLOWLOG GET number 则只打印指定数量的日志。</p><p>最新的日志会最先被打印：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为测试需要，将 slowlog-log-slower-than 设成了 10 微秒</span></span><br><span class="line"></span><br><span class="line">redis&gt; SLOWLOG GET</span><br><span class="line">1) 1) (<span class="built_in">integer</span>) 12                      <span class="comment"># 唯一性(unique)的日志标识符</span></span><br><span class="line">   2) (<span class="built_in">integer</span>) 1324097834              <span class="comment"># 被记录命令的执行时间点，以 UNIX 时间戳格式表示</span></span><br><span class="line">   3) (<span class="built_in">integer</span>) 16                      <span class="comment"># 查询执行时间，以微秒为单位</span></span><br><span class="line">   4) 1) <span class="string">"CONFIG"</span>                       <span class="comment"># 执行的命令，以数组的形式排列</span></span><br><span class="line">      2) <span class="string">"GET"</span>                          <span class="comment"># 这里完整的命令是 CONFIG GET slowlog-log-slower-than</span></span><br><span class="line">      3) <span class="string">"slowlog-log-slower-than"</span></span><br><span class="line"></span><br><span class="line">2) 1) (<span class="built_in">integer</span>) 11</span><br><span class="line">   2) (<span class="built_in">integer</span>) 1324097825</span><br><span class="line">   3) (<span class="built_in">integer</span>) 42</span><br><span class="line">   4) 1) <span class="string">"CONFIG"</span></span><br><span class="line">      2) <span class="string">"GET"</span></span><br><span class="line">      3) <span class="string">"*"</span></span><br><span class="line"></span><br><span class="line">3) 1) (<span class="built_in">integer</span>) 10</span><br><span class="line">   2) (<span class="built_in">integer</span>) 1324097820</span><br><span class="line">   3) (<span class="built_in">integer</span>) 11</span><br><span class="line">   4) 1) <span class="string">"CONFIG"</span></span><br><span class="line">      2) <span class="string">"GET"</span></span><br><span class="line">      3) <span class="string">"slowlog-log-slower-than"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure></p><p>日志的唯一 id 只有在 Redis 服务器重启的时候才会重置，这样可以避免对日志的重复处理(比如你可能会想在每次发现新的慢查询时发邮件通知你)。</p><h4 id="查看当前日志的数量"><a href="#查看当前日志的数量" class="headerlink" title="查看当前日志的数量"></a>查看当前日志的数量</h4><p>使用命令 SLOWLOG LEN 可以查看当前日志的数量。</p><p>请注意这个值和 slower-max-len 的区别，它们一个是当前日志的数量，一个是允许记录的最大日志的数量。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SLOWLOG LEN</span><br><span class="line">(<span class="built_in">integer</span>) 14</span><br></pre></td></tr></table></figure></p><h4 id="清空日志"><a href="#清空日志" class="headerlink" title="清空日志"></a>清空日志</h4><p>使用命令 SLOWLOG RESET 可以清空 slow log 。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SLOWLOG LEN</span><br><span class="line">(<span class="built_in">integer</span>) 14</span><br><span class="line"></span><br><span class="line">redis&gt; SLOWLOG RESET</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SLOWLOG LEN</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure></p><h4 id="返回值-152"><a href="#返回值-152" class="headerlink" title="返回值"></a>返回值</h4><p>取决于不同命令，返回不同的值。</p><h3 id="MONITOR"><a href="#MONITOR" class="headerlink" title="MONITOR"></a>MONITOR</h3><h4 id="MONITOR-1"><a href="#MONITOR-1" class="headerlink" title="MONITOR"></a>MONITOR</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(N)</code></pre><p>实时打印出 Redis 服务器接收到的命令，调试用。</p><h4 id="返回值-153"><a href="#返回值-153" class="headerlink" title="返回值"></a>返回值</h4><p>总是返回 OK 。</p><h4 id="代码示例-145"><a href="#代码示例-145" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MONITOR</span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 以第一个打印值为例</span></span><br><span class="line"><span class="comment"># 1378822099.421623 是时间戳</span></span><br><span class="line"><span class="comment"># [0 127.0.0.1:56604] 中的 0 是数据库号码， 127... 是 IP 地址和端口</span></span><br><span class="line"><span class="comment"># "PING" 是被执行的命令</span></span><br><span class="line">1378822099.421623 [0 127.0.0.1:56604] <span class="string">"PING"</span></span><br><span class="line">1378822105.089572 [0 127.0.0.1:56604] <span class="string">"SET"</span> <span class="string">"msg"</span> <span class="string">"hello world"</span></span><br><span class="line">1378822109.036925 [0 127.0.0.1:56604] <span class="string">"SET"</span> <span class="string">"number"</span> <span class="string">"123"</span></span><br><span class="line">1378822140.649496 [0 127.0.0.1:56604] <span class="string">"SADD"</span> <span class="string">"fruits"</span> <span class="string">"Apple"</span> <span class="string">"Banana"</span> <span class="string">"Cherry"</span></span><br><span class="line">1378822154.117160 [0 127.0.0.1:56604] <span class="string">"EXPIRE"</span> <span class="string">"msg"</span> <span class="string">"10086"</span></span><br><span class="line">1378822257.329412 [0 127.0.0.1:56604] <span class="string">"KEYS"</span> <span class="string">"*"</span></span><br><span class="line">1378822258.690131 [0 127.0.0.1:56604] <span class="string">"DBSIZE"</span></span><br></pre></td></tr></table></figure><h3 id="DEBUG-OBJECT"><a href="#DEBUG-OBJECT" class="headerlink" title="DEBUG OBJECT"></a>DEBUG OBJECT</h3><h4 id="DEBUG-OBJECT-key"><a href="#DEBUG-OBJECT-key" class="headerlink" title="DEBUG OBJECT key"></a>DEBUG OBJECT key</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>DEBUG OBJECT 是一个调试命令，它不应被客户端所使用。</p><p>查看 OBJECT 命令获取更多信息。</p><h4 id="返回值-154"><a href="#返回值-154" class="headerlink" title="返回值"></a>返回值</h4><p>当 key 存在时，返回有关信息。 当 key 不存在时，返回一个错误。</p><h4 id="代码示例-146"><a href="#代码示例-146" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; DEBUG OBJECT my_pc</span><br><span class="line">Value at:0xb6838d20 refcount:1 encoding:raw serializedlength:9 lru:283790 lru_seconds_idle:150</span><br><span class="line"></span><br><span class="line">redis&gt; DEBUG OBJECT your_mac</span><br><span class="line">(error) ERR no such key</span><br></pre></td></tr></table></figure><h3 id="DEBUG-SEGFAULT"><a href="#DEBUG-SEGFAULT" class="headerlink" title="DEBUG SEGFAULT"></a>DEBUG SEGFAULT</h3><h4 id="DEBUG-SEGFAULT-1"><a href="#DEBUG-SEGFAULT-1" class="headerlink" title="DEBUG SEGFAULT"></a>DEBUG SEGFAULT</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>执行一个不合法的内存访问从而让 Redis 崩溃，仅在开发时用于 BUG 模拟。</p><h4 id="返回值-155"><a href="#返回值-155" class="headerlink" title="返回值"></a>返回值</h4><p>无</p><h4 id="代码示例-147"><a href="#代码示例-147" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; DEBUG SEGFAULT</span><br><span class="line">Could not connect to Redis at: Connection refused</span><br><span class="line"></span><br><span class="line">not connected&gt;</span><br></pre></td></tr></table></figure><h2 id="内部命令"><a href="#内部命令" class="headerlink" title="内部命令"></a>内部命令</h2><h3 id="MIGRATE"><a href="#MIGRATE" class="headerlink" title="MIGRATE"></a>MIGRATE</h3><h4 id="MIGRATE-host-port-key-destination-db-timeout-COPY-REPLACE"><a href="#MIGRATE-host-port-key-destination-db-timeout-COPY-REPLACE" class="headerlink" title="MIGRATE host port key destination-db timeout [COPY] [REPLACE]"></a>MIGRATE host port key destination-db timeout [COPY] [REPLACE]</h4><pre><code>可用版本： &gt;= 2.6.0时间复杂度： 这个命令在源实例上实际执行 DUMP 命令和 DEL 命令，在目标实例执行 RESTORE 命令，查看以上命令的文档可以看到详细的复杂度说明。 key 数据在两个实例之间传输的复杂度为 O(N) 。</code></pre><p>将 key 原子性地从当前实例传送到目标实例的指定数据库上，一旦传送成功， key 保证会出现在目标实例上，而当前实例上的 key 会被删除。</p><p>这个命令是一个原子操作，它在执行的时候会阻塞进行迁移的两个实例，直到以下任意结果发生：迁移成功，迁移失败，等待超时。</p><p>命令的内部实现是这样的：它在当前实例对给定 key 执行 DUMP 命令 ，将它序列化，然后传送到目标实例，目标实例再使用 RESTORE 对数据进行反序列化，并将反序列化所得的数据添加到数据库中；当前实例就像目标实例的客户端那样，只要看到 RESTORE 命令返回 OK ，它就会调用 DEL 删除自己数据库上的 key 。</p><p>timeout 参数以毫秒为格式，指定当前实例和目标实例进行沟通的最大间隔时间。这说明操作并不一定要在 timeout 毫秒内完成，只是说数据传送的时间不能超过这个 timeout 数。</p><p>MIGRATE 命令需要在给定的时间规定内完成 IO 操作。如果在传送数据时发生 IO 错误，或者达到了超时时间，那么命令会停止执行，并返回一个特殊的错误： IOERR 。</p><p>当 IOERR 出现时，有以下两种可能：</p><ul><li>key 可能存在于两个实例</li><li>key 可能只存在于当前实例</li></ul><p>唯一不可能发生的情况就是丢失 key ，因此，如果一个客户端执行 MIGRATE 命令，并且不幸遇上 IOERR 错误，那么这个客户端唯一要做的就是检查自己数据库上的 key 是否已经被正确地删除。</p><p>如果有其他错误发生，那么 MIGRATE 保证 key 只会出现在当前实例中。（当然，目标实例的给定数据库上可能有和 key 同名的键，不过这和 MIGRATE 命令没有关系）。</p><h4 id="可选项"><a href="#可选项" class="headerlink" title="可选项"></a>可选项</h4><pre><code>COPY ：不移除源实例上的 key 。REPLACE ：替换目标实例上已存在的 key 。</code></pre><h4 id="返回值-156"><a href="#返回值-156" class="headerlink" title="返回值"></a>返回值</h4><p>迁移成功时返回 OK ，否则返回相应的错误。</p><h4 id="代码示例-148"><a href="#代码示例-148" class="headerlink" title="代码示例"></a>代码示例</h4><p>先启动两个 Redis 实例，一个使用默认的 6379 端口，一个使用 7777 端口。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-server &amp;</span><br><span class="line">[1] 3557</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">$ ./redis-server --port 7777 &amp;</span><br><span class="line">[2] 3560</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>然后用客户端连上 6379 端口的实例，设置一个键，然后将它迁移到 7777 端口的实例上：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-cli</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; flushdb</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SET greeting <span class="string">"Hello from 6379 instance"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; MIGRATE 127.0.0.1 7777 greeting 0 1000</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; EXISTS greeting                           <span class="comment"># 迁移成功后 key 被删除</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure></p><p>使用另一个客户端，查看 7777 端口上的实例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-cli -p 7777</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:7777&gt; GET greeting</span><br><span class="line"><span class="string">"Hello from 6379 instance"</span></span><br></pre></td></tr></table></figure></p><h3 id="DUMP"><a href="#DUMP" class="headerlink" title="DUMP"></a>DUMP</h3><h4 id="DUMP-key"><a href="#DUMP-key" class="headerlink" title="DUMP key"></a>DUMP key</h4><pre><code>可用版本： &gt;= 2.6.0时间复杂度：查找给定键的复杂度为 O(1) ，对键进行序列化的复杂度为 O(N*M) ，其中 N 是构成 key 的 Redis 对象的数量，而 M 则是这些对象的平均大小。如果序列化的对象是比较小的字符串，那么复杂度为 O(1) 。</code></pre><p>序列化给定 key ，并返回被序列化的值，使用 RESTORE 命令可以将这个值反序列化为 Redis 键。</p><p>序列化生成的值有以下几个特点：</p><ul><li>它带有 64 位的校验和，用于检测错误， RESTORE 在进行反序列化之前会先检查校验和。</li><li>值的编码格式和 RDB 文件保持一致。</li><li>RDB 版本会被编码在序列化值当中，如果因为 Redis 的版本不同造成 RDB 格式不兼容，那么 Redis 会拒绝对这个值进行反序列化操作。</li></ul><p>序列化的值不包括任何生存时间信息。</p><h4 id="返回值-157"><a href="#返回值-157" class="headerlink" title="返回值"></a>返回值</h4><p>如果 key 不存在，那么返回 nil 。 否则，返回序列化之后的值。</p><h4 id="代码示例-149"><a href="#代码示例-149" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET greeting <span class="string">"hello, dumping world!"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; DUMP greeting</span><br><span class="line"><span class="string">"\x00\x15hello, dumping world!\x06\x00E\xa0Z\x82\xd8r\xc1\xde"</span></span><br><span class="line"></span><br><span class="line">redis&gt; DUMP not-exists-key</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h3 id="RESTORE"><a href="#RESTORE" class="headerlink" title="RESTORE"></a>RESTORE</h3><h4 id="RESTORE-key-ttl-serialized-value-REPLACE"><a href="#RESTORE-key-ttl-serialized-value-REPLACE" class="headerlink" title="RESTORE key ttl serialized-value [REPLACE]"></a>RESTORE key ttl serialized-value [REPLACE]</h4><pre><code>可用版本： &gt;= 2.6.0时间复杂度： 查找给定键的复杂度为 O(1) ，对键进行反序列化的复杂度为 O(N*M) ，其中 N 是构成 key 的 Redis 对象的数量，而 M 则是这些对象的平均大小。 有序集合(sorted set)的反序列化复杂度为 O(N*M*log(N)) ，因为有序集合每次插入的复杂度为 O(log(N)) 。 如果反序列化的对象是比较小的字符串，那么复杂度为 O(1) 。</code></pre><p>反序列化给定的序列化值，并将它和给定的 key 关联。</p><p>参数 ttl 以毫秒为单位为 key 设置生存时间；如果 ttl 为 0 ，那么不设置生存时间。</p><p>RESTORE 在执行反序列化之前会先对序列化值的 RDB 版本和数据校验和进行检查，如果 RDB 版本不相同或者数据不完整的话，那么 RESTORE 会拒绝进行反序列化，并返回一个错误。</p><p>如果键 key 已经存在， 并且给定了 REPLACE 选项， 那么使用反序列化得出的值来代替键 key 原有的值； 相反地， 如果键 key 已经存在， 但是没有给定 REPLACE 选项， 那么命令返回一个错误。</p><p>更多信息可以参考 DUMP 命令。</p><h4 id="返回值-158"><a href="#返回值-158" class="headerlink" title="返回值"></a>返回值</h4><p>如果反序列化成功那么返回 OK ，否则返回一个错误。</p><h4 id="代码示例-150"><a href="#代码示例-150" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个键，作为 DUMP 命令的输入</span></span><br><span class="line">redis&gt; SET greeting <span class="string">"hello, dumping world!"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; DUMP greeting</span><br><span class="line"><span class="string">"\x00\x15hello, dumping world!\x06\x00E\xa0Z\x82\xd8r\xc1\xde"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将序列化数据 RESTORE 到另一个键上面</span></span><br><span class="line">redis&gt; RESTORE greeting-again 0 <span class="string">"\x00\x15hello, dumping world!\x06\x00E\xa0Z\x82\xd8r\xc1\xde"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET greeting-again</span><br><span class="line"><span class="string">"hello, dumping world!"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在没有给定 REPLACE 选项的情况下，再次尝试反序列化到同一个键，失败</span></span><br><span class="line">redis&gt; RESTORE greeting-again 0 <span class="string">"\x00\x15hello, dumping world!\x06\x00E\xa0Z\x82\xd8r\xc1\xde"</span></span><br><span class="line">(error) ERR Target key name is busy.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给定 REPLACE 选项，对同一个键进行反序列化成功</span></span><br><span class="line">redis&gt; RESTORE greeting-again 0 <span class="string">"\x00\x15hello, dumping world!\x06\x00E\xa0Z\x82\xd8r\xc1\xde"</span> REPLACE</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 尝试使用无效的值进行反序列化，出错</span></span><br><span class="line">redis&gt; RESTORE fake-message 0 <span class="string">"hello moto moto blah blah"</span></span><br><span class="line">(error) ERR DUMP payload version or checksum are wrong</span><br></pre></td></tr></table></figure><h3 id="SYNC"><a href="#SYNC" class="headerlink" title="SYNC"></a>SYNC</h3><h4 id="SYNC-1"><a href="#SYNC-1" class="headerlink" title="SYNC"></a>SYNC</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(N)</code></pre><p>用于复制功能(replication)的内部命令。</p><p>更多信息请参考 Redis 官网的 Replication 章节 。</p><h4 id="返回值-159"><a href="#返回值-159" class="headerlink" title="返回值"></a>返回值</h4><p>序列化数据。</p><h4 id="代码示例-151"><a href="#代码示例-151" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SYNC</span><br><span class="line"><span class="string">"REDIS0002\xfe\x00\x00\auser_id\xc0\x03\x00\anumbers\xc2\xf3\xe0\x01\x00\x00\tdb_number\xc0\x00\x00\x04name\x06huangz\x00\anew_key\nhello_moto\x00\bgreeting\nhello moto\x00\x05my_pc\bthinkpad\x00\x04lock\xc0\x01\x00\nlock_times\xc0\x04\xfe\x01\t\x04info\x19\x02\x04name\b\x00zhangyue\x03age\x02\x0022\xff\t\aooredis,\x03\x04name\a\x00ooredis\aversion\x03\x001.0\x06author\x06\x00huangz\xff\x00\tdb_number\xc0\x01\x00\x05greet\x0bhello world\x02\nmy_friends\x02\x05marry\x04jack\x00\x04name\x05value\xfe\x02\x0c\x01s\x12\x12\x00\x00\x00\r\x00\x00\x00\x02\x00\x00\x01a\x03\xc0f'\xff\xff"</span></span><br><span class="line">(1.90s)</span><br></pre></td></tr></table></figure><h3 id="PSYNC"><a href="#PSYNC" class="headerlink" title="PSYNC"></a>PSYNC</h3><h4 id="PSYNC-master-run-id-offset"><a href="#PSYNC-master-run-id-offset" class="headerlink" title="PSYNC master_run_id offset"></a>PSYNC master_run_id offset</h4><pre><code>可用版本： &gt;= 2.8.0时间复杂度： 不明确</code></pre><p>用于复制功能(replication)的内部命令。</p><p>更多信息请参考 复制（Replication） 文档。</p><h4 id="返回值-160"><a href="#返回值-160" class="headerlink" title="返回值"></a>返回值</h4><p>序列化数据。</p><h4 id="代码示例-152"><a href="#代码示例-152" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PSYNC ? -1</span><br><span class="line"><span class="string">"REDIS0006\xfe\x00\x00\x02kk\x02vv\x00\x03msg\x05hello\xff\xc3\x96P\x12h\bK\xef"</span></span><br></pre></td></tr></table></figure><h1 id="转载出处"><a href="#转载出处" class="headerlink" title="转载出处"></a>转载出处</h1><p><a href="http://redisdoc.com/index.html" rel="external nofollow noopener noreferrer" target="_blank">Redis命令参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Redis" scheme="https://www.sakuratears.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>使用Java发送邮件</title>
    <link href="https://www.sakuratears.top/blog/%E4%BD%BF%E7%94%A8Java%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6.html"/>
    <id>https://www.sakuratears.top/blog/使用Java发送邮件.html</id>
    <published>2019-01-26T04:49:00.000Z</published>
    <updated>2019-01-26T05:07:23.276Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在使用Java开发项目过程中我们通常会遇到发送邮件的需求，那么系统中是如何使用Java发送邮件的呢？今天我们来了解下使用Java发送邮件的两种方式。</p><p>它们分别是使用 apache-commons-email 包来发送邮件、使用javax.mail 包来发送邮件。</p><p>我们分别对它们进行了解。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="JavaMail"><a href="#JavaMail" class="headerlink" title="JavaMail"></a>JavaMail</h2><p>我们来看下使用JavaMail发送一封邮件的Java代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zwt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@detail</span>  使用JavaxMail 发送邮件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/1/23</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMail</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//SMTP主机设置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MAIL_HOST_NAME = <span class="string">"smtp.qq.com"</span>;</span><br><span class="line">    <span class="comment">//发送邮件的邮箱用户名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MAIL_SYSTEM_USER = <span class="string">"test@qq.com"</span>;</span><br><span class="line">    <span class="comment">//发送邮件的邮箱密码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MAIL_SYSTEM_PASSWORD = <span class="string">"SMTP授权码"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送邮件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subject</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> receivers</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> copys</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> attachName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">sendMail</span><span class="params">(String subject, List&lt;String&gt; receivers, List&lt;String&gt; copys, String msg, String attachName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(receivers) || (subject == <span class="keyword">null</span>) || (msg == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SendMailException(<span class="string">"Email receivers or subject or content must be not null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> isSuccess = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取系统属性</span></span><br><span class="line">            Properties properties = System.getProperties();</span><br><span class="line">            <span class="comment">// 设置邮件服务器</span></span><br><span class="line">            properties.setProperty(<span class="string">"mail.smtp.host"</span>, MAIL_HOST_NAME);</span><br><span class="line">            <span class="comment">//传输协议SMTP</span></span><br><span class="line">            properties.setProperty(<span class="string">"mail.transport.protocol"</span>, <span class="string">"smtp"</span>);</span><br><span class="line">            <span class="comment">//开启SMTP认证</span></span><br><span class="line">            properties.setProperty(<span class="string">"mail.smtp.auth"</span>, <span class="string">"true"</span>);</span><br><span class="line">            <span class="comment">//SMTP端口号</span></span><br><span class="line">            properties.setProperty(<span class="string">"mail.smtp.port"</span>,<span class="string">"465"</span>);</span><br><span class="line">            <span class="comment">//开启ssl</span></span><br><span class="line">            properties.setProperty(<span class="string">"mail.smtp.ssl.enable"</span>,<span class="string">"true"</span>);</span><br><span class="line">            <span class="comment">//用户名密码认证</span></span><br><span class="line">            properties.setProperty(<span class="string">"mail.user"</span>,MAIL_SYSTEM_USER );</span><br><span class="line">            properties.setProperty(<span class="string">"mail.password"</span>, MAIL_SYSTEM_PASSWORD);</span><br><span class="line">            <span class="comment">// 获取默认的 Session 对象。</span></span><br><span class="line">            Session session = Session.getDefaultInstance(properties);</span><br><span class="line">            <span class="comment">// 创建默认的 MimeMessage 对象。</span></span><br><span class="line">            MimeMessage message = <span class="keyword">new</span> MimeMessage(session);</span><br><span class="line">            <span class="comment">// 发信人</span></span><br><span class="line">            message.setFrom(<span class="keyword">new</span> InternetAddress(MAIL_SYSTEM_USER));</span><br><span class="line">            <span class="comment">// 收信人</span></span><br><span class="line">            <span class="keyword">for</span>(String receiver:receivers)&#123;</span><br><span class="line">                message.addRecipient(Message.RecipientType.TO,</span><br><span class="line">                        <span class="keyword">new</span> InternetAddress(receiver));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//抄送</span></span><br><span class="line">            <span class="keyword">if</span>(!CollectionUtils.isEmpty(copys))&#123;</span><br><span class="line">                <span class="keyword">for</span>(String copy:copys)&#123;</span><br><span class="line">                    message.addRecipient(Message.RecipientType.CC,</span><br><span class="line">                            <span class="keyword">new</span> InternetAddress(copy));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//邮件主题</span></span><br><span class="line">            message.setSubject(subject);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//有附件创建附件发送</span></span><br><span class="line">            <span class="keyword">if</span>(!StringUtils.isEmpty(attachName))&#123;</span><br><span class="line">                <span class="comment">// 创建消息部分</span></span><br><span class="line">                BodyPart messageBodyPart = <span class="keyword">new</span> MimeBodyPart();</span><br><span class="line">                <span class="comment">// 消息</span></span><br><span class="line">                messageBodyPart.setText(msg);</span><br><span class="line">                <span class="comment">// 创建多重消息</span></span><br><span class="line">                Multipart multipart = <span class="keyword">new</span> MimeMultipart();</span><br><span class="line">                <span class="comment">// 设置文本消息部分</span></span><br><span class="line">                multipart.addBodyPart(messageBodyPart);</span><br><span class="line">                <span class="comment">// 附件部分</span></span><br><span class="line">                messageBodyPart = <span class="keyword">new</span> MimeBodyPart();</span><br><span class="line">                DataSource source = <span class="keyword">new</span> FileDataSource(attachName);</span><br><span class="line">                messageBodyPart.setDataHandler(<span class="keyword">new</span> DataHandler(source));</span><br><span class="line">                messageBodyPart.setFileName(<span class="string">"附件"</span>);</span><br><span class="line">                multipart.addBodyPart(messageBodyPart);</span><br><span class="line">                <span class="comment">// 发送完整消息</span></span><br><span class="line">                message.setContent(multipart);   <span class="comment">//setContent方法可以插入html标签生成Html邮件</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                message.setText(msg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送消息</span></span><br><span class="line">            Transport.send(message);</span><br><span class="line"></span><br><span class="line">            isSuccess = <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (MessagingException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span>  <span class="keyword">new</span> SendMailException(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isSuccess;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"test1@qq.com"</span>);</span><br><span class="line">        sendMail(<span class="string">"test"</span>,list,<span class="keyword">null</span>,<span class="string">"测试一下"</span>,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，要发送一封邮件，Java的处理主要有以下几步：</p><p>①系统参数及属性设置，包括使用的协议（Pop3、SMTP等），是否开启ssl加密、发送邮件邮箱的用户名和密码等</p><p>②设置邮件属性，比如主题、内容、附件、接收人、抄送人等等</p><p>③发送邮件</p><p>我这儿使用的是QQ邮箱，要注意使用SMTP传输协议时，要开启SMTP，使用SSL，邮箱的认证密码不是邮箱密码，而是授权码，需要在QQ邮箱进行设置，如下：</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-369.png" alt="upload successful"></p><p>PS：在发送邮件时，如果想插入图片，可以设置成Html的内联图片，然后通过message.setContent添加这个Html文档。还有一些其它的功能（比如给某个人发送回执等）都可以通过设置实现，有兴趣的可以看下。</p><p>整个发送邮件的代码基本如上，还是比较易于理解的，我们不再对此做过多介绍。</p><h2 id="apache-commons-email"><a href="#apache-commons-email" class="headerlink" title="apache-commons-email"></a>apache-commons-email</h2><p>再来看看Apache提供的apache-commons-email这个包。</p><p>这个包就是对JavaMail进行了一层封装，我们可以看到这个工具包本质还是使用了JavaMail去发送邮件。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-370.png" alt="upload successful"></p><p>我们来看一个使用apache-commons-email包去发送邮件的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMail</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//SMTP主机设置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MAIL_HOST_NAME = <span class="string">"smtp.qq.com"</span>;</span><br><span class="line">    <span class="comment">//发送邮件的邮箱用户名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MAIL_SYSTEM_USER = <span class="string">"test@qq.com"</span>;</span><br><span class="line">    <span class="comment">//发送邮件的邮箱密码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MAIL_SYSTEM_PASSWORD = <span class="string">"SMTP授权码"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送邮件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subject  邮件主题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> receivers  接受者邮件地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> copys    要抄送的邮件地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg       内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> attachName 附件地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">sendMail</span><span class="params">(String subject, List&lt;String&gt; receivers,List&lt;String&gt; copys, String msg, String attachName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(receivers) || (subject == <span class="keyword">null</span>) || (msg == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SendMailException(<span class="string">"Email receivers or subject or content must be not null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> isSuccess = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//SimpleEmail email = new SimpleEmail();//创建简单邮件,不可添加附件、HTML文本等</span></span><br><span class="line">            <span class="comment">//MultiPartEmail  email = new MultiPartEmail();//创建能加附件的邮件,可多个、网络附件亦可</span></span><br><span class="line">            <span class="comment">//HtmlEmail email = new HtmlEmail();//创建能加附件内容为HTML文本的邮件、HTML直接内联图片但必须用setHtmlMsg()传邮件内容</span></span><br><span class="line">            MultiPartEmail email = <span class="keyword">new</span> MultiPartEmail();</span><br><span class="line">            <span class="comment">//设置smtp 主机</span></span><br><span class="line">            email.setHostName(MAIL_HOST_NAME);</span><br><span class="line">            email.setSmtpPort(<span class="number">465</span>);</span><br><span class="line">            email.setSSL(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//邮箱登录认证（保证邮件服务器POP3/SMTP服务开启）</span></span><br><span class="line">            email.setAuthentication(MAIL_SYSTEM_USER,MAIL_SYSTEM_PASSWORD);</span><br><span class="line">            <span class="comment">//收信人列表</span></span><br><span class="line">            <span class="keyword">for</span>(String receiver:receivers)&#123;</span><br><span class="line">                email.addTo(receiver, receiver);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//抄送人列表</span></span><br><span class="line">            <span class="keyword">if</span>(!CollectionUtils.isEmpty(copys))&#123;</span><br><span class="line">                <span class="keyword">for</span>(String copy:copys)&#123;</span><br><span class="line">                    email.addCc(copy,copy);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//发信人</span></span><br><span class="line">            email.setFrom(MAIL_SYSTEM_USER, MAIL_SYSTEM_USER);</span><br><span class="line">            <span class="comment">//邮件主题</span></span><br><span class="line">            email.setSubject(MimeUtility.encodeText(subject));</span><br><span class="line">            <span class="comment">//邮件内容</span></span><br><span class="line">            email.setMsg(msg);</span><br><span class="line">            <span class="comment">//邮件附件</span></span><br><span class="line">            <span class="keyword">if</span> ((attachName != <span class="keyword">null</span>) &amp;&amp; (attachName.trim().length() &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">                EmailAttachment attachment = <span class="keyword">new</span> EmailAttachment();</span><br><span class="line">                attachment.setPath(attachName);</span><br><span class="line">                attachment.setDisposition(<span class="string">"attachment"</span>);</span><br><span class="line">                email.attach(attachment);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//发送邮件</span></span><br><span class="line">            email.send();</span><br><span class="line">            isSuccess = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (EmailException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SendMailException(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SendMailException(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSuccess;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"test1@qq.com"</span>);</span><br><span class="line">        sendMail(<span class="string">"test"</span>,list,<span class="keyword">null</span>,<span class="string">"测试一下"</span>,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比两个程序，可以了解apache-commons-email这个包把JavaMail的Session给我们隐藏了，使得我们更专注于API调用，同时它分出了三种邮件类型，供我们使用。</p><p>使用apache-commons-email，要发送不同类型的邮件，可以创建不同的mail class，如下：</p><pre><code>//SimpleEmail email = new SimpleEmail();//创建简单邮件,不可添加附件、HTML文本等//MultiPartEmail  email = new MultiPartEmail();//创建能加附件的邮件,可多个、网络附件亦可//HtmlEmail email = new HtmlEmail();//创建能加附件内容为HTML文本的邮件、HTML直接内联图片</code></pre><p>上面基本上是使用Java发送邮件的两种方式。</p><p>我测试了一下发邮件的代码，可以成功收到邮件。如下图：</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-371.png" alt="upload successful"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在后台应用系统中邮件系统还是比较常用的，可以用来提供系统邮件预警、发送客户邮件进行活动推广等等一系列的事情。<br>SpringBoot里整合了JavaMail，创建SpringBoot项目时可以直接引入，是十分方便的。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-372.png" alt="upload successful"></p><p>在application.properties里的配置均以spring.mail开头。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># JavaMailSender 邮件发送的配置</span><br><span class="line">spring.mail.host=smtp.qq.com</span><br><span class="line">spring.mail.username=qq邮箱</span><br><span class="line">#QQ邮箱的授权码</span><br><span class="line">spring.mail.password=授权码</span><br><span class="line">spring.mail.properties.mail.smtp.auth=true</span><br><span class="line">spring.mail.properties.mail.smtp.starttls.enable=true</span><br><span class="line">spring.mail.properties.mail.smtp.starttls.required=true</span><br><span class="line">spring.mail.default-encoding=UTF-8</span><br><span class="line">spring.mail.protocol=smtp</span><br><span class="line">spring.mail.port=465</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="JavaMail" scheme="https://www.sakuratears.top/tags/JavaMail/"/>
    
      <category term="Java邮件" scheme="https://www.sakuratears.top/tags/Java%E9%82%AE%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>JWT简介及使用</title>
    <link href="https://www.sakuratears.top/blog/JWT%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BD%BF%E7%94%A8.html"/>
    <id>https://www.sakuratears.top/blog/JWT简介及使用.html</id>
    <published>2019-01-22T14:16:00.000Z</published>
    <updated>2019-01-22T14:48:29.222Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>JWT（JSON Web Tokens）是目前比较流行的跨域认证解决方案，遵循RFC 7519 标准，我们可以使用JWT在用户和服务器之间传递安全可靠的信息。</p><p>我们可以在 <a href="https://jwt.io/" rel="external nofollow noopener noreferrer" target="_blank">JWT的官网</a> 了解到更多关于JWT的信息。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h2><p>JWT主要由<strong>头部</strong>、<strong>载荷</strong>与<strong>签名</strong>三部分构成，三部分的信息用英文逗号“.”分割。</p><p>一个完整的JWT如下：</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-361.png" alt="upload successful"></p><p>它的头部部分（Header）为红色标注部分，载荷（Payload）为蓝色部分，签名（Signature）为橘色部分。</p><p>它们均使用Base64进行编码，我们将上述Base64解码后可以看到如下：</p><p><strong>Header部分Json：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"typ"</span>: <span class="string">"JWT"</span>,</span><br><span class="line"><span class="attr">"alg"</span>: <span class="string">"HS256"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这儿Header声明了使用的加密算法（HS256）及token类型（JWT）。</p><p><strong>Payload部分Json如下：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"phone"</span>: <span class="string">"1888888888"</span>,</span><br><span class="line"><span class="attr">"sessionId"</span>: <span class="string">"111111111111"</span>,</span><br><span class="line"><span class="attr">"exp"</span>: <span class="number">1548052800</span>,</span><br><span class="line"><span class="attr">"userId"</span>: <span class="string">"1433223"</span>,</span><br><span class="line"><span class="attr">"platform"</span>: <span class="string">"APP"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中除exp字段其它都是我自定义的字段。JWT 规定了7个官方字段，供我们选用，如下：</p><pre><code>iss (issuer)：签发人exp (expiration time)：过期时间sub (subject)：主题aud (audience)：受众nbf (Not Before)：生效时间iat (Issued At)：签发时间jti (JWT ID)：编号</code></pre><p>PS：可以看到信息仅仅使用了Base64进行了一下编码，非加密，如果我们想是信息更安全可以对JWT生成的token进行可逆加密。</p><p><strong>Signature部分:</strong></p><p>会对上面两部分进行签名，通常使用<strong>RSA，Hmac或者ECDSA等</strong>签名方式。用于防止上面两部分的数据遭到篡改。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>要想在Java项目里使用JWT，需要引入以下依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--JSON Web Tokens--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.auth0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>java-jwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们来简单的看一下它的源码部分。</p><p>先看一下包的结构：</p><pre><code>algorithm：各种签名的包。exceptions：自定义异常类的包。interfaces和impl：JWT的接口和实现类包。</code></pre><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-362.png" alt="upload successful"></p><p>在algorithm包里我们可以看到我们刚才描述的几种签名算法（RSA，HMAC，ECDSA）。</p><p>在JWTCreator类中，我们可以看到Signature部分是通过Header，Payload经过签名算法得来的。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-363.png" alt="upload successful"></p><p>同时载荷Payload里JWT规定的几个可使用字段也能看到。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-364.png" alt="upload successful"></p><p>生成签名，放入Header信息及Payload信息，使用指定签名算法生成JWT token。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-365.png" alt="upload successful"></p><p>JWTDecoder类为解密token的类，可以看到它的处理方法，获取headerJson和payloadJson，还是比较好理解的。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-366.png" alt="upload successful"></p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>我们使用JWT生成token并使用。</p><p>我们知道，前后端使用token进行交互，服务器端可以不用保存session状态，减轻压力。</p><p>我们定义一个Vo，用于存放一些用户数据，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Accessors</span>(chain = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserVo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户手机号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户唯一Id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * sessionId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String sessionId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过期时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> expiresAt;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户所属平台</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String platform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以认为这些为公共部分，用户登录后应该携带这些信息。</p><p>这样我们就可以使用JWT在该用户登录后生成一个有效token，为保证信息安全，我们可以对生成的token进行加密，如下：</p><p>我们使用AES算法对token进行加解密。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AESUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String ENCODING_UTF8 = <span class="string">"utf-8"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_ALGORITHM = <span class="string">"AES"</span>;</span><br><span class="line">    <span class="comment">/**默认的加密算法*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CIPHER_ALGORITHM = <span class="string">"AES/CBC/PKCS5Padding"</span>;</span><br><span class="line">    <span class="keyword">private</span> String secretKeySeed = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> String ivParameterSeed = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AESUtils</span><span class="params">(String secretKeySeed,String ivParameterSeed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.secretKeySeed = secretKeySeed;</span><br><span class="line">        <span class="keyword">if</span> (ivParameterSeed.length() != <span class="number">16</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"iv向量长度必须为16"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.ivParameterSeed=ivParameterSeed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AESUtils</span><span class="params">(String secretKeySeed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (secretKeySeed.length() != <span class="number">16</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"iv向量长度必须为16"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.secretKeySeed = secretKeySeed;</span><br><span class="line">        <span class="keyword">this</span>.ivParameterSeed=secretKeySeed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AES加密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">aesEncrypt</span><span class="params">(String content)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// AES加密</span></span><br><span class="line">        <span class="keyword">byte</span>[] encryptStr = encrypt(content, secretKeySeed,ivParameterSeed);</span><br><span class="line">        <span class="comment">// BASE64位加密</span></span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(encryptStr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AES解密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptStr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">aesDecrypt</span><span class="params">(String encryptStr)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// BASE64位解密</span></span><br><span class="line">        <span class="keyword">byte</span>[] decodeBase64 = Base64.decodeBase64(encryptStr);</span><br><span class="line">        <span class="comment">// AES解密</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(decrypt(decodeBase64, secretKeySeed,ivParameterSeed),ENCODING_UTF8);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成加密秘钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> SecretKeySpec <span class="title">getSecretKeySpec</span><span class="params">(<span class="keyword">final</span> String secretKeySeed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SecretKeySpec(secretKeySeed.getBytes(), <span class="string">"AES"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            log.error(<span class="string">"生成加密密钥异常"</span>,ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成向量秘钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IvParameterSpec <span class="title">getIvParameterSpec</span><span class="params">(<span class="keyword">final</span> String ivParameterSeed)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用CBC模式，需要一个向量iv，可增加加密算法的强度</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IvParameterSpec(ivParameterSeed.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> byte[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encrypt(String content, String secretKeySeed,String ivParameterSeed) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建密码器</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);</span><br><span class="line">        <span class="comment">// 初始化为加密模式的密码器</span></span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, getSecretKeySpec(secretKeySeed),getIvParameterSpec(ivParameterSeed));</span><br><span class="line">        <span class="comment">// 加密</span></span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(content.getBytes(ENCODING_UTF8));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> byte[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decrypt(<span class="keyword">byte</span>[] content, String secretKeySeed,String ivParameterSeed) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建密码器</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);</span><br><span class="line">        <span class="comment">// 初始化为加密模式的密码器</span></span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, getSecretKeySpec(secretKeySeed),getIvParameterSpec(ivParameterSeed));</span><br><span class="line">        <span class="comment">// 解密</span></span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，根据刚才我们的说明创建一个JWT帮助类用于生成token，大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JWTUtils</span> </span>&#123;</span><br><span class="line">    <span class="comment">//JWT header</span></span><br><span class="line">    <span class="keyword">private</span> String JWT_HEADER = <span class="string">""</span>;</span><br><span class="line">    <span class="comment">//签名算法</span></span><br><span class="line">    <span class="keyword">private</span> Algorithm algorithm;</span><br><span class="line">    <span class="comment">//默认token过期时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> expireTimeMillis=<span class="number">2</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> AtomicBoolean initState = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AESUtils aesUtils=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> JWTUtils instance = <span class="keyword">new</span> JWTUtils();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JWTUtils <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JWTUtils.SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化jwt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jwtSecretKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jwtExpireTimeSeconds</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> aesSecretKeySeed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> aesIvParameterSeed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedEncodingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(String jwtSecretKey,<span class="keyword">long</span> jwtExpireTimeSeconds,String aesSecretKeySeed,String aesIvParameterSeed)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initState.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.algorithm = Algorithm.HMAC256(jwtSecretKey);</span><br><span class="line">            <span class="keyword">if</span>(jwtExpireTimeSeconds&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.expireTimeMillis = jwtExpireTimeSeconds * <span class="number">1000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.JWT_HEADER = StringUtils.substringBefore(JWT.create().sign(Algorithm.HMAC256(jwtSecretKey)), <span class="string">"."</span>)+<span class="string">"."</span>;</span><br><span class="line">            aesUtils = <span class="keyword">new</span> AESUtils(aesSecretKeySeed, aesIvParameterSeed);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            log.error(<span class="string">"重复初始化jwt"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用jwt生成token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userVo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">encodeJWT</span><span class="params">(UserVo userVo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> encodeJWT(userVo,<span class="keyword">this</span>.expireTimeMillis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userVo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTimeMillis</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">encodeJWT</span><span class="params">(UserVo userVo,<span class="keyword">long</span> expireTimeMillis)</span></span>&#123;</span><br><span class="line">        String token = JWT.create()</span><br><span class="line">                .withExpiresAt(<span class="keyword">new</span> Date(System.currentTimeMillis()+expireTimeMillis))</span><br><span class="line">                .withClaim(<span class="string">"phone"</span>,userVo.getPhone())</span><br><span class="line">                .withClaim(<span class="string">"userId"</span>,userVo.getUserId())</span><br><span class="line">                .withClaim(<span class="string">"sessionId"</span>,userVo.getSessionId())</span><br><span class="line">                .withClaim(<span class="string">"platform"</span>,userVo.getPlatform())</span><br><span class="line">                .sign(algorithm);</span><br><span class="line">        System.out.println(<span class="string">"token----&gt; "</span>+token);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            token = aesUtils.aesEncrypt(StringUtils.removeStart(token, JWT_HEADER));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            log.error(<span class="string">"加密异常"</span>,ex);</span><br><span class="line">            token = <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserVo <span class="title">decodeJWT</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        UserVo userVo =<span class="keyword">new</span> UserVo();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isBlank(token)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"无效token"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            String decryptJwtToken = aesUtils.aesDecrypt(token);</span><br><span class="line">            JWTVerifier verifier = JWT.require(algorithm).build();</span><br><span class="line">            DecodedJWT jwt = verifier.verify(StringUtils.join(JWT_HEADER,decryptJwtToken));</span><br><span class="line">            <span class="keyword">long</span> expiresAt = jwt.getExpiresAt()==<span class="keyword">null</span>?<span class="number">0</span>:jwt.getExpiresAt().getTime();</span><br><span class="line">            <span class="keyword">if</span>(System.currentTimeMillis()&gt;expiresAt)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"token有效期超期"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Map&lt;String, Claim&gt; claims = jwt.getClaims();</span><br><span class="line">            userVo.setPhone(claims.get(<span class="string">"phone"</span>)==<span class="keyword">null</span>?<span class="string">""</span>:claims.get(<span class="string">"phone"</span>).asString());</span><br><span class="line">            userVo.setUserId(claims.get(<span class="string">"userId"</span>)==<span class="keyword">null</span>?<span class="string">""</span>:claims.get(<span class="string">"userId"</span>).asString());</span><br><span class="line">            userVo.setSessionId(claims.get(<span class="string">"sessionId"</span>)==<span class="keyword">null</span>?<span class="string">""</span>:claims.get(<span class="string">"sessionId"</span>).asString());</span><br><span class="line">            userVo.setPlatform(claims.get(<span class="string">"platform"</span>)==<span class="keyword">null</span>?<span class="string">""</span>:claims.get(<span class="string">"platform"</span>).asString());</span><br><span class="line">            userVo.setExpiresAt(expiresAt);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exception)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"无效token"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> userVo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，一个简单的JWT工具类就搞定了，可以用于生成token。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>我们测试一下效果，新建方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    JWTUtils jwtUtils = JWTUtils.getInstance();</span><br><span class="line">    jwtUtils.init(<span class="string">"sakuratears"</span>,<span class="number">1000</span>,<span class="string">"1234567891111111"</span>,<span class="string">"test111111111111"</span>);</span><br><span class="line">    UserVo userVo = <span class="keyword">new</span> UserVo();</span><br><span class="line">    userVo.setUserId(<span class="string">"1433223"</span>).setPhone(<span class="string">"1888888888"</span>).setPlatform(<span class="string">"APP"</span>).setSessionId(<span class="string">"111111111111"</span>);</span><br><span class="line">    String token = jwtUtils.encodeJWT(userVo);</span><br><span class="line">    System.out.println(<span class="string">"加密token----&gt; "</span>+token);</span><br><span class="line">    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">    UserVo vo = jwtUtils.decodeJWT(token);</span><br><span class="line">    System.out.println(<span class="string">"解密token得到结果----&gt; "</span>+vo.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-367.png" alt="upload successful"></p><p>我们尝试缩短token失效时间，增加线程等待时间。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jwtUtils.init(<span class="string">"sakuratears"</span>,<span class="number">1</span>,<span class="string">"1234567891111111"</span>,<span class="string">"test111111111111"</span>);</span><br><span class="line">......</span><br><span class="line">Thread.sleep(<span class="number">10000</span>);</span><br></pre></td></tr></table></figure><p>再次运行，可以看到token已失效。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-368.png" alt="upload successful"></p><p>所以我们在为客户端颁发token后，应该设置合理的token失效时间，当token失效后，再次请求，应告诉用户需要重新登录了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>经过上面的一些描述，我们可以知道JWT的一些特点。</p><ol><li><p>JWT默认是不加密的，为了保证安全，可以对JWT（token）进行可逆加密处理。</p></li><li><p>JWT可以用于信息交换，比如上面UserVo里面的手机号，这样我们不用在使用userId在对用户进行数据库查询，提高系统性能。</p></li><li><p>可以看到，JWT一旦签发生成token，如果不设置超时时间或者设置不合理（过长），在有效期内，token始终是有效的，除非服务器进行额外的处理。所以如果token泄露或被盗用，将是十分危险的，故应当设置合理的过期时间。</p></li><li><p>为了减少泄露或者盗用风险，JWT一般使用HTTPS协议进行传输。若使用HTTP协议，务必对token进行可逆加密处理后在进行传输。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="JWT" scheme="https://www.sakuratears.top/tags/JWT/"/>
    
      <category term="Java Web Token" scheme="https://www.sakuratears.top/tags/Java-Web-Token/"/>
    
      <category term="Token" scheme="https://www.sakuratears.top/tags/Token/"/>
    
  </entry>
  
</feed>
