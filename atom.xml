<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SakuraTears的博客</title>
  
  <subtitle>越努力越幸运</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.sakuratears.top/"/>
  <updated>2019-10-16T15:09:15.611Z</updated>
  <id>https://www.sakuratears.top/</id>
  
  <author>
    <name>SakuraTears</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何使Java项目生成可执行的exe文件</title>
    <link href="https://www.sakuratears.top/blog/%E5%A6%82%E4%BD%95%E4%BD%BFJava%E9%A1%B9%E7%9B%AE%E7%94%9F%E6%88%90%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%9A%84exe%E6%96%87%E4%BB%B6.html"/>
    <id>https://www.sakuratears.top/blog/如何使Java项目生成可执行的exe文件.html</id>
    <published>2019-10-16T14:48:00.000Z</published>
    <updated>2019-10-16T15:09:15.611Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前些天，有个朋友问我可否使用Java制作一个exe程序，要求运行程序可以实现某些功能。</p><p>我出于好奇了解了一下，是可以使用Java制作一些客户端exe程序的。</p><p>过程感觉还是比较有意思的，特此记录下来。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>因为这类程序一般都为客户端程序，涉及到较古老的<code>JFrame</code>，我就简单的使用一个例子来说明下。</p><p>我们比如说想制作一个读取文件大小的exe文件。</p><h2 id="构建Java项目"><a href="#构建Java项目" class="headerlink" title="构建Java项目"></a>构建Java项目</h2><p>我们首先构建一个普通的Java Maven项目，如下图。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-529.jpg" alt="upload successful"></p><p>随便给项目起个名称。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-530.jpg" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-531.jpg" alt="upload successful"></p><p>这儿我们不需要任何maven依赖，如果项目较复杂可以引入需要的maven依赖等。</p><p>我们新建一个Frame实现文件读取大小功能。</p><p>test14.jpg</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileHelper</span> <span class="keyword">extends</span> <span class="title">JFrame</span> <span class="keyword">implements</span> <span class="title">ActionListener</span> </span>&#123;</span><br><span class="line">    JButton open=<span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> FileHelper();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileHelper</span><span class="params">()</span></span>&#123;</span><br><span class="line">        open=<span class="keyword">new</span> JButton(<span class="string">"请选择要处理的文件"</span>);</span><br><span class="line">        <span class="keyword">this</span>.add(open);</span><br><span class="line">        <span class="keyword">this</span>.setBounds(<span class="number">400</span>, <span class="number">200</span>, <span class="number">1000</span>, <span class="number">500</span>);</span><br><span class="line">        <span class="keyword">this</span>.setVisible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        open.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">        JFileChooser jfc=<span class="keyword">new</span> JFileChooser();</span><br><span class="line">        jfc.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES );</span><br><span class="line">        jfc.showDialog(<span class="keyword">new</span> JLabel(), <span class="string">"选择"</span>);</span><br><span class="line">        File file=jfc.getSelectedFile();</span><br><span class="line">        <span class="keyword">if</span>(file.isDirectory())&#123;</span><br><span class="line">            JOptionPane.showMessageDialog(<span class="keyword">null</span>, <span class="string">"请选择一个文件"</span>, <span class="string">"信息"</span>, JOptionPane.INFORMATION_MESSAGE);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(file.isFile())&#123;</span><br><span class="line">            <span class="keyword">if</span>(file.canRead())&#123;</span><br><span class="line">                <span class="keyword">long</span> bytes = file.length();</span><br><span class="line">                String size = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">if</span>(bytes &lt; <span class="number">1024</span>)&#123;</span><br><span class="line">                    size = bytes + <span class="string">"B"</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bytes &lt; <span class="number">1048576</span>)&#123;</span><br><span class="line">                    size = bytes/<span class="number">1024</span> + <span class="string">"KB"</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    size = bytes/<span class="number">1048576</span> + <span class="string">"MB"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                String message = <span class="string">"该文件大小为:"</span>+size + <span class="string">"\r\n文件路径:"</span>+file.getPath();</span><br><span class="line">                JOptionPane.showMessageDialog(<span class="keyword">null</span>, message, <span class="string">"信息"</span>, JOptionPane.INFORMATION_MESSAGE);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                JOptionPane.showMessageDialog(<span class="keyword">null</span>, <span class="string">"该文件不可读"</span>, <span class="string">"信息"</span>, JOptionPane.INFORMATION_MESSAGE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们运行一下，可以成功启动此项目。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-532.jpg" alt="upload successful"></p><p>那我们如何将它转换为exe呢？</p><h2 id="生成可执行jar文件"><a href="#生成可执行jar文件" class="headerlink" title="生成可执行jar文件"></a>生成可执行jar文件</h2><p>在生成exe之前，我们需要先生成可执行jar文件，再将jar文件转换成exe文件。</p><p>我们打开IDEA项目结构（File -&gt; Project Structure -&gt; Artifacts），如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-533.jpg" alt="upload successful"></p><p>使项目可以生成一个可执行的jar包。</p><p>这儿要注意选择好项目和启动Main入口后，MANIFSET.MF一定到生成到src文件夹下。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-534.jpg" alt="upload successful"></p><p>完成后会看到我们项目的一些信息，这儿我们配置生成的jar输出到项目目录out下，点击OK即可。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-535.jpg" alt="upload successful"></p><p>这时候在项目src目录下可以看到META-INF文件夹及文件夹里的MANIFSET.MF文件，没有就说明配置错了。</p><p>在IDEA里找到 Build -&gt; Build Artifacts，选择这个项目，点击Build。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-536.jpg" alt="upload successful"></p><p>完成后会看到我们生成的jar包。</p><p>我们copy出来并使用Java运行一下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar framework-exe-app.jar</span><br></pre></td></tr></table></figure><p>可以看到成功运行。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-537.jpg" alt="upload successful"></p><p>显然我们只得到了一个只能在有JRT环境上运行的jar包，下一步我们来把它转成exe文件。</p><h2 id="生成exe文件"><a href="#生成exe文件" class="headerlink" title="生成exe文件"></a>生成exe文件</h2><p>将jar文件转换为exe文件，需要下载exe4j工具，<a href="https://exe4j.apponic.com/" rel="external nofollow noopener noreferrer" target="_blank">exe4j</a>。</p><p>下载完成后安装，会打开welcome界面，这个界面是用来输注册码用的，如果不输入，是可以直接next进行下去的。但若是不输入，双击生成的exe时，会alert出一段话，如图。必须点“确定”才可以执行程序。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-538.jpg" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-539.jpg" alt="upload successful"></p><p>关于License Key，网上可以找到，这儿也提供了一些。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A-XVK258563F-1p4lv7mg7sav</span><br><span class="line">A-XVK209982F-1y0i3h4ywx2h1</span><br><span class="line">A-XVK267351F-dpurrhnyarva</span><br><span class="line">A-XVK204432F-1kkoilo1jy2h3r</span><br><span class="line">A-XVK246130F-1l7msieqiwqnq</span><br><span class="line">A-XVK249554F-pllh351kcke50</span><br><span class="line">A-XVK238729F-25yn13iea25i</span><br><span class="line">A-XVK222711F-134h5ta8yxbm0</span><br></pre></td></tr></table></figure><p>配置后，直接点击Next，选择”JAR” in “EXE” mode，如下图。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-540.jpg" alt="upload successful"></p><p>点击Next，我们输入应用名（这儿我起名MyApp），然后文件输出路径我们新建一个文件夹，然后输出到这个文件夹下。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-541.jpg" alt="upload successful"></p><p>点击Next，在这个页面我们需要配置名称，应用图标可配置可以不配置，如果应用不允许多开则需要勾选 Allow 那个选项。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-542.jpg" alt="upload successful"></p><p>这儿在Advance Options里，还有一些其它可选项，有兴趣的童鞋可以自己看一下。</p><p>如果不想生成错误日志，可以去掉如图选项。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-543.jpg" alt="upload successful"></p><p>这儿我们在这里面选中生成64-bit的应用程序。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-544.jpg" alt="upload successful"></p><p>在第5步Java invocation页面，VM Parameters输入<code>-Dappdir=${EXE4J_EXEDIR}</code>，然后我们将我们生成的jar包引入，如下图：</p><p>Class Path —&gt; + —&gt; Archive —&gt; 选择jar包 —&gt; OK</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-545.jpg" alt="upload successful"></p><p>然后配置我们的程序入口。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-546.jpg" alt="upload successful"></p><p>点击Next，到达第6步，需要设置jre版本，如下图：</p><p>需要设置最小的jre版本，然后在Advance Options里，选择Search Sequence，我们设置使用自己的JRE，这样生成的应用程序可以在没有安装Java的系统上使用。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-547.jpg" alt="upload successful"></p><p>在这之前，我们需要一份JRE（Java Runtime Environment）文件，可以在Java安装目录里找到，或者在官网上下载。比如 <a href="https://www.oracle.com/technetwork/java/javase/downloads/jre8-downloads-2133155.html" rel="external nofollow noopener noreferrer" target="_blank">jre-8u231</a>。</p><p>将它复制到我们之前创建的MyApp目录里，在Search Sequence里选择它。（之前Search Sequence的默认的3个直接删除即可）。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-548.jpg" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-549.jpg" alt="upload successful"></p><p>点击Next，到达第7步，这儿是设置App启动图，可以不设置。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-550.jpg" alt="upload successful"></p><p>第8步默认即可。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-551.jpg" alt="upload successful"></p><p>点击Next，到达最后一步，可以点击<code>Click Here to start Application</code>按钮测试一下应用程序。</p><p>成功说明没有问题，点击<code>Exit</code>按钮即可。</p><p>最后它会问你要不要保存配置信息，保存的话可以下次使用这个配置，这个按自己需要来即可。</p><p>退出后我们在我们的MyApp文件夹下可以找到刚才生成的App，可以运行一下是没有问题的。</p><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><p>我们虽然制作完成了该App，可是我们发现，我们把应用程序exe文件单独移动到一个地方，运行时，就会报找不到JRE环境。</p><p>这是比较容易理解的，我们使用Java编译的class文件，最终转换成了exe文件，但是仍不能离开JRE环境运行，也就是需要将整个MyApp文件夹进行移动，或者作为一个项目（App）。</p><p>这显然和在一台机器上安装JRE没有本质区别……</p><p>就是变成了我们使用了项目自带的JRE环境。</p><p>这也是没有办法的事，因为Java的平台无关性，就是基于它的JRE环境，脱离JRE环境也无法运行class文件，我们的exe其实只是一层包装而已。</p><h2 id="可安装版本的exe文件"><a href="#可安装版本的exe文件" class="headerlink" title="可安装版本的exe文件"></a>可安装版本的exe文件</h2><p>即使是一层包装，能不能使它在优化下呢？起码别人一看起来不立马觉得别扭？</p><p>其实我们可以继续对exe文件和jre部分继续进行包装，使它成为一个安装版本的可执行文件。</p><p>这儿我们需要使用到 Inno Setup，这儿我们可以下载它 <a href="http://www.jrsoftware.org/isdl.php" rel="external nofollow noopener noreferrer" target="_blank">Inno Setup Downloads</a></p><p>下载安装完成（过程略）后打开，如下图：</p><p>我们选择使用生成向导来一步步引导我们生成exe文件。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-552.jpg" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-553.jpg" alt="upload successful"></p><p>我们可以设置自己的App名字及一些基本信息。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-554.jpg" alt="upload successful"></p><p>项目的安装路径，和是否允许用户更改安装路径参数设置我们直接取默认就好。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-555.jpg" alt="upload successful"></p><p>找到我们刚生成的exe文件，然后添加必要文件（jre文件），注意需要将jre文件夹下的全部文件添加上。</p><p>PS: 这儿我们需要新建一个temp文件夹，将jre移动进来，然后选择temp，这样生成的MyApp.exe会和jre文件夹在同一级，不然MyApp.exe找不到JRE环境。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-556.jpg" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-557.jpg" alt="upload successful"></p><p>然后下一步，是配置应用图标创建显示的，如果允许用户不在桌面创建图标，可以如下配置：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-558.jpg" alt="upload successful"></p><p>下一步关于License File 我们直接跳过就行。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-559.jpg" alt="upload successful"></p><p>下一步是安装后使用者权限，我们默认安装后所有人都可以使用即可。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-560.jpg" alt="upload successful"></p><p>下一步设置安装语言，用默认English即可。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-561.jpg" alt="upload successful"></p><p>然后设置生成的文件路径，还有应用图标等。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-562.jpg" alt="upload successful"></p><p>然后下一步到完成。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-563.jpg" alt="upload successful"></p><p>编译时会问到是否保存编译脚本，依照自己选择即可。</p><p>编译效果图如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-564.jpg" alt="upload successful"></p><p>最后会生成可安装的exe文件，我们运行下，把它安装一下。</p><p>我们安装完成可以看一下它的目录，其实和我们刚才的一模一样，只不过现在变成了一整个安装exe，而且安装包体积也被压缩了。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-565.jpg" alt="upload successful"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章没什么特别要总结的，主要就是相关工具的使用。</p><p>可以看到我们一个小小的功能，但生成的exe是巨大的，但是随着项目文件变多，jre占用比例减小，就是逐渐可以接受的了。</p><p>现在Java已经很少在桌面客户端进行一些开发工作了，但了解一下Java-exe的生成过程也是比较有意思的。</p><p>今天的内容就到这里吧。</p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>源码详见于我的 <a href="https://github.com/JavaZWT/" rel="external nofollow noopener noreferrer" target="_blank">GitHub</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="exe" scheme="https://www.sakuratears.top/tags/exe/"/>
    
      <category term="exe4j" scheme="https://www.sakuratears.top/tags/exe4j/"/>
    
      <category term="Inno Setup" scheme="https://www.sakuratears.top/tags/Inno-Setup/"/>
    
  </entry>
  
  <entry>
    <title>Java sort和parallelSort接口及其实现</title>
    <link href="https://www.sakuratears.top/blog/Java-sort%E5%92%8CparallelSort%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0.html"/>
    <id>https://www.sakuratears.top/blog/Java-sort和parallelSort接口及其实现.html</id>
    <published>2019-10-14T14:12:00.000Z</published>
    <updated>2019-10-14T15:22:01.696Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上篇文章我们介绍了 <a href="https://www.sakuratears.top/blog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B9%9D%EF%BC%89-Java%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84DualPivotQuicksort.html#more">排序算法（九）-Java源码中的DualPivotQuicksort</a>，今天我们来看下sort接口的实现，看看JDK对数据排序这块到底做了哪些优化。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="sort接口"><a href="#sort接口" class="headerlink" title="sort接口"></a>sort接口</h2><p>sort接口有多个重载的方法，我们整理下后，它们分别如下：</p><p>在 <code>java.util.Arrays</code>类里，调用 <code>Array.sort(a)</code>方法，可以对数组a进行排序，它有18个重载方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//整个int数组排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    DualPivotQuicksort.sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对int数组from到to的位置进行排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">    DualPivotQuicksort.sort(a, fromIndex, toIndex - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//long数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">long</span>[] a)</span> </span>&#123;</span><br><span class="line">    DualPivotQuicksort.sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">long</span>[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">    DualPivotQuicksort.sort(a, fromIndex, toIndex - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//short数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">short</span>[] a)</span> </span>&#123;</span><br><span class="line">    DualPivotQuicksort.sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">short</span>[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">    DualPivotQuicksort.sort(a, fromIndex, toIndex - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//char数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">char</span>[] a)</span> </span>&#123;</span><br><span class="line">    DualPivotQuicksort.sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">    DualPivotQuicksort.sort(a, fromIndex, toIndex - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//byte数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">byte</span>[] a)</span> </span>&#123;</span><br><span class="line">    DualPivotQuicksort.sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">byte</span>[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">    DualPivotQuicksort.sort(a, fromIndex, toIndex - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//float数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">float</span>[] a)</span> </span>&#123;</span><br><span class="line">    DualPivotQuicksort.sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">float</span>[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">    DualPivotQuicksort.sort(a, fromIndex, toIndex - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//double数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">double</span>[] a)</span> </span>&#123;</span><br><span class="line">    DualPivotQuicksort.sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">double</span>[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">    DualPivotQuicksort.sort(a, fromIndex, toIndex - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Object数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (LegacyMergeSort.userRequested)</span><br><span class="line">        legacyMergeSort(a);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ComparableTimSort.sort(a, <span class="number">0</span>, a.length, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Object[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">    <span class="keyword">if</span> (LegacyMergeSort.userRequested)</span><br><span class="line">        legacyMergeSort(a, fromIndex, toIndex);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ComparableTimSort.sort(a, fromIndex, toIndex, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] a, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sort(a);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (LegacyMergeSort.userRequested)</span><br><span class="line">            legacyMergeSort(a, c);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            TimSort.sort(a, <span class="number">0</span>, a.length, c, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">                            Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sort(a, fromIndex, toIndex);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">        <span class="keyword">if</span> (LegacyMergeSort.userRequested)</span><br><span class="line">            legacyMergeSort(a, fromIndex, toIndex, c);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            TimSort.sort(a, fromIndex, toIndex, c, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p><strong>可以看到对于基本数据类型，因为排序稳定性不会对数据造成影响（两个一样的数据谁前谁后都可以），故使用了DualPivotQuicksort排序算法。</strong></p><p><strong>对于Object数组(没有继承Comparator接口的数据类型)，会先判断一个<code>LegacyMergeSort.userRequested</code>的值是否为真，如果为真就使用legacyMergeSort排序算法，否则就使用ComparableTimSort排序算法。</strong></p><p><strong>对于泛型数组T []，如果比较器<code>Comparator</code>为空，就按照Object []方式进行处理；如果有比较器的话，照样先判断<code>LegacyMergeSort.userRequested</code>的值是否为真，是的话就用legacyMergeSort排序算法，否则就使用TimSort排序算法。</strong></p><p><strong>其他地方的sort最终会调用<code>Array.sort(a)</code>方法。如<code>java.util.Collections</code>类里的<code>sort(List<t> list)</t></code>方法，最终调用了<code>Array.sort(T[] a)</code>。</strong></p><p>根据上面的分析，我们先来看看<code>LegacyMergeSort.userRequested</code>这个参数吧，因为它决定非基本数据类型数组到底是使用legacyMergeSort还是TimSort（ComparableTimSort是TimSort的Object []版本，也相当于TimSort）。</p><p>追踪源码，<code>LegacyMergeSort.userRequested</code>赋值过程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LegacyMergeSort</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> userRequested =</span><br><span class="line">            java.security.AccessController.doPrivileged(</span><br><span class="line">                <span class="keyword">new</span> sun.security.action.GetBooleanAction(</span><br><span class="line">                    <span class="string">"java.util.Arrays.useLegacyMergeSort"</span>)).booleanValue();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到它是可以通过系统设置进行配置的，<code>java -Djava.util.Arrays.useLegacyMergeSort=true</code>，可以设置使用老的归并排序。</p><p>这个值默认是false，即不使用归并排序，Java之所以有这部分判断，完全是为了兼容老版本，同时归并排序这部分将在未来移除（当前介绍版本为JDK1.8，在JDK11中发现已经移除）。</p><p>legacyMergeSort这个方法涉及到的就是归并排序，关于这部分，我们不再展示源码（Java未来版本也会移除），有兴趣的可以看看我之前的文章<a href="https://www.sakuratears.top/blog/Java%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%88Merge-Sort%EF%BC%89">归并排序(MergeSort)</a>部分。这两者唯一不同的是Java的legacyMergeSort在排序部分长度小于 INSERTIONSORT_THRESHOLD = 7 的时候，会使用插入排序，相当于提高了普通归并的效率。</p><p>TimSort或者ComparableTimSort我在之前文章中也有分析了，有兴趣的可以看看，这儿不过多介绍。<a href="https://www.sakuratears.top/blog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89-TimSort.html#more">排序算法（六）- TimSort</a>。</p><p>关于Java源码里的DualPivotQuicksort内容详见这篇文章<a href="https://www.sakuratears.top/blog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B9%9D%EF%BC%89-Java%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84DualPivotQuicksort.html#more">排序算法（九）-Java源码中的DualPivotQuicksort</a>。</p><h2 id="parallelSort接口"><a href="#parallelSort接口" class="headerlink" title="parallelSort接口"></a>parallelSort接口</h2><p>看完串行排序接口，我们再来看下Java自带排序的并行版本parallelSort接口，看看它是如何实现并行排序的。</p><p>先看看它的几个重载方法,由于基本数据类型数组的parallelSort都是类似的，这儿我只拿int[]进行举例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int数据并行排序方法（其它基本数据类型数组和其类似，这儿代码就不在展示）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parallelSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.length, p, g;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= MIN_ARRAY_SORT_GRAN ||</span><br><span class="line">        (p = ForkJoinPool.getCommonPoolParallelism()) == <span class="number">1</span>)</span><br><span class="line">        DualPivotQuicksort.sort(a, <span class="number">0</span>, n - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">new</span> ArraysParallelSortHelpers.FJInt.Sorter</span><br><span class="line">            (<span class="keyword">null</span>, a, <span class="keyword">new</span> <span class="keyword">int</span>[n], <span class="number">0</span>, n, <span class="number">0</span>,</span><br><span class="line">                ((g = n / (p &lt;&lt; <span class="number">2</span>)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span><br><span class="line">                MIN_ARRAY_SORT_GRAN : g).invoke();</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parallelSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">    <span class="keyword">int</span> n = toIndex - fromIndex, p, g;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= MIN_ARRAY_SORT_GRAN ||</span><br><span class="line">        (p = ForkJoinPool.getCommonPoolParallelism()) == <span class="number">1</span>)</span><br><span class="line">        DualPivotQuicksort.sort(a, fromIndex, toIndex - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">new</span> ArraysParallelSortHelpers.FJInt.Sorter</span><br><span class="line">            (<span class="keyword">null</span>, a, <span class="keyword">new</span> <span class="keyword">int</span>[n], fromIndex, n, <span class="number">0</span>,</span><br><span class="line">                ((g = n / (p &lt;&lt; <span class="number">2</span>)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span><br><span class="line">                MIN_ARRAY_SORT_GRAN : g).invoke();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型数组并行排序方法（无比较器）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">parallelSort</span><span class="params">(T[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.length, p, g;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= MIN_ARRAY_SORT_GRAN ||</span><br><span class="line">        (p = ForkJoinPool.getCommonPoolParallelism()) == <span class="number">1</span>)</span><br><span class="line">        TimSort.sort(a, <span class="number">0</span>, n, NaturalOrder.INSTANCE, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">new</span> ArraysParallelSortHelpers.FJObject.Sorter&lt;T&gt;</span><br><span class="line">            (<span class="keyword">null</span>, a,</span><br><span class="line">                (T[])Array.newInstance(a.getClass().getComponentType(), n),</span><br><span class="line">                <span class="number">0</span>, n, <span class="number">0</span>, ((g = n / (p &lt;&lt; <span class="number">2</span>)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span><br><span class="line">                MIN_ARRAY_SORT_GRAN : g, NaturalOrder.INSTANCE).invoke();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parallelSort</span><span class="params">(T[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">    <span class="keyword">int</span> n = toIndex - fromIndex, p, g;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= MIN_ARRAY_SORT_GRAN ||</span><br><span class="line">        (p = ForkJoinPool.getCommonPoolParallelism()) == <span class="number">1</span>)</span><br><span class="line">        TimSort.sort(a, fromIndex, toIndex, NaturalOrder.INSTANCE, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">new</span> ArraysParallelSortHelpers.FJObject.Sorter&lt;T&gt;</span><br><span class="line">            (<span class="keyword">null</span>, a,</span><br><span class="line">                (T[])Array.newInstance(a.getClass().getComponentType(), n),</span><br><span class="line">                fromIndex, n, <span class="number">0</span>, ((g = n / (p &lt;&lt; <span class="number">2</span>)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span><br><span class="line">                MIN_ARRAY_SORT_GRAN : g, NaturalOrder.INSTANCE).invoke();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型数组并行排序方法（有比较器）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">parallelSort</span><span class="params">(T[] a, Comparator&lt;? <span class="keyword">super</span> T&gt; cmp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cmp == <span class="keyword">null</span>)</span><br><span class="line">        cmp = NaturalOrder.INSTANCE;</span><br><span class="line">    <span class="keyword">int</span> n = a.length, p, g;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= MIN_ARRAY_SORT_GRAN ||</span><br><span class="line">        (p = ForkJoinPool.getCommonPoolParallelism()) == <span class="number">1</span>)</span><br><span class="line">        TimSort.sort(a, <span class="number">0</span>, n, cmp, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">new</span> ArraysParallelSortHelpers.FJObject.Sorter&lt;T&gt;</span><br><span class="line">            (<span class="keyword">null</span>, a,</span><br><span class="line">                (T[])Array.newInstance(a.getClass().getComponentType(), n),</span><br><span class="line">                <span class="number">0</span>, n, <span class="number">0</span>, ((g = n / (p &lt;&lt; <span class="number">2</span>)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span><br><span class="line">                MIN_ARRAY_SORT_GRAN : g, cmp).invoke();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">parallelSort</span><span class="params">(T[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Comparator&lt;? <span class="keyword">super</span> T&gt; cmp)</span> </span>&#123;</span><br><span class="line">    rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">    <span class="keyword">if</span> (cmp == <span class="keyword">null</span>)</span><br><span class="line">        cmp = NaturalOrder.INSTANCE;</span><br><span class="line">    <span class="keyword">int</span> n = toIndex - fromIndex, p, g;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= MIN_ARRAY_SORT_GRAN ||</span><br><span class="line">        (p = ForkJoinPool.getCommonPoolParallelism()) == <span class="number">1</span>)</span><br><span class="line">        TimSort.sort(a, fromIndex, toIndex, cmp, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">new</span> ArraysParallelSortHelpers.FJObject.Sorter&lt;T&gt;</span><br><span class="line">            (<span class="keyword">null</span>, a,</span><br><span class="line">                (T[])Array.newInstance(a.getClass().getComponentType(), n),</span><br><span class="line">                fromIndex, n, <span class="number">0</span>, ((g = n / (p &lt;&lt; <span class="number">2</span>)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span><br><span class="line">                MIN_ARRAY_SORT_GRAN : g, cmp).invoke();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><p>对于基本类型数组数据，并行排序会判断排序长度n（或者数组长度）是否小于 <code>MIN_ARRAY_SORT_GRAN = 1 &lt;&lt; 13 = 8192</code>，如果小于或者<code>p = ForkJoinPool.getCommonPoolParallelism()) == 1</code>的时候，就会使用DualPivotQuicksort排序算法；否则它创建了一个<code>ArraysParallelSortHelpers.FJInt.Sorter</code>类进行并行排序。</p><p>对于Object数组或者泛型数组T[]的排序，可以看到与基本数据类型相似，只是最后的排序算法使用的是稳定的TimSort，并行帮助类使用的是<code>ArraysParallelSortHelpers.FJObject.Sorter</code>，这个类底层串行排序也是基于TimSort。</p><p>我们来分析下并行排序源码：</p><p>对于长度小于8192很好理解，就是数据长度小的时候，使用串行排序就可以了，即DualPivotQuicksort，并没有使用并行排序。</p><p>而<code>ForkJoinPool.getCommonPoolParallelism()</code>是返回公共线程池的并行级别，即允许多少个线程并行，如果是1的话说明禁用了线程，那么就无法使用多线程，也就只能使用串行排序，关于这个值和ForkJoinPool相关，后面我们会看下这个类，来了解一下它的实现，这儿就不过多叙述。</p><p>我们重点来看下<code>ArraysParallelSortHelpers.FJInt.Sorter</code>这个类，这个是针对于int数组的并行工具类，当然我们还可以看到其它数据类型的并行工具类，如<code>ArraysParallelSortHelpers.FJByte.Sorter</code>，他们都在<code>ArraysParallelSortHelpers</code>这个类里。</p><p>这个类的并行实现是根据<a href="http://supertech.lcs.mit.edu/cilk/" rel="external nofollow noopener noreferrer" target="_blank">Cilk算法</a>来实现的。</p><blockquote><p>Cilk是一种多线程算法语言。Cilk背后的理念是，程序员应该集中精力构建程序，以暴露并行性和利用局部性，让Cilk的运行时系统负责调度计算，以便在给定平台上高效运行。因此，Cilk运行时系统负责诸如负载平衡、分页和通信协议等细节。然而，与其他多线程语言不同，Cilk是算法语言，因为运行时系统保证了高效和可预测的性能。</p></blockquote><p>算法内容大致如下：</p><ol><li>如果数组长度 n 过小（小于临界值 threshold ），就使用串行排序；</li><li><p>否则，将数组分为两半：</p><ul><li>将一半数组再分为两半（n/4），对于每一半，继续分割下去，直到数组长度小于临界值threshold，不再进行分割；</li><li>对前一半串行排序，对后一半串行排序，两半排序是并行进行的； </li><li>需要注意的是 n/2排序时需要保证两个n/4的并行排序合并完成，以此类推，n/4排序时需要保证两个n/8的并行排序合并完成……</li><li>将两部分合并</li></ul></li></ol><p>其伪代码大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parallelSort</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = high - low +<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; threshold)&#123;</span><br><span class="line">        sort(a);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> half = n &gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        ForkJoinTaskTest task1 = ForkJoinTaskTest(a,low,half-<span class="number">1</span>);</span><br><span class="line">        task1.fork();</span><br><span class="line">        ForkJoinTaskTest task2 = ForkJoinTaskTest(a,half,high-<span class="number">1</span>);</span><br><span class="line">        task2.compute();</span><br><span class="line">        task1.join();</span><br><span class="line">        merge(a,low,half,high-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个分割过程和我们之前说到过的 <a href="https://www.sakuratears.top/blog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89-%E5%8F%8C%E8%B0%83%E6%8E%92%E5%BA%8F.html">双调排序</a>的并行版本有些许类似。</p><p>我们先不看Java源码的相关实现，我们想，如果我们自己实现一个并行版本的排序如何实现呢？</p><p>我们需要使用到<code>ForkJoinPool</code>，我们可以参考我的另一篇文章<a href="https://www.sakuratears.top/blog/%E4%B8%80%E9%81%93Java%E8%AF%95%E9%A2%98%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83.html">一道Java试题引发的思考</a>。</p><p>这篇文章里使用了分支/合并框架（ForkJoinPool）来使用并行处理累加数据，我们参照这个模式，可以根据伪代码写出使用 Java DualPivotQuicksort的并行版本，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParallelSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100000000</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">100000000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] b = a.clone();</span><br><span class="line">        System.out.println(<span class="string">"ParallelSort排序开始："</span>);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        ForkJoinParallelSort task = <span class="keyword">new</span> ForkJoinParallelSort(a);</span><br><span class="line">        <span class="keyword">new</span> ForkJoinPool().invoke(task);</span><br><span class="line">        System.out.println(<span class="string">"ParallelSort耗时："</span> + (System.currentTimeMillis() - start) + <span class="string">"ms"</span>);</span><br><span class="line">        System.out.println(<span class="string">"ParallelSort排序完成！"</span>);</span><br><span class="line">        System.out.println(<span class="string">"数组是否有序："</span> + isOrdered(a));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"ArrayParallelSort排序开始："</span>);</span><br><span class="line">        <span class="keyword">long</span> start1 = System.currentTimeMillis();</span><br><span class="line">        Arrays.parallelSort(b);</span><br><span class="line">        System.out.println(<span class="string">"ArrayParallelSort耗时："</span> + (System.currentTimeMillis() - start1) + <span class="string">"ms"</span>);</span><br><span class="line">        System.out.println(<span class="string">"ArrayParallelSort排序完成！"</span>);</span><br><span class="line">        System.out.println(<span class="string">"数组是否有序："</span> + isOrdered(b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ForkJoinParallelSort</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要排序的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] array;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组起始下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组结束下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> end;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组最小长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">8192</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinParallelSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ForkJoinParallelSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Void <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = end - start + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> half = length &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//小于等于阈值，串行排序处理</span></span><br><span class="line">        <span class="keyword">if</span> (length &lt;= THRESHOLD) &#123;</span><br><span class="line">            computeSequentially(array, start, end);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建一个子任务来为数组的前一半排序</span></span><br><span class="line">        ForkJoinParallelSort leftTask = <span class="keyword">new</span> ForkJoinParallelSort(array, start, start + half - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//利用另一个ForkJoinPool线程异步执行新创建的子任务</span></span><br><span class="line">        leftTask.fork();</span><br><span class="line">        <span class="comment">//创建一个任务为数组的后一半排序</span></span><br><span class="line">        ForkJoinParallelSort rightTask = <span class="keyword">new</span> ForkJoinParallelSort(array, start + half, end);</span><br><span class="line">        <span class="comment">//同步执行第二个子任务，有可能允许进一步递归划分</span></span><br><span class="line">        rightTask.compute();</span><br><span class="line">        <span class="comment">//读取第一个子任务的结果，没有完成就等待</span></span><br><span class="line">        leftTask.join();</span><br><span class="line">        <span class="comment">//合并结果</span></span><br><span class="line">        <span class="comment">//long startTime = System.currentTimeMillis();</span></span><br><span class="line">        merge(array, start, start + half - <span class="number">1</span>, start + half, end);</span><br><span class="line">        <span class="comment">//System.out.println("耗时："+(System.currentTimeMillis()-startTime)+"ms");</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用JavaDualPivotQuickSort串行处理较小的数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">computeSequentially</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//直接调用Arrays.sort 也可以</span></span><br><span class="line">        JavaDualPivotQuicksort.sort(array, start, end, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 快速合并两个有序数组   O(min(m,n))</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> leftStart</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> leftEnd</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rightStart</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rightEnd</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> leftStart, <span class="keyword">int</span> leftEnd, <span class="keyword">int</span> rightStart, <span class="keyword">int</span> rightEnd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array[leftEnd] &lt;= array[rightStart]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = leftStart;</span><br><span class="line">        <span class="keyword">int</span> j = rightStart;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len1 = leftEnd - leftStart + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len2 = rightEnd - rightStart + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[len1 + len2];</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= leftEnd &amp;&amp; j &lt;= rightEnd) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &lt;= array[j]) &#123;</span><br><span class="line">                temp[k++] = array[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[k++] = array[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == leftEnd + <span class="number">1</span> &amp;&amp; j &lt;= rightEnd) &#123;</span><br><span class="line">            System.arraycopy(array, j, temp, k, rightEnd - j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == rightEnd + <span class="number">1</span> &amp;&amp; i &lt;= leftEnd) &#123;</span><br><span class="line">            System.arraycopy(array, i, temp, k, leftEnd - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理完后将temp赋值给array</span></span><br><span class="line">        System.arraycopy(temp, <span class="number">0</span>, array, leftStart, len1);</span><br><span class="line">        System.arraycopy(temp, len1, array, rightStart, len2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码是比较好理解的，其要注意的地方是在排完序的两个有序数组合并上。</p><p>运行一下可以看到对于1亿数据量该方法耗时稳定在6~7s，Java源码的ParallelSort方法耗时在3~4s左右。</p><p>它们结果如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-525.jpg" alt="upload successful"></p><p>可以看到Java源码的排序处理速度要比我们实现的更高效的，速度差异主要在哪儿呢？</p><p>其实Java并行源码中借鉴了Cilk算法，但是有些不同的地方是，会把原数组分成四份进行并行排序。</p><p>算法说明如下：</p><ol><li>将数组分成4个子数组。</li><li>对前面两个子数组进行排序然后合并。</li><li>对后面的两个进行排序然后合并。<br>上面着几个步骤会重复递归，每个子数组都要求容量小于上面计算出来的临界值。</li></ol><p>我们回到<code>ArraysParallelSortHelpers</code>这个类从它里面的FJInt这个类入手，其他的类的实现和其类似。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-526.jpg" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-527.jpg" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-528.jpg" alt="upload successful"></p><p>根据上图的一些介绍，我再简单说明下。</p><p>其实上面图中Java源码这段代码是相当晦涩的，我们如何看出它每次是拆分成4个子任务并处理的呢？</p><p>我们可以根据第一次调用来看，这时候代码中的<code>b = this.base = 0</code>，<code>wb = this.wbase = 0</code>，则三个Sorter如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Sorter(rc, a, w, b+u, n-u, wb+u, g).fork();</span><br><span class="line"><span class="keyword">new</span> Sorter(rc, a, w, b+h, q, wb+h, g).fork();;</span><br><span class="line"><span class="keyword">new</span> Sorter(bc, a, w, b+q, h-q, wb+q, g).fork();</span><br></pre></td></tr></table></figure><p>代入b =0 可以看到，它们分别处理了[ u , u + n - u ],[ h , h + q ],[ q , q + h -q ] 三部分，正好是[ 3/4 , 1 ],[ 1/2 , 3/4 ],[ 1/4 , 1/2 ] 三部分。</p><p>而对于剩下的1/4 ，直接在当前线程处理（不需要fork），代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DualPivotQuicksort.sort(a, b, b + n - <span class="number">1</span>, w, wb, n);<span class="comment">//注：此时 n = q （对于当前线程）,可以看源码的赋值过程</span></span><br></pre></td></tr></table></figure><p>分别排序完了，需要进行合并，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (n &gt; g) &#123;</span><br><span class="line">    <span class="keyword">int</span> h = n &gt;&gt;&gt; <span class="number">1</span>, q = h &gt;&gt;&gt; <span class="number">1</span>, u = h + q; <span class="comment">// quartiles</span></span><br><span class="line">    Relay fc = <span class="keyword">new</span> Relay(<span class="keyword">new</span> Merger(s, w, a, wb, h, wb+h, n-h, b, g));</span><br><span class="line">    Relay rc = <span class="keyword">new</span> Relay(<span class="keyword">new</span> Merger(fc, a, w, b+h, q,b+u, n-u, wb+h, g));</span><br><span class="line">    <span class="keyword">new</span> Sorter(rc, a, w, b+u, n-u, wb+u, g).fork();</span><br><span class="line">    <span class="keyword">new</span> Sorter(rc, a, w, b+h, q, wb+h, g).fork();;</span><br><span class="line">    Relay bc = <span class="keyword">new</span> Relay(<span class="keyword">new</span> Merger(fc, a, w, b, q,b+q, h-q, wb, g));</span><br><span class="line">    <span class="keyword">new</span> Sorter(bc, a, w, b+q, h-q, wb+q, g).fork();</span><br><span class="line">    s = <span class="keyword">new</span> EmptyCompleter(bc);</span><br><span class="line">    n = q;</span><br><span class="line">&#125;</span><br><span class="line">DualPivotQuicksort.sort(a, b, b + n - <span class="number">1</span>, w, wb, n);</span><br><span class="line">s.tryComplete();</span><br></pre></td></tr></table></figure><p>这段Relay的依存关系是 rc （合并后1/2部分）和 bc （合并前1/2部分） 是并行的，fc 会合并rc和bc （排序好的数据）。</p><p>Java中把并行分成四份的优势在哪里呢？</p><p>明显这段代码和使用我们Cilk算法每次分成两份的本质是一样的，而且分成4份代码变得更加晦涩。</p><p>具体原因就要说说这个Merger了，这个Merger是关于两个有序数组并行合并的实现，它的效率是非常高的，我们回到我们自己实现的那个<code>ParallelSort</code>类，可以看到我们设计的merge就是比较常规的合并，当两个数组数据量越大时，耗时越长，我在代码中注掉了耗时计算，有兴趣的童鞋可以打开观察下，在数据量较小情况下，其耗时基本是0~10ms，但是运行中随着两部分待合并的数据越来越大，耗时越来越大。</p><p>比如对于1亿数据的排序，其耗时主要消耗在2个5000w的数据合并成最终结果、4个2500w的数据两两合并成2个5000w数据、8个1250w的数据两两合并成4个2500w数据……的合并上。</p><p>Java中的这个Merger对合并进行了优化，使用了并行合并，其原理如下：</p><ol><li>对于两个待合并数组A，B；</li><li>找到较大（或等于）的一个数组（比如A），如果长度小于阈值8192，就不分割了；如果大于8192，找到较大数组A的中点作为切割点M，使用二分法找到较小数组B中比这个切割点大的最小位置索引P；</li><li>这时候其实我们可以发现A中[lowA , M]和B中[lowB , P]位置数据合并后是始终 小于等于 A中[M , highA]和B中[P , highB]位置数据合并的，这就是分割合并有序的原则；</li><li>如果长度比较大，还会继续并行分割下去；</li><li>然后我们对上面拆分的数据两两合并，最终多线程执行完也就得到了有序数据。</li></ol><p>有兴趣的童鞋可以参考原理结合上图看一下。</p><p>而我们在排序及合并时，会用到工作数组，分成4份后，可以保证最后的排序完成数组在原数组中，而不是在工作数组中，也避免了一次数据拷贝。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于Java自带排序的内容就介绍到这儿，可以看到相比于串行排序，并行排序更加复杂，但是Cilk并行算法的原理还是比较简单的，Java并排代码之所以复杂是因为它尽可能的优化了算法耗时。</p><p>这也是软件开发者应当具有的品质：精益求精。</p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>关于自写的ParallelSort排序可见于我的 <a href="https://github.com/javazwt" rel="external nofollow noopener noreferrer" target="_blank">GitHub</a>。</p><p>关于 ArraysParallelSortHelpers相关代码可以参考JDK源码（1.8及以上版本）。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>JDK ArraysParallelSortHelpers源码</li><li>JDK Arrays源码</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="排序算法" scheme="https://www.sakuratears.top/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
      <category term="并行排序" scheme="https://www.sakuratears.top/tags/%E5%B9%B6%E8%A1%8C%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令大全</title>
    <link href="https://www.sakuratears.top/blog/Linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8.html"/>
    <id>https://www.sakuratears.top/blog/Linux命令大全.html</id>
    <published>2019-10-11T14:11:00.000Z</published>
    <updated>2019-10-16T14:48:00.002Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Linux 命令大全，一些常用命令使用<font color="red"><strong>红色</strong></font>标记。</p><h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><h2 id="linux系统管理命令"><a href="#linux系统管理命令" class="headerlink" title="linux系统管理命令"></a>linux系统管理命令</h2><h3 id="adduser"><a href="#adduser" class="headerlink" title="adduser"></a><font color="red">adduser</font></h3><p>功能说明：新增用户帐号。</p><p>语　　法：<code>adduser</code></p><p>补充说明：在Slackware中，adduser指令是个script程序，利用交谈的方式取得输入的用户帐号资料，然后再交由真正建立帐号的useradd指令建立新用户，如此可方便管理员建立用户帐号。在Red Hat Linux中，adduser指令则是useradd指令的符号连接，两者实际上是同一个指令。</p><h3 id="chfn-change-finger-information"><a href="#chfn-change-finger-information" class="headerlink" title="chfn(change finger information)"></a>chfn(change finger information)</h3><p>功能说明：改变finger指令显示的信息。</p><p>语　　法：<code>chfn [-f &lt;真实姓名&gt;][-h &lt;家中电话&gt;][-o &lt;办公地址&gt;][-p &lt;办公电话&gt;][-uv][帐号名称]</code></p><p>补充说明：chfn指令可用来更改执行finger指令时所显示的信息，这些信息都存放在/etc目录里的asswd文件里。若不指定任何参数，则chfn指令会进入问答式界面。</p><p>参　　数：</p><ul><li>-f&lt;真实姓名&gt;或–full-name&lt;真实姓名&gt; 　   设置真实姓名。 </li><li>-h&lt;家中电话&gt;或–home-phone&lt;家中电话&gt; 　  设置家中的电话号码。 </li><li>-o&lt;办公地址&gt;或–office&lt;办公地址&gt; 　      设置办公室的地址。 </li><li>-p&lt;办公电话&gt;或–office-phone&lt;办公电话&gt; 　设置办公室的电话号码。 </li><li>-u或–help 　在线帮助。 </li><li>-v或-version 　显示版本信息。</li></ul><h3 id="chsh-change-shell"><a href="#chsh-change-shell" class="headerlink" title="chsh(change shell)"></a>chsh(change shell)</h3><p>功能说明：更换登入系统时使用的shell。</p><p>语　　法：<code>chsh [-luv][-s &lt;shell 名称&gt;][用户名称]</code></p><p>补充说明：每位用户在登入系统时，都会拥有预设的shell环境，这个指令可更改其预设值。若不指定任何参数与用户名称，则chsh会以应答的方式进行设置。</p><p>参　　数：</p><ul><li>-s&lt;shell 名称&gt;或–shell&lt;shell 名称&gt; 　更改系统预设的shell环境。 </li><li>-l或–list-shells 　列出目前系统可用的shell清单。 </li><li>-u或–help 　在线帮助。 </li><li>-v或-version 　显示版本信息。</li></ul><h3 id="date"><a href="#date" class="headerlink" title="date"></a><font color="red">date</font></h3><p>功能说明：显示或设置系统时间与日期。</p><p>语    法：<br><code>date [-d &lt;字符串&gt;][-u][+%H%I%K%l%M%P%r%s%S%T%X%Z%a%A%b%B%c%d%D%j%m%U%w%x%y%Y%n%t] 或date [-s &lt;字符串&gt;][-u][MMDDhhmmCCYYss] 或 date [–help][–version]</code></p><p>补充说明：第一种语法可用来显示系统日期或时间，以%为开头的参数为格式参数，可指定日期或时间的显示格式。第二种语法可用来设置系统日期与时间。只有管理员才有设置日期与时间的权限。若不加任何参数，data会显示目前的日期与时间。</p><p>参　　数：</p><ul><li>%H 　小时(以00-23来表示)。 </li><li>%I 　小时(以01-12来表示)。 </li><li>%K 　小时(以0-23来表示)。 </li><li>%l 　小时(以0-12来表示)。 </li><li>%M 　分钟(以00-59来表示)。 </li><li>%P 　AM或PM。 </li><li>%r 　时间(含时分秒，小时以12小时AM/PM来表示)。 </li><li>%s 　总秒数。起算时间为1970-01-01 00:00:00 UTC。 </li><li>%S 　秒(以本地的惯用法来表示)。 </li><li>%T 　时间(含时分秒，小时以24小时制来表示)。 </li><li>%X 　时间(以本地的惯用法来表示)。 </li><li>%Z 　市区。 </li><li>%a 　星期的缩写。 </li><li>%A 　星期的完整名称。 </li><li>%b 　月份英文名的缩写。 </li><li>%B 　月份的完整英文名称。 </li><li>%c 　日期与时间。只输入date指令也会显示同样的结果。 </li><li>%d 　日期(以01-31来表示)。 </li><li>%D 　日期(含年月日)。 </li><li>%j 　该年中的第几天。 </li><li>%m 　月份(以01-12来表示)。 </li><li>%U 　该年中的周数。 </li><li>%w 　该周的天数，0代表周日，1代表周一，异词类推。 </li><li>%x 　日期(以本地的惯用法来表示)。 </li><li>%y 　年份(以00-99来表示)。 </li><li>%Y 　年份(以四位数来表示)。 </li><li>%n 　在显示时，插入新的一行。 </li><li>%t 　在显示时，插入tab。 </li><li>MM 　月份(必要)。 </li><li>DD 　日期(必要)。 </li><li>hh 　小时(必要)。 </li><li>mm 　分钟(必要)。 </li><li>CC 　年份的前两位数(选择性)。 </li><li>YY 　年份的后两位数(选择性)。 </li><li>ss 　秒(选择性)。 </li><li>-d&lt;字符串&gt; 　显示字符串所指的日期与时间。字符串前后必须加上双引号。 </li><li>-s&lt;字符串&gt; 　根据字符串来设置日期与时间。字符串前后必须加上双引号。 </li><li>-u 　显示GMT。 </li><li>–help 　在线帮助。 </li><li>–version 　显示版本信息。</li></ul><h3 id="exit"><a href="#exit" class="headerlink" title="exit"></a><font color="red">exit</font></h3><p>功能说明：退出目前的shell。</p><p>语　　法：<code>exit [状态值]</code></p><p>补充说明：执行exit可使shell以指定的状态值退出。若不设置状态值参数，则shell以预设值退出。状态值0代表执行成功，其他值代表执行失败。exit也可用在script，离开正在执行的script，回到shell。</p><h3 id="finger"><a href="#finger" class="headerlink" title="finger"></a>finger</h3><p>功能说明：查找并显示用户信息。</p><p>语　　法：<code>finger [-lmsp][帐号名称…]</code></p><p>补充说明：finger指令会去查找，并显示指定帐号的用户相关信息，包括本地与远端主机的用户皆可，帐号名称没有大小写的差别。单独执行finger指令，它会显示本地主机现在所有的用户的登陆信息，包括帐号名称，真实姓名，登入终端机，闲置时间，登入时间以及地址和电话。</p><p>参　　数：</p><ul><li>-l 　列出该用户的帐号名称，真实姓名，用户专属目录，登入所用的Shell，登入时间，转信地址，电子邮件状态，还有计划文件和方案文件内容。 </li><li>-m 　排除查找用户的真实姓名。</li><li>-s 　列出该用户的帐号名称，真实姓名，登入终端机，闲置时间，登入时间以及地址和电话。 </li><li>-p 　列出该用户的帐号名称，真实姓名，用户专属目录，登入所用的Shell，登入时间，转信地址，电子邮件状态，但不显示该用户的计划文件和方案文件内容。</li></ul><h3 id="free"><a href="#free" class="headerlink" title="free"></a><font color="red">free</font></h3><p>功能说明：显示内存状态。</p><p>语　　法： <code>free [-bkmotV][-s &lt;间隔秒数&gt;]</code></p><p>补充说明：free指令会显示内存的使用情况，包括实体内存，虚拟的交换文件内存，共享内存区段，以及系统核心使用的缓冲区等。</p><p>参　　数：</p><ul><li>-b 　以Byte为单位显示内存使用情况。 </li><li>-k 　以KB为单位显示内存使用情况。 </li><li>-m 　以MB为单位显示内存使用情况。 </li><li>-o 　不显示缓冲区调节列。 </li><li>-s&lt;间隔秒数&gt; 　持续观察内存使用状况。 </li><li>-t 　显示内存总和列。 </li><li>-V 　显示版本信息。</li></ul><h3 id="fwhois"><a href="#fwhois" class="headerlink" title="fwhois"></a>fwhois</h3><p>功能说明：查找并显示用户信息。</p><p>语　　法：<code>fwhios [帐号名称]</code></p><p>补充说明：本指令的功能有点类似finger指令，它会去查找并显示指定帐号的用户相关信息。不同之处在于fwhois指令是到Network Solutions的WHOIS数据库去查找，该帐号名称必须有在上面注册才能寻获，且名称没有大小写的差别</p><h3 id="gitps-gnu-interactive-tools-process-status"><a href="#gitps-gnu-interactive-tools-process-status" class="headerlink" title="gitps(gnu interactive tools process status)"></a>gitps(gnu interactive tools process status)</h3><p>功能说明：报告程序状况。</p><p>语　　法：<code>gitps [acefgjlnrsSTuvwxX][p &lt;程序识别码&gt;][t &lt;终端机编号&gt;][U &lt;帐号名称&gt;]</code></p><p>补充说明：gitps是用来报告并管理程序执行的指令，基本上它就是通过ps指令来报告，管理程序，也能通过gitps指令随时中断，删除不必要的程序。因为gitps指令会去执行ps指令，所以其参数和ps指令相当类似。</p><p>参　　数：</p><ul><li>a 　显示　现行终端机下的所有程序，包括其他用户的程序。 </li><li>c 　列出程序时，显示每个程序真正的指令名称，而不包含路径，参数或是常驻服务的标示． </li><li>e 　列出程序时，显示每个程序所使用的环境变量。 </li><li>f 　用ASCII字符显示树状结构，表达程序间的相互关系。 </li><li>g 　显示现行终端机下的所有程序，包括群组领导者的程序。 </li><li>j 　采用工作控制的格式来显示程序状况。 </li><li>l 　采用纤细的格式来显示程序状况。 </li><li>n 　以数字来表示USER和WCHAN栏位。 </li><li>p&lt;程序识别码&gt; 　指定程序识别码，并列出该程序的状况。 </li><li>r 　只列出现行终端机正在执行中的程序。 </li><li>s 　采用程序信号的格式显示程序状况。 </li><li>S 　列出程序时，包括已中断的子程序信息。 </li><li>t&lt;终端机机标号&gt; 　指定终端机编号，并列出属于该终端机的程序的状况。 </li><li>T 　显示现行终端机下的所有程序。 </li><li>u 　以用户为主的格式来显示程序状况。 </li><li>U&lt;帐号名称&gt; 　列出属于该用户的程序的状况。 </li><li>v 　采用虚拟内存的格式显示程序状况。 </li><li>w 　采用宽阔的格式来显示程序状况。 </li><li>x 　显示所有程序，不以终端机来区分。 </li><li>X 　采用旧试的Linux i386登陆格式显示程序状况。</li></ul><h3 id="groupdel-group-delete"><a href="#groupdel-group-delete" class="headerlink" title="groupdel(group delete)"></a><font color="red">groupdel(group delete)</font></h3><p>功能说明：删除群组。</p><p>语　　法：<code>groupdel [群组名称]</code></p><p>补充说明：需要从系统上删除群组时，可用groupdel指令来完成这项工作。倘若该群组中仍包括某些用户，则必须先删除这些用户后，方能删除群组。</p><h3 id="groupmod-group-modify"><a href="#groupmod-group-modify" class="headerlink" title="groupmod(group modify)"></a><font color="red">groupmod(group modify)</font></h3><p>功能说明：更改群组识别码或名称。</p><p>语　　法：<code>groupmod [-g &lt;群组识别码&gt; &lt;-o&gt;][-n &lt;新群组名称&gt;][群组名称]</code></p><p>补充说明：需要更改群组的识别码或名称时，可用groupmod指令来完成这项工作。</p><p>参　　数：</p><ul><li>-g &lt;群组识别码&gt; 　设置欲使用的群组识别码。 </li><li>-o 　重复使用群组识别码。 </li><li>-n &lt;新群组名称&gt; 　设置欲使用的群组名称。</li></ul><h3 id="halt"><a href="#halt" class="headerlink" title="halt"></a>halt</h3><p>功能说明：关闭系统。</p><p>语　　法：<code>halt [-dfinpw]</code></p><p>补充说明：halt会先检测系统的runlevel。若runlevel为0或6，则关闭系统，否则即调用shutdown来关闭系统。</p><p>参　　数：</p><ul><li>-d 　不要在wtmp中记录。 </li><li>-f 　不论目前的runlevel为何，不调用shutdown即强制关闭系统。 </li><li>-i 　在halt之前，关闭全部的网络界面。 </li><li>-n 　halt前，不用先执行sync。 </li><li>-p 　halt之后，执行poweroff。 </li><li>-w 　仅在wtmp中记录，而不实际结束系统。</li></ul><h3 id="id"><a href="#id" class="headerlink" title="id"></a><font color="red">id</font></h3><p>功能说明：显示用户的ID，以及所属群组的ID。</p><p>语　　法：<code>id [-gGnru][–help][–version][用户名称]</code></p><p>补充说明：id会显示用户以及所属群组的实际与有效ID。若两个ID相同，则仅显示实际ID。若仅指定用户名称，则显示目前用户的ID。</p><p>参　　数：　</p><ul><li>-g或–group 　显示用户所属群组的ID。 </li><li>-G或–groups 　显示用户所属附加群组的ID。 </li><li>-n或–name 　显示用户，所属群组或附加群组的名称。 </li><li>-r或–real 　显示实际ID。 </li><li>-u或–user 　显示用户ID。 </li><li>-help 　显示帮助。 </li><li>-version 　显示版本信息。</li></ul><h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a><font color="red">kill</font></h3><p>功能说明：删除执行中的程序或工作。</p><p>语　　法：<code>kill [-s &lt;信息名称或编号&gt;][程序]　或　kill [-l &lt;信息编号&gt;]</code></p><p>补充说明：kill可将指定的信息送至程序。预设的信息为SIGTERM(15)，可将指定程序终止。若仍无法终止该程序，可使用SIGKILL(9)信息尝试强制删除程序。程序或工作的编号可利用ps指令或jobs指令查看。 </p><p>参　　数：</p><ul><li>-l &lt;信息编号&gt; 　若不加&lt;信息编号&gt;选项，则-l参数会列出全部的信息名称。 </li><li>-s &lt;信息名称或编号&gt; 　指定要送出的信息。 </li></ul><p>PS: [程序] :　[程序]可以是程序的PID或是PGID，也可以是工作编号。</p><h3 id="last"><a href="#last" class="headerlink" title="last"></a><font color="red">last</font></h3><p>功能说明：列出目前与过去登入系统的用户相关信息。</p><p>语　　法：<code>last [-adRx][-f &lt;记录文件&gt;][-n &lt;显示列数&gt;][帐号名称…][终端机编号…]</code></p><p>补充说明：单独执行last指令，它会读取位于/var/log目录下，名称为wtmp的文件，并把该给文件的内容记录的登入系统的用户名单全部显示出来。</p><p>参　　数：</p><ul><li>-a 　把从何处登入系统的主机名称或IP地址，显示在最后一行。 </li><li>-d 　将IP地址转换成主机名称。 </li><li>-f &lt;记录文件&gt; 　指定记录文件。 </li><li>-n &lt;显示列数&gt;或-&lt;显示列数&gt; 　设置列出名单的显示列数。 </li><li>-R 　不显示登入系统的主机名称或IP地址。 </li><li>-x 　显示系统关机，重新开机，以及执行等级的改变等信息。</li></ul><h3 id="lastb"><a href="#lastb" class="headerlink" title="lastb"></a>lastb</h3><p>功能说明：列出登入系统失败的用户相关信息。</p><p>语　　法：<code>lastb [-adRx][-f &lt;记录文件&gt;][-n &lt;显示列数&gt;][帐号名称…][终端机编号…]</code></p><p>补充说明：单独执行lastb指令，它会读取位于/var/log目录下，名称为btmp的文件，并把该文件内容记录的登入失败的用户名单，全部显示出来。</p><p>参　　数：</p><ul><li>-a 　把从何处登入系统的主机名称或IP地址显示在最后一行。 </li><li>-d 　将IP地址转换成主机名称。 </li><li>-f&lt;记录文件&gt; 　指定记录文件。 </li><li>-n&lt;显示列数&gt;或-&lt;显示列数&gt; 　设置列出名单的显示列数。 </li><li>-R 　不显示登入系统的主机名称或IP地址。 </li><li>-x 　显示系统关机，重新开机，以及执行等级的改变等信息。</li></ul><h3 id="login"><a href="#login" class="headerlink" title="login"></a><font color="red">login</font></h3><p>功能说明：登入系统。</p><p>语　　法：<code>login</code></p><p>补充说明：login指令让用户登入系统，您亦可通过它的功能随时更换登入身份。在Slackware发行版中 ，您可在指令后面附加欲登入的用户名称，它会直接询问密码，等待用户输入。当/etc目录里含名称为nologin的文件时，系统只root帐号登入系统，其他用户一律不准登入。</p><h3 id="logname"><a href="#logname" class="headerlink" title="logname"></a>logname</h3><p>功能说明：显示用户名称。</p><p>语　　法：<code>logname [–help][–version]</code></p><p>补充说明：执行logname指令，它会显示目前用户的名称。</p><p>参　　数：</p><ul><li>–help 　在线帮助。 </li><li>–vesion 　显示版本信息。</li></ul><h3 id="logout"><a href="#logout" class="headerlink" title="logout"></a><font color="red">logout</font></h3><p>功能说明：退出系统。</p><p>语　　法：<code>logout</code></p><p>补充说明：logout指令让用户退出系统，其功能和login指令相互对应。</p><h3 id="logrotate"><a href="#logrotate" class="headerlink" title="logrotate"></a>logrotate</h3><p>功能说明：管理记录文件。</p><p>语　　法：<code>logrotate [-?dfv][-s &lt;状态文件&gt;][–usage][配置文件]</code></p><p>补充说明：使用logrotate指令，可让你轻松管理系统所产生的记录文件。它提供自动替换，压缩，删除和邮寄记录文件，每个记录文件都可被设置成每日，每周或每月处理，也能在文件太大时立即处理。您必须自行编辑，指定配置文件，预设的配置文件存放在/etc目录下，文件名称为logrotate.conf。</p><p>参　　数：</p><ul><li>-?或–help 　在线帮助。 </li><li>-d或–debug 　详细显示指令执行过程，便于排错或了解程序执行的情况。 </li><li>-f或–force 　强行启动记录文件维护操作，纵使logrotate指令认为没有需要亦然。 </li><li>-s&lt;状态文件&gt;或–state=&lt;状态文件&gt; 　使用指定的状态文件。 </li><li>-v或–version 　显示指令执行过程。 </li><li>-usage 　显示指令基本用法。</li></ul><h3 id="newgrp"><a href="#newgrp" class="headerlink" title="newgrp"></a>newgrp</h3><p>功能说明：登入另一个群组。</p><p>语　　法：<code>newgrp [群组名称]</code></p><p>补充说明：newgrp指令类似login指令，当它是以相同的帐号，另一个群组名称，再次登入系统。欲使用newgrp指令切换群组，您必须是该群组的用户，否则将无法登入指定的群组。单一用户要同时隶属多个群组，需利用交替用户的设置。若不指定群组名称，则newgrp指令会登入该用户名称的预设群组。</p><h3 id="nice"><a href="#nice" class="headerlink" title="nice"></a><font color="red">nice</font></h3><p>功能说明：设置优先权。</p><p>语　　法：<code>nice [-n &lt;优先等级&gt;][–help][–version][执行指令]</code></p><p>补充说明：nice指令可以改变程序执行的优先权等级。</p><p>参　　数：</p><ul><li>-n&lt;优先等级&gt;或-&lt;优先等级&gt;或–adjustment=&lt;优先等级&gt; 　设置欲执行的指令的优先权等级。等级的范围从-20－19，其中-20最高，19最低，只有系统管理者可以设置负数的等级。 </li><li>–help 　在线帮助。 </li><li>–version 　显示版本信息。</li></ul><h3 id="procinfo-process-information"><a href="#procinfo-process-information" class="headerlink" title="procinfo(process information)"></a>procinfo(process information)</h3><p>功能说明：显示当前进程信息。</p><p>语　　法：<code>procinfo [-abdDfhimsSv][-F &lt;输出文件&gt;][-n &lt;间隔秒数&gt;]</code></p><p>补充说明：procinfo指令从/proc目录里读取相关数据，将数据妥善整理过后输出到标准输出设备。</p><p>参　　数：</p><ul><li>-a 　显示所有信息。 </li><li>-b 　显示磁盘设备的区块数目，而非存取数目。 </li><li>-d 　显示系统信息每秒间的变化差额，而非总和的数值。本参数必须配合”-f”参数使用 </li><li>-D 　此参数效果和指定”-d”参数类似，但内存和交换文件的信息为总和数值。 </li><li>-f 　进入全画面的互动式操作界面。 </li><li>-F&lt;输出文件&gt; 　把信息状态输出到文件保存起来，而非预设的标准输出设备。 </li><li>-h 　在线帮助。 </li><li>-i 　显示完整的IRP列表。 </li><li>-m 　显示系统模块和外围设备等相关信息。 </li><li>-n间隔秒数&gt; 　设置全画面互动模式的信息更新速度，单位以秒计算。 </li><li>-s 　显示系统的内存，磁盘空间，IRP和DMA等信息，此为预设值。 </li><li>-S 　搭配参数”-d”或”-D”使用时，每秒都会更新信息，不论是否有使用参数”-n”。 </li><li>-v 　显示版本信息。</li></ul><h3 id="ps-process-status"><a href="#ps-process-status" class="headerlink" title="ps(process status)"></a><font color="red">ps(process status)</font></h3><p>功能说明：报告程序状况。</p><p>语　　法：<code>ps [-aAcdefHjlmNVwy][acefghLnrsSTuvxX][-C &lt;指令名称&gt;][-g &lt;群组名称&gt;][-G &lt;群组识别码&gt;][-p &lt;程序识别码&gt;][p &lt;程序识别码&gt;][-s &lt;阶段作业&gt;][-t &lt;终端机编号&gt;][t &lt;终端机编号&gt;][-u &lt;用户识别码&gt;][-U &lt;用户识别码&gt;][U &lt;用户名称&gt;][-&lt;程序识别码&gt;][–cols &lt;每列字符数&gt;][–columns &lt;每列字符数&gt;][–cumulative][–deselect][–forest][–headers][–help][–info][–lines &lt;显示列数&gt;][–no-headers][–group &lt;群组名称&gt;][-Group &lt;群组识别码&gt;][–pid &lt;程序识别码&gt;][–rows &lt;显示列数&gt;][–sid &lt;阶段作业&gt;][–tty &lt;终端机编号&gt;][–user &lt;用户名称&gt;][–User &lt;用户识别码&gt;][–version][–width &lt;每列字符数&gt;]</code></p><p>补充说明：ps是用来报告程序执行状况的指令，您可以搭配kill指令随时中断，删除不必要的程序。</p><p>参　　数：</p><ul><li>-a 　显示所有终端机下执行的程序，除了阶段作业领导者之外。 </li><li>a 　显示现行终端机下的所有程序，包括其他用户的程序。 </li><li>-A 　显示所有程序。 </li><li>-c 　显示CLS和PRI栏位。 </li><li>c 　列出程序时，显示每个程序真正的指令名称，而不包含路径，参数或常驻服务的标示。 </li><li>-C&lt;指令名称&gt; 　指定执行指令的名称，并列出该指令的程序的状况。 </li><li>-d 　显示所有程序，但不包括阶段作业领导者的程序。 </li><li>-e 　此参数的效果和指定”A”参数相同。 </li><li>e 　列出程序时，显示每个程序所使用的环境变量。 </li><li>-f 　显示UID,PPIP,C与STIME栏位。 </li><li>f 　用ASCII字符显示树状结构，表达程序间的相互关系。 </li><li>-g&lt;群组名称&gt; 　此参数的效果和指定”-G”参数相同，当亦能使用阶段作业领导者的名称来指定。 </li><li>g 　显示现行终端机下的所有程序，包括群组领导者的程序。 </li><li>-G&lt;群组识别码&gt; 　列出属于该群组的程序的状况，也可使用群组名称来指定。 </li><li>h 　不显示标题列。 </li><li>-H 　显示树状结构，表示程序间的相互关系。 </li><li>-j或j 　采用工作控制的格式显示程序状况。 </li><li>-l或l 　采用详细的格式来显示程序状况。 </li><li>L 　列出栏位的相关信息。 </li><li>-m或m 　显示所有的执行绪。 </li><li>n 　以数字来表示USER和WCHAN栏位。 </li><li>-N 　显示所有的程序，除了执行ps指令终端机下的程序之外。 </li><li>-p&lt;程序识别码&gt; 　指定程序识别码，并列出该程序的状况。 </li><li>p&lt;程序识别码&gt; 　此参数的效果和指定”-p”参数相同，只在列表格式方面稍有差异。 </li><li>r 　只列出现行终端机正在执行中的程序。 </li><li>-s&lt;阶段作业&gt; 　指定阶段作业的程序识别码，并列出隶属该阶段作业的程序的状况。 </li><li>s 　采用程序信号的格式显示程序状况。 </li><li>S 　列出程序时，包括已中断的子程序资料。 </li><li>-t&lt;终端机编号&gt; 　指定终端机编号，并列出属于该终端机的程序的状况。 </li><li>t&lt;终端机编号&gt; 　此参数的效果和指定”-t”参数相同，只在列表格式方面稍有差异。 </li><li>-T 　显示现行终端机下的所有程序。 </li><li>-u&lt;用户识别码&gt; 　此参数的效果和指定”-U”参数相同。 </li><li>u 　以用户为主的格式来显示程序状况。 </li><li>-U&lt;用户识别码&gt; 　列出属于该用户的程序的状况，也可使用用户名称来指定。 </li><li>U&lt;用户名称&gt; 　列出属于该用户的程序的状况。 </li><li>v 　采用虚拟内存的格式显示程序状况。 </li><li>-V或V 　显示版本信息。 </li><li>-w或w 　采用宽阔的格式来显示程序状况。　 </li><li>x 　显示所有程序，不以终端机来区分。 </li><li>X 　采用旧式的Linux i386登陆格式显示程序状况。 </li><li>-y 　配合参数”-l”使用时，不显示F(flag)栏位，并以RSS栏位取代ADDR栏位　。 </li><li>-&lt;程序识别码&gt; 　此参数的效果和指定”p”参数相同。 </li><li>–cols&lt;每列字符数&gt; 　设置每列的最大字符数。 </li><li>–columns&lt;每列字符数&gt; 　此参数的效果和指定”–cols”参数相同。 </li><li>–cumulative 　此参数的效果和指定”S”参数相同。 </li><li>–deselect 　此参数的效果和指定”-N”参数相同。 </li><li>–forest 　此参数的效果和指定”f”参数相同。 </li><li>–headers 　重复显示标题列。 </li><li>–help 　在线帮助。 </li><li>–info 　显示排错信息。 </li><li>–lines&lt;显示列数&gt; 　设置显示画面的列数。 </li><li>–no-headers 　此参数的效果和指定”h”参数相同，只在列表格式方面稍有差异。 </li><li>–group&lt;群组名称&gt; 　此参数的效果和指定”-G”参数相同。 </li><li>–Group&lt;群组识别码&gt; 　此参数的效果和指定”-G”参数相同。 </li><li>–pid&lt;程序识别码&gt; 　此参数的效果和指定”-p”参数相同。 </li><li>–rows&lt;显示列数&gt; 　此参数的效果和指定”–lines”参数相同。 </li><li>–sid&lt;阶段作业&gt; 　此参数的效果和指定”-s”参数相同。 </li><li>–tty&lt;终端机编号&gt; 　此参数的效果和指定”-t”参数相同。 </li><li>–user&lt;用户名称&gt; 　此参数的效果和指定”-U”参数相同。 </li><li>–User&lt;用户识别码&gt; 　此参数的效果和指定”-U”参数相同。 </li><li>–version 　此参数的效果和指定”-V”参数相同。 </li><li>–widty&lt;每列字符数&gt; 　此参数的效果和指定”-cols”参数相同。</li></ul><h3 id="pstree-process-status-tree"><a href="#pstree-process-status-tree" class="headerlink" title="pstree(process status tree)"></a>pstree(process status tree)</h3><p>功能说明：以树状图显示程序。</p><p>语　　法：<code>pstree [-acGhlnpuUV][-H &lt;程序识别码&gt;][&lt;程序识别码&gt;/&lt;用户名称&gt;]</code></p><p>补充说明：pstree指令用ASCII字符显示树状结构，清楚地表达程序间的相互关系。如果不指定程序识别码或用户名称，则会把系统启动时的第一个程序视为基层，并显示之后的所有程序。若指定用户名称，便会以隶属该用户的第一个程序当作基层，然后显示该用户的所有程序。</p><p>参　　数：</p><ul><li>-a 　显示每个程序的完整指令，包含路径，参数或是常驻服务的标示。 </li><li>-c 　不使用精简标示法。 </li><li>-G 　使用VT100终端机的列绘图字符。 </li><li>-h 　列出树状图时，特别标明现在执行的程序。 </li><li>-H&lt;程序识别码&gt; 　此参数的效果和指定”-h”参数类似，但特别标明指定的程序。 </li><li>-l 　采用长列格式显示树状图。 </li><li>-n 　用程序识别码排序。预设是以程序名称来排序。 </li><li>-p 　显示程序识别码。 </li><li>-u 　显示用户名称。 </li><li>-U 　使用UTF-8列绘图字符。 </li><li>-V 　显示版本信息。</li></ul><h3 id="reboot"><a href="#reboot" class="headerlink" title="reboot"></a>reboot</h3><p>功能说明：重新开机。</p><p>语　　法：<code>dreboot [-dfinw]</code></p><p>补充说明：执行reboot指令可让系统停止运作，并重新开机。</p><p>参　　数：</p><ul><li>-d 　重新开机时不把数据写入记录文件/var/tmp/wtmp。本参数具有”-n”参数的效果。 </li><li>-f 　强制重新开机，不调用shutdown指令的功能。 </li><li>-i 　在重开机之前，先关闭所有网络界面。 </li><li>-n 　重开机之前不检查是否有未结束的程序。 </li><li>-w 　仅做测试，并不真的将系统重新开机，只会把重开机的数据写入/var/log目录下的wtmp记录文件。</li></ul><h3 id="renice"><a href="#renice" class="headerlink" title="renice"></a><font color="red">renice</font></h3><p>功能说明：调整优先权。</p><p>语　　法：<code>renice [优先等级][-g &lt;程序群组名称&gt;…][-p &lt;程序识别码&gt;…][-u &lt;用户名称&gt;…]</code></p><p>补充说明：renice指令可重新调整程序执行的优先权等级。预设是以程序识别码指定程序调整其优先权，您亦可以指定程序群组或用户名称调整优先权等级，并修改所有隶属于该程序群组或用户的程序的优先权。等级范围从-20–19，只有系统管理者可以改变其他用户程序的优先权，也仅有系统管理者可以设置负数等级。</p><p>参　　数：</p><ul><li>-g &lt;程序群组名称&gt; 　使用程序群组名称，修改所有隶属于该程序群组的程序的优先权。 </li><li>-p &lt;程序识别码&gt; 　改变该程序的优先权等级，此参数为预设值。 </li><li>-u &lt;用户名称&gt; 　指定用户名称，修改所有隶属于该用户的程序的优先权。</li></ul><h3 id="rlogin-remote-login"><a href="#rlogin-remote-login" class="headerlink" title="rlogin(remote login)"></a>rlogin(remote login)</h3><p>功能说明：远端登入。</p><p>语　　法：<code>rlogin [-8EL][-e &lt;脱离字符&gt;][-l &lt;用户名称&gt;][主机名称或IP地址]</code></p><p>补充说明：执行rlogin指令开启终端机阶段操作，并登入远端主机。</p><p>参　　数：</p><ul><li>-8 　允许输入8位字符数据。 </li><li>-e脱离字符&gt; 　设置脱离字符。 </li><li>-E 　滤除脱离字符。 </li><li>-l用户名称&gt; 　指定要登入远端主机的用户名称。 </li><li>-L 　使用litout模式进行远端登入阶段操作。</li></ul><h3 id="rsh-remote-shell"><a href="#rsh-remote-shell" class="headerlink" title="rsh(remote shell)"></a>rsh(remote shell)</h3><p>功能说明：远端登入的Shell。</p><p>语　　法：<code>rsh [-dn][-l &lt;用户名称&gt;][主机名称或IP地址][执行指令]</code></p><p>补充说明：rsh提供用户环境，也就是Shell，以便指令能够在指定的远端主机上执行。</p><p>参　　数：</p><ul><li>-d 　使用Socket层级的排错功能。 </li><li>-l&lt;用户名称&gt; 　指定要登入远端主机的用户名称。 </li><li>-n 　把输入的指令号向代号为/dev/null的特殊外围设备。</li></ul><h3 id="rwho"><a href="#rwho" class="headerlink" title="rwho"></a>rwho</h3><p>功能说明：查看系统用户。</p><p>语　　法：<code>rwho [-a]</code></p><p>补充说明：rwho指令的效果类似who指令，但它会显示局域网里所有主机的用户。主机必须提供rwhod常驻服务的功能，方可使用rwho指令。</p><p>参　　数：</p><ul><li>-a 　列出所有的用户，包括闲置时间超过1个小时以上的用户。</li></ul><h3 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h3><p>功能说明：多重视窗管理程序。</p><p>语　　法：<code>screen [-AmRvx -ls -wipe][-d &lt;作业名称&gt;][-h &lt;行数&gt;][-r &lt;作业名称&gt;][-s &lt;shell&gt;][-S &lt;作业名称&gt;]</code></p><p>补充说明：screen为多重视窗管理程序。此处所谓的视窗，是指一个全屏幕的文字模式画面。通常只有在使用telnet登入主机或是使用老式的终端机时，才有可能用到screen程序。</p><p>参　　数：</p><ul><li>-A 　将所有的视窗都调整为目前终端机的大小。 </li><li>-d&lt;作业名称&gt; 　将指定的screen作业离线。 </li><li>-h&lt;行数&gt; 　指定视窗的缓冲区行数。 </li><li>-m 　即使目前已在作业中的screen作业，仍强制建立新的screen作业。 </li><li>-r&lt;作业名称&gt; 　恢复离线的screen作业。 </li><li>-R 　先试图恢复离线的作业。若找不到离线的作业，即建立新的screen作业。 </li><li>-s&lt;shell&gt; 　指定建立新视窗时，所要执行的shell。 </li><li>-S&lt;作业名称&gt; 　指定screen作业的名称。 </li><li>-v 　显示版本信息。 </li><li>-x 　恢复之前离线的screen作业。 </li><li>-ls或–list 　显示目前所有的screen作业。 </li><li>-wipe 　检查目前所有的screen作业，并删除已经无法使用的screen作业。</li></ul><h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h3><p>功能说明：系统关机指令。</p><p>语　　法：<code>shutdown [-efFhknr][-t 秒数][时间][警告信息]</code></p><p>补充说明：shutdown指令可以关闭所有程序，并依用户的需要，进行重新开机或关机的动作。</p><p>参　　数：</p><ul><li>-c 　当执行”shutdown -h 11:50”指令时，只要按+键就可以中断关机的指令。 </li><li>-f 　重新启动时不执行fsck。 </li><li>-F 　重新启动时执行fsck。 </li><li>-h 　将系统关机。 </li><li>-k 　只是送出信息给所有用户，但不会实际关机。 </li><li>-n 　不调用init程序进行关机，而由shutdown自己进行。 </li><li>-r 　shutdown之后重新启动。 </li><li>-t&lt;秒数&gt; 　送出警告信息和删除信息之间要延迟多少秒。 </li></ul><p>PS :</p><pre><code>[时间 ] :　设置多久时间后执行shutdown指令。 [警告信息 ] : 要传送给所有登入用户的信息。</code></pre><h3 id="sliplogin"><a href="#sliplogin" class="headerlink" title="sliplogin"></a>sliplogin</h3><p>功能说明：将SLIP接口加入标准输入。</p><p>语　　法：<code>sliplogin [用户名称]</code></p><p>补充说明：sliplogin可将SLIP接口加入标准输入，把一般终端机的连线变成SLIP连线。通常可用来建立SLIP服务器，让远端电脑以SLIP连线到服务器。sliplogin活去检查/etc/slip/slip.hosts文件中是否有相同的用户名称。通过检查后，sliplogin会调用执行shell script来设置IP地址，子网掩码等网络界面环境。此shell script通常是/etc/slip/slip.login。</p><h3 id="su-super-user"><a href="#su-super-user" class="headerlink" title="su(super user)"></a><font color="red">su(super user)</font></h3><p>功能说明：变更用户身份。</p><p>语　　法：<code>su [-flmp][–help][–version][-][-c &lt;指令&gt;][-s &lt;shell&gt;][用户帐号]</code></p><p>补充说明：su可让用户暂时变更登入的身份。变更时须输入所要变更的用户帐号与密码。</p><p>参　　数：</p><ul><li>-c&lt;指令&gt;或–command=&lt;指令&gt; 　执行完指定的指令后，即恢复原来的身份。 </li><li>-f或–fast 　适用于csh与tsch，使shell不用去读取启动文件。 </li><li>-.-l或–login 　改变身份时，也同时变更工作目录，以及HOME,SHELL,USER,LOGNAME。此外，也会变更PATH变量。  </li><li>-m,-p或–preserve-environment 　变更身份时，不要变更环境变量。 </li><li>-s&lt;shell&gt;或–shell=&lt;shell&gt; 　指定要执行的shell。 </li><li>–help 　显示帮助。 </li><li>–version 　显示版本信息。 </li></ul><p>PS:</p><pre><code>[用户帐号 ] : 指定要变更的用户。若不指定此参数，则预设变更为root。</code></pre><h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a><font color="red">sudo</font></h3><p>功能说明：以其他身份来执行指令。</p><p>语　　法：<code>sudo [-bhHpV][-s &lt;shell&gt;][-u &lt;用户&gt;][指令] 或 sudo [-klv]</code></p><p>补充说明：sudo可让用户以其他的身份来执行指定的指令，预设的身份为root。在/etc/sudoers中设置了可执行sudo指令的用户。若其未经授权的用户企图使用sudo，则会发出警告的邮件给管理员。用户使用sudo时，必须先输入密码，之后有5分钟的有效期限，超过期限则必须重新输入密码。  </p><p>参　　数：</p><ul><li>-b 　在后台执行指令。 </li><li>-h 　显示帮助。 </li><li>-H 　将HOME环境变量设为新身份的HOME环境变量。 </li><li>-k 　结束密码的有效期限，也就是下次再执行sudo时便需要输入密码。 </li><li>-l 　列出目前用户可执行与无法执行的指令。 </li><li>-p 　改变询问密码的提示符号。 </li><li>-s&lt;shell&gt; 　执行指定的shell。 </li><li>-u&lt;用户&gt; 　以指定的用户作为新的身份。若不加上此参数，则预设以root作为新的身份。 </li><li>-v 　延长密码有效期限5分钟。 </li><li>-V 　显示版本信息。</li></ul><h3 id="suspend"><a href="#suspend" class="headerlink" title="suspend"></a>suspend</h3><p>功能说明：暂停执行shell。</p><p>语　　法：<code>suspend [-f]</code></p><p>补充说明：suspend为shell内建指令，可暂停目前正在执行的shell。若要恢复，则必须使用SIGCONT信息。</p><p>参　　数：</p><ul><li>-f 　若目前执行的shell为登入的shell，则suspend预设无法暂停此shell。若要强迫暂停登入的shell，则必须使用-f参数。</li></ul><h3 id="swatch-simple-watcher"><a href="#swatch-simple-watcher" class="headerlink" title="swatch(simple watcher)"></a>swatch(simple watcher)</h3><p>功能说明：系统监控程序。</p><p>语　　法：<code>swatch [-A &lt;分隔字符&gt;][-c &lt;设置文件&gt;][-f &lt;记录文件&gt;][-I &lt;分隔字符&gt;][-P &lt;分隔字符&gt;][-r &lt;时间&gt;][-t &lt;记录文件&gt;]</code></p><p>补充说明：swatch可用来监控系统记录文件，并在发现特定的事件时，执行指定的动作。swatch所监控的事件以及对应事件的动作都存放在swatch的配置文件中。预设的配置文件为拥护根目录下的.swatchrc。然而在Red Hat Linux的预设用户根目录下并没有.swatchrc配置文件，您可将/usr/doc/swatch-2.2/config_files/swatchrc.personal文件复制到用户根目录下的.swatchrc，然后修改.swatchrc所要监控的事件及执行的动作。</p><p>参　　数：</p><ul><li>-A&lt;分隔字符&gt; 　预设配置文件中，动作的分隔字符，预设为逗号。 </li><li>-c设置文件&gt; 　指定配置文件，而不使用预设的配置文件。 </li><li>-f记录文件&gt; 　检查指定的记录文件，检查完毕后不会继续监控该记录文件。 </li><li>-I分隔字符&gt; 　指定输入记录的分隔字符，预设为换行字符。 </li><li>-P分隔字符&gt; 　指定配置文件中，事件的分隔字符，预设为逗号。 </li><li>-r时间&gt; 　在指定的时间重新启动。 </li><li>-t&lt;记录文件&gt; 　检查指定的记录文件，并且会监控加入记录文件中的后继记录。</li></ul><h3 id="tload"><a href="#tload" class="headerlink" title="tload"></a>tload</h3><p>功能说明：显示系统负载状况。</p><p>语　　法：<code>tload [-V][-d &lt;间隔秒数&gt;][-s &lt;刻度大小&gt;][终端机编号]</code></p><p>补充说明：tload指令使用ASCII字符简单地以文字模式显示系统负载状态。假设不给予终端机编号，则会在执行tload指令的终端机显示负载情形。</p><p>参　　数：</p><ul><li>-d&lt;间隔秒数&gt; 　设置tload检测系统负载的间隔时间，单位以秒计算。 </li><li>-s&lt;刻度大小&gt; 　设置图表的垂直刻度大小，单位以列计算。 </li><li>-V 　显示版本信息。</li></ul><h3 id="top"><a href="#top" class="headerlink" title="top"></a><font color="red">top</font></h3><p>功能说明：显示，管理执行中的程序。</p><p>语　　法：<code>top [bciqsS][d &lt;间隔秒数&gt;][n &lt;执行次数&gt;]</code></p><p>补充说明：执行top指令可显示目前正在系统中执行的程序，并通过它所提供的互动式界面，用热键加以管理。</p><p>参　　数：</p><ul><li>b 　使用批处理模式。 </li><li>c 　列出程序时，显示每个程序的完整指令，包括指令名称，路径和参数等相关信息。 </li><li>d&lt;间隔秒数&gt; 　设置top监控程序执行状况的间隔时间，单位以秒计算。 </li><li>i 　执行top指令时，忽略闲置或是已成为Zombie的程序。 </li><li>n&lt;执行次数&gt; 　设置监控信息的更新次数。 </li><li>q 　持续监控程序执行的状况。 </li><li>s 　使用保密模式，消除互动模式下的潜在危机。 </li><li>S 　使用累计模式，其效果类似ps指令的”-S”参数。</li></ul><h3 id="uname"><a href="#uname" class="headerlink" title="uname"></a><font color="red">uname</font></h3><p>功能说明：显示系统信息。</p><p>语　　法：<code>uname [-amnrsv][–help][–version]</code></p><p>补充说明：uname可显示电脑以及操作系统的相关信息。</p><p>参　　数：</p><ul><li>-a或–all 　显示全部的信息。 </li><li>-m或–machine 　显示电脑类型。 </li><li>-n或-nodename 　显示在网络上的主机名称。 </li><li>-r或–release 　显示操作系统的发行编号。 </li><li>-s或–sysname 　显示操作系统名称。 </li><li>-v 　显示操作系统的版本。 </li><li>–help 　显示帮助。 </li><li>–version 　显示版本信息。</li></ul><h3 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a><font color="red">useradd</font></h3><p>功能说明：建立用户帐号。</p><p>语　　法：<code>useradd [-mMnr][-c &lt;备注&gt;][-d &lt;登入目录&gt;][-e &lt;有效期限&gt;][-f &lt;缓冲天数&gt;][-g &lt;群组&gt;][-G &lt;群组&gt;][-s &lt;shell&gt;][-u &lt;uid&gt;][用户帐号] 或 useradd -D [-b][-e &lt;有效期限&gt;][-f &lt;缓冲天数&gt;][-g &lt;群组&gt;][-G &lt;群组&gt;][-s &lt;shell&gt;]</code></p><p>补充说明：useradd可用来建立用户帐号。帐号建好之后，再用passwd设定帐号的密码．而可用userdel删除帐号。使用useradd指令所建立的帐号，实际上是保存在/etc/passwd文本文件中。</p><p>参　　数：</p><ul><li>-c&lt;备注&gt; 　加上备注文字。备注文字会保存在passwd的备注栏位中。　 </li><li>-d&lt;登入目录&gt; 　指定用户登入时的启始目录。 </li><li>-D 　变更预设值． </li><li>-e&lt;有效期限&gt; 　指定帐号的有效期限。 </li><li>-f&lt;缓冲天数&gt; 　指定在密码过期后多少天即关闭该帐号。 </li><li>-g&lt;群组&gt; 　指定用户所属的群组。 </li><li>-G&lt;群组&gt; 　指定用户所属的附加群组。 </li><li>-m 　自动建立用户的登入目录。 </li><li>-M 　不要自动建立用户的登入目录。 </li><li>-n 　取消建立以用户名称为名的群组． </li><li>-r 　建立系统帐号。 </li><li>-s&lt;shell&gt;　 　指定用户登入后所使用的shell。 </li><li>-u&lt;uid&gt; 　指定用户ID。</li></ul><h3 id="userconf"><a href="#userconf" class="headerlink" title="userconf"></a>userconf</h3><p>功能说明：用户帐号设置程序。</p><p>语　　法：<code>userconf [–addgroup &lt;群组&gt;][–adduser &lt;用户ID&gt;&lt;群组&gt;&lt;用户名称&gt;&lt;shell&gt;][–delgroup &lt;群组&gt;][–deluser &lt;用户ID&gt;][–help]</code></p><p>补充说明：userconf实际上为linuxconf的符号连接，提供图形界面的操作方式，供管理员建立与管理各类帐号。若不加任何参数，即进入图形界面。 </p><p>参　　数：</p><ul><li>–addgroup&lt;群组&gt; 　新增群组。 </li><li>–adduser&lt;用户ID&gt;&lt;群组&gt;&lt;用户名称&gt;&lt;shell&gt; 　新增用户帐号。 </li><li>–delgroup&lt;群组&gt; 　删除群组。 </li><li>–deluser&lt;用户ID&gt; 　删除用户帐号。 </li><li>–help 　显示帮助。</li></ul><h3 id="userdel"><a href="#userdel" class="headerlink" title="userdel"></a><font color="red">userdel</font></h3><p>功能说明：删除用户帐号。</p><p>语　　法：<code>userdel [-r][用户帐号]</code></p><p>补充说明：userdel可删除用户帐号与相关的文件。若不加参数，则仅删除用户帐号，而不删除相关文件。</p><p>参　　数：</p><ul><li>-f 　删除用户登入目录以及目录中所有文件。</li></ul><h3 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a><font color="red">usermod</font></h3><p>功能说明：修改用户帐号。</p><p>语　　法：<code>usermod [-LU][-c &lt;备注&gt;][-d &lt;登入目录&gt;][-e &lt;有效期限&gt;][-f &lt;缓冲天数&gt;][-g &lt;群组&gt;][-G &lt;群组&gt;][-l &lt;帐号名称&gt;][-s &lt;shell&gt;][-u &lt;uid&gt;][用户帐号]</code></p><p>补充说明：usermod可用来修改用户帐号的各项设定。</p><p>参　　数：</p><ul><li>-c&lt;备注&gt; 　修改用户帐号的备注文字。 </li><li>-d登入目录&gt; 　修改用户登入时的目录。 </li><li>-e&lt;有效期限&gt; 　修改帐号的有效期限。 </li><li>-f&lt;缓冲天数&gt; 　修改在密码过期后多少天即关闭该帐号。 </li><li>-g&lt;群组&gt; 　修改用户所属的群组。 </li><li>-G&lt;群组&gt; 　修改用户所属的附加群组。 </li><li>-l&lt;帐号名称&gt; 　修改用户帐号名称。 </li><li>-L 　锁定用户密码，使密码无效。 </li><li>-s&lt;shell&gt; 　修改用户登入后所使用的shell。 </li><li>-u&lt;uid&gt; 　修改用户ID。 </li><li>-U 　解除密码锁定。</li></ul><h3 id="vlock-virtual-console-lock"><a href="#vlock-virtual-console-lock" class="headerlink" title="vlock(virtual console lock)"></a>vlock(virtual console lock)</h3><p>功能说明：锁住虚拟终端。</p><p>语　　法：<code>vlock [-achv]</code></p><p>补充说明：执行vlock指令可锁住虚拟终端，避免他人使用。</p><p>参　　数：</p><ul><li>-a或–all 　锁住所有的终端阶段作业，如果您在全屏幕的终端中使用本参数，则会将用键盘切换终端机的功能一并关闭。 </li><li>-c或–current 　锁住目前的终端阶段作业，此为预设值。 </li><li>-h或–help 　在线帮助。 </li><li>-v或–version 　显示版本信息。</li></ul><h3 id="w"><a href="#w" class="headerlink" title="w"></a><font color="red">w</font></h3><p>功能说明：显示目前登入系统的用户信息。</p><p>语　　法：<code>w [-fhlsuV][用户名称]</code></p><p>补充说明：执行这项指令可得知目前登入系统的用户有那些人，以及他们正在执行的程序。单独执行w<br>指令会显示所有的用户，您也可指定用户名称，仅显示某位用户的相关信息。</p><p>参　　数：</p><ul><li>-f 　开启或关闭显示用户从何处登入系统。 </li><li>-h 　不显示各栏位的标题信息列。 </li><li>-l 　使用详细格式列表，此为预设值。 </li><li>-s 　使用简洁格式列表，不显示用户登入时间，终端机阶段作业和程序所耗费的CPU时间。 </li><li>-u 　忽略执行程序的名称，以及该程序耗费CPU时间的信息。 </li><li>-V 　显示版本信息。</li></ul><h3 id="who"><a href="#who" class="headerlink" title="who"></a>who</h3><p>功能说明：显示目前登入系统的用户信息。</p><p>语　　法：<code>who [-Himqsw][–help][–version][am i][记录文件]</code></p><p>补充说明：执行这项指令可得知目前有那些用户登入系统，单独执行who指令会列出登入帐号，使用的 终端机，登入时间以及从何处登入或正在使用哪个X显示器。</p><p>参　　数：</p><ul><li>-H或–heading 　显示各栏位的标题信息列。 </li><li>-i或-u或–idle 　显示闲置时间，若该用户在前一分钟之内有进行任何动作，将标示成”.”号，如果该用户已超过24小时没有任何动作，则标示出”old”字符串。 </li><li>-m 　此参数的效果和指定”am i”字符串相同。 </li><li>-q或–count 　只显示登入系统的帐号名称和总人数。 </li><li>-s 　此参数将忽略不予处理，仅负责解决who指令其他版本的兼容性问题。 </li><li>-w或-T或–mesg或–message或–writable 　显示用户的信息状态栏。 </li><li>–help 　在线帮助。 </li><li>–version 　显示版本信息。</li></ul><h3 id="whoami"><a href="#whoami" class="headerlink" title="whoami"></a>whoami</h3><p>功能说明：显示用户名称。</p><p>语　　法：<code>whoami [–help][–version]</code></p><p>补充说明：显示自身的用户名称，本指令相当于执行”id -un”指令。</p><p>参　　数：</p><ul><li>–help 　在线帮助。 </li><li>–version 　显示版本信息。</li></ul><h3 id="whois"><a href="#whois" class="headerlink" title="whois"></a>whois</h3><p>功能说明：查找并显示用户信息。</p><p>语　　法：<code>whois [帐号名称]</code></p><p>补充说明：whois指令会去查找并显示指定帐号的用户相关信息，因为它是到Network Solutions的WHOIS数据库去查找，所以该帐号名称必须在上面注册方能寻获，且名称没有大小写的差别。</p><h2 id="linux系统设置命令"><a href="#linux系统设置命令" class="headerlink" title="linux系统设置命令"></a>linux系统设置命令</h2><h3 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h3><p>功能说明：设置指令的别名。</p><p>语　　法：<code>alias[别名]=[指令名称]</code></p><p>补充说明：用户可利用alias，自定指令的别名。若仅输入alias，则可列出目前所有的别名设置。　alias的效力仅及于该次登入的操作。若要每次登入是即自动设好别名，可在.profile或.cshrc中设定指令的别名。</p><p>参　　数：若不加任何参数，则列出目前所有的别名设置。</p><h3 id="apmd-advanced-power-management-BIOS-daemon"><a href="#apmd-advanced-power-management-BIOS-daemon" class="headerlink" title="apmd(advanced power management BIOS daemon)"></a>apmd(advanced power management BIOS daemon)</h3><p>功能说明：进阶电源管理服务程序。</p><p>语　　法：<code>apmd [-u v V W][-p &lt;百分比变化量&gt;][-w &lt;百分比值&gt;]</code></p><p>补充说明：apmd负责BIOS进阶电源管理(APM)相关的记录，警告与管理工作。</p><p>参　　数：</p><ul><li>-p&lt;百分比变化量&gt;或–percentage&lt;百分比变化量&gt;  当电力变化的幅度超出设置的百分比变化量，即记录事件百分比变化量的预设值为5，若设置值超过100，则关闭此功能。 </li><li>-u或–utc 将BIOS时钟设为UTC，以便从悬待模式恢复时，将-u参数传送至clock或hwclock程序。 </li><li>-v或–verbose 记录所有的APM事件。 </li><li>-V或–version 显示版本信息。 </li><li>-w&lt;百分比值&gt;或–warn&lt;百分比值&gt; 当电池不在充电状态时，且电池电量低于设置的百分比值，则在syslog(2)的ALERT层记录警告信息。百分比值的预设置为10，若设置为0，则关闭此功能。  </li><li>-W或–wall 发出警告信息给所有人。</li></ul><h3 id="aumix-audio-mixer"><a href="#aumix-audio-mixer" class="headerlink" title="aumix(audio mixer)"></a>aumix(audio mixer)</h3><p>功能说明：设置音效装置。</p><p>语　　法：<code>aumix [-123bcilmoprstvwWx][(+/-)强度][PqR][-dfhILqS]</code></p><p>补充说明：设置各项音效装置的信号强度以及指定播放与录音的装置。</p><p>参　　数：</p><ul><li>[-123bcilmoprstvwWx]为频道参数，用来指定装置的频道；[PqR]可用来指定播放或录音装置；[-dfhILqS] 则为指令参数。若不加任何参数，aumix会显示简单的图形界面供调整设置频道参数：</li><li>-1 　输入信号线１。 </li><li>-2 　输入信号线２。 </li><li>-3 　输入信号线３。 </li><li>-b 　低音。 </li><li>-c 　CD。 </li><li>-i 　输入信号强度。 </li><li>-m 　麦克风。 </li><li>-o 　输出信号强度。  </li><li>-p 　PC喇叭。 </li><li>-r 　录音。 </li><li>-s 　合成器。 </li><li>-t 　高音。 </li><li>-v 　主音量。 </li><li>-w 　PCM。 </li><li>-W 　PCM2。 </li><li>-x 　混音器。 </li><li>(+/-)强度 　出现(+/-)时，代表在原有的强度上加减指定值。若未使用(+/-)，则直接将强度设为指定值。 　</li></ul><p>指定音效装置 </p><ul><li>P 　指定播放装置。 </li><li>q 　显示频道设置。 </li><li>R 　指定录音装置。 </li></ul><p>指令参数 </p><ul><li>-d 　指定音效装置的名称。 </li><li>-f 　指定存储或载入设置的文件。 </li><li>-h 　在使用时显示信息。 </li><li>-I 　以图形界面方式来执行aumix。 </li><li>-L 　从$HOME/.aumixrc或/etc/aumixrc载入设置。 </li><li>-q 　显示所有频道的设置值。 </li><li>-S 　将设置值保存至/HOME/.aumixrc。</li></ul><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>功能说明：显示或设置键盘按键与其相关的功能。</p><p>语　　法：<code>bind [-dlv][-f &lt;按键配置文件&gt;][-m &lt;按键配置&gt;][-q &lt;功能&gt;]</code></p><p>补充说明：您可以利用bind命令了解有哪些按键组合与其功能，也可以自行指定要用哪些按键组合。</p><p>参　　数：</p><ul><li>-d 　显示按键配置的内容。 </li><li>-f&lt;按键配置文件&gt; 　载入指定的按键配置文件。 </li><li>-l 　列出所有的功能。 </li><li>-m&lt;按键配置&gt; 　指定按键配置。 </li><li>-q&lt;功能&gt; 　显示指定功能的按键。 </li><li>-v 　列出目前的按键配置与其功能。</li></ul><h3 id="chkconfig-check-config"><a href="#chkconfig-check-config" class="headerlink" title="chkconfig(check config)"></a>chkconfig(check config)</h3><p>功能说明：检查，设置系统的各种服务。</p><p>语　　法：<code>chkconfig [–add][–del][–list][系统服务] 或 chkconfig [–level &lt;等级代号&gt;][系统服务][on/off/reset]</code></p><p>补充说明：这是Red Hat公司遵循GPL规则所开发的程序，它可查询操作系统在每一个执行等级中会执行哪些系统服务，其中包括各类常驻服务。</p><p>参　　数：</p><ul><li>–add 　增加所指定的系统服务，让chkconfig指令得以管理它，并同时在系统启动的叙述文件内增加相关数据。 </li><li>–del 　删除所指定的系统服务，不再由chkconfig指令管理，并同时在系统启动的叙述文件内删除相关数据。 </li><li>–level&lt;等级代号&gt; 　指定读系统服务要在哪一个执行等级中开启或关毕</li></ul><h3 id="chroot-change-root"><a href="#chroot-change-root" class="headerlink" title="chroot(change root)"></a>chroot(change root)</h3><p>功能说明：改变根目录。</p><p>语　　法：<code>chroot [–help][–version][目的目录][执行指令…]</code></p><p>补充说明：把根目录换成指定的目的目录。</p><p>参　　数：</p><ul><li>–help 　在线帮助。</li><li>–version 　显示版本信息。</li></ul><h3 id="clock"><a href="#clock" class="headerlink" title="clock"></a>clock</h3><p>功能说明：调整 RTC 时间。</p><p>语　　法：<br><code>clock [–adjust][–debug][–directisa][–getepoch][–hctosys][–set –date=”&lt;日期时间&gt;”][–setepoch –epoch=&lt;年份&gt;][–show][–systohc][–test][–utc][–version]</code></p><p>补充说明：RTC 是电脑内建的硬件时间，执行这项指令可以显示现在时刻，调整硬件时钟的时间，将系统时间设成与硬件时钟之时间一致，或是把系统时间回存到硬件时钟。</p><p>参　　数：</p><ul><li>–adjust 　第一次使用”–set”或”–systohc”参数设置硬件时钟，会在/etc目录下产生一个名称为adjtime的文件。当再次使用这两个参数调整硬件时钟，此文件便会记录两次调整间之差异，日后执行clock指令加上”–adjust”参数时，程序会自动根 据记录文件的数值差异，计算出平均值，自动调整硬件时钟的时间。 </li><li>–debug 　详细显示指令执行过程，便于排错或了解程序执行的情形。 </li><li>–directisa 　告诉clock指令不要通过/dev/rtc设备文件，直接对硬件时钟进行存取。这个参数适用于仅有ISA总线结构的老式电脑。 </li><li>–getepoch 　把系统核心内的硬件时钟新时代数值，呈现到标准输出设备。 </li><li>–hctosys 　Hardware Clock to System Time，把系统时间设成和硬件时钟一致。由于这个动作将会造成系统全面更新文件的存取时间，所以最好在系统启动时就执行它。 </li><li>–set–date 　设置硬件时钟的日期和时间。 </li><li>–setepoch–epoch=&lt;年份&gt;  　设置系统核心之硬件时钟的新时代数值，年份以四位树字表示。 </li><li>–show 　读取硬件时钟的时间，并将其呈现至标准输出设备。 </li><li>–systohc 　System Time to Hardware Clock，将系统时间存回硬件时钟内。 </li><li>–test 　仅作测试，并不真的将时间写入硬件时钟或系统时间。 </li><li>–utc 　把硬件时钟上的时间时为CUT，有时也称为UTC或UCT。 </li><li>–version 　显示版本信息。</li></ul><h3 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h3><p>功能说明：设置计时器。</p><p>语　　法：<code>crontab [-u &lt;用户名称&gt;][配置文件] 或 crontab [-u &lt;用户名称&gt;][-elr]</code></p><p>补充说明：cron是一个常驻服务，它提供计时器的功能，让用户在特定的时间得以执行预设的指令或程序。只要用户会编辑计时器的配置文件，就可以使用计时器的功能。其配置文件格式如下：</p><pre><code>Minute Hour Day Month DayOFWeek Command </code></pre><p>参　　数：</p><ul><li>-e 　编辑该用户的计时器设置。 </li><li>-l 　列出该用户的计时器设置。 </li><li>-r 　删除该用户的计时器设置。 </li><li>-u&lt;用户名称&gt; 　指定要设定计时器的用户名称。</li></ul><h3 id="declare"><a href="#declare" class="headerlink" title="declare"></a>declare</h3><p>功能说明：声明 shell 变量。</p><p>语　　法：<code>declare [+/-][rxi][变量名称＝设置值] 或 declare -f</code></p><p>补充说明：declare为shell指令，在第一种语法中可用来声明变量并设置变量的属性([rix]即为变量的属性），在第二种语法中可用来显示shell函数。若不加上任何参数，则会显示全部的shell变量与函数(与执行set指令的效果相同)。</p><p>参　　数：</p><ul><li>+/- 　“-“可用来指定变量的属性，”+”则是取消变量所设的属性。 </li><li>-f 　仅显示函数。 </li><li>r 　将变量设置为只读。 </li><li>x 　指定的变量会成为环境变量，可供shell以外的程序来使用。 </li><li>i 　[设置值]可以是数值，字符串或运算式。</li></ul><h3 id="depmod-depend-module"><a href="#depmod-depend-module" class="headerlink" title="depmod(depend module)"></a>depmod(depend module)</h3><p>功能说明：分析可载入模块的相依性。</p><p>语　　法：<code>depmod [-adeisvV][-m &lt;文件&gt;][–help][模块名称]</code></p><p>补充说明：depmod可检测模块的相依性，供modprobe在安装模块时使用。</p><p>参　　数：</p><ul><li>-a或–all 　分析所有可用的模块。 </li><li>-d或debug 　执行排错模式。 </li><li>-e 　输出无法参照的符号。 </li><li>-i 　不检查符号表的版本。 </li><li>-m&lt;文件&gt;或system-map&lt;文件&gt; 　使用指定的符号表文件。 </li><li>-s或–system-log 　在系统记录中记录错误。 </li><li>-v或–verbose 　执行时显示详细的信息。 </li><li>-V或–version 　显示版本信息。 </li><li>–help 　显示帮助。</li></ul><h3 id="dircolors"><a href="#dircolors" class="headerlink" title="dircolors"></a>dircolors</h3><p>功能说明：设置 ls 指令在显示目录或文件时所用的色彩。</p><p>语　　法：<code>dircolors [色彩配置文件] 或 dircolors [-bcp][–help][–version]</code></p><p>补充说明：dircolors可根据[色彩配置文件]来设置LS_COLORS环境变量或是显示设置LS_COLORS环境变量的shell指令。</p><p>参　　数：</p><ul><li>-b或–sh或–bourne-shell 　显示在Boume shell中，将LS_COLORS设为目前预设置的shell指令。 </li><li>-c或–csh或–c-shell 　显示在C shell中，将LS_COLORS设为目前预设置的shell指令。 </li><li>-p或–print-database 　显示预设置 </li><li>-help 　显示帮助。 </li><li>-version 　显示版本信息。</li></ul><h3 id="dmesg"><a href="#dmesg" class="headerlink" title="dmesg"></a>dmesg</h3><p>功能说明：显示开机信息。</p><p>语　　法：<code>dmesg [-cn][-s &lt;缓冲区大小&gt;]</code></p><p>补充说明：kernel会将开机信息存储在ring buffer中。您若是开机时来不及查看信息，可利用dmesg来查看。开机信息亦保存在/var/log目录中，名称为dmesg的文件里。</p><p>参　　数：</p><ul><li>-c 　显示信息后，清除ring buffer中的内容。 </li><li>-s&lt;缓冲区大小&gt; 　预设置为8196，刚好等于ring buffer的大小。 </li><li>-n 　设置记录信息的层级。</li></ul><h3 id="enable"><a href="#enable" class="headerlink" title="enable"></a>enable</h3><p>功能说明：启动或关闭 shell 内建指令。</p><p>语　　法：<code>enable [-n][-all][内建指令]</code></p><p>补充说明：若要执行的文件名称与shell内建指令相同，可用enable -n来关闭shell内建指令。若不加-n参数，enable可重新启动关闭的指令。</p><p>参　　数：</p><ul><li>-n 　关闭指定的shell内建指令。 </li><li>-all 　显示shell所有关闭与启动的指令。</li></ul><h3 id="eval"><a href="#eval" class="headerlink" title="eval"></a><font color="red">eval</font></h3><p>功能说明：重新运算求出参数的内容。</p><p>语　　法：<code>eval [参数]</code></p><p>补充说明：eval可读取一连串的参数，然后再依参数本身的特性来执行。</p><p>参　　数：参数不限数目，彼此之间用分号分开。</p><h3 id="export"><a href="#export" class="headerlink" title="export"></a><font color="red">export</font></h3><p>功能说明：设置或显示环境变量。</p><p>语　　法：<code>export [-fnp][变量名称]=[变量设置值]</code></p><p>补充说明：在shell中执行程序时，shell会提供一组环境变量。export可新增，修改或删除环境变量，供后续执行的程序使用。export的效力仅及于该此登陆操作。</p><p>参　　数：</p><ul><li>-f 　代表[变量名称]中为函数名称。 </li><li>-n 　删除指定的变量。变量实际上并未删除，只是不会输出到后续指令的执行环境中。 </li><li>-p 　列出所有的shell赋予程序的环境变量。</li></ul><h3 id="fbset-frame-buffer-setup"><a href="#fbset-frame-buffer-setup" class="headerlink" title="fbset(frame buffer setup)"></a>fbset(frame buffer setup)</h3><p>功能说明：设置景框缓冲区。</p><p>语　　法：<code>fbset [-ahinsvVx][-db &lt;信息文件&gt;][-fb &lt;外围设备代号&gt;][–test][显示模式]</code></p><p>补充说明：fbset指令可用于设置景框缓冲区的大小，还能调整画面之分辨率，位置，高低宽窄，色彩 深度，并可决定是否启动先卡之各项硬件特性。</p><p>参　　数：</p><ul><li>-a或–all 　改变所有使用该设备之虚拟终端机的显示模式。 </li><li>-db&lt;信息文件&gt; 　指定显示模式的信息文件，预设值文件名称为fb.modes，存放在/etc目录下  </li><li>-fb&lt;外围设备代号&gt; 　指定用来做为输出景框缓冲区之外围设备，预设置为”/dev/fd0”。 </li><li>-h或-help 　在线帮助。 </li><li>-i或–info 　列出所有景框缓冲区之相关信息。 </li><li>-ifb&lt;外围设备代号&gt; 　使用另一个景框缓冲区外围设备之设置值。 </li><li>-n或–now 　马上改变显示模式。 </li><li>-ofb&lt;外围设备代号&gt; 　此参数效果和指定”-fb”参数相同。 </li><li>-s或–show 　列出目前显示模式之设置。 </li><li>-v或–verbose 　显示指令执行过程。 </li><li>-V或–version 　显示版本信息。 </li><li>-x或–xfree86 　使用XFree86兼容模式。 </li><li>–test 　仅做测试，并不改变现行的显示模式</li></ul><h3 id="grpconv-group-convert-to-shadow-password"><a href="#grpconv-group-convert-to-shadow-password" class="headerlink" title="grpconv(group convert to shadow password)"></a>grpconv(group convert to shadow password)</h3><p>功能说明：开启群组的投影密码。</p><p>语　　法：<code>grpconv</code></p><p>补充说明：Linux系统里的用户和群组密码，分别存放在/etc目录下的passwd和group文件中。因系统运作所需，任何人都得以读取它们，造成安全上的破绽。投影密码将文件内的密码改存在/etc目录下的shadow和gshadow文件内，只允许系统管理者读取，同时把原密码置换为”x”字符。投影密码的功能可随时开启或关闭，您只需执行grpconv指令就能开启群组投影密码。</p><h3 id="grpunconv-group-unconvert-from-shadow-password"><a href="#grpunconv-group-unconvert-from-shadow-password" class="headerlink" title="grpunconv(group unconvert from shadow password)"></a>grpunconv(group unconvert from shadow password)</h3><p>功能说明：关闭群组的投影密码。</p><p>语　　法：<code>grpunconv</code></p><p>补充说明：执行grpunconv指令可关闭群组投影密码，它会把密码从gshadow文件内，回存到group文件里。</p><h3 id="hwclock-hardware-clock"><a href="#hwclock-hardware-clock" class="headerlink" title="hwclock(hardware clock)"></a>hwclock(hardware clock)</h3><p>功能说明：显示与设定硬件时钟。</p><p>语　　法：<br><code>hwclock [–adjust][–debug][–directisa][–hctosys][–show][–systohc][–test]<br>[–utc][–version][–set –date=&lt;日期与时间&gt;]</code></p><p>补充说明：在Linux中有硬件时钟与系统时钟等两种时钟。硬件时钟是指主机板上的时钟设备，也就是通常可在BIOS画面设定的时钟。系统时钟则是指kernel中的时钟。当Linux启动时，系统时钟会去读取硬件时钟的设定，之后系统时钟即独立运作。所有Linux相关指令与函数都是读取系统时钟的设定。</p><p>参　　数：</p><ul><li>–adjust 　hwclock每次更改硬件时钟时，都会记录在/etc/adjtime文件中。使用–adjust参数，可使hwclock根据先前的记录来估算硬件时钟的偏差，并用来校正目前的硬件时钟。 </li><li>–debug 　显示hwclock执行时详细的信息。 </li><li>–directisa 　hwclock预设从/dev/rtc设备来存取硬件时钟。若无法存取时，可用此参数直接以I/O指令来存取硬件时钟。 </li><li>–hctosys 　将系统时钟调整为与目前的硬件时钟一致。 </li><li>–set –date=&lt;日期与时间&gt; 　设定硬件时钟。 </li><li>–show 　显示硬件时钟的时间与日期。 </li><li>–systohc 　将硬件时钟调整为与目前的系统时钟一致。 </li><li>–test 　仅测试程序，而不会实际更改硬件时钟。 </li><li>–utc 　若要使用格林威治时间，请加入此参数，hwclock会执行转换的工作。 </li><li>–version 　显示版本信息。</li></ul><h3 id="insmod-install-module"><a href="#insmod-install-module" class="headerlink" title="insmod(install module)"></a>insmod(install module)</h3><p>功能说明：载入模块。</p><p>语　　法：<code>insmod [-fkmpsvxX][-o &lt;模块名称&gt;][模块文件][符号名称 = 符号值]</code></p><p>补充说明：Linux有许多功能是通过模块的方式，在需要时才载入kernel。如此可使kernel较为精简，进而提高效率，以及保有较大的弹性。这类可载入的模块，通常是设备驱动程序。</p><p>参　　数：</p><ul><li>-f 　不检查目前kernel版本与模块编译时的kernel版本是否一致，强制将模块载入。 </li><li>-k 　将模块设置为自动卸除。 </li><li>-m 　输出模块的载入信息。 </li><li>-o&lt;模块名称&gt; 　指定模块的名称，可使用模块文件的文件名。 </li><li>-p 　测试模块是否能正确地载入kernel。 </li><li>-s 　将所有信息记录在系统记录文件中。 </li><li>-v 　执行时显示详细的信息。 </li><li>-x 　不要汇出模块的外部符号。 </li><li>-X 　汇出模块所有的外部符号，此为预设置</li></ul><h3 id="kbdconfig"><a href="#kbdconfig" class="headerlink" title="kbdconfig"></a>kbdconfig</h3><p>功能说明：设置键盘类型。</p><p>语　　法：<code>kbdconfig [–back][–test]</code></p><p>补充说明：kbdconfig(Red Hat Linux才有的指令)是一个用来设置键盘的程序，提供图形化的操作界面。kbdconfig实际上是修改/etc/sysconfig/keyboard的键盘配置文件。</p><p>参　　数：</p><ul><li>–back 　执行时将预设的Cancel按钮更改为Back按钮。 </li><li>–test 　仅作测试，不会实际更改设置。</li></ul><h3 id="lilo-linux-loader"><a href="#lilo-linux-loader" class="headerlink" title="lilo(linux loader)"></a>lilo(linux loader)</h3><p>功能说明：安装核心载入，开机管理程序。</p><p>语　　法：<code>lilo [-clqtV][-b&lt;外围设备代号&gt;][-C&lt;配置文件&gt;][-d&lt;延迟时间&gt;][－D&lt;识别标签&gt;][-f&lt;几何参数文件&gt;][-i&lt;开机磁区文件&gt;][-I&lt;识别标签&gt;][-m&lt;映射文件&gt;][-P&lt;fix/ignore&gt;][-r&lt;根目录&gt;][-R&lt;执行指令&gt;…][-s&lt;备份文件&gt;][-S&lt;备份文件&gt;][-uU&lt;外围设备代号&gt;][-v…]</code></p><p>补充说明：lilo是个Linux系统核心载入程序，同时具备管理开机的功能。单独执行lilo指令，它会读取/etc/目录下的lilo.conf配置文件，然后根据其内容安装lilo。</p><p>参　　数：</p><ul><li>-b&lt;外围设备代号&gt; 　指定安装lilo之处的外围设备代号。 </li><li>-c 　使用紧致映射模式。 </li><li>-C&lt;配置文件&gt; 　指定lilo的配置文件。 </li><li>-d&lt;延迟时间&gt; 　设置开机延迟时间。 </li><li>-D&lt;识别标签&gt; 　指定开机后预设启动的操作系统，或系统核心识别标签。 </li><li>-f&lt;几何参数文件&gt; 　指定磁盘的几何参数配置文件。 </li><li>-i&lt;开机磁区文件&gt; 　指定欲使用的开机磁区文件，预设是/boot目录里的boot.b文件。 </li><li>-I&lt;识别标签&gt; 　显示系统核心存放之处。 </li><li>-l 　产生线形磁区地址。 </li><li>-m&lt;映射文件&gt; 　指定映射文件。 </li><li>-P&lt;fix/ignore&gt; 　决定要修复或忽略分区表的错误。 </li><li>-q 　列出映射的系统核心文件。 </li><li>-r&lt;根目录&gt; 　设置系统启动时欲挂入成为根目录的目录。 </li><li>-R&lt;执行指令&gt; 　设置下次启动系统时，首先执行的指令。 </li><li>-s&lt;备份文件&gt; 　指定备份文件。 </li><li>-S&lt;备份文件&gt; 　强制指定备份文件。 </li><li>-t 　不执行指令，仅列出实际执行会进行的动作。 </li><li>-u&lt;外围色设备代号&gt; 　删除lilo。 </li><li>-U&lt;外围设备代号&gt; 　此参数的效果和指定”-u”参数类似，当不检查时间戳记。 </li><li>-v 　显示指令执行过程。 </li><li>-V 　显示版本信息。</li></ul><h3 id="liloconfig"><a href="#liloconfig" class="headerlink" title="liloconfig"></a>liloconfig</h3><p>功能说明：设置核心载入，开机管理程序。</p><p>语　　法：<code>liloconfig</code></p><p>补充说明：liloconfig是Slackware发行版专门用来调整lilo设置的程序。它通过互动式操作界面，让用户能够利用键盘上的方向键等，轻易地操控lilo的安装，设置作业，而无须下达各种参数或撰写配置文件。</p><h3 id="lsmod-list-modules"><a href="#lsmod-list-modules" class="headerlink" title="lsmod(list modules)"></a>lsmod(list modules)</h3><p>功能说明：显示已载入系统的模块。</p><p>语　　法：<code>lsmod</code></p><p>补充说明：执行lsmod指令，会列出所有已载入系统的模块。Linux操作系统的核心具有模块化的特性，应此在编译核心时，务须把全部的功能都放入核心。您可以将这些功能编译成一个个单独的模块，待需要时再分别载入。</p><h3 id="minfo"><a href="#minfo" class="headerlink" title="minfo"></a>minfo</h3><p>功能说明：显示MS-DOS文件系统的各项参数。</p><p>语　　法：<code>minfo [-v][驱动器代号]</code></p><p>补充说明：minfo为mtools工具指令，可显示MS-DOS系统磁盘的各项参数，包括磁区数，磁头数…等。</p><p>参　　数：</p><ul><li>-v 　除了一般信息外，并显示可开机磁区的内容。</li></ul><h3 id="mkkickstart"><a href="#mkkickstart" class="headerlink" title="mkkickstart"></a>mkkickstart</h3><p>功能说明：建立安装的组态文件。</p><p>语　　法：<code>mkkickstart [–bootp][–dhcp][–nonet][–nox][–version][–nfs &lt;远端电脑:路径&gt;]</code></p><p>补充说明：mkkickstart可根据目前系统的设置来建立组态文件，供其他电脑在安装时使用。组态文件的内容包括使用语言，网络环境，系统磁盘状态，以及X Windows的设置等信息。</p><p>参　　数：</p><ul><li>–bootp 　安装与开机时，使用BOOTP。 </li><li>–dhcp 　安装与开机时，使用DHCP。 </li><li>–nfs&lt;远端电脑:路径&gt; 　使用指定的网络路径安装。 </li><li>–nonet 　不要进行网络设置，即假设在没有网络环境的状态下。 </li><li>–nox 　不要进行X Windows的环境设置。 </li><li>–version 　显示版本信息。</li></ul><h3 id="modinfo-module-infomation"><a href="#modinfo-module-infomation" class="headerlink" title="modinfo(module infomation)"></a>modinfo(module infomation)</h3><p>功能说明：显示kernel模块的信息。</p><p>语　　法：<code>modinfo [-adhpV][模块文件]</code></p><p>补充说明：modinfo会显示kernel模块的对象文件，以显示该模块的相关信息。</p><p>参　　数：</p><ul><li>-a或–author 　显示模块开发人员。 </li><li>-d或–description 　显示模块的说明。 </li><li>-h或–help 　显示modinfo的参数使用方法。 </li><li>-p或–parameters 　显示模块所支持的参数。 </li><li>-V或–version 　显示版本信息。</li></ul><h3 id="modprobe-module-probe"><a href="#modprobe-module-probe" class="headerlink" title="modprobe(module probe)"></a>modprobe(module probe)</h3><p>功能说明：自动处理可载入模块。</p><p>语　　法：<code>modprobe [-acdlrtvV][–help][模块文件][符号名称 = 符号值]</code></p><p>补充说明：modprobe可载入指定的个别模块，或是载入一组相依的模块。modprobe会根据depmod所产生的相依关系，决定要载入哪些模块。若在载入过程中发生错误，在modprobe会卸载整组的模块。</p><p>参　　数：</p><ul><li>-a或–all 　载入全部的模块。 </li><li>-c或–show-conf 　显示所有模块的设置信息。 </li><li>-d或–debug 　使用排错模式。 </li><li>-l或–list 　显示可用的模块。 </li><li>-r或–remove 　模块闲置不用时，即自动卸载模块。 </li><li>-t或–type 　指定模块类型。 </li><li>-v或–verbose 　执行时显示详细的信息。 </li><li>-V或–version 　显示版本信息。 </li><li>-help 　显示帮助。</li></ul><h3 id="mouseconfig"><a href="#mouseconfig" class="headerlink" title="mouseconfig"></a>mouseconfig</h3><p>功能说明：设置鼠标相关参数。</p><p>语　　法：<br><code>mouseconfig [–back][–emulthree][–help][–expert][–kickstart][–noprobe][–test][–device &lt;连接端口&gt;][鼠标类型]</code></p><p>补充说明：mouseconfig为鼠标设置程序，可自动设置相关参数，或者用户也可以利用所提供互动模式自行设置鼠标。mouseconfig是Red Hat Linux才有的命令。</p><p>参　　数：</p><ul><li>–back 　在设置画面上显示Back按钮，而取代预设的Cancel按钮。 </li><li>–device&lt;连接端口&gt; 　指定硬件连接端口。可用的选项有ttyS0，ttyS1，ttyS2，ttyS3与orpsaux。 </li><li>–emulthree 　将二钮鼠标模拟成三钮鼠标。 </li><li>–help 　显示帮助以及所有支持的鼠标类型。 </li><li>–expert 　程序预设可自动判断部分设置值。若要自行设置，请使用–expert参数。 </li><li>–kickstart 　让程序自动检测并保存所有的鼠标设置。 </li><li>–noprobe 　不要检测鼠标设备。 </li><li>–test 　测试模式，不会改变任何设置。</li></ul><h3 id="ntsysv"><a href="#ntsysv" class="headerlink" title="ntsysv"></a>ntsysv</h3><p>功能说明：设置系统的各种服务。</p><p>语　　法：<code>ntsysv [–back][–level &lt;等级代号&gt;]</code></p><p>补充说明：这是Red Hat公司遵循GPL规则所开发的程序，它具有互动式操作界面，您可以轻易地利用方向键和空格键等，开启，关闭操作系统在每个执行等级中，所要执行的系统服务。</p><p>参　　数：</p><ul><li>–back 　在互动式界面里，显示Back钮，而非Cancel钮。 </li><li>–level &lt;等级代号&gt; 　在指定的执行等级中，决定要开启或关闭哪些系统服务。</li></ul><h3 id="passwd-password"><a href="#passwd-password" class="headerlink" title="passwd(password)"></a>passwd(password)</h3><p>功能说明：设置密码。</p><p>语　　法：<code>passwd [-dklS][-u &lt;-f&gt;][用户名称]</code></p><p>补充说明：passwd指令让用户可以更改自己的密码，而系统管理者则能用它管理系统用户的密码。只有管理者可以指定用户名称，一般用户只能变更自己的密码。</p><p>参　　数：</p><ul><li>-d 　删除密码。本参数仅有系统管理者才能使用。 </li><li>-f 　强制执行。 </li><li>-k 　设置只有在密码过期失效后，方能更新。 </li><li>-l 　锁住密码。 </li><li>-s 　列出密码的相关信息。本参数仅有系统管理者才能使用。 </li><li>-u 　解开已上锁的帐号。</li></ul><h3 id="pwconv"><a href="#pwconv" class="headerlink" title="pwconv"></a>pwconv</h3><p>功能说明：开启用户的投影密码。</p><p>语　　法：<code>pwconv</code></p><p>补充说明：Linux系统里的用户和群组密码，分别存放在名称为passwd和group的文件中，　这两个文件位于/etc目录下。因系统运作所需，任何人都得以读取它们，造成安全上的破绽。投影密码将文件内的密码改存在/etc目录下的shadow和gshadow文件内，只允许系统管理者读取，同时把原密码置换为”x”字符，有效的强化了系统的安全性。</p><h3 id="pwunconv"><a href="#pwunconv" class="headerlink" title="pwunconv"></a>pwunconv</h3><p>功能说明：关闭用户的投影密码。</p><p>语　　法：<code>pwunconv</code></p><p>补充说明：执行pwunconv指令可以关闭用户投影密码，它会把密码从shadow文件内，重回存到passwd文件里。</p><h3 id="rdate-receive-date"><a href="#rdate-receive-date" class="headerlink" title="rdate(receive date)"></a>rdate(receive date)</h3><p>功能说明：显示其他主机的日期与时间。</p><p>语　　法：<code>rdate [-ps][主机名称或IP地址…]</code></p><p>补充说明：执行rdate指令，向其他主机询问系统时间并显示出来。</p><p>参　　数：</p><ul><li>-p 　显示远端主机的日期与时间。 </li><li>-s 　把从远端主机收到的日期和时间，回存到本地主机的系统时间。</li></ul><h3 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h3><p>功能说明：设置终端机视窗的大小。</p><p>语　　法：<code>resize [-cu][-s &lt;列数&gt; &lt;行数&gt;]</code></p><p>补充说明：执行resize指令可设置虚拟终端机的视窗大小。</p><p>参　　数：</p><ul><li>-c 　就算用户环境并非C Shell，也用C Shell指令改变视窗大小。 </li><li>-s &lt;列数&gt; &lt;行数&gt; 　设置终端机视窗的垂直高度和水平宽度。 </li><li>-u 　就算用户环境并非Bourne Shell，也用Bourne Shell指令改变视窗大小。</li></ul><h3 id="rmmod-remove-module"><a href="#rmmod-remove-module" class="headerlink" title="rmmod(remove module)"></a>rmmod(remove module)</h3><p>功能说明：删除模块。</p><p>语　　法：<code>rmmod [-as][模块名称…]</code></p><p>补充说明：执行rmmod指令，可删除不需要的模块。Linux操作系统的核心具有模块化的特性，应此在编译核心时，务须把全部的功能都放如核心。你可以将这些功能编译成一个个单独的模块，待有需要时再分别载入它们。</p><p>参　　数：</p><ul><li>-a 　删除所有目前不需要的模块。 </li><li>-s 　把信息输出至syslog常驻服务，而非终端机界面。</li></ul><h3 id="rpm-redhat-package-manager"><a href="#rpm-redhat-package-manager" class="headerlink" title="rpm(redhat package manager)"></a>rpm(redhat package manager)</h3><p>功能说明：管理套件。</p><p>语　　法：<code>rpm [-acdhilqRsv][-b&lt;完成阶段&gt;&lt;套间档&gt;+][-e&lt;套件挡&gt;][-f&lt;文件&gt;+][-i&lt;套件档&gt;][-p&lt;套件档&gt;＋][-U&lt;套件档&gt;][-vv][–addsign&lt;套件档&gt;+][–allfiles][–allmatches][–badreloc][–buildroot&lt;根目录&gt;][–changelog][–checksig&lt;套件档&gt;+][–clean][–dbpath&lt;数据库目录&gt;][–dump][–excludedocs][–excludepath&lt;排除目录&gt;][–force][–ftpproxy&lt;主机名称或IP地址&gt;][–ftpport&lt;通信端口&gt;][–help][–httpproxy&lt;主机名称或IP地址&gt;][–httpport&lt;通信端口&gt;][–ignorearch][–ignoreos][–ignoresize][–includedocs][–initdb][justdb][–nobulid][–nodeps][–nofiles][–nogpg][–nomd5][–nopgp][–noorder][–noscripts][–notriggers][–oldpackage][–percent][–pipe&lt;执行指令&gt;][–prefix&lt;目的目录&gt;][–provides][–queryformat&lt;档头格式&gt;][–querytags][–rcfile&lt;配置档&gt;][–rebulid&lt;套件档&gt;][–rebuliddb][–recompile&lt;套件档&gt;][–relocate&lt;原目录&gt;=&lt;新目录&gt;][–replacefiles][–replacepkgs][–requires][–resign&lt;套件档&gt;+][–rmsource][–rmsource&lt;文件&gt;][–root&lt;根目录&gt;][–scripts][–setperms][–setugids][–short-circuit][–sign][–target=&lt;安装平台&gt;+][–test][–timecheck&lt;检查秒数&gt;][–triggeredby&lt;套件档&gt;][–triggers][–verify][–version][–whatprovides&lt;功能特性&gt;][–whatrequires&lt;功能特性&gt;]</code></p><p>补充说明：rmp原本是Red Hat Linux发行版专门用来管理Linux各项套件的程序，由于它遵循GPL规则且功能强大方便，因而广受欢迎。逐渐受到其他发行版的采用。RPM套件管理方式的出现，让Linux易于安装，升级，间接提升了Linux的适用度。</p><p>参　　数：</p><ul><li>-a 　查询所有套件。</li><li>-b&lt;完成阶段&gt;&lt;套件档&gt;+或-t &lt;完成阶段&gt;&lt;套件档&gt;+ 　设置包装套件的完成阶段，并指定套件档的文件名称。</li><li>-c 　只列出组态配置文件，本参数需配合”-l”参数使用。 </li><li>-d 　只列出文本文件，本参数需配合”-l”参数使用。　 </li><li>-e&lt;套件档&gt;或–erase&lt;套件档&gt; 　删除指定的套件。</li><li>-f&lt;文件&gt;+ 　查询拥有指定文件的套件。 </li><li>-h或–hash 　套件安装时列出标记。 </li><li>-i 　显示套件的相关信息。 </li><li>-i&lt;套件档&gt;或–install&lt;套件档&gt; 　安装指定的套件档。 </li><li>-l 　显示套件的文件列表。 </li><li>-p&lt;套件档&gt;+ 　查询指定的RPM套件档。 </li><li>-q 　使用询问模式，当遇到任何问题时，rpm指令会先询问用户。 </li><li>-R 　显示套件的关联性信息。 </li><li>-s 　显示文件状态，本参数需配合”-l”参数使用。 </li><li>-U&lt;套件档&gt;或–upgrade&lt;套件档&gt;   升级指定的套件档。 </li><li>-v 　显示指令执行过程。</li><li>-vv 　详细显示指令执行过程，便于排错。 </li><li>-addsign&lt;套件档&gt;+ 　在指定的套件里加上新的签名认证。 </li><li>–allfiles 　安装所有文件。 </li><li>–allmatches 　删除符合指定的套件所包含的文件。 </li><li>–badreloc 　发生错误时，重新配置文件。 </li><li>–buildroot&lt;根目录&gt; 　设置产生套件时，欲当作根目录的目录。 </li><li>–changelog 　显示套件的更改记录。 </li><li>–checksig&lt;套件档&gt;+ 　检验该套件的签名认证。 </li><li>–clean 　完成套件的包装后，删除包装过程中所建立的目录。 </li><li>–dbpath&lt;数据库目录&gt; 　设置欲存放RPM数据库的目录。 </li><li>–dump 　显示每个文件的验证信息。本参数需配合”-l”参数使用。 </li><li>–excludedocs 　安装套件时，不要安装文件。 </li><li>–excludepath&lt;排除目录&gt; 　忽略在指定目录里的所有文件。 </li><li>–force 　强行置换套件或文件。 </li><li>–ftpproxy&lt;主机名称或IP地址&gt; 　指定FTP代理服务器。 </li><li>–ftpport&lt;通信端口&gt; 　设置FTP服务器或代理服务器使用的通信端口。 </li><li>–help 　在线帮助。 </li><li>–httpproxy&lt;主机名称或IP地址&gt; 　指定HTTP代理服务器。 </li><li>–httpport&lt;通信端口&gt; 　设置HTTP服务器或代理服务器使用的通信端口。 </li><li>–ignorearch 　不验证套件档的结构正确性。 </li><li>–ignoreos 　不验证套件档的结构正确性。 </li><li>–ignoresize 　安装前不检查磁盘空间是否足够。 </li><li>–includedocs 　安装套件时，一并安装文件。 </li><li>–initdb 　确认有正确的数据库可以使用。 </li><li>–justdb 　更新数据库，当不变动任何文件。 </li><li>–nobulid 　不执行任何完成阶段。 </li><li>–nodeps 　不验证套件档的相互关联性。 </li><li>–nofiles 　不验证文件的属性。 </li><li>–nogpg 　略过所有GPG的签名认证。 </li><li>–nomd5 　不使用MD5编码演算确认文件的大小与正确性。 </li><li>–nopgp 　略过所有PGP的签名认证。 </li><li>–noorder 　不重新编排套件的安装顺序，以便满足其彼此间的关联性。 </li><li>–noscripts 　不执行任何安装Script文件。 </li><li>–notriggers 　不执行该套件包装内的任何Script文件。 </li><li>–oldpackage 　升级成旧版本的套件。 </li><li>–percent 　安装套件时显示完成度百分比。 </li><li>–pipe&lt;执行指令&gt; 　建立管道，把输出结果转为该执行指令的输入数据。 </li><li>–prefix&lt;目的目录&gt; 　若重新配置文件，就把文件放到指定的目录下。 </li><li>–provides 　查询该套件所提供的兼容度。 </li><li>–queryformat&lt;档头格式&gt; 　设置档头的表示方式。 </li><li>–querytags 　列出可用于档头格式的标签。 </li><li>–rcfile&lt;配置文件&gt; 　使用指定的配置文件。 </li><li>–rebulid&lt;套件档&gt; 　安装原始代码套件，重新产生二进制文件的套件。 </li><li>–rebuliddb 　以现有的数据库为主，重建一份数据库。 </li><li>–recompile&lt;套件档&gt; 　此参数的效果和指定”–rebulid”参数类似，当不产生套件档。 </li><li>–relocate&lt;原目录&gt;=&lt;新目录&gt; 　把本来会放到原目录下的文件改放到新目录。 </li><li>–replacefiles 　强行置换文件。 </li><li>–replacepkgs 　强行置换套件。 </li><li>–requires 　查询该套件所需要的兼容度。 </li><li>–resing&lt;套件档&gt;+ 　删除现有认证，重新产生签名认证。 </li><li>–rmsource 　完成套件的包装后，删除原始代码。 </li><li>–rmsource&lt;文件&gt; 　删除原始代码和指定的文件。 </li><li>–root&lt;根目录&gt; 　设置欲当作根目录的目录。 </li><li>–scripts 　列出安装套件的Script的变量。 </li><li>–setperms 　设置文件的权限。 </li><li>–setugids 　设置文件的拥有者和所属群组。 </li><li>–short-circuit 　直接略过指定完成阶段的步骤。</li><li>–sign 　产生PGP或GPG的签名认证。 </li><li>–target=&lt;安装平台&gt;+ 　设置产生的套件的安装平台。 </li><li>–test 　仅作测试，并不真的安装套件。 </li><li>–timecheck&lt;检查秒数&gt; 　设置检查时间的计时秒数。 </li><li>–triggeredby&lt;套件档&gt; 　查询该套件的包装者。 </li><li>–triggers 　展示套件档内的包装Script。 </li><li>–verify 　此参数的效果和指定”-q”参数相同。 </li><li>–version 　显示版本信息。 </li><li>–whatprovides&lt;功能特性&gt; 　查询该套件对指定的功能特性所提供的兼容度。 </li><li>–whatrequires&lt;功能特性&gt; 　查询该套件对指定的功能特性所需要的兼容度。</li></ul><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>功能说明：设置shell。</p><p>语　　法：<code>set [+-abCdefhHklmnpPtuvx]</code></p><p>补充说明：set指令能设置所使用shell的执行方式，可依照不同的需求来做设置。</p><p>参　　数：</p><ul><li>-a 　标示已修改的变量，以供输出至环境变量。 </li><li>-b 　使被中止的后台程序立刻回报执行状态。 </li><li>-C 　转向所产生的文件无法覆盖已存在的文件。 </li><li>-d 　Shell预设会用杂凑表记忆使用过的指令，以加速指令的执行。使用-d参数可取消。 </li><li>-e 　若指令传回值不等于0，则立即退出shell。　　 </li><li>-f　 　取消使用通配符。 </li><li>-h 　自动记录函数的所在位置。 </li><li>-H Shell 　可利用”!”加&lt;指令编号&gt;的方式来执行history中记录的指令。 </li><li>-k 　指令所给的参数都会被视为此指令的环境变量。 </li><li>-l 　记录for循环的变量名称。 </li><li>-m 　使用监视模式。 </li><li>-n 　只读取指令，而不实际执行。 </li><li>-p 　启动优先顺序模式。 </li><li>-P 　启动-P参数后，执行指令时，会以实际的文件或目录来取代符号连接。 </li><li>-t 　执行完随后的指令，即退出shell。 </li><li>-u 　当执行时使用到未定义过的变量，则显示错误信息。 </li><li>-v 　显示shell所读取的输入值。 </li><li>-x 　执行指令后，会先显示该指令及所下的参数。 </li><li>+&lt;参数&gt; 　取消某个set曾启动的参数。</li></ul><h3 id="setconsole"><a href="#setconsole" class="headerlink" title="setconsole"></a>setconsole</h3><p>功能说明：设置系统终端。</p><p>语　　法：<code>setconsole [video][serial][ttya][ttyb]</code></p><p>补充说明：setconsole可用来指定系统终端。</p><p>参　　数：</p><ul><li>serial 　使用PROM终端。 </li><li>ttya,cua0或ttyS0 　使用第１个串口设备作为终端。 </li><li>ttyb,cua1或ttyS1 　使用第２个串口设备作为终端。 </li><li>video 　使用主机上的现卡作为终端。</li></ul><h3 id="setenv-set-environment-variable"><a href="#setenv-set-environment-variable" class="headerlink" title="setenv(set environment variable)"></a>setenv(set environment variable)</h3><p>功能说明：查询或显示环境变量。</p><p>语　　法：<code>setenv [变量名称][变量值]</code></p><p>补充说明：setenv为tsch中查询或设置环境变量的指令</p><h3 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h3><p>功能说明：设置公用程序。</p><p>语　　法：<code>setup</code></p><p>补充说明：setup是一个设置公用程序，提供图形界面的操作方式。在setup中可设置7类的选项：</p><pre><code>１.登陆认证方式 ２.键盘组态设置 ３.鼠标组态设置 ４.开机时所要启动的系统服务 ５.声卡组态设置 ６.时区设置 ７.X Windows组态设置</code></pre><h3 id="sndconfig"><a href="#sndconfig" class="headerlink" title="sndconfig"></a>sndconfig</h3><p>功能说明：设置声卡。</p><p>语　　法：<code>sndconfig [–help][–noautoconfig][–noprobe]</code></p><p>补充说明：sndconfig为声卡设置程序，支持PnP柚茫勺远觳獠⑸柚肞nP声卡。</p><p>参 　 数：</p><ul><li>–help 　显示帮助。 </li><li>–noautoconfig 　不自动设置PnP的声卡。 </li><li>–noprobe 　不自动检测PnP声卡。</li></ul><h3 id="SVGAText-Mode"><a href="#SVGAText-Mode" class="headerlink" title="SVGAText Mode"></a>SVGAText Mode</h3><p>功能说明：加强文字模式的显示画面。</p><p>语　　法：<code>SVGATextMode [-acdfhmnrsv][-t &lt;配置文件&gt;][模式]</code></p><p>补充说明：SVGATextMode可用来设置文字模式下的显示画面，包括分辨率，字体和更新频率等。</p><p>参　　数：</p><ul><li>-a 　如果新显示模式的屏幕大小与原先不同时，SVGATextMode会执行必要的系统设置。 </li><li>-c 　维持原有的VGA时脉。 </li><li>-d 　执行时会显示详细的信息，供排错时参考。 </li><li>-f 　不要执行配置文件中有关字体载入的指令。 </li><li>-h 　显示帮助。 </li><li>-m 　允许1x1的方式来重设屏幕大小。 </li><li>-n 　仅测试指定的模式。 </li><li>-r 　通知或重设与屏幕大小相关的程序。 </li><li>-s 　显示配置文件中所有可用的模式。 </li><li>-t&lt;配置文件&gt; 　指定配置文件。 </li><li>-v 　SVGATextMode在配置新的显示模式时，预设会先检查垂直与水平的更新更新频率是否在配置文件所指定的范围内，如果不在范围内，则不设置新的显示模式。 </li><li>[模式］ [模式]参数必须是配置文件中模式的名称。</li></ul><h3 id="timeconfig"><a href="#timeconfig" class="headerlink" title="timeconfig"></a>timeconfig</h3><p>功能说明：设置时区。</p><p>语　　法：<code>timeconfig [–arc][–back][–test][–utc][时区名称]</code></p><p>补充说明：这是Red Hat公司遵循GPL规则所开发的程序，它具有互动式操作界面，您可以轻易地利用方向键和空格键等，设置系统时间所属的时区。</p><p>参　　数：</p><ul><li>–arc 　使用Alpha硬件结构的格式存储系统时间。 </li><li>–back 　在互动式界面里，显示Back钮而非Cancel钮。 </li><li>–test 　仅作测试，并不真的改变系统的时区。 </li><li>–utc 　把硬件时钟上的时间视为CUT，有时也称为UTC或UCT。</li></ul><h3 id="ulimit"><a href="#ulimit" class="headerlink" title="ulimit"></a><font color="red">ulimit</font></h3><p>功能说明：控制shell程序的资源。</p><p>语　　法：<code>ulimit [-aHS][-c &lt;core文件上限&gt;][-d &lt;数据节区大小&gt;][-f &lt;文件大小&gt;][-m &lt;内存大小&gt;][-n &lt;文件数目&gt;][-p &lt;缓冲区大小&gt;][-s &lt;堆叠大小&gt;][-t &lt;CPU时间&gt;][-u &lt;程序数目&gt;][-v &lt;虚拟内存大小&gt;]</code></p><p>补充说明：ulimit为shell内建指令，可用来控制shell执行程序的资源。</p><p>参　　数：</p><ul><li>-a 　显示目前资源限制的设定。 </li><li>-c &lt;core文件上限&gt; 　设定core文件的最大值，单位为区块。 </li><li>-d &lt;数据节区大小&gt; 　程序数据节区的最大值，单位为KB。 </li><li>-f &lt;文件大小&gt; 　shell所能建立的最大文件，单位为区块。 </li><li>-H 　设定资源的硬性限制，也就是管理员所设下的限制。 </li><li>-m &lt;内存大小&gt; 　指定可使用内存的上限，单位为KB。 </li><li>-n &lt;文件数目&gt; 　指定同一时间最多可开启的文件数。 </li><li>-p &lt;缓冲区大小&gt; 　指定管道缓冲区的大小，单位512字节。 </li><li>-s &lt;堆叠大小&gt; 　指定堆叠的上限，单位为KB。 </li><li>-S 　设定资源的弹性限制。 </li><li>-t &lt;CPU时间&gt; 　指定CPU使用时间的上限，单位为秒。 </li><li>-u &lt;程序数目&gt; 　用户最多可开启的程序数目。 </li><li>-v &lt;虚拟内存大小&gt; 　指定可使用的虚拟内存上限，单位为KB。</li></ul><h3 id="unalias"><a href="#unalias" class="headerlink" title="unalias"></a>unalias</h3><p>功能说明：删除别名。</p><p>语　　法：<code>unalias [-a][别名]</code></p><p>补充说明：unalias为shell内建指令，可删除别名设置。</p><p>参　　数：</p><ul><li>-a 　删除全部的别名。</li></ul><h3 id="unset"><a href="#unset" class="headerlink" title="unset"></a>unset</h3><p>功能说明：删除变量或函数。</p><p>语　　法：<code>unset [-fv][变量或函数名称]</code></p><p>补充说明：unset为shell内建指令，可删除变量或函数。</p><p>参 　 数：</p><ul><li>-f 　仅删除函数。 </li><li>-v 　仅删除变量。</li></ul><h2 id="linux文档编辑命令"><a href="#linux文档编辑命令" class="headerlink" title="linux文档编辑命令"></a>linux文档编辑命令</h2><h3 id="col"><a href="#col" class="headerlink" title="col"></a>col</h3><p>功能说明：过滤控制字符。</p><p>语　　法：<code>col [-bfx][-l&lt;缓冲区列数&gt;]</code></p><p>补充说明：在许多UNIX说明文件里，都有RLF控制字符。当我们运用shell特殊字符”&gt;”和”&gt;&gt;”，把说明文件的内容输出成纯文本文件时，控制字符会变成乱码，col指令则能有效滤除这些控制字符。</p><p>参　　数：</p><ul><li>-b   过滤掉所有的控制字符，包括RLF和HRLF。</li><li>-f   滤除RLF字符，但允许将HRLF字符呈现出来。</li><li>-x   以多个空格字符来表示跳格字符。</li><li>-l&lt;缓冲区列数&gt;   预设的内存缓冲区有128列，您可以自行指定缓冲区的大小。</li></ul><h3 id="colrm-column-remove"><a href="#colrm-column-remove" class="headerlink" title="colrm(column remove)"></a>colrm(column remove)</h3><p>功能说明：滤掉指定的行。</p><p>语　　法：<code>colrm [开始行数编号&lt;结束行数编号&gt;]</code></p><p>补充说明：colrm指令从标准输入设备读取书记，转而输出到标准输出设备。如果不加任何参数，则该指令不会过滤任何一行。</p><h3 id="comm-common"><a href="#comm-common" class="headerlink" title="comm(common)"></a>comm(common)</h3><p>功能说明：比较两个已排过序的文件。</p><p>语　　法：<code>comm [-123][–help][–version][第1个文件][第2个文件]</code></p><p>补充说明：这项指令会一列列地比较两个已排序文件的差异，并将其结果显示出来，如果没有指定任何参数，则会把结果分成3行显示：第1行仅是在第1个文件中出现过的列，第2行是仅在第2个文件中出现过的列，第3行则是在第1与第2个文件里都出现过的列。若给予的文件名称为”-“，则comm指令会从标准输入设备读取数据。</p><p>参　　数：</p><ul><li>-1   不显示只在第1个文件里出现过的列。</li><li>-2   不显示只在第2个文件里出现过的列。</li><li>-3   不显示只在第1和第2个文件里出现过的列。</li><li>–help   在线帮助。</li><li>–version   显示版本信息。</li></ul><h3 id="csplit-context-split"><a href="#csplit-context-split" class="headerlink" title="csplit(context split)"></a>csplit(context split)</h3><p>功能说明：分割文件。</p><p>语　　法：<code>csplit [-kqsz][-b&lt;输出格式&gt;][-f&lt;输出字首字符串&gt;][-n&lt;输出文件名位数&gt;][–help][–version][文件][范本样式…]</code></p><p>补充说明：将文件依照指定的范本样式予以切割后，分别保存成名称为xx00,xx01,xx02…的文件。若给予的文件名称为”-“，则csplit指令会从标准输入设备读取数据。</p><p>参　　数：</p><ul><li>-b&lt;输出格式&gt;或–suffix-format=&lt;输出格式&gt;   预设的输出格式其文件名称为xx00,xx01…等，您可以通过改变&lt;输出格式&gt;来改变输出的文件名。</li><li>-f&lt;输出字首字符串&gt;或–prefix=&lt;输出字首字符串&gt;   预设的输出字首字符串其文件名为xx00,xx01…等，如果你指定输出字首字符串为”hello”，则输出的文件名称会变成hello00,hello01…等。</li><li>-k或–keep-files   保留文件，就算发生错误或中断执行，也不能删除已经输出保存的文件。</li><li>-n&lt;输出文件名位数&gt;或–digits=&lt;输出文件名位数&gt;   预设的输出文件名位数其文件名称为xx00,xx01…等，如果你指定输出文件名位数为”3”，则输出的文件名称会变成xx000,xx001…等。</li><li>-q或-s或–quiet或–silent   不显示指令执行过程。</li><li>-z或–elide-empty-files   删除长度为0 Byte文件。</li><li>–help   在线帮助。</li><li>–version   显示版本信息。</li></ul><h3 id="ed-editor"><a href="#ed-editor" class="headerlink" title="ed(editor)"></a>ed(editor)</h3><p>功能说明：文本编辑器。</p><p>语　　法：<code>ed [-][-Gs][-p&lt;字符串&gt;][–help][–version][文件]</code></p><p>补充说明：ed是Linux中功能最简单的文本编辑程序，一次仅能编辑一行而非全屏幕方式的操作。</p><p>参　　数：</p><ul><li>-G或–traditional   提供回兼容的功能。</li><li>-p&lt;字符串&gt;   指定ed在command mode的提示字符。</li><li>-s,-,–quiet或–silent   不执行开启文件时的检查功能。</li><li>–help   显示帮助。</li><li>–version   显示版本信息。</li></ul><h3 id="egrep"><a href="#egrep" class="headerlink" title="egrep"></a>egrep</h3><p>功能说明：在文件内查找指定的字符串。egrep执行效果如grep -E，使用的语法及参数可参照grep指令，与grep不同点在于解读字符串的方法，egrep是用extended regular expression语法来解读，而grep则用basic regular expression语法，extended regular expression比basic regular expression有更完整的表达规范。</p><h3 id="ex"><a href="#ex" class="headerlink" title="ex"></a>ex</h3><p>功能说明：在Ex模式下启动vim文本编辑器。ex执行效果如同vi -E，使用语法及参数可参照vi指令，如要从Ex模式回到普通模式，则在vim中输入:vi或:visual即可。</p><h3 id="fgrep-fixed-regexp"><a href="#fgrep-fixed-regexp" class="headerlink" title="fgrep(fixed regexp)"></a>fgrep(fixed regexp)</h3><p>功能说明：查找文件里符合条件的字符串。</p><p>语　　法：<code>fgrep [范本样式][文件或目录…]</code></p><p>补充说明：本指令相当于执行grep指令加上参数”-F”，详见grep指令说明。</p><h3 id="fmt-fromat"><a href="#fmt-fromat" class="headerlink" title="fmt(fromat)"></a>fmt(fromat)</h3><p>功能说明：编排文本文件。</p><p>语　　法：<code>fmt [-cstu][-p&lt;列起始字符串&gt;][-w&lt;每列字符数&gt;][–help][–version][文件…]</code></p><p>补充说明：fmt指令会从指定的文件里读取内容，将其依照指定格式重新编排后，输出到标准输出设备。若指定的文件名为”-“，则fmt指令会从标准输入设备读取数据。</p><p>参　　数：</p><ul><li>-c或–crown-margin   每段前两列缩排。</li><li>-p&lt;列起始字符串&gt;或-prefix=&lt;列起始字符串&gt;   仅合并含有指定字符串的列，通常运用在程序语言的注解方面。</li><li>-s或–split-only   只拆开字数超出每列字符数的列，但不合并字数不足每列字符数的列。</li><li>-t或–tagged-paragraph   每列前两列缩排，但第1列和第2列的缩排格式不同。</li><li>-u或–uniform-spacing   每个字符之间都以一个空格字符间隔，每个句子之间则两个空格字符分隔。</li><li>-w&lt;每列字符数&gt;或–width=&lt;每列字符数&gt;或-&lt;每列字符数&gt;   设置每列的最大字符数。</li><li>–help   在线帮助。</li><li>–version   显示版本信息。</li></ul><h3 id="fold"><a href="#fold" class="headerlink" title="fold"></a>fold</h3><p>功能说明：限制文件列宽。</p><p>语　　法：<code>fold [-bs][-w&lt;每列行数&gt;][–help][–version][文件…]</code></p><p>补充说明：fold指令会从指定的文件里读取内容，将超过限定列宽的列加入增列字符后，输出到标准输出设备。若不指定任何文件名称，或是所给予的文件名为“-”，则fold指令会从标准输入设备读取数据。</p><p>参　　数：</p><ul><li>-b或–bytes   以Byte为单位计算列宽，而非采用行数编号为单位。</li><li>-s或–spaces   以空格字符作为换列点。</li><li>-w&lt;每列行数&gt;或–width&lt;每列行数&gt;   设置每列的最大行数。</li><li>–help   在线帮助。</li><li>–version   显示版本信息。</li></ul><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a><font color="red">grep</font></h3><p>功能说明：查找文件里符合条件的字符串。</p><p>语　　法：<code>grep [-abcEFGhHilLnqrsvVwxy][-A&lt;显示列数&gt;][-B&lt;显示列数&gt;][-C&lt;显示列数&gt;][-d&lt;进行动作&gt;][-e&lt;范本样式&gt;][-f&lt;范本文件&gt;][–help][范本样式][文件或目录…]</code></p><p>补充说明：grep指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设grep指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为“-”，则grep指令会从标准输入设备读取数据。</p><p>参　　数：</p><ul><li>-a或–text   不要忽略二进制的数据。</li><li>-A&lt;显示列数&gt;或–after-context=&lt;显示列数&gt;   除了显示符合范本样式的那一列之外，并显示该列之后的内容。</li><li>-b或–byte-offset   在显示符合范本样式的那一列之前，标示出该列第一个字符的位编号。</li><li>-B&lt;显示列数&gt;或–before-context=&lt;显示列数&gt;   除了显示符合范本样式的那一列之外，并显示该列之前的内容。</li><li>-c或–count   计算符合范本样式的列数。</li><li>-C&lt;显示列数&gt;或–context=&lt;显示列数&gt;或-&lt;显示列数&gt;   除了显示符合范本样式的那一列之外，并显示该列之前后的内容。</li><li>-d&lt;进行动作&gt;或–directories=&lt;进行动作&gt;   当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。</li><li>-e&lt;范本样式&gt;或–regexp=&lt;范本样式&gt;   指定字符串做为查找文件内容的范本样式。</li><li>-E或–extended-regexp   将范本样式为延伸的普通表示法来使用。</li><li>-f&lt;范本文件&gt;或–file=&lt;范本文件&gt;   指定范本文件，其内容含有一个或多个范本样式，让grep查找符合范本条件的文件内容，格式为每列一个范本样式。</li><li>-F或–fixed-regexp   将范本样式视为固定字符串的列表。</li><li>-G或–basic-regexp   将范本样式视为普通的表示法来使用。</li><li>-h或–no-filename   在显示符合范本样式的那一列之前，不标示该列所属的文件名称。</li><li>-H或–with-filename   在显示符合范本样式的那一列之前，表示该列所属的文件名称。</li><li>-i或–ignore-case   忽略字符大小写的差别。</li><li>-l或–file-with-matches   列出文件内容符合指定的范本样式的文件名称。</li><li>-L或–files-without-match   列出文件内容不符合指定的范本样式的文件名称。</li><li>-n或–line-number   在显示符合范本样式的那一列之前，标示出该列的列数编号。</li><li>-q或–quiet或–silent   不显示任何信息。</li><li>-r或–recursive   此参数的效果和指定“-d recurse”参数相同。</li><li>-s或–no-messages   不显示错误信息。</li><li>-v或–revert-match   反转查找。</li><li>-V或–version   显示版本信息。</li><li>-w或–word-regexp   只显示全字符合的列。</li><li>-x或–line-regexp   只显示全列符合的列。</li><li>-y   此参数的效果和指定“-i”参数相同。</li><li>–help   在线帮助。</li></ul><h3 id="ispell-interactive-spelling-checking"><a href="#ispell-interactive-spelling-checking" class="headerlink" title="ispell(interactive spelling checking)"></a>ispell(interactive spelling checking)</h3><p>功能说明：拼字检查程序。</p><p>语　　法：<code>ispell [-aAbBClmMnNPStVx][-d&lt;字典文件&gt;][-L&lt;行数&gt;][-p&lt;字典文件&gt;][-w&lt;非字母字符&gt;][-W&lt;字符串长度&gt;][要检查的文件]</code></p><p>补充说明：ispell预设会使用/usr/lib/ispell/english.hash字典文件来检查文本文件。若在检查的文件中找到字典没有的词汇，ispell会建议使用的词汇，或是让你将新的词汇加入个人字典。</p><p>参　　数：</p><ul><li>-a   当其他程序输出送到ispell时，必须使用此参数。</li><li>-A   读取到”&amp;Include File&amp;”字符串时，就去检查字符串后所指定文件的内容。</li><li>-b   产生备份文件，文件名为.bak。</li><li>-B   检查连字错误。</li><li>-C   不检查连字错误。</li><li>-d&lt;字典文件&gt;   指定字典文件。</li><li>-l   从标准输入设备读取字符串，结束后显示拼错的词汇。</li><li>-L&lt;行数&gt;   指定内文显示的行数。</li><li>-m   自动考虑字尾的变化。</li><li>-M   进入ispell后，在画面下方显示指令的按键。</li><li>-n   检查的文件为noff或troff的格式。</li><li>-N   进入ispell后，在画面下方不显示指令的按键。</li><li>-p&lt;字典文件&gt;   指定个人字典文件。</li><li>-P   不考虑字尾变化的情形。</li><li>-S   不排序建议取代的词汇。</li><li>-t   检查的文件为TeX或LaTeX的格式。</li><li>-V   非ANSI标准的字符会以”M-^”的方式来显示。</li><li>-w&lt;非字母字符&gt;   检查时，特别挑出含有指定的字符。</li><li>-W&lt;字符串长度&gt;   不检查指定长度的词汇。</li><li>-x   不要产生备份文件。</li></ul><h3 id="jed"><a href="#jed" class="headerlink" title="jed"></a>jed</h3><p>功能说明：编辑文本文件。</p><p>语　　法：<code>jed [-2n][-batch][-f&lt;函数&gt;][-g&lt;行数&gt;][-i&lt;文件&gt;][-I&lt;文件&gt;][-s&lt;字符串&gt;][文件]</code></p><p>补充说明：Jed是以Slang所写成的程序，适合用来编辑程序原始代码。</p><p>参　　数：</p><ul><li>-2   显示上下两个编辑区。</li><li>-batch   以批处理模式来执行。</li><li>-f&lt;函数&gt;   执行Slang函数。</li><li>-g&lt;行数&gt;   移到缓冲区中指定的行数。</li><li>-i&lt;文件&gt;   将指定的文件载入缓冲区。</li><li>-i&lt;文件&gt;   载入Slang原始代码文件。</li><li>-n   不要载入jed.rc配置文件。</li><li>-s&lt;字符串&gt;   查找并移到指定的字符串。</li></ul><h3 id="joe"><a href="#joe" class="headerlink" title="joe"></a>joe</h3><p>功能说明：编辑文本文件。</p><p>语　　法：<br><code>joe [-asis][-beep][-csmode][-dopadding][-exask][-force][-help][-keepup][-lightoff][-arking][-mid][-nobackups][-nonotice][-nosta][-noxon][-orphan][-backpath&lt;目录&gt;][-columns&lt;栏位&gt;][-lines&lt;行数&gt;][-pg&lt;行数&gt;][-skiptop&lt;行数&gt;][-autoindent crlf linums overwrite rdonly wordwrap][+&lt;行数&gt;][-indentc&lt;缩排字符&gt;][-istep&lt;缩排字符数&gt;][-keymap&lt;按键配置文件&gt;][-lmargin&lt;栏数&gt;][-rmargin&lt;栏数&gt;][-tab&lt;栏数&gt;][要编辑的文件]</code></p><p>补充说明：Joe是一个功能强大的全屏幕文本编辑程序。操作的复杂度要比Pico高一点，但是功能较为齐全。Joe一次可开启多个文件，每个文件各放在一个编辑区内，并可在文件之间执行剪贴的动作。</p><p>参　　数：</p><p>以下为程序参数</p><ul><li>-asis   字符码超过127的字符不做任何处理。</li><li>-backpath&lt;目录&gt;   指定备份文件的目录。</li><li>-beep   编辑时，若有错误即发出哗声。</li><li>-columns&lt;栏位&gt;   设置栏数。</li><li>-csmode   可执行连续查找模式。</li><li>-dopadding   是程序跟tty间存在缓冲区。</li><li>-exask   在程序中，执行”Ctrl+k+x”时，会先确认是否要保存文件。</li><li>-force   强制在最后一行的结尾处加上换行符号。</li><li>-help   执行程序时一并显示帮助。</li><li>-keepup   在进入程序后，画面上方为状态列。</li><li>-lightoff   选取的区块在执行完区块命令后，就会回复成原来的状态。</li><li>-lines&lt;行数&gt;   设置行数。</li><li>-marking   在选取区块时，反白区块会随着光标移动。</li><li>-mid   当光标移出画面时，即自动卷页，使光标回到中央。</li><li>-nobackups   不建立备份文件。</li><li>-nonotice   程序执行时，不显示版权信息。</li><li>-nosta   程序执行时，不显示状态列。</li><li>-noxon   尝试取消“Ctrl+s”与“Ctrl+q”键的功能。</li><li>-orphan   若同时开启一个以上的文件，则其他文件会置于独立的缓冲区，而不会另外开启编辑区。</li><li>-pg&lt;行数&gt;   按“PageUp”或“PageDown”换页时，所要保留前一页的行数。</li><li>-skiptop&lt;行数&gt;   不使用屏幕上方指定的行数。</li></ul><p>以下为文件参数</p><ul><li>+&lt;行数&gt;   指定开启文件时，光标所在的行数。</li><li>-autoindent   自动缩排。</li><li>-crlf   在换行时，使用CR-LF字符。</li><li>-indentc&lt;缩排字符&gt;   执行缩排时，实际插入的字符。</li><li>-istep&lt;缩排字符数&gt;   每次执行缩排时，所移动的缩排字符数。</li><li>-keymap&lt;按键配置文件&gt;   使用不同的按键配置文件。</li><li>-linums   在每行前面加上行号。</li><li>-lmargin&lt;栏数&gt;   设置左侧边界。</li><li>-overwrite   设置覆盖模式。</li><li>-rmargin&lt;栏数&gt;   设置右侧边界。</li><li>-tab&lt;栏数&gt;   设置tab的宽度。</li><li>-rdonly   以只读的方式开启文件-wordwrap编辑时若超过右侧边界，则自动换行。</li></ul><h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>功能说明：将两个文件中，指定栏位内容相同的行连接起来。</p><p>语　　法：<code>join [-i][-a&lt;1或2&gt;][-e&lt;字符串&gt;][-o&lt;格式&gt;][-t&lt;字符&gt;][-v&lt;1或2&gt;][-1&lt;栏位&gt;][-2&lt;栏位&gt;][–help][–version][文件1][文件2]</code></p><p>补充说明：找出两个文件中，指定栏位内容相同的行，并加以合并，再输出到标准输出设备。</p><p>参　　数：</p><ul><li>-a&lt;1或2&gt;   除了显示原来的输出内容之外，还显示指令文件中没有相同栏位的行。</li><li>-e&lt;字符串&gt;   若[文件1]与[文件2]中找不到指定的栏位，则在输出中填入选项中的字符串。</li><li>-i或–igore-case   比较栏位内容时，忽略大小写的差异。</li><li>-o&lt;格式&gt;   按照指定的格式来显示结果。</li><li>-t&lt;字符&gt;   使用栏位的分隔字符。</li><li>-v&lt;1或2&gt;   跟-a相同，但是只显示文件中没有相同栏位的行。</li><li>-1&lt;栏位&gt;   连接[文件1]指定的栏位。</li><li>-2&lt;栏位&gt;   连接[文件2]指定的栏位。</li><li>–help   显示帮助。</li><li>–version   显示版本信息。</li></ul><h3 id="look"><a href="#look" class="headerlink" title="look"></a>look</h3><p>功能说明：查询单字。</p><p>语　　法：<code>look [-adf][-t&lt;字尾字符串&gt;][字首字符串][字典文件]</code></p><p>补充说明：look指令用于英文单字的查询。您仅需给予它欲查询的字首字符串，它会显示所有开头字符串符合该条件的单字。</p><p>参　　数：</p><ul><li>-a   使用另一个字典文件web2，该文件也位于/usr/dict目录下。</li><li>-d   只对比英文字母和数字，其余一慨忽略不予比对。</li><li>-f   忽略字符大小写差别。</li><li>-t&lt;字尾字符串&gt;   设置字尾字符串。</li></ul><h3 id="mtype"><a href="#mtype" class="headerlink" title="mtype"></a>mtype</h3><p>功能说明：显示MS-DOS文件的内容。</p><p>语　　法：<code>mtype [-st][文件]</code></p><p>补充说明：mtype为mtools工具指令，模拟MS-DOS的type指令，可显示MS-DOS文件的内容。</p><p>参　　数：</p><ul><li>-s   去除8位字符码集的第一个位，使它兼容于7位的ASCII。</li><li>-t   将MS-DOS文本文件中的“换行+光标移至行首”字符转换成Linux的换行字符。</li></ul><h3 id="pico"><a href="#pico" class="headerlink" title="pico"></a>pico</h3><p>功能说明：编辑文字文件。</p><p>语　　法：<code>pico [-bdefghjkmqtvwxz][-n&lt;间隔秒数&gt;][-o&lt;工作目录&gt;][-r&lt;编辑页宽&gt;][-s&lt;拼字检查器&gt;][+&lt;列数编号&gt;][文件]</code></p><p>补充说明：pico是个简单易用、以显示导向为主的文字编辑程序，它伴随着处理电子邮件和新闻组的程序pine而来。</p><p>参　　数：</p><ul><li>-b   开启置换的功能。</li><li>-d   开启删除的功能。</li><li>-e   使用完整的文件名称。</li><li>-f   支持键盘上的F1、F2…等功能键。</li><li>-g   显示光标。</li><li>-h   在线帮助。</li><li>-j   开启切换的功能。</li><li>-k   预设pico在使用剪下命令时，会把光标所在的列的内容全部删除。</li><li>-m   开启鼠标支持的功能，您可用鼠标点选命令列表。</li><li>-n&lt;间隔秒数&gt;   设置多久检查一次新邮件。</li><li>-o&lt;工作目录&gt;   设置工作目录。</li><li>-q   忽略预设值。</li><li>-r&lt;编辑页宽&gt;   设置编辑文件的页宽。</li><li>-s&lt;拼字检查器&gt;   另外指定拼字检查器。</li><li>-t   启动工具模式。</li><li>-v   启动阅读模式，用户只能观看，无法编辑文件的内容。</li><li>-w   关闭自动换行，通过这个参数可以编辑内容很长的列。</li><li>-x   关闭换面下方的命令列表。</li><li>-z   让pico可被Ctrl+z中断，暂存在后台作业里。</li><li>+&lt;列数编号&gt;   执行pico指令进入编辑模式时，从指定的列数开始编辑。</li></ul><h3 id="rgrep-recursive-grep"><a href="#rgrep-recursive-grep" class="headerlink" title="rgrep(recursive grep)"></a>rgrep(recursive grep)</h3><p>功能说明：递归查找文件里符合条件的字符串。</p><p>语　　法：<code>rgrep [-?BcDFhHilnNrv][-R&lt;范本样式&gt;][-W&lt;列长度&gt;][-x&lt;扩展名&gt;][–help][–version][范本样式][文件或目录…]</code></p><p>补充说明：rgrep指令的功能和grep指令类似，可查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设rgrep指令会把含有范本样式的那一列显示出来。</p><p>参　　数：</p><ul><li>-?   显示范本样式与范例的说明。</li><li>-B   忽略二进制的数据。</li><li>-c   计算符合范本样式的列数。</li><li>-D   排错模式，只列出指令搜寻的目录清单，而不会读取文件内容。</li><li>-F   当遇到符号连接时，rgrep预设是忽略不予处理，加上本参数后，rgrep指令就会读取该连接所指向的原始文件的内容。</li><li>-h   特别将符合范本样式的字符串标示出来。</li><li>-H   只列出符合范本样式的字符串，而非显示整列的内容。</li><li>-i   忽略字符大小写的差别。</li><li>-l   列出文件内容符合指定的范本样式的文件名称。</li><li>-n   在显示符合坊本样式的那一列之前，标示出该列的列数编号。</li><li>-N   不要递归处理。</li><li>-r   递归处理，将指定目录下的所有文件及子目录一并处理。</li><li>-R&lt;范本样式&gt;   此参数的效果和指定“-r”参数类似，但只主力符合范本样式文件名称的文件。</li><li>-v   反转查找。</li><li>-W&lt;列长度&gt;   限制符合范本样式的字符串所在列，必须拥有的字符数。</li><li>-x&lt;扩展名&gt;   只处理符合指定扩展名的文件名称的文件。</li><li>–help   在线帮助。</li><li>–version   显示版本信息。</li></ul><h3 id="sed-stream-editor"><a href="#sed-stream-editor" class="headerlink" title="sed(stream editor)"></a>sed(stream editor)</h3><p>功能说明：利用script来处理文本文件。</p><p>语　　法：<code>sed [-hnV][-e &lt;script&gt;][-f&lt;script文件&gt;][文本文件]</code></p><p>补充说明：sed可依照script的指令，来处理、编辑文本文件。</p><p>参　　数：</p><ul><li>-e&lt;script&gt;或–expression=&lt;script&gt;   以选项中指定的script来处理输入的文本文件。</li><li>-f&lt;script文件&gt;或–file=&lt;script文件&gt;  以选项中指定的script文件来处理输入的文本文件。</li><li>-h或–help   显示帮助。</li><li>-n或–quiet或–silent   仅显示script处理后的结果。</li><li>-V或–version   显示版本信息。</li></ul><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>功能说明：将文本文件内容加以排序。</p><p>语　　法：<code>sort [-bcdfimMnr][-o&lt;输出文件&gt;][-t&lt;分隔字符&gt;][+&lt;起始栏位&gt;-&lt;结束栏位&gt;][–help][–verison][文件]</code></p><p>补充说明：sort可针对文本文件的内容，以行为单位来排序。</p><p>参　　数：</p><ul><li>-b   忽略每行前面开始出的空格字符。</li><li>-c   检查文件是否已经按照顺序排序。</li><li>-d   排序时，处理英文字母、数字及空格字符外，忽略其他的字符。</li><li>-f   排序时，将小写字母视为大写字母。</li><li>-i   排序时，除了040至176之间的ASCII字符外，忽略其他的字符。</li><li>-m   将几个排序好的文件进行合并。</li><li>-M   将前面3个字母依照月份的缩写进行排序。</li><li>-n   依照数值的大小排序。</li><li>-o&lt;输出文件&gt;   将排序后的结果存入指定的文件。</li><li>-r   以相反的顺序来排序。</li><li>-t&lt;分隔字符&gt;   指定排序时所用的栏位分隔字符。</li><li>+&lt;起始栏位&gt;-&lt;结束栏位&gt;   以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。</li><li>–help   显示帮助。</li><li>–version   显示版本信息。</li></ul><h3 id="spell"><a href="#spell" class="headerlink" title="spell"></a>spell</h3><p>功能说明：拼字检查程序。</p><p>语　　法：<code>spell</code></p><p>补充说明：spell可从标准输入设备读取字符串，结束后显示拼错的词汇。</p><h3 id="tr-translate-character"><a href="#tr-translate-character" class="headerlink" title="tr(translate character)"></a>tr(translate character)</h3><p>功能说明：转换字符。</p><p>语　　法：<code>tr [-cdst][–help][–version][第一字符集][第二字符集]</code></p><p>补充说明：tr指令从标准输入设备读取数据，经过字符串转译后，输出到标准输出设备。</p><p>参　　数：</p><ul><li>-c或–complerment   取代所有不属于第一字符集的字符。</li><li>-d或–delete   删除所有属于第一字符集的字符。</li><li>-s或–squeeze-repeats   把连续重复的字符以单独一个字符表示。</li><li>-t或–truncate-set1   先删除第一字符集较第二字符集多出的字符。</li><li>–help   在线帮助。</li><li>–version   显示版本信息。</li></ul><h3 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h3><p>功能说明：检查及删除文本文件中重复出现的行列。</p><p>语　　法：<code>uniq [-cdu][-f&lt;栏位&gt;][-s&lt;字符位置&gt;][-w&lt;字符位置&gt;][–help][–version][输入文件][输出文件]</code></p><p>补充说明：uniq可检查文本文件中重复出现的行列。</p><p>参　　数：</p><ul><li>-c或–count   在每列旁边显示该行重复出现的次数。</li><li>-d或–repeated   仅显示重复出现的行列。</li><li>-f&lt;栏位&gt;或–skip-fields=&lt;栏位&gt;   忽略比较指定的栏位。</li><li>-s&lt;字符位置&gt;或–skip-chars=&lt;字符位置&gt;   忽略比较指定的字符。</li><li>-u或–unique   仅显示出一次的行列。</li><li>-w&lt;字符位置&gt;或–check-chars=&lt;字符位置&gt;   指定要比较的字符。</li><li>–help   显示帮助。</li><li>–version   显示版本信息。</li></ul><p>PS:</p><pre><code>[输入文件]   指定已排序好的文本文件。[输出文件]   指定输出的文件。</code></pre><h3 id="wc-word-count"><a href="#wc-word-count" class="headerlink" title="wc(word count)"></a>wc(word count)</h3><p>功能说明：计算字数。</p><p>语　　法：<code>wc [-clw][–help][–version][文件…]</code></p><p>补充说明：利用wc指令我们可以计算文件的Byte数、字数、或是列数，若不指定文件名称、或是所给予的文件名为“-”，则wc指令会从标准输入设备读取数据。</p><p>参　　数：</p><ul><li>-c或–bytes或–chars   只显示Bytes数。</li><li>-l或–lines   只显示列数。</li><li>-w或–words   只显示字数。</li><li>–help   在线帮助。</li><li>–version   显示版本信息。</li></ul><h2 id="linux压缩备份命令"><a href="#linux压缩备份命令" class="headerlink" title="linux压缩备份命令"></a>linux压缩备份命令</h2><h3 id="ar"><a href="#ar" class="headerlink" title="ar"></a>ar</h3><p>功能说明：建立或修改备存文件，或是从备存文件中抽取文件。</p><p>语　　法：<code>ar[-dmpqrtx][cfosSuvV][a&lt;成员文件&gt;][b&lt;成员文件&gt;][i&lt;成员文件&gt;][备存文件][成员文件]</code></p><p>补充说明：ar可让您集合许多文件，成为单一的备存文件。在备存文件中，所有成员文件皆保有原来的属性与权限。</p><p>参　　数：</p><p>　指令参数 </p><ul><li>-d 　删除备存文件中的成员文件。 </li><li>-m 　变更成员文件在备存文件中的次序。 </li><li>-p 　显示备存文件中的成员文件内容。 </li><li>-q 　将问家附加在备存文件末端。 </li><li>-r 　将文件插入备存文件中。 </li><li>-t 　显示备存文件中所包含的文件。 </li><li>-x 　自备存文件中取出成员文件。</li></ul><p>　选项参数 </p><ul><li>a&lt;成员文件&gt; 　将文件插入备存文件中指定的成员文件之后。 </li><li>b&lt;成员文件&gt; 　将文件插入备存文件中指定的成员文件之前。 </li><li>c 　建立备存文件。 </li><li>f 　为避免过长的文件名不兼容于其他系统的ar指令指令，因此可利用此参数，截掉要放入备存文件中过长的成员文件名称。 </li><li>i&lt;成员文件&gt; 　将问家插入备存文件中指定的成员文件之前。 </li><li>o 　保留备存文件中文件的日期。 </li><li>s 　若备存文件中包含了对象模式，可利用此参数建立备存文件的符号表。 </li><li>S 　不产生符号表。 </li><li>u 　只将日期较新文件插入备存文件中。 </li><li>v 　程序执行时显示详细的信息。 </li><li>V 　显示版本信息。</li></ul><h3 id="bunzip2"><a href="#bunzip2" class="headerlink" title="bunzip2"></a>bunzip2</h3><p>功能说明：.bz2文件的解压缩程序。</p><p>语　　法：<code>bunzip2 [-fkLsvV][.bz2压缩文件]</code></p><p>补充说明：bunzip2可解压缩.bz2格式的压缩文件。bunzip2实际上是bzip2的符号连接，执行bunzip2与bzip2 -d的效果相同。</p><p>参　　数：</p><ul><li>-f或–force 　解压缩时，若输出的文件与现有文件同名时，预设不会覆盖现有的文件。若要覆盖，请使用此参数。 </li><li>-k或–keep 　在解压缩后，预设会删除原来的压缩文件。若要保留压缩文件，请使用此参数。 </li><li>-s或–small 　降低程序执行时，内存的使用量。 </li><li>-v或–verbose 　解压缩文件时，显示详细的信息。 </li><li>-l,–license,-V或–version 　显示版本信息。</li></ul><h3 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h3><p>功能说明：.bz2文件的压缩程序。</p><p>语　　法：<code>bzip2 [-cdfhkLstvVz][–repetitive-best][–repetitive-fast][- 压缩等级][要压缩的文件]</code></p><p>补充说明：bzip2采用新的压缩演算法，压缩效果比传统的LZ77/LZ78压缩演算法来得好。若没有加上任何参数，bzip2压缩完文件后会产生.bz2的压缩文件，并删除原始的文件。</p><p>参　　数：</p><ul><li>-c或–stdout 　将压缩与解压缩的结果送到标准输出。 </li><li>-d或–decompress 　执行解压缩。 </li><li>-f或–force 　bzip2在压缩或解压缩时，若输出文件与现有文件同名，预设不会覆盖现有文件。若要覆盖，请使用此参数。 </li><li>-h或–help 　显示帮助。 </li><li>-k或–keep 　bzip2在压缩或解压缩后，会删除原始的文件。若要保留原始文件，请使用此参数。 </li><li>-s或–small 　降低程序执行时内存的使用量。 </li><li>-t或–test 　测试.bz2压缩文件的完整性。 </li><li>-v或–verbose 　压缩或解压缩文件时，显示详细的信息。 </li><li>-z或–compress 　强制执行压缩。 </li><li>-L,–license,</li><li>-V或–version 　显示版本信息。 </li><li>–repetitive-best 　若文件中有重复出现的资料时，可利用此参数提高压缩效果。 </li><li>–repetitive-fast 　若文件中有重复出现的资料时，可利用此参数加快执行速度。 </li><li>-压缩等级 　压缩时的区块大小。</li></ul><h3 id="bzip2recover"><a href="#bzip2recover" class="headerlink" title="bzip2recover"></a>bzip2recover</h3><p>功能说明：用来修复损坏的.bz2文件。</p><p>语　　法：<code>bzip2recover [.bz2 压缩文件]</code></p><p>补充说明：bzip2是以区块的方式来压缩文件，每个区块视为独立的单位。因此，当某一区块损坏时，便可利用bzip2recover，试着将文件中的区块隔开来，以便解压缩正常的区块。通常只适用在压缩文件很大的情况。</p><h3 id="compress"><a href="#compress" class="headerlink" title="compress"></a>compress</h3><p>功能说明：压缩或解压文件。</p><p>语　　法：<code>compress [-cdfrvV][-b &lt;压缩效率&gt;][文件或目录…]</code></p><p>补充说明：compress是个历史悠久的压缩程序，文件经它压缩后，其名称后面会多出”.Z”的扩展名。当要解压缩时，可执行uncompress指令。事实上uncompress是指向compress的符号连接，因此不论是压缩或解压缩，都可通过compress指令单独完成。</p><p>参　　数：</p><ul><li>-b&lt;压缩效率&gt; 　压缩效率是一个介于9－16的数值，预设值为”16”，指定愈大的数值，压缩效率就愈高。 </li><li>-c 　把压缩后的文件输出到标准输出设备，不去更动原始文件。 </li><li>-d 　对文件进行解压缩而非压缩。 </li><li>-f 　强制保存压缩文件，不理会文件名称或硬连接是否存在，该文件是否为符号连接以及压缩效率高低的问题。 </li><li>-r 　递归处理，将指定目录下的所有文件及子目录一并处理。 </li><li>-v 　显示指令执行过程。 </li><li>-V 　显示指令版本及程序预设值。</li></ul><h3 id="cpio-copy-in-out"><a href="#cpio-copy-in-out" class="headerlink" title="cpio(copy in/out)"></a>cpio(copy in/out)</h3><p>功能说明：备份文件。</p><p>语　　法：<code>cpio [-0aABckLovV][-C &lt;输入/输出大小&gt;][-F &lt;备份档&gt;][-H &lt;备份格式&gt;][-O &lt;备份档&gt;][–block-size=&lt;区块大小&gt;][–force-local][–help][–quiet][–version] 或 cpio [-bBcdfikmnrsStuvV][-C &lt;输入/输出大小&gt;][-E &lt;范本文件&gt;][-F &lt;备份档&gt;][-H &lt;备份格式&gt;][-I &lt;备份档&gt;][-M &lt;回传信息&gt;][-R &lt;拥有者&gt;&lt;:/.&gt;&lt;所属群组&gt;][–block-size=&lt;区块大小&gt;][–force-local][–help][–no-absolute-filenames][–no-preserve-owner][–only-verify-crc][–quiet][–sparse][–version][范本样式…] 或 cpio [-0adkiLmpuvV][-R &lt;拥有者&gt;&lt;:/.&gt;&lt;所属群组&gt;][–help][–no-preserve-owner][–quiet][–sparse][–version][目的目]</code></p><p>补充说明：cpio是用来建立，还原备份档的工具程序，它可以加入，解开cpio或tra备份档内的文件。</p><p>参　　数：</p><ul><li>-0或–null 　接受新增列控制字符，通常配合find指令的”-print0”参数使用。 </li><li>-a或–reset-access-time 　重新设置文件的存取时间。 </li><li>-A或–append 　附加到已存在的备份档中，且这个备份档必须存放在磁盘上，而不能放置于磁带机里。 </li><li>-b或–swap 　此参数的效果和同时指定”-sS”参数相同。 </li><li>-B 　将输入/输出的区块大小改成5210 Bytes。 </li><li>-c 　使用旧ASCII备份格式。 </li><li>-C&lt;区块大小&gt;或–io-size=&lt;区块大小&gt; 　设置输入/输出的区块大小，单位是Byte。 </li><li>-d或–make-directories 　如有需要cpio会自行建立目录。 </li><li>-E&lt;范本文件&gt;或–pattern-file=&lt;范本文件&gt; 　指定范本文件，其内含有一个或多个范本样式，让cpio解开符合范本条件的文件，格式为每列一个范本样式。 </li><li>-f或–nonmatching 　让cpio解开所有不符合范本条件的文件。 </li><li>-F&lt;备份档&gt;或–file=&lt;备份档&gt; 　指定备份档的名称，用来取代标准输入或输出，也能借此通过网络使用另一台主机的保存设备存取备份档。 </li><li>-H&lt;备份格式&gt; 　指定备份时欲使用的文件格式。 </li><li>-i或–extract 　执行copy-in模式，还原备份档。 </li><li>-l&lt;备份档&gt; 　指定备份档的名称，用来取代标准输入，也能借此通过网络使用另一台主机的保存设备读取备份档。 </li><li>-k 　此参数将忽略不予处理，仅负责解决cpio不同版本间的兼容性问题。 </li><li>-l或–link 　以硬连接的方式取代复制文件，可在copy-pass模式下运用。 </li><li>-L或–dereference 　不建立符号连接，直接复制该连接所指向的原始文件。 </li><li>-m或preserve-modification-time 　不去更换文件的更改时间。 </li><li>-M&lt;回传信息&gt;或–message=&lt;回传信息&gt; 　设置更换保存媒体的信息。 </li><li>-n或–numeric-uid-gid 　使用”-tv”参数列出备份档的内容时，若再加上参数”-n”，则会以用户识别码和群组识别码替代拥有者和群组名称列出文件清单。 </li><li>-o或–create 　执行copy-out模式，建立备份档。 </li><li>-O&lt;备份档&gt; 　指定备份档的名称，用来取代标准输出，也能借此通过网络　使用另一台主机的保存设备存放备份档。 </li><li>-p或–pass-through 　执行copy-pass模式，略过备份步骤，直接将文件复制到目的目录。 </li><li>-r或–rename 　当有文件名称需要更动时，采用互动模式。 </li><li>-R&lt;拥有者&gt;&lt;:/.&gt;&lt;所属群组&gt;或</li><li>—-owner&lt;拥有者&gt;&lt;:/.&gt;&lt;所属群组&gt; 　在copy-in模式还原备份档，或copy-pass模式复制文件时，可指定这些备份，复制的文件的拥有者与所属群组。 </li><li>-s或–swap-bytes 　交换每对字节的内容。 </li><li>-S或–swap-halfwords 　交换每半个字节的内容。 </li><li>-t或–list 　将输入的内容呈现出来。 </li><li>-u或–unconditional 　置换所有文件，不论日期时间的新旧与否，皆不予询问而直接覆盖。 </li><li>-v或–verbose 　详细显示指令的执行过程。 </li><li>-V或–dot 　执行指令时，在每个文件的执行程序前面加上”.”号 </li><li>–block-size=&lt;区块大小&gt; 　设置输入/输出的区块大小，假如设置数值为5，则区块大小为2500，若设置成10，则区块大小为5120，依次类推。 </li><li>–force-local 　强制将备份档存放在本地主机。 </li><li>–help 　在线帮助。 </li><li>–no-absolute-filenames 　使用相对路径建立文件名称。 </li><li>–no-preserve-owner 　不保留文件的拥有者，谁解开了备份档，那些文件就归谁所有。 </li><li>-only-verify-crc 　当备份档采用CRC备份格式时，可使用这项参数检查备份档内的每个文件是否正确无误。 </li><li>–quiet 　不显示复制了多少区块。 </li><li>–sparse 　倘若一个文件内含大量的连续0字节，则将此文件存成稀疏文件。 </li><li>–version 　显示版本信息。</li></ul><h3 id="dump"><a href="#dump" class="headerlink" title="dump"></a><font color="red">dump</font></h3><p>功能说明：备份文件系统。</p><p>语　　法：<code>dump [-cnu][-0123456789][-b &lt;区块大小&gt;][-B &lt;区块数目&gt;][-d &lt;密度&gt;][-f &lt;设备名称&gt;][-h &lt;层级&gt;][-s &lt;磁带长度&gt;][-T &lt;日期&gt;][目录或文件系统] 或 dump [-wW]</code></p><p>补充说明：dump为备份工具程序，可将目录或整个文件系统备份至指定的设备，或备份成一个大文件。</p><p>参　　数：</p><ul><li>-0123456789 　备份的层级。 </li><li>-b&lt;区块大小&gt; 　指定区块的大小，单位为KB。 </li><li>-B&lt;区块数目&gt; 　指定备份卷册的区块数目。 </li><li>-c 　修改备份磁带预设的密度与容量。 </li><li>-d&lt;密度&gt; 　设置磁带的密度。单位为BPI。 </li><li>-f&lt;设备名称&gt; 　指定备份设备。 </li><li>-h&lt;层级&gt; 　当备份层级等于或大雨指定的层级时，将不备份用户标示为”nodump”的文件。 </li><li>-n 　当备份工作需要管理员介入时，向所有”operator”群组中的使用者发出通知。 </li><li>-s&lt;磁带长度&gt; 　备份磁带的长度，单位为英尺。 </li><li>-T&lt;日期&gt; 　指定开始备份的时间与日期。 </li><li>-u 　备份完毕后，在/etc/dumpdates中记录备份的文件系统，层级，日期与时间等。 </li><li>-w 　与-W类似，但仅显示需要备份的文件。 </li><li>-W 　显示需要备份的文件及其最后一次备份的层级，时间与日期。</li></ul><h3 id="gunzip-gnu-unzip"><a href="#gunzip-gnu-unzip" class="headerlink" title="gunzip(gnu unzip)"></a>gunzip(gnu unzip)</h3><p>功能说明：解压文件。</p><p>语　　法：<code>gunzip [-acfhlLnNqrtvV][-s &lt;压缩字尾字符串&gt;][文件…] 或 gunzip [-acfhlLnNqrtvV][-s &lt;压缩字尾字符串&gt;][目录]</code></p><p>补充说明：gunzip是个使用广泛的解压缩程序，它用于解开被gzip压缩过的文件，这些压缩文件预设最后的扩展名为”.gz”。事实上gunzip就是gzip的硬连接，因此不论是压缩或解压缩，都可通过gzip指令单独完成。</p><p>参　　数：</p><ul><li>-a或–ascii 　使用ASCII文字模式。 </li><li>-c或–stdout或–to-stdout 　把解压后的文件输出到标准输出设备。 </li><li>-f或-force 　强行解开压缩文件，不理会文件名称或硬连接是否存在以及该文件是否为符号连接。 </li><li>-h或–help 　在线帮助。 </li><li>-l或–list 　列出压缩文件的相关信息。 </li><li>-L或–license 　显示版本与版权信息。 </li><li>-n或–no-name 　解压缩时，若压缩文件内含有远来的文件名称及时间戳记，则将其忽略不予处理。 </li><li>-N或–name 　解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其回存到解开的文件上。 </li><li>-q或–quiet 　不显示警告信息。 </li><li>-r或–recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。 </li><li>-S&lt;压缩字尾字符串&gt;或–suffix&lt;压缩字尾字符串&gt; 　更改压缩字尾字符串。 </li><li>-t或–test 　测试压缩文件是否正确无误。 </li><li>-v或–verbose 　显示指令执行过程。 </li><li>-V或–version 显示版本信息。</li></ul><h3 id="gzexe-gzip-executable"><a href="#gzexe-gzip-executable" class="headerlink" title="gzexe(gzip executable)"></a>gzexe(gzip executable)</h3><p>功能说明：压缩执行文件。</p><p>语　　法：<code>gzexe [-d][执行文件…]</code></p><p>补充说明：gzexe是用来压缩执行文件的程序。当您去执行被压缩过的执行文件时，该文件会自动解压然后继续执行，和使用一般的执行文件相同。</p><p>参　　数：</p><ul><li>-d 　解开压缩文件。</li></ul><h3 id="gzip-gnu-zip"><a href="#gzip-gnu-zip" class="headerlink" title="gzip(gnu zip)"></a><font color="red">gzip(gnu zip)</font></h3><p>功能说明：压缩文件。</p><p>语　　法：<code>gzip [-acdfhlLnNqrtvV][-S &lt;压缩字尾字符串&gt;][-&lt;压缩效率&gt;][–best/fast][文件…] 或 gzip [-acdfhlLnNqrtvV][-S &lt;压缩字尾字符串&gt;][-&lt;压缩效率&gt;][–best/fast][目录]</code></p><p>补充说明：gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多出”.gz”的扩展名。</p><p>参　　数：</p><ul><li>-a或–ascii 　使用ASCII文字模式。 </li><li>-c或–stdout或–to-stdout 　把压缩后的文件输出到标准输出设备，不去更动原始文件。 </li><li>-d或–decompress或—-uncompress 　解开压缩文件。 </li><li>-f或–force 　强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接。 </li><li>-h或–help 　在线帮助。 </li><li>-l或–list 　列出压缩文件的相关信息。 </li><li>-L或–license 　显示版本与版权信息。 </li><li>-n或–no-name 　压缩文件时，不保存原来的文件名称及时间戳记。 </li><li>-N或–name 　压缩文件时，保存原来的文件名称及时间戳记。 </li><li>-q或–quiet 　不显示警告信息。 </li><li>-r或–recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。 </li><li>-S&lt;压缩字尾字符串&gt;或—-suffix&lt;压缩字尾字符串&gt; 　更改压缩字尾字符串。 </li><li>-t或–test 　测试压缩文件是否正确无误。 </li><li>-v或–verbose 　显示指令执行过程。 </li><li>-V或–version 　显示版本信息。 </li><li>-&lt;压缩效率&gt; 　压缩效率是一个介于1－9的数值，预设值为”6”，指定愈大的数值，压缩效率就会愈高。 </li><li>–best 　此参数的效果和指定”-9”参数相同。 </li><li>–fast 　此参数的效果和指定”-1”参数相同。</li></ul><h3 id="lha"><a href="#lha" class="headerlink" title="lha"></a>lha</h3><p>功能说明：压缩或解压缩文件。</p><p>语　　法：<br><code>lha [-acdfglmnpqtuvx][-a &lt;0/1/2&gt;/u&lt;/0/1/2&gt;][-&lt;a/c/u&gt;d][-&lt;e/x&gt;i][-&lt;a/u&gt;o][-&lt;e/x&gt;w=&lt;目的目录&gt;][-&lt;a/u&gt;z][压缩文件][文件…] 或 lha [-acdfglmnpqtuvx][-a &lt;0/1/2&gt;/u&lt;/0/1/2&gt;][-&lt;a/c/u&gt;d][-&lt;e/x&gt;i][-&lt;a/u&gt;o][-&lt;e/x&gt;w=&lt;目的目录&gt;][-&lt;a/u&gt;z][压缩文件][目录…]</code></p><p>补充说明：lha是从lharc演变而来的压缩程序，文件经它压缩后，会另外产生具有”.lzh”扩展名的压缩文件。</p><p>参　　数：</p><ul><li>-a或a   压缩文件，并加入到压缩文件内。</li><li>-a&lt;0/1/2&gt;/u&lt;/0/1/2&gt;   压缩文件时，采用不同的文件头。</li><li>-c或c   压缩文件，重新建构新的压缩文件后，再将其加入。</li><li>-d或d   从压缩文件内删除指定的文件。</li><li>-&lt;a/c/u&gt;d或&lt;a/c/u&gt;d   压缩文件，然后将其加入，重新建构，更新压缩文件或，删除原始文件，也就是把文件移到压缩文件中。</li><li>-e或e   解开压缩文件。</li><li>-f或f   强制执行lha命令，在解压时会直接覆盖已有的文件而不加以询问。</li><li>-g或g   使用通用的压缩格式，便于解决兼容性的问题。</li><li>-&lt;e/x&gt;i或&lt;e/x&gt;i   解开压缩文件时，忽略保存在压缩文件内的文件路径，直接将其解压后存放在现行目录下或是指定的目录中。</li><li>-l或l   列出压缩文件的相关信息。</li><li>-m或m   此参数的效果和同时指定”-ad”参数相同。</li><li>-n或n   不执行指令，仅列出实际执行会进行的动作。</li><li>-&lt;a/u&gt;o或&lt;a/u&gt;o   采用lharc兼容格式，将压缩后的文件加入，更新压缩文件。</li><li>-p或p   从压缩文件内输出到标准输出设备。</li><li>-q或q   不显示指令执行过程。</li><li>-t或t   检查备份文件内的每个文件是否正确无误。</li><li>-u或u   更换较新的文件到压缩文件内。</li><li>-u&lt;/0/1/2&gt;或u&lt;/0/1/2&gt;   在文件压缩时采用不同的文件头，然后更新到压缩文件内。</li><li>-v或v   详细列出压缩文件的相关信息。</li><li>-&lt;e/x&gt;w=&lt;目的目录&gt;或&lt;e/x&gt;w=&lt;目的目录&gt;   指定解压缩的目录。</li><li>-x或x   解开压缩文件。</li><li>-&lt;a/u&gt;z或&lt;a/u&gt;z   不压缩文件，直接把它加入，更新压缩文件。</li></ul><h3 id="restore"><a href="#restore" class="headerlink" title="restore"></a>restore</h3><p>功能说明：还原(Restore)由倾倒(Dump)操作所备份下来的文件或整个文件系统(一个分区)。</p><p>语　　法：<code>restore [-cCvy][-b &lt;区块大小&gt;][-D &lt;文件系统&gt;][-f &lt;备份文件&gt;][-s &lt;文件编号&gt;] 或 restore [-chimvy][-b &lt;区块大小&gt;][-f &lt;备份文件&gt;][-s &lt;文件编号&gt;] 或 restore [-crvy][-b &lt;区块大小&gt;][-f &lt;备份文件&gt;][-s &lt;文件编号&gt;] 或 restore [-cRvy][-b &lt;区块大小&gt;][-D &lt;文件系统&gt;][-f &lt;备份文件&gt;][-s &lt;文件编号&gt;] 或 restore [chtvy][-b &lt;区块大小&gt;][-D &lt;文件系统&gt;][-f &lt;备份文件&gt;][-s &lt;文件编号&gt;][文件…] 或 restore [-chmvxy][-b &lt;区块大小&gt;][-D &lt;文件系统&gt;][-f &lt;备份文件&gt;][-s &lt;文件编号&gt;][文件…]</code></p><p>补充说明：restore 指令所进行的操作和dump指令相反，倾倒操作可用来备份文件，而还原操作则是写回这些已备份的文件。</p><p>参　　数：</p><ul><li>-b&lt;区块大小&gt;   设置区块大小，单位是Byte。</li><li>-c   不检查倾倒操作的备份格式，仅准许读取使用旧格式的备份文件。</li><li>-C   使用对比模式，将备份的文件与现行的文件相互对比。</li><li>-D&lt;文件系统&gt;   允许用户指定文件系统的名称。</li><li>-f&lt;备份文件&gt;   从指定的文件中读取备份数据，进行还原操作。</li><li>-h   仅解出目录而不包括与该目录相关的所有文件。</li><li>-i   使用互动模式，在进行还原操作时，restore指令将依序询问用户。</li><li>-m   解开符合指定的inode编号的文件或目录而非采用文件名称指定。</li><li>-r   进行还原操作。</li><li>-R   全面还原文件系统时，检查应从何处开始进行。</li><li>-s&lt;文件编号&gt;   当备份数据超过一卷磁带时，您可以指定备份文件的编号。</li><li>-t   指定文件名称，若该文件已存在备份文件中，则列出它们的名称。</li><li>-v   显示指令执行过程。</li><li>-x   设置文件名称，且从指定的存储媒体里读入它们，若该文件已存在在备份文件中，则将其还原到文件系统内。</li><li>-y   不询问任何问题，一律以同意回答并继续执行指令。</li></ul><h3 id="tar-tape-archive"><a href="#tar-tape-archive" class="headerlink" title="tar(tape archive)"></a><font color="red">tar(tape archive)</font></h3><p>功能说明：备份文件。</p><p>语　　法：<code>tar [-ABcdgGhiklmMoOpPrRsStuUvwWxzZ][-b &lt;区块数目&gt;][-C &lt;目的目录&gt;][-f &lt;备份文件&gt;][-F &lt;Script文件&gt;][-K &lt;文件&gt;][-L &lt;媒体容量&gt;][-N &lt;日期时间&gt;][-T &lt;范本文件&gt;][-V &lt;卷册名称&gt;][-X &lt;范本文件&gt;][-&lt;设备编号&gt;&lt;存储密度&gt;][–after-date=&lt;日期时间&gt;][–atime-preserve][–backuup=&lt;备份方式&gt;][–checkpoint][–concatenate][–confirmation][–delete][–exclude=&lt;范本样式&gt;][–force-local][–group=&lt;群组名称&gt;][–help][–ignore-failed-read][–new-volume-script=&lt;Script文件&gt;][–newer-mtime][–no-recursion][–null][–numeric-owner][–owner=&lt;用户名称&gt;][–posix][–erve][–preserve-order][–preserve-permissions][–record-size=&lt;区块数目&gt;][–recursive-unlink][–remove-files][–rsh-command=&lt;执行指令&gt;][–same-owner][–suffix=&lt;备份字尾字符串&gt;][–totals][–use-compress-program=&lt;执行指令&gt;][–version][–volno-file=&lt;编号文件&gt;][文件或目录…]</code></p><p>补充说明：tar是用来建立，还原备份文件的工具程序，它可以加入，解开备份文件内的文件。</p><p>参　　数：</p><ul><li>-A或–catenate   新增温暖件到已存在的备份文件。</li><li>-b&lt;区块数目&gt;或–blocking-factor=&lt;区块数目&gt;   设置每笔记录的区块数目，每个区块大小为12Bytes。</li><li>-B或–read-full-records   读取数据时重设区块大小。</li><li>-c或–create   建立新的备份文件。</li><li>-C&lt;目的目录&gt;或–directory=&lt;目的目录&gt;   切换到指定的目录。</li><li>-d或–diff或–compare   对比备份文件内和文件系统上的文件的差异。</li><li>-f&lt;备份文件&gt;或–file=&lt;备份文件&gt;   指定备份文件。</li><li>-F&lt;Script文件&gt;或–info-script=&lt;Script文件&gt;   每次更换磁带时，就执行指定的Script文件。</li><li>-g或–listed-incremental   处理GNU格式的大量备份。</li><li>-G或–incremental   处理旧的GNU格式的大量备份。</li><li>-h或–dereference   不建立符号连接，直接复制该连接所指向的原始文件。</li><li>-i或–ignore-zeros   忽略备份文件中的0 Byte区块，也就是EOF。</li><li>-k或–keep-old-files   解开备份文件时，不覆盖已有的文件。</li><li>-K&lt;文件&gt;或–starting-file=&lt;文件&gt;   从指定的文件开始还原。</li><li>-l或–one-file-system   复制的文件或目录存放的文件系统，必须与tar指令执行时所处的文件系统相同，否则不予复制。</li><li>-L&lt;媒体容量&gt;或-tape-length=&lt;媒体容量&gt;   设置存放每体的容量，单位以1024 Bytes计算。</li><li>-m或–modification-time   还原文件时，不变更文件的更改时间。</li><li>-M或–multi-volume   在建立，还原备份文件或列出其中的内容时，采用多卷册模式。</li><li>-N&lt;日期格式&gt;或–newer=&lt;日期时间&gt;   只将较指定日期更新的文件保存到备份文件里。</li><li>-o或–old-archive或–portability   将资料写入备份文件时使用V7格式。</li><li>-O或–stdout   把从备份文件里还原的文件输出到标准输出设备。</li><li>-p或–same-permissions   用原来的文件权限还原文件。</li><li>-P或–absolute-names   文件名使用绝对名称，不移除文件名称前的”/“号。</li><li>-r或–append   新增文件到已存在的备份文件的结尾部分。</li><li>-R或–block-number   列出每个信息在备份文件中的区块编号。</li><li>-s或–same-order   还原文件的顺序和备份文件内的存放顺序相同。</li><li>-S或–sparse   倘若一个文件内含大量的连续0字节，则将此文件存成稀疏文件。</li><li>-t或–list   列出备份文件的内容。</li><li>-T&lt;范本文件&gt;或–files-from=&lt;范本文件&gt;   指定范本文件，其内含有一个或多个范本样式，让tar解开或建立符合设置条件的文件。</li><li>-u或–update   仅置换较备份文件内的文件更新的文件。</li><li>-U或–unlink-first   解开压缩文件还原文件之前，先解除文件的连接。</li><li>-v或–verbose   显示指令执行过程。</li><li>-V&lt;卷册名称&gt;或–label=&lt;卷册名称&gt;   建立使用指定的卷册名称的备份文件。</li><li>-w或–interactive   遭遇问题时先询问用户。</li><li>-W或–verify   写入备份文件后，确认文件正确无误。</li><li>-x或–extract或–get  从备份文件中还原文件。</li><li>-X&lt;范本文件&gt;或–exclude-from=&lt;范本文件&gt;  指定范本文件，其内含有一个或多个范本样式，让ar排除符合设置条件的文件。</li><li>-z或–gzip或–ungzip   通过gzip指令处理备份文件。</li><li>-Z或–compress或–uncompress   通过compress指令处理备份文件。</li><li>-&lt;设备编号&gt;&lt;存储密度&gt;   设置备份用的外围设备编号及存放数据的密度。</li><li>–after-date=&lt;日期时间&gt;   此参数的效果和指定”-N”参数相同。</li><li>–atime-preserve   不变更文件的存取时间。</li><li>–backup=&lt;备份方式&gt;或–backup   移除文件前先进行备份。</li><li>–checkpoint   读取备份文件时列出目录名称。</li><li>–concatenate   此参数的效果和指定”-A”参数相同。</li><li>–confirmation   此参数的效果和指定”-w”参数相同。</li><li>–delete   从备份文件中删除指定的文件。</li><li>–exclude=&lt;范本样式&gt;   排除符合范本样式的问家。</li><li>–group=&lt;群组名称&gt;   把加入设备文件中的文件的所属群组设成指定的群组。</li><li>–help   在线帮助。</li><li>–ignore-failed-read   忽略数据读取错误，不中断程序的执行。</li><li>–new-volume-script=&lt;Script文件&gt;   此参数的效果和指定”-F”参数相同。</li><li>–newer-mtime   只保存更改过的文件。</li><li>–no-recursion   不做递归处理，也就是指定目录下的所有文件及子目录不予处理。</li><li>–null   从null设备读取文件名称。</li><li>–numeric-owner   以用户识别码及群组识别码取代用户名称和群组名称。</li><li>–owner=&lt;用户名称&gt;   把加入备份文件中的文件的拥有者设成指定的用户。</li><li>–posix   将数据写入备份文件时使用POSIX格式。</li><li>–preserve      此参数的效果和指定”-ps”参数相同。</li><li>–preserve-order      此参数的效果和指定”-A”参数相同。</li><li>–preserve-permissions      此参数的效果和指定”-p”参数相同。</li><li>–record-size=&lt;区块数目&gt;      此参数的效果和指定”-b”参数相同。</li><li>–recursive-unlink   解开压缩文件还原目录之前，先解除整个目录下所有文件的连接。</li><li>–remove-files   文件加入备份文件后，就将其删除。</li><li>–rsh-command=&lt;执行指令&gt;   设置要在远端主机上执行的指令，以取代rsh指令。</li><li>–same-owner   尝试以相同的文件拥有者还原问家你。</li><li>–suffix=&lt;备份字尾字符串&gt;   移除文件前先行备份。</li><li>–totals   备份文件建立后，列出文件大小。</li><li>–use-compress-program=&lt;执行指令&gt;   通过指定的指令处理备份文件。</li><li>–version   显示版本信息。</li><li>–volno-file=&lt;编号文件&gt;   使用指定文件内的编号取代预设的卷册编号。</li></ul><h3 id="unarj"><a href="#unarj" class="headerlink" title="unarj"></a>unarj</h3><p>功能说明：解压缩.arj文件。</p><p>语　　法：<code>unarj [eltx][.arj压缩文件]</code></p><p>补充说明：unarj为.arj压缩文件的压缩程序。</p><p>参　　数：</p><ul><li>e   解压缩.arj文件。</li><li>l   显示压缩文件内所包含的文件。</li><li>t   检查压缩文件是否正确。</li><li>x   解压缩时保留原有的路径。</li></ul><h3 id="unzip"><a href="#unzip" class="headerlink" title="unzip"></a><font color="red">unzip</font></h3><p>功能说明：解压缩zip文件</p><p>语　　法：<code>unzip [-cflptuvz][-agCjLMnoqsVX][-P &lt;密码&gt;][.zip文件][文件][-d &lt;目录&gt;][-x &lt;文件&gt;] 或 unzip [-Z]</code></p><p>补充说明：unzip为.zip压缩文件的解压缩程序。</p><p>参　　数：</p><ul><li>-c   将解压缩的结果显示到屏幕上，并对字符做适当的转换。</li><li>-f   更新现有的文件。</li><li>-l   显示压缩文件内所包含的文件。</li><li>-p   与-c参数类似，会将解压缩的结果显示到屏幕上，但不会执行任何的转换。</li><li>-t   检查压缩文件是否正确。</li><li>-u   与-f参数类似，但是除了更新现有的文件外，也会将压缩文件中的其他文件解压缩到目录中。</li><li>-v   执行是时显示详细的信息。</li><li>-z   仅显示压缩文件的备注文字。</li><li>-a   对文本文件进行必要的字符转换。</li><li>-b   不要对文本文件进行字符转换。 </li><li>-C   压缩文件中的文件名称区分大小写。</li><li>-j   不处理压缩文件中原有的目录路径。</li><li>-L   将压缩文件中的全部文件名改为小写。</li><li>-M   将输出结果送到more程序处理。</li><li>-n   解压缩时不要覆盖原有的文件。</li><li>-o   不必先询问用户，unzip执行后覆盖原有文件。</li><li>-P&lt;密码&gt;   使用zip的密码选项。</li><li>-q   执行时不显示任何信息。</li><li>-s   将文件名中的空白字符转换为底线字符。</li><li>-V   保留VMS的文件版本信息。</li><li><p>-X   解压缩时同时回存文件原来的UID/GID。</p><p>  [.zip文件]   指定.zip压缩文件。<br>  [文件]   指定要处理.zip压缩文件中的哪些文件。</p></li><li><p>-d&lt;目录&gt;   指定文件解压缩后所要存储的目录。</p></li><li>-x&lt;文件&gt;   指定不要处理.zip压缩文件中的哪些文件。</li><li>-Z   unzip -Z等于执行zipinfo指令。</li></ul><h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a><font color="red">zip</font></h3><p>功能说明：压缩文件。</p><p>语　　法：<code>zip [-AcdDfFghjJKlLmoqrSTuvVwXyz$][-b &lt;工作目录&gt;][-ll][-n &lt;字尾字符串&gt;][-t &lt;日期时间&gt;][-&lt;压缩效率&gt;][压缩文件][文件…][-i &lt;范本样式&gt;][-x &lt;范本样式&gt;]</code></p><p>补充说明：zip是个使用广泛的压缩程序，文件经它压缩后会另外产生具有”.zip”扩展名的压缩文件。</p><p>参　　数：</p><ul><li>-A   调整可执行的自动解压缩文件。</li><li>-b&lt;工作目录&gt;   指定暂时存放文件的目录。</li><li>-c   替每个被压缩的文件加上注释。</li><li>-d   从压缩文件内删除指定的文件。</li><li>-D   压缩文件内不建立目录名称。</li><li>-f   此参数的效果和指定”-u”参数类似，但不仅更新既有文件，如果某些文件原本不存在于压缩文件内，使用本参数会一并将其加入压缩文件中。</li><li>-F   尝试修复已损坏的压缩文件。</li><li>-g   将文件压缩后附加在既有的压缩文件之后，而非另行建立新的压缩文件。</li><li>-h   在线帮助。</li><li>-i&lt;范本样式&gt;   只压缩符合条件的文件。</li><li>-j   只保存文件名称及其内容，而不存放任何目录名称。</li><li>-J   删除压缩文件前面不必要的数据。</li><li>-k   使用MS-DOS兼容格式的文件名称。</li><li>-l   压缩文件时，把LF字符置换成LF+CR字符。</li><li>-ll   压缩文件时，把LF+CR字符置换成LF字符。</li><li>-L   显示版权信息。</li><li>-m   将文件压缩并加入压缩文件后，删除原始文件，即把文件移到压缩文件中。</li><li>-n&lt;字尾字符串&gt;   不压缩具有特定字尾字符串的文件。</li><li>-o   以压缩文件内拥有最新更改时间的文件为准，将压缩文件的更改时间设成和该文件相同。</li><li>-q   不显示指令执行过程。</li><li>-r   递归处理，将指定目录下的所有文件和子目录一并处理。</li><li>-S   包含系统和隐藏文件。</li><li>-t&lt;日期时间&gt;   把压缩文件的日期设成指定的日期。</li><li>-T   检查备份文件内的每个文件是否正确无误。</li><li>-u   更换较新的文件到压缩文件内。</li><li>-v   显示指令执行过程或显示版本信息。</li><li>-V   保存VMS操作系统的文件属性。</li><li>-w   在文件名称里假如版本编号，本参数仅在VMS操作系统下有效。</li><li>-x&lt;范本样式&gt;   压缩时排除符合条件的文件。</li><li>-X   不保存额外的文件属性。</li><li>-y   直接保存符号连接，而非该连接所指向的文件，本参数仅在UNIX之类的系统下有效。</li><li>-z   替压缩文件加上注释。</li><li>-$   保存第一个被压缩文件所在磁盘的卷册名称。</li><li>-&lt;压缩效率&gt;   压缩效率是一个介于1-9的数值。</li></ul><h3 id="zipinfo"><a href="#zipinfo" class="headerlink" title="zipinfo"></a>zipinfo</h3><p>功能说明：列出压缩文件信息。</p><p>语　　法：<code>zipinfo [-12hlmMstTvz][压缩文件][文件…][-x &lt;范本样式&gt;]</code></p><p>补充说明：执行zipinfo指令可得知zip压缩文件的详细信息。</p><p>参　　数：</p><ul><li>-1   只列出文件名称。</li><li>-2   此参数的效果和指定”-1”参数类似，但可搭配”-h”,”-t”和”-z”参数使用。</li><li>-h   只列出压缩文件的文件名称。</li><li>-l   此参数的效果和指定”-m”参数类似，但会列出原始文件的大小而非每个文件的压缩率。</li><li>-m   此参数的效果和指定”-s”参数类似，但多会列出每个文件的压缩率。</li><li>-M   若信息内容超过一个画面，则采用类似more指令的方式列出信息。</li><li>-s   用类似执行”ls -l”指令的效果列出压缩文件内容。</li><li>-t   只列出压缩文件内所包含的文件数目，压缩前后的文件大小及压缩率。</li><li>-T   将压缩文件内每个文件的日期时间用年，月，日，时，分，秒的顺序列出。</li><li>-v   详细显示压缩文件内每一个文件的信息。</li><li>-x&lt;范本样式&gt;   不列出符合条件的文件的信息。</li><li>-z   如果压缩文件内含有注释，就将注释显示出来。</li></ul><h2 id="linux文件管理命令"><a href="#linux文件管理命令" class="headerlink" title="linux文件管理命令"></a>linux文件管理命令</h2><h3 id="diff-differential"><a href="#diff-differential" class="headerlink" title="diff(differential)"></a>diff(differential)</h3><p>功能说明：比较文件的差异。 </p><p>语　　法：<code>diff [-abBcdefHilnNpPqrstTuvwy][-&lt;行数&gt;][-C &lt;行数&gt;][-D &lt;巨集名称&gt;][-I &lt;字符或字符串&gt;][-S &lt;文件&gt;][-W &lt;宽度&gt;][-x &lt;文件或目录&gt;][-X &lt;文件&gt;][–help][–left-column][–suppress-common-line][文件或目录1][文件或目录2] </code></p><p>补充说明：diff以逐行的方式，比较文本文件的异同处。所是指定要比较目录，则diff会比较目录中相同文件名的文件，但不会比较其中子目录。</p><p>参　　数：</p><ul><li>-&lt;行数&gt; 　指定要显示多少行的文本。此参数必须与-c或-u参数一并使用。 </li><li>-a或–text 　diff预设只会逐行比较文本文件。</li><li>-b或–ignore-space-change 　不检查空格字符的不同。 </li><li>-B或–ignore-blank-lines 　不检查空白行。 </li><li>-c 　显示全部内文，并标出不同之处。 </li><li>-C&lt;行数&gt;或–context&lt;行数&gt; 　与执行”-c-&lt;行数&gt;”指令相同。 </li><li>-d或–minimal 　使用不同的演算法，以较小的单位来做比较。 </li><li>-D&lt;巨集名称&gt;或ifdef&lt;巨集名称&gt; 　此参数的输出格式可用于前置处理器巨集。 </li><li>-e或–ed 　此参数的输出格式可用于ed的script文件。 </li><li>-f或-forward-ed 　输出的格式类似ed的script文件，但按照原来文件的顺序来显示不同处。 </li><li>-H或–speed-large-files 　比较大文件时，可加快速度。 </li><li>-l&lt;字符或字符串&gt;或–ignore-matching-lines&lt;字符或字符串&gt; 　若两个文件在某几行有所不同，而这几行同时都包含了选项中指定的字符或字符串，则不显示这两个文件的差异。 </li><li>-i或–ignore-case 　不检查大小写的不同。 </li><li>-l或–paginate 　将结果交由pr程序来分页。 </li><li>-n或–rcs 　将比较结果以RCS的格式来显示。 </li><li>-N或–new-file 　在比较目录时，若文件A仅出现在某个目录中，预设会显示：</li><li>Only in目录：文件A若使用-N参数，则diff会将文件A与一个空白的文件比较。  </li><li>-p 　若比较的文件为C语言的程序码文件时，显示差异所在的函数名称。 </li><li>-P或–unidirectional-new-file 　与-N类似，但只有当第二个目录包含了一个第一个目录所没有的文件时，才会将这个文件与空白的文件做比较。 </li><li>-q或–brief 　仅显示有无差异，不显示详细的信息。 </li><li>-r或–recursive 　比较子目录中的文件。 </li><li>-s或–report-identical-files 　若没有发现任何差异，仍然显示信息。 </li><li>-S&lt;文件&gt;或–starting-file&lt;文件&gt; 　在比较目录时，从指定的文件开始比较。 </li><li>-t或–expand-tabs 　在输出时，将tab字符展开。 </li><li>-T或–initial-tab 　在每行前面加上tab字符以便对齐。 </li><li>-u,-U&lt;列数&gt;或–unified=&lt;列数&gt; 　以合并的方式来显示文件内容的不同。 </li><li>-v或–version 　显示版本信息。 </li><li>-w或–ignore-all-space 　忽略全部的空格字符。 </li><li>-W&lt;宽度&gt;或–width&lt;宽度&gt; 　在使用-y参数时，指定栏宽。 </li><li>-x&lt;文件名或目录&gt;或–exclude&lt;文件名或目录&gt; 　不比较选项中所指定的文件或目录。 </li><li>-X&lt;文件&gt;或–exclude-from&lt;文件&gt; 　您可以将文件或目录类型存成文本文件，然后在=&lt;文件&gt;中指定此文本文件。 </li><li>-y或–side-by-side 　以并列的方式显示文件的异同之处。 </li><li>–help 　显示帮助。 </li><li>–left-column 　在使用-y参数时，若两个文件某一行内容相同，则仅在左侧的栏位显示该行内容。</li><li>–suppress-common-lines 　在使用-y参数时，仅显示不同之处。</li></ul><h3 id="diffstat-differential-status"><a href="#diffstat-differential-status" class="headerlink" title="diffstat(differential status)"></a>diffstat(differential status)</h3><p>功能说明：根据diff的比较结果，显示统计数字。</p><p>语　　法：<code>diff [-wV][-n &lt;文件名长度&gt;][-p &lt;文件名长度&gt;]</code></p><p>补充说明：diffstat读取diff的输出结果，然后统计各文件的插入，删除，修改等差异计量。</p><p>参　　数：</p><ul><li>-n&lt;文件名长度&gt; 　指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。 </li><li>-p&lt;文件名长度&gt; 　与-n参数相同，但此处的&lt;文件名长度&gt;包括了文件的路径。 </li><li>-w 　指定输出时栏位的宽度。 </li><li>-V 　显示版本信息。</li></ul><h3 id="file"><a href="#file" class="headerlink" title="file"></a>file</h3><p>功能说明：辨识文件类型。 </p><p>语　　法：<code>file [-beLvz][-f &lt;名称文件&gt;][-m &lt;魔法数字文件&gt;…][文件或目录…]  </code></p><p>补充说明：通过file指令，我们得以辨识该文件的类型。 </p><p>参　　数：</p><ul><li>-b 　列出辨识结果时，不显示文件名称。 </li><li>-c 　详细显示指令执行过程，便于排错或分析程序执行的情形。 </li><li>-f&lt;名称文件&gt; 　指定名称文件，其内容有一个或多个文件名称呢感，让file依序辨识这些文件，格式为每列一个文件名称。  </li><li>-L 　直接显示符号连接所指向的文件的类别。 </li><li>-m&lt;魔法数字文件&gt; 　指定魔法数字文件。 </li><li>-v 　显示版本信息。 </li><li>-z 　尝试去解读压缩文件的内容。</li></ul><h3 id="find"><a href="#find" class="headerlink" title="find"></a><font color="red">find</font></h3><p>功能说明：查找文件或目录。</p><p>语　　法：<code>find [目录…][-amin &lt;分钟&gt;][-anewer &lt;参考文件或目录&gt;][-atime &lt;24小时数&gt;][-cmin &lt;分钟&gt;][-cnewer &lt;参考文件或目录&gt;][-ctime &lt;24小时数&gt;][-daystart][-depyh][-empty][-exec &lt;执行指令&gt;][-false][-fls &lt;列表文件&gt;][-follow][-fprint &lt;列表文件&gt;][-fprint0 &lt;列表文件&gt;][-fprintf &lt;列表文件&gt;&lt;输出格式&gt;][-fstype &lt;文件系统类型&gt;][-gid &lt;群组识别码&gt;][-group &lt;群组名称&gt;][-help][-ilname &lt;范本样式&gt;][-iname &lt;范本样式&gt;][-inum &lt;inode编号&gt;][-ipath &lt;范本样式&gt;][-iregex &lt;范本样式&gt;][-links &lt;连接数目&gt;][-lname &lt;范本样式&gt;][-ls][-maxdepth &lt;目录层级&gt;][-mindepth &lt;目录层级&gt;][-mmin &lt;分钟&gt;][-mount]<br>[-mtime &lt;24小时数&gt;][-name &lt;范本样式&gt;][-newer &lt;参考文件或目录&gt;][-nogroup][noleaf] [-nouser][-ok &lt;执行指令&gt;][-path &lt;范本样式&gt;][-perm &lt;权限数值&gt;][-print][-print0][-printf &lt;输出格式&gt;][-prune][-regex &lt;范本样式&gt;][-size &lt;文件大小&gt;][-true][-type &lt;文件类型&gt;][-uid &lt;用户识别码&gt;][-used &lt;日数&gt;][-user &lt;拥有者名称&gt;][-version][-xdev][-xtype &lt;文件类型&gt;]</code></p><p>补充说明：find指令用于查找符合条件的文件。任何位于参数之前的字符串都将被视为欲查找的目录。</p><p>参　　数：</p><ul><li>-amin&lt;分钟&gt; 　查找在指定时间曾被存取过的文件或目录，单位以分钟计算。 </li><li>-anewer&lt;参考文件或目录&gt; 　查找其存取时间较指定文件或目录的存取时间更接近现在的文件或目录。 </li><li>-atime&lt;24小时数&gt; 　查找在指定时间曾被存取过的文件或目录，单位以24小时计算。 </li><li>-cmin&lt;分钟&gt; 　查找在指定时间之时被更改的文件或目录。 </li><li>-cnewer&lt;参考文件或目录&gt; 　查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录。 </li><li>-ctime&lt;24小时数&gt; 　查找在指定时间之时被更改的文件或目录，单位以24小时计算。 </li><li>-daystart 　从本日开始计算时间。 </li><li>-depth 　从指定目录下最深层的子目录开始查找。 </li><li>-expty 　寻找文件大小为0 Byte的文件，或目录下没有任何子目录或文件的空目录。 </li><li>-exec&lt;执行指令&gt; 　假设find指令的回传值为True，就执行该指令。 </li><li>-false 　将find指令的回传值皆设为False。 </li><li>-fls&lt;列表文件&gt; 　此参数的效果和指定”-ls”参数类似，但会把结果保存为指定的列表文件。 </li><li>-follow 　排除符号连接。 </li><li>-fprint&lt;列表文件&gt; 　此参数的效果和指定”-print”参数类似，但会把结果保存成指定的列表文件。 </li><li>-fprint0&lt;列表文件&gt; 　此参数的效果和指定”-print0”参数类似，但会把结果保存成指定的列表文件。 </li><li>-fprintf&lt;列表文件&gt;&lt;输出格式&gt; 　此参数的效果和指定”-printf”参数类似，但会把结果保存成指定的列表文件。 </li><li>-fstype&lt;文件系统类型&gt; 　只寻找该文件系统类型下的文件或目录。 </li><li>-gid&lt;群组识别码&gt; 　查找符合指定之群组识别码的文件或目录。 </li><li>-group&lt;群组名称&gt; 　查找符合指定之群组名称的文件或目录。 </li><li>-help或–help 　在线帮助。 </li><li>-ilname&lt;范本样式&gt; 　此参数的效果和指定”-lname”参数类似，但忽略字符大小写的差别。 </li><li>-iname&lt;范本样式&gt; 　此参数的效果和指定”-name”参数类似，但忽略字符大小写的差别。 </li><li>-inum&lt;inode编号&gt; 　查找符合指定的inode编号的文件或目录。 </li><li>-ipath&lt;范本样式&gt; 　此参数的效果和指定”-ipath”参数类似，但忽略字符大小写的差别。 </li><li>-iregex&lt;范本样式&gt; 　此参数的效果和指定”-regexe”参数类似，但忽略字符大小写的差别。 </li><li>-links&lt;连接数目&gt; 　查找符合指定的硬连接数目的文件或目录。 </li><li>-iname&lt;范本样式&gt; 　指定字符串作为寻找符号连接的范本样式。 </li><li>-ls 　假设find指令的回传值为True，就将文件或目录名称列出到标准输出。 </li><li>-maxdepth&lt;目录层级&gt; 　设置最大目录层级。 </li><li>-mindepth&lt;目录层级&gt; 　设置最小目录层级。 </li><li>-mmin&lt;分钟&gt; 　查找在指定时间曾被更改过的文件或目录，单位以分钟计算。 </li><li>-mount 　此参数的效果和指定”-xdev”相同。 </li><li>-mtime&lt;24小时数&gt; 　查找在指定时间曾被更改过的文件或目录，单位以24小时计算。 </li><li>-name&lt;范本样式&gt; 　指定字符串作为寻找文件或目录的范本样式。 </li><li>-newer&lt;参考文件或目录&gt; 　查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录。 </li><li>-nogroup 　找出不属于本地主机群组识别码的文件或目录。 </li><li>-noleaf 　不去考虑目录至少需拥有两个硬连接存在。 </li><li>-nouser 　找出不属于本地主机用户识别码的文件或目录。 </li><li>-ok&lt;执行指令&gt; 　此参数的效果和指定”-exec”参数类似，但在执行指令之前会先询问用户，若回答”y”或”Y”，则放弃执行指令。 </li><li>-path&lt;范本样式&gt; 　指定字符串作为寻找目录的范本样式。 </li><li>-perm&lt;权限数值&gt; 　查找符合指定的权限数值的文件或目录。 </li><li>-print 　假设find指令的回传值为True，就将文件或目录名称列出到标准输出。格式为每列一个名称，每个名称之前皆有”./“字符串。 </li><li>-print0 　假设find指令的回传值为True，就将文件或目录名称列出到标准输出。格式为全部的名称皆在同一行。 </li><li>-printf&lt;输出格式&gt; 　假设find指令的回传值为True，就将文件或目录名称列出到标准输出。格式可以自行指定。 </li><li>-prune 　不寻找字符串作为寻找文件或目录的范本样式。 </li><li>-regex&lt;范本样式&gt; 　指定字符串作为寻找文件或目录的范本样式。 </li><li>-size&lt;文件大小&gt; 　查找符合指定的文件大小的文件。 </li><li>-true 　将find指令的回传值皆设为True。 </li><li>-typ&lt;文件类型&gt; 　只寻找符合指定的文件类型的文件。 </li><li>-uid&lt;用户识别码&gt; 　查找符合指定的用户识别码的文件或目录。 </li><li>-used&lt;日数&gt; 　查找文件或目录被更改之后在指定时间曾被存取过的文件或目录，单位以日计算。 </li><li>-user&lt;拥有者名称&gt; 　查找符合指定的拥有者名称的文件或目录。 </li><li>-version或–version 　显示版本信息。 </li><li>-xdev 　将范围局限在先行的文件系统中。 </li><li>-xtype&lt;文件类型&gt; 　此参数的效果和指定”-type”参数类似，差别在于它针对符号连接检查。</li></ul><h3 id="git-gnu-interactive-tools"><a href="#git-gnu-interactive-tools" class="headerlink" title="git(gnu interactive tools)"></a>git(gnu interactive tools)</h3><p>功能说明：文字模式下的文件管理员。 </p><p>语　　法：<code>git</code></p><p>补充说明：git是用来管理文件的程序，它十分类似DOS下的Norton Commander，具有互动式操作界面。它的操作方法和Norton Commander几乎一样，略诉如下： </p><pre><code>F1 ：执行info指令，查询指令相关信息，会要求您输入欲查询的名称。 F2 ：执行cat指令，列出文件内容。 F3 ：执行gitview指令，观看文件内容。 F4 ：执行vi指令，编辑文件内容。 F5 ：执行cp指令，复制文件或目录，会要求您输入目标文件或目录。 F6 ：执行mv指令，移动文件或目录，或是更改其名称，会要求您输入目标文件或目录。 F7 ：执行mkdir指令，建立目录。 F8 ：执行rm指令，删除文件或目录。 F9 ：执行make指令，批处理执行指令或编译程序时，会要求您输入相关命令。 F10 ：离开git文件管理员。</code></pre><h3 id="gitview-gnu-interactie-tools-viewer"><a href="#gitview-gnu-interactie-tools-viewer" class="headerlink" title="gitview(gnu interactie tools viewer)"></a>gitview(gnu interactie tools viewer)</h3><p>功能说明：Hex/ASCII的看文件程序。 </p><p>语　　法：<code>gitview [-bchilv][文件] </code></p><p>补充说明：gitview指令可用于观看文件的内容，它会同时显示十六进制和ASCII格式的字码。 </p><p>参　　数：</p><ul><li>-b 　单色模式，不使用ANSI控制码显示彩色。 </li><li>-c 　彩色模式，使用ANSI控制码显示色彩。 </li><li>-h 　在线帮助。 </li><li>-i 　显示存放gitview程序的所在位置。 </li><li>-l 　不使用先前的显示字符。 </li><li>-v 　显示版本信息。</li></ul><h3 id="ln-link"><a href="#ln-link" class="headerlink" title="ln(link)"></a>ln(link)</h3><p>功能说明：连接文件或目录。 </p><p>语　　法：<code>ln [-bdfinsv][-S &lt;字尾备份字符串&gt;][-V &lt;备份方式&gt;][–help][–version][源文件或目录][目标文件或目录] 或 ln [-bdfinsv][-S &lt;字尾备份字符串&gt;][-V &lt;备份方式&gt;][–help][–version][源文件或目录…][目的目录] </code></p><p>补充说明：ln指令用在连接文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则会把前面指定的所有文件或目录复制到该目录中。若同时指定多个文件或目录，且最后的目的地并非是一个已存在的目录，则会出现错误信息。 </p><p>参　　数：</p><ul><li>-b或–backup 　删除，覆盖目标文件之前的备份。 </li><li>-d或-F或–directory 　建立目录的硬连接。 </li><li>-f或–force 　强行建立文件或目录的连接，不论文件或目录是否存在。 </li><li>-i或–interactive 　覆盖既有文件之前先询问用户。 </li><li>-n或–no-dereference 　把符号连接的目的目录视为一般文件。 </li><li>-s或–symbolic 　对源文件建立符号连接，而非硬连接。 </li><li>-S&lt;字尾备份字符串&gt;或–suffix=&lt;字尾备份字符串&gt; 　用”-b”参数备份目标文件后，备份文件的字尾会被加上一个备份字符串，预设的字尾备份字符串是符号”~”，您可通过”-S”参数来改变它。 </li><li>-v或–verbose 　显示指令执行过程。 </li><li>-V&lt;备份方式&gt;或–version-control=&lt;备份方式&gt; 　用”-b”参数备份目标文件后，备份文件的字尾会被加上一个备份字符串，这个字符串不仅可用”-S”参数变更，当使用”-V”参数&lt;备份方式&gt;指定不同备份方式时，也会产生不同字尾的备份字符串。 </li><li>–help 　在线帮助。 </li><li>–version 　显示版本信息。</li></ul><h3 id="locate"><a href="#locate" class="headerlink" title="locate"></a><font color="red">locate</font></h3><p>功能说明：查找文件。 </p><p>语　　法：<code>locate [-d &lt;数据库文件&gt;][–help][–version][范本样式…]</code></p><p>补充说明：locate指令用于查找符合条件的文件，它会去保存文件与目录名称的数据库内，查找合乎范本样式条件的文件或目录。 </p><p>参　　数：</p><ul><li>-d&lt;数据库文件&gt;或–database=&lt;数据库文件&gt;  设置locate指令使用的数据库。locate指令预设的数据库位于/var/lib/slocate目录里，文件名为slocate.db，您可使用这个参数另行指定。 </li><li>–help 　在线帮助。 </li><li>–version 　显示版本信息。</li></ul><h3 id="lsattr-list-attribute"><a href="#lsattr-list-attribute" class="headerlink" title="lsattr(list attribute)"></a>lsattr(list attribute)</h3><p>功能说明：显示文件属性。 </p><p>语　　法：<code>lsattr [-adlRvV][文件或目录…]  </code></p><p>补充说明：用chattr执行改变文件或目录的属性，可执行lsattr指令查询其属性。 </p><p>参　　数：</p><ul><li>-a 　显示所有文件和目录，包括以”.”为名称开头字符的额外内建，现行目录”.”与上层目录”..”。 </li><li>-d 　显示，目录名称，而非其内容。 </li><li>-l 　此参数目前没有任何作用。 </li><li>-R 　递归处理，将指定目录下的所有文件及子目录一并处理。 </li><li>-v 　显示文件或目录版本。 </li><li>-V 　显示版本信息。</li></ul><h3 id="mattrib"><a href="#mattrib" class="headerlink" title="mattrib"></a>mattrib</h3><p>功能说明：变更或显示MS-DOS文件的属性。 </p><p>语　　法：<code>mattrib [+/-][ahrs][-/X][文件] 或 mattrib [-/X][文件] </code></p><p>补充说明：mattrib为mtools工具指令，模拟MS-DOS的attrib指令，可变更MS-DOS文件的属性。 </p><p>参　　数：</p><ul><li>+/- 　“+”代表开启指定的文件属性。”-“代表关闭指定的文件属性。 </li><li>a 　备份属性。使备份程序可用来判断文件是否已经备份过。 </li><li>h 　隐藏属性。 </li><li>r 　只读属性。 </li><li>s 　系统属性。 </li><li>-/ 　列出指定目录及子目录下所有文件的属性。 </li><li>-X 　显示文件属性时，中间不输入空格。</li></ul><h3 id="mc-midnight-commander"><a href="#mc-midnight-commander" class="headerlink" title="mc(midnight commander)"></a>mc(midnight commander)</h3><p>功能说明：提供一个菜单式的文件管理程序。</p><p>语　　法：<code>mc [-abcdfhkPstuUVx][-C &lt;参数&gt;][-l &lt;文件&gt;][-v &lt;文件&gt;][目录] </code></p><p>补充说明：执行mc之后，将会看到菜单式的文件管理程序，共分成４个部分。 </p><p>参　　数：</p><ul><li>-a 　当mc程序画线时不用绘图字符画线。 </li><li>-b 　使用单色模式显示。 </li><li>-c 　使用彩色模式显示。 </li><li>-C&lt;参数&gt; 　指定显示的颜色。 </li><li>-d 　不使用鼠标。 </li><li>-f 　显示mc函数库所在的目录。 </li><li>-h 　显示帮助。 </li><li>-k 　重设softkeys成预设置。 </li><li>-l&lt;文件&gt; 　在指定文件中保存ftpfs对话窗的内容。 </li><li>-P 　程序结束时，列出最后的工作目录。 </li><li>-s 　用慢速的终端机模式显示，在这模式下将减少大量的绘图及文字显示。 </li><li>-t 　使用TEMPCAP变量设置终端机，而不使用预设置。 </li><li>-u 　不用目前的shell程序。 </li><li>-U 　使用目前的shell程序。 </li><li>-v&lt;文件&gt; 　使用mc的内部编辑器来显示指定的文件。 </li><li>-V 　显示版本信息。 </li><li>-x 　指定以xterm模式显示。</li></ul><h3 id="mcopy"><a href="#mcopy" class="headerlink" title="mcopy"></a>mcopy</h3><p>功能说明：复制MS-DOS文件。</p><p>语　　法：<code>mcopy [-bnmpQt/][源文件][目标文件或目录]</code></p><p>补充说明：mcopy为mtools工具指令，可在MS-DOS文件系统中复制文件或是在MS-DOS与Linux的文件系统之间复制文件。mcopy会MS-DOS磁盘驱动器代号出现的位置来判断如何复制文件。</p><p>参　　数：</p><ul><li>-b 　批处理模式。 </li><li>-n 　覆盖其他文件时，不需进行确认而直接覆盖。 </li><li>-m 　将源文件修改时间设为目标文件的修改时间。 </li><li>-p 　将源文件属性设为目标文件的属性。 </li><li>-Q 　复制多个文件时，若发生错误，则立即结束程序。 </li><li>-t 　转换文本文件。 </li><li>-/ 　复制子目录以及其中的所有文件。</li></ul><h3 id="mdel"><a href="#mdel" class="headerlink" title="mdel"></a>mdel</h3><p>功能说明：删除MS-DOS文件。</p><p>语　　法：<code>mdel [文件…]</code></p><p>补充说明：mdel为mtools工具指令，模拟MS-DOS的del指令，可删除MS-DOS文件系统中的文件。</p><h3 id="mdir"><a href="#mdir" class="headerlink" title="mdir"></a>mdir</h3><p>功能说明：显示MS-DOS目录。</p><p>语　　法：<code>mdir [-afwx/][目录]</code></p><p>补充说明：mdir为mtools工具指令，模拟MS-DOS的dir指令，可显示MS-DOS文件系统中的目录内容。</p><p>参　　数：</p><ul><li>-/   显示目录下所有子目录与文件。 </li><li>-a 　显示隐藏文件。 </li><li>-f 　不显示磁盘所剩余的可用空间。 </li><li>-w 　仅显示目录或文件名称，并以横排方式呈现，以便一次能显示较多的目录或文件。 </li><li>-X 　仅显示目录下所有子目录与文件的完整路径，不显示其他信息。</li></ul><h3 id="mktemp"><a href="#mktemp" class="headerlink" title="mktemp"></a>mktemp</h3><p>功能说明：建立暂存文件。</p><p>语　　法：<code>mktemp [-qu][文件名参数]</code></p><p>补充说明：mktemp可建立一个暂存文件，供shell script使用。</p><p>参　　数：</p><ul><li>-q 　执行时若发生错误，不会显示任何信息。 </li><li><p>-u 　暂存文件会在mktemp结束前先行删除。 </p><p>  　[文件名参数] 　文件名参数必须是以”自订名称.XXXXXX”的格式。</p></li></ul><h3 id="mmove"><a href="#mmove" class="headerlink" title="mmove"></a>mmove</h3><p>功能说明：在MS-DOS文件系统中，移动文件或目录，或更改名称。</p><p>语　　法：<code>mmove [源文件或目录…][目标文件或目录]</code></p><p>补充说明：mmove为mtools工具指令，模拟MS-DOS的move指令，可在MS-DOS文件系统中移动现有的文件或目录，或是更改现有文件或目录的名称。</p><h3 id="mread"><a href="#mread" class="headerlink" title="mread"></a>mread</h3><p>功能说明：将MS-DOS文件复制到Linux/Unix的目录中。</p><p>语　　法：<code>mread [MS-DOS文件…][Linux文件或目录]</code></p><p>补充说明：mread为mtools工具指令，可将MS-DOS文件复制到Linux的文件系统中。这个指令目前已经不常用，一般都使用mcopy指令来代替。</p><h3 id="mren"><a href="#mren" class="headerlink" title="mren"></a>mren</h3><p>功能说明：更改MS-DOS文件或目录的名称，或是移动文件或目录。</p><p>语　　法：<code>mren [源文件或目录…][目标文件或目录]</code></p><p>补充说明：mren为MS-DOS工具指令，模拟MS-DOS的ren指令，可更改MS-DOS文件或目录名称。除此之外，ren也可移动文件或目录，但仅限于在同一设备内。</p><h3 id="mshowfat"><a href="#mshowfat" class="headerlink" title="mshowfat"></a>mshowfat</h3><p>功能说明：显示MS-DOS文件在FAT中的记录。</p><p>语　　法：<code>mshowfat [文件…]</code></p><p>补充说明：mshowfat为mtools工具指令，可显示MS-DOS文件在FAT中的记录编号。</p><h3 id="mtools"><a href="#mtools" class="headerlink" title="mtools"></a>mtools</h3><p>功能说明：显示mtools支持的指令。</p><p>语　　法：<code>mtools</code></p><p>补充说明：mtools为MS-DOS文件系统的工具程序，可模拟许多MS-DOS的指令。这些指令都是mtools的符号连接，因此会有一些共同的特性。</p><p>参　　数：</p><ul><li>-a 　长文件名重复时自动更改目标文件的长文件名。 </li><li>-A 　短文件名重复但长文件名不同时自动更改目标文件的短文件名。 </li><li>-o 　长文件名重复时，将目标文件覆盖现有的文件。 </li><li>-O 　短文件名重复但长文件名不同时，将目标文件覆盖现有的文件。 </li><li>-r 　长文件名重复时，要求用户更改目标文件的长文件名。 </li><li>-R 　短文件名重复但长文件名煌保笥没Ц哪勘晡募亩涛募?nbsp;</li><li>-s 　长文件名重复时，则不处理该目标文件。 </li><li>-S 　短文件名重复但长文件名不同时，则不处理该目标文件。 </li><li>-v 　执行时显示详细的说明。 </li><li>-V 　显示版本信息。</li></ul><h3 id="mtoolstest"><a href="#mtoolstest" class="headerlink" title="mtoolstest"></a>mtoolstest</h3><p>功能说明：测试并显示mtools的相关设置。</p><p>语　　法：<code>mtoolstest</code></p><p>补充说明：mtoolstest为mtools工具指令，可读取与分析mtools的配置文件，并在屏幕上显示结果</p><h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a><font color="red">mv</font></h3><p>功能说明：移动或更名现有的文件或目录。</p><p>语　　法：<code>mv [-bfiuv][–help][–version][-S &lt;附加字尾&gt;][-V &lt;方法&gt;][源文件或目录][目标文件或目录]</code></p><p>补充说明：mv可移动文件或目录，或是更改文件或目录的名称。</p><p>参　　数：</p><ul><li>-b或–backup 　若需覆盖文件，则覆盖前先行备份。 </li><li>-f或–force 　若目标文件或目录与现有的文件或目录重复，则直接覆盖现有的文　件或目录。 </li><li>-i或–interactive 　覆盖前先行询问用户。 </li><li>-S&lt;附加字尾&gt;或</li><li>–suffix=&lt;附加字尾&gt; 　与-b参数一并使用，可指定备份文件的所要附加的字尾。 </li><li>-u或–update 　在移动或更改文件名时，若目标文件已存在，且其文件日期比源文件新，则不覆盖目标文件。 </li><li>-v或–verbose 　执行时显示详细的信息。 </li><li>-V=&lt;方法&gt;或</li><li>–version-control=&lt;方法&gt; 　与-b参数一并使用，可指定备份的方法。 </li><li>–help 　显示帮助。 </li><li>–version 　显示版本信息。</li></ul><h3 id="od-octal-dump"><a href="#od-octal-dump" class="headerlink" title="od(octal dump)"></a>od(octal dump)</h3><p>功能说明：输出文件内容。</p><p>语　　法：<code>od [-abcdfhilovx][-A &lt;字码基数&gt;][-j &lt;字符数目&gt;][-N &lt;字符数目&gt;][-s &lt;字符串字符数&gt;][-t &lt;输出格式&gt;][-w &lt;每列字符数&gt;][–help][–version][文件…]</code></p><p>补充说明：od指令会读取所给予的文件的内容，并将其内容以八进制字码呈现出来。</p><p>参　　数：</p><ul><li>-a 　此参数的效果和同时指定”-ta”参数相同。 </li><li>-A&lt;字码基数&gt; 　选择要以何种基数计算字码。 </li><li>-b 　此参数的效果和同时指定”-toC”参数相同。 </li><li>-c 　此参数的效果和同时指定”-tC”参数相同。 </li><li>-d 　此参数的效果和同时指定”-tu2”参数相同。 </li><li>-f 　此参数的效果和同时指定”-tfF”参数相同。 </li><li>-h 　此参数的效果和同时指定”-tx2”参数相同。 </li><li>-i 　此参数的效果和同时指定”-td2”参数相同。 </li><li>-j&lt;字符数目&gt;或–skip-bytes=&lt;字符数目&gt; 　略过设置的字符数目。 </li><li>-l 　此参数的效果和同时指定”-td4”参数相同。 </li><li>-N&lt;字符数目&gt;或–read-bytes=&lt;字符数目&gt; 　到设置的字符数目为止。 </li><li>-o 　此参数的效果和同时指定”-to2”参数相同。 </li><li>-s&lt;字符串字符数&gt;或–strings=&lt;字符串字符数&gt; 　只显示符合指定的字符数目的字符串。 </li><li>-t&lt;输出格式&gt;或–format=&lt;输出格式&gt; 　设置输出格式。 </li><li>-v或–output-duplicates 　输出时不省略重复的数据。 </li><li>-w&lt;每列字符数&gt;或–width=&lt;每列字符数&gt; 　设置每列的最大字符数。 </li><li>-x 　此参数的效果和同时指定”-h”参数相同。 </li><li>–help 　在线帮助。 </li><li>–version 　显示版本信息。</li></ul><h3 id="paste"><a href="#paste" class="headerlink" title="paste"></a>paste</h3><p>功能说明：合并文件的列。</p><p>语　　法：<code>paste [-s][-d &lt;间隔字符&gt;][–help][–version][文件…]</code></p><p>补充说明：paste指令会把每个文件以列对列的方式，一列列地加以合并。</p><p>参　　数：</p><ul><li>-d&lt;间隔字符&gt;或–delimiters=&lt;间隔字符&gt; 　用指定的间隔字符取代跳格字符。 </li><li>-s或–serial 　串列进行而非平行处理。 </li><li>–help 　在线帮助。 </li><li>–version 　显示帮助信息。</li></ul><h3 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h3><p>功能说明：修补文件。</p><p>语　　法：<code>patch [-bceEflnNRstTuvZ][-B &lt;备份字首字符串&gt;][-d &lt;工作目录&gt;][-D &lt;标示符号&gt;][-F &lt;监别列数&gt;][-g &lt;控制数值&gt;][-i &lt;修补文件&gt;][-o &lt;输出文件&gt;][-p &lt;剥离层级&gt;][-r &lt;拒绝文件&gt;][-V &lt;备份方式&gt;][-Y &lt;备份字首字符串&gt;][-z &lt;备份字尾字符串&gt;][–backup-if　　 -mismatch][–binary][–help][–nobackup-if-mismatch][–verbose][原始文件 &lt;修补文件&gt;] 或 path [-p &lt;剥离层级&gt;] &lt; [修补文件]</code></p><p>补充说明：patch指令让用户利用设置修补文件的方式，修改，更新原始文件。倘若一次仅修改一个文件，可直接在指令列中下达指令依序执行。如果配合修补文件的方式则能一次修补大批文件，这也是Linux系统核心的升级方法之一。</p><p>参　　数：</p><ul><li>-b或–backup 　备份每一个原始文件。 </li><li>-B&lt;备份字首字符串&gt;或–prefix=&lt;备份字首字符串&gt; 　设置文件备份时，附加在文件名称前面的字首字符串，该字符串可以是路径名称。 </li><li>-c或–context 　把修补数据解译成关联性的差异。 </li><li>-d&lt;工作目录&gt;或–directory=&lt;工作目录&gt; 　设置工作目录。 </li><li>-D&lt;标示符号&gt;或–ifdef=&lt;标示符号&gt; 　用指定的符号把改变的地方标示出来。 </li><li>-e或–ed 　把修补数据解译成ed指令可用的叙述文件。 </li><li>-E或–remove-empty-files 　若修补过后输出的文件其内容是一片空白，则移除该文件。 </li><li>-f或–force 　此参数的效果和指定”-t”参数类似，但会假设修补数据的版本为新　版本。 </li><li>-F&lt;监别列数&gt;或–fuzz&lt;监别列数&gt; 　设置监别列数的最大值。 </li><li>-g&lt;控制数值&gt;或–get=&lt;控制数值&gt; 　设置以RSC或SCCS控制修补作业。 </li><li>-i&lt;修补文件&gt;或–input=&lt;修补文件&gt; 　读取指定的修补问家你。 </li><li>-l或–ignore-whitespace 　忽略修补数据与输入数据的跳格，空格字符。 </li><li>-n或–normal 　把修补数据解译成一般性的差异。 </li><li>-N或–forward 　忽略修补的数据较原始文件的版本更旧，或该版本的修补数据已使　用过。 </li><li>-o&lt;输出文件&gt;或–output=&lt;输出文件&gt; 　设置输出文件的名称，修补过的文件会以该名称存放。 </li><li>-p&lt;剥离层级&gt;或–strip=&lt;剥离层级&gt; 　设置欲剥离几层路径名称。 </li><li>-f&lt;拒绝文件&gt;或–reject-file=&lt;拒绝文件&gt; 　设置保存拒绝修补相关信息的文件名称，预设的文件名称为.rej。 </li><li>-R或–reverse 　假设修补数据是由新旧文件交换位置而产生。 </li><li>-s或–quiet或–silent 　不显示指令执行过程，除非发生错误。 </li><li>-t或–batch 　自动略过错误，不询问任何问题。 </li><li>-T或–set-time 　此参数的效果和指定”-Z”参数类似，但以本地时间为主。 </li><li>-u或–unified 　把修补数据解译成一致化的差异。 </li><li>-v或–version 　显示版本信息。 </li><li>-V&lt;备份方式&gt;或–version-control=&lt;备份方式&gt; 　用”-b”参数备份目标文件后，备份文件的字尾会被加上一个备份字符串，这个字符串不仅可用”-z”参数变更，当使用”-V”参数指定不同备份方式时，也会产生不同字尾的备份字符串。</li><li>-Y&lt;备份字首字符串&gt;或–basename-prefix=–&lt;备份字首字符串&gt; 　设置文件备份时，附加在文件基本名称开头的字首字符串。</li><li>-z&lt;备份字尾字符串&gt;或–suffix=&lt;备份字尾字符串&gt; 　此参数的效果和指定”-B”参数类似，差别在于修补作业使用的路径与文件名若为src/linux/fs/super.c，加上”backup/“字符串后，文件super.c会备份于/src/linux/fs/backup目录里。 </li><li>-Z或–set-utc 　把修补过的文件更改，存取时间设为UTC。 </li><li>–backup-if-mismatch 　在修补数据不完全吻合，且没有刻意指定要备份文件时，才备份文件。 </li><li>–binary 　以二进制模式读写数据，而不通过标准输出设备。 </li><li>–help 　在线帮助。 </li><li>–nobackup-if-mismatch 　在修补数据不完全吻合，且没有刻意指定要备份文件时，不要备份文件。 </li><li>–verbose 　详细显示指令的执行过程。</li></ul><h3 id="rcp-remote-copy"><a href="#rcp-remote-copy" class="headerlink" title="rcp(remote copy)"></a>rcp(remote copy)</h3><p>功能说明：远端复制文件或目录。</p><p>语　　法：<code>rcp [-pr][源文件或目录][目标文件或目录] 或 rcp [-pr][源文件或目录…][目标文件] </code></p><p>补充说明：rcp指令用在远端复制文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则它灰把前面指定的所有文件或目录复制到该目录中。</p><p>参　　数：</p><ul><li>-p 　保留源文件或目录的属性，包括拥有者，所属群组，权限与时间。 </li><li>-r 　递归处理，将指定目录下的文件与子目录一并处理。</li></ul><h3 id="rhmask"><a href="#rhmask" class="headerlink" title="rhmask"></a>rhmask</h3><p>功能说明：产生与还原加密文件。</p><p>语　　法：<code>rhmask [加密文件][输出文件] 或 rhmask [-d][加密文件][源文件][输出文件]</code></p><p>补充说明：执行rhmask指令可制作加密过的文件，方便用户在公开的网络上传输该文件，而不至于被任意盗用。</p><p>参　　数：</p><ul><li>-d 　产生加密过的文件。</li></ul><h3 id="rm-remove"><a href="#rm-remove" class="headerlink" title="rm(remove)"></a><font color="red">rm(remove)</font></h3><p>功能说明：删除文件或目录。</p><p>语　　法：<code>rm [-dfirv][–help][–version][文件或目录…]</code></p><p>补充说明：执行rm指令可删除文件或目录，如欲删除目录必须加上参数”-r”，否则预设仅会删除文件。 </p><p>参　　数：</p><ul><li>-d或–directory 　直接把欲删除的目录的硬连接数据删成0，删除该目录。 </li><li>-f或–force 　强制删除文件或目录。 </li><li>-i或–interactive 　删除既有文件或目录之前先询问用户。 </li><li>-r或-R或–recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。 </li><li>-v或–verbose 　显示指令执行过程。 </li><li>–help 　在线帮助。 </li><li>–version 　显示版本信息。</li></ul><h3 id="slocate-secure-locate"><a href="#slocate-secure-locate" class="headerlink" title="slocate(secure locate)"></a>slocate(secure locate)</h3><p>功能说明：查找文件或目录。</p><p>语　　法：<code>slocate [-u][–help][–version][-d &lt;目录&gt;][查找的文件]</code></p><p>补充说明：slocate本身具有一个数据库，里面存放了系统中文件与目录的相关信息。</p><p>参　　数：</p><ul><li>-d&lt;目录&gt;或–database=&lt;目录&gt; 　指定数据库所在的目录。 </li><li>-u 　更新slocate数据库。 </li><li>–help 　显示帮助。 </li><li>–version 　显示版本信息。</li></ul><h3 id="split"><a href="#split" class="headerlink" title="split"></a>split</h3><p>功能说明：切割文件。</p><p>语　　法：<code>split [–help][–version][-&lt;行数&gt;][-b &lt;字节&gt;][-C &lt;字节&gt;][-l &lt;行数&gt;][要切割的文件][输出文件名]</code></p><p>补充说明：split可将文件切成较小的文件，预设每1000行会切成一个小文件。</p><p>参　　数：</p><ul><li>-&lt;行数&gt;或-l&lt;行数&gt; 　指定每多少行就要切成一个小文件。 </li><li>-b&lt;字节&gt; 　指定每多少字就要切成一个小文件。 </li><li>-C&lt;字节&gt; 　与-b参数类似，但切割时尽量维持每行的完整性。 </li><li>–help 　显示帮助。 </li><li>–version 　显示版本信息。<br>　<br>  [输出文件名] 　设置切割后文件的前置文件名，split会自动在前置文件名后再加上编号。</li></ul><h3 id="tee"><a href="#tee" class="headerlink" title="tee"></a>tee</h3><p>功能说明：读取标准输入的数据，并将其内容输出成文件。</p><p>语　　法：<code>tee [-ai][–help][–version][文件…]</code></p><p>补充说明：tee指令会从标准输入设备读取数据，将其内容输出到标准输出设备，同时保存成文件。</p><p>参　　数：</p><ul><li>-a或–append 　附加到既有文件的后面，而非覆盖它． </li><li>-i-i或–ignore-interrupts 　忽略中断信号。 </li><li>–help 　在线帮助。 </li><li>–version 　显示版本信息。</li></ul><h3 id="tmpwatch-temporary-watch"><a href="#tmpwatch-temporary-watch" class="headerlink" title="tmpwatch(temporary watch)"></a>tmpwatch(temporary watch)</h3><p>功能说明：删除暂存文件。</p><p>语　　法：<code>tmpwatch [-afqv][–test][超期时间][目录…]</code></p><p>补充说明：执行tmpwatch指令可删除不必要的暂存文件，您可以设置文件超期时间，单位以小时计算。</p><p>参　　数：</p><ul><li>-a或–all 　删除任何类型的文件。 </li><li>-f或–force 　强制删除文件或目录，其效果类似rm指令的”-f”参数。 </li><li>-q或–quiet 　不显示指令执行过程。 </li><li>-v或–verbose 　详细显示指令执行过程。 </li><li>-test 　仅作测试，并不真的删除文件或目录。</li></ul><h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><p>功能说明：改变文件或目录时间。</p><p>语　　法：<code>touch [-acfm][-d &lt;日期时间&gt;][-r &lt;参考文件或目录&gt;][-t &lt;日期时间&gt;][–help]　　 [–version][文件或目录…] 或 touch [-acfm][–help][–version][日期时间][文件或目录…] </code></p><p>补充说明：使用touch指令可更改文件或目录的日期时间，包括存取时间和更改时间。</p><p>参　　数：</p><ul><li>-a或–time=atime或–time=access或–time=use 　只更改存取时间。 </li><li>-c或–no-create 　不建立任何文件。 </li><li>-d&lt;时间日期&gt; 　使用指定的日期时间，而非现在的时间。 </li><li>-f 　此参数将忽略不予处理，仅负责解决BSD版本touch指令的兼容性问题。 </li><li>-m或–time=mtime或–time=modify 　只更改变动时间。 </li><li>-r&lt;参考文件或目录&gt; 　把指定文件或目录的日期时间，统统设成和参考文件或目录的日期时间相同。 </li><li>-t&lt;日期时间&gt; 　使用指定的日期时间，而非现在的时间。 </li><li>–help 　在线帮助。 </li><li>–version 　显示版本信息。</li></ul><h3 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h3><p>功能说明：指定在建立文件时预设的权限掩码。</p><p>语　　法：<code>umask [-S][权限掩码]</code></p><p>补充说明：umask可用来设定[权限掩码]。[权限掩码]是由3个八进制的数字所组成，将现有的存取权限减掉权限掩码后，即可产生建立文件时预设的权限。</p><p>参　　数：</p><ul><li>-S 　以文字的方式来表示权限掩码。</li></ul><h3 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h3><p>功能说明：查找文件。</p><p>语　　法：<code>whereis [-bfmsu][-B &lt;目录&gt;…][-M &lt;目录&gt;…][-S &lt;目录&gt;…][文件…]</code></p><p>补充说明：whereis指令会在特定目录中查找符合条件的文件。这些文件的烈性应属于原始代码，二进制文件，或是帮助文件。</p><p>参　　数：</p><ul><li>-b 　只查找二进制文件。 </li><li>-B&lt;目录&gt; 　只在设置的目录下查找二进制文件。 </li><li>-f 　不显示文件名前的路径名称。 </li><li>-m 　只查找说明文件。 </li><li>-M&lt;目录&gt; 　只在设置的目录下查找说明文件。 </li><li>-s 　只查找原始代码文件。 </li><li>-S&lt;目录&gt; 　只在设置的目录下查找原始代码文件。 </li><li>-u 　查找不包含指定类型的文件。</li></ul><h3 id="which"><a href="#which" class="headerlink" title="which"></a>which</h3><p>功能说明：查找文件。</p><p>语　　法：<code>which [文件…]</code></p><p>补充说明：which指令会在环境变量$PATH设置的目录里查找符合条件的文件。</p><p>参　　数：</p><ul><li>-n&lt;文件名长度&gt; 　指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。 </li><li>-p&lt;文件名长度&gt; 　与-n参数相同，但此处的&lt;文件名长度&gt;包括了文件的路径。 </li><li>-w 　指定输出时栏位的宽度。 </li><li>-V 　显示版本信息。</li></ul><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a><font color="red">cat</font></h3><p>使用权限：所有使用者 </p><p>使用方式：<code>cat [-AbeEnstTuv] [–help] [–version] fileName </code></p><p>说明：把档案串连接后传到基本输出（萤幕或加 &gt; fileName 到另一个档案）</p><p>参数：</p><ul><li>-n 或 –number 由 1 开始对所有输出的行数编号</li><li>-b 或 –number-nonblank 和 -n 相似，只不过对于空白行不编号</li><li>-s 或 –squeeze-blank 当遇到有连续两行以上的空白行，就代换为一行的空白行</li><li>-v 或 –show-nonprinting</li></ul><p>范例：</p><pre><code>cat -n textfile1 &amp;gt; textfile2 把 textfile1 的档案内容加上行号后输入 textfile2 这个档案里cat -b textfile1 textfile2 &amp;gt;&amp;gt; textfile3 把 textfile1 和 textfile2 的档案内容加上行号（空白行不加）之后将内容附加到 textfile3 里。</code></pre><h3 id="chattr-change-attribute"><a href="#chattr-change-attribute" class="headerlink" title="chattr(change attribute)"></a>chattr(change attribute)</h3><p>功能说明：改变文件属性。</p><p>语　　法：<code>chattr [-RV][-v&lt;版本编号&gt;][+/-/=&lt;属性&gt;][文件或目录…]</code></p><p>补充说明：这项指令可改变存放在ext2文件系统上的文件或目录属性，这些属性共有以下8种模式： </p><pre><code>　a：让文件或目录仅供附加用途。 　b：不更新文件或目录的最后存取时间。 　c：将文件或目录压缩后存放。 　d：将文件或目录排除在倾倒操作之外。 　i：不得任意更动文件或目录。 　s：保密性删除文件或目录。 　S：即时更新文件或目录。 　u：预防以外删除。 </code></pre><p>参　　数：</p><ul><li>-R  递归处理，将指定目录下的所有文件及子目录一并处理。 </li><li>-v&lt;版本编号&gt;  设置文件或目录版本。 </li><li>-V  显示指令执行过程。 </li><li>+&lt;属性&gt;  开启文件或目录的该项属性。 </li><li>-&lt;属性&gt;  关闭文件或目录的该项属性。 </li><li>=&lt;属性&gt;  指定文件或目录的该项属性。</li></ul><h3 id="chgrp-change-group"><a href="#chgrp-change-group" class="headerlink" title="chgrp(change group)"></a>chgrp(change group)</h3><p>功能说明：变更文件或目录的所属群组。</p><p>语　　法：<code>chgrp [-cfhRv][–help][–version][所属群组][文件或目录…] 或 chgrp [-cfhRv][–help][–reference=&lt;参考文件或目录&gt;][–version][文件或目录…] </code></p><p>补充说明：在UNIX系统家族里，文件或目录权限的掌控以拥有者及所属群组来管理。您可以使用chgrp指令去变更文件与目录的所属群组，设置方式采用群组名称或群组识别码皆可。 </p><p>参　　数：</p><ul><li>-c或–changes  效果类似”-v”参数，但仅回报更改的部分。 </li><li>-f或–quiet或–silent 　不显示错误信息。 </li><li>-h或–no-dereference 　只对符号连接的文件作修改，而不更动其他任何相关文件。 </li><li>-R或–recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。 </li><li>-v或–verbose 　显示指令执行过程。 </li><li>–help 　在线帮助。 </li><li>–reference=&lt;参考文件或目录&gt; 　把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同。 </li><li>–version 　显示版本信息。</li></ul><h3 id="chmod-change-mode"><a href="#chmod-change-mode" class="headerlink" title="chmod(change mode)"></a><font color="red">chmod(change mode)</font></h3><p>功能说明：变更文件或目录的权限。</p><p>语　　法：<code>chmod [-cfRv][–help][–version][&lt;权限范围&gt;+/-/=&lt;权限设置…&gt;][文件或目录…] 或 chmod [-cfRv][–help][–version][数字代号][文件或目录…] 或 chmod [-cfRv][–help][–reference=&lt;参考文件或目录&gt;][–version][文件或目录…] </code></p><p>补充说明：在UNIX系统家族里，文件或目录权限的控制分别以读取，写入，执行3种一般权限来区分，另有3种特殊权限可供运用，再搭配拥有者与所属群组管理权限范围。您可以使用chmod指令去变更文件与目录的权限，设置方式采用文字或数字代号皆可。符号连接的权限无法变更，如果您对符号连接修改权限，其改变会作用在被连接的原始文件。权限范围的表示法如下： </p><pre><code>　u：User，即文件或目录的拥有者。 　g：Group，即文件或目录的所属群组。 　o：Other，除了文件或目录拥有者或所属群组之外，其他用户皆属于这个范围。 　a：All，即全部的用户，包含拥有者，所属群组以及其他用户。  　有关权限代号的部分，列表于下： 　r：读取权限，数字代号为&quot;4&quot;。 　w：写入权限，数字代号为&quot;2&quot;。 　x：执行或切换权限，数字代号为&quot;1&quot;。 　-：不具任何权限，数字代号为&quot;0&quot;。 　s：特殊?b&amp;gt;功能说明：变更文件或目录的权限。</code></pre><p>参　　数：</p><ul><li>-c或–changes 　效果类似”-v”参数，但仅回报更改的部分。 </li><li>-f或–quiet或–silent 　不显示错误信息。 </li><li>-R或–recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。 </li><li>-v或–verbose 　显示指令执行过程。 </li><li>–help 　在线帮助。 </li><li>–reference=&lt;参考文件或目录&gt; 　把指定文件或目录的权限全部设成和参考文件或目录的权限相同 </li><li><p>–version 　显示版本信息。 </p><p>  　&lt;权限范围&gt;+&lt;权限设置&gt; 　开启权限范围的文件或目录的该项权限设置。<br>  　&lt;权限范围&gt;-&lt;权限设置&gt; 　关闭权限范围的文件或目录的该项权限设置。<br>  　&lt;权限范围&gt;=&lt;权限设置&gt; 　指定权限范围的文件或目录的该项权限设置。<br>   如chmod a+x …</p></li></ul><h3 id="chown-change-owner"><a href="#chown-change-owner" class="headerlink" title="chown(change owner)"></a><font color="red">chown(change owner)</font></h3><p>功能说明：变更文件或目录的拥有者或所属群组。</p><p>语　　法：<code>chown [-cfhRv][–dereference][–help][–version][拥有者.&lt;所属群组&gt;][文件或目录..] 或chown [-chfRv][–dereference][–help][–version][.所属群组][文件或目录… …] 或chown [-cfhRv][–dereference][–help][–reference=&lt;参考文件或目录&gt;][–version][文件或目录…] </code></p><p>补充说明：在UNIX系统家族里，文件或目录权限的掌控以拥有者及所属群组来管理。您可以使用chown指令去变更文件与目录的拥有者或所属群组，设置方式采用用户名称或用户识别码皆可，设置群组则用群组名称或群组识别码。 </p><p>参　　数：</p><ul><li>-c或–changes 　效果类似”-v”参数，但仅回报更改的部分。 </li><li>-f或–quite或–silent 　不显示错误信息。 </li><li>-h或–no-dereference 　之对符号连接的文件作修改，而不更动其他任何相关文件。 </li><li>-R或–recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。 </li><li>-v或–version 　显示指令执行过程。 </li><li>–dereference 　效果和”-h”参数相同。 </li><li>–help 　在线帮助。 </li><li>–reference=&lt;参考文件或目录&gt; 　把指定文件或目录的拥有者与所属群组全部设成和参考文件或目　录的拥有者与所属群组相同。 </li><li>–version 　显示版本信息。</li></ul><h3 id="cksum-check-sum"><a href="#cksum-check-sum" class="headerlink" title="cksum(check sum)"></a>cksum(check sum)</h3><p>功能说明：检查文件的CRC是否正确。 </p><p>语　　法：<code>cksum [–help][–version][文件…] </code> </p><p>补充说明：CRC是一种排错检查方式，该演算法的标准由CCITT所指定，至少可检测到99.998%的已知错误。指定文件交由cksum演算，它会回报计算结果，供用户核对文件是否正确无误。若不指定任何文件名称或是所给予的文件名为”-“，则cksum指令会从标准输入设备读取数据。 </p><p>参　　数：</p><ul><li>–help 　在线帮助。 </li><li>–version 　显示版本信息。</li></ul><h3 id="cmp-compare"><a href="#cmp-compare" class="headerlink" title="cmp(compare)"></a>cmp(compare)</h3><p>功能说明：比较两个文件是否有差异。</p><p>语　　法：<code>cmp [-clsv][-i &lt;字符数目&gt;][–help][第一个文件][第二个文件]</code></p><p>补充说明：当相互比较的两个文件完全一样时，则该指令不会显示任何信息。若发现有所差异，预设会标示出第一个不同之处的字符和列数编号。若不指定任何文件名称或是所给予的文件名为”-“，则cmp指令会从标准输入设备读取数据。</p><p>参　　数：</p><ul><li>-c或–print-chars 　除了标明差异处的十进制字码之外，一并显示该字符所对应字符。 </li><li>-i&lt;字符数目&gt;或–ignore-initial=&lt;字符数目&gt; 　指定一个数目。 </li><li>-l或–verbose 　标示出所有不一样的地方。 </li><li>-s或–quiet或–silent 　不显示错误信息。 </li><li>-v或–version 　显示版本信息。 </li><li>–help 　在线帮助。</li></ul><h3 id="cp-copy"><a href="#cp-copy" class="headerlink" title="cp(copy)"></a><font color="red">cp(copy)</font></h3><p>功能说明：复制文件或目录。 </p><p>语　　法：<code>cp [-abdfilpPrRsuvx][-S &lt;备份字尾字符串&gt;][-V &lt;备份方式&gt;][–help][–spares=&lt;使用时机&gt;][–version][源文件或目录][目标文件或目录] [目的目录] </code></p><p>补充说明：cp指令用在复制文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则它会把前面指定的所有文件或目录复制到该目录中。若同时指定多个文件或目录，而最后的目的地并非是一个已存在的目录，则会出现错误信息。</p><p>参　　数：</p><ul><li>-a或–archive 　此参数的效果和同时指定”-dpR”参数相同。 </li><li>-b或–backup 　删除，覆盖目标文件之前的备份，备份文件会在字尾加上一个备份字符串。 </li><li>-d或–no-dereference 　当复制符号连接时，把目标文件或目录也建立为符号连接，并指向与源文件或目录连接的原始文件或目录。 </li><li>-f或–force 　强行复制文件或目录，不论目标文件或目录是否已存在。 </li><li>-i或–interactive 　覆盖既有文件之前先询问用户。 </li><li>-l或–link 　对源文件建立硬连接，而非复制文件。 </li><li>-p或–preserve 　保留源文件或目录的属性。 </li><li>-P或–parents 　保留源文件或目录的路径。 </li><li>-r 　递归处理，将指定目录下的文件与子目录一并处理。 </li><li>-R或–recursive 　递归处理，将指定目录下的所有文件与子目录一并处理。 </li><li>-s或–symbolic-link 　对源文件建立符号连接，而非复制文件。 </li><li>-S&lt;备份字尾字符串&gt;或–suffix=&lt;备份字尾字符串&gt; 　用”-b”参数备份目标文件后，备份文件的字尾会被加上一个备份字符串，预设的备份字尾字符串是符号”~”。 </li><li>-u或–update 　使用这项参数后只会在源文件的更改时间较目标文件更新时或是　名称相互对应的目标文件并不存在，才复制文件。 </li><li>-v或–verbose 　显示指令执行过程。 </li><li>-V&lt;备份方式&gt;或–version-control=&lt;备份方式&gt; 　用”-b”参数备份目标文件后，备份文件的字尾会被加上一个备份字符串，这字符串不仅可用”-S”参数变更，当使用”-V”参数指定不同备份方式时，也会产生不同字尾的备份字串。  </li><li>-x或–one-file-system 　复制的文件或目录存放的文件系统，必须与cp指令执行时所处的文件系统相同，否则不予复制。 </li><li>–help 　在线帮助。 </li><li>–sparse=&lt;使用时机&gt; 　设置保存稀疏文件的时机。 </li><li>–version 　显示版本信息。</li></ul><h3 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h3><p>使用权限：所有使用者</p><p>用法：<code>cut -cnum1-num2 filename</code></p><p>说明：显示每行从开头算起 num1 到 num2 的文字。</p><p>范例：</p><pre><code>shell&amp;gt;&amp;gt; cat exampletest2this is test1shell&amp;gt;&amp;gt; cut -c0-6 example       ## print 开头算起前 6 个字元test2this i </code></pre><h3 id="indent"><a href="#indent" class="headerlink" title="indent"></a>indent</h3><p>功能说明：调整C原始代码文件的格式。</p><p>语　　法：<code>indent [参数][源文件] 或 indent [参数][源文件][-o 目标文件]</code></p><p>补充说明：indent可辨识C的原始代码文件，并加以格式化，以方便程序设计师阅读。 </p><p>参　　数：</p><ul><li>-bad或–blank-lines-after-declarations  　在声明区段或加上空白行。 </li><li>-bap或–blank-lines-after-procedures 　在程序或加上空白行。 </li><li>-bbb或–blank-lines-after-block-comments 　在注释区段后加上空白行。 </li><li>-bc或–blank-lines-after-commas  　在声明区段中，若出现逗号即换行。 </li><li>-bl或–braces-after-if-line 　if(或是else,for等等)与后面执行区段的”{“不同行，且”}”自成一行。 </li><li>-bli&lt;缩排格数&gt;或–brace-indent&lt;缩排格数&gt; 　设置{ }缩排的格数。 </li><li>-br或–braces-on-if-line 　if(或是else,for等等)与后面执行跛段的”{“不同行，且”}”自成一行。 </li><li>-bs或–blank-before-sizeof 　在sizeof之后空一格。 </li><li>-c&lt;栏数&gt;或–comment-indentation&lt;栏数&gt; 　将注释置于程序码右侧指定的栏位。 </li><li>-cd&lt;栏数&gt;或–declaration-comment-column&lt;栏数&gt; 　将注释置于声明右侧指定的栏位。 </li><li>-cdb或–comment-delimiters-on-blank-lines 　注释符号自成一行。 </li><li>-ce或–cuddle-else 　将else置于”}”(if执行区段的结尾)之后。 </li><li>-ci&lt;缩排格数&gt;或–continuation-indentation&lt;缩排格数&gt; 　叙述过长而换行时，指定换行后缩排的格数。 </li><li>-cli&lt;缩排格数&gt;或–case-indentation-&lt;缩排格数&gt; 　使用case时，switch缩排的格数。 </li><li>-cp&lt;栏数&gt;或-else-endif-column&lt;栏数&gt; 　将注释置于else与elseif叙述右侧定的栏位。 </li><li>-cs或–space-after-cast 　在cast之后空一格。 </li><li>-d&lt;缩排格数&gt;或-line-comments-indentation&lt;缩排格数&gt; 　针对不是放在程序码右侧的注释，设置其缩排格数。 </li><li>-di&lt;栏数&gt;或–declaration-indentation&lt;栏数&gt; 　将声明区段的变量置于指定的栏位。 </li><li>-fc1或–format-first-column-comments 　针对放在每行最前端的注释，设置其格式。 </li><li>-fca或–format-all-comments 　设置所有注释的格式。 </li><li>-gnu或–gnu-style 　指定使用GNU的格式，此为预设值。 </li><li>-i&lt;格数&gt;或–indent-level&lt;格数&gt; 　设置缩排的格数。 </li><li>-ip&lt;格数&gt;或–parameter-indentation&lt;格数&gt; 　设置参数的缩排格数。 </li><li>-kr或–k-and-r-style 　指定使用Kernighan&amp;Ritchie的格式。 </li><li>-lp或–continue-at-parentheses 　叙述过长而换行，且叙述中包含了括弧时，将括弧中的每行起始栏位内容垂直对其排列。 </li><li>-nbad或–no-blank-lines-after-declarations 　在声明区段后不要加上空白行。 </li><li>-nbap或–no-blank-lines-after-procedures 　在程序后不要加上空白行。 </li><li>-nbbb或–no-blank-lines-after-block-comments 　在注释区段后不要加上空白行。 </li><li>-nbc或–no-blank-lines-after-commas 　在声明区段中，即使出现逗号，仍旧不要换行。 </li><li>-ncdb或–no-comment-delimiters-on-blank-lines 　注释符号不要自成一行。 </li><li>-nce或–dont-cuddle-else 　不要将else置于”}”之后。 </li><li>-ncs或–no-space-after-casts 　不要在cast之后空一格。 </li><li>-nfc1或–dont-format-first-column-comments 　不要格式化放在每行最前端的注释。 </li><li>-nfca或–dont-format-comments 　不要格式化任何的注释。 </li><li>-nip或–no-parameter-indentation 　参数不要缩排。 </li><li>-nlp或–dont-line-up-parentheses 　叙述过长而换行，且叙述中包含了括弧时，不用将括弧中的每行起始栏位垂直对其排列。 </li><li>-npcs或–no-space-after-function-call-names 　在调用的函数名称之后，不要加上空格。 </li><li>-npro或–ignore-profile 　不要读取indent的配置文件.indent.pro。 </li><li>-npsl或–dont-break-procedure-type 　程序类型与程序名称放在同一行。 </li><li>-nsc或–dont-star-comments 　注解左侧不要加上星号(*)。 </li><li>-nsob或–leave-optional-semicolon 　不用处理多余的空白行。 </li><li>-nss或–dont-space-special-semicolon  　若for或while区段仅有一行时，在分号前不加上空格。 </li><li>-nv或–no-verbosity 　不显示详细的信息。 </li><li>-orig或–original 　使用Berkeley的格式。 </li><li>-pcs或–space-after-procedure-calls 　在调用的函数名称与”{“之间加上空格。 </li><li>-psl或–procnames-start-lines 　程序类型置于程序名称的前一行。 </li><li>-sc或–start-left-side-of-comments 　在每行注释左侧加上星号(*)。 </li><li>-sob或–swallow-optional-blank-lines 　删除多余的空白行。 </li><li>-ss或–space-special-semicolon 　若for或swile区段今有一行时，在分号前加上空格。 </li><li>-st或–standard-output 　将结果显示在标准输出设备。 </li><li>-T 　数据类型名称缩排。 </li><li>-ts&lt;格数&gt;或–tab-size&lt;格数&gt; 　设置tab的长度。 </li><li>-v或–verbose 　执行时显示详细的信息。 </li><li>-version 　显示版本信息。</li></ul><h2 id="linux文件传输命令"><a href="#linux文件传输命令" class="headerlink" title="linux文件传输命令"></a>linux文件传输命令</h2><h3 id="bye"><a href="#bye" class="headerlink" title="bye"></a>bye</h3><p>功能说明：中断FTP连线并结束程序。</p><p>语　　法：<code>bye</code></p><p>补充说明：在ftp模式下，输入bye即可中断目前的连线作业，并结束ftp的执行。</p><h3 id="ftp-file-transfer-protocol"><a href="#ftp-file-transfer-protocol" class="headerlink" title="ftp(file transfer protocol)"></a>ftp(file transfer protocol)</h3><p>功能说明：设置文件系统相关功能。</p><p>语　　法：<code>ftp [-dignv][主机名称或IP地址]</code></p><p>补充说明：FTP是ARPANet的标准文件传输协议，该网络就是现今Internet的前身。</p><p>参　　数：</p><ul><li>-d   详细显示指令执行过程，便于排错或分析程序执行的情形。</li><li>-i   关闭互动模式，不询问任何问题。</li><li>-g   关闭本地主机文件名称支持特殊字符的扩充特性。</li><li>-n   不使用自动登陆。</li><li>-v   显示指令执行过程。</li></ul><h3 id="ftpcount"><a href="#ftpcount" class="headerlink" title="ftpcount"></a>ftpcount</h3><p>功能说明：显示目前以FTP登入的用户人数。</p><p>语　　法：<code>ftpcount</code></p><p>补充说明：执行这项指令可得知目前用FTP登入系统的人数以及FTP登入人数的上限。</p><h3 id="ftpshut-ftp-shutdown"><a href="#ftpshut-ftp-shutdown" class="headerlink" title="ftpshut(ftp shutdown)"></a>ftpshut(ftp shutdown)</h3><p>功能说明：在指定的时间关闭FTP服务器。</p><p>语　　法：<code>ftpshut [-d&lt;分钟&gt;][-l&lt;分钟&gt;][关闭时间][“警告信息”]</code></p><p>补充说明：本指令提供系统管理者在设置的时间关闭FTP服务器，且能在关闭之前发出警告信息通知用户。关闭时间若设置后为”none”，则会马上关闭服务器。如果采用”+30”的方式来设置表示服务器在30分钟之后关闭。依次类推，假设使用”1130”的格式则代表服务器会在每日的11时30分关闭，时间格式为24小时制。FTP服务器关闭后，在/etc目录下会产生一个名称为shutmsg的文件，把它删除后即可再度启动FTP服务器的功能。</p><p>参　　数：</p><ul><li>-d&lt;分钟&gt;   切断所有FTP连线时间。</li><li>-l&lt;分钟&gt;   停止接受FTP登入的时间。</li></ul><h3 id="ftpwho"><a href="#ftpwho" class="headerlink" title="ftpwho"></a>ftpwho</h3><p>功能说明：显示目前所有以FTP登入的用户信息。</p><p>语　　法：<code>ftpwho</code></p><p>补充说明：执行这项指令可得知目前用FTP登入系统的用户有那些人，以及他们正在进行的操作。</p><h3 id="ncftp-nc-file-transfer-protocol"><a href="#ncftp-nc-file-transfer-protocol" class="headerlink" title="ncftp(nc file transfer protocol)"></a>ncftp(nc file transfer protocol)</h3><p>功能说明：传输文件。</p><p>语　　法：<code>ncftp [主机或IP地址]</code></p><p>补充说明：FTP让用户得以下载存放于服务器主机的文件，也能将文件上传到远端主机放置。NcFTP是文字模式FTP程序的佼佼者，它具备多样特色， 包括显示传输速率，下载进度，自动续传，标住书签，可通过防火墙和代理服务器等。</p><h3 id="tftp-trivial-file-transfer-protocol"><a href="#tftp-trivial-file-transfer-protocol" class="headerlink" title="tftp(trivial file transfer protocol)"></a>tftp(trivial file transfer protocol)</h3><p>功能说明：传输文件。</p><p>语　　法：<code>tftp [主机名称或IP地址]</code></p><p>补充说明：FTP让用户得以下载存放于远端主机的文件，也能将文件上传到远端主机放置。tftp是简单的文字模式ftp程序，它所使用的指令和FTP类似。</p><h3 id="uucico"><a href="#uucico" class="headerlink" title="uucico"></a>uucico</h3><p>功能说明：UUCP文件传输服务程序。</p><p>语　　法：<code>uucico [-cCDefqvwz][-i&lt;类型&gt;][-I&lt;文件&gt;][-p&lt;连接端口号码&gt;][-][-rl][-s&lt;主机&gt;][-S&lt;主机&gt;][-u&lt;用户&gt;][-x&lt;类型&gt;][–help]</code></p><p>补充说明：uucico是用来处理uucp或uux送到队列的文件传输工具。uucico有两种工作模式：主动模式和附属模式。当在主动模式下时，uucico会调用远端主机；在附属模式下时，uucico则接受远端主机的调用。</p><p>参　　数：</p><ul><li>-c或–quiet   当不执行任何工作时，不要更改记录文件的内容及更新目前的状态。</li><li>-C或–ifwork   当有工作要执行时，才调用-s或-S参数所指定主机。</li><li>-D或–nodetach   不要与控制终端机离线。</li><li>-e或–loop   在附属模式下执行，并且出现要求登入的提示画面。</li><li>-f或–force   当执行错误时，不等待任何时间即重新调用主机。</li><li>-i&lt;类型&gt;或–stdin&lt;类型&gt;   当使用到标准输入设备时，指定连接端口的类型。</li><li>-I&lt;文件&gt;–config&lt;文件&gt;   指定使用的配置文件。</li><li>-l或–prompt   出现要求登入的提示画面。</li><li>-p&lt;连接端口号码&gt;或-port&lt;连接端口号码&gt;   指定连接端口号码。</li><li>-q或–quiet   不要启动uuxqt服务程序。</li><li>-r0或–slave   以附属模式启动。</li><li>-s&lt;主机&gt;或–system&lt;主机&gt;   调用指定的主机。</li><li>-u&lt;用户&gt;或–login&lt;用户&gt;   指定登入的用户帐号，而不允许输入任意的登入帐号。</li><li>-v或–version   显示版本信息，并且结束程序。</li><li>-w或–wait   在主动模式下，当执行调用动作时，则出现要求登入的提示画面。</li><li>-x&lt;类型&gt;或-X&lt;类型&gt;或outgoing-debug&lt;类型&gt;   启动指定的排错模式。</li><li>-z或–try-next   当执行不成功时，尝试下一个选择而不结束程序。</li><li>–help   显示帮助，并且结束程序。</li></ul><h3 id="uucp"><a href="#uucp" class="headerlink" title="uucp"></a>uucp</h3><p>功能说明：在Unix系统之间传送文件。</p><p>语　　法：<code>uucp [-cCdfjmrRtvW][-g&lt;等级&gt;][-I&lt;配置文件&gt;][-n&lt;用户&gt;][-x&lt;类型&gt;][–help][…来源][目的]</code></p><p>补充说明：UUCP为Unix系统之间，通过序列线来连线的协议。uucp使用UUCP协议，主要的功能为传送文件。</p><p>参　　数：</p><ul><li>-c或–nocopy   不用将文件复制到缓冲区。</li><li>-C或–copy   将文件复制到缓冲区。</li><li>-d或–directiories   在传送文件时，自动在[目的]建立必要的目录。</li><li>-f或–nodirectiories   在传送文件时，若需要在[目的]建立目录，则放弃执行该作业。</li><li>-g&lt;等级&gt;或–grade&lt;等级&gt;   指定文件传送作业的优先顺序。</li><li>-I&lt;配置文件&gt;或–config&lt;配置文件&gt;   指定uucp配置文件。</li><li>-j或–jobid   显示作业编号。</li><li>-m或–mail   作业结束后，以电子邮件报告作业是否顺利完成。</li><li>-n&lt;用户&gt;或–notify&lt;用户&gt;   作业结束后，以电子邮件向指定的用户报告作业是否顺利完成。</li><li>-r或–nouucico   不要立即启动uucico服务程序，仅将作业送到队列中，待稍后再执行。</li><li>-R或–recursive   若[来源]为目录，则将整个目录包含子目录复制到[目的]。</li><li>-t或–uuto   将最后一个参数视为”主机名!用户”。</li><li>-v或–version   显示版本信息。</li><li>-W或–noexpand   不要将目前所在的目录加入路径。</li><li>-x&lt;类型&gt;或–debug&lt;类型&gt;启动指定的排错模式。</li><li><p>–help   显示帮助。</p><p>   [源…]   指定源文件或路径。<br>   [目的]   指定目标文件或路径。</p></li></ul><h3 id="uupick"><a href="#uupick" class="headerlink" title="uupick"></a>uupick</h3><p>功能说明：处理传送进来的文件。</p><p>语　　法：<code>uupick [-v][-I&lt;配置文件&gt;][-s&lt;主机&gt;][-x&lt;层级&gt;][–help]</code></p><p>补充说明：当其他主机通过UUCP将文件传送进来时，可利用uupick指令取出这些文件。</p><p>参　　数：</p><ul><li>-I&lt;配置文件&gt;或–config&lt;配置文件&gt;   指定配置文件。</li><li>-s&lt;主机&gt;或–system&lt;主机&gt;   处理由指定主机传送过来的文件。</li><li>-v或–version   显示版本信息。</li><li>–help   显示帮助。</li></ul><h3 id="uuto"><a href="#uuto" class="headerlink" title="uuto"></a>uuto</h3><p>功能说明：将文件传送到远端的UUCP主机。</p><p>语　　法：<code>uuto [文件][目的]</code></p><p>补充说明：uuto为script文件，它实际上会执行uucp，用来将文件传送到远端UUCP主机，并在完成工作后，以邮件通知远端主机上的用户。</p><p>参　　数：</p><p>相关参数请参考uucp指令。</p><h2 id="linux磁盘管理命令"><a href="#linux磁盘管理命令" class="headerlink" title="linux磁盘管理命令"></a>linux磁盘管理命令</h2><h3 id="cd-change-directory"><a href="#cd-change-directory" class="headerlink" title="cd(change directory)"></a><font color="red">cd(change directory)</font></h3><p>功能说明：切换目录。</p><p>语　　法：<code>cd [目的目录]</code></p><p>补充说明：cd指令可让用户在不同的目录间切换，但该用户必须拥有足够的权限进入目的目录。</p><h3 id="df-disk-free"><a href="#df-disk-free" class="headerlink" title="df(disk free)"></a><font color="red">df(disk free)</font></h3><p>功能说明：显示磁盘的相关信息。</p><p>语　　法：<code>df [-ahHiklmPT][–block-size=&lt;区块大小&gt;][-t &lt;文件系统类型&gt;][-x &lt;文件系统类型&gt;][–help][–no-sync][–sync][–version][文件或设备]</code></p><p>补充说明：df可显示磁盘的文件系统与使用情形。</p><p>参　　数：</p><ul><li>-a或–all   包含全部的文件系统。</li><li>–block-size=&lt;区块大小&gt;   以指定的区块大小来显示区块数目。</li><li>-h或–human-readable   以可读性较高的方式来显示信息。</li><li>-H或–si   与-h参数相同，但在计算时是以1000 Bytes为换算单位而非1024 Bytes。</li><li>-i或–inodes   显示inode的信息。</li><li>-k或–kilobytes   指定区块大小为1024字节。</li><li>-l或–local   仅显示本地端的文件系统。</li><li>-m或–megabytes   指定区块大小为1048576字节。</li><li>–no-sync   在取得磁盘使用信息前，不要执行sync指令，此为预设值。</li><li>-P或–portability   使用POSIX的输出格式。</li><li>–sync   在取得磁盘使用信息前，先执行sync指令。</li><li>-t&lt;文件系统类型&gt;或–type=&lt;文件系统类型&gt;   仅显示指定文件系统类型的磁盘信息。</li><li>-T或–print-type   显示文件系统的类型。</li><li>-x&lt;文件系统类型&gt;或–exclude-type=&lt;文件系统类型&gt;   不要显示指定文件系统类型的磁盘信息。</li><li>–help   显示帮助。</li><li><p>–version   显示版本信息。</p><p>  [文件或设备]   指定磁盘设备。</p></li></ul><h3 id="dirs"><a href="#dirs" class="headerlink" title="dirs"></a><font color="red">dirs</font></h3><p>功能说明：显示目录记录。</p><p>语　　法：<code>dirs [+/-n -l]</code></p><p>补充说明：显示目录堆叠中的记录。</p><p>参　　数：</p><ul><li>+n   显示从左边算起第n笔的目录。</li><li>-n   显示从右边算起第n笔的目录。</li><li>-l   显示目录完整的记录。</li></ul><h3 id="du-disk-usage"><a href="#du-disk-usage" class="headerlink" title="du(disk usage)"></a><font color="red">du(disk usage)</font></h3><p>功能说明：显示目录或文件的大小。</p><p>语　　法：<code>du [-abcDhHklmsSx][-L &lt;符号连接&gt;][-X &lt;文件&gt;][–block-size][–exclude=&lt;目录或文件&gt;][–max-depth=&lt;目录层数&gt;][–help][–version][目录或文件]</code></p><p>补充说明：du会显示指定的目录或文件所占用的磁盘空间。</p><p>参　　数：</p><ul><li>-a或-all   显示目录中个别文件的大小。</li><li>-b或-bytes   显示目录或文件大小时，以byte为单位。</li><li>-c或–total   除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。</li><li>-D或–dereference-args   显示指定符号连接的源文件大小。</li><li>-h或–human-readable   以K，M，G为单位，提高信息的可读性。</li><li>-H或–si   与-h参数相同，但是K，M，G是以1000为换算单位。</li><li>-k或–kilobytes   以1024 bytes为单位。</li><li>-l或–count-links   重复计算硬件连接的文件。</li><li>-L&lt;符号连接&gt;或–dereference&lt;符号连接&gt;   显示选项中所指定符号连接的源文件大小。</li><li>-m或–megabytes   以1MB为单位。</li><li>-s或–summarize   仅显示总计。</li><li>-S或–separate-dirs   显示个别目录的大小时，并不含其子目录的大小。</li><li>-x或–one-file-xystem   以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。</li><li>-X&lt;文件&gt;或–exclude-from=&lt;文件&gt;   在&lt;文件&gt;指定目录或文件。</li><li>–exclude=&lt;目录或文件&gt;   略过指定的目录或文件。</li><li>–max-depth=&lt;目录层数&gt;   超过指定层数的目录后，予以忽略。</li><li>–help   显示帮助。</li><li>–version   显示版本信息。</li></ul><h3 id="edquota-edit-quota"><a href="#edquota-edit-quota" class="headerlink" title="edquota(edit quota)"></a>edquota(edit quota)</h3><p>功能说明：编辑用户或群组的quota。</p><p>语　　法：<code>edquota [-p &lt;源用户名称&gt;][-ug][用户或群组名称…] 或 edquota [-ug] -t</code></p><p>补充说明：edquota预设会使用vi来编辑使用者或群组的quota设置。</p><p>参　　数：</p><ul><li>-u   设置用户的quota，这是预设的参数。</li><li>-g   设置群组的quota。</li><li>-p&lt;源用户名称&gt;   将源用户的quota设置套用至其他用户或群组。</li><li>-t   设置宽限期限。</li></ul><h3 id="eject"><a href="#eject" class="headerlink" title="eject"></a>eject</h3><p>功能说明：退出抽取式设备。</p><p>语　　法：<code>eject [-dfhnqrstv][-a &lt;开关&gt;][-c &lt;光驱编号&gt;][设备]</code></p><p>补充说明：若设备已挂入，则eject会先将该设备卸除再退出。</p><p>参　　数：</p><pre><code>[设备]   设备可以是驱动程序名称，也可以是挂入点。</code></pre><ul><li>-a&lt;开关&gt;或–auto&lt;开关&gt;   控制设备的自动退出功能。</li><li>-c&lt;光驱编号&gt;或–changerslut&lt;光驱编号&gt;   选择光驱柜中的光驱。</li><li>-d或–default   显示预设的设备，而不是实际执行动作。</li><li>-f或–floppy   退出抽取式磁盘。</li><li>-h或–help   显示帮助。</li><li>-n或–noop   显示指定的设备。</li><li>-q或–tape   退出磁带。</li><li>-r或–cdrom   退出光盘。</li><li>-s或–scsi   以SCSI指令来退出设备。</li><li>-t或–trayclose   关闭光盘的托盘。</li><li>-v或–verbose   执行时，显示详细的说明。</li></ul><h3 id="lndir-link-directory"><a href="#lndir-link-directory" class="headerlink" title="lndir(link directory)"></a>lndir(link directory)</h3><p>功能说明：连接目录内容。</p><p>语　　法：<code>lndir [-ignorelinks][-silent][源目录][目的目录]</code></p><p>补充说明：执行lndir指令，可一口气把源目录底下的文件和子目录统统建立起相互对应的符号连接。</p><p>参　　数：</p><ul><li>-ignorelinks   直接建立符号连接的符号连接。</li><li>-silent   不显示指令执行过程。</li></ul><h3 id="ls-list"><a href="#ls-list" class="headerlink" title="ls(list)"></a><font color="red">ls(list)</font></h3><p>功能说明：列出目录内容。</p><p>语　　法：<code>ls [-1aAbBcCdDfFgGhHiklLmnNopqQrRsStuUvxX][-I &lt;范本样式&gt;][-T &lt;跳格字数&gt;][-w &lt;每列字符数&gt;][–block-size=&lt;区块大小&gt;][–color=&lt;使用时机&gt;][–format=&lt;列表格式&gt;][–full-time][–help][–indicator-style=&lt;标注样式&gt;][–quoting-style=&lt;引号样式&gt;][–show-control-chars][–sort=&lt;排序方式&gt;][–time=&lt;时间戳记&gt;][–version][文件或目录…]</code></p><p>补充说明：执行ls指令可列出目录的内容，包括文件和子目录的名称。</p><p>参　　数：</p><ul><li>-1   每列仅显示一个文件或目录名称。</li><li>-a或–all   下所有文件和目录。</li><li>-A或–almost-all   显示所有文件和目录，但不显示现行目录和上层目录。</li><li>-b或–escape   显示脱离字符。</li><li>-B或–ignore-backups   忽略备份文件和目录。</li><li>-c   以更改时间排序，显示文件和目录。</li><li>-C   以又上至下，从左到右的直行方式显示文件和目录名称。</li><li>-d或–directory   显示目录名称而非其内容。</li><li>-D或–dired   用Emacs的模式产生文件和目录列表。</li><li>-f   此参数的效果和同时指定”aU”参数相同，并关闭”lst”参数的效果。</li><li>-F或–classify   在执行文件，目录，Socket，符号连接，管道名称后面，各自加上”*”,”/“,”=”,”@”,”|”号。</li><li>-g   次参数将忽略不予处理。</li><li>-G或–no-group   不显示群组名称。</li><li>-h或–human-readable   用”K”,”M”,”G”来显示文件和目录的大小。</li><li>-H或–si   此参数的效果和指定”-h”参数类似，但计算单位是1000Bytes而非1024Bytes。</li><li>-i或–inode   显示文件和目录的inode编号。</li><li>-I&lt;范本样式&gt;或–ignore=&lt;范本样式&gt;   不显示符合范本样式的文件或目录名称。</li><li>-k或–kilobytes   此参数的效果和指定”block-size=1024”参数相同。</li><li>-l   使用详细格式列表。</li><li>-L或–dereference   如遇到性质为符号连接的文件或目录，直接列出该连接所指向的原始文件或目录。</li><li>-m   用”,”号区隔每个文件和目录的名称。</li><li>-n或–numeric-uid-gid   以用户识别码和群组识别码替代其名称。</li><li>-N或–literal   直接列出文件和目录名称，包括控制字符。</li><li>-o   此参数的效果和指定”-l” 参数类似，但不列出群组名称或识别码。</li><li>-p或–file-type   此参数的效果和指定”-F”参数类似，但不会在执行文件名称后面加上”*”号。</li><li>-q或–hide-control-chars   用”?”号取代控制字符，列出文件和目录名称。</li><li>-Q或–quote-name   把文件和目录名称以””号标示起来。</li><li>-r或–reverse   反向排序。</li><li>-R或–recursive   递归处理，将指定目录下的所有文件及子目录一并处理。</li><li>-s或–size   显示文件和目录的大小，以区块为单位。</li><li>-S   用文件和目录的大小排序。</li><li>-t   用文件和目录的更改时间排序。</li><li>-T&lt;跳格字符&gt;或–tabsize=&lt;跳格字数&gt;   设置跳格字符所对应的空白字符数。</li><li>-u   以最后存取时间排序，显示文件和目录。</li><li>-U   列出文件和目录名称时不予排序。</li><li>-v   文件和目录的名称列表以版本进行排序。</li><li>-w&lt;每列字符数&gt;或–width=&lt;每列字符数&gt;   设置每列的最大字符数。</li><li>-x   以从左到右，由上至下的横列方式显示文件和目录名称。</li><li>-X   以文件和目录的最后一个扩展名排序。</li><li>–block-size=&lt;区块大小&gt;   指定存放文件的区块大小。</li><li>–color=&lt;列表格式&gt;   培植文件和目录的列表格式。</li><li>–full-time   列出完整的日期与时间。</li><li>–help   在线帮助。</li><li>–indicator-style=&lt;标注样式&gt;   在文件和目录等名称后面加上标注，易于辨识该名称所属的类型。</li><li>–quoting-syte=&lt;引号样式&gt;   把文件和目录名称以指定的引号样式标示起来。</li><li>–show-control-chars   在文件和目录列表时，使用控制字符。</li><li>–sort=&lt;排序方式&gt;   配置文件和目录列表的排序方式。</li><li>–time=&lt;时间戳记&gt;   用指定的时间戳记取代更改时间。</li><li>–version   显示版本信息。</li></ul><h3 id="mcd"><a href="#mcd" class="headerlink" title="mcd"></a>mcd</h3><p>功能说明：在MS-DOS文件系统中切换工作目录</p><p>语　　法：<code>mcd [目录名称]</code></p><p>补充说明：mcd为mtools工具指令，可在MS-DOS文件系统中切换工作目录。若不加任何参数，则显示目前所在的磁盘与工作目录。</p><h3 id="mdeltree"><a href="#mdeltree" class="headerlink" title="mdeltree"></a>mdeltree</h3><p>功能说明：删除MS-DOS目录</p><p>语　　法：<code>mdeltree [目录…]</code></p><p>补充说明：mdel为mtools工具指令，模拟MS-DOS的deltree指令，可删除MS-DOS文件系统中的目录及目录下所有子目录与文件。</p><h3 id="mdu"><a href="#mdu" class="headerlink" title="mdu"></a>mdu</h3><p>功能说明：显示MS-DOS目录所占用的磁盘空间。</p><p>语　　法：<code>mdu [-as][目录]</code></p><p>补充说明：mdu为mstools工具指令，可显示MS-DOS文件系统中目录所占用的磁盘空间。</p><p>参　　数：</p><ul><li>-a   显示每个文件及整个目录所占用的空间。</li><li>-s   仅显示整个目录所占用的空间。</li></ul><h3 id="mkdir-make-directories"><a href="#mkdir-make-directories" class="headerlink" title="mkdir(make directories)"></a><font color="red">mkdir(make directories)</font></h3><p>功能说明：建立目录</p><p>语　　法：<code>mkdir [-p][–help][–version][-m &lt;目录属性&gt;][目录名称]</code></p><p>补充说明：mkdir可建立目录并同时设置目录的权限。</p><p>参　　数：</p><ul><li>-m&lt;目录属性&gt;或–mode&lt;目录属性&gt;   建立目录时同时设置目录的权限。</li><li>-p或–parents   若所要建立目录的上层目录目前尚未建立，则会一并建立上层目录。</li><li>–help   显示帮助。</li><li>–verbose   执行时显示详细的信息。</li><li>–version   显示版本信息。</li></ul><h3 id="mlabel"><a href="#mlabel" class="headerlink" title="mlabel"></a>mlabel</h3><p>功能说明：显示或设置MS-DOS磁盘驱动器的标签名称。</p><p>语　　法：<code>mlabel [-csvV][驱动器代号][标签名称]</code></p><p>补充说明：mlabel为mtools工具指令，模拟MS-DOS的label指令，可显示或设置MS-DOS磁盘驱动器的标签名称。</p><p>参　　数：</p><ul><li>-c   清楚标签名称</li><li>-s   显示标签名称</li><li>-v   执行时显示详细的信息。</li><li>-V   显示版本信息。</li></ul><h3 id="mmd"><a href="#mmd" class="headerlink" title="mmd"></a>mmd</h3><p>功能说明：在MS-DOS文件系统中建立目录。</p><p>语　　法：<code>mmd [目录…]</code></p><p>补充说明：mmd为mtools工具指令，模拟MS-DOS的md指令，可在MS-DOS的文件系统中建立目录。</p><h3 id="mmount"><a href="#mmount" class="headerlink" title="mmount"></a>mmount</h3><p>功能说明：挂入MS-DOS文件系统。</p><p>语　　法：<code>mmount [驱动器代号][mount参数]</code></p><p>补充说明：mmount为mtools工具指令，可根据[mount参数]中的设置，将磁盘内容挂入到Linux目录中。</p><p>参　　数：</p><pre><code>[mount参数]的用法请参考mount指令。</code></pre><h3 id="mrd"><a href="#mrd" class="headerlink" title="mrd"></a>mrd</h3><p>功能说明：删除MS-DOS文件系统中的目录。</p><p>语　　法：<code>mrd [目录…]</code></p><p>补充说明：mrd为mtools工具指令，模拟MS-DOS的rd指令，可删除MS-DOS的目录。</p><h3 id="mzip"><a href="#mzip" class="headerlink" title="mzip"></a>mzip</h3><p>功能说明：Zip/Jaz磁盘驱动器控制指令。</p><p>语　　法：<code>mzip [-efpqruwx]</code></p><p>补充说明：mzip为mtools工具指令，可设置Zip或Jaz磁盘驱动区的保护模式以及执行退出磁盘的动作。</p><p>参　　数：</p><ul><li>-e   退出磁盘。</li><li>-f   与-e参数一并使用，不管是否已经挂入磁盘中的文件系统，一律强制退出磁盘。</li><li>-p   设置磁盘的写入密码。</li><li>-q   显示目前的状态。</li><li>-r   将磁盘设为防写状态。</li><li>-u   退出磁盘以前，暂时解除磁盘的保护状态。</li><li>-w   将磁盘设为可写入状态。</li><li>-x   设置磁盘的密码。</li></ul><h3 id="pwd-print-working-directory"><a href="#pwd-print-working-directory" class="headerlink" title="pwd(print working directory)"></a><font color="red">pwd(print working directory)</font></h3><p>功能说明：显示工作目录。</p><p>语　　法：<code>pwd [–help][–version]</code></p><p>补充说明：执行pwd指令可立刻得知您目前所在的工作目录的绝对路径名称。</p><p>参　　数：</p><ul><li>–help   在线帮助。</li><li>–version   显示版本信息。</li></ul><h3 id="quota"><a href="#quota" class="headerlink" title="quota"></a>quota</h3><p>功能说明：显示磁盘已使用的空间与限制。</p><p>语　　法：<code>quota [-quvV][用户名称…] 或 quota [-gqvV][群组名称…]</code></p><p>补充说明：执行quota指令，可查询磁盘空间的限制，并得知已使用多少空间。</p><p>参　　数：</p><ul><li>-g   列出群组的磁盘空间限制。</li><li>-q   简明列表，只列出超过限制的部分。</li><li>-u   列出用户的磁盘空间限制。</li><li>-v   显示该用户或群组，在所有挂入系统的存储设备的空间限制。</li><li>-V   显示版本信息。</li></ul><h3 id="quotacheck"><a href="#quotacheck" class="headerlink" title="quotacheck"></a>quotacheck</h3><p>功能说明：检查磁盘的使用空间与限制。</p><p>语　　法：<code>quotacheck [-adgRuv][文件系统…]</code></p><p>补充说明：执行quotacheck指令，扫描挂入系统的分区，并在各分区的文件系统根目录下产生quota.user和quota.group文件，设置用户和群组的磁盘空间限制。</p><p>参　　数：</p><ul><li>-a   扫描在/etc/fstab文件里，有加入quota设置的分区。</li><li>-d   详细显示指令执行过程，便于排错或了解程序执行的情形。</li><li>-g   扫描磁盘空间时，计算每个群组识别码所占用的目录和文件数目。</li><li>-R   排除根目录所在的分区。</li><li>-u   扫描磁盘空间时，计算每个用户识别码所占用的目录和文件数目。</li><li>-v   显示指令执行过程。</li></ul><h3 id="quotaoff"><a href="#quotaoff" class="headerlink" title="quotaoff"></a>quotaoff</h3><p>功能说明：关闭磁盘空间限制。</p><p>语　　法：<code>quotaoff [-aguv][文件系统…]</code></p><p>补充说明：执行quotaoff指令可关闭用户和群组的磁盘空间限制。</p><p>参　　数：</p><ul><li>-a   关闭在/etc/fstab文件里，有加入quota设置的分区的空间限制。</li><li>-g   关闭群组的磁盘空间限制。</li><li>-u   关闭用户的磁盘空间限制。</li><li>-v   显示指令执行过程。</li></ul><h3 id="quotaon"><a href="#quotaon" class="headerlink" title="quotaon"></a>quotaon</h3><p>功能说明：开启磁盘空间限制。</p><p>语　　法：<code>quotaon [-aguv][文件系统…]</code></p><p>补充说明：执行quotaon指令可开启用户和群组的才磅秒年空间限制，各分区的文件系统根目录必须有quota.user和quota.group配置文件。</p><p>参　　数：</p><ul><li>-a   开启在/ect/fstab文件里，有加入quota设置的分区的空间限制。</li><li>-g   开启群组的磁盘空间限制。</li><li>-u   开启用户的磁盘空间限制。</li><li>-v   显示指令指令执行过程。</li></ul><h3 id="repquota-report-quota"><a href="#repquota-report-quota" class="headerlink" title="repquota(report quota)"></a>repquota(report quota)</h3><p>功能说明：检查磁盘空间限制的状态。</p><p>语　　法：<code>repquota [-aguv][文件系统…]</code></p><p>补充说明：执行repquota指令，可报告磁盘空间限制的状况，清楚得知每位用户或每个群组已使用多少空间。</p><p>参　　数：</p><ul><li>-a   列出在/etc/fstab文件里，有加入quota设置的分区的使用状况，包括用户和群组。</li><li>-g   列出所有群组的磁盘空间限制。</li><li>-u   列出所有用户的磁盘空间限制。</li><li>-v   显示该用户或群组的所有空间限制。</li></ul><h3 id="rmdir-remove-directory"><a href="#rmdir-remove-directory" class="headerlink" title="rmdir(remove directory)"></a>rmdir(remove directory)</h3><p>功能说明：删除目录。</p><p>语　　法：<code>rmdir [-p][–help][–ignore-fail-on-non-empty][–verbose][–version][目录…]</code></p><p>补充说明：当有空目录要删除时，可使用rmdir指令。</p><p>参　　数：</p><ul><li>-p或–parents   删除指定目录后，若该目录的上层目录已变成空目录，则将其一并删除。</li><li>–help   在线帮助。</li><li>–ignore-fail-on-non-empty   忽略非空目录的错误信息。</li><li>–verbose   显示指令执行过程。</li><li>–version   显示版本信息。</li></ul><h3 id="rmt-remote-magnetic-tape"><a href="#rmt-remote-magnetic-tape" class="headerlink" title="rmt(remote magnetic tape)"></a>rmt(remote magnetic tape)</h3><p>功能说明：远端磁带传输协议模块。</p><p>语　　法：<code>rmt</code></p><p>补充说明：通过rmt指令，用户可通过IPC连线，远端操控磁带机的倾倒和还原操作。</p><h3 id="stat-status"><a href="#stat-status" class="headerlink" title="stat(status)"></a><font color="red">stat(status)</font></h3><p>功能说明：显示inode内容。</p><p>语　　法：<code>stat [文件或目录]</code></p><p>补充说明：stat以文字的格式来显示inode的内容。</p><h3 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h3><p>功能说明：以树状图列出目录的内容。</p><p>语　　法：<code>tree [-aACdDfFgilnNpqstux][-I &lt;范本样式&gt;][-P &lt;范本样式&gt;][目录…]</code></p><p>补充说明：执行tree指令，它会列出指定目录下的所有文件，包括子目录里的文件。</p><p>参　　数：</p><ul><li>-a   显示所有文件和目录。</li><li>-A   使用ASNI绘图字符显示树状图而非以ASCII字符组合。</li><li>-C   在文件和目录清单加上色彩，便于区分各种类型。</li><li>-d   显示目录名称而非内容。</li><li>-D   列出文件或目录的更改时间。</li><li>-f   在每个文件或目录之前，显示完整的相对路径名称。</li><li>-F   在执行文件，目录，Socket，符号连接，管道名称名称，各自加上”*”,”/“,”=”,”@”,”|”号。</li><li>-g   列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码。</li><li>-i   不以阶梯状列出文件或目录名称。</li><li>-I&lt;范本样式&gt;   不显示符合范本样式的文件或目录名称。</li><li>-l   如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录。</li><li>-n   不在文件和目录清单加上色彩。</li><li>-N   直接列出文件和目录名称，包括控制字符。</li><li>-p   列出权限标示。</li><li>-P&lt;范本样式&gt;   只显示符合范本样式的文件或目录名称。</li><li>-q   用”?”号取代控制字符，列出文件和目录名称。</li><li>-s   列出文件或目录大小。</li><li>-t   用文件和目录的更改时间排序。</li><li>-u   列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码。</li><li>-x   将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该子目录予以排除在寻找范围外。</li></ul><h3 id="umount"><a href="#umount" class="headerlink" title="umount"></a>umount</h3><p>功能说明：卸除文件系统。</p><p>语　　法：<code>umount [-ahnrvV][-t &lt;文件系统类型&gt;][文件系统]</code></p><p>补充说明：umount可卸除目前挂在Linux目录中的文件系统。</p><p>参　　数：</p><ul><li>-a   卸除/etc/mtab中记录的所有文件系统。</li><li>-h   显示帮助。</li><li>-n   卸除时不要将信息存入/etc/mtab文件中。</li><li>-r   若无法成功卸除，则尝试以只读的方式重新挂入文件系统。</li><li>-t&lt;文件系统类型&gt;   仅卸除选项中所指定的文件系统。</li><li>-v   执行时显示详细的信息。</li><li><p>-V   显示版本信息。</p><p>  [文件系统]   除了直接指定文件系统外，也可以用设备名称或挂入点来表示文件系统。</p></li></ul><h2 id="linux磁盘维护命令"><a href="#linux磁盘维护命令" class="headerlink" title="linux磁盘维护命令"></a>linux磁盘维护命令</h2><h3 id="badblocks"><a href="#badblocks" class="headerlink" title="badblocks"></a>badblocks</h3><p>功能说明：检查磁盘装置中损坏的区块。</p><p>语　　法：<code>badblocks [-svw][-b &lt;区块大小&gt;][-o &lt;输出文件&gt;][磁盘装置][磁盘区块数][启始区块]</code></p><p>补充说明：执行指令时须指定所要检查的磁盘装置，及此装置的磁盘区块数。</p><p>参　　数：</p><ul><li>-b&lt;区块大小&gt;   指定磁盘的区块大小，单位为字节。</li><li>-o&lt;输出文件&gt;   将检查的结果写入指定的输出文件。</li><li>-s   在检查时显示进度。</li><li>-v   执行时显示详细的信息。</li><li><p>-w   在检查时，执行写入测试。</p><pre><code>[磁盘装置]   指定要检查的磁盘装置。[磁盘区块数]   指定磁盘装置的区块总数。[启始区块]   指定要从哪个区块开始检查。</code></pre></li></ul><h3 id="cfdisk"><a href="#cfdisk" class="headerlink" title="cfdisk"></a>cfdisk</h3><p>功能说明：磁盘分区。</p><p>语　　法：<code>cfdisk [-avz][-c &lt;柱面数目&gt;-h &lt;磁头数目&gt;-s &lt;盘区数目&gt;][-P &lt;r,s,t&gt;][外围设备代号]</code></p><p>补充说明：cfdisk是用来磁盘分区的程序，它十分类似DOS的fdisk，具有互动式操作界面而非传统fdisk的问答式界面，您可以轻易地利用方向键来操控分区操作。</p><p>参　　数：</p><ul><li>-a   在程序里不用反白代表选取，而以箭头表示。</li><li>-c&lt;柱面数目&gt;   忽略BIOS的数值，直接指定磁盘的柱面数目。</li><li>-h&lt;磁头数目&gt;   忽略BIOS的数值，直接指定磁盘的磁头数目。</li><li>-P&lt;r,s,t&gt;   显示分区表的内容，附加参数”r”会显示整个分区表的详细资料，附加参数”s”会依照磁区的顺序显示相关信息，附加参数”t”则会以磁头，磁区，柱面的方式来显示资料。</li><li>-s&lt;磁区数目&gt;   忽略BIOS的数值，直接指定磁盘的磁区数目。</li><li>-v   显示版本信息。</li><li>-z   不读取现有的分区，直接当作没有分区的新磁盘使用。</li></ul><h3 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h3><p>功能说明：读取，转换并输出数据。</p><p>语　　法：<code>dd [bs=&lt;字节数&gt;][cbs=&lt;字节数&gt;][conv=&lt;关键字&gt;][count=&lt;区块数&gt;][ibs=&lt;字节数&gt;][if=&lt;文件&gt;][obs=&lt;字节数&gt;][of=&lt;文件&gt;][seek=&lt;区块数&gt;][skip=&lt;区块数&gt;][–help][–version]</code></p><p>补充说明：dd可从标准输入或文件读取数据，依指定的格式来转换数据，再输出到文件，设备或标准输出。</p><p>参　　数：</p><ul><li>bs=&lt;字节数&gt;   将ibs( 输入)与obs(输出)设成指定的字节数。</li><li>cbs=&lt;字节数&gt;   转换时，每次只转换指定的字节数。</li><li>conv=&lt;关键字&gt;   指定文件转换的方式。</li><li>count=&lt;区块数&gt;   仅读取指定的区块数。</li><li>ibs=&lt;字节数&gt;   每次读取的字节数。</li><li>if=&lt;文件&gt;   从文件读取。</li><li>obs=&lt;字节数&gt;   每次输出的字节数。</li><li>of=&lt;文件&gt;   输出到文件。</li><li>seek=&lt;区块数&gt;   一开始输出时，跳过指定的区块数。</li><li>skip=&lt;区块数&gt;   一开始读取时，跳过指定的区块数。</li><li>–help   帮助。</li><li>–version   显示版本信息。</li></ul><h3 id="e2fsck-ext2-file-system-check"><a href="#e2fsck-ext2-file-system-check" class="headerlink" title="e2fsck(ext2 file system check)"></a>e2fsck(ext2 file system check)</h3><p>功能说明：检查ext2文件系统的正确性。</p><p>语　　法：<code>e2fsck [-acCdfFnprsStvVy][-b &lt;superblock&gt;][-B &lt;区块大小&gt;][-l &lt;文件&gt;][-L &lt;文件&gt;][设备名称]</code></p><p>补充说明：e2fsck执行后的传回值及代表意义如下。</p><ul><li>0     没有任何错误发生。</li><li>1     文件系统发生错误，并且已经修正。</li><li>2     文件系统发生错误，并且已经修正。</li><li>4     文件系统发生错误，但没有修正。</li><li>8     运作时发生错误。</li><li>16    使用的语法发生错误。</li><li>128   共享的函数库发生错误。</li></ul><p>参　　数：</p><ul><li>-a   不询问使用者意见，便自动修复文件系统。</li><li>-b&lt;superblock&gt;   指定superblock，而不使用预设的superblock。</li><li>-B&lt;区块大小&gt;   指定区块的大小，单位为字节。</li><li>-c   一并执行badblocks，以标示损坏的区块。</li><li>-C   将检查过程的信息完整记录在file descriptor中，使得整个检查过程都能完整监控。</li><li>-d   显示排错信息。</li><li>-f   即使文件系统没有错误迹象，仍强制地检查正确性。</li><li>-F   执行前先清除设备的缓冲区。</li><li>-l&lt;文件&gt;   将文件中指定的区块加到损坏区块列表。</li><li>-L&lt;文件&gt;   先清除损坏区块列表，再将文件中指定的区块加到损坏区块列表。因此损坏区块列表的区块跟文件中指定的区块是一样的。</li><li>-n   以只读模式开启文件系统，并采取非互动方式执行，所有的问题对话均设置以”no”回答。</li><li>-p   不询问使用者意见，便自动修复文件系统。</li><li>-r   此参数只为了兼容性而存在，并无实际作用。</li><li>-s   如果文件系统的字节顺序不适当，就交换字节顺序，否则不做任何动作。</li><li>-S   不管文件系统的字节顺序，一律交换字节顺序。</li><li>-t   显示时间信息。</li><li>-v   执行时显示详细的信息。</li><li>-V   显示版本信息。</li><li>-y   采取非互动方式执行，所有的问题均设置以”yes”回答。</li></ul><h3 id="ext2ed-ext2-file-system-editor"><a href="#ext2ed-ext2-file-system-editor" class="headerlink" title="ext2ed(ext2 file system editor)"></a>ext2ed(ext2 file system editor)</h3><p>功能说明：ext2文件系统编辑程序。</p><p>语　　法：<code>ext2ed</code></p><p>补充说明：ext2ed可直接处理硬盘分区上的数据，这指令只有Red Hat Linux才提供。</p><p>参　　数：</p><p>  一般指令</p><ul><li>setdevice[设备名称]   指定要处理的设备。</li><li>disablewrite   将ext2ed设为只读的状态。</li><li>enablewrite   将ext2ed设为可读写的状态。</li><li>help[指令]   显示个别指令的帮助。</li><li>next   移至下一个单位，单位会依目前所在的模式而异。</li><li>prev   移至前一个单位，单位会依目前所在的模式而异。</li><li>pgup   移至下一页。</li><li>pgdn   移至上一页。</li><li>set   修改目前的数据，参数会依目前所在的模式而异。</li><li><p>writedata   在执行此指令之后，才会实际修改分区中的数据。</p><p>ext2进入3种模式的指令</p></li><li><p>super   进入main superblock,即Superblock模式。</p></li><li>group&lt;编号&gt;   进入指定的group，即Group模式。</li><li><p>cd&lt;目录或文件&gt;   在inode模式下，进入指定的目录或文件，即Inode模式。</p><p>Superblock模式</p></li><li><p>gocopy&lt;备份编号&gt;   进入指定的superblock备份。</p></li><li><p>setactivecopy   将目前所在的superblock，复制到main superblock。</p><p>Group模式</p></li><li><p>blockbitmap   显示目前groupo的区块图。</p></li><li>inode   进入目前group的第一个inode。</li><li><p>inodebitmap   显示目前group的inode二进制码。</p><p>Inode模式</p></li><li><p>dir   进入目录模式。</p></li><li>file   进入文件模式。</li></ul><h3 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h3><p>功能说明：磁盘分区。</p><p>语　　法：<code>fdisk [-b &lt;分区大小&gt;][-uv][外围设备代号] 或 fdisk [-l][-b &lt;分区大小&gt;][-uv][外围设备代号…] 或 fdisk [-s &lt;分区编号&gt;]</code></p><p>补充说明：fdisk是用来磁盘分区的程序，它采用传统的问答式界面，而非类似DOS fdisk的cfdisk互动式操作界面，因此在使用上较为不便，但功能却丝毫不打折扣。</p><p>参　　数：</p><ul><li>-b&lt;分区大小&gt;   指定每个分区的大小。</li><li>-l   列出指定的外围设备的分区表状况。</li><li>-s&lt;分区编号&gt;   将指定的分区大小输出到标准输出上，单位为区块。</li><li>-u   搭配”-l”参数列表，会用分区数目取代柱面数目，来表示每个分区的起始地址。</li><li>-v   显示版本信息。</li></ul><h3 id="fsck-ext2-file-system-check-second-filesystem"><a href="#fsck-ext2-file-system-check-second-filesystem" class="headerlink" title="fsck.ext2(file system check-second filesystem)"></a>fsck.ext2(file system check-second filesystem)</h3><p>功能说明：检查文件系统并尝试修复错误。</p><p>语　　法：<code>fsck.ext2 [-acdfFnprsStvVy][-b &lt;分区第一个磁区地址&gt;][-B &lt;区块大小&gt;][-C &lt;反叙述器&gt;][-I &lt;inode缓冲区块数&gt;][-l/L &lt;损坏区块文件&gt;][-P &lt;处理inode大小&gt;][外围设备代号]</code></p><p>补充说明：当ext2文件系统发生错误时，可用fsck.ext2指令尝试加以修复。</p><p>参　　数：</p><ul><li>-a   自动修复文件系统，不询问任何问题。</li><li>-b&lt;分区第一个磁区地址&gt;   指定分区的第一个磁区的起始地址，也就是Super Block。</li><li>-B&lt;区块大小&gt;   设置该分区每个区块的大小。</li><li>-c   检查指定的文件系统内，是否存在有损坏的区块。</li><li>-C&lt;反叙述器&gt;   指定反叙述器，fsck.ext2指令会把全部的执行过程，都交由其逆向叙述，便于排错或监控程序执行的情形。</li><li>-d   详细显示指令执行过程，便于排错或分析程序执行的情形。</li><li>-f   强制对该文件系统进行完整检查，纵然该文件系统在慨略检查下没有问题。</li><li>-F   检查文件系统之前，先清理该保存设备块区内的数据。</li><li>-I&lt;inode缓冲区块数&gt;   设置欲检查的文件系统，其inode缓冲区的区块数目。</li><li>-l&lt;损坏区块文件&gt;   把文件中所列出的区块，视为损坏区块并将其标示出来，避免应用程序使用该区块。</li><li>-L&lt;损坏区块文件&gt;   此参数的效果和指定”-l”参数类似，但在参考损坏区块文件标示损坏区块之前，会先将原来标示成损坏区块者统统清楚，即全部重新设置，而非仅是加入新的损坏区块标示。</li><li>-n   把欲检查的文件系统设成只读，并关闭互动模式，否决所有询问的问题。</li><li>-p   此参数的效果和指定”-a”参数相同。</li><li>-P&lt;处理inode大小&gt;   设置fsck.ext2指令所能处理的inode大小为多少。</li><li>-r   此参数将忽略不予处理，仅负责解决兼容性的问题。</li><li>-s   检查文件系统时，交换每对字节的内容。</li><li>-S   此参数的效果和指定”-s”参数类似，但不论该文件系统是否已是标准位顺序，一律交换每对字节的内容。</li><li>-t   显示fsck.ext2指令的时序信息。</li><li>-v   详细显示指令执行过程。</li><li>-V   显示版本信息。</li><li>-y   关闭互动模式，且同意所有询问的问题。</li></ul><h3 id="fsck-file-system-check"><a href="#fsck-file-system-check" class="headerlink" title="fsck(file system check)"></a>fsck(file system check)</h3><p>功能说明：检查文件系统并尝试修复错误。</p><p>语　　法：<code>fsck [-aANPrRsTV][-t &lt;文件系统类型&gt;][文件系统…]</code></p><p>补充说明：当文件系统发生错误四化，可用fsck指令尝试加以修复。</p><p>参　　数：</p><ul><li>-a   自动修复文件系统，不询问任何问题。</li><li>-A   依照/etc/fstab配置文件的内容，检查文件内所列的全部文件系统。</li><li>-N   不执行指令，仅列出实际执行会进行的动作。</li><li>-P   当搭配”-A”参数使用时，则会同时检查所有的文件系统。</li><li>-r   采用互动模式，在执行修复时询问问题，让用户得以确认并决定处理方式。</li><li>-R   当搭配”-A”参数使用时，则会略过/目录的文件系统不予检查。</li><li>-s   依序执行检查作业，而非同时执行。</li><li>-t&lt;文件系统类型&gt;   指定要检查的文件系统类型。</li><li>-T   执行fsck指令时，不显示标题信息。</li><li>-V   显示指令执行过程。</li></ul><h3 id="fsck-minix-file-system-check-minix-filesystem"><a href="#fsck-minix-file-system-check-minix-filesystem" class="headerlink" title="fsck.minix(file system check-minix filesystem)"></a>fsck.minix(file system check-minix filesystem)</h3><p>功能说明：检查文件系统并尝试修复错误。</p><p>语　　法：<code>fsck.minix [-aflmrsv][外围设备代号]</code></p><p>补充说明：当minix文件系统发生错误时，可用fsck.minix指令尝试加以参考。</p><p>参　　数：</p><ul><li>-a   自动修复文件系统，不询问任何问题。</li><li>-f   强制对该文件系统进行完整检查，纵然该文件系统在慨略检查下没有问题。</li><li>-l   列出所有文件名称。</li><li>-m   使用类似MINIX操作系统的警告信息。</li><li>-r   采用互动模式，在执行修复时询问问题，让用户得以确认并决定处理方式。</li><li>-s   显示该分区第一个磁区的相关信息。</li><li>-v   显示指令执行过程。</li></ul><h3 id="fsconf-file-system-configurator"><a href="#fsconf-file-system-configurator" class="headerlink" title="fsconf(file system configurator)"></a>fsconf(file system configurator)</h3><p>功能说明：设置文件系统相关功能。</p><p>语　　法：<code>fsconf [–check]</code></p><p>补充说明：fsconf是Red Hat Linux发行版专门用来调整Linux各项设置的程序。</p><p>参　　数：</p><ul><li>–chedk   检查特定文件的权限。</li></ul><h3 id="hdparm-hard-disk-parameters"><a href="#hdparm-hard-disk-parameters" class="headerlink" title="hdparm(hard disk parameters)"></a>hdparm(hard disk parameters)</h3><p>功能说明：显示与设定硬盘的参数。</p><p>语　　法：<code>hdparm [-CfghiIqtTvyYZ][-a &lt;快取分区&gt;][-A &lt;0或1&gt;][-c &lt;I/O模式&gt;][-d &lt;0或1&gt;][-k &lt;0或1&gt;][-K &lt;0或1&gt;][-m &lt;分区数&gt;][-n &lt;0或1&gt;][-p &lt;PIO模式&gt;][-P &lt;分区数&gt;][-r &lt;0或1&gt;][-S &lt;时间&gt;][-u &lt;0或1&gt;][-W &lt;0或1&gt;][-X &lt;传输模式&gt;][设备]</code></p><p>补充说明：hdparm可检测，显示与设定IDE或SCSI硬盘的参数。</p><p>参　　数：</p><ul><li>-a&lt;快取分区&gt;   设定读取文件时，预先存入块区的分区数，若不加上&lt;快取分区&gt;选项，则显示目前的设定。</li><li>-A&lt;0或1&gt;   启动或关闭读取文件时的快取功能。</li><li>-c&lt;I/O模式&gt;   设定IDE32位I/O模式。</li><li>-C   检测IDE硬盘的电源管理模式。</li><li>-d&lt;0或1&gt;   设定磁盘的DMA模式。</li><li>-f   将内存缓冲区的数据写入硬盘，并清楚缓冲区。</li><li>-g   显示硬盘的磁轨，磁头，磁区等参数。</li><li>-h   显示帮助。</li><li>-i   显示硬盘的硬件规格信息，这些信息是在开机时由硬盘本身所提供。</li><li>-I   直接读取硬盘所提供的硬件规格信息。</li><li>-k&lt;0或1&gt;   重设硬盘时，保留-dmu参数的设定。</li><li>-K&lt;0或1&gt;   重设硬盘时，保留-APSWXZ参数的设定。</li><li>-m&lt;磁区数&gt;   设定硬盘多重分区存取的分区数。</li><li>-n&lt;0或1&gt;   忽略硬盘写入时所发生的错误。</li><li>-p&lt;PIO模式&gt;   设定硬盘的PIO模式。</li><li>-P&lt;磁区数&gt;   设定硬盘内部快取的分区数。</li><li>-q   在执行后续的参数时，不在屏幕上显示任何信息。</li><li>-r&lt;0或1&gt;   设定硬盘的读写模式。</li><li>-S&lt;时间&gt;   设定硬盘进入省电模式前的等待时间。</li><li>-t   评估硬盘的读取效率。</li><li>-T   平谷硬盘快取的读取效率。</li><li>-u&lt;0或1&gt;   在硬盘存取时，允许其他中断要求同时执行。</li><li>-v   显示硬盘的相关设定。</li><li>-W&lt;0或1&gt;   设定硬盘的写入快取。</li><li>-X&lt;传输模式&gt;   设定硬盘的传输模式。</li><li>-y   使IDE硬盘进入省电模式。</li><li>-Y   使IDE硬盘进入睡眠模式。</li><li>-Z   关闭某些Seagate硬盘的自动省电功能。</li></ul><h3 id="losetup-loop-setup"><a href="#losetup-loop-setup" class="headerlink" title="losetup(loop setup)"></a>losetup(loop setup)</h3><p>功能说明：设置循环设备。</p><p>语　　法：<code>losetup [-d][-e &lt;加密方式&gt;][-o &lt;平移数目&gt;][循环设备代号][文件]</code></p><p>补充说明：循环设备可把文件虚拟成区块设备，籍以模拟整个文件系统，让用户得以将其视为硬盘驱动器，光驱或软驱等设备，并挂入当作目录来使用。</p><p>参　　数：</p><ul><li>-d   卸除设备。</li><li>-e&lt;加密方式&gt;   启动加密编码。</li><li>-o&lt;平移数目&gt;   设置数据平移的数目。</li></ul><h3 id="mbadblocks"><a href="#mbadblocks" class="headerlink" title="mbadblocks"></a>mbadblocks</h3><p>功能说明：检查MS-DOS文件系统的磁盘是否有损坏的磁区。</p><p>语　　法：<code>mbadblocks [驱动器代号]</code></p><p>补充说明：mbadblocks为mtools工具指令，可用来扫描MS-DOS文件系统的磁盘驱动器，并标示出损坏的磁区。</p><h3 id="mformat"><a href="#mformat" class="headerlink" title="mformat"></a>mformat</h3><p>功能说明：对MS-DOS文件系统的磁盘进行格式化。</p><p>语　　法：<code>mformat [-1aCFIKX][-0 &lt;数据传输率&gt;][-2 &lt;磁区数&gt;][-A &lt;数据传输率&gt;][-B &lt;开机区文件&gt;][-c &lt;丛集大小&gt;][-h &lt;磁头数&gt;][-H &lt;隐藏磁区数&gt;][-l &lt;磁盘标签&gt;][-M &lt;磁区大小&gt;][-n &lt;序号&gt;][-r &lt;根目录大小&gt;][-s &lt;磁区数&gt;][-S &lt;磁区大小&gt;][-t &lt;柱面数&gt;][驱动器代号]</code></p><p>补充说明：mformat为mtools工具指令，模拟MS-DOS的format指令，可将指定的磁盘或硬盘分区格式化为MS-DOS文件系统。</p><p>参　　数：</p><ul><li>-0&lt;数据传输率&gt;   指定第0磁轨的数据传输率。</li><li>-1   不使用2M格式。</li><li>-2&lt;磁区数&gt;   指定在第0磁轨的第0个磁头的磁区数，也就是所谓的2M格式。</li><li>-a   指定产生Atari格式的序号。</li><li>-A&lt;数据传输率&gt;   指定第0磁轨以外所有磁轨的数据传输率。</li><li>-B&lt;开机区文件&gt;   从指定的文件来建立开机区。</li><li>-c&lt;丛集大小&gt;   指定丛集大小，单位为磁区。</li><li>-C   建立磁盘MS-DOS文件系统的映像文件。</li><li>-F   以FAT32来格式化磁盘。</li><li>-H&lt;隐藏磁区数&gt;   指定隐藏磁区的数目。</li><li>-I   指定FAT32的frVersion编号。</li><li>-k   尽可能地保留原有的开机区。</li><li>-l&lt;磁盘标签&gt;   指定磁盘标签名称。</li><li>-M&lt;磁区大小&gt;   指定MS-DOS文件系统所使用的磁区大小，预设应该与硬体磁区大小相同，单位为字节。</li><li>-n&lt;序号&gt;   指定序号。</li><li>-r&lt;根目录大小&gt;   指定根目录的大小，单位为磁区。</li><li>-s&lt;磁区数&gt;   指定每一磁轨所包含的磁区数目。</li><li>-S&lt;磁区大小&gt;   指定硬件磁区大小。</li><li>-t&lt;柱面数&gt;   指定柱面数目。</li><li>-X   格式化XDF磁盘。</li></ul><h3 id="mkbootdisk-make-boot-disk"><a href="#mkbootdisk-make-boot-disk" class="headerlink" title="mkbootdisk(make boot disk)"></a>mkbootdisk(make boot disk)</h3><p>功能说明：建立目前系统的启动盘。</p><p>语　　法：<code>mkbootdisk [–noprompt][–verbose][–version][–device &lt;设备&gt;][–mkinitrdargs &lt;参数&gt;][kernel 版本]</code></p><p>补充说明：mkbootdisk可建立目前系统的启动盘。</p><p>参　　数：</p><ul><li>–device&lt;设备&gt;   指定设备。</li><li>–mkinitrdargs&lt;参数&gt;   设置mkinitrd的参数。</li><li>–noprompt   不会提示用户插入磁盘。</li><li>–verbose   执行时显示详细的信息。</li><li>–version   显示版本信息。</li></ul><h3 id="mkdosfs-make-Dos-file-system"><a href="#mkdosfs-make-Dos-file-system" class="headerlink" title="mkdosfs(make Dos file system)"></a>mkdosfs(make Dos file system)</h3><p>功能说明：建立MS-DOS文件系统。</p><p>语　　法：<code>mkdosfs [-cv][-f &lt;FAT数目&gt;][-F &lt;FAT记录的单位&gt;][-i &lt;磁盘序号&gt;][-l &lt;文件名&gt;][-m &lt;信息文件&gt;][-n &lt;标签&gt;][-r &lt;根目录项目数&gt;][-s &lt;磁区数&gt;][设备名称][区块数]</code></p><p>补充说明：mkdosfs可在Linux下，将磁盘格式化为MS-DOS文件系统的格式。</p><p>参　　数：</p><ul><li>-c   检查是否有损坏的区块。</li><li>-f&lt;FAT数目&gt;   指定FAT的数目，目前支持1与2两种选项。</li><li>-F&lt;FAT记录的单位&gt;   指定FAT记录的单位为12或16位。</li><li>-i&lt;磁盘序号&gt;   设置文件系统的磁盘序号。</li><li>-l&lt;文件名&gt;   从指定的文件中，读取文件系统中损坏区块的信息。</li><li>-m&lt;信息文件&gt;   若以次文件系统开机，而却因操作系统没有正常安装，则会显示选项中所指定的信息文件内容。</li><li>-n&lt;标签&gt;   设置文件系统的磁盘标签名称。</li><li>-r&lt;根目录项目数&gt;   设置根目录最多能记载项目数。</li><li>-s&lt;磁区数&gt;   指定每个丛集所包含的磁区数。</li><li>-v   执行时显示详细的信息。</li></ul><h3 id="mke2fs-make-ext2-file-system"><a href="#mke2fs-make-ext2-file-system" class="headerlink" title="mke2fs(make ext2 file system)"></a>mke2fs(make ext2 file system)</h3><p>功能说明：建立ext2文件系统。</p><p>语　　法：<code>mke2fs [-cFMqrSvV][-b &lt;区块大小&gt;][-f &lt;不连续区段大小&gt;][-i &lt;字节&gt;][-N &lt;inode数&gt;][-l &lt;文件&gt;][-L &lt;标签&gt;][-m &lt;百分比值&gt;][-R=&lt;区块数&gt;][ 设备名称][区块数]</code></p><p>补充说明：mke2fs可建立Linux的ext2文件系统。</p><p>参　　数：</p><ul><li>-b&lt;区块大小&gt;   指定区块大小，单位为字节。</li><li>-c   检查是否有损坏的区块。</li><li>-f&lt;不连续区段大小&gt;   指定不连续区段的大小，单位为字节。</li><li>-F   不管指定的设备为何，强制执行mke2fs。</li><li>-i&lt;字节&gt;   指定”字节/inode”的比例。</li><li>-N&lt;inode数&gt;   指定要建立的inode数目。</li><li>-l&lt;文件&gt;   从指定的文件中，读取文件西中损坏区块的信息。</li><li>-L&lt;标签&gt;   设置文件系统的标签名称。</li><li>-m&lt;百分比值&gt;   指定给管理员保留区块的比例，预设为5%。</li><li>-M   记录最后一次挂入的目录。</li><li>-q   执行时不显示任何信息。</li><li>-r   指定要建立的ext2文件系统版本。</li><li>-R=&lt;区块数&gt;   设置磁盘阵列参数。</li><li>-S   仅写入superblock与group descriptors，而不更改inode able inode bitmap以及block bitmap。</li><li>-v   执行时显示详细信息。</li><li>-V   显示版本信息。</li></ul><h3 id="mkfs-ext2"><a href="#mkfs-ext2" class="headerlink" title="mkfs.ext2"></a>mkfs.ext2</h3><p>功能说明：与mke2fs相同。</p><h3 id="mkfs-make-file-system"><a href="#mkfs-make-file-system" class="headerlink" title="mkfs(make file system)"></a>mkfs(make file system)</h3><p>功能说明：建立各种文件系统。</p><p>语　　法：<code>mkfs [-vV][fs][-f &lt;文件系统类型&gt;][设备名称][区块数]</code></p><p>补充说明：mkfs本身并不执行建立文件系统的工作，而是去调用相关的程序来执行。</p><p>参　　数：</p><ul><li>fs   指定建立文件系统时的参数。</li><li>-t&lt;文件系统类型&gt;   指定要建立何种文件系统。</li><li>-v   显示版本信息与详细的使用方法。</li><li>-V   显示简要的使用方法。</li></ul><h3 id="mkfs-minix"><a href="#mkfs-minix" class="headerlink" title="mkfs.minix"></a>mkfs.minix</h3><p>功能说明：建立Minix文件系统。</p><p>语　　法：<code>mkfs.minix [-cv][-i &lt;inode数目&gt;][-l &lt;文件&gt;][-n &lt;文件名长度&gt;][设备名称][区块数]</code></p><p>补充说明：mkfs.minix可建立Minix文件系统。</p><p>参　　数：</p><ul><li>-c   检查是否有损坏的区块。</li><li>-i&lt;inode数目&gt;   指定文件系统的inode总数。</li><li>-l&lt;文件&gt;   从指定的文件中，读取文件系统中损坏区块的信息。</li><li>-n&lt;文件名长度&gt;   指定文件名称长度的上限。</li><li>-v   建立第2版的Minix文件系统。</li></ul><h3 id="mkfs-msdos"><a href="#mkfs-msdos" class="headerlink" title="mkfs.msdos"></a>mkfs.msdos</h3><p>功能说明：与mkdosfs相同。</p><h3 id="mkinitrd-make-initial-ramdisk-images"><a href="#mkinitrd-make-initial-ramdisk-images" class="headerlink" title="mkinitrd(make initial ramdisk images)"></a>mkinitrd(make initial ramdisk images)</h3><p>功能说明：建立要载入ramdisk的映像文件。</p><p>语　　法：<code>mkinitrd [-fv][–omit-scsi-modules][–version][–preload=&lt;模块名称&gt;][–with=&lt;模块名称&gt;][映像文件][Kernel 版本]</code></p><p>补充说明：mkinitrd可建立映像文件，以供Linux开机时载入ramdisk。</p><p>参　　数：</p><ul><li>-f   若指定的映像问家名称与现有文件重复，则覆盖现有的文件。</li><li>-v　　执行时显示详细的信息。</li><li>–omit-scsi-modules   不要载入SCSI模块。</li><li>–preload=&lt;模块名称&gt;   指定要载入的模块。</li><li>–with=&lt;模块名称&gt;   指定要载入的模块。</li><li>–version   显示版本信息。</li></ul><h3 id="mkisofs-make-iso-file-system"><a href="#mkisofs-make-iso-file-system" class="headerlink" title="mkisofs(make iso file system)"></a>mkisofs(make iso file system)</h3><p>功能说明：建立ISO 9660映像文件。</p><p>语　　法：<code>mkisofs [-adDfhJlLNrRTvz][-print-size][-quiet][-A &lt;应用程序ID&gt;][-abstract &lt;摘要文件&gt;][-b &lt;开机映像文件&gt;][-biblio &lt;ISBN文件&gt;][-c &lt;开机文件名称&gt;][-C &lt;盘区编号，磁区编号&gt;][-copyright &lt;版权信息文件&gt;][-hide &lt;目录或文件名&gt;][-hide-joliet &lt;文件或目录名&gt;][-log-file &lt;记录文件&gt;][-m &lt;目录或文件名&gt;][-M &lt;开机映像文件&gt;][-o &lt;映像文件&gt;][-p &lt;数据处理人&gt;][-P &lt;光盘发行人&gt;][-sysid &lt;系统ID &gt;][-V &lt;光盘ID &gt;][-volset &lt;卷册集ID&gt;][-volset-size &lt;光盘总数&gt;][-volset-seqno &lt;卷册序号&gt;][-x &lt;目录&gt;][目录或文件]</code></p><p>补充说明：mkisofs可将指定的目录与文件做成ISO 9660格式的映像文件，以供刻录光盘。</p><p>参　　数：</p><ul><li>-a或–all   mkisofs通常不处理备份文件。使用此参数可以把备份文件加到映像文件中。</li><li>-A&lt;应用程序ID&gt;或-appid&lt;应用程序ID&gt;   指定光盘的应用程序ID。</li><li>-abstract&lt;摘要文件&gt;   指定摘要文件的文件名。</li><li>-b&lt;开机映像文件&gt;或-eltorito-boot&lt;开机映像文件&gt;   指定在制作可开机光盘时所需的开机映像文件。</li><li>-biblio&lt;ISBN文件&gt;   指定ISBN文件的文件名，ISBN文件位于光盘根目录下，记录光盘的ISBN。</li><li>-c&lt;开机文件名称&gt;   制作可开机光盘时，mkisofs会将开机映像文件中的全-eltorito-catalog&lt;开机文件名称&gt;全部内容作成一个文件。</li><li>-C&lt;盘区编号，盘区编号&gt;   将许多节区合成一个映像文件时，必须使用此参数。</li><li>-copyright&lt;版权信息文件&gt;   指定版权信息文件的文件名。</li><li>-d或-omit-period   省略文件后的句号。</li><li>-D或-disable-deep-relocation   ISO 9660最多只能处理8层的目录，超过8层的部分，RRIP会自动将它们设置成ISO 9660兼容的格式。使用-D参数可关闭此功能。</li><li>-f或-follow-links   忽略符号连接。</li><li>-h   显示帮助。</li><li>-hide&lt;目录或文件名&gt;   使指定的目录或文件在ISO 9660或Rock RidgeExtensions的系统中隐藏。</li><li>-hide-joliet&lt;目录或文件名&gt;   使指定的目录或文件在Joliet系统中隐藏。</li><li>-J或-joliet   使用Joliet格式的目录与文件名称。</li><li>-l或-full-iso9660-filenames   使用ISO 9660 32字符长度的文件名。</li><li>-L或-allow-leading-dots   允许文件名的第一个字符为句号。</li><li>-log-file&lt;记录文件&gt;   在执行过程中若有错误信息，预设会显示在屏幕上。</li><li>-m&lt;目录或文件名&gt;或-exclude&lt;目录或文件名&gt;   指定的目录或文件名将不会房入映像文件中。</li><li>-M&lt;映像文件&gt;或-prev-session&lt;映像文件&gt;   与指定的映像文件合并。</li><li>-N或-omit-version-number   省略ISO 9660文件中的版本信息。</li><li>-o&lt;映像文件&gt;或-output&lt;映像文件&gt;   指定映像文件的名称。</li><li>-p&lt;数据处理人&gt;或-preparer&lt;数据处理人&gt;   记录光盘的数据处理人。</li><li>-print-size   显示预估的文件系统大小。</li><li>-quiet   执行时不显示任何信息。</li><li>-r或-rational-rock   使用Rock Ridge Extensions，并开放全部文件的读取权限。</li><li>-R或-rock   使用Rock Ridge Extensions。</li><li>-sysid&lt;系统ID&gt;   指定光盘的系统ID。</li><li>-T或-translation-table   建立文件名的转换表，适用于不支持Rock Ridge Extensions的系统上。</li><li>-v或-verbose   执行时显示详细的信息。</li><li>-V&lt;光盘ID&gt;或-volid&lt;光盘ID&gt;   指定光盘的卷册集ID。</li><li>-volset-size&lt;光盘总数&gt;   指定卷册集所包含的光盘张数。</li><li>-volset-seqno&lt;卷册序号&gt;   指定光盘片在卷册集中的编号。</li><li>-x&lt;目录&gt;   指定的目录将不会放入映像文件中。</li><li>-z   建立通透性压缩文件的SUSP记录，此记录目前只在Alpha机器上的Linux有效。</li></ul><h3 id="mkswap"><a href="#mkswap" class="headerlink" title="mkswap"></a>mkswap</h3><p>功能说明：设置交换区(swap area)。</p><p>语　　法：<code>mkswap [-cf][-v0][-v1][设备名称或文件][交换区大小]</code></p><p>补充说明：mkswap可将磁盘分区或文件设为Linux的交换区。</p><p>参　　数：</p><ul><li>-c   建立交换区前，先检查是否有损坏的区块。</li><li>-f   在SPARC电脑上建立交换区时，要加上此参数。</li><li>-v0   建立旧式交换区，此为预设值。</li><li><p>-v1   建立新式交换区。</p><p>  [交换区大小]   指定交换区的大小，单位为1024字节。</p></li></ul><h3 id="mpartition"><a href="#mpartition" class="headerlink" title="mpartition"></a>mpartition</h3><p>功能说明：建立或删除MS-DOS的分区。</p><p>语　　法：<code>mpartition [-acdfIprv][-b &lt;磁区数&gt;][-h &lt;磁头数&gt;][l &lt;磁区数&gt;][-s &lt;磁区数&gt;][-t &lt;柱面数&gt;][驱动器代号]</code></p><p>补充说明：mpartition为mtools工具指令，可建立或删除磁盘分区。</p><p>参　　数：</p><ul><li>-a   将分区设置为可开机分区。</li><li>-b&lt;磁区数&gt;   建立分区时，指定要从第几个磁区开始建立分区。</li><li>-c   建立分区。</li><li>-d   将分区设置为无法开机的分区。</li><li>-f   强制地修改分区而不管检查时发生的错误信息。</li><li>-h&lt;磁头数&gt;   建立分区时，指定分区的磁头数。</li><li>-I   删除全部的分区。</li><li>-l&lt;磁区数&gt;   建立分区时，指定分区的容量大小，单位为磁区数。</li><li>-p   当要重新建立分区时，显示命令列。</li><li>-r   删除分区。</li><li>-s&lt;磁区数&gt;   建立分区时，指定每个磁轨的磁区数。</li><li>-t&lt;柱面数&gt;   建立分区时，指定分区的柱面数。</li><li>-v   与-p参数一并使用，若没有同时下达修改分区的命令，则显示目前分区的状态。</li></ul><h3 id="sfdisk"><a href="#sfdisk" class="headerlink" title="sfdisk"></a>sfdisk</h3><p>功能说明：硬盘恩区工具程序。</p><p>语　　法：<code>sfdisk [-?Tvx][-d &lt;硬盘&gt;][-g &lt;硬盘&gt;][-l &lt;硬盘&gt;][-s &lt;分区&gt;][-V &lt;硬盘&gt;]</code></p><p>补充说明：sfdisk为硬盘分区工具程序，可显示分区的设置信息，并检查分区是否正常。</p><p>参　　数：</p><ul><li>-?或–help   显示帮助。</li><li>-d&lt;硬盘&gt;   显示硬盘分区的设置。</li><li>-g&lt;硬盘&gt;或–show-geometry&lt;硬盘&gt;   显示硬盘的CHS参数。</li><li>-l&lt;硬盘&gt;   显示后硬盘分区的相关设置。</li><li>-s&lt;分区&gt;   显示分区的大小，单位为区块。</li><li>-T或–list-types   显示所有sfdisk能辨识的文件系统ID。</li><li>-v或–version   显示版本信息。</li><li>-V&lt;硬盘&gt;或–verify&lt;硬盘&gt;   检查硬盘分区是否正常。</li><li>-x或–show-extend   显示扩展分区中的逻辑分区。</li></ul><h3 id="swapoff"><a href="#swapoff" class="headerlink" title="swapoff"></a>swapoff</h3><p>功能说明：关闭系统交换区(swap area)。</p><p>语　　法：<code>swapoff [设备]</code></p><p>补充说明：swapoff实际上为swapon的符号连接，可用来关闭系统的交换区。</p><h3 id="swapon"><a href="#swapon" class="headerlink" title="swapon"></a>swapon</h3><p>功能说明：启动系统交换区(swap area)。</p><p>语　　法：<code>swapon [-ahsV][-p &lt;优先顺序&gt;][设备]</code></p><p>补充说明：Linux系统的内存管理必须使用交换区来建立虚拟内存。</p><p>参　　数：</p><ul><li>-a   将/etc/fstab文件中所有设置为swap的设备，启动为交换区。</li><li>-h   显示帮助。</li><li>-p&lt;优先顺序&gt;   指定交换区的优先顺序。</li><li>-s   显示交换区的使用状况。</li><li>-V   显示版本信息。</li></ul><h3 id="symlinks-symbolic-links"><a href="#symlinks-symbolic-links" class="headerlink" title="symlinks(symbolic links)"></a>symlinks(symbolic links)</h3><p>功能说明：维护符号连接的工具程序。</p><p>语　　法：<code>symlinks [-cdrstv][目录]</code></p><p>补充说明：symlinks可检查目录中的符号连接，并显示符号连接类型。以下为symlinks可判断的符号连接类型：</p><ul><li>absolute：符号连接使用了绝对路径。</li><li>dangling：原始文件已经不存在。</li><li>lengthy：符号连接的路径中包含了多余的”../“。</li><li>messy：符号连接的路径中包含了多余的”/“。</li><li>other_fs：原始文件位于其他文件系统中。</li><li>relative：符号连接使用了相对路径。</li></ul><p>参　　数：</p><ul><li>-c   将使用绝对路径的符号连接转换为相对路径。</li><li>-d   移除dangling类型的符号连接。</li><li>-r   检查目录下所有子目录中的符号连接。</li><li>-s   检查lengthy类型的符号连接。</li><li>-t   与-c一并使用时，会显示如何将绝对路径的符号连接转换为相对路径，但不会实际转换。</li><li>-v   显示所有类型的符号连接。</li></ul><h3 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h3><p>功能说明：将内存缓冲区内的数据写入磁盘。</p><p>语　　法：<code>sync [–help][–version]</code></p><p>补充说明：在Linux系统中，当数据需要存入磁盘时，通常会先放到缓冲区内，等到适当的时刻再写入磁盘，如此可提高系统的执行效率。</p><p>参　　数：</p><ul><li>–help   显示帮助。</li><li>–version   显示版本信息。</li></ul><h2 id="linux网络通讯命令"><a href="#linux网络通讯命令" class="headerlink" title="linux网络通讯命令"></a>linux网络通讯命令</h2><h3 id="dip"><a href="#dip" class="headerlink" title="dip"></a>dip</h3><p>功能说明：IP拨号连接。</p><p>语　　法：<code>dip [-aikltv][-m&lt;MTU数目&gt;][-p&lt;协议&gt;][拨号script文件]</code></p><p>补充说明：dip可控制调制解调器，以拨号IP的方式建立对外的双向连接。</p><p>参　　数：</p><ul><li>-a   询问用户名称与密码。</li><li>-i   启动拨号服务器功能。</li><li>-k   删除执行中的dip程序。</li><li>-l   指定要删除的连线，必须配合-k参数一起使用。</li><li>-m&lt;MTU数目&gt;   设置最大传输单位，预设值为296。</li><li>-p&lt;协议&gt;   设置通信协议。</li><li>-t   进入dip的指令模式。</li><li>-v   执行时显示详细的信息。</li></ul><h3 id="getty-get-teletypewriter"><a href="#getty-get-teletypewriter" class="headerlink" title="getty(get teletypewriter)"></a>getty(get teletypewriter)</h3><p>功能说明：设置终端机模式，连线速率和管制线路。</p><p>语　　法：<code>getty [-h][-d&lt;组态配置文件&gt;][-r&lt;延迟秒数&gt;][-t&lt;超时秒数&gt;][-w&lt;等待字符串&gt;][终端机编号][连线速率&lt;终端机类型&gt;&lt;管制线路&gt;] 或 getty [-c&lt;定义配置文件&gt;]</code></p><p>补充说明：getty指令是UNIX之类操作系统启动时所必须的3个步骤之一。</p><p>参　　数：</p><ul><li>-c&lt;定义配置文件&gt;   指定定义配置文件，预设为/etc/gettydefs。</li><li>-d&lt;组态配置文件&gt;   指定组态配置文件，预设为/etc/conf.getty。</li><li>-h   当传输速率为0时就强制断线。</li><li>-r&lt;延迟秒数&gt;   设置延迟时间。</li><li>-t&lt;超时秒数&gt;   设置等待登入的时间。</li><li>-w&lt;等待字符串&gt;   设置等待回应的字符串。</li></ul><h3 id="mingetty"><a href="#mingetty" class="headerlink" title="mingetty"></a>mingetty</h3><p>功能说明：精简版的getty。</p><p>语　　法：<code>mingetty [–long-hostname][–noclear][tty]</code></p><p>补充说明：mingetty适用于本机上的登入程序。</p><p>参　　数：</p><ul><li>–long-hostname   显示完整的主机名称。</li><li>–noclear   在询问登入的用户名称之前不要清楚屏幕画面。</li></ul><h3 id="ppp-off"><a href="#ppp-off" class="headerlink" title="ppp-off"></a>ppp-off</h3><p>功能说明：关闭ppp连线。</p><p>语　　法：<code>ppp-off</code></p><p>补充说明：这是Slackware发行版内附的程序，让用户切断PPP的网络连线。</p><h3 id="smbd-samba-daemon"><a href="#smbd-samba-daemon" class="headerlink" title="smbd(samba daemon)"></a>smbd(samba daemon)</h3><p>功能说明：Samba服务器程序。</p><p>语　　法：<code>smbd [-aDhoP][-d&lt;排错层级&gt;][-i&lt;范围&gt;][-l&lt;记录文件&gt;][-O&lt;连接槽选项&gt;][-p&lt;连接端口编号&gt;][-s&lt;配置文件&gt;]</code></p><p>补充说明：smbd为Samba服务器程序，可分享文件与打印机等网络资源供Windows相关的用户端程序存取。</p><p>参　　数：</p><ul><li>-a   所有的连线记录都会加到记录文件中。</li><li>-d&lt;排错层级&gt;   指定记录文件所记载事件的详细程度。</li><li>-D   使用此参数时，smbd会以服务程序的方式在后台执行。</li><li>-h   显示帮助。</li><li>-i&lt;范围&gt;   指定NetBIOS名称的范围。</li><li>-l&lt;记录文件&gt;   指定记录文件的名称。</li><li>-o   每次启动时，会覆盖原有的记录文件。</li><li>-O&lt;连接槽选项&gt;   设置连接槽选项。</li><li>-p&lt;连接端口编号&gt;   设置连接端口编号。</li><li>-P   仅用来测试smbd程序的正确性。</li><li>-s&lt;配置文件&gt;   指定smbd的设置文件。</li></ul><h3 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a><font color="red">telnet</font></h3><p>功能说明：远端登入。</p><p>语　　法：<code>telnet [-8acdEfFKLrx][-b&lt;主机别名&gt;][-e&lt;脱离字符&gt;][-k&lt;域名&gt;][-l&lt;用户名称&gt;][-n&lt;记录文件&gt;][-S&lt;服务类型&gt;][-X&lt;认证形态&gt;][主机名称或IP地址&lt;通信端口&gt;]</code></p><p>补充说明：执行telnet指令开启终端机阶段作业，并登入远端主机。</p><p>参　　数：</p><ul><li>-8   允许使用8位字符资料，包括输入与输出。</li><li>-a   尝试自动登入远端系统。</li><li>-b&lt;主机别名&gt;   使用别名指定远端主机名称。</li><li>-c   不读取用户专属目录里的.telnetrc文件。</li><li>-d   启动排错模式。</li><li>-e&lt;脱离字符&gt;   设置脱离字符。</li><li>-E   滤除脱离字符。</li><li>-f   此参数的效果和指定”-F”参数相同。</li><li>-F   使用Kerberos V5认证时，加上此参数可把本地主机的认证数据上传到远端主机。</li><li>-k&lt;域名&gt;   使用Kerberos认证时，加上此参数让远端主机采用指定的领域名，而非该主机的域名。</li><li>-K   不自动登入远端主机。</li><li>-l&lt;用户名称&gt;   指定要登入远端主机的用户名称。</li><li>-L   允许输出8位字符资料。</li><li>-n&lt;记录文件&gt;   指定文件记录相关信息。</li><li>-r   使用类似rlogin指令的用户界面。</li><li>-S&lt;服务类型&gt;   设置telnet连线所需的IP TOS信息。</li><li>-x   假设主机有支持数据加密的功能，就使用它。</li><li>-X&lt;认证形态&gt;   关闭指定的认证形态。</li></ul><h3 id="uulog"><a href="#uulog" class="headerlink" title="uulog"></a>uulog</h3><p>功能说明：显示UUCP记录文件。</p><p>语　　法：<code>uulog [-DFISv][-&lt;行数&gt;][-f&lt;主机&gt;][-I&lt;配置文件&gt;][-n&lt;行数&gt;][-s&lt;主机&gt;][-u&lt;用户&gt;][-X&lt;层级&gt;][–help]</code></p><p>补充说明：uulog可用来显示UUCP记录文件中记录。</p><p>参　　数：</p><ul><li>-D或–debuglog   显示排错记录。</li><li>-f&lt;主机&gt;或–follow&lt;主机&gt;   与-F参数类似，但仅显示与指定主机相关的记录。</li><li>-I&lt;配置文件&gt;或–config&lt;配置文件&gt;   指定程序的配置文件。</li><li>-&lt;行数&gt;,-n&lt;行数&gt;或–lines&lt;行数&gt;   显示记录文件中，从最后算起指定行数的数值。</li><li>-s&lt;主机&gt;   仅显示记录文件中，与指定文件相关的记录。</li><li>-S或–statslog   显示统计记录。</li><li>-u&lt;用户&gt;或–suer&lt;用户&gt;   仅显示记录文件中，与指定用户相关的记录。</li><li>-v或–version   显示版本信息。</li><li>-X&lt;层级&gt;或–debug&lt;层级&gt;   设定排错层级。</li><li>–help   显示帮助。</li></ul><h3 id="uustat"><a href="#uustat" class="headerlink" title="uustat"></a>uustat</h3><p>功能说明：显示UUCP目前的状况。</p><p>语　　法：<code>uustat [-aeiKmMNpqQRv][-B&lt;行数&gt;][-c&lt;指令&gt;][-C&lt;指令&gt;][-I&lt;配置文件&gt;][-k&lt;工作&gt;][-o&lt;小时&gt;][-r&lt;工作&gt;][-s&lt;主机&gt;][-S&lt;主机&gt;][-u&lt;用户&gt;][-U&lt;用户&gt;][-W&lt;附注&gt;][-y&lt;小时&gt;][-x&lt;层级&gt;][–help]</code></p><p>补充说明：执行uucp与uux指令后，会先将工作送到队列，再由uucico来执行工作。uustat可显示，删除或启动队列中等待执行的工作。</p><p>参　　数：</p><ul><li>-a或-all   显示全部的UUCP工作。</li><li>-B&lt;行数&gt;或–mail-lines&lt;行数&gt;   与-M或-N参数一并使用，用来指定邮件中要包含多少行的信息。</li><li>-c&lt;指令&gt;或–command&lt;指令&gt;   显示与&lt;指令&gt;有关的工作。</li><li>-C&lt;指令&gt;或–not-command&lt;指令&gt;   显示与&lt;指令&gt;无关的工作。</li><li>-e或–executions   仅显示待执行的工作。</li><li>-i或–prompt   针对队列中的每项工作，询问使用是否要删除工作。</li><li>-I&lt;配置文件&gt;或–config&lt;配置文件&gt;   指定配置文件。</li><li>-k&lt;工作&gt;或–kill&lt;工作&gt;   删除指定的工作。</li><li>-m或–status   删除全部的工作。</li><li>-M或-mail   将状态信息邮寄给UUCP管理员。</li><li>-N或–notify   将状态信息分别邮寄给提出该项工作的用户。</li><li>-o&lt;小时&gt;或–older-than&lt;小时&gt;   显示超过指定时数的工作。</li><li>-p或–ps   显示负责UUCP锁定的程序。</li><li>-q或–list   显示每台远端主机上所要执行工作的状态。</li><li>-Q或–no-list   不显示工作。</li><li>-r&lt;工作&gt;或–rejuvenate&lt;工作&gt;   重新启动指定的工作。</li><li>-R或–rejuvenate-all   重新启动全部的工作。</li><li>-s&lt;主机&gt;或–system&lt;主机&gt;   显示与&lt;主机&gt;有关的工作。</li><li>-S&lt;主机&gt;或–not-system&lt;主机&gt;   显示与&lt;主机&gt;无关的工作。</li><li>-v或–version   显示版本信息。</li><li>-u&lt;用户&gt;或–user&lt;用户&gt;   显示与&lt;用户&gt;有关的工作。</li><li>-U&lt;用户&gt;或–not-user&lt;用户&gt;   显示与&lt;用户&gt;无关的工作。</li><li>-W&lt;附注&gt;或–comment&lt;附注&gt;   要放在邮件信息中的附注。</li><li>-y&lt;小时&gt;或–younger-than&lt;小时&gt;   显示低于指定时数的工作。</li><li>-x&lt;层级&gt;或–debug&lt;层级&gt;   指定排错层级。</li><li>–help   显示帮助。</li></ul><h3 id="uux"><a href="#uux" class="headerlink" title="uux"></a>uux</h3><p>功能说明：在远端的UUCP主机上执行指令。</p><p>语　　法：<code>uux [-bcCIjlnrvz][-a&lt;地址&gt;][-g&lt;等级&gt;][-s&lt;文件&gt;][-x&lt;层级&gt;][–help][指令]</code></p><p>补充说明：uux可在远端的UUCP主机上执行指令或是执行本机上的指令，但在执行时会使用远端电脑的文件。</p><p>参　　数：</p><ul><li>-或-p或–stdin   直接从键盘读取要执行的指令。</li><li>-a&lt;地址&gt;或–requestor&lt;地址&gt;   执行邮件地址，以便寄送状态信息。</li><li>-b或–erturn-stdin   在屏幕上显示状态信息。</li><li>-c或–nocopy   不用将文件复制到缓冲区。</li><li>-C或–copy   将文件复制到缓冲区。</li><li>-g&lt;等级&gt;或–grade&lt;等级&gt;   指定文件传送作业的优先顺序。</li><li>-I或–config file   指定uux配置文件。</li><li>-j或–jobid   显示作业编号。</li><li>-l或–link   将本机上的文件连接到缓冲区。</li><li>-n或–notification=no   无论发生任何状态，都不寄邮件通知用户。</li><li>-r或–nouucico   不要立即启动uucico服务程序，仅将作业送到队列中，然后再执行。</li><li>-s&lt;文件&gt;或–status&lt;文件&gt;   将完成状态保存为指定的文件。</li><li>-v或–version   显示版本信息。</li><li>-x&lt;层级&gt;或–debug&lt;层级&gt;   指定排错层级。</li><li>-z或–notification=error   若发生错误，则以邮件来通知用户。</li><li>–help   显示帮助。</li></ul><h3 id="cu-call-up"><a href="#cu-call-up" class="headerlink" title="cu(call up)"></a>cu(call up)</h3><p>功能说明：连接另一个系统主机。</p><p>语　　法：<code>cu [dehnotv][-a&lt;通信端口&gt;][-c&lt;电话号码&gt;][-E&lt;脱离字符&gt;][-I&lt;设置文件&gt;][-l&lt;外围设备代号&gt;][-s&lt;连线速率&gt;][-x&lt;排错模式&gt;][-z&lt;系统主机&gt;][–help][-nostop][–parity=none][&lt;系统主机&gt;/&lt;电话号码&gt;]</code></p><p>补充说明：本指令可连接另一台主机，并采用类似拨号终端机的接口工作，也可执行简易的文件传输作业。</p><p>参　　数：</p><ul><li>-a&lt;通信端口&gt;或-p&lt;通信端口&gt;或–port&lt;通信端口&gt;   使用指定的通信端口进行连线。</li><li>-c&lt;电话号码&gt;或–phone&lt;电话号码&gt;   拨打该电话号码。</li><li>-d   进入排错模式。</li><li>-e或–parity=even   使用双同位检查。</li><li>-E&lt;脱离字符&gt;或–escape&lt;脱离字符&gt;   设置脱离字符。</li><li>-h或–halfduple   使用半双工模式。</li><li>-I&lt;配置文件&gt;或–config&lt;配置文件&gt;   指定要使用的配置文件。</li><li>-l&lt;外围设备代号&gt;或–line&lt;外围设备代号&gt;   指定某项外围设备，作为连接的设备。</li><li>-n或–prompt   拨号时等待用户输入电话号码。</li><li>-o或–parity=odd   使用单同位检查。</li><li>-s&lt;连线速率&gt;或–speed&lt;连线速率&gt;或–baud&lt;连线速率&gt;或-&lt;连线速率&gt;   设置连线的速率，单位以鲍率计算。</li><li>-t或–maper   把CR字符置换成LF+CR字符。</li><li>-v或–version   显示版本信息。</li><li>-x&lt;排错模式&gt;或–debug&lt;排错模式&gt;   使用排错模式。</li><li>-z&lt;系统主机&gt;或–system&lt;系统主机&gt;   连接该系统主机。</li><li>–help   在线帮助。</li><li>–nostop   关闭Xon/Xoff软件流量控制。</li><li>–parity=none   不使用同位检查。</li></ul><h3 id="dnsconf-dns-configurator"><a href="#dnsconf-dns-configurator" class="headerlink" title="dnsconf(dns configurator)"></a>dnsconf(dns configurator)</h3><p>功能说明：设置DNS服务器组态。</p><p>语　　法：<code>dnsconf [–deldomain&lt;域&gt;][–delsecondary&lt;域&gt;][–newdomain&lt;域&gt;][–set&lt;主机&gt;&lt;IP&gt;][–setcname&lt;CNAME&gt;&lt;主机&gt;][–setmx&lt;域&gt;&lt;主机&gt;][–setns&lt;域&gt;&lt;主机&gt;][–unset&lt;主机&gt;]</code></p><p>补充说明：dnsconf实际上为linuxconf的符号连接，提供图形截面的操作方式，供管理员管理DNS服务器。</p><p>参　　数：</p><ul><li>–deldomain&lt;域&gt;   删除域。</li><li>–delsecondary&lt;域&gt;   删除次级域。</li><li>–newdomain&lt;域&gt;   新增域。</li><li>–set&lt;主机&gt;&lt;IP&gt;   新增主机记录。</li><li>–setcname&lt;CNAME&gt;&lt;主机&gt;   设置&lt;CNAME&gt;。</li><li>–setmx&lt;域&gt;&lt;主机&gt;   指定域的邮件主机。</li><li>–setns&lt;域&gt;&lt;主机&gt;   指定域的DNS服务器。</li><li>–unset&lt;主机&gt;   删除DNS中某台主机的记录。</li></ul><h3 id="efax"><a href="#efax" class="headerlink" title="efax"></a>efax</h3><p>功能说明：收发传真。</p><p>语　　法：<code>efax [-sw][-a&lt;AT指令&gt;][-c&lt;调制解调器属性&gt;][-d&lt;驱动程序&gt;][-f&lt;字体文件&gt;][-g&lt;指令&gt;][-h&lt;传真标题字符串&gt;][-i&lt;AT指令&gt;][-j&lt;AT指令&gt;][-k&lt;AT指令&gt;][-l&lt;识别码&gt;][-o&lt;选项&gt;][-q&lt;错误次数&gt;][-r&lt;文件名&gt;][-v&lt;信息类型&gt;][-x&lt;UUCP锁定文件&gt;][-t&lt;电话号码&gt;&lt;传真文件&gt;]</code></p><p>补充说明：支持Class 1与Class 2的调制解调器来收发传真。</p><p>参　　数：</p><ul><li>-a&lt;AT指令&gt;   以指定的AT指令来接电话。</li><li>-c&lt;调制解调器属性&gt;   设置本机调制解调器的属性。</li><li>-d&lt;驱动程序&gt;   指定调制解调器驱动程序。</li><li>-f&lt;字体文件&gt;   使用指定的字体文件来建立传真标题。</li><li>-g&lt;指令&gt;   若接到的电话为数据，则执行指定的指令。</li><li>-h&lt;传真标题字符串&gt;   指定字符串为每页最前端的标题。</li><li>-i&lt;AT指令&gt;   在调制解调器进入传真模式前，传送AT指令到调制解调器。</li><li>-j&lt;AT指令&gt;   在调制解调器进入传真模式后，传送AT指令到调制解调器。</li><li>-k&lt;AT指令&gt;   在调制解调器离开传真模式前，传送AT指令到调制解调器。</li><li>-l&lt;识别码&gt;   设置本机调制解调器的识别码。</li><li>-o&lt;选项&gt;   使用非标准调制解调器时设置相关选项。</li><li>-q&lt;错误次数&gt;   接收传真时，当每页发生错误次数超过指定的数目时，要求对方重发。</li><li>-r&lt;文件名&gt;   在接收传真时，将每页分别保存成文件。</li><li>-v&lt;信息类型&gt;   选择要印出的信息类型。</li><li>-w   不要接听电话，等待OK或CONNECT的信号。</li><li>-x&lt;UUCP锁定文件&gt;   使用UUCP格式的锁定文件来锁定调制解调器。</li><li>-t&lt;电话号码&gt;&lt;传真文件&gt;   以&lt;电话号码&gt;中的号码来拨号，并将&lt;传真文件&gt;传真出去。</li></ul><h3 id="httpd-http-daemon"><a href="#httpd-http-daemon" class="headerlink" title="httpd(http daemon)"></a>httpd(http daemon)</h3><p>功能说明：Apache HTTP服务器程序。</p><p>语　　法：<code>httpd [-hlLStvVX][-c&lt;httpd指令&gt;][-C&lt;httpd指令&gt;][-d&lt;服务器根目录&gt;][-D&lt;设定文件参数&gt;][-f&lt;设定文件&gt;]</code></p><p>补充说明：httpd为Apache HTTP服务器程序。直接执行程序可启动服务器的服务。</p><p>参　　数：</p><ul><li>-c&lt;httpd指令&gt;   在读取配置文件前，先执行选项中的指令。</li><li>-C&lt;httpd指令&gt;   在读取配置文件后，再执行选项中的指令。</li><li>-d&lt;服务器根目录&gt;   指定服务器的根目录。</li><li>-D&lt;设定文件参数&gt;   指定要传入配置文件的参数。</li><li>-f&lt;设定文件&gt;   指定配置文件。</li><li>-h   显示帮助。</li><li>-l   显示服务器编译时所包含的模块。</li><li>-L   显示httpd指令的说明。</li><li>-S   显示配置文件中的设定。</li><li>-t   测试配置文件的语法是否正确。</li><li>-v   显示版本信息。</li><li>-V   显示版本信息以及建立环境。</li><li>-X   以单一程序的方式来启动服务器。</li></ul><h3 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h3><p>功能说明：显示或设置网络设备。</p><p>语　　法：<code>ifconfig [网络设备][down up -allmulti -arp -promisc][add&lt;地址&gt;][del&lt;地址&gt;][&lt;hw&lt;网络设备类型&gt;&lt;硬件地址&gt;][io_addr&lt;I/O地址&gt;][irq&lt;IRQ地址&gt;][media&lt;网络媒介类型&gt;][mem_start&lt;内存地址&gt;][metric&lt;数目&gt;][mtu&lt;字节&gt;][netmask&lt;子网掩码&gt;][tunnel&lt;地址&gt;][-broadcast&lt;地址&gt;][-pointopoint&lt;地址&gt;][IP地址]</code></p><p>补充说明：ifconfig可设置网络设备的状态，或是显示目前的设置。</p><p>参　　数：</p><ul><li>add&lt;地址&gt;   设置网络设备IPv6的IP地址。</li><li>del&lt;地址&gt;   删除网络设备IPv6的IP地址。</li><li>down   关闭指定的网络设备。</li><li>hw&lt;网络设备类型&gt;&lt;硬件地址&gt;   设置网络设备的类型与硬件地址。</li><li>io_addr&lt;I/O地址&gt;   设置网络设备的I/O地址。</li><li>irq&lt;IRQ地址&gt;   设置网络设备的IRQ。</li><li>media&lt;网络媒介类型&gt;   设置网络设备的媒介类型。</li><li>mem_start&lt;内存地址&gt;   设置网络设备在主内存所占用的起始地址。</li><li>metric&lt;数目&gt;   指定在计算数据包的转送次数时，所要加上的数目。</li><li>mtu&lt;字节&gt;   设置网络设备的MTU。</li><li>netmask&lt;子网掩码&gt;   设置网络设备的子网掩码。</li><li>tunnel&lt;地址&gt;   建立IPv4与IPv6之间的隧道通信地址。</li><li>up   启动指定的网络设备。</li><li>-broadcast&lt;地址&gt;   将要送往指定地址的数据包当成广播数据包来处理。</li><li>-pointopoint&lt;地址&gt;   与指定地址的网络设备建立直接连线，此模式具有保密功能。</li><li><p>-promisc   关闭或启动指定网络设备的promiscuous模式。</p><p>  [IP地址]   指定网络设备的IP地址。<br>  [网络设备]   指定网络设备的名称。</p></li></ul><h3 id="mesg"><a href="#mesg" class="headerlink" title="mesg"></a>mesg</h3><p>功能说明：设置终端机的写入权限。</p><p>语　　法：<code>mesg [ny]</code></p><p>补充说明：将mesg设置y时，其他用户可利用write指令将信息直接显示在您的屏幕上。</p><p>参　　数：</p><ul><li>n   不允许其他用户将信息直接显示在你的屏幕上。</li><li>y   允许其他用户将信息直接显示在你的屏幕上。</li></ul><h3 id="minicom"><a href="#minicom" class="headerlink" title="minicom"></a>minicom</h3><p>功能说明：调制解调器通信程序。</p><p>语　　法：<code>minicom [-8lmMostz][-a&lt;on或0ff&gt;][-c&lt;on或off&gt;][-C&lt;取文件&gt;][-d&lt;编号&gt;][-p&lt;模拟终端机&gt;][-S&lt;script文件&gt;][配置文件]</code></p><p>补充说明：minicom是一个相当受欢迎的PPP拨号连线程序。</p><p>参　　数：</p><ul><li>-8   不要修改任何8位编码的字符。</li><li>-a&lt;on或0ff&gt;   设置终端机属性。</li><li>-c&lt;on或off&gt;   设置彩色模式。</li><li>-C&lt;取文件&gt;   指定取文件，并在启动时开启取功能。</li><li>-d&lt;编号&gt;   启动或直接拨号。</li><li>-l   不会将所有的字符都转成ASCII码。</li><li>-m   以Alt或Meta键作为指令键。</li><li>-M   与-m参数类似。</li><li>-o   不要初始化调制解调器。</li><li>-p   &lt;模拟终端机&gt;   使用模拟终端机。</li><li>-s   开启程序设置画面。</li><li>-S&lt;script文件&gt;   在启动时，执行指定的script文件。</li><li>-t   设置终端机的类型。</li><li><p>-z   在终端机上显示状态列。</p><p>   [配置文件]   指定minicom配置文件。</p></li></ul><h3 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h3><p>功能说明：设置路由器。</p><p>语　　法：<code>nc [-hlnruz][-g&lt;网关…&gt;][-G&lt;指向器数目&gt;][-i&lt;延迟秒数&gt;][-o&lt;输出文件&gt;][-p&lt;通信端口&gt;][-s&lt;来源位址&gt;][-v…][-w&lt;超时秒数&gt;][主机名称][通信端口…]</code></p><p>补充说明：执行本指令可设置路由器的相关参数。</p><p>参　　数：</p><ul><li>-g&lt;网关&gt;   设置路由器跃程通信网关，最丢哦可设置8个。</li><li>-G&lt;指向器数目&gt;   设置来源路由指向器，其数值为4的倍数。</li><li>-h   在线帮助。</li><li>-i&lt;延迟秒数&gt;   设置时间间隔，以便传送信息及扫描通信端口。</li><li>-l   使用监听模式，管控传入的资料。</li><li>-n   直接使用IP地址，而不通过域名服务器。</li><li>-o&lt;输出文件&gt;   指定文件名称，把往来传输的数据以16进制字码倾倒成该文件保存。</li><li>-p&lt;通信端口&gt;   设置本地主机使用的通信端口。</li><li>-r   乱数指定本地与远端主机的通信端口。</li><li>-s&lt;来源位址&gt;   设置本地主机送出数据包的IP地址。</li><li>-u   使用UDP传输协议。</li><li>-v   显示指令执行过程。</li><li>-w&lt;超时秒数&gt;   设置等待连线的时间。</li><li>-z   使用0输入/输出模式，只在扫描通信端口时使用。</li></ul><h3 id="netconf"><a href="#netconf" class="headerlink" title="netconf"></a>netconf</h3><p>功能说明：设置各项网络功能。</p><p>语　　法：<code>netconf</code></p><p>补充说明：netconf是Red Hat Linux发行版专门用来调整Linux各项设置的程序。</p><h3 id="netconfig"><a href="#netconfig" class="headerlink" title="netconfig"></a>netconfig</h3><p>功能说明：设置网络环境。</p><p>语　　法：<code>netconfig</code></p><p>补充说明：这是Slackware发行版内附程序，它具有互动式的问答界面，让用户轻易完成网络环境的设置。</p><h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a><font color="red">netstat</font></h3><p>功能说明：显示网络状态。</p><p>语　　法：<code>netstat [-acCeFghilMnNoprstuvVwx][-A&lt;网络类型&gt;][–ip]</code></p><p>补充说明：利用netstat指令可让你得知整个Linux系统的网络情况。</p><p>参　　数：</p><ul><li>-a或–all   显示所有连线中的Socket。</li><li>-A&lt;网络类型&gt;或–&lt;网络类型&gt;   列出该网络类型连线中的相关地址。</li><li>-c或–continuous   持续列出网络状态。</li><li>-C或–cache   显示路由器配置的快取信息。</li><li>-e或–extend   显示网络其他相关信息。</li><li>-F或–fib   显示FIB。</li><li>-g或–groups   显示多重广播功能群组组员名单。</li><li>-h或–help   在线帮助。</li><li>-i或–interfaces   显示网络界面信息表单。</li><li>-l或–listening   显示监控中的服务器的Socket。</li><li>-M或–masquerade   显示伪装的网络连线。</li><li>-n或–numeric   直接使用IP地址，而不通过域名服务器。</li><li>-N或–netlink或–symbolic   显示网络硬件外围设备的符号连接名称。</li><li>-o或–timers   显示计时器。</li><li>-p或–programs   显示正在使用Socket的程序识别码和程序名称。</li><li>-r或–route   显示Routing Table。</li><li>-s或–statistice   显示网络工作信息统计表。</li><li>-t或–tcp   显示TCP传输协议的连线状况。</li><li>-u或–udp   显示UDP传输协议的连线状况。</li><li>-v或–verbose   显示指令执行过程。</li><li>-V或–version   显示版本信息。</li><li>-w或–raw   显示RAW传输协议的连线状况。</li><li>-x或–unix   此参数的效果和指定”-A unix”参数相同。</li><li>–ip或–inet   此参数的效果和指定”-A inet”参数相同。</li></ul><h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a><font color="red">ping</font></h3><p>功能说明：检测主机。</p><p>语　　法：<code>ping [-dfnqrRv][-c&lt;完成次数&gt;][-i&lt;间隔秒数&gt;][-I&lt;网络界面&gt;][-l&lt;前置载入&gt;][-p&lt;范本样式&gt;][-s&lt;数据包大小&gt;][-t&lt;存活数值&gt;][主机名称或IP地址]</code></p><p>补充说明：执行ping指令会使用ICMP传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。</p><p>参　　数：</p><ul><li>-d   使用Socket的SO_DEBUG功能。</li><li>-c&lt;完成次数&gt;   设置完成要求回应的次数。</li><li>-f   极限检测。</li><li>-i&lt;间隔秒数&gt;   指定收发信息的间隔时间。</li><li>-I&lt;网络界面&gt;   使用指定的网络界面送出数据包。</li><li>-l&lt;前置载入&gt;   设置在送出要求信息之前，先行发出的数据包。</li><li>-n   只输出数值。</li><li>-p&lt;范本样式&gt;   设置填满数据包的范本样式。</li><li>-q   不显示指令执行过程，开头和结尾的相关信息除外。</li><li>-r   忽略普通的Routing Table，直接将数据包送到远端主机上。</li><li>-R   记录路由过程。</li><li>-s&lt;数据包大小&gt;   设置数据包的大小。</li><li>-t&lt;存活数值&gt;   设置存活数值TTL的大小。</li><li>-v   详细显示指令的执行过程。</li></ul><h3 id="pppstats-point-to-point-protocol-status"><a href="#pppstats-point-to-point-protocol-status" class="headerlink" title="pppstats(point to point protocol status)"></a>pppstats(point to point protocol status)</h3><p>功能说明：显示PPP连线状态。</p><p>语　　法：<code>pppstats [-adrv][-c&lt;执行次数&gt;][-w&lt;间隔秒数&gt;][网络界面]</code></p><p>补充说明：利用pppstats指令可让你得知PPP连接网络的相关信息。</p><p>参　　数：</p><ul><li>-a   显示绝对统计值。</li><li>-c&lt;执行次数&gt;   设置回报状况的次数。</li><li>-d   显示相对统计值。</li><li>-r   显示数据包压缩比率的统计值。</li><li>-v   显示VJTCP文件头的压缩效率统计值。</li><li>-w&lt;间隔秒数&gt;   设置显示统计信息的间隔时间。</li></ul><h3 id="samba"><a href="#samba" class="headerlink" title="samba"></a>samba</h3><p>功能说明：Samba服务器控制。</p><p>语　　法：<code>samba [start][stop][status][restart]</code></p><p>补充说明：samba为script文件，可启动，停止Samba服务器或回报目前的状态。</p><p>参　　数：</p><ul><li>start   启动Samba服务器的服务。</li><li>stop    停止Samba服务器的服务。</li><li>status   显示Samba服务器目前的状态。</li><li>restart   重新启动Samba服务器。</li></ul><h3 id="setserial"><a href="#setserial" class="headerlink" title="setserial"></a>setserial</h3><p>功能说明：设置或显示串口的相关信息。</p><p>语　　法：<code>setserial [-abgGqvVz][设备][串口参数]</code></p><p>补充说明：setserial可用来设置串口或显示目前的设置。</p><p>参　　数：</p><ul><li>-a   显示详细信息。</li><li>-b   显示摘要信息。</li><li>-g   显示串口的相关信息。</li><li>-G   以指令列表的格式来显示信息。</li><li>-q   执行时显示较少的信息。</li><li>-v   执行时显示较多的信息。</li><li>-V   显示版本信息。</li><li>-z   设置前，先将所有的标记归零。</li></ul><h3 id="shapecfg-shaper-configuration"><a href="#shapecfg-shaper-configuration" class="headerlink" title="shapecfg(shaper configuration)"></a>shapecfg(shaper configuration)</h3><p>功能说明：管制网络设备的流量。</p><p>语　　法：<code>shapecfg attach [流量管制器][网络设备] 或  shapecfg speed [流量管制器][带宽]</code></p><p>补充说明：自Linux-2.15开始，便支持流量管制的功能。</p><p>参　　数：</p><ul><li>attach   将流量管制器与实际的网络设备结合。</li><li>speed   设置流量管制器的对外传输带宽。</li></ul><h3 id="smbd-samba-daemon-1"><a href="#smbd-samba-daemon-1" class="headerlink" title="smbd(samba daemon)"></a>smbd(samba daemon)</h3><p>功能说明：Samba服务器程序。</p><p>语　　法：<code>smbd [-aDhoP][-d&lt;排错层级&gt;][-i&lt;范围&gt;][-l&lt;记录文件&gt;][-O&lt;连接槽选项&gt;][-p&lt;连接端口编号&gt;][-s&lt;配置文件&gt;]</code></p><p>补充说明：smbd为Samba服务器程序，可分享文件与打印机等网络资源供Windows相关的用户端程序存取。</p><p>参　　数：</p><ul><li>-a   所有的连线记录都会加到记录文件中。</li><li>-d&lt;排错层级&gt;   指定记录文件所记载事件的详细程度。</li><li>-D   使用此参数时，smbd会以服务程序的方式在后台执行。</li><li>-h   显示帮助。</li><li>-i&lt;范围&gt;   指定NetBIOS名称的范围。</li><li>-l&lt;记录文件&gt;   指定记录文件的名称。</li><li>-o   每次启动时，会覆盖原有的记录文件。</li><li>-O&lt;连接槽选项&gt;   设置连接槽选项。</li><li>-p&lt;连接端口编号&gt;   设置连接端口编号。</li><li>-P   仅用来测试smbd程序的正确性。</li><li>-s&lt;配置文件&gt;   指定smbd的设置文件。</li></ul><h3 id="statserial-status-ofserial-port"><a href="#statserial-status-ofserial-port" class="headerlink" title="statserial(status ofserial port)"></a>statserial(status ofserial port)</h3><p>功能说明：显示串口状态。</p><p>语　　法：<code>statserial [-dnx][串口设备名称]</code></p><p>补充说明：statserial可显示各个接脚的状态，常用来判断串口是否正常。</p><p>参　　数：</p><ul><li>-d   以10进制数字来表示串口的状态。</li><li>-n   仅显示一次串口的状态后即结束程序。</li><li>-x   与-n参数类似，但是以16进制来表示。</li></ul><h3 id="talk"><a href="#talk" class="headerlink" title="talk"></a>talk</h3><p>功能说明：与其他用户交谈。</p><p>语　　法：<code>talk [用户名称][终端机编号]</code></p><p>补充说明：通过talk指令，你可以和另一个用户线上交谈。</p><h3 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h3><p>功能说明：倾倒网络传输数据。</p><p>语　　法：<code>tcpdump [-adeflnNOpqStvx][-c&lt;数据包数目&gt;][-dd][-ddd][-F&lt;表达文件&gt;][-i&lt;网络界面&gt;][-r&lt;数据包文件&gt;][-s&lt;数据包大小&gt;][-tt][-T&lt;数据包类型&gt;][-vv][-w&lt;数据包文件&gt;][输出数据栏位]</code></p><p>补充说明：执行tcpdump指令可列出经过指定网络界面的数据包文件头，在Linux操作系统中，你必须是系统管理员。</p><p>参　　数：</p><ul><li>-a   尝试将网络和广播地址转换成名称。</li><li>-c&lt;数据包数目&gt;   收到指定的数据包数目后，就停止进行倾倒操作。</li><li>-d   把编译过的数据包编码转换成可阅读的格式，并倾倒到标准输出。</li><li>-dd   把编译过的数据包编码转换成C语言的格式，并倾倒到标准输出。</li><li>-ddd   把编译过的数据包编码转换成十进制数字的格式，并倾倒到标准输出。</li><li>-e   在每列倾倒资料上显示连接层级的文件头。</li><li>-f   用数字显示网际网络地址。</li><li>-F&lt;表达文件&gt;   指定内含表达方式的文件。</li><li>-i&lt;网络界面&gt;   使用指定的网络截面送出数据包。</li><li>-l   使用标准输出列的缓冲区。</li><li>-n   不把主机的网络地址转换成名字。</li><li>-N   不列出域名。</li><li>-O   不将数据包编码最佳化。</li><li>-p   不让网络界面进入混杂模式。</li><li>-q   快速输出，仅列出少数的传输协议信息。</li><li>-r&lt;数据包文件&gt;   从指定的文件读取数据包数据。</li><li>-s&lt;数据包大小&gt;   设置每个数据包的大小。</li><li>-S   用绝对而非相对数值列出TCP关联数。</li><li>-t   在每列倾倒资料上不显示时间戳记。</li><li>-tt   在每列倾倒资料上显示未经格式化的时间戳记。</li><li>-T&lt;数据包类型&gt;   强制将表达方式所指定的数据包转译成设置的数据包类型。</li><li>-v   详细显示指令执行过程。</li><li>-vv   更详细显示指令执行过程。</li><li>-x   用十六进制字码列出数据包资料。</li><li>-w&lt;数据包文件&gt;   把数据包数据写入指定的文件。</li></ul><h3 id="testparm-test-parameter"><a href="#testparm-test-parameter" class="headerlink" title="testparm(test parameter)"></a>testparm(test parameter)</h3><p>功能说明：测试Samba的设置是否正确无误。</p><p>语　　法：<code>testparm [-s][配置文件][&lt;主机名称&gt;&lt;IP地址&gt;]</code></p><p>补充说明：执行testparm指令可以简单测试Samba的配置文件，假如测试结果无误，Samba常驻服务就能正确载入该设置值，但并不保证其后的操作如预期般一切正常。</p><p>参　　数：</p><ul><li>-s   不显示提示符号等待用户按下Enter键，就直接列出Samba服务定义信息。</li></ul><h3 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h3><p>功能说明：显示数据包到主机间的路径。</p><p>语　　法：<code>traceroute [-dFlnrvx][-f&lt;存活数值&gt;][-g&lt;网关&gt;…][-i&lt;网络界面&gt;][-m&lt;存活数值&gt;][-p&lt;通信端口&gt;][-s&lt;来源地址&gt;][-t&lt;服务类型&gt;][-w&lt;超时秒数&gt;][主机名称或IP地址][数据包大小]</code></p><p>补充说明：traceroute指令让你追踪网络数据包的路由途径，预设数据包大小是40Bytes，用户可另行设置。</p><p>参　　数：</p><ul><li>-d   使用Socket层级的排错功能。</li><li>-f&lt;存活数值&gt;   设置第一个检测数据包的存活数值TTL的大小。</li><li>-F   设置勿离断位。</li><li>-g&lt;网关&gt;   设置来源路由网关，最多可设置8个。</li><li>-i&lt;网络界面&gt;   使用指定的网络界面送出数据包。</li><li>-I   使用ICMP回应取代UDP资料信息。</li><li>-m&lt;存活数值&gt;   设置检测数据包的最大存活数值TTL的大小。</li><li>-n   直接使用IP地址而非主机名称。</li><li>-p&lt;通信端口&gt;   设置UDP传输协议的通信端口。</li><li>-r   忽略普通的Routing Table，直接将数据包送到远端主机上。</li><li>-s&lt;来源地址&gt;   设置本地主机送出数据包的IP地址。</li><li>-t&lt;服务类型&gt;   设置检测数据包的TOS数值。</li><li>-v   详细显示指令的执行过程。</li><li>-w&lt;超时秒数&gt;   设置等待远端主机回报的时间。</li><li>-x   开启或关闭数据包的正确性检验。</li></ul><h3 id="tty-teletypewriter"><a href="#tty-teletypewriter" class="headerlink" title="tty(teletypewriter)"></a>tty(teletypewriter)</h3><p>功能说明：显示终端机连接标准输入设备的文件名称。</p><p>语　　法：<code>tty [-s][–help][–version]</code></p><p>补充说明：在Linux操作系统中，所有外围设备都有其名称与代号，这些名称代号以特殊文件的类型存放于/dev目录下。你可以执行tty指令查询目前使用的终端机的文件名称。</p><p>参　　数：</p><ul><li>-s或–silent或–quiet   不显示任何信息，只回传状态代码。</li><li>–help   在线帮助。</li><li>–version   显示版本信息。</li></ul><h3 id="uuname"><a href="#uuname" class="headerlink" title="uuname"></a>uuname</h3><p>功能说明：显示全部的UUCP远端主机。</p><p>语　　法：<code>uuname [-alv][-I&lt;配置文件&gt;][–help]</code></p><p>补充说明：uuname可显示UUCP远端主机。</p><p>参　　数：</p><ul><li>-a或–aliases   显示别名。</li><li>-I&lt;配置文件&gt;或–config&lt;配置文件&gt;   指定程序的配置文件。</li><li>-l或–local   显示本机名称。</li><li>-v或–version   显示版本信息。</li><li>–help   显示帮助。</li></ul><h3 id="wall-write-all"><a href="#wall-write-all" class="headerlink" title="wall(write all)"></a>wall(write all)</h3><p>功能说明：传送信息。</p><p>语　　法：<code>wall [公告信息]</code></p><p>补充说明：通过wall指令可将信息发送给每位同意接收公众信息的终端机用户，若不给予其信息内容，则wall指令会从标准输入设备读取数据，然后再把所得到的数据传送给所有终端机用户。</p><h3 id="write"><a href="#write" class="headerlink" title="write"></a>write</h3><p>功能说明：传送信息。</p><p>语　　法：<code>write [用户名称][终端机编号]</code></p><p>补充说明：通过write指令可传递信息给另一位登入系统的用户，当输入完毕后，键入EOF表示信息结束，write指令就会将信息传给对方。如果接收信息的用户不只登入本地主机一次，你可以指定接收信息的终端机编号。</p><h3 id="ytalk"><a href="#ytalk" class="headerlink" title="ytalk"></a>ytalk</h3><p>功能说明：与其他用户交谈。</p><p>语　　法：<code>ytalk [-isxY][-h&lt;主机名称IP地址&gt;][用户名称…]</code></p><p>补充说明：通过ytalk指令，你可以和其他用户线上交谈，如果想和其他主机的用户交谈，在用户名称后加上其主机名称或IP地址即可。</p><p>参　　数：</p><ul><li>-h&lt;主机名称IP地址&gt;   指定交谈对象所在的远端主机。</li><li>-i   用提醒声响代替显示信息。</li><li>-s   在指令提示符号先开启ytalk交谈窗。</li><li>-x   关闭图形界面。</li><li>-Y   所有必须回应yes或no的问题，都必须用大写英文字母”Y”或”N”回答。</li></ul><h3 id="arpwatch-ARP-watcher"><a href="#arpwatch-ARP-watcher" class="headerlink" title="arpwatch(ARP watcher)"></a>arpwatch(ARP watcher)</h3><p>功能说明：监听网络上ARP的记录。</p><p>语　　法：<code>arpwatch [-d][-f&lt;记录文件&gt;][-i&lt;接口&gt;][-r&lt;记录文件&gt;]</code></p><p>补充说明：ARP(Address Resolution Protocol)是用来解析IP与网络装置硬件地址的协议。arpwatch可监听区域网络中的ARP数据包并记录，同时将监听到的变化通过E-mail来报告。</p><p>参　　数：</p><ul><li>-d   启动排错模式。</li><li>-f&lt;记录文件&gt;   设置存储ARP记录的文件，预设为/var/arpwatch/arp.dat。</li><li>-i&lt;接口&gt;   指定监听ARP的接口，预设的接口为eth0。</li><li>-r&lt;记录文件&gt;   从指定的文件中读取ARP记录，而不是从网络上监听。</li></ul><h3 id="apachectl-Apache-control-interface"><a href="#apachectl-Apache-control-interface" class="headerlink" title="apachectl(Apache control interface)"></a>apachectl(Apache control interface)</h3><p>功能说明：可用来控制Apache HTTP服务器的程序。</p><p>语　　法：<code>apachectl [configtest][fullstatus][graceful][help][restart][start][status][stop]</code></p><p>补充说明：apachectl是slackware内附Apache HTTP服务器的script文件，可供管理员控制服务器，但在其他Linux的Apache HTTP服务器不一定有这个文件。</p><p>参　　数：</p><ul><li>configtest   检查设置文件中的语法是否正确。</li><li>fullstatus   显示服务器完整的状态信息。</li><li>graceful   重新启动Apache服务器，但不会中断原有的连接。</li><li>help   显示帮助信息。</li><li>restart   重新启动Apache服务器。</li><li>start   启动Apache服务器。</li><li>status   显示服务器摘要的状态信息。</li><li>stop   停止Apache服务器。</li></ul><h3 id="smbclient-samba-client"><a href="#smbclient-samba-client" class="headerlink" title="smbclient(samba client)"></a>smbclient(samba client)</h3><p>功能说明：可存取SMB/CIFS服务器的用户端程序。</p><p>语　　法：<code>smbclient [网络资源][密码][-EhLN][-B&lt;IP地址&gt;][-d&lt;排错层级&gt;][-i&lt;范围&gt;][-I&lt;IP地址&gt;][-l&lt;记录文件&gt;][-M&lt;NetBIOS名称&gt;][-n&lt;NetBIOS名称&gt;][-O&lt;连接槽选项&gt;][-p&lt;TCP连接端口&gt;][-R&lt;名称解析顺序&gt;][-s&lt;目录&gt;][-t&lt;服务器字码&gt;][-T&lt;tar选项&gt;][-U&lt;用户名称&gt;][-W&lt;工作群组&gt;]</code></p><p>补充说明：SMB与CIFS为服务器通信协议，常用于Windows95/98/NT等系统。smbclient可让Linux系统存取Windows系统所分享的资源。</p><p>参　　数：</p><ul><li>[网络资源]  [网络资源]的格式为//服务器名称/资源分享名称。</li><li>[密码]   输入存取网络资源所需的密码。</li><li>-B&lt;IP地址&gt;   传送广播数据包时所用的IP地址。</li><li>-d&lt;排错层级&gt;   指定记录文件所记载事件的详细程度。</li><li>-E   将信息送到标准错误输出设备。</li><li>-h   显示帮助。</li><li>-i&lt;范围&gt;   设置NetBIOS名称范围。</li><li>-I&lt;IP地址&gt;   指定服务器的IP地址。</li><li>-l&lt;记录文件&gt;   指定记录文件的名称。</li><li>-L   显示服务器端所分享出来的所有资源。</li><li>-M&lt;NetBIOS名称&gt;   可利用WinPopup协议，将信息送给选项中所指定的主机。</li><li>-n&lt;NetBIOS名称&gt;   指定用户端所要使用的NetBIOS名称。</li><li>-N   不用询问密码。</li><li>-O&lt;连接槽选项&gt;   设置用户端TCP连接槽的选项。</li><li>-p&lt;TCP连接端口&gt;   指定服务器端TCP连接端口编号。</li><li>-R&lt;名称解析顺序&gt;   设置NetBIOS名称解析的顺序。</li><li>-s&lt;目录&gt;   指定smb.conf所在的目录。</li><li>-t&lt;服务器字码&gt;   设置用何种字符码来解析服务器端的文件名称。</li><li>-T&lt;tar选项&gt;   备份服务器端分享的全部文件，并打包成tar格式的文件。</li><li>-U&lt;用户名称&gt;   指定用户名称。</li><li>-W&lt;工作群组&gt;   指定工作群组名称。</li></ul><h3 id="pppsetup"><a href="#pppsetup" class="headerlink" title="pppsetup"></a>pppsetup</h3><p>功能说明：设置PPP连线。</p><p>语　　法：<code>pppsetup</code></p><p>补充说明：这是Slackware发行版内附程序，它具有互动式的问答界面，让用户轻易完成PPP的连线设置。</p><h2 id="linux电子邮件与新闻组命令"><a href="#linux电子邮件与新闻组命令" class="headerlink" title="linux电子邮件与新闻组命令"></a>linux电子邮件与新闻组命令</h2><h3 id="archive"><a href="#archive" class="headerlink" title="archive"></a>archive</h3><p>功能说明：新闻组文件备存程序。</p><p>语　　法：<code>archive [-fmr][-a&lt;备存目录&gt;][-i&lt;索引文件&gt;][源文件]</code></p><p>补充说明：archive会读取新闻组的文件，然后加以备存。archive备存时，会保存[源文件]中文件的目录阶层。</p><p>参　　数：</p><ul><li>-a&lt;备存目录&gt;   指定备存的目录。</li><li>-f   将阶层目录名称的阶层关系取消，以句点来取代斜线。</li><li>-i&lt;索引文件&gt;   制作文件索引。</li><li>-m   将文件复制到目的地，建立文件连接后，以连接取代原始的文件。</li><li>-r   archive预设的标准错误输出为/var/errlog。-r参数可取消此功能。</li><li>[源文件]   在源文件中指定要备份的文件。</li></ul><h3 id="ctlinnd-control-the-internet-news-daemon"><a href="#ctlinnd-control-the-internet-news-daemon" class="headerlink" title="ctlinnd(control the internet news daemon)"></a>ctlinnd(control the internet news daemon)</h3><p>功能说明：设置INN新闻组服务器。</p><p>语　　法：<code>ctlinnd [-hs][-t&lt;超时秒数&gt;][控制命令&lt;设置数值&gt;…]</code></p><p>补充说明：通过ctlinnd指令，可以对新闻组服务器这项常驻服务下达控制命令，直接设置相关数值。</p><p>参　　数：</p><ul><li>-h   在线帮助。</li><li>-s   不显示指令执行过程。</li><li>-t&lt;超时秒数&gt;   设置等待服务器回报的时间，单位以秒计算，超过此一时间则为超时。</li></ul><h3 id="elm"><a href="#elm" class="headerlink" title="elm"></a>elm</h3><p>功能说明：E-mail管理程序。</p><p>语　　法：<code>elm [-s&lt;邮件主题&gt;][收信人别名或地址]&lt;[要输入的文件] 或 elm [-hmvz][-f&lt;目录&gt;][-i&lt;文件名&gt;]</code></p><p>补充说明：elm为全屏文字模式的电子邮件管理程序。与mail相比，elm提供较易操作的界面，但仍不及pine来得友善。</p><p>参　　数：</p><ul><li>-s&lt;邮件主题&gt;   指定新邮件的邮件主题。</li><li>-f&lt;目录&gt;   开启程序时，读取指定的目录。</li><li>-h   显示帮助。</li><li>-i&lt;文件名&gt;   将文件内容插入送出的邮件中。</li><li>-m   进入elm后，不显示指令说明。</li><li>-v   显示elm的版本信息。</li><li>-z   若收件信箱没有邮件，则不启动elm程序。</li></ul><h3 id="getlist"><a href="#getlist" class="headerlink" title="getlist"></a>getlist</h3><p>功能说明：下载新闻组清单。</p><p>语　　法：<code>getlist [-h&lt;新闻组服务器&gt;][-p&lt;通信端口&gt;][群组类型&lt;范本样式&gt;&lt;群组名称&gt;]</code></p><p>补充说明：getlist指令会从新闻服务器下载新闻组清单，并把清单输出到标准输出设备。</p><p>参　　数：</p><ul><li>-h&lt;新闻组服务器&gt;   指定欲连接的新闻组服务器。</li><li>-p&lt;通信端口&gt;   设置连接新闻组服务器的通讯端口。</li></ul><h3 id="inncheck-inn-check"><a href="#inncheck-inn-check" class="headerlink" title="inncheck(inn check)"></a>inncheck(inn check)</h3><p>功能说明：检查inn相关配置文件的语法是否正确。</p><p>语　　法：<code>inncheck [-afv][-pedantic][-perm][-noperm][文件]</code></p><p>补充说明：inncheck会检查inn配置文件的语法是否正确，但不会实际修改这些配置文件。</p><p>参　　数：</p><ul><li>-a   不管是否出现[文件]参数，仍然检查全部的配置文件。</li><li>-f   若发现配置文件有误，则列出可修正错误的指令。</li><li>-v   执行时显示详细的信息。</li><li>-pedantic   以较为严格的方式来检查。</li><li>-perm   检查文件权限是否有误。</li><li>–noperm   不检查文件的权限设置。</li><li>[文件]   若不指定此参数，则inncheck会检查所有预设的文件。</li></ul><h3 id="mail"><a href="#mail" class="headerlink" title="mail"></a>mail</h3><p>功能说明：E-mail管理程序。</p><p>语　　法：<code>mail [-iInNv][-b&lt;地址&gt;][-c&lt;地址&gt;][-f&lt;邮件文件&gt;][-s&lt;邮件主题&gt;][-u&lt;用户帐号&gt;][收信人地址]</code></p><p>补充说明：mail是一个文字模式的邮件管理程序，操作的界面不像elm或pine那么容易使用，但功能尚称完整。</p><p>参　　数：</p><ul><li>-b&lt;地址&gt;   指定密件副本的收信人地址。</li><li>-c&lt;地址&gt;   指定副本的收信人地址。</li><li>-f&lt;邮件文件&gt;   读取指定邮件文件中的邮件。</li><li>-i   不显示终端发出的信息。</li><li>-I   使用互动模式。</li><li>-n   程序使用时，不使用mail.rc文件中的设置。</li><li>-N   阅读邮件时，不显示邮件的标题。</li><li>-s&lt;邮件主题&gt;   指定邮件的主题。</li><li>-u&lt;用户帐号&gt;   读取指定用户的邮件。</li><li>-v   执行时，显示详细的信息。</li></ul><h3 id="mailconf"><a href="#mailconf" class="headerlink" title="mailconf"></a>mailconf</h3><p>功能说明：Sendmail设置程序。</p><p>语　　法：<code>mailconf [–addvdom&lt;虚拟网络&gt;][–delvdom&lt;虚拟网络&gt;][–help]</code></p><p>补充说明：mailconf实际为linuxconf的符号连接，用来设置Sendmail相关的选项。执行mailconf时，不管目前的环境为指令列模式或是X Window，都会出现图形界面的设置画面，让您轻松地完成设置。所有指令列的参数都可以在图形界面中设置。建议不用加上任何参数，直接进入mailconf的图形界面来设置。</p><h3 id="mailq-mail-queue"><a href="#mailq-mail-queue" class="headerlink" title="mailq(mail queue)"></a>mailq(mail queue)</h3><p>功能说明：显示待寄邮件的清单。</p><p>语　　法：<code>mailq [-q]</code></p><p>补充说明：mailq可列出待寄邮件的清单，包括邮件ID，邮件大小，邮件保存时间，寄信人，收信人，以及邮件无法寄出的原因，提供管理员参考的信息。mailq实际上是执行sendmail -bp指令。</p><p>参　　数：</p><ul><li>-v   显示较详细的信息。</li></ul><h3 id="messages"><a href="#messages" class="headerlink" title="messages"></a>messages</h3><p>功能说明：查看信箱中的邮件数。</p><p>语　　法：<code>messages [邮件目录或文件]</code></p><p>补充说明：messages实际上是一个script文件，可用来检查信箱中的邮件数。若不指定[邮件目录或文件]参数，则显示目前收件信箱中的邮件数。</p><h3 id="metamail"><a href="#metamail" class="headerlink" title="metamail"></a>metamail</h3><p>功能说明：负责处理非文字E-mail的程序。</p><p>语　　法：<code>metafile [-bBdehpPqrRTwxyz][-c&lt;邮件内容类型&gt;][-f&lt;寄信人地址&gt;][-m&lt;邮件管理程序名称&gt;][-s&lt;邮件主题&gt;][文件名]</code></p><p>补充说明：当E-mail管理程序遇到非ISO-8859-1标准文字的邮件内容，而不知道要如何处理的时候，即调用metamail。</p><p>参　　数：</p><ul><li>-b   邮件只有内文，没有表头。</li><li>-B   在背景显示信息。</li><li>-c&lt;邮件内容类型&gt;   不要读取邮件表头的”Content-type”栏位，而去读取&lt;邮件内容类型&gt;中的设置，以决定要调用哪个程序来处理邮件信息。</li><li>-d   metamail在调用其他程序显示信息前，不需向用户确认。</li><li>-e   删除内文前端的空白行。</li><li>-f&lt;寄信人地址&gt;   不要读取邮件表头中的寄信人地址，而去读取选项中的设置。</li><li>-h   使用metamail的邮件管理程序名称。</li><li>-m&lt;邮件管理程序名称&gt;   记录调用metamail的邮件管理程序名称。</li><li>-p   将显示内容送给more指令处理之后，再送到输出设备。</li><li>-P   与-p参数功能类似，但会在信息结束显示”Press RETURN to go on”字符串。</li><li>-q   metamail在调用其他程序来显示信息前，不用在屏幕上显示相关的信息。</li><li>-r   metamail预设无法让root用户执行。</li><li>-R   显示信息前先清除屏幕。</li><li>-s&lt;邮件主题&gt;   不要读取邮件表头中的邮件主题，而去读取选项中的设置。</li><li>-T   若要在一个新的终端机模拟视窗中重新启动metamail，则metamail必须以递归模式来调用程序本身，这时便需要使用-T参数。</li><li>-w   不要读取mailcap中的设置，而直接处理邮件，并将数据存入文件中。</li><li>-x   不要以终端机模式来执行，即不使用互动模式。</li><li>-y   抽出邮件内文中MIME格式的部分。</li><li>-z   程序结束时将输入的文件删除。</li></ul><h3 id="mutt"><a href="#mutt" class="headerlink" title="mutt"></a>mutt</h3><p>功能说明：E-mail管理程序。</p><p>语　　法：<code>mutt [-hnpRvxz][-a&lt;文件&gt;][-b&lt;地址&gt;][-c&lt;地址&gt;][-f&lt;邮件文件&gt;][-F&lt;配置文件&gt;][-H&lt;邮件草稿&gt;][-i&lt;文件&gt;][-m&lt;类型&gt;][-s&lt;主题&gt;][邮件地址]</code></p><p>补充说明：mutt是一个文字模式的邮件管理程序，提供了全屏幕的操作界面。</p><p>参　　数：</p><ul><li>-a&lt;文件&gt;   在邮件中加上附加文件。</li><li>-b&lt;地址&gt;   指定密件副本的收信人地址。</li><li>-c&lt;地址&gt;   指定副本的收信人地址。</li><li>-f&lt;邮件文件&gt;   指定要载入的邮件文件。</li><li>-F&lt;配置文件&gt;   指定mutt程序的设置文件，而不读取预设的.muttrc文件。</li><li>-h   显示帮助。</li><li>-H&lt;邮件草稿&gt;   将指定的邮件草稿送出。</li><li>-i&lt;文件&gt;   将指定文件插入邮件内文中。</li><li>-m&lt;类型&gt;   指定预设的邮件信箱类型。</li><li>-n   不要去读取程序培植文件(/etc/Muttrc)。</li><li>-p   在mutt中编辑完邮件后，而不想将邮件立即送出，可将该邮件暂缓寄出。</li><li>-R   以只读的方式开启邮件文件。</li><li>-s&lt;主题&gt;   指定邮件的主题。</li><li>-v   显示mutt的版本信息以及当初编译此文件时所给予的参数。</li><li>-x   模拟mailx的编辑方式。</li><li>-z   与-f参数一并使用时，若邮件文件中没有邮件即不启动mutt。</li></ul><h3 id="nntpget"><a href="#nntpget" class="headerlink" title="nntpget"></a>nntpget</h3><p>功能说明：下载新闻组文章。</p><p>语　　法：<code>nntpget [-ov][-d&lt;组类型清单&gt;][-f&lt;文件或目录&gt;][-n&lt;组名称清单&gt;][-t&lt;时间日期&gt;][-u&lt;文件或目录&gt;][新闻组服务器]</code></p><p>补充说明：执行nntpget指令将从指定的新闻组服务器下载文章。nntpget指令会从标准输入设备读取信息识别码，而下载的新闻文章则呈现到标准输出设备。</p><p>参　　数：</p><ul><li>-d&lt;组类型清单&gt;   指定新闻组类型为distribution的清单。</li><li>-f&lt;文件或目录&gt;   下载其更改时间较指定文件或目录的更改时间更接近现在的新闻文章。</li><li>-n&lt;组名称清单&gt;   指定新闻组名称的清单。</li><li>-o   下载本地主机所没有的新闻文章。</li><li>-t&lt;时间日期&gt;   指定时间与日期，较该日期时间更新的新闻文章都会被下载。</li><li>-u&lt;文件或目录&gt;   此参数的效果和指定”-f”参数类似，但它在成功下载文章之后会去更改指定文件或木的更改时间，便于下次再作为参考。</li><li>-v   当指令执行时，把每篇文章的信息识别码都送到标准输出。本参数需配合参数”-o”使用。</li></ul><h3 id="pine"><a href="#pine" class="headerlink" title="pine"></a>pine</h3><p>功能说明：收发电子邮件，浏览新闻组。</p><p>语　　法：<code>pine [-ahikorz][-attach&lt;附件&gt;][-attach_and_delete&lt;附件&gt;][-attachlist&lt;附件清单&gt;][-c&lt;邮件编号&gt;][-conf][-create_lu&lt;地址薄&gt;&lt;排序法&gt;][-f&lt;收件箱&gt;][-F&lt;文件&gt;][-I&lt;暂存快捷键&gt;][-n&lt;邮件编号&gt;][-nr][-p&lt;环境文件&gt;][-pinerc&lt;输出文件&gt;][-P&lt;配置文件&gt;][-sort&lt;排序法&gt;&lt;/reverse&gt;][-url&lt;URL&gt;][-&lt;功能选项&gt;=&lt;设置值&gt;][用户名称或电子邮件地址…]</code></p><p>补充说明：pine是个以显示导向为住的邮件处理程序，包括一般电子邮件和新闻组的文章。pine也支持MIME格式，可让用户将MIME的对象保存成文件，甚至指定外挂程序直接开启对象。</p><p>参　　数：</p><ul><li>-a   在UWIN中使用匿名模式。</li><li>-attach&lt;附件&gt;   把指定的文件附加在信件里，一并夹带寄出。</li><li>-attach_and_delete   此参数的效果和指定”-attach”参数类似，但在信件寄出后&lt;附件&gt;会将指定的文件删除。</li><li>-attachlist&lt;附件清单&gt;   设置一份文件清单，把该清单内的文件全部附加到信件中，夹带寄出。</li><li>-c&lt;邮件编号&gt;   直接开启指定编号的邮件。</li><li>-conf   产生pine.conf的范例文件，并输出到标准输出设备。</li><li>-create_lu&lt;地址薄&gt;&lt;排序法&gt;   将地址薄以指定的排序法排序，产生.addressbook.lu索引文件。</li><li>-f&lt;收件箱&gt;   开启指定的接收信件箱，而非预设的INBOX收件箱。</li><li>-F&lt;文件&gt;   直接浏览指定文件的内容。</li><li>-h   在线帮助。</li><li>-i   直接进入收件箱。</li><li>-I&lt;暂存快捷键&gt;   设置进入pine就要执行的命令，该命令以快捷键的按键指定。</li><li>-k   支持键盘上的F1,F2…等功能，而非使用一般快捷键。</li><li>-n&lt;邮件编号&gt;   设置现在的邮件编号。</li><li>-nr   使用UWIN的特殊模式。</li><li>-o   设置收件箱为只读。</li><li>-p&lt;环境文件&gt;   另外指定pine的环境文件。</li><li>-pinerc&lt;输出文件&gt;   读取.pinerc环境文件的内容并输出成文件保存起来，您必须指定输出文件的名称。</li><li>-r   展示模式。</li><li>-sort&lt;排序法&gt;   把收件箱内的信件依指定的方式排序。</li><li>-url&lt;URL&gt;   直接开启给予的URL。</li><li>-z   让pine可被Ctrl+z中断，暂存在后台作业里。</li><li>-&lt;功能选项&gt;=&lt;设置值&gt;   暂时指定各项功能的设置值。</li></ul><h3 id="slrn"><a href="#slrn" class="headerlink" title="slrn"></a>slrn</h3><p>功能说明：新闻组阅读程序。</p><p>语　　法：<code>slrn [-Cdnp][-create][-help][-f&lt;新闻组文件&gt;][-h&lt;服务器&gt;][–version]</code></p><p>补充说明：slrn是一个很容易使用的新闻组阅读程序，提供全屏幕的图形操作界面，让用户能轻松地阅读与管理新闻组。</p><p>参　　数：</p><ul><li>-C   使用彩色模式。</li><li>-d   下载组清单时，也一并下载每个组的说明。</li><li>-f&lt;新闻组文件&gt;   指定要存储组内容的文件，预设的文件名为.newsrc。</li><li>-h&lt;服务器&gt;   指定新闻组服务器。</li><li>-n   不要检查是否有新的新闻组。</li><li>-p   设置新闻组服务器的连接端口编号，预设为119。</li><li>-create   第一次连上某台新闻组服务器时，必须使用此参数，以便下载服务器中的组清单，并保存在指定的newsrc文件中。</li><li>-help   显示帮助。</li><li>–version   显示版本信息。</li></ul><h2 id="linux其他命令"><a href="#linux其他命令" class="headerlink" title="linux其他命令"></a>linux其他命令</h2><h3 id="reconfig"><a href="#reconfig" class="headerlink" title="reconfig"></a>reconfig</h3><p>功能说明：转换配置文件。</p><p>语　　法：<code>reconfig [Xconfig] XF86Config</code></p><p>补充说明：reconfig指令能将XFree86 3.1及以前的版本的配置文件，转成新的格式。现今的配置文件XF86Config，存放在/etc或/etc/X11目录下，它的格式包含了更多的信息，因此在转换之后，您还须自行编辑设置文件，输入不足的部分。</p><h3 id="startx-start-X-Window"><a href="#startx-start-X-Window" class="headerlink" title="startx(start X Window)"></a>startx(start X Window)</h3><p>功能说明：启动X Window。</p><p>语　　法：<code>startx [程序][–服务器设置]</code></p><p>补充说明：startx为启动X Window的script文件，实际上启动X Window的程序为xinit。</p><p>参　　数：</p><ul><li>[程序]   此处所指定的[程序]为X Window所要执行程序的配置文件。</li><li>[–服务器设置]   startx预设会去读取.xerverrc中的配置，决定启动X Window的方式。</li></ul><h3 id="xconfigurator"><a href="#xconfigurator" class="headerlink" title="xconfigurator"></a>xconfigurator</h3><p>功能说明：设置XFree86。</p><p>语　　法：<code>Xconfigurator [–card&lt;显卡型号&gt;][–expert][–help][–hsync”&lt;水平扫描频率&gt;”][-kickstart][–monitor&lt;显示器型号&gt;][–server&lt;显示服务器&gt;][–vsync”&lt;垂直扫描频率&gt;”]</code></p><p>补充说明：这是Red Hat公司遵循GPL规则所开发的程序，它具有互动式操作界面，您可以轻易地利用方向键和空格键等，设置显卡和显示器，并选择欲使用的画面分辨率与色彩深度，最后保存配置文件XF86Config。</p><p>参　　数：</p><ul><li>–card&lt;显卡型号&gt;   设置显卡的型号，可用”–help”参数查询型号列表。</li><li>–expert   启用专家模式，增加用户得以自行选择的项目而非由程序完全自动检测。</li><li>–help   在线帮助。</li><li>–hsync”&lt;水平扫描频率&gt;”   设置水平扫描频率。</li><li>–kickstart   启用全自动模式。</li><li>–monitor&lt;显示器型号&gt;   设置显示器型号，可用”–help”参数查询型号列表。</li><li>–server&lt;显示服务器&gt;   设置显示服务器。</li><li>–vsync”&lt;垂直扫描频率&gt;”   设置垂直扫描频率。</li></ul><h3 id="XF86Setup"><a href="#XF86Setup" class="headerlink" title="XF86Setup"></a>XF86Setup</h3><p>功能说明：设置XFee86。</p><p>语　　法：<code>XF86Setup [-display&lt;主机名称或IP地址&gt;:&lt;显示器编号&gt;][-nodialog][-sync]</code></p><p>补充说明：这是Linux系统用来设置XFee86的程序，它会进入图形模式，通过互动操作界面，让用户轻松完成XFee86环境的设置。</p><p>参　　数：</p><ul><li>-display&lt;主机名称或IP地址&gt;:&lt;显示器编号&gt;   指定显示XF86Setup设置画面的主机名称以及欲在该主机上的哪个显示器显示画面。</li><li>-nodialog   执行XF86Setup时，不显示交谈窗，直接以文字模式提出询问。</li><li>–sync   和X Server进行数据同步传输。</li></ul><h3 id="xlsatoms"><a href="#xlsatoms" class="headerlink" title="xlsatoms"></a>xlsatoms</h3><p>功能说明：列出X Server定义的成分。</p><p>语　　法：<code>xlsatoms [-display&lt;显示器编号&gt;][-format&lt;输出格式&gt;][-name&lt;成分名称&gt;][-range&lt;列表范围&gt;]</code></p><p>补充说明：执行xlsatoms指令会列出X Server内部所有定义的成分，每个成分都有其编号，您可利用参数设置列表范围，或直接指定欲查询的成分名称。</p><p>参　　数：</p><ul><li>-display&lt;显示器编号&gt;   指定X Server连接的显示器编号，该编号由”0”开始计算， 依序递增。</li><li>-format&lt;输出格式&gt;   设置成分清单的列表格式，您可使用控制字符改变显示样式。</li><li>-name&lt;成分名称&gt;   列出指定的成分。</li><li>-range&lt;列表范围&gt;   设置成分清单的列表范围。 </li></ul><h3 id="xlsclients"><a href="#xlsclients" class="headerlink" title="xlsclients"></a>xlsclients</h3><p>功能说明：列出显示器中的客户端应用程序。</p><p>语　　法：<code>xlsclients [-al][-display&lt;显示器编号&gt;][-m&lt;最大指令长度&gt;]</code></p><p>补充说明：执行xlsclients指令可列出某个显示器中，正在执行的客户端应用程序信息。</p><p>参　　数：</p><ul><li>-a   列出所有显示器的客户端应用程序信息。</li><li>-display&lt;显示器编号&gt;   指定X Server连接的显示器编号，该编号由”0”开始计算，依序递增。</li><li>-l   使用详细格式列表。</li><li>-m&lt;最大指令长度&gt;   设置显示指令信息的最大长度，单位以字符计算。</li></ul><h3 id="xlsfonts"><a href="#xlsfonts" class="headerlink" title="xlsfonts"></a>xlsfonts</h3><p>功能说明：列出X Server使用的字体。</p><p>语　　法：<code>xlsfonts [-1Clmou][-display&lt;主机名称或IP地址&gt;:&lt;显示器编号&gt;][-fn&lt;范本样式&gt;][-ll][-lll][-n&lt;显示栏位数&gt;][-w&lt;每列字符数&gt;]</code></p><p>补充说明：执行xlsfonts指令会显示目前X Server可使用的字体，也能使用范本样式仅列出的符合条件的字体。</p><p>参　　数：</p><ul><li>-1   仅用单一栏位列出字体清单。</li><li>-C   使用多个栏位列出字体清单。</li><li>-display&lt;主机名称或IP地址&gt;:&lt;显示器编号&gt;   指定显示XF86Setup设置画面的主机名称以及欲放在该主机机上的哪个显示器画面。</li><li>-fn&lt;范本样式&gt;   只列出符合范本样式指定的条件的字体。</li><li>-l   除字体名称外，同时列出字体的属性。</li><li>-ll   此参数的效果和指定”l”参数类似，但显示更详细的信息。</li><li>-lll   此参数的效果和指定”ll”参数类似，但显示更详细的信息。</li><li>-m   配合参数”-l”使用时，一并列出字体大小的上下限。</li><li>-n&lt;显示栏位数&gt;   设置每列显示的栏位数。</li><li>-o   以OpenFont的形式列出字体清单。</li><li>-u   列出字体清单时不依照其名称排序。</li><li>-w&lt;每列字符数&gt;   设置每列的最大字符数。</li></ul><h3 id="yes"><a href="#yes" class="headerlink" title="yes"></a>yes</h3><p>1.命令说明</p><pre><code>输出回应的字符串。yes回应“y”字符，后者指定字符。 </code></pre><p>2.路径</p><pre><code>/usr/bin/yes</code></pre><p>3.语法 :<code>yes [–help] [–version] string</code></p><p>4.参数</p><ul><li>–help 显示帮助字符。 –version 显示版本信息 </li></ul><p>5.相关命令</p><p>无</p><p>6.举例说明</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@bixuan/]<span class="comment">#yes "OK" //回应“OK”字符串。</span></span><br><span class="line">命令执行结果如下：</span><br><span class="line">OK</span><br><span class="line">OK</span><br><span class="line">OK </span><br><span class="line">...</span><br><span class="line">Ctrl+c //按Ctrl+c键中断</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Linux" scheme="https://www.sakuratears.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>记一次MySQL历史数据初始化的问题</title>
    <link href="https://www.sakuratears.top/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1MySQL%E5%8E%86%E5%8F%B2%E6%95%B0%E6%8D%AE%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E9%97%AE%E9%A2%98.html"/>
    <id>https://www.sakuratears.top/blog/记一次MySQL历史数据初始化的问题.html</id>
    <published>2019-09-25T14:14:00.000Z</published>
    <updated>2019-09-26T14:24:31.946Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>先说下背景吧，在某项目迭代过程中，由于系统设计问题，需要对b表新增加两个字段（证件类型type和证件号码number），这本来是一件很平常的事情。</p><p>但是对于b表的历史数据，需要对其进行初始化维护，也就是历史数据要赋值，这理论上也是一件简单的事情。</p><p>证件信息数据要从a表获取，但是a表中对于一个用户（userId）可以有多种类型证件，且证件可以被修改。</p><p>对于b表，只需要一种证件，它遵循一个规则，即证件类型有个优先级（d、b、e、c、a），取优先级最高的一张，如果证件被改动过（update_date），则从改动的证件里按照上面优先级找到一张。</p><p>看起来很懵逼，我们来分析下。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>我们先来看下a，b表结构。</p><p>对于b表，我略去部分结构，b表主要简化如下，其中type和number是我们需求新增的字段，对于历史数据，这两个字段需要维护。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`b`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'自增主键'</span>,</span><br><span class="line">  <span class="string">`user_id`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户ID'</span>,</span><br><span class="line">  <span class="string">`type`</span> <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'证件类型'</span>,</span><br><span class="line">  <span class="string">`number`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'证件号'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">1</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'b表'</span>;</span><br></pre></td></tr></table></figure><p>A表的简化如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`a`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'自增主键'</span>,</span><br><span class="line">  <span class="string">`user_id`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户ID'</span>,</span><br><span class="line">  <span class="string">`type`</span> <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'证件类型'</span>,</span><br><span class="line">  <span class="string">`number`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'证件号'</span>,</span><br><span class="line">  <span class="string">`create_date`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line">  <span class="string">`update_date`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'更新时间'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">1</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'a表'</span>;</span><br></pre></td></tr></table></figure><p>我们假设a、b表有如下数据：</p><p>b表<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`b`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>) <span class="keyword">VALUES</span> (<span class="string">'1'</span>, <span class="string">'111111'</span>, <span class="string">''</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`b`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>) <span class="keyword">VALUES</span> (<span class="string">'2'</span>, <span class="string">'222222'</span>, <span class="string">''</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`b`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>) <span class="keyword">VALUES</span> (<span class="string">'3'</span>, <span class="string">'333333'</span>, <span class="string">''</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`b`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>) <span class="keyword">VALUES</span> (<span class="string">'4'</span>, <span class="string">'444444'</span>, <span class="string">''</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`b`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>) <span class="keyword">VALUES</span> (<span class="string">'5'</span>, <span class="string">'555555'</span>, <span class="string">''</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`b`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>) <span class="keyword">VALUES</span> (<span class="string">'6'</span>, <span class="string">'666666'</span>, <span class="string">''</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`b`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>) <span class="keyword">VALUES</span> (<span class="string">'7'</span>, <span class="string">'777777'</span>, <span class="string">''</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`b`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>) <span class="keyword">VALUES</span> (<span class="string">'8'</span>, <span class="string">'888888'</span>, <span class="string">''</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`b`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>) <span class="keyword">VALUES</span> (<span class="string">'9'</span>, <span class="string">'999999'</span>, <span class="string">''</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`b`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>) <span class="keyword">VALUES</span> (<span class="string">'10'</span>, <span class="string">'111111'</span>, <span class="string">''</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></p><p>a表<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`a`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>, <span class="string">`create_date`</span>, <span class="string">`update_date`</span>) <span class="keyword">VALUES</span> (<span class="string">'1'</span>, <span class="string">'111111'</span>, <span class="string">'a'</span>, <span class="string">'123'</span>, <span class="string">'2019-09-10 14:02:46'</span>, <span class="string">'2019-09-10 14:02:46'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`a`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>, <span class="string">`create_date`</span>, <span class="string">`update_date`</span>) <span class="keyword">VALUES</span> (<span class="string">'10'</span>, <span class="string">'111111'</span>, <span class="string">'c'</span>, <span class="string">'1234'</span>, <span class="string">'2019-09-10 14:02:46'</span>, <span class="string">'2019-09-11 14:02:46'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`a`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>, <span class="string">`create_date`</span>, <span class="string">`update_date`</span>) <span class="keyword">VALUES</span> (<span class="string">'2'</span>, <span class="string">'111111'</span>, <span class="string">'d'</span>, <span class="string">'32122'</span>, <span class="string">'2019-09-10 14:02:46'</span>, <span class="string">'2019-09-11 14:02:46'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`a`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>, <span class="string">`create_date`</span>, <span class="string">`update_date`</span>) <span class="keyword">VALUES</span> (<span class="string">'12'</span>, <span class="string">'222222'</span>, <span class="string">'d'</span>, <span class="string">'32111'</span>, <span class="string">'2019-09-10 14:02:46'</span>, <span class="string">'2019-09-12 14:02:46'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`a`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>, <span class="string">`create_date`</span>, <span class="string">`update_date`</span>) <span class="keyword">VALUES</span> (<span class="string">'3'</span>, <span class="string">'333333'</span>, <span class="string">'b'</span>, <span class="string">'12131'</span>, <span class="string">'2019-09-10 14:02:46'</span>, <span class="string">'2019-09-10 14:02:46'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`a`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>, <span class="string">`create_date`</span>, <span class="string">`update_date`</span>) <span class="keyword">VALUES</span> (<span class="string">'13'</span>, <span class="string">'333333'</span>, <span class="string">'d'</span>, <span class="string">'12133'</span>, <span class="string">'2019-09-10 14:02:46'</span>, <span class="string">'2019-09-10 14:02:46'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`a`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>, <span class="string">`create_date`</span>, <span class="string">`update_date`</span>) <span class="keyword">VALUES</span> (<span class="string">'4'</span>, <span class="string">'444444'</span>, <span class="string">'b'</span>, <span class="string">'3434'</span>, <span class="string">'2019-09-10 14:02:46'</span>, <span class="string">'2019-09-10 14:02:46'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`a`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>, <span class="string">`create_date`</span>, <span class="string">`update_date`</span>) <span class="keyword">VALUES</span> (<span class="string">'14'</span>, <span class="string">'444444'</span>, <span class="string">'e'</span>, <span class="string">'34341'</span>, <span class="string">'2019-09-10 14:02:46'</span>, <span class="string">'2019-09-13 14:02:46'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`a`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>, <span class="string">`create_date`</span>, <span class="string">`update_date`</span>) <span class="keyword">VALUES</span> (<span class="string">'5'</span>, <span class="string">'555555'</span>, <span class="string">'c'</span>, <span class="string">'353452'</span>, <span class="string">'2019-09-10 14:02:46'</span>, <span class="string">'2019-09-10 14:02:46'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`a`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>, <span class="string">`create_date`</span>, <span class="string">`update_date`</span>) <span class="keyword">VALUES</span> (<span class="string">'15'</span>, <span class="string">'555555'</span>, <span class="string">'a'</span>, <span class="string">'3534599'</span>, <span class="string">'2019-09-10 14:02:46'</span>, <span class="string">'2019-09-11 14:02:46'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`a`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>, <span class="string">`create_date`</span>, <span class="string">`update_date`</span>) <span class="keyword">VALUES</span> (<span class="string">'6'</span>, <span class="string">'666666'</span>, <span class="string">'c'</span>, <span class="string">'3654688'</span>, <span class="string">'2019-09-10 14:02:46'</span>, <span class="string">'2019-09-10 14:02:46'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`a`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>, <span class="string">`create_date`</span>, <span class="string">`update_date`</span>) <span class="keyword">VALUES</span> (<span class="string">'16'</span>, <span class="string">'666666'</span>, <span class="string">'a'</span>, <span class="string">'365461'</span>, <span class="string">'2019-09-10 14:02:46'</span>, <span class="string">'2019-09-10 14:02:46'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`a`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>, <span class="string">`create_date`</span>, <span class="string">`update_date`</span>) <span class="keyword">VALUES</span> (<span class="string">'7'</span>, <span class="string">'777777'</span>, <span class="string">'d'</span>, <span class="string">'4645655'</span>, <span class="string">'2019-09-10 14:02:46'</span>, <span class="string">'2019-09-10 14:02:46'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`a`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>, <span class="string">`create_date`</span>, <span class="string">`update_date`</span>) <span class="keyword">VALUES</span> (<span class="string">'17'</span>, <span class="string">'777777'</span>, <span class="string">'b'</span>, <span class="string">'4645653'</span>, <span class="string">'2019-09-10 14:02:46'</span>, <span class="string">'2019-09-11 14:02:46'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`a`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>, <span class="string">`create_date`</span>, <span class="string">`update_date`</span>) <span class="keyword">VALUES</span> (<span class="string">'8'</span>, <span class="string">'888888'</span>, <span class="string">'d'</span>, <span class="string">'4444'</span>, <span class="string">'2019-09-10 14:02:46'</span>, <span class="string">'2019-09-11 14:02:46'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`a`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>, <span class="string">`create_date`</span>, <span class="string">`update_date`</span>) <span class="keyword">VALUES</span> (<span class="string">'18'</span>, <span class="string">'999999'</span>, <span class="string">'c'</span>, <span class="string">'44447'</span>, <span class="string">'2019-09-10 14:02:46'</span>, <span class="string">'2019-09-10 14:02:46'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`a`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>, <span class="string">`create_date`</span>, <span class="string">`update_date`</span>) <span class="keyword">VALUES</span> (<span class="string">'9'</span>, <span class="string">'999999'</span>, <span class="string">'d'</span>, <span class="string">'234243'</span>, <span class="string">'2019-09-10 14:02:46'</span>, <span class="string">'2019-09-10 14:02:46'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`a`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>, <span class="string">`create_date`</span>, <span class="string">`update_date`</span>) <span class="keyword">VALUES</span> (<span class="string">'19'</span>, <span class="string">'999999'</span>, <span class="string">'e'</span>, <span class="string">'234248'</span>, <span class="string">'2019-09-10 14:02:46'</span>, <span class="string">'2019-09-10 14:02:46'</span>);</span><br></pre></td></tr></table></figure></p><p>他们的表数据如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-520.jpg" alt="upload successful"><br><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-521.jpg" alt="upload successful"></p><p>我们根据前言里提到的规则，b表只接受该用户一张证件，优先级为（d、b、e、c、a），但是如果证件被改动过的话，就在改动列表里继续按照优先级寻找。</p><p>所以对于上面的<code>user_id = 444444</code>的用户，我们应该放入e证件，因为它被改动过；对于 <code>user_id = 111111</code>的用户，可以看到c和d都被改动过，因此从c和d里选，而不考虑a类型，d的优先级高，故最后放入d证件。</p><p>虽然程序里很好解决，但是历史数据初始化需要使用SQL处理，我们来看下。</p><p>首先要更新b表数据，这些数据应该从a表（或者a表最后经过一系列查询形成的临时表）获取并赋值，它的SQL语句部分应大致如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> b</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> (</span><br><span class="line"> <span class="keyword">SELECT</span> XXXXX <span class="keyword">from</span> a</span><br><span class="line">) <span class="keyword">AS</span> temp <span class="keyword">ON</span> b.user_id = temp.user_id</span><br><span class="line"><span class="keyword">SET</span> b.type = temp.type,</span><br><span class="line"> b.number = temp.number;</span><br></pre></td></tr></table></figure><p>这个SQL比较好理解，temp临时表部分表示我们在a里查询出一个user_id、type、number一组数据，在通过user_id相等对b表的type和number进行赋值。</p><p>接下来就是关于如何获取生成的临时表这部分了。</p><p>我们先寻找改动过的，在里面对于每个用户找到他的最高优先级的证件。</p><p>可以看到这是在MySQL中使用分组排序获取最高优先级的数据。</p><p>SQL如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    *</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span></span><br><span class="line">            user_id,</span><br><span class="line">            <span class="keyword">type</span>,</span><br><span class="line">            <span class="built_in">number</span></span><br><span class="line">        <span class="keyword">FROM</span></span><br><span class="line">            a</span><br><span class="line">        <span class="keyword">WHERE</span></span><br><span class="line">        create_date &lt;&gt; update_date</span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">            user_id,</span><br><span class="line">            (</span><br><span class="line">                <span class="keyword">CASE</span> <span class="keyword">type</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'d'</span> <span class="keyword">THEN</span></span><br><span class="line">                    <span class="number">1</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'b'</span> <span class="keyword">THEN</span></span><br><span class="line">                    <span class="number">2</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'e'</span> <span class="keyword">THEN</span></span><br><span class="line">                    <span class="number">3</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'c'</span> <span class="keyword">THEN</span></span><br><span class="line">                    <span class="number">4</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'a'</span> <span class="keyword">THEN</span></span><br><span class="line">                    <span class="number">5</span></span><br><span class="line">                <span class="keyword">END</span></span><br><span class="line">            )</span><br><span class="line">    ) <span class="keyword">AS</span> t</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    t.user_id</span><br></pre></td></tr></table></figure><p>这儿我们看到，我们这里GROUP BY了user_id 和 type，因此t表返回的每个user_id的第一条即为需要的数据，这时候对t表根据user_id进行GROUP BY，进而获取到了每个的第一条数据。</p><p>我们在获取没有改动过的，这儿要注意要除去改动过的用户证件，因为它已经包含在上面的SQL里了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    *</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span></span><br><span class="line">            user_id,</span><br><span class="line">            <span class="keyword">type</span>,</span><br><span class="line">            <span class="built_in">number</span></span><br><span class="line">        <span class="keyword">FROM</span></span><br><span class="line">            a</span><br><span class="line">        <span class="keyword">WHERE</span></span><br><span class="line">        create_date = update_date</span><br><span class="line">        <span class="keyword">AND</span> user_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">            <span class="keyword">SELECT</span></span><br><span class="line">                user_id</span><br><span class="line">            <span class="keyword">FROM</span></span><br><span class="line">                a</span><br><span class="line">            <span class="keyword">WHERE</span></span><br><span class="line">                create_date &lt;&gt; update_date</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">            user_id,</span><br><span class="line">            (</span><br><span class="line">                <span class="keyword">CASE</span> <span class="keyword">type</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'d'</span> <span class="keyword">THEN</span></span><br><span class="line">                    <span class="number">1</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'b'</span> <span class="keyword">THEN</span></span><br><span class="line">                    <span class="number">2</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'e'</span> <span class="keyword">THEN</span></span><br><span class="line">                    <span class="number">3</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'c'</span> <span class="keyword">THEN</span></span><br><span class="line">                    <span class="number">4</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'a'</span> <span class="keyword">THEN</span></span><br><span class="line">                    <span class="number">5</span></span><br><span class="line">                <span class="keyword">END</span></span><br><span class="line">            )</span><br><span class="line">    ) <span class="keyword">AS</span> t</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    t.user_id</span><br></pre></td></tr></table></figure><p>然后我们使用UNION ALL 将两部分合并。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">SELECT</span></span><br><span class="line">    *</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span></span><br><span class="line">            user_id,</span><br><span class="line">            <span class="keyword">type</span>,</span><br><span class="line">            <span class="built_in">number</span></span><br><span class="line">        <span class="keyword">FROM</span></span><br><span class="line">            a</span><br><span class="line">        <span class="keyword">WHERE</span></span><br><span class="line">        create_date &lt;&gt; update_date</span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">            user_id,</span><br><span class="line">            (</span><br><span class="line">                <span class="keyword">CASE</span> <span class="keyword">type</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'d'</span> <span class="keyword">THEN</span></span><br><span class="line">                    <span class="number">1</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'b'</span> <span class="keyword">THEN</span></span><br><span class="line">                    <span class="number">2</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'e'</span> <span class="keyword">THEN</span></span><br><span class="line">                    <span class="number">3</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'c'</span> <span class="keyword">THEN</span></span><br><span class="line">                    <span class="number">4</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'a'</span> <span class="keyword">THEN</span></span><br><span class="line">                    <span class="number">5</span></span><br><span class="line">                <span class="keyword">END</span></span><br><span class="line">            )</span><br><span class="line">    ) <span class="keyword">AS</span> t</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    t.user_id)</span><br><span class="line">    <span class="keyword">UNION</span> ALL</span><br><span class="line">(<span class="keyword">SELECT</span></span><br><span class="line">    *</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span></span><br><span class="line">            user_id,</span><br><span class="line">            <span class="keyword">type</span>,</span><br><span class="line">            <span class="built_in">number</span></span><br><span class="line">        <span class="keyword">FROM</span></span><br><span class="line">            a</span><br><span class="line">        <span class="keyword">WHERE</span></span><br><span class="line">        create_date = update_date</span><br><span class="line">        <span class="keyword">AND</span> user_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">            <span class="keyword">SELECT</span></span><br><span class="line">                user_id</span><br><span class="line">            <span class="keyword">FROM</span></span><br><span class="line">                a</span><br><span class="line">            <span class="keyword">WHERE</span></span><br><span class="line">                create_date &lt;&gt; update_date</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">            user_id,</span><br><span class="line">            (</span><br><span class="line">                <span class="keyword">CASE</span> <span class="keyword">type</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'d'</span> <span class="keyword">THEN</span></span><br><span class="line">                    <span class="number">1</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'b'</span> <span class="keyword">THEN</span></span><br><span class="line">                    <span class="number">2</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'e'</span> <span class="keyword">THEN</span></span><br><span class="line">                    <span class="number">3</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'c'</span> <span class="keyword">THEN</span></span><br><span class="line">                    <span class="number">4</span></span><br><span class="line">                <span class="keyword">WHEN</span> <span class="string">'a'</span> <span class="keyword">THEN</span></span><br><span class="line">                    <span class="number">5</span></span><br><span class="line">                <span class="keyword">END</span></span><br><span class="line">            )</span><br><span class="line">    ) <span class="keyword">AS</span> t</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    t.user_id)</span><br></pre></td></tr></table></figure><p>然后我们最后得到的SQL如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> b</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> (</span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">user_id,</span><br><span class="line"><span class="keyword">type</span>,</span><br><span class="line"><span class="built_in">number</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">a</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">create_date &lt;&gt; update_date</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">user_id,</span><br><span class="line">(</span><br><span class="line"><span class="keyword">CASE</span> <span class="keyword">type</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'d'</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'b'</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'e'</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'c'</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'a'</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">)</span><br><span class="line">) <span class="keyword">AS</span> t</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">t.user_id</span><br><span class="line">)</span><br><span class="line"><span class="keyword">UNION</span> ALL</span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">user_id,</span><br><span class="line"><span class="keyword">type</span>,</span><br><span class="line"><span class="built_in">number</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">a</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">create_date = update_date</span><br><span class="line"><span class="keyword">AND</span> user_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">user_id</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">a</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">create_date &lt;&gt; update_date</span><br><span class="line">)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">user_id,</span><br><span class="line">(</span><br><span class="line"><span class="keyword">CASE</span> <span class="keyword">type</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'d'</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'b'</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'e'</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'c'</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'a'</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">)</span><br><span class="line">) <span class="keyword">AS</span> t</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">t.user_id</span><br><span class="line">)</span><br><span class="line">) <span class="keyword">AS</span> temp <span class="keyword">ON</span> b.user_id = temp.user_id</span><br><span class="line"><span class="keyword">SET</span> b.type = temp.type,</span><br><span class="line"> b.number = temp.number;</span><br></pre></td></tr></table></figure><p>我们也可以将上面数据放入临时表中，再通过临时表插入b表，如下：</p><p>创建临时表help_temp：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TEMPORARY</span> <span class="keyword">TABLE</span> help_temp (</span><br><span class="line">user_id <span class="built_in">VARCHAR</span> (<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="keyword">type</span> <span class="built_in">VARCHAR</span> (<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="built_in">number</span> <span class="built_in">VARCHAR</span> (<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>插入临时表数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> help_temp (user_id, <span class="keyword">type</span>, <span class="built_in">number</span>) <span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(</span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">user_id,</span><br><span class="line"><span class="keyword">type</span>,</span><br><span class="line"><span class="built_in">number</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">a</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">create_date &lt;&gt; update_date</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">user_id,</span><br><span class="line">(</span><br><span class="line"><span class="keyword">CASE</span> <span class="keyword">type</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'d'</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'b'</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'e'</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'c'</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'a'</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">)</span><br><span class="line">) <span class="keyword">AS</span> t</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">t.user_id</span><br><span class="line">)</span><br><span class="line"><span class="keyword">UNION</span> ALL</span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">user_id,</span><br><span class="line"><span class="keyword">type</span>,</span><br><span class="line"><span class="built_in">number</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">a</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">create_date = update_date</span><br><span class="line"><span class="keyword">AND</span> user_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">user_id</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">a</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">create_date &lt;&gt; update_date</span><br><span class="line">)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">user_id,</span><br><span class="line">(</span><br><span class="line"><span class="keyword">CASE</span> <span class="keyword">type</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'d'</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'b'</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'e'</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'c'</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'a'</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">)</span><br><span class="line">) <span class="keyword">AS</span> t</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">t.user_id</span><br><span class="line">)</span><br><span class="line">) <span class="keyword">AS</span> temp;</span><br></pre></td></tr></table></figure><p>将临时表数据放入到b表中：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> b</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> help_temp <span class="keyword">ON</span> b.user_id = help_temp.user_id</span><br><span class="line"><span class="keyword">SET</span> b.type = help_temp.type,</span><br><span class="line"> b.number = help_temp.number;</span><br></pre></td></tr></table></figure><p>删除临时表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TEMPORARY</span> <span class="keyword">TABLE</span> help_temp;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们上述使用了<code>CASE…WHEN</code>语句，它可以跟在<code>ORDER BY</code> 或者 <code>GROUP BY</code>语句后面，可以让数据按照指定格式排序；</p><p>我们通过<code>GROUP BY</code> user_id 和 type得到一次分组结构，这分组里面的第一条即是我们要求的数据，其实这样<code>GROUP BY</code>返回的数据也是通过对user_id分组，对type排序的数据集；我们拿到user_id这一层分组的第一条即可，故得到的数据再对user_id进行<code>GROUP BY</code>即可。</p><p>使用<code>UNION ALL</code>合并两部分数据，<code>UNION ALL</code>是合并全部数据，如果只使用<code>UNION</code>，合并时相同的数据只会保留一条。</p><p>要将一张表里的数据UPDATE到另一张表里，我们这里使用了<code>INNER JOIN ON</code>语句。</p><p>最后提到了临时表，当我们处理过程较复杂时，可以加入临时表进行辅助处理数据，处理完后连接断开后临时表自动删除，当然也可以主动去删除临时表。</p><h1 id="引申"><a href="#引申" class="headerlink" title="引申"></a>引申</h1><p>我们上面所说的分组排序，相当于<code>GROUP BY</code>了两个字段，对于type来说，只能为不同的值，如果user_id,type相同，则两条数据会被分到同一组。</p><p>如下，a表我们新增一条数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`a`</span> (<span class="string">`id`</span>, <span class="string">`user_id`</span>, <span class="string">`type`</span>, <span class="string">`number`</span>, <span class="string">`create_date`</span>, <span class="string">`update_date`</span>) <span class="keyword">VALUES</span> (<span class="string">'20'</span>, <span class="string">'111111'</span>, <span class="string">'a'</span>, <span class="string">'1234'</span>, <span class="string">'2019-09-10 14:02:46'</span>, <span class="string">'2019-09-10 14:02:46'</span>);</span><br></pre></td></tr></table></figure><p>可以看到此时a表数据如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-522.jpg" alt="upload successful"></p><p>对于<code>user_id = 111111</code>的用户，他有两个相同的<code>type = a</code>的证件，这时候我们<code>GROUP BY user_id,type</code>，得到的数据这两条肯定会只取一条。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-523.jpg" alt="upload successful"></p><p>我们如果想分组排序这样肯定是不对的，因为缺失了一条数据，怎么处理呢？</p><p>一种非常简单的处理方式是再引入一个字段<code>GROUP BY</code>，比如证件号number，如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-524.jpg" alt="upload successful"></p><p>可以看到这时候数据就完全展示了。</p><p>会不会没有辅助字段可以引入呢？</p><p>实际中，只要有主键id存在，我们理论上无论如何也是可以找到辅助<code>GROUP BY</code>的字段，如上面我们使用主键id，也是可以得到user_id和type的分组排序结果的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="MySQL" scheme="https://www.sakuratears.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>排序算法（九）- Java源码中的DualPivotQuicksort</title>
    <link href="https://www.sakuratears.top/blog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B9%9D%EF%BC%89-Java%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84DualPivotQuicksort.html"/>
    <id>https://www.sakuratears.top/blog/排序算法（九）-Java源码中的DualPivotQuicksort.html</id>
    <published>2019-09-17T15:02:00.000Z</published>
    <updated>2019-09-19T14:11:22.215Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上篇文章中我们了解了双轴快排和三路快排的原理及实现，<a href="https://www.sakuratears.top/blog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89-%E5%8F%8C%E8%BD%B4%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html#more">排序算法（七） - 双轴快速排序</a>和<a href="https://www.sakuratears.top/blog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89-%E4%B8%89%E8%B7%AF%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html#more">排序算法（八） - 三路快速排序</a>，了解了虽然快速排序有着较高的效率，但是在数据坏的情况下排序速度非常不乐观。</p><p>而后提到了Java源码中的DualPivotQuicksort，它是一种混合排序算法。</p><p>而双轴快排和三路快排正是Java源码中的DualPivotQuicksort的一部分，我们来看下它吧。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>这个排序算法是Vladimir Yaroslavskiy、Jon Bentley、Josh Bloch在2011年完成的，最早见于JDK1.7版本。</p><p>它是一种混合排序算法，其内部主要包括插入排序、三路快排、双轴快排、计数排序、归并排序这几种排序算法，将几种排序算法的优点发挥出来。</p><p>在了解排序原理之前，先了解几个固定值，这几个固定值是根据大量实验确定的数据。</p><ul><li><p><strong>MAX_RUN_COUNT = 67</strong></p><p>这个值，可以用来指使用归并排序的最大RUN数量，也可以指校验数据是否可以使用归并排序的一个标准。</p><p>比如对于int型数据int[] array，DualPivotQuicksort在开始时会从数组头部开始，寻找连续有序数据段，寻找到一段，就把末尾下标记录进一个run，如果该段逆序，就把它倒过来，比如[1,2,8,5,3,2,7,1,9]，它的有序段分隔为[1,2,8][5,3,2][7,1][9]，其中[5,3,2]和[7,1]在处理过程中会倒过来，这样如果当数据量大时，明显run数量会超过67，如果超了，就直接使用优化的快排处理了。</p><p>PS：上面的例子我们可以看到最后的run为 <font color="red"></font></p><p>run[0] = 2 =  index0 -index 2= [1,2,8] ; </p><p>run[1] = 5 = index3 - index5 = [2,3,5] ; </p><p>run[2] = 7 = index6 -index7= [1,7] ; </p><p>run[3] = 8 = index8 = [9] ; </p><p></p><p>其实run[2]和run[3]是可以合并的，这样可以节省run数量。<font color="red">合并条件就是后一个run的第一个元素要大于等于前一个run的最后一个元素</font>。JDK1.8并未对这块做处理，JDK9及以上版本这块有了优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (run[count] &gt; left &amp;&amp; a[run[count]] &gt;= a[run[count] - <span class="number">1</span>]) &#123;</span><br><span class="line">  count--; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>会处理这种情况。</p><ul><li><p><strong>QUICKSORT_THRESHOLD = 286</strong></p><p>这个值表示快排阈值，如果数据量不超过286，就直接使用优化的快排处理。</p></li><li><p><strong>INSERTION_SORT_THRESHOLD = 47</strong></p><p>这个值表示插入排序阈值，对于长度小于等于这个数的数据，就使用插入排序（或变体）处理。</p></li><li><p><strong>COUNTING_SORT_THRESHOLD_FOR_BYTE = 29</strong></p><p>对于byte类型数据，如果数据长度小于等于这个值，直接使用插入排序处理。（超过会使用计数排序处理）</p></li><li><p><strong>COUNTING_SORT_THRESHOLD_FOR_SHORT_OR_CHAR = 3200</strong></p><p>对于short或者char类型数据，如果长度超过3200阈值，就会使用计数排序处理。</p></li><li><p><strong>NUM_SHORT_VALUES = 1 &lt;&lt; 16 = 65536</strong></p><p>对于short类型数据，使用计数排序时，初始化桶的数量。（-32768 &lt;= short &lt;= 32767）</p></li><li><p><strong>NUM_CHAR_VALUES = 1 &lt;&lt; 16 = 65536</strong></p><p>对于char类型数据，使用计数排序时，初始化桶的数量。（字符集范围Unicode  0-65535）</p></li><li><p><strong>NUM_BYTE_VALUES = 1 &lt;&lt; 8 = 256</strong></p><p>对于byte类型数据，使用计数排序，初始化桶的数量。（-128 &lt;= byte &lt;= 127）</p></li></ul><p>以上前五个都是大量实验确定的值。</p><p>DualPivotQuicksort的算法原理可以大致描述如下：</p><h3 id="int类型数据"><a href="#int类型数据" class="headerlink" title="int类型数据"></a>int类型数据</h3><ol><li><p>对于待排序数组<code>int[] array</code>，如果数据长度小于 <code>QUICKSORT_THRESHOLD = 286</code>，直接使用优化的快速排序<code>sort</code>；</p></li><li><p>否则校验数据，构建一个 <code>MAX_RUN_COUNT+1 = 68</code> 的数组，用来存储run，也用来校验是否可以使用归并排序或者使用优化的快排<code>sort</code>；</p></li><li><p>对于待排序数组，依次寻找连续有序数组段，将末尾index记录进run，由于会出现相等的数据值：</p><ul><li><p>JDK1.8的处理方式是统计连续相等值的数量，超过 <code>MAX_RUN_LENGTH=33</code> 时会直接使用优化后的快速排序<code>sort</code>；</p></li><li><p>JDK9及以上版本的处理方式为将这些相等值统计进了上一个run里。逆序后相邻两个run可以保持升序的也会被合并。</p><p>如上面例子：[1,2,8,5,3,2,7,1,9] 会分成[1,2,8][5,3,2][7,1][9]，倒序的逆序得到[1,2,8][2,3,5][1,7][9] 这四个run，JDK9及以上版本[1,7][9]这两个run会合并为一个[1,7,9]，得益于这个校验。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (run[count] &gt; left &amp;&amp; a[run[count]] &gt;= a[run[count] - <span class="number">1</span>]) &#123;</span><br><span class="line">            count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>如果统计过程中run数量超过<code>MAX_RUN_COUNT</code>（限制条件<code>++count == MAX_RUN_COUNT</code>），则说明数据不是高度结构化的（是杂乱无章的），就会使用优化后的快排进行处理<code>sort</code>；如果是高度结构化的（部分有序的），会使用归并排序进行处理。</p></li><li><p>再来说下优化后的快速排序<code>sort</code>：</p><ul><li><p>如果输入数据长度小于 <code>INSERTION_SORT_THRESHOLD = 47</code> ，则直接使用插入排序（或变种）进行处理。</p></li><li><p>具体使用普通的插入排序还是变种的插入排序，取决于<code>leftmost</code>这个<code>boolean</code>值，如果<code>true</code>的话就使用普通的插排；否则使用首部部分部分有序的插排（变种）。</p></li><li><p>如果长度大于等于47，就要开始真正的快排部分了，首先它会寻找5个点<code>index（e1,e2,e3,e4,e5）</code>，这5个index可以大致把数据分成等长的7份（其中<code>e3</code>近似为数据长度中点）；</p></li><li><p>对这5个index上的值进行排序同时交换了它们的位置（用的是穷举法的插入排序）；</p></li><li><p>如果这5个点的值都不相等，用 <code>array[e2]</code> 和 <code>array[e4]</code> 作为基准轴，对数据进行双轴快排处理，这里面有一点优化，（我们知道双轴快排会把数据分成3份，左部分、中间部分、右部分）就是如果中间部分长度超过4/7总长度，会跳过等于<code>pivot</code>（基准值）的元素，因为它们是相等的；</p></li><li><p>如果5个点的值全部相等，就使用三路快排处理，其轴为 <code>array[e3]</code> 即中间值（5个值都相等，较大概率说明数据的重复度很高了）。</p></li></ul></li></ol><h3 id="long类型数据"><a href="#long类型数据" class="headerlink" title="long类型数据"></a>long类型数据</h3><p>同int类型数据处理</p><h3 id="short类型数据"><a href="#short类型数据" class="headerlink" title="short类型数据"></a>short类型数据</h3><ol><li><p>对于待排序数组<code>short[] array</code>，如果数据长度大于 <code>COUNTING_SORT_THRESHOLD_FOR_SHORT_OR_CHAR = 3200</code> ，直接使用计数排序处理，计数排序的初始化桶数量为 <code>NUM_SHORT_VALUES = 65536</code>；</p></li><li><p>否则对于小于等于<code>3200</code>的数据，参考int类型处理。</p></li></ol><h3 id="char类型数据"><a href="#char类型数据" class="headerlink" title="char类型数据"></a>char类型数据</h3><p>参考short类型处理方式</p><h3 id="byte类型数据"><a href="#byte类型数据" class="headerlink" title="byte类型数据"></a>byte类型数据</h3><ol><li><p>对于待排序数组<code>byte[] array</code>，如果数据长度大于 <code>COUNTING_SORT_THRESHOLD_FOR_BYTE = 29</code> ，直接使用计数排序处理，其中初始化的桶数量为 <code>NUM_BYTE_VALUES = 256</code>；</p></li><li><p>否则数据长度小于等于<code>29</code>，直接使用插入排序法处理。</p></li></ol><h3 id="float类型数据"><a href="#float类型数据" class="headerlink" title="float类型数据"></a>float类型数据</h3><ol><li><p>对于待排序数组<code>float[] array</code>，先看看数据中有没有<code>NaN</code>这种数据，有的话直接与尾部数据交换，排序边界位置也应该缩小，因为<code>NaN</code>是无法参与比较的；</p></li><li><p>对于剩下可以比较大小的数据部分，直接参考int类型数据的处理方式；</p></li><li><p>排好后，由于可能有正0和负数0（-0.0 和 +0.0）这种数据，这种情况下负0应该在正0前面的，需要特殊处理下（程序中使用了 <code>Float.floatToRawIntBits</code>方法处理，这个可以返回浮点值的实际表示形式，可以确定正负）。</p></li></ol><h3 id="double类型数据"><a href="#double类型数据" class="headerlink" title="double类型数据"></a>double类型数据</h3><p>参考float类型处理方式</p><p>以上就是DualPivotQuicksort的逻辑原理。</p><h2 id="相关源代码"><a href="#相关源代码" class="headerlink" title="相关源代码"></a>相关源代码</h2><p>我们可以在 <code>java.util.DualPivotQuicksort</code>找到这个类，它是一个not public且final，且构造函数为private的类。</p><p>下图是我对它源码的一些解读，有兴趣的可以看看，这儿使用的是JDK1.8_131版本，在高版本的JDK中，某些部分有些改动，但不影响整体阅读。</p><p>这个源码有3000多行，考虑到文字数量及可读性问题，我使用了图片，方便大家阅读部分逻辑。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-515.jpg" alt="upload successful"><br><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-516.jpg" alt="upload successful"><br><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-517.jpg" alt="upload successful"></p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>上面我们看到Java里优化后的DualPivotQuicksort代码量是十分巨大的，这儿我们以int[]举例，来检测DualPivotQuicksort的效率问题。</p><p>我们创建几个测试数组，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 随机生成数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] randomArray(<span class="keyword">int</span> length)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = r.nextInt(length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成一个有序的倒序数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] reversalArray(<span class="keyword">int</span> length)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = a.length - i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成有个有序的正序数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] orderArray(<span class="keyword">int</span> length)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成前X部分有序后length-X部分无序的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] orderAndRandomArray(<span class="keyword">int</span> length,<span class="keyword">int</span> x)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &gt;= length)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"x不能超过length"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x; i++) &#123;</span><br><span class="line">            a[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=a.length - x;i&lt;a.length;i++ )&#123;</span><br><span class="line">            a[i] = r.nextInt(length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成前x部分无序后length-x部分有序的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] randomAndOrderArray(<span class="keyword">int</span> length,<span class="keyword">int</span> x)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &gt;= length)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"x不能超过length"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x; i++) &#123;</span><br><span class="line">            a[i] = r.nextInt(length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=a.length - x;i&lt;a.length;i++ )&#123;</span><br><span class="line">            a[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Java-DualPivotQuicksort排序开始："</span>);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        JavaDualPivotQuicksort.sort(a,<span class="number">0</span>,a.length-<span class="number">1</span>,<span class="keyword">null</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">"Java-DualPivotQuicksort耗时："</span>+(System.currentTimeMillis()-start)+<span class="string">"ms"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Java-DualPivotQuicksort排序完成！"</span>);</span><br><span class="line">        System.out.println(<span class="string">"数组是否有序："</span>+isOrdered(a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> length = <span class="number">100000000</span>;</span><br><span class="line">        <span class="comment">//随机无序数组</span></span><br><span class="line">        <span class="keyword">int</span>[] a1 = randomArray(length);</span><br><span class="line">        doSort(a1);</span><br><span class="line">        <span class="comment">//有序数组</span></span><br><span class="line">        <span class="keyword">int</span>[] a2 = orderArray(length);</span><br><span class="line">        doSort(a2);</span><br><span class="line">        <span class="comment">//逆序数组</span></span><br><span class="line">        <span class="keyword">int</span>[] a3 = reversalArray(length);</span><br><span class="line">        doSort(a3);</span><br><span class="line">        <span class="comment">//前部分有序后部分无序数组</span></span><br><span class="line">        <span class="keyword">int</span>[] a4 = orderAndRandomArray(length,length/<span class="number">3</span>);</span><br><span class="line">        doSort(a4);</span><br><span class="line">        <span class="comment">//前部分无序后部分有序数组</span></span><br><span class="line">        <span class="keyword">int</span>[] a5 = randomAndOrderArray(length,length/<span class="number">3</span>);</span><br><span class="line">        doSort(a5);</span><br><span class="line">        <span class="comment">//前部分有序后部分无序数组</span></span><br><span class="line">        <span class="keyword">int</span>[] a6 = orderAndRandomArray(length,length - length/<span class="number">3</span>);</span><br><span class="line">        doSort(a6);</span><br><span class="line">        <span class="comment">//前部分无序后部分有序数组</span></span><br><span class="line">        <span class="keyword">int</span>[] a7 = randomAndOrderArray(length,length/<span class="number">2</span>);</span><br><span class="line">        doSort(a7);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后可以得到类似的结果：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-518.jpg" alt="upload successful"></p><p>PS：我们可以使用之前提到的所有排序算法进行测试，其效率都不如该算法稳定。对于O(n^2)复杂度的排序算法，很多出现内存或者栈溢出异常。</p><p>我们进一步分析下该算法。</p><p>可以看到该算法排序取决于几个要素：<strong>数据长度、数据类型、数据是否结构化（部分有序）</strong>。</p><p>其算法比较突出的地方有以下几点：</p><ul><li><p>创建了 <code>MAX_RUN_COUNT+1</code> 个run，这个run一个重要的作用就是判断数据是否结构化，如果是的话用归并处理要快很多；如果不是，再使用快排，相比直接快排，只是浪费了一些校验时间，却规避了快排<code>O(n^2)</code>复杂度出现的情况，这也是run的数量要取合适的一个原因，算法作者通过大量实验确定了67这个数。</p></li><li><p>当对于<code>short、char、byte</code>类型数据时，由于其范围不是很大，计数排序的优势就体现出来了，因此使用了计数排序。</p></li><li><p>对数据进行快排时，首先选择了5个点，在分情况从中获取基准值，并决定使用双轴快排还是三路快排。</p><p>这儿有一点是比较有意思的，我们可以看下源码中的这个优化后的快排算法<code>sort(int[] a, int left, int right, boolean leftmost)</code>，它掺杂着双轴快排和三路快排，使用条件是看这5个点的值是否相等，也就是比如一个数组A，开始时使用了双轴快排，分成了3段A1、A2、A3，可能出现A1后面使用了三路快排（数据里重复元素较多，导致5个点的值全部相等），A2和A3继续使用双轴快排的情况。</p></li></ul><h2 id="复杂度情况"><a href="#复杂度情况" class="headerlink" title="复杂度情况"></a>复杂度情况</h2><p>该排序算法的时间复杂度如下：</p><ul><li>时间复杂度（最好）：O(n)</li><li>时间复杂度（平均）：O(n * log n)</li><li>时间复杂度（最差）：O(n * log n)</li></ul><p>该排序算法的空间复杂度最差为O(n * log n)。</p><p>该排序算法为不稳定排序算法。</p><h2 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h2><p>这个排序算法就不展示动图了。其排序流程图大致如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-519.jpg" alt="upload successful"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于该算法的主要内容基本就介绍到这里了，有兴趣的同学可以看看源代码，了解下算法中每个排序（优化排序）具体的实现过程。</p><p>可以看到JDK源代码中对于一些常用方法、工具类，是有大量优化的。</p><h1 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h1><p>上述所提到的所有Java代码均可见于我的<a href="https://github.com/javazwt" rel="external nofollow noopener noreferrer" target="_blank">Github</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>JDK1.8 <code>java.util.DualPivotQuicksort</code> 源码</li><li>JDK9.0 <code>java.util.DualPivotQuicksort</code> 源码</li><li>JDK11.0 <code>java.util.DualPivotQuicksort</code> 源码</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="DualPivotQuicksort" scheme="https://www.sakuratears.top/tags/DualPivotQuicksort/"/>
    
  </entry>
  
  <entry>
    <title>排序算法（八） - 三路快速排序</title>
    <link href="https://www.sakuratears.top/blog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89-%E4%B8%89%E8%B7%AF%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html"/>
    <id>https://www.sakuratears.top/blog/排序算法（八）-三路快速排序.html</id>
    <published>2019-09-17T14:05:00.000Z</published>
    <updated>2019-09-17T14:34:38.498Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上篇文章我们讲到了<a href="https://www.sakuratears.top/blog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89-%E5%8F%8C%E8%BD%B4%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html#more">双轴快速排序</a>，今天我们来看下快排的另一种 - 三路快速排序（ThirdWayQuickSort），也称三向切分的快速排序。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="简介及原理"><a href="#简介及原理" class="headerlink" title="简介及原理"></a>简介及原理</h2><p>三路快速排序（ThirdWayQuickSort）是如何出现的呢？</p><p>我们知道，对于待排序数组，其数据是随机的，如果数组中有大量相同元素，无论普通快排还是双轴快排，由于快速排序的判定问题，会导致这些重复数移到一边从而大幅增加算法的运算时间。</p><p>为了优化这种数据情况，进而出现了三路快速排序。</p><p>三路快速排序也是采用一个轴值pivot，那具体是哪三路呢？ </p><p>三路指的就是每分割（Partition）一次，三路排序会把数据分为小于pivot、等于pivot和大于pivot的三部分。</p><p>三路排序的大致原理如下：</p><ol><li>对于待排序数组，选取第一个元素为中轴pivot；</li><li>每次分割处理将小于pivot的数据放到左边，等于pivot的数据放在中间，大于pivot的数据放在右边；</li><li>对小于pivot和大于pivot的部分重复分割过程。</li></ol><p>我们以一个数组为例，来看下它的原理,如下图。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-510.jpg" alt="upload successful"></p><p>其算法描述如下：</p><ol><li>对于待排序数组<code>a</code>，最左索引为<code>left</code>，最右索引为<code>right</code>；</li><li>排序过程中，以<code>a[left]</code>最为<code>pivot</code>，用<code>i</code>、<code>j</code>、<code>k</code>将数组分割为4部分，其中<code>i</code>表示<code>pivot</code>元素的起始index，所有小于<code>pivot</code>的元素下标都应该小于<code>i</code>；<code>k</code>表示待扫描的元素索引从<code>i+1</code>开始，到<code>j</code>结束；<code>j</code>表示待扫描元素的最后索引；</li><li>开始时<code>i=left</code>，<code>k=left+1</code>,<code>j=right</code>,此时小于<code>pivot</code>的元素为0个，大于<code>pivot</code>的元素为0个，待扫描的元素为<code>j-k+1</code>个；</li><li>从<code>k</code>开始扫描，当该元素比<code>pivot</code>小时，交换<code>a[i]</code>和<code>a[k]</code>，同时<code>i++</code>，<code>k++</code>，这样就能把该元素放到<code>pivot</code>的左边了；</li><li>当该元素等于<code>pivot</code>时，略过即可，即<code>k++</code>；</li><li><p>当该元素大于<code>pivot</code>时，需要把它放到右边，先看下<code>a[j]</code>和<code>pivot</code>的大小。</p><p> (1) 如果<code>a[j] &gt; pivot</code>，显然它已经在右边了，我们只需<code>j–</code>即可；</p><p> (2) 如果<code>a[j] = pivot</code>，这时候我们需要交换<code>a[k]</code>和<code>a[j]</code>的位置，同时<code>k++</code>,<code>j–</code>即可；</p><p> (3) 如果<code>a[j] &lt; pivot</code>，这时候我们除了交换<code>a[k]</code>和<code>a[j]</code>位置后，继续交换<code>a[i]</code>和<code>a[k]</code>的位置，将这个小元素移到左边，同时<code>i++</code>,<code>j–</code>,<code>k++</code>;</p></li><li><p>最后数据会被分为大于<code>pivot</code>、小于<code>pivot</code>、等于<code>pivot</code>的三部分，我们对大于<code>pivot</code>和小于<code>pivot</code>的部分再进行上述逻辑，直到传入的数据长度为1，说明数据全部有序了。</p></li></ol><h2 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-511.gif" alt="upload successful"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThirdWayQuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort3Way</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归终止条件，少于等于一个元素的数组已有序</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i, j, k, pivot;</span><br><span class="line">        <span class="comment">//首元素作为中轴</span></span><br><span class="line">        pivot = a[left];</span><br><span class="line">        i = left;</span><br><span class="line">        k = left + <span class="number">1</span>;</span><br><span class="line">        j = right;</span><br><span class="line"></span><br><span class="line">        outer:</span><br><span class="line">        <span class="keyword">while</span> (k &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[k] &lt; pivot) &#123;</span><br><span class="line">                swap(a, i, k);</span><br><span class="line">                i++;</span><br><span class="line">                k++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[k] == pivot) &#123;</span><br><span class="line">                k++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">// 遇到A[k]&gt;pivot的情况，j从右向左扫描</span></span><br><span class="line">                <span class="comment">//A[j]&gt;pivot的情况,j继续向左扫描</span></span><br><span class="line">                <span class="keyword">while</span> (a[j] &gt; pivot) &#123;</span><br><span class="line">                    j--;</span><br><span class="line">                    <span class="keyword">if</span> (j &lt; k) &#123;</span><br><span class="line">                        <span class="keyword">break</span> outer;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//A[j]==pivot的情况</span></span><br><span class="line">                <span class="keyword">if</span> (a[j] == pivot) &#123;</span><br><span class="line">                    swap(a, k, j);</span><br><span class="line">                    k++;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//A[j]&lt;pivot的情况</span></span><br><span class="line">                    swap(a, i, j);</span><br><span class="line">                    swap(a, j, k);</span><br><span class="line">                    i++;</span><br><span class="line">                    k++;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//A[i, j] 等于 pivot 且位置固定，不需要参与排序</span></span><br><span class="line">        <span class="comment">// 对小于pivot的部分进行递归</span></span><br><span class="line">        quickSort3Way(a, left, i - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 对大于pivot的部分进行递归</span></span><br><span class="line">        quickSort3Way(a, j + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100000000</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">100000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"ThirdWayQuickSort排序开始："</span>);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        quickSort3Way(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"ThirdWayQuickSort耗时："</span>+(System.currentTimeMillis()-start)+<span class="string">"ms"</span>);</span><br><span class="line">        System.out.println(<span class="string">"ThirdWayQuickSort排序完成！"</span>);</span><br><span class="line">        System.out.println(<span class="string">"数组是否有序："</span>+isOrdered(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h2><p>三路快排的时间复杂度与快速排序相当：</p><ul><li>时间复杂度（最好）：O(n * log n)</li><li>时间复杂度（平均）：O(n * log n)</li><li>时间复杂度（最差）：O(n^2)</li></ul><p>三路快排的空间复杂度为O(n * log n) （递归消耗栈空间，是一种就地排序算法，如果从堆空间角度空间复杂度为O(1)）</p><p>三路快排也是一种不稳定排序算法。</p><p>相比普通快排和双轴快排，我们可以看到三路快排对于有重复数据的数组处理较佳，可以减少元素交换次数。</p><h2 id="测试相关"><a href="#测试相关" class="headerlink" title="测试相关"></a>测试相关</h2><p>我们来实际测试下，相关代码如下：</p><p>我们准备1亿数据，但是数据集范围为[0,10000)，这时候相同元素产生的就会比较多，我们分别测试下三路快排、双轴快排和普通快排。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100000000</span>];</span><br><span class="line">    Random r = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        a[i] = r.nextInt(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] b = a.clone();</span><br><span class="line">    <span class="keyword">int</span>[] c = a.clone();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"ThirdWayQuickSort排序开始："</span>);</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    quickSort3Way(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">"ThirdWayQuickSort耗时："</span>+(System.currentTimeMillis()-start)+<span class="string">"ms"</span>);</span><br><span class="line">    System.out.println(<span class="string">"ThirdWayQuickSort排序完成！"</span>);</span><br><span class="line">    System.out.println(<span class="string">"数组是否有序："</span>+isOrdered(a));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"DualPivotQuickSort排序开始："</span>);</span><br><span class="line">    <span class="keyword">long</span> start1 = System.currentTimeMillis();</span><br><span class="line">    DualPivotQuickSort.dualPivotQuickSort(b,<span class="number">0</span>,b.length-<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">"DualPivotQuickSort耗时："</span>+(System.currentTimeMillis()-start1)+<span class="string">"ms"</span>);</span><br><span class="line">    System.out.println(<span class="string">"DualPivotQuickSort排序完成！"</span>);</span><br><span class="line">    System.out.println(<span class="string">"数组是否有序："</span>+isOrdered(b));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"QuickSort排序开始："</span>);</span><br><span class="line">    <span class="keyword">long</span> start2 = System.currentTimeMillis();</span><br><span class="line">    QuickSort.quickSort(c,<span class="number">0</span>,c.length-<span class="number">1</span>,<span class="keyword">true</span>);</span><br><span class="line">    System.out.println(<span class="string">"QuickSort耗时："</span>+(System.currentTimeMillis()-start2)+<span class="string">"ms"</span>);</span><br><span class="line">    System.out.println(<span class="string">"QuickSort排序完成！"</span>);</span><br><span class="line">    System.out.println(<span class="string">"数组是否有序："</span>+isOrdered(c));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多次测试结果大致如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-512.jpg" alt="upload successful"></p><p>我们可以看到，当数据集重复元素较多时，三路快排确实有着比较优的排序效率。</p><p>我们将数据集范围改为[0,100)，效果更加明显。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    a[i] = r.nextInt(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-513.jpg" alt="upload successful"></p><p>我们增大数据集范围，改为[0,100000000)，再来测试一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    a[i] = r.nextInt(<span class="number">100000000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-514.jpg" alt="upload successful"></p><p>可以看到三路快排效率比不上双轴快排了，因为这种情况下，重复元素较少，三路快排基本退化为普通快排。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过对三路快排（ThirdWayQuickSort）的介绍，我们大致了解了它的一些原理和排序过程，快速排序主要就有普通快排、三路快排和双轴快排三种。</p><p>在数据集元素重复较多的情况下，三路快排有着显著的优势，因此它和双轴快排一起，作为了Java对基本数据类型排序方法实现的一部分。</p><h1 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h1><p>本篇文章提到的所有代码均可见于我的<a href="https://github.com/javazwt" rel="external nofollow noopener noreferrer" target="_blank">GitHub</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="排序算法" scheme="https://www.sakuratears.top/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
      <category term="sort" scheme="https://www.sakuratears.top/tags/sort/"/>
    
      <category term="三路快排" scheme="https://www.sakuratears.top/tags/%E4%B8%89%E8%B7%AF%E5%BF%AB%E6%8E%92/"/>
    
  </entry>
  
  <entry>
    <title>排序算法（七） - 双轴快速排序</title>
    <link href="https://www.sakuratears.top/blog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89-%E5%8F%8C%E8%BD%B4%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html"/>
    <id>https://www.sakuratears.top/blog/排序算法（七）-双轴快速排序.html</id>
    <published>2019-09-13T07:55:00.000Z</published>
    <updated>2019-09-13T09:18:02.449Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上篇文章我们介绍了TimSort排序算法，<a href="https://www.sakuratears.top/blog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89-TimSort.html#more">排序算法（六）- TimSort</a>，今天我们再来看一种排序算法，双轴快速排序（DualPivotQuicksort），这个排序算法也是非常有意思的，它也是目前Java对于基本数据类型数组排序使用的内置排序算法。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="双轴快速排序（DualPivotQuicksort）"><a href="#双轴快速排序（DualPivotQuicksort）" class="headerlink" title="双轴快速排序（DualPivotQuicksort）"></a>双轴快速排序（DualPivotQuicksort）</h2><h3 id="简介及原理"><a href="#简介及原理" class="headerlink" title="简介及原理"></a>简介及原理</h3><p>双轴快速排序（DualPivotQuicksort）是Vladimir Yaroslavskiy在2009年开发出来的一种排序算法，是<a href="https://www.sakuratears.top/blog/Java%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%88Quick-Sort%EF%BC%89">快速排序</a>的一种变体，与快排不同的是，它有两个基准值（快排有一个）。</p><p>相比快速排序，双轴快速排序有着更高的效率，我们来看下。</p><p>我们先来回顾下快速排序，快排的主要原理如下：</p><pre><code>对于待排序数组，选择一个基数(pivot)，然后把比它小的那些数放在它的左边，把比它大的那些数放在它的右边，然后再对这个数左右两部分数递归的执行快排过程，直到子数组只剩一个数为止。</code></pre><p>如下图所示。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-504.jpg" alt="upload successful"></p><p>而双轴快速排序会把待排序数组分为3份，有两个基准点，我们先来看下双轴快排的伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sort A[left..right]</span></span><br><span class="line">dual_pivot_quicksort(A,left,right) </span><br><span class="line">    <span class="keyword">if</span> right−left ≥ <span class="number">1</span></span><br><span class="line">        p := min &#123;A[left],A[right]&#125;</span><br><span class="line">        q := max&#123;A[left],A[right]&#125;</span><br><span class="line">        ℓ := left +<span class="number">1</span>; g := right −<span class="number">1</span>; k := ℓ</span><br><span class="line">        <span class="keyword">while</span> k ≤ g</span><br><span class="line">            <span class="keyword">if</span> A[k] &lt; p</span><br><span class="line">                 Swap A[k] and A[ℓ]; ℓ := ℓ+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> A[k] ≥ q</span><br><span class="line">                <span class="keyword">while</span> A[g] &gt; q and k &lt; g</span><br><span class="line">                    g := g −<span class="number">1</span></span><br><span class="line">                end <span class="keyword">while</span></span><br><span class="line">                Swap A[k] and A[g]; g := g −<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> A[k] &lt; p</span><br><span class="line">                    Swap A[k] and A[ℓ]; ℓ := ℓ+<span class="number">1</span></span><br><span class="line">                end <span class="keyword">if</span></span><br><span class="line">            end <span class="keyword">if</span></span><br><span class="line">            k := k +<span class="number">1</span></span><br><span class="line">        end <span class="keyword">while</span></span><br><span class="line">        ℓ := ℓ−<span class="number">1</span>; g := g +<span class="number">1</span></span><br><span class="line">        <span class="comment">// p to final position</span></span><br><span class="line">        A[left] := A[ℓ]; A[ℓ] := p </span><br><span class="line">        <span class="comment">// q to final position</span></span><br><span class="line">        A[right] := A[g]; A[g] := q </span><br><span class="line">        dual_pivot_quicksort(A, left , ℓ−<span class="number">1</span>)</span><br><span class="line">        dual_pivot_quicksort(A, ℓ+<span class="number">1</span>,g −<span class="number">1</span>)</span><br><span class="line">        dual_pivot_quicksort(A,g +<span class="number">1</span>,right)</span><br><span class="line">    end <span class="keyword">if</span></span><br></pre></td></tr></table></figure><p>它的原理图如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-505.jpg" alt="upload successful"></p><p>双轴快速排序的工作原理：</p><pre><code>对于待排序数组，取最小索引上的值和最大索引上的值为基准，根据这两个基准，可以把数组分成小于最小基准的一部分、大于最小基准小于最大基准的一部分、大于最大基准的一部分，共三部分；再对这三部分进行双轴快速排序。</code></pre><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>我们根据伪代码，可以写出双轴快排的具体代码，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DualPivotQuickSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dualPivotQuickSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//根据两个基准将数据分成三部分</span></span><br><span class="line">        <span class="keyword">if</span> (right - left &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> pivot1 = Math.min(a[left], a[right]);</span><br><span class="line">            <span class="keyword">int</span> pivot2 = Math.max(a[left], a[right]);</span><br><span class="line">            <span class="keyword">int</span> start = left + <span class="number">1</span>, end = right - <span class="number">1</span>, tempIndex = start;</span><br><span class="line">            <span class="keyword">while</span> (tempIndex &lt;= end) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[tempIndex] &lt; pivot1) &#123;</span><br><span class="line">                    swap(a, tempIndex, start);</span><br><span class="line">                    start++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[tempIndex] &gt;= pivot2) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (a[end] &gt; pivot2 &amp;&amp; tempIndex &lt; end) &#123;</span><br><span class="line">                        end--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    swap(a, tempIndex, end);</span><br><span class="line">                    end--;</span><br><span class="line">                    <span class="keyword">if</span> (a[tempIndex] &lt; pivot1) &#123;</span><br><span class="line">                        swap(a, tempIndex, start);</span><br><span class="line">                        start++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                tempIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">            start--;</span><br><span class="line">            end++;</span><br><span class="line">            <span class="comment">//分完堆后两个基准的位置还不对，需要将这两个基准移动到正确位置</span></span><br><span class="line">            a[left] = a[start];</span><br><span class="line">            a[start] = pivot1;</span><br><span class="line">            a[right] = a[end];</span><br><span class="line">            a[end] = pivot2;</span><br><span class="line">            <span class="comment">//对分成的三部分继续进行双轴快排</span></span><br><span class="line">            dualPivotQuickSort(a, left, start - <span class="number">1</span>);</span><br><span class="line">            dualPivotQuickSort(a, start + <span class="number">1</span>, end - <span class="number">1</span>);</span><br><span class="line">            dualPivotQuickSort(a, end + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100000000</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">100000000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"DualPivotQuicksort排序开始："</span>);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        dualPivotQuickSort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"DualPivotQuicksort耗时："</span> + (System.currentTimeMillis() - start) + <span class="string">"ms"</span>);</span><br><span class="line">        System.out.println(<span class="string">"DualPivotQuicksort排序完成！"</span>);</span><br><span class="line">        System.out.println(<span class="string">"数组是否有序："</span> + isOrdered(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们继续使用1亿数据量对其进行测试，可得到如下结果：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-506.jpg" alt="upload successful"></p><p>可以看到双轴快排排序1亿数据耗时在9s左右，我们在<a href="https://www.sakuratears.top/blog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89-%E5%8F%8C%E8%B0%83%E6%8E%92%E5%BA%8F.html">排序算法（五）-双调排序</a>中测过1亿数据情况下普通快速排序耗时大概在12s左右。</p><p>我们也可以测试大量数据，实际上，双轴快排效率是要优于普通快排的。</p><h3 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h3><p>下面视频演示了在一定数据量下的排序过程。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-507.gif" alt="upload successful"></p><h3 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><p>我们来分析下双轴快排的复杂度情况。</p><p>我们知道，对于递归，其时间复杂度公式如下：</p><pre><code>T[n] = aT[n/b] + f(n)</code></pre><p>我们对于普通快速排序，最好情况下，很容易得到其时间复杂度公式：</p><pre><code>T[n] = 2T[n/2] + n</code></pre><p>其中 T[n/2]为平分后的子数组的时间复杂度，n 是划分两部分数组所需要的时间。这个公式表示快排每次正好可以把序列分成两个相等的子序列。其中T[0] = T[1] = 1。</p><p>迭代求公式有可以得到时间复杂度如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-508.jpg" alt="upload successful"></p><p>对于双轴快速排序，我们在最优情况下可以得到其时间复杂度公式：</p><pre><code>T[n] = 3T[n/3]+n</code></pre><p>其中 T[n/3]为平分后的子数组的时间复杂度，n 是划分两部分数组所需要的时间。这个公式表示快排每次正好可以把序列分成三个相等的子序列。其中T[0] = T[1] = 1。</p><p>迭代求公式有可以得到时间复杂度如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-509.jpg" alt="upload successful"></p><p>可以看到双轴快速排序的时间复杂度也是O(n * log n)级别的。</p><p>双轴快速排序的时间复杂度：</p><pre><code>时间复杂度（最好）：O(n * log n)时间复杂度（平均）：O(n * log n)时间复杂度（最差）：O(n^2)</code></pre><p>对于空间复杂度，每次递归需要一定栈空间保存结果，其栈空间复杂度公式：</p><pre><code>S[n] = 3S[n/3] + n</code></pre><p>其中 T[n/3]为平分后的子数组的空间复杂度，n 是保存此层递归结果所需要的空间。这个公式表示快排每次正好可以把序列分成三个相等的子序列。其中T[0] = T[1] = 1。</p><p>根据这个公式可以得到双轴快排的栈空间复杂度是O(n * log n)级别的，但是双轴快排却不消耗堆空间，其堆空间复杂度为O(1)。</p><p>双轴快速排序的空间复杂度：</p><pre><code>就地排序算法的空间复杂度为O(1)，如果考虑到递归调用占用系统资源，它的空间复杂度为O(n * log n)</code></pre><p>双轴快速排序也是一种不稳定排序算法。</p><h3 id="双轴快速排序为什么比普通快排要快"><a href="#双轴快速排序为什么比普通快排要快" class="headerlink" title="双轴快速排序为什么比普通快排要快"></a>双轴快速排序为什么比普通快排要快</h3><p>关于双轴快速排序有一篇论文 <a href="https://arxiv.org/pdf/1511.01138.pdf" rel="external nofollow noopener noreferrer" target="_blank">Why Is Dual-Pivot Quicksort Fast?</a>，有兴趣的可以看一下。</p><p>论文中详细介绍了为什么相比普通快排，双轴快速排序要快。</p><p>论文中提到双轴快速排序的<strong>元素比较次数</strong>是要比普通快排要多的。</p><p>它们的比较次数比值大致如下：</p><pre><code>DualPivotQuickSort vs QuickSort    =&gt;    1.7043nlnn  vs  1.5697nlnn</code></pre><p>一般排序算法中元素比较次数越多其耗费的时间越高，可是双轴快排却和普通快排呈现了两种不同的结果，这样理论与实验是相矛盾的。</p><p>论文作者提到在我们在排序时不仅要考虑元素比较次数，还应该考虑 <strong>CPU的速度，内存的速度，CPU和内存速度是否匹配</strong> 等的影响。</p><p>作者提出了“内存墙”问题：</p><pre><code>据统计在过去的25年里面，CPU的速度平均每年增长46%, 而内存的带宽每年只增长37%，那么经过25年的这种不均衡发展，它们之间的差距已经蛮大了。假如这种不均衡持续持续发展，有一天CPU速度再增长也不会让程序变得更快，因为CPU始终在等待内存传输数据，这就是传说中内存墙(Memory Wall)。</code></pre><p>同时给出了另一种比较排序算法优劣的方法：<strong>扫描元素个数算法</strong>。</p><p>在这种新的算法里面，我们把对于数组里面一个元素的访问: array[i] 称为一次扫描。但是对于同一个下标，并且对应的值也不变的话，即使访问多次我们也只算一次。而且我们不管这个访问到底是读还是写。</p><p>为什么只算一次呢？因为在CPU高速缓存下，再次访问数组同一下标下的元素要比访问一个新的下标元素的时间少很多。（缓存级别vs内存级别）</p><p>因为内存比较慢，统计CPU与内存之间的数据流量的大小也就把这个比较慢的内存的因素考虑进去了，因此也就比元素比较次数更能体现算法在当下计算机里面的性能指标。</p><p>在这种新算法下，作者计算的两种排序算法的<strong>扫描元素个数</strong>之比为：</p><pre><code>DualPivotQuickSort vs QuickSort    =&gt;    1.4035nlnn  vs  1.5697nlnn</code></pre><p>也就是普通快排要比双轴快排多扫描了12%的元素，也相当于节约了大概12%的时间，在实际实验过程中来看，节约了10%左右的时间。</p><p>具体的计算过程可参考论文中的一些计算公式。</p><h3 id="Java中的DualPivotQuicksort"><a href="#Java中的DualPivotQuicksort" class="headerlink" title="Java中的DualPivotQuicksort"></a>Java中的DualPivotQuicksort</h3><p>在看这个问题之前，我们先来构造一个完全倒序的数组，比如1亿数据量，来测试DualPivotQuicksort。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100000000</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = <span class="number">100000000</span> - i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"DualPivotQuicksort排序开始："</span>);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        dualPivotQuickSort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"DualPivotQuicksort耗时："</span> + (System.currentTimeMillis() - start) + <span class="string">"ms"</span>);</span><br><span class="line">        System.out.println(<span class="string">"DualPivotQuicksort排序完成！"</span>);</span><br><span class="line">        System.out.println(<span class="string">"数组是否有序："</span> + isOrdered(a));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们运行这个测试类，后面会等待很久然后出现栈溢出异常，原因很简单，这种情况下，双轴快排退化成冒泡排序（与普通快排类似），时间复杂度为O(n^2)。</p><p>这是我们无法忍受的。</p><p>作为一款优秀的排序算法，不仅要求其能适应最好情况和一般情况，更重要的是要其在最差情况下效率也要高效。更不用说如果作为一种语言的源代码的基础包里的部分了。</p><p>因此Java里的排序算法是有大量优化的。</p><p>我们在Java源代码中可以找到类 <code>DualPivotQuicksort.java</code>，它是<code>Arrays.sort</code>底层代码实现的一部分（另一部分是TimSort）,主要对于基本数据类型进行排序（不需要考虑稳定性）。</p><p>我们看到它是一种混合排序算法，而不单单是双轴快排。</p><p>其内部使用了插入排序、归并排序、双轴快速排序、单轴（普通）快速排序、计数排序等排序算法。</p><p>关于这个排序的分析我将在下篇文章介绍下。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于双轴排序算法的内容就聊到这儿，本文介绍了双轴快排的实现原理及一些特点。</p><p>在下篇文章里我会介绍下Java源代码里的DualPivotQuicksort，这个类由Vladimir Yaroslavskiy、Jon Bentley、Josh Bloch编写，是一个高效的排序算法。</p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>文中涉及到的程序代码详见我的 <a href="https://github.com/JavaZWT" rel="external nofollow noopener noreferrer" target="_blank">Github</a>。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://arxiv.org/pdf/1511.01138.pdf" rel="external nofollow noopener noreferrer" target="_blank">Why Is Dual-Pivot Quicksort Fast?</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="排序算法" scheme="https://www.sakuratears.top/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
      <category term="Sort" scheme="https://www.sakuratears.top/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>排序算法（六）- TimSort</title>
    <link href="https://www.sakuratears.top/blog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89-TimSort.html"/>
    <id>https://www.sakuratears.top/blog/排序算法（六）-TimSort.html</id>
    <published>2019-09-07T14:41:00.000Z</published>
    <updated>2019-09-08T01:45:18.059Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们在上篇文章 <a href="https://www.sakuratears.top/blog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89-%E5%8F%8C%E8%B0%83%E6%8E%92%E5%BA%8F.html#more">排序算法（五）-双调排序</a> 介绍了双调排序，今天我们来看一下另一种排序算法 —— TimSort。</p><p>TimSort是Tim Peters发明的一种混合排序，最早是Python语言的内置排序算法。</p><p>关于Python内置的TimSort描述可以查看该 <a href="http://svn.python.org/projects/python/trunk/Objects/listsort.txt" rel="external nofollow noopener noreferrer" target="_blank">文档</a>。</p><p>关于TimSort的理论基础，可以查看该篇论文 <a href="https://www.researchgate.net/publication/220778904_Optimistic_Sorting_and_Information_Theoretic_Complexity" rel="external nofollow noopener noreferrer" target="_blank">Optimistic Sorting and Information Theoretic Complexity</a>，这篇论文论证了插入排序和归并排序合并后效率提高的可能性，即TimSort的理论基础。</p><p>Java自Java 7 后加入TimSort，其实现参考了Python版本的实现，我们可以在JDK源码的util包下找到它，<code>java.util.TimSort</code>，这个class不是public的，我们无法直接调用，只能够通过Java提供的sort方法等间接调用它。</p><p>为什么引入了TimSort呢？我们慢慢来看下吧。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="TimSort的排序原理"><a href="#TimSort的排序原理" class="headerlink" title="TimSort的排序原理"></a>TimSort的排序原理</h2><p>说到排序算法，我们就先来了解下排序算法的基本原理，这样有助于我们更快理解算法本身。</p><p>TimSort作为一种混合排序算法，其内部使用了插入排序（准确的说是<a href="https://www.sakuratears.top/blog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89.html#%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%88BinaryInsertionSort%EF%BC%89">二分插入排序</a>）和<a href="https://www.sakuratears.top/blog/Java%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%88Merge-Sort%EF%BC%89">归并排序</a>。</p><p>根据我们之前说到的，归并排序是一种时间复杂度很平均（O(n * log n) 排序算法，其缺点一个是如果两个序列长度相差较大（一个长序列和一个短序列归并），排序效率无法体现；另一个是当数组长度很小时，归并的效率也不是很高且浪费空间。</p><p>对于插入排序，虽然时间复杂度为（O(n^2)），但是较小数据量下，其表现也不错，在一部分数据已经排序的情况下，其表现要更好，而使用插入排序的变种二分插入排序，虽不能减少移动次数，但减少了比较次数。</p><p>说到这里，我们再说TimSort基于的一个简单事实：数组中的数据都是部分有序（升序或降序）的。</p><p>什么意思呢？ 比如 数组[9,8,5,7,3,9,1,3,4,6,0,5,3]，可以看到里面部分数据[9,8,5],[1,3,4,6]等等有序。</p><p>这对插入排序是十分友好的。</p><p>Timsort排序算法可以概括成如下几步：</p><ol><li>把待排数组划分成一个个run，当然run不能太短，长度最小阈值为minRun；</li><li>run的划分规则：从数组最小下标low开始，寻找连续有序部分（连续逆序也算，寻找的时候会把这段顺序反过来），如果这段有序部分长度小于minRun，就用二分插入排序补充到minRun；</li><li><p>将run入栈，当栈顶的run的长度不满足下列约束条件中任意一个时，</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">runLen[n-<span class="number">1</span>] &gt; runLen[n] + runLen[n+<span class="number">1</span>]</span><br><span class="line">runLen[n] &gt; runLen[n+<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p> 则利用归并排序将其中最短的2个run合并成一个新run；</p></li><li>最后会有一次强制合并合并所有栈内剩余所有run，最终栈空，生成有序数组。</li></ol><p>TimSort算法的原理可以用下图大致表示：</p><p>这儿我们设minRun = 4.</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-500.jpg" alt="upload successful"></p><p>如上图可以清晰的看到TimSort的排序过程。</p><h2 id="TimSort源码分析"><a href="#TimSort源码分析" class="headerlink" title="TimSort源码分析"></a>TimSort源码分析</h2><p>下面我们来分析下TimSort的源码。</p><p>它的主要入口为sort方法，sort方法参数说明如下：</p><pre><code>T[] a : 表示待排序数组；int lo：排序的起始位置，如果排整个数组传0即可；int hi：排序的终止位置，排整个数组传数组长度n即可；Comparator&lt;? super T&gt; c：数据的比较规则；T[] work： 合并所需的临时存储空间设置，一般不需要我们设置，会有默认值，传null即可；int workBase ：合并所需的临时存储空间分片基数值，一般不需要我们设置，会有默认值，传0即可；int workLen：合并所需的临时存储空间默认长度，一般不需要我们设置，会有默认值，传0即可。</code></pre><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-501.jpg" alt="upload successful"></p><p>可以看到传入的排序位置lo和hi，如果长度小于2，直接返回，如果小于32，就做mini-TimSort，迷你TimSort就相当于上面图中说的部分有序的二分插入排序。</p><p>再来看下下面部分。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-502.jpg" alt="upload successful"></p><p>TimSort先计算出该数组的minRun，然后开始处理数据，拿到有序长度，判断是否小于minRun，小于的话就用插入排序补齐，然后入栈，看看是否需要进行归并排序，移动位置到下一个run，重复上述过程，最后在进行一次归并排序，得到有序数据。</p><p><strong>二分插入排序法的源码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">binarySort</span><span class="params">(T[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> start,Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> lo &lt;= start &amp;&amp; start &lt;= hi;</span><br><span class="line">    <span class="keyword">if</span> (start == lo)</span><br><span class="line">        start++;</span><br><span class="line">    <span class="keyword">for</span> ( ; start &lt; hi; start++) &#123;</span><br><span class="line">        T pivot = a[start];</span><br><span class="line">        <span class="comment">// Set left (and right) to the index where a[start] (pivot) belongs</span></span><br><span class="line">        <span class="keyword">int</span> left = lo;</span><br><span class="line">        <span class="keyword">int</span> right = start;</span><br><span class="line">        <span class="keyword">assert</span> left &lt;= right;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Invariants:</span></span><br><span class="line"><span class="comment">         *   pivot &gt;= all in [lo, left).</span></span><br><span class="line"><span class="comment">         *   pivot &lt;  all in [right, start).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (c.compare(pivot, a[mid]) &lt; <span class="number">0</span>)</span><br><span class="line">                right = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">assert</span> left == right;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * The invariants still hold: pivot &gt;= all in [lo, left) and</span></span><br><span class="line"><span class="comment">         * pivot &lt; all in [left, start), so pivot belongs at left.  Note</span></span><br><span class="line"><span class="comment">         * that if there are elements equal to pivot, left points to the</span></span><br><span class="line"><span class="comment">         * first slot after them -- that's why this sort is stable.</span></span><br><span class="line"><span class="comment">         * Slide elements over to make room for pivot.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> n = start - left;  <span class="comment">// The number of elements to move</span></span><br><span class="line">        <span class="comment">// Switch is just an optimization for arraycopy in default case</span></span><br><span class="line">        <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:  a[left + <span class="number">2</span>] = a[left + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:  a[left + <span class="number">1</span>] = a[left];</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: System.arraycopy(a, left, a, left + <span class="number">1</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">        a[left] = pivot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>计算有序部分长度（如果逆序有序就把数据处理成正序）的源码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">int</span> <span class="title">countRunAndMakeAscending</span><span class="params">(T[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi,Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> lo &lt; hi;</span><br><span class="line">    <span class="keyword">int</span> runHi = lo + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (runHi == hi)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// Find end of run, and reverse range if descending</span></span><br><span class="line">    <span class="keyword">if</span> (c.compare(a[runHi++], a[lo]) &lt; <span class="number">0</span>) &#123; <span class="comment">// Descending</span></span><br><span class="line">        <span class="keyword">while</span> (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - <span class="number">1</span>]) &lt; <span class="number">0</span>)</span><br><span class="line">            runHi++;</span><br><span class="line">        reverseRange(a, lo, runHi);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                              <span class="comment">// Ascending</span></span><br><span class="line">        <span class="keyword">while</span> (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - <span class="number">1</span>]) &gt;= <span class="number">0</span>)</span><br><span class="line">            runHi++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> runHi - lo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverseRange</span><span class="params">(Object[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    hi--;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        Object t = a[lo];</span><br><span class="line">        a[lo++] = a[hi];</span><br><span class="line">        a[hi--] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取该数组的minRun的相关代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minRunLength</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> n &gt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>;      <span class="comment">// Becomes 1 if any 1 bits are shifted off</span></span><br><span class="line">    <span class="keyword">while</span> (n &gt;= MIN_MERGE) &#123;</span><br><span class="line">        r |= (n &amp; <span class="number">1</span>);</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n + r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到如果入参n小于MIN_MERGE（32）时，会直接返回n，因为太小了；如果n恰好是2的幂，则返回MIN_MERGE/2；否则返回一个int k, MIN_MERGE/2 &lt;= k &lt;= MIN_MERGE，使n/k接近但小于2的幂次值。</p><p>关于这样设计的基本原理，可以查看Tim在Python上关于它的描述文档 <a href="http://svn.python.org/projects/python/trunk/Objects/listsort.txt" rel="external nofollow noopener noreferrer" target="_blank">listsort.txt</a>。</p><p><strong>检测并合并不符合条件的栈元素的相关代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeCollapse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (stackSize &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = stackSize - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span> &amp;&amp; runLen[n-<span class="number">1</span>] &lt;= runLen[n] + runLen[n+<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (runLen[n - <span class="number">1</span>] &lt; runLen[n + <span class="number">1</span>])</span><br><span class="line">                n--;</span><br><span class="line">            mergeAt(n);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (runLen[n] &lt;= runLen[n + <span class="number">1</span>]) &#123;</span><br><span class="line">            mergeAt(n);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// Invariant is established</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到它的合并条件，如上面提到的。</p><p>关于它的合并方法<code>mergeAt</code>，内容较多，在这儿就不展示了。</p><p><strong>最后强制合并栈元素的代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeForceCollapse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (stackSize &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = stackSize - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span> &amp;&amp; runLen[n - <span class="number">1</span>] &lt; runLen[n + <span class="number">1</span>])</span><br><span class="line">            n--;</span><br><span class="line">        mergeAt(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法最终会将栈内元素合并为1个，即run[0],即有序数组。</p><p><strong>初始化栈空间及归并缓存空间代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">TimSort</span><span class="params">(T[] a, Comparator&lt;? <span class="keyword">super</span> T&gt; c, T[] work, <span class="keyword">int</span> workBase, <span class="keyword">int</span> workLen)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.a = a;</span><br><span class="line">     <span class="keyword">this</span>.c = c;</span><br><span class="line">     <span class="comment">// Allocate temp storage (which may be increased later if necessary)</span></span><br><span class="line">     <span class="keyword">int</span> len = a.length;</span><br><span class="line">     <span class="keyword">int</span> tlen = (len &lt; <span class="number">2</span> * INITIAL_TMP_STORAGE_LENGTH) ?</span><br><span class="line">         len &gt;&gt;&gt; <span class="number">1</span> : INITIAL_TMP_STORAGE_LENGTH;</span><br><span class="line">     <span class="keyword">if</span> (work == <span class="keyword">null</span> || workLen &lt; tlen || workBase + tlen &gt; work.length) &#123;</span><br><span class="line">         <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"UnnecessaryLocalVariable"</span>&#125;)</span><br><span class="line">         T[] newArray = (T[])java.lang.reflect.Array.newInstance</span><br><span class="line">             (a.getClass().getComponentType(), tlen);</span><br><span class="line">         tmp = newArray;</span><br><span class="line">         tmpBase = <span class="number">0</span>;</span><br><span class="line">         tmpLen = tlen;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         tmp = work;</span><br><span class="line">         tmpBase = workBase;</span><br><span class="line">         tmpLen = workLen;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> stackLen = (len &lt;    <span class="number">120</span>  ?  <span class="number">5</span> :</span><br><span class="line">                     len &lt;   <span class="number">1542</span>  ? <span class="number">10</span> :</span><br><span class="line">                     len &lt; <span class="number">119151</span>  ? <span class="number">24</span> : <span class="number">49</span>);</span><br><span class="line">     runBase = <span class="keyword">new</span> <span class="keyword">int</span>[stackLen];</span><br><span class="line">     runLen = <span class="keyword">new</span> <span class="keyword">int</span>[stackLen];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="Java版本TimSort曾经的Bug"><a href="#Java版本TimSort曾经的Bug" class="headerlink" title="Java版本TimSort曾经的Bug"></a>Java版本TimSort曾经的Bug</h2><p>在JDK1.7时候，TimSort曾经有一个bug，会引发数组下标越界异常。</p><p>PS：这个Bug已经被fix了。</p><p>bug详情可参考如下链接 <a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=8011944" rel="external nofollow noopener noreferrer" target="_blank">JDK-8011944 : Sort fails with ArrayIndexOutOfBoundsException</a>。</p><p>关于这篇bug的发现验证解决可参考这篇pdf,<a href="http://envisage-project.eu/wp-content/uploads/2015/02/sorting.pdf" rel="external nofollow noopener noreferrer" target="_blank">OpenJDK’s java.utils.Collection.sort() is broken:The good, the bad and the worst case?</a>。</p><p>我们这儿简单说下这个bug吧。</p><p>上面我们看到TimSort栈内元素合并的条件，它的目的在于尽量保证两个要进行归并排序的数组长度大致相同。</p><p>所以栈内所有run应该满足如下条件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> &lt;= i &lt;= StackSize-<span class="number">1</span></span><br><span class="line">runLen[n-<span class="number">1</span>] &gt; runLen[n] + runLen[n+<span class="number">1</span>]</span><br><span class="line">runLen[n] &gt; runLen[n+<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>我们看<code>mergeCollapse</code>方法也能验证这一点。</p><p>大多数情况下我们检查栈顶的3个元素就能满足约束条件，但是一些特殊情况下就不行了，比如下面的这个栈：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">120, 80, 25, 20, 30</span><br></pre></td></tr></table></figure></p><p>根据源码，因为25 &lt; 20 + 30，25 &lt; 30，所以将25和20两个run进行合并，此时栈内的情况变为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">120, 80, 45, 30</span><br></pre></td></tr></table></figure></p><p>由于80 &gt; 45 + 30，45 &gt; 30，满足约束条件，此时归并就终止了。但是注意栈里的其他run，120 &lt; 80 + 45，这是不满足约束条件的，而由于我们只判断了栈顶的run，因此在这里就留下了“隐患”。</p><p>大多数情况下，这并不是什么问题，因为TimSort最终可以通过最后的强制归并将数据排序合并。</p><p>但是Bug发现者构造了一个非常精致的Array，成功的让Timsort算法抛出java.lang.ArrayIndexOutOfBoundsException，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BreakTimSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN=<span class="number">16</span>;</span><br><span class="line">    ArrayDeque&lt;Integer&gt; chunks = <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BOUND1 = <span class="number">2</span>*MIN+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BOUND2 = BOUND1+MIN+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BOUND3 = BOUND1+<span class="number">1</span>+BOUND2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BOUND4 = BOUND2+<span class="number">1</span>+BOUND3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BOUND5 = BOUND3+<span class="number">1</span>+BOUND4;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> B)</span> </span>&#123;</span><br><span class="line">        chunks.addFirst(B);</span><br><span class="line">        <span class="keyword">if</span> (size &lt; BOUND1) &#123;</span><br><span class="line">            chunks.addFirst(size);</span><br><span class="line">            <span class="keyword">return</span> size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> asize = (size+<span class="number">2</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (size &gt;= BOUND2 &amp;&amp; asize &lt; BOUND1)</span><br><span class="line">            asize = BOUND1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (size &gt;= BOUND3 &amp;&amp; asize &lt; BOUND2)</span><br><span class="line">            asize = BOUND2;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (size &gt;= BOUND4 &amp;&amp; asize &lt; BOUND3)</span><br><span class="line">            asize = BOUND3;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (size &gt;= BOUND5 &amp;&amp; asize &lt; BOUND4)</span><br><span class="line">            asize = BOUND4;</span><br><span class="line">        <span class="keyword">if</span> (size - asize &gt;= B)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError( <span class="string">"  "</span> +size+ <span class="string">" , "</span> +asize+ <span class="string">" , "</span> +B);</span><br><span class="line">        <span class="keyword">return</span> build (asize, size - asize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        chunks.addFirst(MIN);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> B = MIN+<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> A = B + MIN + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> eps = build(A, B);</span><br><span class="line">            B = B+A+<span class="number">1</span>;</span><br><span class="line">            A = B+eps + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        chunks.addFirst(B);</span><br><span class="line">        chunks.addFirst(A);</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer len: chunks) &#123;</span><br><span class="line">            total += len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pow = MIN;</span><br><span class="line">        <span class="keyword">while</span> (pow &lt; total)</span><br><span class="line">            pow += pow;</span><br><span class="line">        chunks.addLast(pow-total);</span><br><span class="line">        System.err.println( <span class="string">" Total:  "</span> +total);</span><br><span class="line">        Object[] array = <span class="keyword">new</span> Object[pow];</span><br><span class="line">        <span class="keyword">int</span> off = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer len: chunks) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                array[pos++] = Integer.valueOf(i == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            off++;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(array);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] param)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> BreakTimSort().run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS:这段代码我们现在测试是没有问题的，因为这个bug已经被Fix了，如果想复现这个bug，可以下载 JDK - 1.7.0_07 版本。</p><p>这个bug出现的原因是TimSort初始化时会申请栈空间，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> stackLen = (len &lt;    <span class="number">120</span>  ?  <span class="number">5</span> :</span><br><span class="line">                        len &lt;   <span class="number">1542</span>  ? <span class="number">10</span> :</span><br><span class="line">                        len &lt; <span class="number">119151</span>  ? <span class="number">24</span> : <span class="number">49</span>);</span><br><span class="line">        runBase = <span class="keyword">new</span> <span class="keyword">int</span>[stackLen];</span><br><span class="line">        runLen = <span class="keyword">new</span> <span class="keyword">int</span>[stackLen];</span><br></pre></td></tr></table></figure><p>在JDK - 1.7.0_07版本它是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> stackLen = (len &lt;    <span class="number">120</span>  ?  <span class="number">5</span> :</span><br><span class="line">                len &lt;   <span class="number">1542</span>  ? <span class="number">10</span> :</span><br><span class="line">                len &lt; <span class="number">119151</span>  ? <span class="number">19</span> : <span class="number">40</span>);</span><br><span class="line">        runBase = <span class="keyword">new</span> <span class="keyword">int</span>[stackLen];</span><br><span class="line">        runLen = <span class="keyword">new</span> <span class="keyword">int</span>[stackLen];</span><br></pre></td></tr></table></figure><p>可以看到有几个数字不一样，是的，不要小看这几个“魔法”数字。</p><p>这几个数字怎么来呢？ 我们栈归并的条件上面有提到，它其实就是函数 F(n) &lt; F(n-1) + F(n-2) +1，我们设F(n) = F(n-1) + F(n-2) +1，这个函数是不是很熟悉，在 <a href="https://www.sakuratears.top/blog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89.html#%E5%B9%B3%E6%BB%91%E6%8E%92%E5%BA%8F%EF%BC%88SmoothSort%EF%BC%89">SmoothSort</a>里我们有提到过，不过我们这里的起始是0，第一个元素是minRun。</p><p>我们设minRun为16（上面的<code>minRunLength</code>方法，可以看到minRun最小值为MIN_MERGE/2 = 16），如下程序：</p><p>PS:minRun越小，数组长度固定的情况下，分的份数就越多，理论需要的栈数量也越多。栈数量要多，少的话可能出现数组下标越界问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] k = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">5</span>,<span class="number">10</span>,<span class="number">19</span>,<span class="number">40</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">0</span>;p&lt;k.length;p++)&#123;</span><br><span class="line">        <span class="keyword">long</span> sum =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k[p];i++)&#123;</span><br><span class="line">            sum += function(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(k[p] +<span class="string">"---&gt;"</span>+sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">function</span><span class="params">(<span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n ==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">16</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> function(n-<span class="number">1</span>) + function(n-<span class="number">2</span>)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5---&gt;119</span><br><span class="line">10---&gt;1541</span><br><span class="line">19---&gt;119150</span><br><span class="line">40---&gt;2917196495</span><br></pre></td></tr></table></figure><p>当为40的时候已经超出了int最大值。</p><p>上述数据是在理想情况下，即 F(n) = F(n-1) + F(n-2) +1，但是实际上会有不满足的情况，这时候需要的栈大小就应该大一些，因而就出现了我们上述所说的异常。</p><p>关于实际需要的栈大小，上面PDF中给出了，可以直接查看，如下：</p><table><thead><tr><th>array size</th><th>64</th><th>128</th><th>160</th><th>65536</th><th>131072</th><th>67108864</th><th>1073741824</th></tr></thead><tbody><tr><td>required stack size</td><td>3</td><td>4</td><td>5</td><td>21</td><td>23</td><td>41</td><td>49</td></tr><tr><td>runLen.length</td><td>5</td><td>10</td><td>10</td><td>19 (24)</td><td>40</td><td>40</td><td>40</td></tr></tbody></table><p>可以看到JDK1.8中长度已经变为了5,10,24,49，相当于修复了这个bug。</p><p>上述PDF中还给出了一种出现无法合并的栈的情况的解决方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeCollapse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (stackSize &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = stackSize - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span> &amp;&amp; runLen[n-<span class="number">1</span>] &lt;=runLen[n] + runLen[n + <span class="number">1</span>]</span><br><span class="line">                ||n-<span class="number">1</span> &gt; <span class="number">0</span> &amp;&amp; runLen[n-<span class="number">2</span>] &lt;=runLen[n] + runLen[n-<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">if</span> (runLen[n-<span class="number">1</span>] &lt;runLen[n + <span class="number">1</span>]) &#123;</span><br><span class="line">                n--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">0</span> || runLen[n] &gt; runLen[n + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// Invariant is established</span></span><br><span class="line">        &#125;</span><br><span class="line">        mergeAt(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于增加了<code> n-1 &gt; 0 &amp;&amp; runLen[n-2] &lt;= runLen[n] + runLen[n-1]</code> 这部分，把栈顶的第4个元素也加入了判断。</p><p>但是Java社区JDK1.8中并未采用这段代码，还是原来的3层栈元素判断，只是变更了栈的长度作为解决办法，原因不详。</p><p>以上就是TimSort曾经出现的bug。</p><h2 id="测试TimSort"><a href="#测试TimSort" class="headerlink" title="测试TimSort"></a>测试TimSort</h2><p>我们将TimSort源码中的泛型去掉，排序数组改为int[]，测试下TimSort的性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_MERGE = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  MIN_GALLOP = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minGallop = MIN_GALLOP;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_TMP_STORAGE_LENGTH = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] tmp;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tmpBase;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tmpLen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stackSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] runBase;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] runLen;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">TimSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] work, <span class="keyword">int</span> workBase, <span class="keyword">int</span> workLen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Allocate temp storage (which may be increased later if necessary)</span></span><br><span class="line">        <span class="keyword">int</span> len = a.length;</span><br><span class="line">        <span class="keyword">int</span> tlen = (len &lt; <span class="number">2</span> * INITIAL_TMP_STORAGE_LENGTH) ?</span><br><span class="line">                len &gt;&gt;&gt; <span class="number">1</span> : INITIAL_TMP_STORAGE_LENGTH;</span><br><span class="line">        <span class="keyword">if</span> (work == <span class="keyword">null</span> || workLen &lt; tlen || workBase + tlen &gt; work.length) &#123;</span><br><span class="line">            tmp = <span class="keyword">new</span> <span class="keyword">int</span>[tlen];</span><br><span class="line">            tmpBase = <span class="number">0</span>;</span><br><span class="line">            tmpLen = tlen;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp = work;</span><br><span class="line">            tmpBase = workBase;</span><br><span class="line">            tmpLen = workLen;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> stackLen = (len &lt;    <span class="number">120</span>  ?  <span class="number">5</span> :</span><br><span class="line">                len &lt;   <span class="number">1542</span>  ? <span class="number">10</span> :</span><br><span class="line">                        len &lt; <span class="number">119151</span>  ? <span class="number">24</span> : <span class="number">49</span>);</span><br><span class="line">        runBase = <span class="keyword">new</span> <span class="keyword">int</span>[stackLen];</span><br><span class="line">        runLen = <span class="keyword">new</span> <span class="keyword">int</span>[stackLen];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi,<span class="keyword">int</span>[] work, <span class="keyword">int</span> workBase, <span class="keyword">int</span> workLen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> a != <span class="keyword">null</span> &amp;&amp; lo &gt;= <span class="number">0</span> &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= a.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> nRemaining  = hi - lo;</span><br><span class="line">        <span class="keyword">if</span> (nRemaining &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;  <span class="comment">// Arrays of size 0 and 1 are always sorted</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If array is small, do a "mini-TimSort" with no merges</span></span><br><span class="line">        <span class="keyword">if</span> (nRemaining &lt; MIN_MERGE) &#123;</span><br><span class="line">            <span class="keyword">int</span> initRunLen = countRunAndMakeAscending(a, lo, hi);</span><br><span class="line">            binarySort(a, lo, hi, lo + initRunLen);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TimSort ts = <span class="keyword">new</span> TimSort(a,work, workBase, workLen);</span><br><span class="line">        <span class="keyword">int</span> minRun = minRunLength(nRemaining);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// Identify next run</span></span><br><span class="line">            <span class="keyword">int</span> runLen = countRunAndMakeAscending(a, lo, hi);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If run is short, extend to min(minRun, nRemaining)</span></span><br><span class="line">            <span class="keyword">if</span> (runLen &lt; minRun) &#123;</span><br><span class="line">                <span class="keyword">int</span> force = nRemaining &lt;= minRun ? nRemaining : minRun;</span><br><span class="line">                binarySort(a, lo, lo + force, lo + runLen);</span><br><span class="line">                runLen = force;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Push run onto pending-run stack, and maybe merge</span></span><br><span class="line">            ts.pushRun(lo, runLen);</span><br><span class="line">            ts.mergeCollapse();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Advance to find next run</span></span><br><span class="line">            lo += runLen;</span><br><span class="line">            nRemaining -= runLen;</span><br><span class="line">        &#125; <span class="keyword">while</span> (nRemaining != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Merge all remaining runs to complete sort</span></span><br><span class="line">        <span class="keyword">assert</span> lo == hi;</span><br><span class="line">        ts.mergeForceCollapse();</span><br><span class="line">        <span class="keyword">assert</span> ts.stackSize == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binarySort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> lo &lt;= start &amp;&amp; start &lt;= hi;</span><br><span class="line">        <span class="keyword">if</span> (start == lo) &#123;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ( ; start &lt; hi; start++) &#123;</span><br><span class="line">            <span class="keyword">int</span> pivot = a[start];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Set left (and right) to the index where a[start] (pivot) belongs</span></span><br><span class="line">            <span class="keyword">int</span> left = lo;</span><br><span class="line">            <span class="keyword">int</span> right = start;</span><br><span class="line">            <span class="keyword">assert</span> left &lt;= right;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Invariants:</span></span><br><span class="line"><span class="comment">             *   pivot &gt;= all in [lo, left).</span></span><br><span class="line"><span class="comment">             *   pivot &lt;  all in [right, start).</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (pivot&lt;a[mid]) &#123;</span><br><span class="line">                    right = mid;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">assert</span> left == right;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// The number of elements to move</span></span><br><span class="line">            <span class="keyword">int</span> n = start - left;</span><br><span class="line">            <span class="comment">// Switch is just an optimization for arraycopy in default case</span></span><br><span class="line">            <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:  a[left + <span class="number">2</span>] = a[left + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:  a[left + <span class="number">1</span>] = a[left];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: System.arraycopy(a, left, a, left + <span class="number">1</span>, n);</span><br><span class="line">            &#125;</span><br><span class="line">            a[left] = pivot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countRunAndMakeAscending</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> lo &lt; hi;</span><br><span class="line">        <span class="keyword">int</span> runHi = lo + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (runHi == hi) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find end of run, and reverse range if descending</span></span><br><span class="line">        <span class="comment">// Descending</span></span><br><span class="line">        <span class="keyword">if</span> (a[runHi++]&lt; a[lo]) &#123;</span><br><span class="line">            <span class="keyword">while</span> (runHi &lt; hi &amp;&amp; a[runHi]&lt; a[runHi - <span class="number">1</span>]) &#123;</span><br><span class="line">                runHi++;</span><br><span class="line">            &#125;</span><br><span class="line">            reverseRange(a, lo, runHi);</span><br><span class="line">        <span class="comment">// Ascending</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (runHi &lt; hi &amp;&amp; a[runHi]&gt;= a[runHi - <span class="number">1</span>]) &#123;</span><br><span class="line">                runHi++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> runHi - lo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverseRange</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        hi--;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = a[lo];</span><br><span class="line">            a[lo++] = a[hi];</span><br><span class="line">            a[hi--] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minRunLength</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> n &gt;= <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// Becomes 1 if any 1 bits are shifted off</span></span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt;= MIN_MERGE) &#123;</span><br><span class="line">            r |= (n &amp; <span class="number">1</span>);</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n + r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushRun</span><span class="params">(<span class="keyword">int</span> runBase, <span class="keyword">int</span> runLen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.runBase[stackSize] = runBase;</span><br><span class="line">        <span class="keyword">this</span>.runLen[stackSize] = runLen;</span><br><span class="line">        stackSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeCollapse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (stackSize &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = stackSize - <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (n &gt; <span class="number">0</span> &amp;&amp; runLen[n-<span class="number">1</span>] &lt;= runLen[n] + runLen[n+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (runLen[n - <span class="number">1</span>] &lt; runLen[n + <span class="number">1</span>]) &#123;</span><br><span class="line">                    n--;</span><br><span class="line">                &#125;</span><br><span class="line">                mergeAt(n);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (runLen[n] &lt;= runLen[n + <span class="number">1</span>]) &#123;</span><br><span class="line">                mergeAt(n);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// Invariant is established</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeForceCollapse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (stackSize &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = stackSize - <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (n &gt; <span class="number">0</span> &amp;&amp; runLen[n - <span class="number">1</span>] &lt; runLen[n + <span class="number">1</span>]) &#123;</span><br><span class="line">                n--;</span><br><span class="line">            &#125;</span><br><span class="line">            mergeAt(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeAt</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> stackSize &gt;= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">assert</span> i &gt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">assert</span> i == stackSize - <span class="number">2</span> || i == stackSize - <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> base1 = runBase[i];</span><br><span class="line">        <span class="keyword">int</span> len1 = runLen[i];</span><br><span class="line">        <span class="keyword">int</span> base2 = runBase[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> len2 = runLen[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">assert</span> len1 &gt; <span class="number">0</span> &amp;&amp; len2 &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">assert</span> base1 + len1 == base2;</span><br><span class="line"></span><br><span class="line">        runLen[i] = len1 + len2;</span><br><span class="line">        <span class="keyword">if</span> (i == stackSize - <span class="number">3</span>) &#123;</span><br><span class="line">            runBase[i + <span class="number">1</span>] = runBase[i + <span class="number">2</span>];</span><br><span class="line">            runLen[i + <span class="number">1</span>] = runLen[i + <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        stackSize--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> k = gallopRight(a[base2], a, base1, len1, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">assert</span> k &gt;= <span class="number">0</span>;</span><br><span class="line">        base1 += k;</span><br><span class="line">        len1 -= k;</span><br><span class="line">        <span class="keyword">if</span> (len1 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        len2 = gallopLeft(a[base1 + len1 - <span class="number">1</span>], a, base2, len2, len2 - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">assert</span> len2 &gt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (len2 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Merge remaining runs, using tmp array with min(len1, len2) elements</span></span><br><span class="line">        <span class="keyword">if</span> (len1 &lt;= len2) &#123;</span><br><span class="line">            mergeLo(base1, len1, base2, len2);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            mergeHi(base1, len1, base2, len2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gallopLeft</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span>[] a, <span class="keyword">int</span> base, <span class="keyword">int</span> len, <span class="keyword">int</span> hint)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> len &gt; <span class="number">0</span> &amp;&amp; hint &gt;= <span class="number">0</span> &amp;&amp; hint &lt; len;</span><br><span class="line">        <span class="keyword">int</span> lastOfs = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ofs = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (key&gt; a[base + hint]) &#123;</span><br><span class="line">            <span class="comment">// Gallop right until a[base+hint+lastOfs] &lt; key &lt;= a[base+hint+ofs]</span></span><br><span class="line">            <span class="keyword">int</span> maxOfs = len - hint;</span><br><span class="line">            <span class="keyword">while</span> (ofs &lt; maxOfs &amp;&amp; key&gt; a[base + hint + ofs]) &#123;</span><br><span class="line">                lastOfs = ofs;</span><br><span class="line">                ofs = (ofs &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// int overflow</span></span><br><span class="line">                <span class="keyword">if</span> (ofs &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    ofs = maxOfs;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ofs &gt; maxOfs) &#123;</span><br><span class="line">                ofs = maxOfs;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Make offsets relative to base</span></span><br><span class="line">            lastOfs += hint;</span><br><span class="line">            ofs += hint;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// key &lt;= a[base + hint]</span></span><br><span class="line">            <span class="comment">// Gallop left until a[base+hint-ofs] &lt; key &lt;= a[base+hint-lastOfs]</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> maxOfs = hint + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (ofs &lt; maxOfs &amp;&amp; key&lt;= a[base + hint - ofs]) &#123;</span><br><span class="line">                lastOfs = ofs;</span><br><span class="line">                ofs = (ofs &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// int overflow</span></span><br><span class="line">                <span class="keyword">if</span> (ofs &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    ofs = maxOfs;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ofs &gt; maxOfs) &#123;</span><br><span class="line">                ofs = maxOfs;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Make offsets relative to base</span></span><br><span class="line">            <span class="keyword">int</span> tmp = lastOfs;</span><br><span class="line">            lastOfs = hint - ofs;</span><br><span class="line">            ofs = hint - tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">assert</span> -<span class="number">1</span> &lt;= lastOfs &amp;&amp; lastOfs &lt; ofs &amp;&amp; ofs &lt;= len;</span><br><span class="line"></span><br><span class="line">        lastOfs++;</span><br><span class="line">        <span class="keyword">while</span> (lastOfs &lt; ofs) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = lastOfs + ((ofs - lastOfs) &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (key&gt; a[base + m]) &#123;</span><br><span class="line">                <span class="comment">// a[base + m] &lt; key</span></span><br><span class="line">                lastOfs = m + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// key &lt;= a[base + m]</span></span><br><span class="line">                ofs = m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// so a[base + ofs - 1] &lt; key &lt;= a[base + ofs]</span></span><br><span class="line">        <span class="keyword">assert</span> lastOfs == ofs;</span><br><span class="line">        <span class="keyword">return</span> ofs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gallopRight</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span>[] a, <span class="keyword">int</span> base, <span class="keyword">int</span> len,<span class="keyword">int</span> hint)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> len &gt; <span class="number">0</span> &amp;&amp; hint &gt;= <span class="number">0</span> &amp;&amp; hint &lt; len;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ofs = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> lastOfs = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (key&lt; a[base + hint]) &#123;</span><br><span class="line">            <span class="comment">// Gallop left until a[b+hint - ofs] &lt;= key &lt; a[b+hint - lastOfs]</span></span><br><span class="line">            <span class="keyword">int</span> maxOfs = hint + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (ofs &lt; maxOfs &amp;&amp; key&lt; a[base + hint - ofs]) &#123;</span><br><span class="line">                lastOfs = ofs;</span><br><span class="line">                ofs = (ofs &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// int overflow</span></span><br><span class="line">                <span class="keyword">if</span> (ofs &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    ofs = maxOfs;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ofs &gt; maxOfs) &#123;</span><br><span class="line">                ofs = maxOfs;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Make offsets relative to b</span></span><br><span class="line">            <span class="keyword">int</span> tmp = lastOfs;</span><br><span class="line">            lastOfs = hint - ofs;</span><br><span class="line">            ofs = hint - tmp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// a[b + hint] &lt;= key</span></span><br><span class="line">            <span class="comment">// Gallop right until a[b+hint + lastOfs] &lt;= key &lt; a[b+hint + ofs]</span></span><br><span class="line">            <span class="keyword">int</span> maxOfs = len - hint;</span><br><span class="line">            <span class="keyword">while</span> (ofs &lt; maxOfs &amp;&amp; key&gt;= a[base + hint + ofs]) &#123;</span><br><span class="line">                lastOfs = ofs;</span><br><span class="line">                ofs = (ofs &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// int overflow</span></span><br><span class="line">                <span class="keyword">if</span> (ofs &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    ofs = maxOfs;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ofs &gt; maxOfs) &#123;</span><br><span class="line">                ofs = maxOfs;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Make offsets relative to b</span></span><br><span class="line">            lastOfs += hint;</span><br><span class="line">            ofs += hint;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">assert</span> -<span class="number">1</span> &lt;= lastOfs &amp;&amp; lastOfs &lt; ofs &amp;&amp; ofs &lt;= len;</span><br><span class="line"></span><br><span class="line">        lastOfs++;</span><br><span class="line">        <span class="keyword">while</span> (lastOfs &lt; ofs) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = lastOfs + ((ofs - lastOfs) &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (key&lt; a[base + m]) &#123;</span><br><span class="line">                <span class="comment">// key &lt; a[b + m]</span></span><br><span class="line">                ofs = m;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// a[b + m] &lt;= key</span></span><br><span class="line">                lastOfs = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// so a[b + ofs - 1] &lt;= key &lt; a[b + ofs]</span></span><br><span class="line">        <span class="keyword">assert</span> lastOfs == ofs;</span><br><span class="line">        <span class="keyword">return</span> ofs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeLo</span><span class="params">(<span class="keyword">int</span> base1, <span class="keyword">int</span> len1, <span class="keyword">int</span> base2, <span class="keyword">int</span> len2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> len1 &gt; <span class="number">0</span> &amp;&amp; len2 &gt; <span class="number">0</span> &amp;&amp; base1 + len1 == base2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Copy first run into temp array</span></span><br><span class="line">        <span class="comment">// For performance</span></span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">this</span>.a;</span><br><span class="line">        <span class="keyword">int</span>[] tmp = ensureCapacity(len1);</span><br><span class="line">        <span class="comment">// Indexes into tmp array</span></span><br><span class="line">        <span class="keyword">int</span> cursor1 = tmpBase;</span><br><span class="line">        <span class="comment">// Indexes int a</span></span><br><span class="line">        <span class="keyword">int</span> cursor2 = base2;</span><br><span class="line">        <span class="comment">// Indexes int a</span></span><br><span class="line">        <span class="keyword">int</span> dest = base1;</span><br><span class="line">        System.arraycopy(a, base1, tmp, cursor1, len1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Move first element of second run and deal with degenerate cases</span></span><br><span class="line">        a[dest++] = a[cursor2++];</span><br><span class="line">        <span class="keyword">if</span> (--len2 == <span class="number">0</span>) &#123;</span><br><span class="line">            System.arraycopy(tmp, cursor1, a, dest, len1);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len1 == <span class="number">1</span>) &#123;</span><br><span class="line">            System.arraycopy(a, cursor2, a, dest, len2);</span><br><span class="line">            <span class="comment">// Last elt of run 1 to end of merge</span></span><br><span class="line">            a[dest + len2] = tmp[cursor1];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> minGallop = <span class="keyword">this</span>.minGallop;</span><br><span class="line">        outer:</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// Number of times in a row that first run won</span></span><br><span class="line">            <span class="keyword">int</span> count1 = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// Number of times in a row that second run won</span></span><br><span class="line">            <span class="keyword">int</span> count2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">assert</span> len1 &gt; <span class="number">1</span> &amp;&amp; len2 &gt; <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (a[cursor2]&lt; tmp[cursor1]) &#123;</span><br><span class="line">                    a[dest++] = a[cursor2++];</span><br><span class="line">                    count2++;</span><br><span class="line">                    count1 = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (--len2 == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span> outer;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    a[dest++] = tmp[cursor1++];</span><br><span class="line">                    count1++;</span><br><span class="line">                    count2 = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (--len1 == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span> outer;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((count1 | count2) &lt; minGallop);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">assert</span> len1 &gt; <span class="number">1</span> &amp;&amp; len2 &gt; <span class="number">0</span>;</span><br><span class="line">                count1 = gallopRight(a[cursor2], tmp, cursor1, len1, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (count1 != <span class="number">0</span>) &#123;</span><br><span class="line">                    System.arraycopy(tmp, cursor1, a, dest, count1);</span><br><span class="line">                    dest += count1;</span><br><span class="line">                    cursor1 += count1;</span><br><span class="line">                    len1 -= count1;</span><br><span class="line">                    <span class="comment">// len1 == 1 || len1 == 0</span></span><br><span class="line">                    <span class="keyword">if</span> (len1 &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span> outer;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                a[dest++] = a[cursor2++];</span><br><span class="line">                <span class="keyword">if</span> (--len2 == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span> outer;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                count2 = gallopLeft(tmp[cursor1], a, cursor2, len2, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (count2 != <span class="number">0</span>) &#123;</span><br><span class="line">                    System.arraycopy(a, cursor2, a, dest, count2);</span><br><span class="line">                    dest += count2;</span><br><span class="line">                    cursor2 += count2;</span><br><span class="line">                    len2 -= count2;</span><br><span class="line">                    <span class="keyword">if</span> (len2 == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span> outer;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                a[dest++] = tmp[cursor1++];</span><br><span class="line">                <span class="keyword">if</span> (--len1 == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span> outer;</span><br><span class="line">                &#125;</span><br><span class="line">                minGallop--;</span><br><span class="line">            &#125; <span class="keyword">while</span> (count1 &gt;= MIN_GALLOP | count2 &gt;= MIN_GALLOP);</span><br><span class="line">            <span class="keyword">if</span> (minGallop &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                minGallop = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Penalize for leaving gallop mode</span></span><br><span class="line">            minGallop += <span class="number">2</span>;</span><br><span class="line">        &#125;  <span class="comment">// End of "outer" loop</span></span><br><span class="line">        <span class="comment">// Write back to field</span></span><br><span class="line">        <span class="keyword">this</span>.minGallop = minGallop &lt; <span class="number">1</span> ? <span class="number">1</span> : minGallop;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len1 == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">assert</span> len2 &gt; <span class="number">0</span>;</span><br><span class="line">            System.arraycopy(a, cursor2, a, dest, len2);</span><br><span class="line">            <span class="comment">//  Last elt of run 1 to end of merge</span></span><br><span class="line">            a[dest + len2] = tmp[cursor1];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len1 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"Comparison method violates its general contract!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">assert</span> len2 == <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">assert</span> len1 &gt; <span class="number">1</span>;</span><br><span class="line">            System.arraycopy(tmp, cursor1, a, dest, len1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeHi</span><span class="params">(<span class="keyword">int</span> base1, <span class="keyword">int</span> len1, <span class="keyword">int</span> base2, <span class="keyword">int</span> len2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> len1 &gt; <span class="number">0</span> &amp;&amp; len2 &gt; <span class="number">0</span> &amp;&amp; base1 + len1 == base2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Copy second run into temp array</span></span><br><span class="line">        <span class="comment">// For performance</span></span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">this</span>.a;</span><br><span class="line">        <span class="keyword">int</span>[] tmp = ensureCapacity(len2);</span><br><span class="line">        <span class="keyword">int</span> tmpBase = <span class="keyword">this</span>.tmpBase;</span><br><span class="line">        System.arraycopy(a, base2, tmp, tmpBase, len2);</span><br><span class="line">        <span class="comment">// Indexes into a</span></span><br><span class="line">        <span class="keyword">int</span> cursor1 = base1 + len1 - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// Indexes into tmp array</span></span><br><span class="line">        <span class="keyword">int</span> cursor2 = tmpBase + len2 - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// Indexes into a</span></span><br><span class="line">        <span class="keyword">int</span> dest = base2 + len2 - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Move last element of first run and deal with degenerate cases</span></span><br><span class="line">        a[dest--] = a[cursor1--];</span><br><span class="line">        <span class="keyword">if</span> (--len1 == <span class="number">0</span>) &#123;</span><br><span class="line">            System.arraycopy(tmp, tmpBase, a, dest - (len2 - <span class="number">1</span>), len2);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len2 == <span class="number">1</span>) &#123;</span><br><span class="line">            dest -= len1;</span><br><span class="line">            cursor1 -= len1;</span><br><span class="line">            System.arraycopy(a, cursor1 + <span class="number">1</span>, a, dest + <span class="number">1</span>, len1);</span><br><span class="line">            a[dest] = tmp[cursor2];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> minGallop = <span class="keyword">this</span>.minGallop;</span><br><span class="line">        outer:</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// Number of times in a row that first run won</span></span><br><span class="line">            <span class="keyword">int</span> count1 = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// Number of times in a row that second run won</span></span><br><span class="line">            <span class="keyword">int</span> count2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">assert</span> len1 &gt; <span class="number">0</span> &amp;&amp; len2 &gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (tmp[cursor2]&lt; a[cursor1]) &#123;</span><br><span class="line">                    a[dest--] = a[cursor1--];</span><br><span class="line">                    count1++;</span><br><span class="line">                    count2 = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (--len1 == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span> outer;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    a[dest--] = tmp[cursor2--];</span><br><span class="line">                    count2++;</span><br><span class="line">                    count1 = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (--len2 == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span> outer;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((count1 | count2) &lt; minGallop);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">assert</span> len1 &gt; <span class="number">0</span> &amp;&amp; len2 &gt; <span class="number">1</span>;</span><br><span class="line">                count1 = len1 - gallopRight(tmp[cursor2], a, base1, len1, len1 - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (count1 != <span class="number">0</span>) &#123;</span><br><span class="line">                    dest -= count1;</span><br><span class="line">                    cursor1 -= count1;</span><br><span class="line">                    len1 -= count1;</span><br><span class="line">                    System.arraycopy(a, cursor1 + <span class="number">1</span>, a, dest + <span class="number">1</span>, count1);</span><br><span class="line">                    <span class="keyword">if</span> (len1 == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span> outer;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                a[dest--] = tmp[cursor2--];</span><br><span class="line">                <span class="keyword">if</span> (--len2 == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span> outer;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                count2 = len2 - gallopLeft(a[cursor1], tmp, tmpBase, len2, len2 - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (count2 != <span class="number">0</span>) &#123;</span><br><span class="line">                    dest -= count2;</span><br><span class="line">                    cursor2 -= count2;</span><br><span class="line">                    len2 -= count2;</span><br><span class="line">                    System.arraycopy(tmp, cursor2 + <span class="number">1</span>, a, dest + <span class="number">1</span>, count2);</span><br><span class="line">                    <span class="comment">// len2 == 1 || len2 == 0</span></span><br><span class="line">                    <span class="keyword">if</span> (len2 &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span> outer;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                a[dest--] = a[cursor1--];</span><br><span class="line">                <span class="keyword">if</span> (--len1 == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span> outer;</span><br><span class="line">                &#125;</span><br><span class="line">                minGallop--;</span><br><span class="line">            &#125; <span class="keyword">while</span> (count1 &gt;= MIN_GALLOP | count2 &gt;= MIN_GALLOP);</span><br><span class="line">            <span class="keyword">if</span> (minGallop &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                minGallop = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Penalize for leaving gallop mode</span></span><br><span class="line">            minGallop += <span class="number">2</span>;</span><br><span class="line">        &#125;  <span class="comment">// End of "outer" loop</span></span><br><span class="line">        <span class="comment">// Write back to field</span></span><br><span class="line">        <span class="keyword">this</span>.minGallop = minGallop &lt; <span class="number">1</span> ? <span class="number">1</span> : minGallop;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len2 == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">assert</span> len1 &gt; <span class="number">0</span>;</span><br><span class="line">            dest -= len1;</span><br><span class="line">            cursor1 -= len1;</span><br><span class="line">            System.arraycopy(a, cursor1 + <span class="number">1</span>, a, dest + <span class="number">1</span>, len1);</span><br><span class="line">            <span class="comment">// Move first elt of run2 to front of merge</span></span><br><span class="line">            a[dest] = tmp[cursor2];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len2 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"Comparison method violates its general contract!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">assert</span> len1 == <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">assert</span> len2 &gt; <span class="number">0</span>;</span><br><span class="line">            System.arraycopy(tmp, tmpBase, a, dest - (len2 - <span class="number">1</span>), len2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] ensureCapacity(<span class="keyword">int</span> minCapacity) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tmpLen &lt; minCapacity) &#123;</span><br><span class="line">            <span class="comment">// Compute smallest power of 2 &gt; minCapacity</span></span><br><span class="line">            <span class="keyword">int</span> newSize = minCapacity;</span><br><span class="line">            newSize |= newSize &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            newSize |= newSize &gt;&gt; <span class="number">2</span>;</span><br><span class="line">            newSize |= newSize &gt;&gt; <span class="number">4</span>;</span><br><span class="line">            newSize |= newSize &gt;&gt; <span class="number">8</span>;</span><br><span class="line">            newSize |= newSize &gt;&gt; <span class="number">16</span>;</span><br><span class="line">            newSize++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Not bloody likely!</span></span><br><span class="line">            <span class="keyword">if</span> (newSize &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                newSize = minCapacity;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                newSize = Math.min(newSize, a.length &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tmp = <span class="keyword">new</span> <span class="keyword">int</span>[newSize];</span><br><span class="line">            tmpLen = newSize;</span><br><span class="line">            tmpBase = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100000000</span>];</span><br><span class="line">            Random r = <span class="keyword">new</span> Random();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">                a[i] = r.nextInt(<span class="number">100000000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"TimSort排序开始："</span>);</span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">            sort(a,<span class="number">0</span>,a.length,<span class="keyword">null</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">            System.out.println(<span class="string">"TimSort耗时："</span>+(System.currentTimeMillis()-start)+<span class="string">"ms"</span>);</span><br><span class="line">            System.out.println(<span class="string">"TimSort排序完成！"</span>);</span><br><span class="line">            System.out.println(<span class="string">"数组是否有序："</span>+isOrdered(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有如下结果，排序1亿数据耗时在17s左右。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TimSort排序开始：</span><br><span class="line">TimSort耗时：17831ms</span><br><span class="line">TimSort排序完成！</span><br><span class="line">数组是否有序：true</span><br></pre></td></tr></table></figure><p>TimSort的时间复杂度如下：</p><ul><li>时间复杂度（最好）：O(n)</li><li>时间复杂度（平均）：O(n * log n)</li><li>时间复杂度（最差）：O(n * log n)</li></ul><p>TimSort的空间复杂度：O(n)</p><p>TimSort是一种稳定排序算法。</p><p>TimSort之所以能成为Java的内置排序算法之一，除了其优秀的性能，另一点就在于它的稳定性了。</p><p>我们可以对大量随机数据进行测试，虽然TimSort和快排（或者其变种）具有相同的时间复杂度【平均 O(n * log n)】，但实际数据显示快排还是要快一些的。</p><p>但是快排的缺点是它的不稳定性，比如100个人按名字进行排序，有两个叫张三的，张三(1)无序下是在张三(2)之前的，快排完后可能他们的顺序就变化了，这在某些情况下可能会有问题。</p><p>我们来看下TimSort排序动图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-503.gif" alt="upload successful"></p><p>图中可以清晰的看到TimSort的排序过程。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>在util包下除了TimSort，我们还可以看到一个类 ComparableTimSort，它是针对未实现 Comparator 接口的数据的排序版本，如Object[]。</p><p>我们对于一个int[] a，调用数组的 <code>Arrays.sort(a)</code>，会使用TimSort吗？</p><p>答案是否定的，对于一些基本数据类型数组，两个相同的数的前后顺序不会造成任何影响，所以<code>Arrays.sort(a)</code>里使用了另一种更快速的排序算法DualPivotQuicksort。</p><p>我们有时间再看一下DualPivotQuicksort这个排序。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇文章通过对TimSort的分析，了解了TimSort的工作运行原理，对Java内置的排序算法有了更深的了解。</p><p>后面我们将看下Java的sort接口实现，看看Java内部是如何进一步优化排序，提高效率的。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>JDK1.8 <code>java.util.TimSort</code>、<code>java.util.ComparableTimSort</code>源码</li><li>JDK1.7 <code>java.util.TimSort</code>源码</li><li><a href="http://svn.python.org/projects/python/trunk/Objects/listsort.txt" rel="external nofollow noopener noreferrer" target="_blank">Python TimSort listsort.txt</a></li><li><a href="http://envisage-project.eu/wp-content/uploads/2015/02/sorting.pdf" rel="external nofollow noopener noreferrer" target="_blank">OpenJDK’s java.utils.Collection.sort() is broken:The good, the bad and the worst case?</a></li></ul><h1 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h1><p>上述文中涉及到的代码可见于我的 <a href="https://github.com/JavaZWT/" rel="external nofollow noopener noreferrer" target="_blank">GitHub</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="排序算法" scheme="https://www.sakuratears.top/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
      <category term="TimSort" scheme="https://www.sakuratears.top/tags/TimSort/"/>
    
  </entry>
  
  <entry>
    <title>排序算法（五）-双调排序</title>
    <link href="https://www.sakuratears.top/blog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89-%E5%8F%8C%E8%B0%83%E6%8E%92%E5%BA%8F.html"/>
    <id>https://www.sakuratears.top/blog/排序算法（五）-双调排序.html</id>
    <published>2019-09-04T14:09:00.000Z</published>
    <updated>2019-09-04T14:20:57.176Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>续我们 <a href="https://www.sakuratears.top/blog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89.html#more">排序算法（四）</a> 所说的那样，今天我们来看下一种很适合多路归并的排序算法，双调排序（BitonicSort）。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="双调排序（BitonicSort）"><a href="#双调排序（BitonicSort）" class="headerlink" title="双调排序（BitonicSort）"></a>双调排序（BitonicSort）</h2><h3 id="原理及简介"><a href="#原理及简介" class="headerlink" title="原理及简介"></a>原理及简介</h3><p>双调排序（BitonicSort）的原理是使用双调序列（Bitonic sequence）的性质来进行排序。</p><p>那什么是<strong>双调序列</strong>呢？</p><pre><code>如果一个序列A=[X0, X1, X2, ...... , Xn-1]，存在一个下标i（0≤i≤n-1），使得：X0 ≤ X1 ≤ ...... ≤ Xi, and Xi ≥ Xi+1 ≥ ...... ≥ Xn-1那么我们称这个序列是双调的（Bitonic）。</code></pre><p>如下面的数据格式：</p><p>[5,9,10,17,6,3,2,1]</p><p>需要注意的几点：</p><ul><li>一个序列如果是完全的非降序或非升序的，它也是Bitonic的。（i为0或者n-1时）</li><li>Bitonic序列的子序列仍为Bitonic的。 </li><li>将一个Bitonic序列进行循环移位操作后，也是Bitonic序列。</li><li>任意两个实数，都可以组成双调序列。</li></ul><p>如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-489.jpg" alt="upload successful"></p><p>因此可以知道，如果一个序列循环移位后可以表示成 up -&gt; down 形式，那么它就是Bitonic的。</p><p><strong>如果一个无序序列（满足长度为2的幂），则可以从最小的Bitonic序列（数组中的每两个数为一个Bitonic序列）开始，将整个序列变为Bitonic的。</strong></p><p>我们再来看下Batcher定理，这个定理用于双调排序的双调合并。</p><p><strong>Batcher定理</strong></p><pre><code>将任意一个长为2n的双调序列A分为等长的两半X和Y，将X中的元素与Y中的元素一一按原序比较，即a[i]与a[i+n] (i &lt; n)比较，将较大者放入MAX序列，较小者放入MIN序列。则得到的MAX和MIN序列仍然是双调序列，并且MAX序列中的任意一个元素不小于MIN序列中的任意一个元素。</code></pre><p>PS：这个定理的证明和 0-1序列 有关，有兴趣的可以查阅<a href="http://www.inf.fh-flensburg.de/lang/algorithmen/sortieren/bitonic/bitonicen.htm" rel="external nofollow noopener noreferrer" target="_blank">相关资料</a>。</p><p>PS: 0-1序列，一个只有0，1元素的序列。</p><p><strong>根据这个定理，我们继续下去，如果MAX和MIN也是长为2m的，那么它们可以继续拆分成 MAX(max),MAX(min)和MIN(max)和MIN(min)……一直继续下去，直到要拆分的序列长度为1，这时候整个序列A会完全有序排列。</strong></p><p>这个定理非常有意思，我们来看下。</p><p>比如对于一个序列 A [3,5,7,9,10,17,19,22,17,15,12,10,9,8,5,1]，明显看出它是一个双调序列，其中X为[3,5,7,9,10,17,19,22]单调递增，Y为[17,15,12,10,9,8,5,1]单调递减，且X序列长度等于Y序列长度，我们试着按照上面定理将数据按照原序进行比较，得到MAX和MIN两个序列，它们分别为 MAX [17,15,12,10,10,17,19,22]，MIN [3,5,7,9,9,8,5,1]，对MAX和MIN按照Batcher定理继续拆分……</p><p>我们将上述过程用图的形式描述出来，对于无序数组 [8,12,6,18,9,1,3,4]，其排序过程如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-490.jpg" alt="upload successful"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>上述过程我们使用Java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitonicSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 升降序标志</span></span><br><span class="line"><span class="comment">     * true 升序</span></span><br><span class="line"><span class="comment">     * false 降序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">boolean</span> ASCENDING = <span class="keyword">true</span>, DESCENDING = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bitonicSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        sort(a, <span class="number">0</span>, a.length, ASCENDING);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> n, <span class="keyword">boolean</span> dir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = n / <span class="number">2</span>;</span><br><span class="line">            sort(a, lo, m, ASCENDING);</span><br><span class="line">            sort(a, lo + m, m, DESCENDING);</span><br><span class="line">            bitonicMerge(a, lo, n, dir);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bitonicMerge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> n, <span class="keyword">boolean</span> dir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = n / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt; lo + m; i++) &#123;</span><br><span class="line">                compare(a, i, i + m, dir);</span><br><span class="line">            &#125;</span><br><span class="line">            bitonicMerge(a, lo, m, dir);</span><br><span class="line">            bitonicMerge(a, lo + m, m, dir);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">boolean</span> dir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dir == (a[i] &gt; a[j])) &#123;</span><br><span class="line">            exchange(a, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"BitonicSort排序前："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        bitonicSort(a);</span><br><span class="line">        System.out.println(<span class="string">"BitonicSort排序后："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h3><p>我们来看下排序动图，也很直观，可以看到非常明显的双调序列变化过程。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-491.gif" alt="upload successful"></p><h3 id="缺陷及优化"><a href="#缺陷及优化" class="headerlink" title="缺陷及优化"></a>缺陷及优化</h3><p>上面的代码我们可以发现当数组长度为 2^n 时才会排序正确，长度不为2的幂的情况下排序是不正确的。</p><p>这一点是非常好理解的，对于我们上面双调序列和Batcher定理来说，只有当数组长度为2的幂的情况下数组才会被正确分割运算下去。</p><p><strong>但是现实中数据长度大部分都不是2的幂次的，如何让我们的双调排序适应非2的幂次的长度的数据呢？</strong></p><h4 id="n-2-k数据的双调排序方案"><a href="#n-2-k数据的双调排序方案" class="headerlink" title="n!=2^k数据的双调排序方案"></a>n!=2^k数据的双调排序方案</h4><h5 id="改造数据长度"><a href="#改造数据长度" class="headerlink" title="改造数据长度"></a>改造数据长度</h5><p>有一些想法是改造数组，将数据填充到2的幂次长度，填充值为最大值，排序完成后，删除数组尾部填充长度的数据。</p><p>这种做法有一个明显缺陷，比如一个长度为1025的数据，我们要填充到2048长度才能解决问题，对于更大的数据，我们或许填充的更多，这显然不是一个好办法。</p><p>那如果只排序前 2^n 部分，对于剩余部分使用经典排序（插入排序、选择排序）处理呢？</p><p>这种做法如果对于一个长度为2047的数组，使用双调排序排1024部分，剩下的1023用经典排序处理，好像也不是很完美。</p><p>如果开始判断数组长度，接近高次2的幂的数据就用填充法，接近低次2的幂的数据就用部分双调排序法呢？好像也不是特别理想。</p><h5 id="n-2-k数据的双调排序算法"><a href="#n-2-k数据的双调排序算法" class="headerlink" title="n!=2^k数据的双调排序算法"></a>n!=2^k数据的双调排序算法</h5><p>下面我们介绍一种对于任意n的双调排序网络算法，它的定理来源于Batcher定理的引申。</p><p>设想如果我们的序列A长度n!=2^k，我们可以找到一个最小的2的幂次长度p=2^q，使得p&gt;n，这时候p-n部分填充最大值Max，同时p/2 之前的序列单调递减，p/2 之后的队列单调递增，如下：</p><p>[8,7,6,5,4,3,2,1,7]</p><p>[8,7,6,5,4,3,2,1,7,Max,Max,Max,Max,Max,Max,Max]</p><p>我们使用Batcher定理可得到如下序列：</p><p>X [7,7,6,5,4,3,2,1]  Y[8,Max,Max,Max,Max,Max,Max,Max] -&gt;[8]</p><p>可以发现Y序列的每一个值都是不小于X序列的每一个值的，即 Xi &lt;= Yj。</p><p>我们可以用图表示这个过程，如下：</p><p>我们看下[8,12,6,18,9,1,3]这个数组的排序模拟过程。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-492.jpg" alt="upload successful"></p><p>可以看到，我们虚构出来的Max部分是始终不参与交换的。</p><p>在实际排序中，我们不用虚构Max部分，直接将数组长度/2 进行分割，保证左半部分单调递减，右半部分单调递增，再使用Batcher定理，就会得到需要的已排序序列。</p><p>我们可以写出适用于任意数据长度的双调排序算法代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitonicBetterSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * sorting direction</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">boolean</span> ASCENDING = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bitonicSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        sort(a,<span class="number">0</span>, a.length, ASCENDING);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> n, <span class="keyword">boolean</span> dir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = n / <span class="number">2</span>;</span><br><span class="line">            sort(a,lo, m, !dir);</span><br><span class="line">            sort(a,lo + m, n - m, dir);</span><br><span class="line">            bitonicMerge(a,lo, n, dir);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bitonicMerge</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> lo, <span class="keyword">int</span> n, <span class="keyword">boolean</span> dir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = greatestPowerOfTwoLessThan(n);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt; lo + n - m; i++) &#123;</span><br><span class="line">                compare(a,i, i + m, dir);</span><br><span class="line">            &#125;</span><br><span class="line">            bitonicMerge(a,lo, m, dir);</span><br><span class="line">            bitonicMerge(a,lo + m, n - m, dir);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">boolean</span> dir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dir == (a[i] &gt; a[j])) &#123;</span><br><span class="line">            exchange(a,i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">greatestPowerOfTwoLessThan</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; n) &#123;</span><br><span class="line">            k = k &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"BitonicSort排序前："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        bitonicSort(a);</span><br><span class="line">        System.out.println(<span class="string">"BitonicSort排序后："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的动图给出了数组长度为25的数组排序演示：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-493.gif" alt="upload successful"></p><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><p>为了从两个长度为n/2的排序序列中形成长度为n的排序序列，需要进行log(n)次比较。整个排序网络的比较方程T(n)为:</p><p>T(n) = log(n) + T(n/2)</p><p>这个递归方程的解是：</p><p>T(n) = log(n) + log(n)-1 + log(n)-2 +…+1 = log(n)·(log(n)+1) / 2</p><p>排序网络的每个阶段需要进行n/2个比较。</p><p>总的来说，复杂度为 [log(n)·(log(n)+1) / 2] · n/2 = [ n·log(n)·(log(n)+1) ]/4 = O(n·(log n)^2)</p><p>算法的空间复杂度为O(1)。</p><p>该算法是一种不稳定排序算法。</p><p>以上是在串行运行下的复杂度情况，可以看出它比一般的归并排序（O(n·(log n))）要慢。</p><h3 id="并行条件下的双调排序"><a href="#并行条件下的双调排序" class="headerlink" title="并行条件下的双调排序"></a>并行条件下的双调排序</h3><p>既然说到双调排序十分适用于并行排序，我们就简单改造下代码，使其使用并行排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitonicParallelSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可用CPU核数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分片数，取偶数，如果核数过少就使用默认值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_PROCESSORS = NCPU &gt;= <span class="number">16</span> ? (NCPU % <span class="number">2</span> == <span class="number">0</span> ? NCPU : NCPU + <span class="number">1</span>) : <span class="number">16</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工作线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分片大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> PIECE = <span class="number">10000</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * sorting direction</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">boolean</span> ASCENDING = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bitonicSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化分片大小</span></span><br><span class="line">        PIECE = a.length/MIN_PROCESSORS;</span><br><span class="line">        sort(a,<span class="number">0</span>, a.length, ASCENDING);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> n, <span class="keyword">boolean</span> dir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = n / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(n &gt; PIECE)&#123;</span><br><span class="line">                Future future1 = parallelSort(a, lo, m, !dir);</span><br><span class="line">                Future future2 = parallelSort(a, lo + m, n - m, dir);</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(future1.isDone()&amp;&amp;future2.isDone())&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sort(a, lo, m, !dir);</span><br><span class="line">                sort(a, lo + m, n - m, dir);</span><br><span class="line">            &#125;</span><br><span class="line">            bitonicMerge(a, lo, n, dir);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bitonicMerge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> n, <span class="keyword">boolean</span> dir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = greatestPowerOfTwoLessThan(n);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt; lo + n - m; i++) &#123;</span><br><span class="line">                compare(a, i, i + m, dir);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(n &gt; PIECE)&#123;</span><br><span class="line">                Future future1 = parallelMerge(a, lo, m, dir);</span><br><span class="line">                Future future2 = parallelMerge(a, lo + m, n - m, dir);</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(future1.isDone()&amp;&amp;future2.isDone())&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                bitonicMerge(a, lo, m, dir);</span><br><span class="line">                bitonicMerge(a, lo + m, n - m, dir);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">boolean</span> dir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dir == (a[i] &gt; a[j])) &#123;</span><br><span class="line">            exchange(a, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">greatestPowerOfTwoLessThan</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; n) &#123;</span><br><span class="line">            k = k &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Future <span class="title">parallelSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> n, <span class="keyword">boolean</span> dir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> executorService.submit(()-&gt;sort(a,lo,n,dir));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Future <span class="title">parallelMerge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> n, <span class="keyword">boolean</span> dir)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> executorService.submit(()-&gt;bitonicMerge(a,lo,n,dir));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100000000</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">100000000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"BitonicParallelSort排序开始："</span>);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        bitonicSort(a);</span><br><span class="line">        System.out.println(<span class="string">"BitonicParallelSort耗时："</span>+(System.currentTimeMillis()-start)+<span class="string">"ms"</span>);</span><br><span class="line">        System.out.println(<span class="string">"BitonicParallelSort排序完成！"</span>);</span><br><span class="line">        System.out.println(<span class="string">"数组是否有序："</span>+isOrdered(a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isOrdered</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length -<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&lt;=a[i+<span class="number">1</span>] != ASCENDING)&#123;</span><br><span class="line">                System.out.println(a[i]+<span class="string">"....."</span>+a[i+<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我这边使用了线程池来进行处理，我们定义了最小分片长度，这个长度需要初始化，一般取数组长度与每级分片数量之比；</p><p>可以看到我们上面生成双调序列（sort方法）和Batcher合并（bitonicMerge方法）均使用了多线程进行处理。</p><p>上面的方法按照理论上应该比正常的串行双调排序快1倍时间。</p><p>我们来验证下，我们准备1亿数据量，数据大小区间在[0 - 100000000]，对上述的 BitonicBetterSort（串行）和 BitonicParallelSort（并行）进行测试验证。</p><p>测试结果大致如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-494.jpg" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-495.jpg" alt="upload successful"></p><p>可以看到BitonicBetterSort（串行）耗时在55s左右，BitonicParallelSort（并行）耗时在30s左右，还是比较符合预期的。</p><p>我们看到，无论sort方法还是bitonicMerge方法，并行情况下（N &gt; PEICE），递归的每级都丢给了两个线程（一个负责升序排列的线程、一个负责降序排列的线程）。</p><p>原来的串行程序是执行完升序，再执行降序；现在是升序降序同时执行，所以快1倍时间由此得来。</p><p>我们可以看下双调并行排序动图演示过程。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-496.gif" alt="upload successful"></p><h3 id="并行条件下的双调排序调优"><a href="#并行条件下的双调排序调优" class="headerlink" title="并行条件下的双调排序调优"></a>并行条件下的双调排序调优</h3><p>以上就是双调排序（BitonicSort）的全部内容，通过这篇文章我们了解到了双调排序的原理和一些特点。</p><p>PS：本来这儿的标题是总结，但是写着写着又想到了一些东西，就把标题改了。</p><p>双调排序可以说是非常适合并行运行的一种排序算法了，它的无论开始先生成双调序列的方法，还是后面Batcher合并，都可以做到在同一数据组里处理而不相互干扰。</p><p>就如对于一个长度为64的序列，分为前32部分和后32部分，这两部分最后生成1个升序序列和一个降序序列（或者一个降序一个升序）即可，最后它们在进行Batcher合并，因此双调序列并行情况下也可以结合其他一些就地排序算法进行处理。</p><p>比如我们上述并行代码中，当数据长度不足以分片时，我们是继续按照双调排序进行的，其实这样效率会降低。</p><p>比如1亿量的数据，如果我们分了1000次片，每个片就有10w数据，对于这些数据，我们目的就是生成一个升序（或者降序）的序列，此时使用串行的双调排序效率不高，继续分片的话线程数量（系统开销）又大大增加，得到的时间提升甚微。</p><p>这种情况我们就可以使用一些O(n * log n)级别的就地排序算法，比如<a href="https://www.sakuratears.top/blog/Java%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%88Quick-Sort%EF%BC%89">快速排序</a>。</p><p>我下面写了一个当分片不足时采用并行快排的双调并行排序算法代码，大家可以看下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitonicParallelMixtureSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可用CPU核数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分片数，取偶数，如果核数过少就使用默认值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_PROCESSORS = NCPU &gt;= <span class="number">16</span> ? (NCPU % <span class="number">2</span> == <span class="number">0</span> ? NCPU : NCPU + <span class="number">1</span>) : <span class="number">16</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工作线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分片大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> PIECE = <span class="number">10000</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * sorting direction</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">boolean</span> ASCENDING = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bitonicSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化分片大小</span></span><br><span class="line">        PIECE = a.length/MIN_PROCESSORS;</span><br><span class="line">        sort(a,<span class="number">0</span>, a.length, ASCENDING);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> n, <span class="keyword">boolean</span> dir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = n / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(n &gt; PIECE)&#123;</span><br><span class="line">                Future future1 = parallelSort(a, lo, m, !dir);</span><br><span class="line">                Future future2 = parallelSort(a, lo + m, n - m, dir);</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(future1.isDone()&amp;&amp;future2.isDone())&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                Future future1 = parallelQuickSort(a, lo, lo + m - <span class="number">1</span>, !dir);</span><br><span class="line">                Future future2 = parallelQuickSort(a, lo + m, lo + n - <span class="number">1</span>, dir);</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(future1.isDone()&amp;&amp;future2.isDone())&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            bitonicMerge(a, lo, n, dir);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bitonicMerge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> n, <span class="keyword">boolean</span> dir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = greatestPowerOfTwoLessThan(n);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt; lo + n - m; i++) &#123;</span><br><span class="line">                compare(a, i, i + m, dir);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(n &gt; PIECE)&#123;</span><br><span class="line">                Future future1 = parallelMerge(a, lo, m, dir);</span><br><span class="line">                Future future2 = parallelMerge(a, lo + m, n - m, dir);</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(future1.isDone()&amp;&amp;future2.isDone())&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                bitonicMerge(a, lo, m, dir);</span><br><span class="line">                bitonicMerge(a, lo + m, n - m, dir);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">boolean</span> dir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dir == (a[i] &gt; a[j])) &#123;</span><br><span class="line">            exchange(a, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">greatestPowerOfTwoLessThan</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; n) &#123;</span><br><span class="line">            k = k &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Future <span class="title">parallelSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> n, <span class="keyword">boolean</span> dir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> executorService.submit(()-&gt;sort(a,lo,n,dir));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Future <span class="title">parallelMerge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> n, <span class="keyword">boolean</span> dir)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> executorService.submit(()-&gt;bitonicMerge(a,lo,n,dir));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Future <span class="title">parallelQuickSort</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> low,<span class="keyword">int</span> high,<span class="keyword">boolean</span> dir)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> executorService.submit(()-&gt;quickSort(a,low,high,dir));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 快排</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> low</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> high</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dir  true 表示从小到大 正序排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> low,<span class="keyword">int</span> high,<span class="keyword">boolean</span> dir)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">            <span class="comment">//将表一分为二</span></span><br><span class="line">            <span class="keyword">int</span> privotLoc=partition(a,low,high,dir);</span><br><span class="line">            quickSort(a,low,privotLoc-<span class="number">1</span>,dir);</span><br><span class="line">            quickSort(a,privotLoc+<span class="number">1</span>,high,dir);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">boolean</span> dir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = a[high];</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="comment">//升序</span></span><br><span class="line">            <span class="keyword">if</span> (dir) &#123;</span><br><span class="line">                <span class="keyword">while</span> (a[low] &lt; pivot &amp;&amp; low &lt; high) &#123;</span><br><span class="line">                    low++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">                    a[high--] = a[low];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (a[high] &gt; pivot &amp;&amp; low &lt; high) &#123;</span><br><span class="line">                    high--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">                    a[low++] = a[high];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//降序</span></span><br><span class="line">                <span class="keyword">while</span> (a[low] &gt; pivot &amp;&amp; low &lt; high) &#123;</span><br><span class="line">                    low++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">                    a[high--] = a[low];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (a[high] &lt; pivot &amp;&amp; low &lt; high) &#123;</span><br><span class="line">                    high--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">                    a[low++] = a[high];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[low] = pivot;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100000000</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">100000000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"BitonicParallelMixtureSort排序开始："</span>);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        bitonicSort(a);</span><br><span class="line">        System.out.println(<span class="string">"BitonicParallelMixtureSort耗时："</span>+(System.currentTimeMillis()-start)+<span class="string">"ms"</span>);</span><br><span class="line">        System.out.println(<span class="string">"BitonicParallelMixtureSort排序完成！"</span>);</span><br><span class="line">        System.out.println(<span class="string">"数组是否有序："</span>+isOrdered(a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isOrdered</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length -<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&lt;=a[i+<span class="number">1</span>] != ASCENDING)&#123;</span><br><span class="line">                System.out.println(a[i]+<span class="string">"....."</span>+a[i+<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们同样运行1亿数据量，测试该算法的耗时，如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-497.jpg" alt="upload successful"></p><p>可以看到处理1亿数据时间缩短到了15s，相比之前又提高了一倍。</p><p>上述代码主要在分片小于a.length/MIN_PROCESSORS的地方进行了优化，由于两部分不冲突，快速排序部分也使用了并行处理。</p><p>可以看到，我们不知不觉的写了一个属于自己的混合排序算法，emmmm…..</p><p>当然，这里不是结束，算法还是可以优化的，比如当处理到的数据过小时（比如处理长度小于16），快排的优势无法显著体现，我们这时候可以使用插入排序处理数据等，可以参考<a href="https://www.sakuratears.top/blog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89.html#%E5%86%85%E7%9C%81%E6%8E%92%E5%BA%8F%EF%BC%88IntroSort%EF%BC%89">内省排序（IntroSort）</a>的处理。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>说到这里，基本上算是结束了，本文通过介绍双调排序，理解了它的运行原理的同时，又提供了一个并行版本，以及并行版本的一些优化，让我们了解到了排序算法非常有意思的一些地方。</p><p>本来以为到这儿就结束了，我手贱测试了下快排和内省排序1亿数据量的运行情况。</p><p>如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-498.jpg" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-499.jpg" alt="upload successful"></p><p>内省排序不愧是C++标准模板库的排序算法，只耗时10s就完成了，比我们的并行排序要快，哈哈！！</p><p>快速排序耗时12s左右，瞬间感觉到将快排应用到我们双调并行排序中是大材小用了。</p><p>同时也可以看到内省排序确实对快排做了优化，数据量越大越明显。</p><p>总的来说，快排大法好（内省也主要使用了快排）！</p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>本文中提到的所有源代码均可以在我的Github上看到。</p><p><a href="https://github.com/JavaZWT" rel="external nofollow noopener noreferrer" target="_blank">Github-JavaZWT</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="排序算法" scheme="https://www.sakuratears.top/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
      <category term="双调排序" scheme="https://www.sakuratears.top/tags/%E5%8F%8C%E8%B0%83%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>排序算法（四）</title>
    <link href="https://www.sakuratears.top/blog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89.html"/>
    <id>https://www.sakuratears.top/blog/排序算法（四）.html</id>
    <published>2019-09-01T02:06:00.000Z</published>
    <updated>2019-09-01T03:22:12.028Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上篇文章<a href="https://www.sakuratears.top/blog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89.html#more">排序算法（三）</a>我们介绍了7种排序算法。</p><p>可以知道到目前我们已经介绍了27种排序算法，当然，不仅仅如此，还有若干排序算法，我们今天继续来看一下。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>今天我们介绍4种排序算法，它们如下：</p><table><thead><tr><th>Sort Name</th><th>Time(Best)</th><th>Time(Average)</th><th>Time(Worst)</th><th>Memory</th><th>Stable</th></tr></thead><tbody><tr><td>IntroSort</td><td>O(n * log n)</td><td>O(n * log n)</td><td>O(n * log n)</td><td>O(log n)</td><td>No</td></tr><tr><td>SmoothSort</td><td>O(n)</td><td>O(n * log n)</td><td>O(n * log n)</td><td>O(1)</td><td>No</td></tr><tr><td>TreeSelectionSort</td><td>O(n * log n)</td><td>O(n * log n)</td><td>O(n * log n)</td><td>O(n)</td><td>Yes</td></tr><tr><td>AmericanFlagSort</td><td>O(n * k/d)</td><td>O(n * k/d)</td><td>O(n * k/d)</td><td>O(1)</td><td>No</td></tr></tbody></table><p>我们分别来看下。</p><h2 id="内省排序（IntroSort）"><a href="#内省排序（IntroSort）" class="headerlink" title="内省排序（IntroSort）"></a>内省排序（IntroSort）</h2><h3 id="简介及原理"><a href="#简介及原理" class="headerlink" title="简介及原理"></a>简介及原理</h3><p>内省排序（Introspective Sort）是一种比较排序算法，也是一个混合排序算法，是由David Musser在1997年设计的排序算法。</p><p>它内部使用了<a href="https://www.sakuratears.top/blog/Java%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%88Quick-Sort%EF%BC%89">快速排序（QuickSort）</a>、<a href="https://www.sakuratears.top/blog/Java%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html#%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88Heap-Sort%EF%BC%89">堆排序（HeapSort）</a>和<a href="https://www.sakuratears.top/blog/Java%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%88Insertion-Sort%EF%BC%89">插入排序（InsertionSort）</a>三种排序算法。</p><p>该排序算法的主要策略如下：</p><ol><li>数据量大时采用快速排序（QuickSort），分段递归排序；</li><li>一旦分段后的数据量小于某个阈值，为避免快排的递归调用带来的额外负荷，就改用插入排序（InsertionSort）；</li><li>如果递归层次过深，就会采用堆排序（HeapSort）；</li><li>三点中值”获取好的数组分割。</li></ol><p><strong>关于“三点中值”</strong></p><p>内省排序使用的分段递归，每一个数组段都会重复上述 1、2、3 策略部分，内省排序如何对数组进行分段的呢？这就涉及到它的“三点中值”算法了。</p><p>我们来看下它的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">median3</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> first, <span class="keyword">int</span> median, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array[first] &lt; array[median]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[median] &lt; array[end]) &#123;</span><br><span class="line">            <span class="keyword">return</span> median;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[first] &lt; array[end]) &#123;</span><br><span class="line">            <span class="keyword">return</span> end;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[first] &lt; array[end]) &#123;</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[median] &lt; array[end]) &#123;</span><br><span class="line">            <span class="keyword">return</span> end;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> median;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑比较好理解：</p><ul><li><p>如果数组首部元素比中间元素小：</p><ul><li>中间元素小于尾部元素，就取中间的index；</li><li>首部元素小于尾部元素，就取尾部的index；</li><li>否则取首部的index。</li></ul></li><li><p>如果数组首部元素比中间元素大或者等于：</p><ul><li>首部元素小于尾部元素，就取首部的index；</li><li>中间元素小于尾部元素，就取尾部的index；</li><li>否则取中间的index。</li></ul></li></ul><p>我们知道快排要确立一个基准元素，对于普通快排，我们取a[low]，这儿内省排序中的快排，基准元素的index为 <code>median3(array, begin, begin + (end - begin) / 2, end)</code>，可以看到是寻找的<code>begin</code>，<code>end</code>和<code>begin + (end - begin) / 2</code>这三点的“三点中值”。</p><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>检测待排序数组长度，如果大于阈值（默认16），就会采用分段递归排序；</li><li>递归最大深度为 2 * lg(array.length) ，对于每一段，都会使用快速排序，快排基准值为数组“三点中值”位置的元素值；</li><li>当递归深度过大时，就会采用堆排序；</li><li>随着不断分割，递归重复上述排序过程，当数组分割后的长度小于阈值时，就采用插入排序完成最后排序过程。</li></ol><h3 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-482.gif" alt="upload successful"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntroSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据量的分界线，决定了使用quick sort/heap sort还是insertion sort</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">16</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 堆排序用到的辅助函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">2</span> * i + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        temp = array[index1];</span><br><span class="line">        array[index1] = array[index2];</span><br><span class="line">        array[index2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapShiftDown</span><span class="params">(<span class="keyword">int</span>[] heap, <span class="keyword">int</span> i, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = left(i - begin) + begin;</span><br><span class="line">        <span class="keyword">int</span> r = right(i - begin) + begin;</span><br><span class="line">        <span class="keyword">int</span> largest = i;</span><br><span class="line">        <span class="comment">//找出左右字节点与父节点中的最大者</span></span><br><span class="line">        <span class="keyword">if</span> (l &lt; end &amp;&amp; heap[l] &gt; heap[largest]) &#123;</span><br><span class="line">            largest = l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; end &amp;&amp; heap[r] &gt; heap[largest]) &#123;</span><br><span class="line">            largest = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若最大者不为父节点，则需交换数据，并持续向下滚动至满足最大堆特性</span></span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            swap(heap, largest, i);</span><br><span class="line">            heapShiftDown(heap, largest, begin, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自底向上的开始建堆，即从堆的倒数第二层开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> begin</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span>[] heap, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (begin + end) / <span class="number">2</span>; i &gt;= begin; i--) &#123;</span><br><span class="line">            heapShiftDown(heap, i, begin, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 堆排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> begin</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] heap, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        buildHeap(heap, begin, end);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = end; i &gt; begin; i--) &#123;</span><br><span class="line">            swap(heap, begin, i);</span><br><span class="line">            heapShiftDown(heap, begin, begin, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, j, temp;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">//store the original sorted array in temp</span></span><br><span class="line">            temp = array[i];</span><br><span class="line">            <span class="comment">//compare the new array with temp(maybe -1?)</span></span><br><span class="line">            <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; temp &lt; array[j - <span class="number">1</span>]; j--) &#123;</span><br><span class="line">                <span class="comment">//all larger elements are moved one pot to the right</span></span><br><span class="line">                array[j] = array[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            array[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 三点中值计算</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> first</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> median</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">median3</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> first, <span class="keyword">int</span> median, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array[first] &lt; array[median]) &#123;</span><br><span class="line">            <span class="keyword">return</span> helpMethod(array, first, median, end);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> helpMethod(array, median, first, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">helpMethod</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> first, <span class="keyword">int</span> median, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array[median] &lt; array[end]) &#123;</span><br><span class="line">            <span class="keyword">return</span> median;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[first] &lt; array[end]) &#123;</span><br><span class="line">            <span class="keyword">return</span> end;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对数组分割</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//选择最右侧的元素作为分割标准</span></span><br><span class="line">        <span class="keyword">int</span> index = left;</span><br><span class="line">        swap(array, p, right);</span><br><span class="line">        <span class="keyword">int</span> pivot = array[right];</span><br><span class="line">        <span class="comment">//将所有小于标准的点移动到index的左侧</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &lt; pivot) &#123;</span><br><span class="line">                swap(array, index++, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将标准与index指向的元素交换，返回index，即分割位置</span></span><br><span class="line">        swap(array, right, index);</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归的对数组进行分割排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> begin</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> depthLimit</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">introSortLoop</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> begin, <span class="keyword">int</span> end, <span class="keyword">int</span> depthLimit)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//子数组数据量大小，则交给后面的插入排序进行处理</span></span><br><span class="line">        <span class="keyword">while</span> ((end - begin + <span class="number">1</span>) &gt; THRESHOLD) &#123;</span><br><span class="line">            <span class="comment">//递归深度过大，则由堆排序代替</span></span><br><span class="line">            <span class="keyword">if</span> (depthLimit == <span class="number">0</span>) &#123;</span><br><span class="line">                heapSort(array, begin, end);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            --depthLimit;</span><br><span class="line">            <span class="comment">//使用quick sort进行排序</span></span><br><span class="line">            <span class="keyword">int</span> cut = partition(array, begin, end,</span><br><span class="line">                    median3(array, begin, begin + (end - begin) / <span class="number">2</span>, end));</span><br><span class="line">            introSortLoop(array, cut, end, depthLimit);</span><br><span class="line">            <span class="comment">//对左半段进行递归的sort</span></span><br><span class="line">            end = cut;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算最大容忍的递归深度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lg</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; n &gt; <span class="number">1</span>; n &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            ++k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * IntroSort排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">introSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (len != <span class="number">1</span>) &#123;</span><br><span class="line">            introSortLoop(array, <span class="number">0</span>, len - <span class="number">1</span>, lg(len) * <span class="number">2</span>);</span><br><span class="line">            insertionSort(array, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"IntroSort排序前："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        introSort(a,a.length);</span><br><span class="line">        System.out.println(<span class="string">"IntroSort排序后："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ul><li>该排序算法吸取了快排、插入排序、堆排的优点，是一种效率较高的排序算法；</li><li>内省排序算法是C++标准模板库 <code>std::sort</code>采用的算法；</li><li><p>该排序算法的时间复杂度：</p><ul><li>时间复杂度（最好）： O(n*log n)</li><li>时间复杂度（平均）： O(n*log n)</li><li>时间复杂度（最差）： O(n*log n)</li></ul></li><li><p>该排序算法的空间复杂度为：O(log n)</p></li><li>该排序算法为不稳定排序算法</li></ul><h2 id="平滑排序（SmoothSort）"><a href="#平滑排序（SmoothSort）" class="headerlink" title="平滑排序（SmoothSort）"></a>平滑排序（SmoothSort）</h2><h3 id="简介及原理-1"><a href="#简介及原理-1" class="headerlink" title="简介及原理"></a>简介及原理</h3><p>平滑排序（SmoothSort）是一种比较排序算法，是堆排序的一个变体，由 Edsger Dijkstra 在1981年发明并发表。</p><p>SmoothSort作为<a href="https://www.sakuratears.top/blog/Java%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html#%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88Heap-Sort%EF%BC%89">堆排序</a>的变种，与其不同是其引入了斐波那契数列来确定堆排序中子节点的位置。</p><p>斐波那契数列（Fibonacci sequence）：又称黄金分割数列、兔子数列，函数表达式为 F[n]=F[n-1]+F[n-2] (n&gt;=3,F[1]=1,F[2]=1)。</p><p>可以知道斐波那契数列指的是这样一个数列 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233，377，610，987，1597，2584，4181，6765，10946，17711，28657，46368……..</p><p>我们平滑排序中，使用的数列和其有细微不同，其函数表达式为 F[n]=F[n-1]+F[n-2]+1 (n&gt;=3,F[1]=1,F[2]=1)。</p><p>可以得到SmoothSort使用的数列是这样的  1, 1, 3, 5, 9, 15, 25, 41, 67, 109, 177, 287, 465, 753, 1219, 1973,3193, 5167, 8361, 13529, 21891, 35421, 57313……..</p><p>我们来回顾下堆排序原理，堆排序是利用了完全二叉堆（完全二叉树），来在数组里隐式构建一个完全二叉堆。</p><p>之所以完全二叉树可以用数组来表示，是因为完全二叉树有一个性质：除了最底层，每一层都是满的，每个结点对应数组中的一个元素。</p><p>如下图：</p><p>分别是最大完全二叉树堆（特点是父节点的值大于两个小节点的值） 和 最小完全二叉树堆（特点是父节点的值小于两个小节点的值）以及它们分别对应的隐式数组结构。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-483.jpg" alt="upload successful"></p><p>开始时我们需要构建一个隐式完全二叉堆（从大到小排就构建最小堆、从小到大排就构建最大堆），因为对于一个待排序数组，它目前的顺序不一定符合完全二叉堆的性质。</p><p>比如对于数组从小到大排列，堆排序先将数组改造为最大堆，然后将堆顶和堆底元素交换，之后将底部上升，重新构建最大堆，保持最大堆性质。由于堆顶元素必然是堆中最大的元素，所以一次操作之后，堆中存在的最大元素被分离出堆，重复n-1次之后，数组排列完毕。</p><p>如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-484.jpg" alt="upload successful"></p><p>关于构建最大堆（或者最小堆）和堆调整的相关代码，可以参考上面内省排序代码中的<code>buildHeap</code>和<code>heapShiftDown</code>相关方法。</p><p>好，回归到SmoothSort，与堆排序类似，Smooth也是首先将数组转为隐式数组堆结构，然后通过重复提取最大剩余元素（从小到大的排序），并在剩余元素上重新构建最大堆，来生成排序数组的。</p><p>我们可以看到，我们的堆排序，隐式堆在数组中表示后，父节点一定是在子节点之前，且初始元素是该隐式堆的根节点。</p><p>而SmoothSort有所不同的是，它的父节点总是在子节点之后，就相当于将树倒了过来。</p><p>比如一个数组[4,7,8,2,3,1,5,6]，使用堆排序时，初始构建的最大堆是这样的[8,7,5,6,3,1,4,2]，这样构建好后，将8与2换位置，数组变为[2,7,5,6,3,1,4][8]，剩余元素[2,7,5,6,3,1,4]在构建最大堆；</p><p>而使用SmoothSort后，初始构建的最大堆变为[3,1,6,2,4,7,5,8]，然后分离8，数组变为[3,1,6,2,4,7,5][8]，剩余部分[3,1,6,2,4,7,5]继续构建最大堆。</p><p>可以看到这样的话最大数已经在数组正确的位置，减少了不必要的交换（8已经在最后，堆排序的话还要和底部元素2进行交换）。</p><p>我们可以看到对于SmoothSort，其隐式数组结构是确定的，与数组本身无关。</p><p>PS：相比堆排序，我们需要构造完全二叉树，即每个父节点下面有两个子节点，但是SmoothSort不用这样，它可以先确定隐式二叉树结构，比如使用完全二叉树，就如上面[3,1,6,2,4,7,5,8]这个例子，也可以不使用这种树结构，比如某个父节点下有三个子节点。</p><p>Edsger Dijkstra（该算法作者）使用了一种分割方法，就是我们上面提到的斐波那契数列（Fibonacci sequence），这样的话，形成的树的兄弟节点的子节点永远不可能有相同的节点数（除为1时）。我们可以看看堆排序，使用的完全二叉树，除最后底部外，其他的节点其子节点都只有两个子节点，是固定的。</p><p>关于为什么没有使用完全二叉树，算法作者认为使用完全二叉树将会和堆排序有相同的算法效率，而且对于大量数据，使用完全二叉树会被分割成更多子树及子树的子树。</p><p>隐式树结构的实现可以很容易地通过一次性地计算斐波那契数字列表和父和子关系表(它们完全不依赖于要排序的值)来实现。但是为了使它成为一种就地（不额外占用空间）排序算法，Edsger Dijkstra以一种巧妙的方式维护了固定数量的整数变量，这样在计算的每个点都可以访问相关信息，而不需要任何表。虽然这样做不会影响算法复杂度，但是代码量大大提高且变得晦涩难懂。</p><h3 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>对于待排序数组，根据 斐波那契数列 构建堆结构；</li><li>每次找到堆结构根节点（最大值）分离出堆结构，剩余部分重新变为合适的堆结构；</li><li>依次进行，当取出堆结构最后一个元素时，排序完成。</li></ol><h3 id="动图演示-1"><a href="#动图演示-1" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-485.gif" alt="upload successful"></p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmoothSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换指定数组两个数的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> index1,<span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp =  array[index1];</span><br><span class="line">        array[index1] = array[index2];</span><br><span class="line">        array[index2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 斐波那契数列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] leonardo = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;</span><br><span class="line">            <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">15</span>, <span class="number">25</span>, <span class="number">41</span>, <span class="number">67</span>, <span class="number">109</span>, <span class="number">177</span>, <span class="number">287</span>, <span class="number">465</span>, <span class="number">753</span>, <span class="number">1219</span>, <span class="number">1973</span>,</span><br><span class="line">            <span class="number">3193</span>, <span class="number">5167</span>, <span class="number">8361</span>, <span class="number">13529</span>, <span class="number">21891</span>, <span class="number">35421</span>, <span class="number">57313</span>, <span class="number">92735</span>, <span class="number">150049</span>, <span class="number">242785</span>,</span><br><span class="line">            <span class="number">392835</span>, <span class="number">635621</span>, <span class="number">1028457</span>, <span class="number">1664079</span>, <span class="number">2692537</span>, <span class="number">4356617</span>, <span class="number">7049155</span>, <span class="number">11405773</span>,</span><br><span class="line">            <span class="number">18454929</span>, <span class="number">29860703</span>, <span class="number">48315633</span>, <span class="number">78176337</span>, <span class="number">126491971</span>, <span class="number">204668309</span>, <span class="number">331160281</span>,</span><br><span class="line">            <span class="number">535828591</span>, <span class="number">866988873</span>, <span class="number">1402817465</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 堆调整函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> currentHeap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> levelIndex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> levels</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">smoothSortFix</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> currentHeap, <span class="keyword">int</span> levelIndex, <span class="keyword">int</span>[] levels)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> prevHeap;</span><br><span class="line">        <span class="keyword">int</span> maxChild;</span><br><span class="line">        <span class="keyword">int</span> childHeap1;</span><br><span class="line">        <span class="keyword">int</span> childHeap2;</span><br><span class="line">        <span class="keyword">int</span> currentLevel;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(levelIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            prevHeap = currentHeap - leonardo[levels[levelIndex]];</span><br><span class="line">            <span class="keyword">if</span>(array[currentHeap]&lt; array[prevHeap]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(levels[levelIndex] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    childHeap1 = currentHeap - <span class="number">1</span> - leonardo[levels[levelIndex] - <span class="number">2</span>];</span><br><span class="line">                    childHeap2 = currentHeap - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(array[prevHeap]&lt; array[childHeap1]) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(array[prevHeap] &lt; array[childHeap2])&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                swap(array,currentHeap,prevHeap);</span><br><span class="line">                currentHeap = prevHeap;</span><br><span class="line">                levelIndex -= <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        currentLevel = levels[levelIndex];</span><br><span class="line">        <span class="keyword">while</span>(currentLevel &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            maxChild = currentHeap;</span><br><span class="line">            childHeap1 = currentHeap - <span class="number">1</span> - leonardo[currentLevel - <span class="number">2</span>];</span><br><span class="line">            childHeap2 = currentHeap - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(array[maxChild]&lt; array[childHeap1])&#123;</span><br><span class="line">                maxChild = childHeap1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(array[maxChild]&lt; array[childHeap2]) &#123;</span><br><span class="line">                maxChild = childHeap2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(maxChild == childHeap1) &#123;</span><br><span class="line">                swap(array,currentHeap, childHeap1);</span><br><span class="line">                currentHeap = childHeap1;</span><br><span class="line">                currentLevel -= <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(maxChild == childHeap2) &#123;</span><br><span class="line">                swap(array,currentHeap, childHeap2);</span><br><span class="line">                currentHeap = childHeap2;</span><br><span class="line">                currentLevel -= <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Smooth排序算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> size</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">smoothSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] levels = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">        <span class="keyword">int</span> toplevel = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(toplevel &gt; <span class="number">0</span> &amp;&amp; levels[toplevel - <span class="number">1</span>] - levels[toplevel] == <span class="number">1</span>) &#123;</span><br><span class="line">                toplevel -= <span class="number">1</span>;</span><br><span class="line">                levels[toplevel] += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(levels[toplevel] != <span class="number">1</span>) &#123;</span><br><span class="line">                toplevel += <span class="number">1</span>;</span><br><span class="line">                levels[toplevel] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                toplevel += <span class="number">1</span>;</span><br><span class="line">                levels[toplevel] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            smoothSortFix(array, i, toplevel, levels);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = size - <span class="number">2</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(levels[toplevel] &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                toplevel -= <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                levels[toplevel] -= <span class="number">1</span>;</span><br><span class="line">                levels[toplevel + <span class="number">1</span>] = levels[toplevel] - <span class="number">1</span>;</span><br><span class="line">                toplevel += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                smoothSortFix(array, i - leonardo[levels[toplevel]], toplevel - <span class="number">1</span>, levels);</span><br><span class="line">                smoothSortFix(array, i, toplevel, levels);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"SmoothSort排序前："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        smoothSort(a,a.length);</span><br><span class="line">        System.out.println(<span class="string">"SmoothSort排序后："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他注意事项-1"><a href="#其他注意事项-1" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ul><li>SmoothSort是排序算法中理论值比较好的，但由于SmoothSort所用的树构建是基于斐波那契数列，复杂度因子较大，所以该算法的实际效率并不是特别好；</li><li>可以看到SmoothSort在数据基本有序的情况下可以达到O(n)的时间复杂度，比堆排序要好；</li><li><p>该排序算法时间复杂度：</p><ul><li>时间复杂度（最好）：O(n)</li><li>时间复杂度（平均）：O(n * log n)</li><li>时间复杂度（最差）：O(n * log n)</li></ul></li><li><p>该排序算法的空间复杂度：O(1)。</p></li><li>该排序算法为不稳定排序算法。</li></ul><h2 id="树形选择排序（TreeSelectionSort）"><a href="#树形选择排序（TreeSelectionSort）" class="headerlink" title="树形选择排序（TreeSelectionSort）"></a>树形选择排序（TreeSelectionSort）</h2><h3 id="简介及原理-2"><a href="#简介及原理-2" class="headerlink" title="简介及原理"></a>简介及原理</h3><p>树形选择排序（TreeSelectionSort）又称锦标赛排序（TournamentSort），是一种选择排序算法。由于其排序比较过程类似于锦标赛，因此得名锦标赛排序。</p><p>对于一个待排序数组，如下[8,6,3,2,9,5]，我们可以两两比较找到一组最小值，拿到这组最小值后在两两比较下去……最终找到最小的值，如下：</p><pre><code>[8,6,3,2,9,5][6,2,5][2,5][2]</code></pre><p>拿到最小值后，我们把最小值的位置填充为无穷大，继续上述比较逻辑。</p><pre><code>[8,6,3,Max,9,5][6,3,5][3,5][3]</code></pre><p>依次进行下去，当数组所有值都为无穷大时，我们可以得到有序数组。因为这个过程很像完全二叉树，因此也被叫做树形选择排序。</p><p>如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-486.jpg" alt="upload successful"></p><h3 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>对于待排序数组，构建一个满二叉树，节点总数 = 叶子节点数*2-1，其中叶子节点数即为数组长度。可以用数组表示这个满二叉树 <code>int [] tree = new int[totalSize + 1]</code>;</li><li>填充二叉树叶子节点，需要比较每个节点的“冠军”放入父节点；</li><li>每次找到根节点（最小的元素）移走，并将最小元素的位置设置为正无穷；</li><li>重复上述比较过程；</li></ol><h3 id="动图演示-2"><a href="#动图演示-2" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-487.gif" alt="upload successful"></p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSelectionSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">treeSelectionSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 数组长度</span></span><br><span class="line">        <span class="keyword">int</span> len = array.length;</span><br><span class="line">        <span class="comment">// 对一个满二叉树，节点总数 = 叶子节点数*2-1</span></span><br><span class="line">        <span class="keyword">int</span> nodeSize = len * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 这里将用数组表示二叉树的存储结构</span></span><br><span class="line">        <span class="keyword">int</span>[] tree = <span class="keyword">new</span> <span class="keyword">int</span>[nodeSize + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">/* 填充叶子节点 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>, j = <span class="number">0</span>; i &gt;= <span class="number">0</span>; i--, j++) &#123;</span><br><span class="line">            tree[nodeSize - j] = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 填充其他节点 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nodeSize - len; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            tree[i] = tree[i * <span class="number">2</span>] &lt; tree[i * <span class="number">2</span> + <span class="number">1</span>] ? tree[i * <span class="number">2</span>] : tree[i * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 将每次找出的最小元素移走 */</span></span><br><span class="line">        <span class="comment">// 数组a的索引</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 最小值的索引</span></span><br><span class="line">        <span class="keyword">int</span> minIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; len) &#123;</span><br><span class="line">            <span class="comment">// 这是tree的根节点，也是最小元素</span></span><br><span class="line">            <span class="keyword">int</span> min = tree[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 将tree中最小的元素取到a[0]中</span></span><br><span class="line">            array[index++] = tree[<span class="number">1</span>];</span><br><span class="line">            minIndex = nodeSize;</span><br><span class="line">            <span class="comment">/* 从最后的叶子节点开始，直到找到最小值的索引 */</span></span><br><span class="line">            <span class="keyword">while</span> (tree[minIndex] != min) &#123;</span><br><span class="line">                minIndex--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将这个最小元素置为最大</span></span><br><span class="line">            tree[minIndex] = Integer.MAX_VALUE;</span><br><span class="line">            <span class="comment">/* 如果这个节点还有父节点，那么就将它的兄弟节点升到父亲节点位置 */</span></span><br><span class="line">            <span class="comment">// 根结点的索引是1</span></span><br><span class="line">            <span class="keyword">while</span> (minIndex &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 这个节点是左节点</span></span><br><span class="line">                <span class="keyword">if</span> (minIndex % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    tree[minIndex / <span class="number">2</span>] = tree[minIndex] &lt; tree[minIndex + <span class="number">1</span>] ? tree[minIndex] : tree[minIndex + <span class="number">1</span>];</span><br><span class="line">                    minIndex = minIndex / <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">// 这个节点是右节点</span></span><br><span class="line">                    tree[minIndex / <span class="number">2</span>] = tree[minIndex] &lt; tree[minIndex - <span class="number">1</span>] ? tree[minIndex] : tree[minIndex - <span class="number">1</span>];</span><br><span class="line">                    minIndex = minIndex / <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"TreeSelectionSort排序前："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        treeSelectionSort(a);</span><br><span class="line">        System.out.println(<span class="string">"TreeSelectionSort排序后："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他注意事项-2"><a href="#其他注意事项-2" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ul><li>可以看到这种排序算法有辅助存储空间较多、和“最大值”进行多余比较等缺点。为了弥补该缺陷，J. willioms 在1964年提出了<a href="(https://www.sakuratears.top/blog/Java%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html#%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88Heap-Sort%EF%BC%89">堆排序</a>;</li><li>该排序算法的时间复杂度为：O(n * log n)；</li><li>该排序算法的空间复杂度为：O(n);</li><li>该排序算法为稳定排序算法。</li></ul><h2 id="美国旗帜排序（AmericanFlagSort）"><a href="#美国旗帜排序（AmericanFlagSort）" class="headerlink" title="美国旗帜排序（AmericanFlagSort）"></a>美国旗帜排序（AmericanFlagSort）</h2><h3 id="简介与原理"><a href="#简介与原理" class="headerlink" title="简介与原理"></a>简介与原理</h3><p>美国旗帜排序（AmericanFlagSort）是<a href="https://www.sakuratears.top/blog/Java%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%88Radix-Sort%EF%BC%89">基数排序（RadixSort）</a>的一个变体。</p><p>和基数排序不同的是，AmericanFlagSort一般排序从数据高位切入，会用一个数组保存位数据信息，再用一个数组记录数据位置。</p><p>之所以称为美国旗帜排序，是因为排序时的算法很像美国星条旗（将数组划分成很多“条纹”）。</p><p>我们来看一下：</p><p>比如对于一个数组[8,100,7622,520,6542,7,8888,33,1234]，该排序算法会先找到它的最大值8888，并获取其位数，得到最大数为4位数，构建一个长度为10的数组，初始值为0，即[0,0,0,0,0,0,0,0,0,0];</p><p>该数组0位表示0-999的数的个数，1位表示1000-1999 的数的个数……依次类推，因此我们可以得到如下数组[5,1,0,0,0,0,1,1,1,0]，同时需要一个位置数组记录位置，默认长度10，初始值为0，即[0,0,0,0,0,0,0,0,0,0]；</p><p>如何表示数据位置呢？我们使用<code>offset[0] = 0;offset[i] = count[i - 1] + offset[i - 1];</code>来记录数据位置，得到如下数组[0,5,6,6,6,6,6,7,8,9];</p><p>然后结合原数组，将数据按照高位基数排序，得到如下数组[8,100,33,520,7,1234,6542,7622,8888]，继续根据第二高位进行排序，相当于重复上述过程，可以得到数组[8,33,7,100,520,1234,6542,7622,8888];</p><p>继续第三高位排序得到[8,7,33,100,520,1234,6542,7622,8888]，继续最后一位排序可以得到[7,8,33,100,520,1234,6542,7622,8888]，为最终有序数组。</p><h3 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>对于未排序数组，找到它的基数N，比如对于十进制数，基数是10（数的位数为0-9，不可能有其他值）；对于二进制，基数是2 （只有0，1）；对于字符串，通常使用256或者128作为基数；</li><li>构建两个数组，一个用于存储数据位信息，另一个用来记录数据位置；</li><li>待排序数组根据上面两个数组进行高位排序，排序完成后高位上数字较小者都在前面，较大者在后面；</li><li>继续对第二高位、第三高位……重复3过程，直到排序完成。</li></ol><h3 id="动图演示-3"><a href="#动图演示-3" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-488.gif" alt="upload successful"></p><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmericanFlagSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 10位数的基数是10</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUMBER_OF_BUCKETS = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">americanFlagSort</span><span class="params">(<span class="keyword">int</span>[] unsorted)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Max number of digits</span></span><br><span class="line">        <span class="keyword">int</span> numberOfDigits = getMaxNumberOfDigits(unsorted);</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numberOfDigits - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            max *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(unsorted, <span class="number">0</span>, unsorted.length, max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] unsorted, <span class="keyword">int</span> start, <span class="keyword">int</span> length, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// First pass - find counts</span></span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[NUMBER_OF_BUCKETS];</span><br><span class="line">        <span class="keyword">int</span>[] offset = <span class="keyword">new</span> <span class="keyword">int</span>[NUMBER_OF_BUCKETS];</span><br><span class="line">        <span class="keyword">int</span> digit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = unsorted[i];</span><br><span class="line">            digit = getDigit(d, divisor);</span><br><span class="line">            count[digit]++;</span><br><span class="line">        &#125;</span><br><span class="line">        offset[<span class="number">0</span>] = start;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; NUMBER_OF_BUCKETS; i++) &#123;</span><br><span class="line">            offset[i] = count[i - <span class="number">1</span>] + offset[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Second pass - move into position</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; NUMBER_OF_BUCKETS; b++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (count[b] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> origin = offset[b];</span><br><span class="line">                <span class="keyword">int</span> from = origin;</span><br><span class="line">                <span class="keyword">int</span> num = unsorted[from];</span><br><span class="line">                unsorted[from] = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    digit = getDigit(num, divisor);</span><br><span class="line">                    <span class="keyword">int</span> to = offset[digit]++;</span><br><span class="line">                    count[digit]--;</span><br><span class="line">                    <span class="keyword">int</span> temp = unsorted[to];</span><br><span class="line">                    unsorted[to] = num;</span><br><span class="line">                    num = temp;</span><br><span class="line">                    from = to;</span><br><span class="line">                &#125; <span class="keyword">while</span> (from != origin);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (divisor &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// Sort the buckets</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUMBER_OF_BUCKETS; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> begin = (i &gt; <span class="number">0</span>) ? offset[i - <span class="number">1</span>] : start;</span><br><span class="line">                <span class="keyword">int</span> end = offset[i];</span><br><span class="line">                <span class="keyword">if</span> (end - begin &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    sort(unsorted, begin, end, divisor / <span class="number">10</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取最大值 位长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unsorted</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxNumberOfDigits</span><span class="params">(<span class="keyword">int</span>[] unsorted)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : unsorted) &#123;</span><br><span class="line">            temp = (<span class="keyword">int</span>) Math.log10(i) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (temp &gt; max) &#123;</span><br><span class="line">                max = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取该位数字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> integer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> divisor</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDigit</span><span class="params">(<span class="keyword">int</span> integer, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (integer / divisor) % <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"AmericanFlagSort排序前："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        americanFlagSort(a);</span><br><span class="line">        System.out.println(<span class="string">"AmericanFlagSort排序后："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他注意事项-3"><a href="#其他注意事项-3" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ul><li>可以看到该排序和基数排序一样，只能用于正整数或者可以表示成正整数的数据排序；</li><li>该排序也是一种就地排序算法，除了需要新建两个基数N的数组外，排序过程都是在待排序数组内部进行的；</li><li>该排序效率最高的时候是处理二进制数据的时候，这时候可以使用移位操作来避免一些求幂运算；</li><li>因为该排序是比较随机的，每个桶里的数的分布完全取决于数据集，因此该排序对大数据集并不友好；</li><li>如果对于纯字符串排序，数据量较多的情况下，该排序方法理论上是优于快排的；</li><li><p>该排序方法的时间复杂度：</p><ul><li>时间复杂度（最好）：O(n*k/d)</li><li>时间复杂度（平均）：O(n*k/d)</li><li>时间复杂度（最差）：O(n*k/d)</li></ul></li><li><p>该排序算法的空间复杂度：O(1)</p></li><li>该排序算法为不稳定排序算法</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>今天的排序算法就介绍到这里，后面我会介绍两种比较有意思的排序，一个是双调排序，另一个是TimSort，TimSort是目前Java使用的排序，我们来详细了解一下它。对于双调排序，它是一种可以进行多路归并的并行排序算法，也是比较有特点的。</p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>本文所有源码详见我的 <a href="https://github.com/JavaZWT" rel="external nofollow noopener noreferrer" target="_blank">GitHub</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="排序算法" scheme="https://www.sakuratears.top/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序算法（三）</title>
    <link href="https://www.sakuratears.top/blog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89.html"/>
    <id>https://www.sakuratears.top/blog/排序算法（三）.html</id>
    <published>2019-08-26T13:55:00.000Z</published>
    <updated>2019-08-26T14:09:26.265Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上篇文章<a href="https://www.sakuratears.top/blog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89.html">排序算法（二）</a>我们介绍了10种排序算法，今天我们再来介绍一些其他的排序算法。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>今天我们介绍7种排序算法，它们如下：</p><table><thead><tr><th>Sort Name</th><th>Time(Best)</th><th>Time(Average)</th><th>Time(Worst)</th><th>Memory</th><th>Stable</th></tr></thead><tbody><tr><td>BinaryTreeSort</td><td>O(n)</td><td>O(n * log n)</td><td>O(n * log n)</td><td>O(n)</td><td>Yes</td></tr><tr><td>FlashSort</td><td>O(n)</td><td>O(n+k)</td><td>O(n^2)</td><td>O(n+k)</td><td>Yes</td></tr><tr><td>PatienceSort</td><td>O(n)</td><td>O(n * log n)</td><td>O(n * log n)</td><td>O(n)</td><td>No</td></tr><tr><td>StoogeSort</td><td>——</td><td>——</td><td>O(n^(log 3 / log 1.5))</td><td>O(n)</td><td>Yes</td></tr><tr><td>PancakeSort</td><td>O(n)</td><td>O(n^2)</td><td>O(n^2)</td><td>O(n)</td><td>No</td></tr><tr><td>InPlaceMergeSort</td><td>——</td><td>——</td><td>O(n * (log n)^2)</td><td>O(1)</td><td>Yes</td></tr><tr><td>StrandSort</td><td>O(n)</td><td>O(n^2)</td><td>O(n^2)</td><td>O(n)</td><td>Yes</td></tr></tbody></table><p>我们分别来看下。</p><h2 id="二叉排序树排序（BinaryTreeSort）"><a href="#二叉排序树排序（BinaryTreeSort）" class="headerlink" title="二叉排序树排序（BinaryTreeSort）"></a>二叉排序树排序（BinaryTreeSort）</h2><h3 id="简介及原理"><a href="#简介及原理" class="headerlink" title="简介及原理"></a>简介及原理</h3><p>二叉排序树排序（BinaryTreeSort），其原理是利用二叉树的特性，较小值依次比较放在树的左边，较大值依次比较放在树的右边，形成一个数据二叉树，然后将数据从左到右遍历出来即可。</p><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>对于待排序数组array，构建一个二叉树tree，根节点可以取array[0]，此时根节点的左右叶子节点为null；</li><li>对数组里每个元素，放入二叉树tree，如果小于根节点数值，应该放到左边，左边如果没有节点就创建一个并放入，如果有则需要比较其节点值和放入值大小，进而确定要放置的位置；右边同理；</li><li>进而我们会得到一个二叉树，我们从左向右遍历二叉树，就可以得到有序的数组。</li></ol><h3 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-475.gif" alt="upload successful"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] binaryTreeSort(<span class="keyword">int</span>[] array)&#123;</span><br><span class="line">        BinaryNode root = <span class="keyword">new</span> BinaryNode(array[<span class="number">0</span>], <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;array.length; i++)&#123;</span><br><span class="line">            root.addChild(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = BinaryNode.getSortedList(root);</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++) &#123;</span><br><span class="line">            result[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"BinaryTreeSort排序前："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        <span class="keyword">int</span> [] s = binaryTreeSort(a);</span><br><span class="line">        System.out.println(<span class="string">"BinaryTreeSort排序后："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树节点类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryNode</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点当前值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 左节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> BinaryNode lChild;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 右节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> BinaryNode rChild;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 排序结果集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; resultList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryNode</span><span class="params">(<span class="keyword">int</span> value, BinaryNode l, BinaryNode r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.lChild = l;</span><br><span class="line">        <span class="keyword">this</span>.rChild = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> BinaryNode <span class="title">getLChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> BinaryNode <span class="title">getRChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">getSortedList</span><span class="params">(BinaryNode root)</span> </span>&#123;</span><br><span class="line">        iterate(root);</span><br><span class="line">        <span class="keyword">return</span> resultList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加一个节点</span></span><br><span class="line"><span class="comment">     * **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addChild</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; value)&#123;</span><br><span class="line">            <span class="keyword">if</span>(lChild!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                lChild.addChild(n);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                lChild = <span class="keyword">new</span> BinaryNode(n, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(rChild!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                rChild.addChild(n);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                rChild = <span class="keyword">new</span> BinaryNode(n, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代赋值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterate</span><span class="params">(BinaryNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.lChild!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            iterate(root.getLChild());</span><br><span class="line">        &#125;</span><br><span class="line">        resultList.add(root.getValue());</span><br><span class="line">        <span class="keyword">if</span>(root.rChild!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            iterate(root.getRChild());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ul><li><p>这儿是否可以使用平衡二叉树？</p><p> 可以，但平衡二叉树可以提高单个数据查找性能，我们这儿需要处理全部数据，同时平衡二叉树插入时涉及到树的旋转变化等，因此使用平衡二叉树的效率不一定比普通二叉树效率高。</p><p> 某些情况下，使用平衡二叉树递归取值的栈深度会比普通二叉树要低。</p></li><li><p>该排序算法的时间复杂度：</p><p>时间复杂度（最好）：O(n)</p><p>时间复杂度（平均）：O(n * log n)</p><p>时间复杂度（最差）：O(n * log n)</p></li><li><p>该排序算法空间复杂度：O(n)</p></li><li>该排序算法是稳定排序算法。</li></ul><h2 id="闪电排序（FlashSort）"><a href="#闪电排序（FlashSort）" class="headerlink" title="闪电排序（FlashSort）"></a>闪电排序（FlashSort）</h2><h3 id="简介及原理-1"><a href="#简介及原理-1" class="headerlink" title="简介及原理"></a>简介及原理</h3><p>闪电排序（FlashSort）是由Karl-Dietrich Neubert在1997年发展而来的一种排序算法，并且在欧洲理论计算机协会的新闻简报上发表了该算法。</p><p>该算法类似于<a href="https://www.sakuratears.top/blog/Java%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html#%E6%A1%B6%E6%8E%92%E5%BA%8F%EF%BC%88Bucket-Sort%EF%BC%89">桶排序</a>，主要改进了对使用桶的预测。</p><p>我们知道，对于桶排序，我们首先要确定桶的数量，不能太多或者太少。</p><p>太多的话，桶中元素少，或者无用桶多，会浪费内存；太少的话，桶中元素多，每个桶中这些元素进行由大到小（或者由小到大）排序时就会比较耗时。（可参考HashMap理解桶排序）</p><p>因此桶的数量对排序性能的影响也不能忽视，FlashSort就是可以提前预知桶的大致数量及元素在桶中的位置，使其元素尽量利用每个桶，然后进行排序的。</p><p><strong>FlashSort是如何预测的呢？</strong></p><p>我们知道，桶排序桶的数量bucketCount一般为 INT[(Amax - Amin)/Asize] +1，对于如下数组[1,152,1000,8763,3,88,1000001,666,9999,100]，根据公式可以算出需要的桶的数量为(1000001-1)/10 +1 = 1000001。</p><p>显然浪费了大量桶（内存），当然bucketCount也可以设置为数组长度，但是如果有一个长度为100000的数组，数组元素只有[0-9]之间的元素，我们显然设置的bucketCount也会不合适。</p><p>你一定会说可以取 INT[(Amax - Amin)/Asize] +1 或者数组长度中的最小值啊，哈哈，当然这么想也正确，但是即使这样，桶排序也不一定会完全把所有的桶充分利用，也会出现空桶的情况，因而造成内存浪费。</p><p>FlashSort就可以充分利用桶吗？ 是的，其数据的位置主要依赖一个公式，如下：</p><pre><code>K(Ai) = 1 + INT[ (m-1)(Ai-Amin)/(Amax-Amin) ]</code></pre><p>这个公式可以算出数组的Ai项在桶中的位置。</p><p>比如如下数组[6,2,4,1,5,9]，m如果取数组长度的话 m=6（也表明桶的数量为m个），我们可以算出：</p><ul><li>K(6) = 1 + 5 * 5/8 = 4</li><li>K(2) = 1 + 5 * 1/8 = 1</li><li>K(4) = 1 + 5 * 3/8 = 2</li><li>K(1) = 1 + 5 * 0/8 = 1</li><li>K(5) = 1 + 5 * 4/8 = 3</li><li>K(9) = 1 + 5 * 8/8 = 6</li></ul><p>可以看到极大的利用了桶，在数据量较多的情况下，与桶排序相比效果更明显。</p><p>可以看到上面我们m （桶的数量）取的数组长度，这显然不太合理，我们m一般取 0.1n (n代表数组长度)，当m&lt;1 时，m=1。这样保证桶尽量少的浪费的前提下，尽可能减少桶的使用数量。</p><p>如果数组过大，m过小，会导致每个桶内数据多，排序浪费较多时间；如果数据少，但桶较多，会导致内存浪费。所以对于具体数组，m也可以自己指定，以达到排序效率和空间的优化平衡。</p><h3 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h3><ul><li>构建M个桶，M可以取0.1N （N数组长度）或者自定义；</li><li>根据FlashSort的K(Ai)计算公式，找到每个元素所在的桶，放入元素；</li><li>对于每个桶中的元素，如果元素个数大于等于2，需要进行内部排序；</li><li>从小到大（或者大到小）依次取出桶中元素，得到有序数组。</li></ul><h3 id="动图演示-1"><a href="#动图演示-1" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-476.gif" alt="upload successful"></p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlashSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">flashSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//桶排序</span></span><br><span class="line">        partialFlashSort(array, array.length);</span><br><span class="line">        <span class="comment">//桶内元素使用插入排序</span></span><br><span class="line">        insertionSort(array);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">partialFlashSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//m值，取0.1n，也可以自由指定</span></span><br><span class="line">        <span class="keyword">int</span> bucketSize = n / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (bucketSize &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            bucketSize = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//构建bucket</span></span><br><span class="line">        <span class="keyword">int</span>[] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[bucketSize];</span><br><span class="line">        <span class="keyword">int</span> i, j, k;</span><br><span class="line">        <span class="keyword">int</span> min = a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> maxIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到最大最小值</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt; min) &#123;</span><br><span class="line">                min = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; a[maxIndex]) &#123;</span><br><span class="line">                maxIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min == a[maxIndex]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算系数</span></span><br><span class="line">        <span class="keyword">double</span> c1 = ((<span class="keyword">double</span>) bucketSize - <span class="number">1</span>) / (a[maxIndex] - min);</span><br><span class="line">        <span class="comment">//计算元素位置</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            k = (<span class="keyword">int</span>) (c1 * (a[i] - min));</span><br><span class="line">            buckets[k]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt; bucketSize; k++) &#123;</span><br><span class="line">            buckets[k] += buckets[k - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//元素入桶</span></span><br><span class="line">        <span class="keyword">int</span> hold = a[maxIndex];</span><br><span class="line">        a[maxIndex] = a[<span class="number">0</span>];</span><br><span class="line">        a[<span class="number">0</span>] = hold;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> nmove = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flash;</span><br><span class="line">        j = <span class="number">0</span>;</span><br><span class="line">        k = bucketSize - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (nmove &lt; n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; (buckets[k] - <span class="number">1</span>)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">                k = (<span class="keyword">int</span>) (c1 * (a[j] - min));</span><br><span class="line">            &#125;</span><br><span class="line">            flash = a[j];</span><br><span class="line">            <span class="keyword">while</span> (j != buckets[k]) &#123;</span><br><span class="line">                k = (<span class="keyword">int</span>) (c1 * (flash - min));</span><br><span class="line">                hold = a[buckets[k] - <span class="number">1</span>];</span><br><span class="line">                a[buckets[k] - <span class="number">1</span>] = flash;</span><br><span class="line">                flash = hold;</span><br><span class="line">                buckets[k]--;</span><br><span class="line">                nmove++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, j, hold;</span><br><span class="line">        <span class="keyword">for</span> (i = a.length - <span class="number">3</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i + <span class="number">1</span>] &lt; a[i]) &#123;</span><br><span class="line">                hold = a[i];</span><br><span class="line">                j = i;</span><br><span class="line">                <span class="keyword">while</span> (a[j + <span class="number">1</span>] &lt; hold) &#123;</span><br><span class="line">                    a[j] = a[j + <span class="number">1</span>];</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                a[j] = hold;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"FlashSort排序前："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        flashSort(a);</span><br><span class="line">        System.out.println(<span class="string">"FlashSort排序后："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他注意事项-1"><a href="#其他注意事项-1" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ul><li>可以看到FlashSort只是优化了桶排序的元素存放桶的位置，使其尽量均匀分布于每个桶，而且选择合适的m值（桶数量）也是至关重要的（无论FlashSort或者桶排序）；</li><li><p>该算法时间复杂度：</p><ul><li>时间复杂度（最好）：O(n)</li><li>时间复杂度（平均）：O(n+k)</li><li>时间复杂度（最差）：O(n^2)</li></ul></li><li><p>该算法空间复杂度：O(n+k)</p></li><li>该算法为稳定排序算法。</li></ul><h2 id="耐心排序（PatienceSort）"><a href="#耐心排序（PatienceSort）" class="headerlink" title="耐心排序（PatienceSort）"></a>耐心排序（PatienceSort）</h2><h3 id="简介及原理-2"><a href="#简介及原理-2" class="headerlink" title="简介及原理"></a>简介及原理</h3><p>耐心排序（PatienceSort）是将数组的元素分类成很多堆再串接回数组的一种排序算法。受到纸牌游戏的启发和命名。</p><p>我们在Windows系统上一定玩过纸牌游戏吧，我们知道，无序的纸牌要变为有序，我们需要将无序的纸牌通过操作进行有序分堆，最后在将这些堆纸牌合并生成有序的结果。</p><p>我们后面的动图也会模拟纸牌来看下耐心排序的执行过程。</p><h3 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>创建一个堆数组；</li><li>比较当前指向的元素和每个堆的第一个元素；</li><li>若当前元素比所有堆的第一个元素大，创建新的堆并加入到堆数组中；</li><li>如果当前元素比堆内的第一个元素小，就放入该堆头部作为新的第一个元素；</li><li>分类完后将每个堆有两种处理方式，可以通过合并后使用插入排序形成有序数列，也可以使用优先级队列依次取出元素完成排序。</li></ol><p>PS：其实第4步，如果元素找到了多个符合条件的堆，可以放到任意一个堆里作为首元素。</p><h3 id="动图演示-2"><a href="#动图演示-2" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-477.gif" alt="upload successful"></p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><p>这里的代码有两个，都比较好理解，第一个是将生成的堆合并，然后使用插入排序处理；第二个是生成堆后，使用优先级队列处理堆中数据。</p><p>大家都可以看下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PatienceSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">patienceSort</span><span class="params">(<span class="keyword">int</span>[] theArray)</span> </span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; newList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; theArray.length; i++) &#123;</span><br><span class="line">            List&lt;Integer&gt; bucketList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">//先开始创建一个堆</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                bucketList.add(theArray[i]);</span><br><span class="line">                newList.add(bucketList);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">boolean</span> isOk = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; newList.size(); j++) &#123;</span><br><span class="line">                    <span class="comment">//如果当前元素比堆内的第一个元素小，就放入该堆头部作为新的第一个元素，然后执行下个元素判断</span></span><br><span class="line">                    <span class="comment">//这儿我们直接放到第一个符合的堆里了，其实放到其它符合的也是可以的，放到最后一个符合的堆里还可以解决子序列问题</span></span><br><span class="line">                    <span class="keyword">if</span> (theArray[i] &lt; (<span class="keyword">int</span>) ((List) newList.get(j)).get(<span class="number">0</span>)) &#123;</span><br><span class="line">                        (newList.get(j)).add(<span class="number">0</span>, theArray[i]);</span><br><span class="line">                        isOk = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果当前元素比所有堆内的第一个元素大，就创建个新堆，把元素作为第一个元素放进去</span></span><br><span class="line">                <span class="keyword">if</span> (!isOk) &#123;</span><br><span class="line">                    bucketList.add(theArray[i]);</span><br><span class="line">                    newList.add(bucketList);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">////生成的堆合并，而后使用插入排序</span></span><br><span class="line">        <span class="keyword">int</span> q = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; newList.size(); m++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; (newList.get(m)).size(); n++) &#123;</span><br><span class="line">                theArray[q] = (<span class="keyword">int</span>) ((List) newList.get(m)).get(n);</span><br><span class="line">                q++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//插入排序</span></span><br><span class="line">        <span class="keyword">int</span> tmp;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; theArray.length; i++) &#123;</span><br><span class="line">            tmp = theArray[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; theArray[j] &gt; tmp; j--) &#123;</span><br><span class="line">                theArray[j + <span class="number">1</span>] = theArray[j];</span><br><span class="line">            &#125;</span><br><span class="line">            theArray[j + <span class="number">1</span>] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">200</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"PatienceSort排序前："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        patienceSort(a);</span><br><span class="line">        System.out.println(<span class="string">"PatienceSort排序后："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E extends Comparable&lt;? <span class="keyword">super</span> E&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">patienceSort</span><span class="params">(E[] n)</span> </span>&#123;</span><br><span class="line">        List&lt;Pile&lt;E&gt;&gt; piles = <span class="keyword">new</span> ArrayList&lt;Pile&lt;E&gt;&gt;();</span><br><span class="line">        <span class="comment">//生成堆</span></span><br><span class="line">        <span class="keyword">for</span> (E x : n) &#123;</span><br><span class="line">            Pile&lt;E&gt; newPile = <span class="keyword">new</span> Pile&lt;E&gt;();</span><br><span class="line">            newPile.push(x);</span><br><span class="line">            <span class="keyword">int</span> i = Collections.binarySearch(piles, newPile);</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                i = ~i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i != piles.size()) &#123;</span><br><span class="line">                piles.get(i).push(x);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                piles.add(newPile);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用优先级队列处理数据</span></span><br><span class="line">        PriorityQueue&lt;Pile&lt;E&gt;&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;Pile&lt;E&gt;&gt;(piles);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; n.length; c++) &#123;</span><br><span class="line">            Pile&lt;E&gt; smallPile = heap.poll();</span><br><span class="line">            n[c] = smallPile.pop();</span><br><span class="line">            <span class="keyword">if</span> (!smallPile.isEmpty()) &#123;</span><br><span class="line">                heap.offer(smallPile);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">assert</span>(heap.isEmpty());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pile</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;? <span class="title">super</span> <span class="title">E</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Pile</span>&lt;<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Pile&lt;E&gt; y)</span> </span>&#123; <span class="keyword">return</span> peek().compareTo(y.peek()); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他注意事项-2"><a href="#其他注意事项-2" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ul><li><p>该算法有一个变体，可以有效地计算给定数据中的最长增长子列和最长递减子列。比如有个数组[7,8,2,3,5,8,6,4,3,1,5,9]，我们可以看到最长增长子列为[2,3,5,8]，最长递减子列为[8,6,4,3,1]</p><p>我们使用耐心排序算法来看下：</p><p>算法描述的PS部分：如果元素找到了多个符合条件的堆，可以放到任意一个堆里作为首元素，我们在这儿放到最后一个符合的堆中。</p><ul><li>根据耐心排序，我们可以把[7,8,2,3,5,8,6,4,3,1,5,9]数组按照上述算法分为如下堆数组： [3,7],[2,8],[5],[1,3,4,6,8],[5],[9]。显而易见最长递减子列为[1,3,4,6,8]的反向序列。</li><li>我们对于上述所讲的算法，也可以反过来，即比较当前指向的元素和每个堆的第一个元素，如果当前元素大于该堆第一个元素，在进行放入操作，这样可以得到如下堆数组：[8,7],[8,5,3,2],[6],[4],[3],[9,5,1]。显而易见[8,5,3,2]是最长递增子列的反向序列。</li></ul></li><li><p>该排序算法时间复杂度：</p><ul><li>时间复杂度（最好）：O(n)</li><li>时间复杂度（平均）：O(n * log n)</li><li>时间复杂度（最差）：O(n * log n)</li></ul></li><li><p>该排序算法空间复杂度：O(n)</p></li><li>该排序算法为不稳定排序算法</li></ul><h2 id="臭皮匠排序（StoogeSort）"><a href="#臭皮匠排序（StoogeSort）" class="headerlink" title="臭皮匠排序（StoogeSort）"></a>臭皮匠排序（StoogeSort）</h2><h3 id="简介及原理-3"><a href="#简介及原理-3" class="headerlink" title="简介及原理"></a>简介及原理</h3><p>臭皮匠排序（StoogeSort）是一种低效的递归排序算法，是由Howard、Fine等教授提出的所谓“漂亮的”排序算法，代码很漂亮但是很耗时。</p><p>臭皮匠排序翻译的由来：因为这个排序和3有很大关系（3个臭皮匠）。</p><p>我们来看下算法描述：</p><h3 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>如果最后一个值小于第一个值，则交换这两个数；</li><li>如果当前集合元素数量大于等于3：<ol><li>使用臭皮匠排序前2/3的元素；</li><li>使用臭皮匠排序后2/3的元素；</li><li>再次使用臭皮匠排序前2/3的元素。</li></ol></li></ol><h3 id="动图演示-3"><a href="#动图演示-3" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-478.gif" alt="upload successful"></p><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoogeSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stoogeSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        stoogeSort(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stoogeSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果第一个数大于最后一个数，交换位置</span></span><br><span class="line">        <span class="keyword">if</span> (array[low] &gt; array[high]) &#123;</span><br><span class="line">            swap(array, low, high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (low + <span class="number">1</span> &gt;= high)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> third = (high - low + <span class="number">1</span>) / <span class="number">3</span>;</span><br><span class="line">        <span class="comment">//排序前2/3数组元素</span></span><br><span class="line">        stoogeSort(array, low, high - third);</span><br><span class="line">        <span class="comment">//排序后2/3数组元素</span></span><br><span class="line">        stoogeSort(array, low + third, high);</span><br><span class="line">        <span class="comment">//排序前2/3数组元素</span></span><br><span class="line">        stoogeSort(array, low, high - third);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b == c)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = a[b];</span><br><span class="line">        a[b] = a[c];</span><br><span class="line">        a[c] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"StoogeSort排序前："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        stoogeSort(a);</span><br><span class="line">        System.out.println(<span class="string">"StoogeSort排序后："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他注意事项-3"><a href="#其他注意事项-3" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ul><li>该算法是一种低效的递归排序算法，甚至慢于冒泡排序，相比经典排序，臭皮匠排序性能十分差；</li><li><p>该算法的时间复杂度：</p><p> 时间复杂度（最差）：O(n^(log 3 / log 1.5))</p></li><li><p>该算法的空间复杂度：O(n)</p></li><li>该排序算法为稳定排序算法。</li></ul><h2 id="煎饼排序（PancakeSort）"><a href="#煎饼排序（PancakeSort）" class="headerlink" title="煎饼排序（PancakeSort）"></a>煎饼排序（PancakeSort）</h2><h3 id="简介及原理-4"><a href="#简介及原理-4" class="headerlink" title="简介及原理"></a>简介及原理</h3><p>煎饼排序（PancakeSort），我们对于排序数组，可以看成一叠大大小小的煎饼，假设我们有一把锅铲，可以每次从任意位置铲起上方全部煎饼并翻面，最终我们可以实现按煎饼大小进行排序的煎饼堆。</p><p>比如对于一个数组 [3,1,3,6,8,2,7,1]，我们把它看成煎饼堆，则我们使用“锅铲”翻转的过程如下：</p><ol><li>[3,1,3,6,8,2,7,1]   初始化</li><li>[8,6,3,1,3,2,7,1]   先把“大煎饼”8翻转到上面</li><li>[1,7,2,3,1,3,6,8]   再把“大煎饼”8翻转到下面</li><li>[7,1,2,3,1,3,6,8]   再把“第二大煎饼”7翻转到上面</li><li>[6,3,1,3,2,1,7,8]   再把7翻转到下面</li><li>[1,2,3,1,3,6,7,8]   再把6翻转到下面</li><li>[3,2,1,1,3,6,7,8]   再把3翻转到上面</li><li>[1,1,2,3,3,6,7,8]   再把3翻转到下面，完成排序</li></ol><h3 id="算法描述-4"><a href="#算法描述-4" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>对于待排序数组，找到最大值最小值及索引；</li><li>将最大值翻转到顶部，在翻转到数组底部；</li><li>此时再从未排序数组里找到最大值及索引，重复1、2过程。</li></ol><h3 id="动图演示-4"><a href="#动图演示-4" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-479.gif" alt="upload successful"></p><h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PancakeSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 翻转</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">flip</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] heap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (n + <span class="number">1</span>) / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = heap[i];</span><br><span class="line">            heap[i] = heap[n - i];</span><br><span class="line">            heap[n - i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取最小最大值数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] minmax(<span class="keyword">int</span> n, <span class="keyword">int</span>[] heap) &#123;</span><br><span class="line">        <span class="keyword">int</span> xm, xM;</span><br><span class="line">        xm = xM = heap[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> posm = <span class="number">0</span>, posM = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (heap[i] &lt; xm) &#123;</span><br><span class="line">                xm = heap[i];</span><br><span class="line">                posm = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (heap[i] &gt; xM) &#123;</span><br><span class="line">                xM = heap[i];</span><br><span class="line">                posM = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;posm, posM&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> dir, <span class="keyword">int</span>[] heap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] mM = minmax(n, heap);</span><br><span class="line">        <span class="keyword">int</span> bestXPos = mM[dir];</span><br><span class="line">        <span class="keyword">int</span> altXPos = mM[<span class="number">1</span> - dir];</span><br><span class="line">        <span class="keyword">boolean</span> flipped = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bestXPos == n - <span class="number">1</span>) &#123;</span><br><span class="line">            --n;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bestXPos == <span class="number">0</span>) &#123;</span><br><span class="line">            flip(n - <span class="number">1</span>, heap);</span><br><span class="line">            --n;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (altXPos == n - <span class="number">1</span>) &#123;</span><br><span class="line">            dir = <span class="number">1</span> - dir;</span><br><span class="line">            --n;</span><br><span class="line">            flipped = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            flip(bestXPos, heap);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(n, dir, heap);</span><br><span class="line">        <span class="keyword">if</span> (flipped) &#123;</span><br><span class="line">            flip(n, heap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pancakeSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        sort(array.length, <span class="number">1</span>, array);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"PancakeSort排序前："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        pancakeSort(a);</span><br><span class="line">        System.out.println(<span class="string">"PancakeSort排序后："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他注意事项-4"><a href="#其他注意事项-4" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ul><li><p>煎饼排序的一个问题变种为焦煎饼排序，即对于我们的煎饼，每张煎饼都有一面是烤焦的，最终除了按照大小排序以外还要让所有焦面向下；</p><p>  焦煎饼问题： 比如对于上面的[3,1,3,6,8,2,7,1]数组，它们的右面都是“焦”的，我们按照上面的步骤走，会发现当执行到第4步得到[7,1,2,3,1,3,6,8]，其中[7,1][3,1,3,6,8]是焦面向下，[2]是焦面向上的，我们执行第5步把7翻转到底下时，7的焦面就向上了，就不符合要求了，因此这时候我们需要在单独翻转一次“煎饼”7，然后把[7,1,2,3,1,3,6]整个翻转一下。</p><p>  关于这部分的代码我就略过了，有兴趣的同学可以自己写一下。关于如何表示焦煎饼的正反两面也可以思考下。</p></li><li><p>煎饼排序的时间复杂度：</p><ul><li>时间复杂度（最好）：O(n)</li><li>时间复杂度（平均）：O(n^2)</li><li>时间复杂度（最差）：O(n^2)</li></ul></li><li><p>该排序算法的空间复杂度：O(n)</p></li><li>该排序算法是一种不稳定排序算法。</li></ul><h2 id="原地归并排序（InPlaceMergeSort）"><a href="#原地归并排序（InPlaceMergeSort）" class="headerlink" title="原地归并排序（InPlaceMergeSort）"></a>原地归并排序（InPlaceMergeSort）</h2><h3 id="简介及原理-5"><a href="#简介及原理-5" class="headerlink" title="简介及原理"></a>简介及原理</h3><p>原地归并排序（InPlaceMergeSort）是<a href="https://www.sakuratears.top/blog/Java%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%88Merge-Sort%EF%BC%89">归并排序（MergeSort）</a>的一个变种。</p><p>我们知道，当使用归并排序时，我们需要借助辅助数组。原地归并排序可以使我们不使用辅助数组即可完成目标数组的排序。</p><h3 id="算法描述-5"><a href="#算法描述-5" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>将长度为n的数组分为两个n/2的子序列；</li><li>对两个子序列分别进行归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ol><h3 id="动图演示-5"><a href="#动图演示-5" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-480.gif" alt="upload successful"></p><h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InPlaceMergeSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inPlaceMergeSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        inPlaceMergeSort(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inPlaceMergeSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> first, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid, lt, rt;</span><br><span class="line">        <span class="keyword">int</span> tmp;</span><br><span class="line">        <span class="keyword">if</span> (first &gt;= last) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mid = (first + last) / <span class="number">2</span>;</span><br><span class="line">        inPlaceMergeSort(array, first, mid);</span><br><span class="line">        inPlaceMergeSort(array, mid + <span class="number">1</span>, last);</span><br><span class="line">        lt = first;</span><br><span class="line">        rt = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// One extra check:  can we SKIP the merge?</span></span><br><span class="line">        <span class="keyword">if</span> (array[mid] &lt;= array[rt]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (lt &lt;= mid &amp;&amp; rt &lt;= last) &#123;</span><br><span class="line">            <span class="comment">// Select from left:  no change, just advance lt</span></span><br><span class="line">            <span class="keyword">if</span> (array[lt] &lt;= array[rt]) &#123;</span><br><span class="line">                lt++;</span><br><span class="line">                <span class="comment">// Select from right:  rotate [lt..rt] and correct</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Will move to [lt]</span></span><br><span class="line">                tmp = array[rt];</span><br><span class="line">                System.arraycopy(array, lt, array, lt + <span class="number">1</span>, rt - lt);</span><br><span class="line">                array[lt] = tmp;</span><br><span class="line">                <span class="comment">// EVERYTHING has moved up by one</span></span><br><span class="line">                lt++;</span><br><span class="line">                mid++;</span><br><span class="line">                rt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Whatever remains in [rt..last] is in place</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"InPlaceMergeSort排序前："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        inPlaceMergeSort(a);</span><br><span class="line">        System.out.println(<span class="string">"InPlaceMergeSort排序后："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他注意事项-5"><a href="#其他注意事项-5" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ul><li><p>该排序的时间复杂度与归并排序相当：</p><p>  时间复杂度（最差）：O(n * (log n)^2)</p></li><li><p>由于未使用辅助数组，因此该排序的空间复杂度为：O(1)</p></li><li>该排序为稳定排序算法。</li></ul><h2 id="Strand排序（StrandSort）"><a href="#Strand排序（StrandSort）" class="headerlink" title="Strand排序（StrandSort）"></a>Strand排序（StrandSort）</h2><h3 id="简介及原理-6"><a href="#简介及原理-6" class="headerlink" title="简介及原理"></a>简介及原理</h3><p>Strand排序（StrandSort）又称串排序、线排序，其原理主要和子有序数组有关。</p><p>这儿的子有序数组是这样定义的：比如一个数组[5,3,7,8,2,1,9]，则它的子有序数组为[5,7,8,9],此时原数组变为[3,2,1],其中子有序数组为[3]，依次类推……得到最终子有序数组为[5,7,8,9],[3],[2],[1]。</p><p>得到子有序数组后将它们合并为新的有序数组。</p><p>比如数组[7,9,6,3,2,5,8,1]，我们使用Strand排序：</p><ul><li>[7,9,6,3,2,5,8,1] 得到子有序数组和另一个子数组  [7,9][6,3,2,5,8,1];</li><li>[6,3,2,5,8,1] 得到子有序数组和另一个子数组  [6,8][3,2,5,1] ，将[7,9]和[6,8]有序合并得到[6,7,8,9];</li><li>[3,2,5,1] 继续得到 [3,5][2,1]， [3,5]与[6,7,8,9]合并得到[3,5,6,7,8,9];</li><li>[2,1]得到[2][1]，继续合并得到[1,2,3,5,6,7,8,9]；</li><li>[1,2,3,5,6,7,8,9]即为要求的有序数组。</li></ul><h3 id="算法描述-6"><a href="#算法描述-6" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>对于待排序数组，取首元素为基础数；</li><li>向后寻找子有序数组，原数组变为一个子有序数组和一个新的子数组；</li><li>对于新的子数组，继续1、2步逻辑，得到新的子子有序数组和另一个新的子子数组；</li><li>将子有序数组和子子有序数组合并成有序数组，新的子子数组重复上述逻辑。</li></ol><h3 id="动图演示-6"><a href="#动图演示-6" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-481.gif" alt="upload successful"></p><h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><p>这儿我们借助LinkedList实现StrandSort</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrandSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;E extends Comparable&lt;? <span class="keyword">super</span> E&gt;&gt; <span class="function">LinkedList&lt;E&gt; <span class="title">strandSort</span><span class="params">(LinkedList&lt;E&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list.size() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;E&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            LinkedList&lt;E&gt; sorted = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="comment">//same as remove() or remove(0)</span></span><br><span class="line">            sorted.add(list.removeFirst());</span><br><span class="line">            <span class="keyword">for</span> (Iterator&lt;E&gt; it = list.iterator(); it.hasNext(); ) &#123;</span><br><span class="line">                E elem = it.next();</span><br><span class="line">                <span class="keyword">if</span> (sorted.peekLast().compareTo(elem) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//same as add(elem) or add(0, elem)</span></span><br><span class="line">                    sorted.addLast(elem);</span><br><span class="line">                    it.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result = merge(sorted, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;E extends Comparable&lt;? <span class="keyword">super</span> E&gt;&gt; <span class="function">LinkedList&lt;E&gt; <span class="title">merge</span><span class="params">(LinkedList&lt;E&gt; left, LinkedList&lt;E&gt; right)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;E&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!left.isEmpty() &amp;&amp; !right.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//change the direction of this comparison to change the direction of the sort</span></span><br><span class="line">            <span class="keyword">if</span> (left.peek().compareTo(right.peek()) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                result.add(left.remove());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result.add(right.remove());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result.addAll(left);</span><br><span class="line">        result.addAll(right);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">strandSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Arrays.stream(array).forEach(e -&gt; linkedList.add(e));</span><br><span class="line">        List&lt;Integer&gt; list = strandSort(linkedList);</span><br><span class="line">        <span class="keyword">assert</span> list.size() == array.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            array[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"StrandSort排序前："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        strandSort(a);</span><br><span class="line">        System.out.println(<span class="string">"StrandSort排序后："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他注意事项-6"><a href="#其他注意事项-6" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ul><li><p>该排序算法的时间复杂度如下：</p><ul><li>时间复杂度（最好）： O(n)</li><li>时间复杂度（平均）： O(n^2)</li><li>时间复杂度（最差）： O(n^2)</li></ul></li><li><p>该排序算法的空间复杂度为： O(n)</p></li><li>该排序算法是稳定排序算法。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>今天我们了解了7种排序算法，这7种排序算法还是比较好理解的，我们可以看到，各个排序都有各自的一些优点（某些个例除外），比如有的时间复杂度要低些，但空间复杂度要高些；有的空间复杂度低，但是时间复杂度要高些；还有一些数据量小的情况下，可能经典排序（冒泡、插入、选择）效率要高，因此可以选择一个合适的阈值，当要排序的数组部分数据量小时，我们可以使用它们代替。</p><p>比如归并排序，如果数组较小，就没必要继续归并，而采用插入排序可能会提高效率等。</p><p>所以后面我们会介绍一些经典的混合排序，还有一些基于某些原理的排序等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="排序算法" scheme="https://www.sakuratears.top/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序算法（二）</title>
    <link href="https://www.sakuratears.top/blog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89.html"/>
    <id>https://www.sakuratears.top/blog/排序算法（二）.html</id>
    <published>2019-08-20T14:39:00.000Z</published>
    <updated>2019-08-20T15:25:04.386Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前一篇文章介绍了10种常用的排序算法，<a href="https://www.sakuratears.top/blog/Java%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html">Java排序算法</a>,今天我们来介绍一些其它的排序算法。</p><p>数据排序问题到今天，虽然是一个“已经被解决了”的问题，但是仍有许多排序算法出现，它们有些基于一些原理，有些是基础排序算法的优化。</p><p>我们了解下这些排序算法，对我们是十分有帮助的。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>今天我们主要介绍十种排序算法，它们如下：</p><table><thead><tr><th>Sort Name</th><th>Time(Best)</th><th>Time(Average)</th><th>Time(Worst)</th><th>Memory</th><th>Stable</th></tr></thead><tbody><tr><td>BeadSort</td><td>O(n)</td><td>O(n^2)</td><td>O(n^2)</td><td>O(n^2)</td><td>YES</td></tr><tr><td>SleepSort</td><td>unpredictable</td><td>unpredictable</td><td>∞</td><td>unpredictable</td><td>NO</td></tr><tr><td>BogoSort</td><td>O(n)</td><td>O(n * n!)</td><td>O(n * n! -&gt; ∞ )</td><td>O(1)</td><td>NO</td></tr><tr><td>PermutationSort</td><td>O(n!)</td><td>O(n!)</td><td>O(n!)</td><td>O(1)</td><td>NO</td></tr><tr><td>GnomeSort</td><td>O(n)</td><td>O(n^2)</td><td>O(n^2)</td><td>O(1)</td><td>YES</td></tr><tr><td>PigeonholeSort</td><td>O(n+k)</td><td>O(n+k)</td><td>O(n+k)</td><td>O(n*k)</td><td>YES</td></tr><tr><td>CombSort</td><td>——</td><td>O(n^2)</td><td>O(n^2)</td><td>O(1)</td><td>NO</td></tr><tr><td>CocktailSort</td><td>O(n)</td><td>O(n^2)</td><td>O(n^2)</td><td>O(1)</td><td>YES</td></tr><tr><td>BinaryInsertionSort</td><td>O(n)</td><td>O(n^2)</td><td>O(n^2)</td><td>O(1)</td><td>YES</td></tr><tr><td>CycleSort</td><td>O(n)</td><td>O(n^2)</td><td>O(n^2)</td><td>O(1)</td><td>NO</td></tr></tbody></table><p>我们分别来看一下。</p><h2 id="珠排序（BeadSort）"><a href="#珠排序（BeadSort）" class="headerlink" title="珠排序（BeadSort）"></a>珠排序（BeadSort）</h2><h3 id="简介及原理"><a href="#简介及原理" class="headerlink" title="简介及原理"></a>简介及原理</h3><p>珠排序(BeadSort)，也叫重力排序，是一种自然排序算法，由Joshua J. Arulanandham, Cristian S. Calude 和 Michael J. Dinneen 在2002年发展而来，并且在欧洲理论计算机协会的新闻简报上发表了该算法。</p><p>该算法的原理可认为基于重力原理，我们对算盘一定比较熟悉，设想算盘上的每个珠子代表1，开始时算珠排列无序，当我们竖起算盘时，算珠就会整齐的排列起来。</p><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>我们需要找到待排序数组中的最大值，以此值为x轴最大值，以待排序数组长度为y轴，我们可以构建一个二维数组（算盘）；</li><li>y轴上数据表示数组元素的值，因此我们以y轴为基准，对于一个数组元素N，就在该位置放N个珠子（表现在二维数组上即为1）;</li><li>上面即是算盘的初始化，初始化完成后，我们以x轴为基准，这时候y轴珠子的高度不同，切换基准后，由于重力原因，珠子会下坠，直到稳定;</li><li>最后我们以y轴为基准获取上面的值，从下到上可形成数组的倒序，从上到下可形成数组的正序，这样数据便排序完成。</li></ol><h3 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-465.gif" alt="upload successful"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>根据上面描述，我们很容易实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeadSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">beadSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = array.length;</span><br><span class="line">        <span class="comment">//获取待排序数组的最大值</span></span><br><span class="line">        <span class="keyword">int</span> max = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> min = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &gt; max) &#123;</span><br><span class="line">                max = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(array[i] &lt; min)&#123;</span><br><span class="line">                min = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化算盘</span></span><br><span class="line">        <span class="comment">//构建一个二维数组，算盘最小长度应该为 max,高为 length</span></span><br><span class="line">        <span class="keyword">int</span>[][] bead = <span class="keyword">new</span> <span class="keyword">int</span>[max][length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y=<span class="number">0</span>;y&lt;length;y++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;array[y];x++)&#123;</span><br><span class="line">                bead[x][y] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//珠子下落</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;max;x++)&#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;y&lt;length;y++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(bead[x][y]==<span class="number">0</span>)&#123;</span><br><span class="line">                    count ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//有值，需要移动</span></span><br><span class="line">            <span class="keyword">if</span>(count!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;count;k++)&#123;</span><br><span class="line">                    temp[k] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                bead[x] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//完成后取出数值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;y&lt;length;y++)&#123;</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;max;x++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(bead[x][y]!=<span class="number">0</span>)&#123;</span><br><span class="line">                    len ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            array[y] = len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"BeadSort排序前："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        beadSort(a);</span><br><span class="line">        System.out.println(<span class="string">"BeadSort排序后："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ul><li>可以看到我们构建了一个 <code>max <em> length</em></code> 的二维数组，实际我们想下，也可以构建一个 <code>(max-min+1)  length</code> 的二维数组，最后排好后都加上<code>min</code>，理论上可以节约空间。</li><li>这个排序算法有一个缺点很明显：那就是它只适用于正整数的排序，原因很明显，“算盘”上我们没法表示负数。</li><li>如果你非要用这种排序方法排含有负数的数组，可以对数组分类，分成正数数组和负数数组，负数数组数据先转为正数排序，排好后在转成负数数组和另一个排好的正数数组合并。</li><li><p>关于珠排序的时间复杂度：</p><p>  O(1)：即所有珠子都同时移动，但这种算法只是概念上的，无法在计算机中实现。</p><p>  O(√n)：在真实的物理世界中用引力实现，所需时间正比于珠子最大高度的平方根，而最大高度正比于n。</p><p>  O(n)：一次移动一列珠子，可以用模拟和数字的硬件实现。</p><p>  O(S)，S是所有输入数据的和：一次移动一个珠子，能在软件中实现。</p></li><li><p>空间复杂度：可以看到影响空间的<code>max</code>值和<code>length</code>值，都和数据大小n成正比关系，因此该算法即使在最好的情况下，也是有O(n^2)空间复杂度的。</p></li><li>稳定性：我们看动图里3的位置变化，可以知道该排序算法是稳定的。</li><li>实用性：该排序方法并不实用，也不建议使用。</li></ul><h2 id="睡排序（SleepSort）"><a href="#睡排序（SleepSort）" class="headerlink" title="睡排序（SleepSort）"></a>睡排序（SleepSort）</h2><h3 id="简介及原理-1"><a href="#简介及原理-1" class="headerlink" title="简介及原理"></a>简介及原理</h3><p>顾名思义，就是睡一会儿，按谁先醒的顺序输出。这要借助计算机中的线程休眠（sleep）机制。</p><h3 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>对于待排序数组，开 数组长度 个线程，并使它们同时等待；</li><li>同时执行线程的sleep方法，sleep数组元素值的时间，哪一个线程先苏醒，就把该值输出；</li><li>所有线程sleep完成后，就得到了排序好的数据。</li></ol><h3 id="动图演示-1"><a href="#动图演示-1" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-466.gif" alt="upload successful"></p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">sleepSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建num个线程池，进行睡排序</span></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(nums.length);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch doneSignal = <span class="keyword">new</span> CountDownLatch(nums.length);</span><br><span class="line">        <span class="keyword">final</span> List&lt;Integer&gt; list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        List&lt;Future&gt; futureList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> <span class="keyword">int</span> num:nums) &#123;</span><br><span class="line">           Future future = executorService.submit(()-&gt;&#123;</span><br><span class="line">                doneSignal.countDown();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    doneSignal.await();</span><br><span class="line">                    <span class="comment">//线程时间为毫秒，可靠性较弱，我们 * 1000 改为秒，可靠性会提高，但是仍有可能排序错误！！！</span></span><br><span class="line">                    Thread.sleep(num * <span class="number">1000</span>);</span><br><span class="line">                    list.add(num);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            futureList.add(future);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环检测线程是否完成</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">boolean</span> finish = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(Future future:futureList)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!future.isDone())&#123;</span><br><span class="line">                    finish = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(finish)&#123;</span><br><span class="line">               executorService.shutdown();</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"SleepSort排序前："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        List&lt;Integer&gt; list = sleepSort(a);</span><br><span class="line">        System.out.println(<span class="string">"SleepSort排序后："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(list.toArray()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他注意事项-1"><a href="#其他注意事项-1" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ul><li>强烈不推荐在任何地方使用此方法，如果应用于项目，被发现后后果自付，与本作者无关。</li><li><p>该排序方法有许多明显缺点：</p><ul><li>该排序方法只能应用于较小的正整数排序；</li><li>该排序方法是不可靠的，上述代码我们即使对num * 1000增加了可靠度，而后输出的排序结果也有可能不正确；</li><li>该排序方法是不稳定的；</li><li>该排序方法的时间复杂度取决于数据值大小，一般远远大于任何排序算法；</li><li>由于开了N个线程，我们一般认为该排序方法空间复杂度大于其它排序算法。</li></ul></li></ul><h2 id="Bogo排序（BogoSort）"><a href="#Bogo排序（BogoSort）" class="headerlink" title="Bogo排序（BogoSort）"></a>Bogo排序（BogoSort）</h2><h3 id="简介及原理-2"><a href="#简介及原理-2" class="headerlink" title="简介及原理"></a>简介及原理</h3><p>Bogo排序又称猴子排序，其原理基于猴子无限定理。</p><p>猴子无限定理：无限只猴子，在无限的时间内，随机敲击键盘，总有一只可以敲出莎士比亚全集。</p><p>可以看到，本排序方法主要思想就是基于运气！！！</p><h3 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>检查数组是否已排序，如果已排序，输出结果；</li><li>如果不是有序数组，随机打乱数组里数据位置，返回第一步。</li></ol><h3 id="动图演示-2"><a href="#动图演示-2" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-467.png" alt="upload successful"></p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BogoSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bogoSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = array.length;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">boolean</span> tag;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            tag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//检测是否有序</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[i] &lt; array[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    tag = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果有序，则排序完成</span></span><br><span class="line">            <span class="keyword">if</span> (tag) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//顺序不对，则随机打乱</span></span><br><span class="line">            Random random = <span class="keyword">new</span> Random();</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                j = random.nextInt(size);</span><br><span class="line">                <span class="comment">//随机交换两值</span></span><br><span class="line">                swap(array, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[p];</span><br><span class="line">        a[p] = a[q];</span><br><span class="line">        a[q] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"BogoSort排序前："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        bogoSort(a);</span><br><span class="line">        System.out.println(<span class="string">"BogoSort排序后："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他注意事项-2"><a href="#其他注意事项-2" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ul><li>当数据量逐渐变大时，该排序方法时间复杂度会激增，因此该排序方法非常不实用。</li><li>可以看到该排序方法是不稳定的。</li><li><p>该排序方法的时间复杂度如下：</p><ul><li>时间复杂度（最好）：O(n)</li><li>时间复杂度（平均）：O(n * n!)</li><li>时间复杂度（最差）：O(n * n! -&gt; ∞ )</li></ul></li><li><p>该排序方法的空间复杂度为 O(1)。</p></li></ul><h2 id="全排序（PermutationSort）"><a href="#全排序（PermutationSort）" class="headerlink" title="全排序（PermutationSort）"></a>全排序（PermutationSort）</h2><h3 id="简介及原理-3"><a href="#简介及原理-3" class="headerlink" title="简介及原理"></a>简介及原理</h3><p>全排序（PermutationSort）又称全排列排序，顾名思义，一个长度有限的数组，其内部数据的排列组合也是有限的，我们找到全部排列组合，里面总至少有一个组合满足数组有序这个条件。</p><p>全排列：从n个不同元素中任取m（m≤n）个元素，按照一定的顺序排列起来，叫做从n个不同元素中取出m个元素的一个排列，当m=n时所有的排列情况叫全排列。</p><p>PS：对于一个长度为n的数组，其全排列组合有 n! 种。</p><h3 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>对于一个长度为n的数组，列出其所有排列组合情况；</li><li>校验所有排列组合是否有序，如果有序，输出该组合结果。</li></ol><h3 id="动图演示-3"><a href="#动图演示-3" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-468.gif" alt="upload successful"></p><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PermutationSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] permutationSort(<span class="keyword">int</span>[] a) &#123;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        permute(a, a.length, list);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] x : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isSorted(x)) &#123;</span><br><span class="line">                <span class="keyword">return</span> x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取数组的全排列</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">permute</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, List&lt;<span class="keyword">int</span>[]&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">            System.arraycopy(a, <span class="number">0</span>, b, <span class="number">0</span>, a.length);</span><br><span class="line">            list.add(b);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            swap(a, i, n - <span class="number">1</span>);</span><br><span class="line">            permute(a, n - <span class="number">1</span>, list);</span><br><span class="line">            swap(a, i, n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断数组是否有序</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i - <span class="number">1</span>] &gt; a[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换数组两数数值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"PermutationSort排序前："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        <span class="keyword">int</span> [] s = permutationSort(a);</span><br><span class="line">        System.out.println(<span class="string">"PermutationSort排序后："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他注意事项-3"><a href="#其他注意事项-3" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ul><li>首先看到我们上面代码，列出了所有排列情况，再一一判断每种情况是不是有序，实际上<code>List&lt;int[]&gt; list</code>这个是多余的，我们完全可以在生成每一种组合后，直接判断它是否有序，这样可以节约一定空间和时间，这儿不再过多介绍。</li><li>可以看到这种排序方法也是不实用的，当数据逐渐变大时，排序耗时我们是无法容忍的。</li><li>可以看到这种排序方法是不稳定的。</li><li>该方法的时间复杂度为 O(n!)。</li><li>该排序方法的空间复杂度为 O(1)。</li></ul><h2 id="侏儒排序（GnomeSort）"><a href="#侏儒排序（GnomeSort）" class="headerlink" title="侏儒排序（GnomeSort）"></a>侏儒排序（GnomeSort）</h2><h3 id="简介及原理-4"><a href="#简介及原理-4" class="headerlink" title="简介及原理"></a>简介及原理</h3><p>侏儒排序（GnomeSort或StupidSort）最初由伊朗计算机工程师Hamid Sarbazi-Azad博士于2000年提出并被称为“愚蠢排序”，然后由Dick Grune描述并命名为“GnomeSort”。它在概念上很简单，不需要嵌套循环。</p><p>关于GnomeSort名字的由来：Dick Grune描述了一个花园侏儒的故事，侏儒对花园花盆进行分类，他看着旁边的花盆和前一个花盆; 如果他们按照正确的顺序，他会向前迈出一步；否则他会将它们交换掉，并向后退一步；如果无法继续后退，他会继续前进; 如果他前进后前面没有了花盆，他就完成了花盆排序。</p><h3 id="算法描述-4"><a href="#算法描述-4" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>对于给定的数组a，从0下标开始，跳过下标0；</li><li>对于大于0的下标，如3，判断数组值a[3]和a[2]大小，如果a[3]&gt;=a[2]，继续下一个值比较；</li><li>如果a[3] &lt; a[2],就会将a[3]和a[2]交换，同时我们的位置会移动到下标2上，比较a[2]（实际上是原来的a[3]）与a[1]的大小，相当于重复第二步过程；</li><li>可以看到边界条件就是位置为0和位置为数组长度-1的地方，一个是无法继续向“后退”（说明这个值是当前已排序部分的最小值），一个是无法继续“前进”（说明排序完成）。</li></ol><h3 id="动图演示-4"><a href="#动图演示-4" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-469.gif" alt="upload successful"></p><h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GnomeSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gnomeSort</span><span class="params">(<span class="keyword">int</span>[] ar)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = ar.length;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || ar[i - <span class="number">1</span>] &lt;= ar[i]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = ar[i];</span><br><span class="line">                ar[i] = ar[i - <span class="number">1</span>];</span><br><span class="line">                ar[--i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"GnomeSort排序前："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        gnomeSort(a);</span><br><span class="line">        System.out.println(<span class="string">"GnomeSort排序后："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他注意事项-4"><a href="#其他注意事项-4" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ul><li>可以看到侏儒排序十分“简单”（代码层面上），它只有一层循环，但是循环次数 &gt;=n次（n为数组长度），当顺序错误（ar[i - 1] &gt; ar[i]）时，除了交互两数外，i值还会减1，这就是所说的“后退”；</li><li>我们也可以引入变量，用来记录a[i]，在与a[i - 1]及之前的数进行对比，找到位置后进行存储，这样处理的话侏儒排序类似于插入排序的变种；</li><li>可以看到该排序方法为稳定排序；</li><li><p>该排序方法的时间复杂度如下：</p><ul><li>时间复杂度（最好）：O(n)</li><li>时间复杂度（平均）：O(n^2)</li><li>时间复杂度（最差）：O(n^2)</li></ul></li><li><p>该排序方法的空间复杂度为 O(1)。</p></li></ul><h2 id="鸽巢排序（PigeonholeSort）"><a href="#鸽巢排序（PigeonholeSort）" class="headerlink" title="鸽巢排序（PigeonholeSort）"></a>鸽巢排序（PigeonholeSort）</h2><h3 id="简介及原理-5"><a href="#简介及原理-5" class="headerlink" title="简介及原理"></a>简介及原理</h3><p>鸽巢排序（PigeonholeSort）也被称作基数分类，原理类似桶排序,同样需要一个很大的鸽巢（桶排序里管这个叫桶），鸽巢其实就是数组，数组的索引位置就表示值，该索引位置的值表示出现次数，如果全部为1次或0次那就是桶排序。</p><p>鸽巢排序的原理：我们可以构建数组元素最大值个“鸽巢”，对于待排序数组，将它的元素值一个个对应到“鸽巢”索引值上，如果“鸽巢”该索引位置值为0，表示数组里没有此值，如果为n（&gt;=1），表示数组里该元素（索引值）有n个该值。</p><h3 id="算法描述-5"><a href="#算法描述-5" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>给定一个待排序数组，创建一个备用数组（鸽巢），并初始化元素为0，备用数组的索引即是待排序数组的值；</li><li>把待排序数组的值，放到“鸽巢”里（即用作备用数组的索引）；</li><li>把“鸽巢”里的值再依次送回待排序数组。</li></ol><h3 id="动图演示-5"><a href="#动图演示-5" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-470.gif" alt="upload successful"></p><h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PigeonholeSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] pigeonhole(<span class="keyword">int</span>[] array, <span class="keyword">int</span> maxNumber)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] pigeonhole = <span class="keyword">new</span> <span class="keyword">int</span>[maxNumber + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * pigeonhole[10] = 4; 的含意是</span></span><br><span class="line"><span class="comment">         * 在待排数组中有4个10出现,同理其它</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> item:array) &#123;</span><br><span class="line">            pigeonhole[item]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pigeonhole;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pigeonholeSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e:array) &#123;</span><br><span class="line">            <span class="keyword">if</span>(e&gt;max)&#123;</span><br><span class="line">                max = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//构建鸽巢</span></span><br><span class="line">        <span class="keyword">int</span>[] sorted = pigeonhole(array,max);</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sorted.length;i++)&#123;</span><br><span class="line">            <span class="comment">//如果有不为空的说明放入了元素，下标即为元素值</span></span><br><span class="line">            <span class="keyword">if</span>(sorted[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;sorted[i];k++)&#123;</span><br><span class="line">                    array[index] = i;</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"PigeonholeSort排序前："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        pigeonholeSort(a);</span><br><span class="line">        System.out.println(<span class="string">"PigeonholeSort排序后："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他注意事项-5"><a href="#其他注意事项-5" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ul><li>感觉是不是很像<a href="https://www.sakuratears.top/blog/Java%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%88Counting-Sort%EF%BC%89">计数排序</a>？是的，鸽巢排序的一个比较有名的变形就是计数排序，对于解决指定问题有奇效；</li><li>我们可以看到，如果我们数组元素差值较大，比如[1,100,100000,888888]这个数组，我们使用鸽巢排序，会浪费很大空间，所以它只有在差值(或者可被映射在差值)很小的范围内的数值排序的情况下适用（鸽巢也可以是对象数组等，对象的比较需要有具体实现等）;</li><li>我们一般很少使用鸽巢排序, 因为它很少可以在灵活性, 简便性, 尤是速度上超过其他主流排序算法；</li><li>该排序算法为稳定排序算法；</li><li><p>该排序算法时间复杂度如下：</p><ul><li>时间复杂度（最好）： O(n+k)</li><li>时间复杂度（平均）： O(n+k)</li><li>时间复杂度（最差）： O(n+k)</li></ul></li><li><p>该排序算法空间复杂度 ： O(n*k)</p></li></ul><h2 id="梳排序（CombSort）"><a href="#梳排序（CombSort）" class="headerlink" title="梳排序（CombSort）"></a>梳排序（CombSort）</h2><h3 id="简介及原理-6"><a href="#简介及原理-6" class="headerlink" title="简介及原理"></a>简介及原理</h3><p>梳排序（CombSort）是一种由Wlodzimierz Dobosiewicz于1980年所发明的不稳定排序算法，并由Stephen Lacey和Richard Box于1991年四月号的Byte杂志中推广。</p><p>梳排序改良自冒泡排序和快速排序，其要旨在于消除“乌龟”（亦即在数组尾部的小数值），这些数值是造成冒泡排序缓慢的主因。相对地，“兔子”（亦即在数组前端的大数值）不影响冒泡排序的性能。</p><p>我们知道，在冒泡排序中，只比较数组中相邻的二项，即比较的二项的间距（Gap）是1，梳排序提出此间距其实可大于1。</p><p>梳排序中，开始时的间距设置为数组长度，并在循环中以固定比率递减，即递减率。在一次循环中，梳排序如同冒泡排序一样把数组从首到尾扫描一次，比较及交换两项，不同的是两项的间距不固定于1。如果间距递减至1，梳排序假定输入数组大致排序好，并以冒泡排序作最后检查及修正。</p><p>递减率的设置影响着梳排序的效率，原作者以随机数作实验，得到最有效递减率为1.3。</p><p>如果此比率太小，则导致循环中有过多的比较，如果比率太大，则未能有效消除数组中的“乌龟”。有时候我们也会取递减率倒数与间距相乘（因为编程语言乘法较快）来进行计算，这个倒数通常取0.8.</p><h3 id="算法描述-6"><a href="#算法描述-6" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>对于待排序数组，我们开始以数组长度为间距delta，比较两值，如果a[i] &gt; a[i + delta]，则交换他们的位置；</li><li>根据递减率shrink，先判断间距delta是否 &gt;1，是的话下次间距变为delta =  delta/shrink ，继续第一步比较；</li><li>最后再用冒泡排序排序一遍得到排序好的数组。</li></ol><h3 id="动图演示-6"><a href="#动图演示-6" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-471.gif" alt="upload successful"></p><h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CombSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">combSort</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = data.length;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">double</span> shrink = <span class="number">1.3</span>;</span><br><span class="line">        <span class="keyword">int</span> i, delta = n, noswap = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (noswap == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (noswap = <span class="number">1</span>, i = <span class="number">0</span>; i + delta &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (data[i] &gt; data[i + delta]) &#123;</span><br><span class="line">                    data[i] ^= data[i + delta];</span><br><span class="line">                    data[i + delta] ^= data[i];</span><br><span class="line">                    data[i] ^= data[i + delta];</span><br><span class="line">                    noswap = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (delta &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                delta /= shrink;</span><br><span class="line">                noswap = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"CombSort排序前："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        combSort(a);</span><br><span class="line">        System.out.println(<span class="string">"CombSort排序后："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他注意事项-6"><a href="#其他注意事项-6" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ul><li>上述代码我们使用了除法计算循环间距，当然也可以使用乘法，乘数可以取0.8；</li><li>梳排序的效率在开始时最佳，接近结束时，即进入冒泡排序时最差。如果间距delta变得太小时(例如小于10)，我们可以改用插入排序等其他排序算法，提升整体性能；</li><li>梳排序是一种不稳定排序算法；</li><li><p>该排序算法时间复杂度如下：</p><ul><li>时间复杂度（平均）： O(n^2)</li><li>时间复杂度（最差）： O(n^2)</li></ul></li><li><p>该排序算法空间复杂度 ： O(1)</p></li></ul><h2 id="鸡尾酒排序（CocktailSort）"><a href="#鸡尾酒排序（CocktailSort）" class="headerlink" title="鸡尾酒排序（CocktailSort）"></a>鸡尾酒排序（CocktailSort）</h2><h3 id="简介及原理-7"><a href="#简介及原理-7" class="headerlink" title="简介及原理"></a>简介及原理</h3><p>鸡尾酒排序（CocktailSort）是冒泡排序（BubbleSort）的一种变形，也称双向冒泡排序。</p><p>之所以称为双向冒泡排序，是因为该排序算法与冒泡排序的不同处在于排序时是以双向在序列中进行排序。如何双向呢？</p><p>对于冒泡排序，我们每次是由左到右（或者由右到左）依次比较序列里的每个元素；而对于鸡尾酒排序，我们是先由左到右然后在由右到左去比较序列中的元素。</p><h3 id="算法描述-7"><a href="#算法描述-7" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>对于待排序数组，对于每次循环，我们都会由左到右（升序）进行冒泡排序，然后在由右到左（降序）进行冒泡排序；</li><li>这样对于外层循环，我们只需循环数组一半长度即可；</li><li>先对数组从左到右排序（升序）将最大的数字放在最右端;</li><li>再对数组从右到左排序（降序）将最小的数字放在最左端;</li><li>以此类推（先找最大，再找最小，然后找第二大，再找第二小），不断缩小未排序数字的范围，直到最后一个数字结束。</li></ol><h3 id="动图演示-7"><a href="#动图演示-7" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-472.gif" alt="upload successful"></p><h3 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CocktailSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cocktailSort</span><span class="params">(<span class="keyword">int</span>[] src)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; src.length / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//将最小值排到队首</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; src.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (src[j] &gt; src[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = src[j];</span><br><span class="line">                    src[j] = src[j + <span class="number">1</span>];</span><br><span class="line">                    src[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将最大值排到队尾</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = src.length - <span class="number">1</span> - (i + <span class="number">1</span>); j &gt; i; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (src[j] &lt; src[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = src[j];</span><br><span class="line">                    src[j] = src[j - <span class="number">1</span>];</span><br><span class="line">                    src[j - <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"CocktailSort排序前："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        cocktailSort(a);</span><br><span class="line">        System.out.println(<span class="string">"CocktailSort排序后："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他注意事项-7"><a href="#其他注意事项-7" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ul><li>我们可以看到，鸡尾酒排序相对于普通冒泡排序减少了数据比较次数，因此鸡尾酒排序是冒泡排序的一种优化，其理论性能会高于普通冒泡排序；</li><li><p>鸡尾酒排序的时间复杂度：</p><ul><li>时间复杂度（最好）：O(n)</li><li>时间复杂度（平均）：O(n^2)</li><li>时间复杂度（最差）：O(n^2)</li></ul></li><li><p>空间复杂度：O(1)</p></li><li>该排序算法为稳定排序算法。</li></ul><h2 id="折半插入排序（BinaryInsertionSort）"><a href="#折半插入排序（BinaryInsertionSort）" class="headerlink" title="折半插入排序（BinaryInsertionSort）"></a>折半插入排序（BinaryInsertionSort）</h2><h3 id="简介及原理-8"><a href="#简介及原理-8" class="headerlink" title="简介及原理"></a>简介及原理</h3><p>折半插入排序（BinaryInsertionSort）又称二分插入排序，是普通插入排序（InsertionSort）的一种优化。</p><p>听名字也很好理解，对于普通插入排序，我们是和已排队列一个一个比较找到该值要插入的位置；而对于折半插入排序，是在已排数组中通过二分查找查找到数据插入位置，在将数据统一后移来实现。</p><h3 id="算法描述-8"><a href="#算法描述-8" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>二分法查找插入位置，创建两个指针 low = 0，high = i-1；</li><li>mid = (low+high)/2 ,对于data[i]，如果data[i] &lt; data[mid]，说明还要向小查找，此时将high = mid-1；如果data[i] &gt; data[mid]。说明还要向大查找，此时将low = mid+1；</li><li>需要判断low和high，如果low &gt; high，就无需继续查找了，要插入的位置即为low，否则继续进行2步骤。</li></ol><h3 id="动图演示-8"><a href="#动图演示-8" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-473.gif" alt="upload successful"></p><h3 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryInsertionSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] binaryInsertionSort(<span class="keyword">int</span>[] data) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, len = data.length; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 要插入的元素</span></span><br><span class="line">            <span class="keyword">int</span> temp = data[i];</span><br><span class="line">            <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> high = i - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 折半比较，直到找到low大于high时（找到比他大的值的位置low）</span></span><br><span class="line">            <span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (data[mid] &gt; temp) &#123;</span><br><span class="line">                    high = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    low = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 移动 比他大的值，全部后移</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; low; j--) &#123;</span><br><span class="line">                data[j] = data[j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 插入</span></span><br><span class="line">            data[low] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"BinaryInsertionSort排序前："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        <span class="keyword">int</span>[] s = binaryInsertionSort(a);</span><br><span class="line">        System.out.println(<span class="string">"BinaryInsertionSort排序后："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他注意事项-8"><a href="#其他注意事项-8" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ul><li>和普通插入排序比起来，因为使用了二分查找，所以理论上比较次数平均会少一些；</li><li>折半查找只是减少了比较次数，但是元素的移动次数不变；</li><li><p>该排序时间复杂度：</p><p>时间复杂度和排序完成度没有关系，和数组大小有关系，因此该排序时间复杂度与普通插入排序相当。</p><ul><li>时间复杂度（最好）：O(n)    </li><li>时间复杂度（平均）：O(n^2)    </li><li>时间复杂度（最差）：O(n^2)</li></ul></li><li><p>空间复杂度：O(1)</p></li><li>该排序算法为稳定排序算法。</li></ul><h2 id="圈排序（CycleSort）"><a href="#圈排序（CycleSort）" class="headerlink" title="圈排序（CycleSort）"></a>圈排序（CycleSort）</h2><h3 id="简介及原理-9"><a href="#简介及原理-9" class="headerlink" title="简介及原理"></a>简介及原理</h3><p>圈排序的理论基础是，如果每个坏组的元素返回到它们的正确位置，那么整个序列将被排序。</p><p>什么是坏组？</p><p>给定一个对象序列，例如一个整数数组;如果这些元素没有按顺序排列，那是因为其中一些元素在它们之间交换了位置。如下：</p><p>对于数列 [4,1,2,3,5,0]不是按顺序排列的，因为4,5,0交换了位置(1个坏组)，[4、2、3、7、5、0、1]顺序不对，因为4、5、0交换了位置，2、3、7、1交换了位置(两个坏组)。</p><p>在离散数学中，每一组，无论好坏，都被称为一个周期或一个轨道。</p><p>我们按照此理论进行的排序便可称为圈排序。</p><h3 id="算法描述-9"><a href="#算法描述-9" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>对于待排序数组，比如[5、3、4、8、6、1、2]，可以看到它的有序数组为[1、2、3、4、5、6、8]；</li><li>可以看到5、3、4、8、6、1、2顺序不对，不在自己位置上，5应该在6的位置，6应该在1的位置，1应该在5的位置上，因此5、6、1构成了一个坏组；同理3应该在4位置，4应该在8位置，8应该在2位置，2应该在3位置，因此3、4、8、2构成一个坏组；</li><li>我们通过循坏将上述两个坏组的位置调整，单项循坏，位置变化 5-&gt;6-&gt;1-&gt;5，3-&gt;4-&gt;8-&gt;2-&gt;3，便可以得到有序数组[1、2、3、4、5、6、8]。    </li></ol><h3 id="动图演示-9"><a href="#动图演示-9" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-474.gif" alt="upload successful"></p><h3 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CycleSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cycleSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> cs = <span class="number">0</span>, seeker, pos; cs &lt; array.length - <span class="number">1</span>; cs++) &#123;</span><br><span class="line">            <span class="comment">//假设array[cs]中的元素不合适</span></span><br><span class="line">            seeker = array[cs];</span><br><span class="line">            pos = cs;</span><br><span class="line">            <span class="comment">//找到seeker的正确位置(pos)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = cs + <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[i] &lt; seeker) &#123;</span><br><span class="line">                    pos++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果seeker已经在正确的位置，继续</span></span><br><span class="line">            <span class="keyword">if</span> (pos == cs) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//复制后移动索引pos(如果有的话)</span></span><br><span class="line">            <span class="keyword">while</span> (seeker == array[pos]) &#123;</span><br><span class="line">                pos++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//seeker放到了它正确的位置（索引pos处），同时原来pos处的元素成为了新的seeker，需要找到另一个位置</span></span><br><span class="line">            seeker = set(array, seeker, pos);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//在进入下一个循环之前完成当前循环。在当前周期结束时，pos==cs，因为一个周期总是在它开始的地方结束。</span></span><br><span class="line">            <span class="keyword">while</span> (pos != cs) &#123;</span><br><span class="line">                <span class="comment">//代码同上</span></span><br><span class="line">                pos = cs;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = cs + <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (array[i] &lt; seeker) &#123;</span><br><span class="line">                        pos++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (seeker == array[pos]) &#123;</span><br><span class="line">                    pos++;</span><br><span class="line">                &#125;</span><br><span class="line">                seeker = set(array, seeker, pos);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> data, <span class="keyword">int</span> ndx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> array[ndx];</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            array[ndx] = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"CycleSort排序前："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        cycleSort(a);</span><br><span class="line">        System.out.println(<span class="string">"CycleSort排序后："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他注意事项-9"><a href="#其他注意事项-9" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ul><li>可以看到圈排序期间，每个元素最多移动一次；</li><li><p>该算法的时间复杂度：</p><ul><li>时间复杂度（最好）：O(n)</li><li>时间复杂度（平均）：O(n^2)</li><li>时间复杂度（最差）：O(n^2)</li></ul></li><li><p>该算法空间复杂度：O(1)</p></li><li>该算法是不稳定排序算法。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过上述10种排序算法，我们了解了许多“奇奇怪怪”的排序算法，以及它们的一些原理，排序算法也远远不止这些，后面我们还会介绍更多的排序算法，及其一些基本原理。</p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>上述文章中包含本章中所有的源代码，有兴趣的同学也可以通过我的 <a href="https://github.com/JavaZWT" rel="external nofollow noopener noreferrer" target="_blank">Github</a> 查看源码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="排序算法" scheme="https://www.sakuratears.top/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Eureka详解</title>
    <link href="https://www.sakuratears.top/blog/Eureka%E8%AF%A6%E8%A7%A3.html"/>
    <id>https://www.sakuratears.top/blog/Eureka详解.html</id>
    <published>2019-08-10T09:55:00.000Z</published>
    <updated>2019-08-10T10:37:40.631Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇文章<a href="https://www.sakuratears.top/blog/Eureka%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.html">Eureka简介及简单使用</a> 我们通过一些简单示例，对Eureka有了一些简单了解。</p><p>我们这片文章将深入了解Eureka，详细介绍Eureka的基础架构、节点间的通信机制以及一些进阶配置等。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h2><p>Eureka服务治理基础架构的三个核心要素：</p><ul><li>服务注册中心：Eureka提供的服务端，提供服务注册与发现功能。也就是上篇文章里的eureka-server。</li><li>服务提供者：提供服务的应用，可以是SpringBoot应用，也可以是其他技术平台且遵循Eureka通信机制的应用。它将自己提供的服务注册到Eureka，以供其他应用发现。也就是上篇文章里的sakura-service。</li><li>服务消费者：消费者应用从服务注册中心获取服务列表，从而使消费者可以知道去何处调用其所需要的服务。也就是上篇文章里的sakura-consumer。</li></ul><p>注：很多时候，客户端既是服务提供者也是服务调用者。</p><h2 id="服务治理机制"><a href="#服务治理机制" class="headerlink" title="服务治理机制"></a>服务治理机制</h2><p>要理解服务治理机制，我们先看一下这张图。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-464.png" alt="upload successful"></p><p>根据上图，我们来详细了解下Eureka从服务注册到服务调用，及各个元素所涉及的一些重要通信行为。</p><h3 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h3><p>服务提供者主要有服务注册、服务续约、服务下线等行为，我们分别来看下。</p><ul><li><p>服务注册</p><p>  服务提供者在启动的时候会通过发送REST请求的发送将自己注册到Eureka Server上，同时带上自身服务的一些元数据信息。Eureka Server接受到这个REST请求之后，将元数据信息存储在一个双层结构Map中，其中第一层key是服务名，第二层key是具体服务的实例名。</p><p>  服务注册时，需要 <code>eureka.client.register-with-eureka</code>参数为true(默认为true)，如果设置为false该服务实例将不会进行服务注册操作。</p></li><li><p>服务续约</p><p>  服务注册完成后，服务提供者会维护一个心跳，用来持续告诉Eureka Server：“我还活着”，以防止Eureka Server的“剔除任务”将该服务实例从服务列表剔除，我们称该操作为服务续约。</p><p>  服务续约有两个重要参数可以进行配置(Eureka Server的配置文件里)，如下：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 定义服务续约任务的调用间隔时间，默认30s</span><br><span class="line">eureka.instance.lease-renewal-interval-in-seconds=30</span><br><span class="line"># 定义服务失效的时间，默认90s</span><br><span class="line">eureka.instance.lease-expiration-duration-in-seconds=90</span><br></pre></td></tr></table></figure></li><li><p>服务下线</p><p>  在系统运行过程中存在临时关闭或者重启某个实例的情况，在该实例服务关闭期间，我们不希望客户端继续调用服务关闭的实例。所以在客户端程序中，当服务实例进行正常的关闭操作时，它会触发一个服务下线的REST请求给Eureka Server，告诉注册中心“我要下线了”，注册中心收到请求后会将该服务状态置为下线（DOWN），并把该下线事件传播出去。</p></li></ul><h3 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h3><p>服务消费者主要有获取服务、服务调用等行为，我们分别来看下。</p><ul><li><p>获取服务</p><p>  当我们启动服务消费者时，它会发送一个REST请求给服务注册中心，来获取上面注册的服务清单。为了性能考虑，Eureka Server会维护一份只读的服务清单来返回给客户端，同时该缓存清单会每个30s更新一次。</p><p>  如果想要修改缓存清单更新时间，可以通过下面参数进行修改，该参数默认30s。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eureka.client.registry-fetch-interval-seconds=30</span><br></pre></td></tr></table></figure><p>  获取服务列表是服务消费者的基础，可以通过修改下面参数为false使服务消费者不生效，该值默认为true。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eureka.client.fetch-registry=true</span><br></pre></td></tr></table></figure></li><li><p>服务调用</p><p>  服务消费者在获取到服务清单后，通过服务名可以获取到提供该服务的实例名和该实例的元数据信息。有了这些服务实例的详细信息，服务消费者可以根据自己的需要选择要调用的实例。如采用轮询等方式，进而实现客户端负载均衡。</p><p>  对于访问实例的选择，Eureka中有Region和Zone的概念，一个Region中可以包含多个Zone，每个服务客户端需要被注册到一个Zone中，所以每个客户端对应一个Region和一个Zone。在进行服务调用的时候，优先访问同处于一个Zone的服务提供方，若访问不到，就访问其他的Zone。</p></li></ul><h3 id="服务注册中心"><a href="#服务注册中心" class="headerlink" title="服务注册中心"></a>服务注册中心</h3><p>服务注册中心主要有服务同步、失效剔除、自我保护等行为，我们分别来看下。</p><ul><li><p>服务同步</p><p>  如上图，两个服务提供者分别注册到了两个不同的服务注册中心上，即它们的信息分别被两个服务注册中心维护。由于服务注册中心之间相互注册为服务，当服务提供者发送注册请求到一个注册中心时，注册中心会将该请求转发给集群中相连的其他注册中心，从而实现注册中心之间的服务同步。</p><p>  服务同步后，两个服务提供者的服务信息可以在这两台注册中心中任意一台上获取到。</p></li><li><p>失效剔除</p><p>  有些时候，我们服务实例不一定会正常下线，可能由于内存溢出、网络故障等原因导致该实例无法正常工作，而注册中心无法收到下线请求。为剔除这些无法提供服务的实例，Eureka Server在启动时会创建一个定时任务，每个一段时间（默认60s）将当前清单中超时（默认90s）没有续约的服务实例剔除出去。</p></li><li><p>自我保护</p><p>  我们知道，服务注册到Eureka Server之后，会维护一个心跳连接，告诉Eureka Server自己还活着。Eureka Server在运行期间，会统计心跳的比例在15min之内是否低于85%，如果出现低于的情况（如单机调试、生产环境网络问题等），Eureka Server会将当前的实例信息保护起来，让这些实例不会过期，尽可能保护这些注册信息。但是保护期内如果实例出现问题，服务调用方拿到已经不存在的服务实例，就会出现调用失败的情况，所以服务调用方需要有容错机制，如请求重试、断路器等。</p><p>  Eureka Server进入自我保护后，注册中心信息面板上会出现类型下面的红色警告信息：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY&apos;RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE.</span><br></pre></td></tr></table></figure><p>  我们本地调试很容易触发Eureka的自我保护机制，这可能导致我们的服务实例不是那么准确。我们可以通过设置下面参数来关闭自我保护机制，该值默认为true，表示开启自我保护机制。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eureka.server.enable-self-preservation=false</span><br></pre></td></tr></table></figure></li></ul><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>我们通过<code>@EnableDiscoveryClient</code>这个注解，可以找到<code>com.netflix.discovery.DiscoveryClient</code>这个类，过程略。</p><p>我们来看下这个类，这个类是Netflix开源包中的内容，位于<code>eureka-client</code>包下。</p><p>这个类主要有以下功能：</p><ul><li>向Eureka Server注册服务实例；</li><li>向Eureka Server服务租约；</li><li>当服务关闭时，向Eureka Server取消租约；</li><li>查询Eureka Server中的服务实例列表。</li></ul><p>为保证与Eureka Server交互，我们需要配置一个Eureka Server的URL列表，即之前所说的<code>eureka.client.service-url</code>参数。</p><p>关于这个类，我们主要看一下它的<code>initScheduledTasks</code>方法。我们可以看到这个方法在<code>DiscoveryClient</code>的构造器里被调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initScheduledTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (clientConfig.shouldFetchRegistry()) &#123;</span><br><span class="line">        <span class="comment">// registry cache refresh timer</span></span><br><span class="line">        <span class="keyword">int</span> registryFetchIntervalSeconds = clientConfig.getRegistryFetchIntervalSeconds();</span><br><span class="line">        <span class="keyword">int</span> expBackOffBound = clientConfig.getCacheRefreshExecutorExponentialBackOffBound();</span><br><span class="line">        scheduler.schedule(</span><br><span class="line">                <span class="keyword">new</span> TimedSupervisorTask(</span><br><span class="line">                        <span class="string">"cacheRefresh"</span>,</span><br><span class="line">                        scheduler,</span><br><span class="line">                        cacheRefreshExecutor,</span><br><span class="line">                        registryFetchIntervalSeconds,</span><br><span class="line">                        TimeUnit.SECONDS,</span><br><span class="line">                        expBackOffBound,</span><br><span class="line">                        <span class="keyword">new</span> CacheRefreshThread()</span><br><span class="line">                ),</span><br><span class="line">                registryFetchIntervalSeconds, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clientConfig.shouldRegisterWithEureka()) &#123;</span><br><span class="line">        <span class="keyword">int</span> renewalIntervalInSecs = instanceInfo.getLeaseInfo().getRenewalIntervalInSecs();</span><br><span class="line">        <span class="keyword">int</span> expBackOffBound = clientConfig.getHeartbeatExecutorExponentialBackOffBound();</span><br><span class="line">        logger.info(<span class="string">"Starting heartbeat executor: "</span> + <span class="string">"renew interval is: &#123;&#125;"</span>, renewalIntervalInSecs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Heartbeat timer</span></span><br><span class="line">        scheduler.schedule(</span><br><span class="line">                <span class="keyword">new</span> TimedSupervisorTask(</span><br><span class="line">                        <span class="string">"heartbeat"</span>,</span><br><span class="line">                        scheduler,</span><br><span class="line">                        heartbeatExecutor,</span><br><span class="line">                        renewalIntervalInSecs,</span><br><span class="line">                        TimeUnit.SECONDS,</span><br><span class="line">                        expBackOffBound,</span><br><span class="line">                        <span class="keyword">new</span> HeartbeatThread()</span><br><span class="line">                ),</span><br><span class="line">                renewalIntervalInSecs, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// InstanceInfo replicator</span></span><br><span class="line">        instanceInfoReplicator = <span class="keyword">new</span> InstanceInfoReplicator(</span><br><span class="line">                <span class="keyword">this</span>,</span><br><span class="line">                instanceInfo,</span><br><span class="line">                clientConfig.getInstanceInfoReplicationIntervalSeconds(),</span><br><span class="line">                <span class="number">2</span>); <span class="comment">// burstSize</span></span><br><span class="line"></span><br><span class="line">        statusChangeListener = <span class="keyword">new</span> ApplicationInfoManager.StatusChangeListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"statusChangeListener"</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(StatusChangeEvent statusChangeEvent)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (InstanceStatus.DOWN == statusChangeEvent.getStatus() ||</span><br><span class="line">                        InstanceStatus.DOWN == statusChangeEvent.getPreviousStatus()) &#123;</span><br><span class="line">                    <span class="comment">// log at warn level if DOWN was involved</span></span><br><span class="line">                    logger.warn(<span class="string">"Saw local status change event &#123;&#125;"</span>, statusChangeEvent);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    logger.info(<span class="string">"Saw local status change event &#123;&#125;"</span>, statusChangeEvent);</span><br><span class="line">                &#125;</span><br><span class="line">                instanceInfoReplicator.onDemandUpdate();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clientConfig.shouldOnDemandUpdateStatusChange()) &#123;</span><br><span class="line">            applicationInfoManager.registerStatusChangeListener(statusChangeListener);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        instanceInfoReplicator.start(clientConfig.getInitialInstanceInfoReplicationIntervalSeconds());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.info(<span class="string">"Not registering with Eureka server per configuration"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个方法里面主要有几个定时任务线程，分别被两个if包围，分别是<code>if (clientConfig.shouldFetchRegistry()) </code>和<code>if (clientConfig.shouldRegisterWithEureka())</code>，这两个参数也是我们上面说的可以配置的，代表着是否开启服务消费<code>eureka.client.fetch-registry=true</code>和是否开启服务注册<code>eureka.client.register-with-eureka=true</code>。</p><p>对于<code>if (clientConfig.shouldRegisterWithEureka())</code>逻辑里我们可以看到创建了<code>InstanceInfoReplicator</code>的一个实例并启动，该类继承Runable接口，我们找到它的run方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        discoveryClient.refreshInstanceInfo();</span><br><span class="line"></span><br><span class="line">        Long dirtyTimestamp = instanceInfo.isDirtyWithTime();</span><br><span class="line">        <span class="keyword">if</span> (dirtyTimestamp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            discoveryClient.register();</span><br><span class="line">            instanceInfo.unsetIsDirty(dirtyTimestamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.warn(<span class="string">"There was a problem with the instance info replicator"</span>, t);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Future next = scheduler.schedule(<span class="keyword">this</span>, replicationIntervalSeconds, TimeUnit.SECONDS);</span><br><span class="line">        scheduledPeriodicRef.set(next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到里面调用了<code>discoveryClient.register()</code>方法，这个方法便是<font color="red"><strong>服务注册</strong></font>的主要方法，我们看下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">register</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    logger.info(PREFIX + <span class="string">"&#123;&#125;: registering service..."</span>, appPathIdentifier);</span><br><span class="line">    EurekaHttpResponse&lt;Void&gt; httpResponse;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        httpResponse = eurekaTransport.registrationClient.register(instanceInfo);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.warn(PREFIX + <span class="string">"&#123;&#125; - registration failed &#123;&#125;"</span>, appPathIdentifier, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">        logger.info(PREFIX + <span class="string">"&#123;&#125; - registration status: &#123;&#125;"</span>, appPathIdentifier, httpResponse.getStatusCode());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> httpResponse.getStatusCode() == Status.NO_CONTENT.getStatusCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到注册操作通过REST进行，发送一个<code>com.netflix.appinfo.InstanceInfo</code>对象，该对象就是注册时客户端给服务端的服务元数据。</p><p>继续跟进<code>registrationClient.register</code>方法，找到<code>RestTemplateEurekaHttpClient</code>实现的<code>register</code>方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title">register</span><span class="params">(InstanceInfo info)</span> </span>&#123;</span><br><span class="line">String urlPath = serviceUrl + <span class="string">"apps/"</span> + info.getAppName();</span><br><span class="line"></span><br><span class="line">HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">headers.add(HttpHeaders.ACCEPT_ENCODING, <span class="string">"gzip"</span>);</span><br><span class="line">headers.add(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE);</span><br><span class="line"></span><br><span class="line">ResponseEntity&lt;Void&gt; response = restTemplate.exchange(urlPath, HttpMethod.POST,</span><br><span class="line"><span class="keyword">new</span> HttpEntity&lt;&gt;(info, headers), Void.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> anEurekaHttpResponse(response.getStatusCodeValue())</span><br><span class="line">.headers(headersOf(response)).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到注册是以gzip和POST请求发送的。</p><p>在<code>com.netflix.eureka.resources.ApplicationsResource</code>类，可以看到<font color="red"><strong>服务注册中心是如何处理服务注册请求</strong></font>的，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Path</span>(<span class="string">"/&#123;version&#125;/apps"</span>)</span><br><span class="line"><span class="meta">@Produces</span>(&#123;<span class="string">"application/xml"</span>, <span class="string">"application/json"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationsResource</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Path</span>(<span class="string">"&#123;appId&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationResource <span class="title">getApplicationResource</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            @PathParam(<span class="string">"version"</span>)</span> String version,</span></span><br><span class="line"><span class="function">            @<span class="title">PathParam</span><span class="params">(<span class="string">"appId"</span>)</span> String appId) </span>&#123;</span><br><span class="line">        CurrentRequestVersion.set(Version.toEnum(version));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApplicationResource(appId, serverConfig, registry);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@POST</span></span><br><span class="line"><span class="meta">@Consumes</span>(&#123;<span class="string">"application/json"</span>, <span class="string">"application/xml"</span>&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">addInstance</span><span class="params">(InstanceInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">                            @HeaderParam(PeerEurekaNode.HEADER_REPLICATION)</span> String isReplication) </span>&#123;</span><br><span class="line">    ...<span class="comment">//部分代码略</span></span><br><span class="line">    registry.register(info, <span class="string">"true"</span>.equals(isReplication));</span><br><span class="line">    <span class="keyword">return</span> Response.status(<span class="number">204</span>).build();  <span class="comment">// 204 to be backwards compatible</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过一些校验然后进行注册。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">final</span> InstanceInfo info, <span class="keyword">final</span> <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</span><br><span class="line">handleRegistration(info, resolveInstanceLeaseDuration(info), isReplication);</span><br><span class="line"><span class="keyword">super</span>.register(info, isReplication);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleRegistration</span><span class="params">(InstanceInfo info, <span class="keyword">int</span> leaseDuration,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">boolean</span> isReplication)</span> </span>&#123;</span><br><span class="line">log(<span class="string">"register "</span> + info.getAppName() + <span class="string">", vip "</span> + info.getVIPAddress()</span><br><span class="line">+ <span class="string">", leaseDuration "</span> + leaseDuration + <span class="string">", isReplication "</span></span><br><span class="line">+ isReplication);</span><br><span class="line">publishEvent(<span class="keyword">new</span> EurekaInstanceRegisteredEvent(<span class="keyword">this</span>, info, leaseDuration,</span><br><span class="line">isReplication));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终通过<code>publishEvent</code>方法将注册事件传播出去，提供给其他Eureka Server。这一块的过多代码我们不在分析。</p><p>再来看下<code>com.netflix.discovery.DiscoveryClient</code>这个类剩下的两个Timer，它们分别调用了<code>new HeartbeatThread()</code>和<code>new CacheRefreshThread()</code>，明显知道两个分别是心跳检测和刷新线程，里面也可以看到它们也可以通过参数进行配置一些信息。</p><p>我们先来看下<code>HeartbeatThread</code>类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartbeatThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (renew()) &#123;</span><br><span class="line">            lastSuccessfulHeartbeatTimestamp = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>renew</code>方法，这是<font color="red"><strong>服务续约</strong></font>的主要方法，我们看下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">renew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EurekaHttpResponse&lt;InstanceInfo&gt; httpResponse;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            httpResponse = eurekaTransport.registrationClient.sendHeartBeat(instanceInfo.getAppName(), instanceInfo.getId(), instanceInfo, <span class="keyword">null</span>);</span><br><span class="line">            logger.debug(PREFIX + <span class="string">"&#123;&#125; - Heartbeat status: &#123;&#125;"</span>, appPathIdentifier, httpResponse.getStatusCode());</span><br><span class="line">            <span class="keyword">if</span> (httpResponse.getStatusCode() == Status.NOT_FOUND.getStatusCode()) &#123;</span><br><span class="line">                REREGISTER_COUNTER.increment();</span><br><span class="line">                logger.info(PREFIX + <span class="string">"&#123;&#125; - Re-registering apps/&#123;&#125;"</span>, appPathIdentifier, instanceInfo.getAppName());</span><br><span class="line">                <span class="keyword">long</span> timestamp = instanceInfo.setIsDirtyWithTime();</span><br><span class="line">                <span class="keyword">boolean</span> success = register();</span><br><span class="line">                <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                    instanceInfo.unsetIsDirty(timestamp);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> success;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> httpResponse.getStatusCode() == Status.OK.getStatusCode();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            logger.error(PREFIX + <span class="string">"&#123;&#125; - was unable to send heartbeat!"</span>, appPathIdentifier, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这段代码不再过多介绍。</p><p>我们再来看下<code>CacheRefreshThread</code>类，这个类可以<font color="red"><strong>获取服务列表</strong></font>并缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CacheRefreshThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        refreshRegistry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>refreshRegistry</code>方法和<code>fetchRegistry</code>方法代码较多，我只展示了关键部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">refreshRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">boolean</span> success = fetchRegistry(remoteRegionsModified);</span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">        registrySize = localRegionApps.get().size();</span><br><span class="line">        lastSuccessfulRegistryFetchTimestamp = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">fetchRegistry</span><span class="params">(<span class="keyword">boolean</span> forceFullRegistryFetch)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (clientConfig.shouldDisableDelta()</span><br><span class="line">        || (!Strings.isNullOrEmpty(clientConfig.getRegistryRefreshSingleVipAddress()))</span><br><span class="line">        || forceFullRegistryFetch</span><br><span class="line">        || (applications == <span class="keyword">null</span>)</span><br><span class="line">        || (applications.getRegisteredApplications().size() == <span class="number">0</span>)</span><br><span class="line">        || (applications.getVersion() == -<span class="number">1</span>)) <span class="comment">//Client application does not have latest library supporting delta</span></span><br><span class="line">    &#123;</span><br><span class="line">        getAndStoreFullRegistry();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        getAndUpdateDelta(applications);</span><br><span class="line">    &#125;</span><br><span class="line">    ...        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于<code>fetchRegistry</code>方法，可以看到它会根据是否第一次进行服务获取而发起了不同的REST请求和响应，如果是第一次，会获取全部服务信息<code>getAndStoreFullRegistry</code>方法，否则获取更新部分的信息<code>getAndUpdateDelta</code>。</p><p>关于Eureka中的<font color="red"><strong>Region、Zone和serviceUrls</strong></font>，我们来看下，通过配置的<code>eureka.client.service-url</code>属性，我们可以很方便的找到<code>org.springframework.cloud.netflix.eureka.EurekaClientConfigBean</code>类中的<code>getEurekaServerServiceUrls</code>方法，它的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getEurekaServerServiceUrls</span><span class="params">(String myZone)</span> </span>&#123;</span><br><span class="line">String serviceUrls = <span class="keyword">this</span>.serviceUrl.get(myZone);</span><br><span class="line"><span class="keyword">if</span> (serviceUrls == <span class="keyword">null</span> || serviceUrls.isEmpty()) &#123;</span><br><span class="line">serviceUrls = <span class="keyword">this</span>.serviceUrl.get(DEFAULT_ZONE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.isEmpty(serviceUrls)) &#123;</span><br><span class="line"><span class="keyword">final</span> String[] serviceUrlsSplit = StringUtils</span><br><span class="line">.commaDelimitedListToStringArray(serviceUrls);</span><br><span class="line">List&lt;String&gt; eurekaServiceUrls = <span class="keyword">new</span> ArrayList&lt;&gt;(serviceUrlsSplit.length);</span><br><span class="line"><span class="keyword">for</span> (String eurekaServiceUrl : serviceUrlsSplit) &#123;</span><br><span class="line"><span class="keyword">if</span> (!endsWithSlash(eurekaServiceUrl)) &#123;</span><br><span class="line">eurekaServiceUrl += <span class="string">"/"</span>;</span><br><span class="line">&#125;</span><br><span class="line">eurekaServiceUrls.add(eurekaServiceUrl.trim());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> eurekaServiceUrls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法在<code>com.netflix.discovery.endpoint.EndpointUtils</code>的<code>getServiceUrlsFromConfig</code>方法会被调用，用于获取Region和Zone。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getServiceUrlsFromConfig</span><span class="params">(EurekaClientConfig clientConfig, String instanceZone, <span class="keyword">boolean</span> preferSameZone)</span> </span>&#123;</span><br><span class="line">     List&lt;String&gt; orderedUrls = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">     String region = getRegion(clientConfig);</span><br><span class="line">     String[] availZones = clientConfig.getAvailabilityZones(clientConfig.getRegion());</span><br><span class="line">     <span class="keyword">if</span> (availZones == <span class="keyword">null</span> || availZones.length == <span class="number">0</span>) &#123;</span><br><span class="line">         availZones = <span class="keyword">new</span> String[<span class="number">1</span>];</span><br><span class="line">         availZones[<span class="number">0</span>] = DEFAULT_ZONE;</span><br><span class="line">     &#125;</span><br><span class="line">     logger.debug(<span class="string">"The availability zone for the given region &#123;&#125; are &#123;&#125;"</span>, region, availZones);</span><br><span class="line">     <span class="keyword">int</span> myZoneOffset = getZoneOffset(instanceZone, preferSameZone, availZones);</span><br><span class="line"></span><br><span class="line">     List&lt;String&gt; serviceUrls = clientConfig.getEurekaServerServiceUrls(availZones[myZoneOffset]);</span><br><span class="line">     <span class="keyword">if</span> (serviceUrls != <span class="keyword">null</span>) &#123;</span><br><span class="line">         orderedUrls.addAll(serviceUrls);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> currentOffset = myZoneOffset == (availZones.length - <span class="number">1</span>) ? <span class="number">0</span> : (myZoneOffset + <span class="number">1</span>);</span><br><span class="line">     <span class="keyword">while</span> (currentOffset != myZoneOffset) &#123;</span><br><span class="line">         serviceUrls = clientConfig.getEurekaServerServiceUrls(availZones[currentOffset]);</span><br><span class="line">         <span class="keyword">if</span> (serviceUrls != <span class="keyword">null</span>) &#123;</span><br><span class="line">             orderedUrls.addAll(serviceUrls);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (currentOffset == (availZones.length - <span class="number">1</span>)) &#123;</span><br><span class="line">             currentOffset = <span class="number">0</span>;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             currentOffset++;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (orderedUrls.size() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"DiscoveryClient: invalid serviceUrl specified!"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> orderedUrls;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出，当我们没有为Region配置Zone时，将默认采用defaultZone，若要为应用指定Zone，可以通过<code>eureka.client.availability-zones</code>来进行指定，Zone可以设置多个，通过逗号分隔来进行设置，可以判断Region和Zone是一对多的关系。</p><p>设置Zone可以在负载均衡时实现区域亲和特性，例如Ribbon的负载均衡策略会优先访问客户端处于同一个Zone的服务端实例，该Zone域没有服务端可用实例后才会访问其他Zone。我们结合实际部署物理结构，可以有效地设计出针对区域性故障的容错集群。</p><h2 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h2><p>我们上面讲了许多源码，可能很多同学也没有细看，大家更注重的是Eureka的快速上手和使用，这儿，我把Eureka配置的一些参数总结下，来供大家参考，用于解决一些实际问题。</p><h3 id="Eureka-client-配置项"><a href="#Eureka-client-配置项" class="headerlink" title="Eureka client 配置项"></a>Eureka client 配置项</h3><table><thead><tr><th style="text-align:left">参数Key</th><th style="text-align:left">说明</th><th style="text-align:left">参数Value类型</th><th style="text-align:left">参数Value默认值</th><th style="text-align:left">注意</th></tr></thead><tbody><tr><td style="text-align:left">eureka.client.register-with-eureka</td><td style="text-align:left">是否向注册中心注册当前实例</td><td style="text-align:left">boolean</td><td style="text-align:left">true</td><td style="text-align:left">对于高可用的Eureka Server集群，该值需为true，以形成一组相互注册的Server集群</td></tr><tr><td style="text-align:left">eureka.client.fetch-registry</td><td style="text-align:left">是否需要检索服务信息（从注册中心获取服务信息）</td><td style="text-align:left">boolean</td><td style="text-align:left">true</td><td style="text-align:left">同上</td></tr><tr><td style="text-align:left">eureka.client.enabled</td><td style="text-align:left">是否启用Eureka Client</td><td style="text-align:left">boolean</td><td style="text-align:left">true</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.service-url</td><td style="text-align:left">服务注册地址(注册中心地址)（一般使用默认配置eureka.client.service-url.defaultZone）</td><td style="text-align:left">Map&lt;String,String&gt;</td><td style="text-align:left"></td><td style="text-align:left">该值由于是Map，有一个默认key值defaultZone（常用），也可以自己指定Zone，如下格式eureka.client.service-url.testZone=<a href="http://172.30.13.173:8002/eureka/,http://172.30.13.173:8003/eureka/" rel="external nofollow noopener noreferrer" target="_blank">http://172.30.13.173:8002/eureka/,http://172.30.13.173:8003/eureka/</a>  参数是服务注册中心地址，多个地址以逗号隔开，其中testZone需要通过eureka.client.availability-zones参数指定</td></tr><tr><td style="text-align:left">eureka.client.availability-zones</td><td style="text-align:left">可用的Zone列表（一般无需配置）</td><td style="text-align:left">Map&lt;String,String&gt;</td><td style="text-align:left"></td><td style="text-align:left">该值由于是Map，有一个默认key值us-east-1（代表Region），也可以自己指定Region，如下格式eureka.client.availability-zones.testRegion=testZone,testZone1 参数表示可用的Zone，以逗号分开，其中testRegion需要通过eureka.client.region指定</td></tr><tr><td style="text-align:left">eureka.client.region</td><td style="text-align:left">Eureka Client Region域</td><td style="text-align:left">String</td><td style="text-align:left">us-east-1</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.registry-fetch-interval-seconds</td><td style="text-align:left">从注册中心同步服务信息的间隔时间（单位：秒）</td><td style="text-align:left">int</td><td style="text-align:left">30</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.prefer-same-zone-eureka</td><td style="text-align:left">是否偏好使用处于相同Zone的Eureka服务端</td><td style="text-align:left">boolean</td><td style="text-align:left">true</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.filter-only-up-instances</td><td style="text-align:left">获取实例时是否过滤，仅保留UP状态的实例</td><td style="text-align:left">boolean</td><td style="text-align:left">true</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.use-dns-for-fetching-service-urls</td><td style="text-align:left">使用DNS来获取Eureka服务端的serviceUrl</td><td style="text-align:left">boolean</td><td style="text-align:left">false</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.heartbeat-executor-thread-pool-size</td><td style="text-align:left">心跳连接池的初始化线程数</td><td style="text-align:left">int</td><td style="text-align:left">2</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.heartbeat-executor-exponential-back-off-bound</td><td style="text-align:left">心跳超时重试延迟时间的最大乘数值</td><td style="text-align:left">int</td><td style="text-align:left">10</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.cache-refresh-executor-thread-pool-size</td><td style="text-align:left">缓存刷新线程池的初始化线程数</td><td style="text-align:left">int</td><td style="text-align:left">2</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.cache-refresh-executor-exponential-back-off-bound</td><td style="text-align:left">缓存刷新超时重试延迟时间的最大乘数值</td><td style="text-align:left">int</td><td style="text-align:left">10</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.healthcheck.enabled</td><td style="text-align:left">是否进行健康状态检测</td><td style="text-align:left">boolean</td><td style="text-align:left">true</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.instance-info-replication-interval-seconds</td><td style="text-align:left">更新实例信息的变化到Eureka服务端的间隔时间，单位为秒</td><td style="text-align:left">int</td><td style="text-align:left">30</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.initial-instance-info-replication-interval-seconds</td><td style="text-align:left">初始化实例信息的变化到Eureka服务端的间隔时间，单位为秒</td><td style="text-align:left">int</td><td style="text-align:left">40</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.eureka-service-url-poll-interval-seconds</td><td style="text-align:left">轮询Eureka服务地址更改的时间间隔，单位秒</td><td style="text-align:left">int</td><td style="text-align:left">300</td><td style="text-align:left">当我们与Spring Cloud Config配合，动态刷新Eureka的serviceURL地址时需要关注该参数</td></tr><tr><td style="text-align:left">eureka.client.eureka-server-read-timeout-seconds</td><td style="text-align:left">读取Eureka Server信息超时时间，单位秒</td><td style="text-align:left">int</td><td style="text-align:left">8</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.eureka-server-connect-timeout-seconds</td><td style="text-align:left">连接Eureka Server的超时时间，单位秒</td><td style="text-align:left">int</td><td style="text-align:left">5</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.eureka-server-total-connections</td><td style="text-align:left">从Eureka客户端到Eureka服务端的连接总数</td><td style="text-align:left">int</td><td style="text-align:left">200</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.eureka-server-total-connections-per-host</td><td style="text-align:left">从Eureka客户端到每个Eureka服务端的连接总数</td><td style="text-align:left">int</td><td style="text-align:left">50</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.eureka-connection-idle-timeout-seconds</td><td style="text-align:left">Eureka服务端空闲连接关闭时间，单位秒</td><td style="text-align:left">int</td><td style="text-align:left">30</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.eureka-server-port</td><td style="text-align:left">获取要用于构造服务url的端口，以便在eureka服务器列表来自DNS时联系eureka服务器</td><td style="text-align:left">String</td><td style="text-align:left"></td><td style="text-align:left">如果返回服务url eurekaServerServiceUrls(字符串)，则不需要此信息。当useDnsForFetchingServiceUrls设置为true时，将使用DNS机制，eureka客户机希望DNS以某种方式配置，以便它能够动态获取更改的eureka服务器。更改在运行时生效</td></tr><tr><td style="text-align:left">eureka.client.eureka-server-d-n-s-name</td><td style="text-align:left">获取要查询的DNS名称，以获得eureka服务器列表</td><td style="text-align:left">String</td><td style="text-align:left"></td><td style="text-align:left">如果通过实现serviceUrls返回服务url，则不需要此信息。当useDnsForFetchingServiceUrls设置为true时，将使用DNS机制，eureka客户机希望DNS以某种方式配置，以便它能够动态获取更改的eureka服务器。更改在运行时生效</td></tr><tr><td style="text-align:left">eureka.client.eureka-server-u-r-l-context</td><td style="text-align:left">获取要用于构造服务URL的URL上下文，以便在eureka服务器列表来自DNS时通知eureka服务器</td><td style="text-align:left">String</td><td style="text-align:left"></td><td style="text-align:left">如果从eurekaServerServiceUrls返回服务url，则不需要此信息。当useDnsForFetchingServiceUrls设置为true时，将使用DNS机制，eureka客户机希望DNS以某种方式配置，以便它能够动态获取更改的eureka服务器。更改在运行时生效</td></tr><tr><td style="text-align:left">eureka.client.proxy-host</td><td style="text-align:left">获取eureka服务的代理主机</td><td style="text-align:left">String</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.proxy-port</td><td style="text-align:left">获取eureka服务的代理端口</td><td style="text-align:left">String</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.proxy-user-name</td><td style="text-align:left">获取eureka服务的代理用户名</td><td style="text-align:left">String</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.proxy-password</td><td style="text-align:left">获取eureka服务的代理密码</td><td style="text-align:left">String</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.g-zip-content</td><td style="text-align:left">eureka注册表的内容是否要进行压缩</td><td style="text-align:left">boolean</td><td style="text-align:left">true</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.allow-redirects</td><td style="text-align:left">服务器是否可以将客户机请求重定向到备份服务器/集群</td><td style="text-align:left">boolean</td><td style="text-align:left">false</td><td style="text-align:left">如果设置为false，服务器将直接处理请求，如果设置为true，它可能向客户机发送HTTP重定向，并提供一个新的服务器位置。</td></tr><tr><td style="text-align:left">eureka.client.should-enforce-registration-at-init</td><td style="text-align:left">客户端是否应在初始化期间强制注册</td><td style="text-align:left">boolean</td><td style="text-align:left">false</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.should-unregister-on-shutdown</td><td style="text-align:left">客户端关闭时是否应显式地从远程服务器注销自己</td><td style="text-align:left">boolean</td><td style="text-align:left">true</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.registry-refresh-single-vip-address</td><td style="text-align:left">客户端是否只对单个VIP的注册地址信息感兴趣</td><td style="text-align:left">String</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.client-data-accept</td><td style="text-align:left">客户端数据接收的EurekaAccept名称</td><td style="text-align:left">String</td><td style="text-align:left">full</td><td style="text-align:left">full支持LegacyJacksonJson、JacksonJson、XStreamJson、XStreamXml、JacksonXml;compact支持JacksonJsonMini、JacksonXmlMini</td></tr><tr><td style="text-align:left">eureka.client.fetch-remote-regions-registry</td><td style="text-align:left">将获取eureka注册表信息的区域的逗号分隔列表</td><td style="text-align:left">String</td><td style="text-align:left"></td><td style="text-align:left">配置此参数后，必须为每个availability zones定义regions用于返回availabilityZones参数。否则，将导致客户端启动失败。</td></tr><tr><td style="text-align:left">eureka.client.decoder-name</td><td style="text-align:left">临时解码器</td><td style="text-align:left">String</td><td style="text-align:left"></td><td style="text-align:left">这是一个临时配置，一旦最新的编解码器稳定下来，就可以删除它(因为只有一个编解码器)</td></tr><tr><td style="text-align:left">eureka.client.encoder-name</td><td style="text-align:left">临时编码器</td><td style="text-align:left">String</td><td style="text-align:left"></td><td style="text-align:left">这是一个临时配置，一旦最新的编解码器稳定下来，就可以删除它(因为只有一个编解码器)</td></tr><tr><td style="text-align:left">eureka.client.order</td><td style="text-align:left">该参数可使“CompositeDiscoveryClient”对服务提供者上可用的客户端排序</td><td style="text-align:left">int</td><td style="text-align:left">0</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.disable-delta</td><td style="text-align:left">eureka客户端是否应该禁用对delta的抓取，从而每次都是请求获取全部服务信息</td><td style="text-align:left">boolean</td><td style="text-align:left">false</td><td style="text-align:left">注意，设置为true后不会增量更新服务注册信息，而是全量更新，delta获取（增量更新）可以极大地减少流量，因为eureka服务器的更改速度通常比获取速度低得多。更改在运行时的下一个服务注册信息获取周期中有效，该周期由registryFetchIntervalSeconds指定</td></tr><tr><td style="text-align:left">eureka.client.log-delta-diff</td><td style="text-align:left">是否根据服务注册信息记录eureka服务端和eureka客户端之间注册信息的差异</td><td style="text-align:left">boolean</td><td style="text-align:left">false</td><td style="text-align:left">Eureka客户端尝试仅检索来自Eureka服务器的增量更改，以最小化网络流量。在接收到增量之后，eureka客户端将协调来自服务器的信息，以验证它没有遗漏某些信息。当客户端与服务器通信出现网络问题时，可能会发生协调失败。如果对账失败，eureka客户端将获得完整的服务注册信息。在获得完整的注册表信息时，eureka客户端可以记录客户端和服务器之间的差异，而这个设置控制着这一点。更改在运行时的下一个注册信息获取周期中有效，该周期由registryFetchIntervalSecondsr指定</td></tr><tr><td style="text-align:left">eureka.client.on-demand-update-status-change</td><td style="text-align:left">是否将客户端状态同步到远程Eureka服务器</td><td style="text-align:left">boolean</td><td style="text-align:left">true</td><td style="text-align:left">如果设置为true，则通过ApplicationInfoManager将本地状态变化注册/更新到远程eureka服务器</td></tr><tr><td style="text-align:left">eureka.client.backup-registry-impl</td><td style="text-align:left">获取服务注册信息实现类的名称，该类需要实现BackupRegistry接口，在Eureka客户端启动时只能触发一次，来拿到服务注册信息</td><td style="text-align:left">String</td><td style="text-align:left"></td><td style="text-align:left">对于需要额外弹性来处理注册信息的应用程序来说，这个参数可能会用到，否则服务注册信息我们是无法显式操作的</td></tr><tr><td style="text-align:left">eureka.client.property-resolver</td><td style="text-align:left">property参数转换，可以实现自定义property文件类</td><td style="text-align:left">PropertyResolver</td><td style="text-align:left"></td><td style="text-align:left">需要实现PropertyResolver接口的类</td></tr><tr><td style="text-align:left">eureka.client.dollar-replacement</td><td style="text-align:left">在序列化/反序列化eureka服务器中的信息时，获取美元符号<code>$</code>的替换字符串</td><td style="text-align:left">String</td><td style="text-align:left"><font>_-</font></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.escape-char-replacement</td><td style="text-align:left">在序列化/反序列化eureka服务器中的信息时，获取下划线符号<code>_</code>的替换字符串</td><td style="text-align:left">String</td><td style="text-align:left">__</td><td style="text-align:left"></td></tr></tbody></table><h3 id="Eureka-instance-配置项"><a href="#Eureka-instance-配置项" class="headerlink" title="Eureka instance 配置项"></a>Eureka instance 配置项</h3><table><thead><tr><th>参数Key</th><th>说明</th><th>参数Value类型</th><th>参数Value默认值</th><th>注意</th></tr></thead><tbody><tr><td>eureka.instance.hostname</td><td>主机名</td><td>String</td><td></td><td>不配置的话将根据操作系统的主机名来获取</td></tr><tr><td>eureka.instance.appname</td><td>服务名</td><td>String</td><td>unknown</td><td>默认取spring.application.name的配置值，两者都没有配置为默认值unknown</td></tr><tr><td>eureka.instance.instance-id</td><td>实例ID</td><td>String</td><td></td><td>一般如下配置eureka.instance.instance-id=${server.address}:${server.port}</td></tr><tr><td>eureka.instance.prefer-ip-address</td><td>是否使用IP定义主机名标识</td><td>boolean</td><td>false</td><td></td></tr><tr><td>eureka.instance.lease-renewal-interval-in-seconds</td><td>Eureka客户端向服务端发送心跳的时间间隔，单位秒</td><td>int</td><td>30</td><td></td></tr><tr><td>eureka.instance.lease-expiration-duration-in-seconds</td><td>Eureka服务端在收到最后一次心跳之后等待的时间上限，单位秒</td><td>int</td><td>90</td><td>超过改时间后服务端会将该实例从服务清单上剔除，从而禁止服务调用请求被发送到该实例上</td></tr><tr><td>eureka.instance.non-secure-port</td><td>非安全通信端口号</td><td>int</td><td>80</td><td></td></tr><tr><td>eureka.instance.non-secure-port-enabled</td><td>是否开启非安全通信端口号</td><td>boolean</td><td>true</td><td></td></tr><tr><td>eureka.instance.secure-port</td><td>安全通信端口号</td><td>int</td><td>443</td><td></td></tr><tr><td>eureka.instance.secure-port-enabled</td><td>是否开启安全通信端口号</td><td>boolean</td><td>false</td><td></td></tr><tr><td>eureka.instance.namespace</td><td>获取用于查找属性的名称空间</td><td>String</td><td>eureka</td><td>SpringCloud下该属性不生效，会被忽略</td></tr><tr><td>eureka.instance.virtual-host-name</td><td>获取为此实例定义的虚拟主机名</td><td>String</td><td>unknown</td><td>这通常是其他实例使用虚拟主机名查找此实例的方式。如果你需要查找此实例，这个主机名也是完全合格的</td></tr><tr><td>eureka.instance.secure-virtual-host-name</td><td>获取此实例的安全的虚拟主机名</td><td>String</td><td>unknown</td><td></td></tr><tr><td>eureka.instance.environment</td><td>实例所属环境</td><td>Environment</td><td></td><td>设置后会读取指定环境下的spring.application.name属性</td></tr><tr><td>eureka.instance.health-check-url-path</td><td>实例健康检测的相对路径</td><td>String</td><td>/actuator/health</td><td></td></tr><tr><td>eureka.instance.health-check-url</td><td>实例健康状态检测的绝对地址URL</td><td>String</td><td></td><td>如果页面就是在当前服务实例下，只需提供healthCheckUrlPath参数即可，否则可能代理的其他的服务器信息，需要提供绝对地址，如果提供了绝对地址，优先使用绝对地址</td></tr><tr><td>eureka.instance.secure-health-check-url</td><td>实例健康状态检查安全访问地址</td><td>String</td><td></td><td></td></tr><tr><td>eureka.instance.home-page-url-path</td><td>Eureka实例展示主页的相对路径</td><td>String</td><td>/</td><td></td></tr><tr><td>eureka.instance.home-page-url</td><td>Eureka实例展示主页的绝对路径</td><td>String</td><td></td><td>参照health-check-url</td></tr><tr><td>eureka.instance.status-page-url-path</td><td>实例状态信息监控相对地址</td><td>String</td><td>/actuator/info</td><td></td></tr><tr><td>eureka.instance.status-page-url</td><td>实例状态信息监控绝对地址</td><td>String</td><td></td><td>参照health-check-url</td></tr><tr><td>eureka.instance.instance-enabled-onit</td><td>是否使该实例在向eureka注册后是否可以立即进行通信</td><td>boolean</td><td>false</td><td>有时，应用程序可能需要进行一些预处理，然后才能处理请求；如不需预处理，可设置为true</td></tr><tr><td>eureka.instance.registry.default-open-for-traffic-count</td><td>该实例，注册服务中心，默认打开的通信数量</td><td>int</td><td>1</td><td></td></tr><tr><td>eureka.instance.registry.expected-number-of-clients-sending-renews</td><td>单位时间期望的续约连接数量</td><td>int</td><td>1</td><td>此数需要大于0，以确保注册中心可以根据注册数量调整失效清除策略，如果设为0，即使注册成功也不会重置速率阈值</td></tr><tr><td>eureka.instance.data-center-info</td><td>返回部署此实例的数据中心。如果实例部署在AWS中，则此信息用于获取一些特定于AWS的实例信息</td><td>DataCenterInfo</td><td>DataCenterInfo.Name.MyOwn</td><td></td></tr><tr><td>eureka.instance.initial-status</td><td>实例初始化状态</td><td>InstanceStatus</td><td>UP</td><td></td></tr><tr><td>eureka.instance.ip-address</td><td>配置实例的IPAdress</td><td>String</td><td></td><td>此信息仅用于测试，因为与其他实例的通信主要使用getHostName中提供的信息进行</td></tr><tr><td>eureka.instance.app-group-name</td><td>获取要在eureka中注册的应用程序组的名称</td><td>String</td><td></td><td></td></tr><tr><td>eureka.instance.a-s-g-name</td><td>用于AWS平台自动扩展的与此实例关联的组名</td><td>String</td><td></td><td></td></tr><tr><td>eureka.instance.default-address-resolution-order</td><td>默认的地址解析顺序</td><td>String[]</td><td>[]</td><td></td></tr><tr><td>eureka.instance.metadata-map</td><td>该服务实例的子定义元数据，可以被服务中心接受到</td><td>Map&lt;String,String&gt;</td><td></td><td></td></tr></tbody></table><h3 id="Eureka-Server配置项"><a href="#Eureka-Server配置项" class="headerlink" title="Eureka Server配置项"></a>Eureka Server配置项</h3><table><thead><tr><th>参数Key</th><th>说明</th><th>参数Value类型</th><th>参数Value默认值</th><th>注意</th></tr></thead><tbody><tr><td>eureka.server.enable-self-preservation</td><td>Eureka Server是否启用自我保护机制</td><td>boolean</td><td>true</td><td></td></tr><tr><td>eureka.server.response-cache-update-interval-ms</td><td>eureka server刷新readCacheMap的时间，单位毫秒</td><td>long</td><td>30000</td><td>client读取的是readCacheMap，这个时间决定了多久会把readWriteCacheMap的缓存更新到readCacheMap上，默认30s</td></tr><tr><td>eureka.server.response-cache-auto-expiration-in-seconds</td><td>eureka server缓存readWriteCacheMap失效时间，单位秒</td><td>long</td><td>180</td><td>这个只有在这个时间过去后缓存才会失效，失效前不会更新，过期后从registry重新读取注册服务信息，registry是一个ConcurrentHashMap。</td></tr><tr><td>eureka.server.eviction-interval-timer-in-ms</td><td>每次主动失效检测间隔，单位毫秒</td><td>long</td><td>60000</td><td></td></tr><tr><td>eureka.server.renewal-percent-threshold</td><td>阈值因子，一段时间内心跳比例是否低于此值，低于此值开启自我保护</td><td>double</td><td>0.85</td><td></td></tr><tr><td>eureka.server.renewal-threshold-update-interval-ms</td><td>阈值更新的时间间隔</td><td>int</td><td>900000</td><td>结合阈值因子参数我们可以看到，默认情况下，当15min内心跳比例低于85%，Eureka会进入自我保护模式</td></tr><tr><td>eureka.server.rate-limiter-enabled</td><td>是否启用请求频率限制</td><td>boolean</td><td>false</td><td></td></tr><tr><td>eureka.server.rate-limiter-burst-size</td><td>请求频率大小限制</td><td>int</td><td>10</td><td></td></tr><tr><td>eureka.server.rate-limiter-full-fetch-average-rate</td><td>请求频率的平均值</td><td>int</td><td>100</td><td></td></tr><tr><td>eureka.server.rate-limiter-registry-fetch-average-rate</td><td>注册服务、拉去服务列表数据的请求频率的平均值</td><td>int</td><td>500</td><td></td></tr><tr><td>eureka.server.rate-limiter-throttle-standard-clients</td><td>是否对标准的client进行频率请求限制。如果是false，则只对非标准client进行限制</td><td>boolean</td><td>false</td><td></td></tr><tr><td>eureka.server.rate-limiter-privileged-clients</td><td>设置信任的client list</td><td>Set</td><td></td><td></td></tr><tr><td>eureka.server.peer-eureka-nodes-update-interval-ms</td><td>eureka节点间间隔多长时间更新一次数据,单位毫秒</td><td>int</td><td>600000</td><td></td></tr><tr><td>eureka.server.peer-eureka-status-refresh-time-interval-ms</td><td>eureka服务状态的相互更新的时间间隔，单位毫秒</td><td>int</td><td>30000</td><td></td></tr><tr><td>eureka.server.peer-node-connect-timeout-ms</td><td>eureka对等节点间连接超时时间，单位毫秒</td><td>int</td><td>200</td><td></td></tr><tr><td>eureka.server.peer-node-connection-idle-timeout-seconds</td><td>eureka对等节点连接后的空闲时间，单位秒</td><td>int</td><td>30</td><td></td></tr><tr><td>eureka.server.peer-node-read-timeout-ms</td><td>节点间的读数据连接超时时间，单位毫秒</td><td>int</td><td>200</td><td></td></tr><tr><td>eureka.server.peer-node-total-connections</td><td>eureka server 节点间连接的总共最大连接数量</td><td>int</td><td>1000</td><td></td></tr><tr><td>eureka.server.peer-node-total-connections-per-host</td><td>eureka server 节点间连接的单机最大连接数量</td><td>int</td><td>500</td><td></td></tr><tr><td>eureka.server.enable-replicated-request-compression</td><td>发送复制数据是否在request中总是压缩</td><td>boolean</td><td>false</td><td></td></tr><tr><td>eureka.server.batch-replication</td><td>指示群集节点之间的复制是否应批处理以提高网络效率</td><td>boolean</td><td>false</td><td></td></tr><tr><td>eureka.server.max-elements-in-peer-replication-pool</td><td>允许备份到备份池的最大复制事件数量</td><td>int</td><td>10000</td><td>这个备份池负责除状态更新的其他事件。可以根据内存大小，超时和复制流量，来设置此值得大小</td></tr><tr><td>eureka.server.max-elements-in-status-replication-pool</td><td>允许备份到状态备份池的最大复制事件数量</td><td>int</td><td>10000</td><td></td></tr><tr><td>eureka.server.max-idle-thread-age-in-minutes-for-peer-replication</td><td>多个服务中心相互同步信息线程的最大空闲时间，单位min</td><td>long</td><td>15</td><td></td></tr><tr><td>eureka.server.max-idle-thread-in-minutes-age-for-status-replication</td><td>状态同步线程的最大空闲时间，单位min</td><td>long</td><td>10</td><td></td></tr><tr><td>eureka.server.max-threads-for-peer-replication</td><td>服务注册中心各个instance相互复制数据的最大线程数量</td><td>int</td><td>20</td><td></td></tr><tr><td>eureka.server.max-threads-for-status-replication</td><td>服务注册中心各个instance相互复制状态数据的最大线程数量</td><td>int</td><td>1</td><td></td></tr><tr><td>eureka.server.max-time-for-replication</td><td>instance之间复制数据的通信时长，单位毫秒</td><td>int</td><td>300000</td><td></td></tr><tr><td>eureka.server.min-available-instances-for-peer-replication</td><td>正常的对等服务instance最小数量</td><td>int</td><td>-1</td><td>-1表示服务中心为单节点。</td></tr><tr><td>eureka.server.min-threads-for-peer-replication</td><td>instance之间相互复制开启的最小线程数量</td><td>int</td><td>5</td><td></td></tr><tr><td>eureka.server.min-threads-for-status-replication</td><td>instance之间用于状态复制，开启的最小线程数量</td><td>int</td><td>1</td><td></td></tr><tr><td>eureka.server.number-of-replication-retries</td><td>instance之间复制数据时可以重试的次数</td><td>int</td><td>5</td><td></td></tr><tr><td>eureka.server.registry-sync-retries</td><td>在服务节点启动时，eureka尝试获取注册信息的次数</td><td>int</td><td>0</td><td></td></tr><tr><td>eureka.server.registry-sync-retry-wait-ms</td><td>在服务节点启动时，eureka多次尝试获取注册信息的间隔时间</td><td>int</td><td>30000</td><td></td></tr><tr><td>eureka.server.wait-time-in-ms-when-sync-empty</td><td>当eureka server启动的时候，不能从对等节点获取instance注册信息的情况，应等待多长时间</td><td>int</td><td>300000</td><td></td></tr><tr><td>eureka.server.disable-delta-for-remote-regions</td><td>过期数据，是否也提供给远程region</td><td>boolean</td><td>false</td><td></td></tr><tr><td>eureka.server.disable-transparent-fallback-to-other-region</td><td>回退到远程区域中的应用程序的旧行为 (如果已配置) 如果本地区域中没有该应用程序的实例, 则将被禁用</td><td>boolean</td><td>false</td><td></td></tr><tr><td>eureka.server.g-zip-content-from-remote-region</td><td>指示在服务器支持的情况下, 是否必须为远程区域压缩从eureka服务器获取的内容</td><td>boolean</td><td>true</td><td></td></tr><tr><td>eureka.server.remote-region-connect-timeout-ms</td><td>连接eureka remote note的连接超时时间，单位毫秒</td><td>int</td><td>1000</td><td></td></tr><tr><td>eureka.server.remote-region-app-whitelist</td><td>remote region 应用白名单</td><td>Map&lt;String,String&gt;</td><td></td><td></td></tr><tr><td>eureka.server.remote-region-connection-idle-timeout-seconds</td><td>连接eureka remote note的连接空闲时间,单位秒</td><td>int</td><td>30</td><td></td></tr><tr><td>eureka.server.remote-region-fetch-thread-pool-size</td><td>执行remote region 获取注册信息的请求线程池大小</td><td>int</td><td>20</td><td></td></tr><tr><td>eureka.server.remote-region-read-timeout-ms</td><td>remote region 从对等eureka加点读取数据的超时时间，单位毫秒</td><td>int</td><td>1000</td><td></td></tr><tr><td>eureka.server.remote-region-registry-fetch-interval</td><td>从remote region 获取注册信息的时间间隔，单位秒</td><td>int</td><td>30</td><td></td></tr><tr><td>eureka.server.remote-region-total-connections</td><td>remote region 连接eureka节点的总连接数量</td><td>int</td><td>1000</td><td></td></tr><tr><td>eureka.server.remote-region-total-connections-per-host</td><td>remote region 连接eureka节点的单机连接数量</td><td>int</td><td>50</td><td></td></tr><tr><td>eureka.server.remote-region-trust-store</td><td>remote region抓取注册信息的存储文件，而这个可靠的存储文件需要全限定名来指定</td><td>String</td><td>“”</td><td></td></tr><tr><td>eureka.server.remote-region-trust-store-password</td><td>remote region 储存的文件的密码</td><td>String</td><td>“changeit”</td><td></td></tr><tr><td>eureka.server.remote-region-urls</td><td>远程region URL地址</td><td>String</td><td></td><td>remote region url.多个逗号隔开</td></tr><tr><td>eureka.server.remote-region-urls-with-name</td><td>远程region URL地址名称</td><td>Map&lt;String,String&gt;</td><td></td><td>remote region url.多个逗号隔开</td></tr><tr><td>eureka.server.a-s-g-cache-expiry-timeout-ms</td><td>缓存ASG信息的过期时间，单位毫秒</td><td>int</td><td>60000</td><td></td></tr><tr><td>eureka.server.a-s-g-query-timeout-ms</td><td>查询ASG信息的超时时间，单位毫秒</td><td>int</td><td>300</td><td></td></tr><tr><td>eureka.server.a-s-g-update-interval-ms</td><td>服务更新ASG信息的频率，单位毫秒</td><td>int</td><td>30000</td><td></td></tr><tr><td>eureka.server.a-w-s-access-id</td><td>AWS访问ID</td><td>String</td><td></td><td></td></tr><tr><td>eureka.server.a-w-s-secret-key</td><td>AWS安全密钥</td><td>String</td><td></td><td></td></tr><tr><td>eureka.server.binding-strategy</td><td>AWS绑定策略</td><td>AwsBindingStrategy</td><td>eip</td><td></td></tr><tr><td>eureka.server.list-auto-scaling-groups-role-name</td><td>用于从第三方AWS 帐户描述自动扩展分组的角色的名称</td><td>String</td><td></td><td></td></tr><tr><td>eureka.server.prime-aws-replica-connections</td><td>是否应该建立连接引导</td><td>boolean</td><td>true</td><td></td></tr><tr><td>eureka.server.e-i-p-bind-rebind-retries</td><td>服务端尝试绑定候选EIP的次数</td><td>int</td><td>3</td><td></td></tr><tr><td>eureka.server.e-i-p-binding-retry-interval-ms</td><td>服务端绑定EIP的时间间隔.如果绑定就检查;如果绑定失效就重新绑定。当且仅当已经绑定的情况，单位毫秒</td><td>int</td><td>300000</td><td></td></tr><tr><td>eureka.server.e-i-p-binding-retry-interval-ms-when-unbound</td><td>服务端绑定EIP的时间间隔.当且仅当服务为绑定的情况，单位毫秒</td><td>int</td><td>60000</td><td></td></tr><tr><td>eureka.server.route53-bind-rebind-retries</td><td>服务端尝试绑定route53的次数</td><td>int</td><td>3</td><td></td></tr><tr><td>eureka.server.route53-binding-retry-interval-ms</td><td>服务端间隔多长时间尝试绑定route53，单位毫秒</td><td>int</td><td>300000</td><td></td></tr><tr><td>eureka.server.route53-domain-t-t-l</td><td>route53 domain生存时间</td><td>int</td><td>30</td><td></td></tr><tr><td>eureka.server.delta-retention-timer-interval-in-ms</td><td>间隔多长时间，清除过期的delta数据</td><td>int</td><td>30000</td><td></td></tr><tr><td>eureka.server.disable-delta</td><td>过期数据，是否也提供给client</td><td>boolean</td><td>false</td><td></td></tr><tr><td>eureka.server.log-identity-headers</td><td>eureka服务端是否记录client的身份header</td><td>boolean</td><td>true</td><td></td></tr><tr><td>eureka.server.retention-time-in-m-s-in-delta-queue</td><td>缓存增量数据的时间，以便在检索的时候不丢失信息</td><td>int</td><td>180000</td></tr><tr><td>eureka.server.sync-when-timestamp-differs</td><td>当时间戳不一致的时候，是否进行同步</td><td>boolean</td><td>true</td><td></td></tr><tr><td>eureka.server.use-read-only-response-cache</td><td>是否采用只读缓存策略，只读策略对于缓存的数据不会过期</td><td>boolean</td><td>true</td><td></td></tr><tr><td>eureka.server.json-codec-name</td><td>json的转换的实现类名</td><td>String</td><td></td><td></td></tr><tr><td>eureka.server.property-resolver</td><td>属性解析器</td><td>PropertyResolver</td><td></td><td></td></tr><tr><td>eureka.server.xml-codec-name</td><td>eureka server xml的编解码实现名称</td><td>String</td><td></td><td></td></tr></tbody></table><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章通过对Eureka的一些分析，简单了解了Eureka的一些工作原理，对我们使用Eureka还是蛮有帮助的。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>SpringCloud 微服务实战</li><li>Eureka源码</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Eureka" scheme="https://www.sakuratears.top/tags/Eureka/"/>
    
      <category term="SpringCloud" scheme="https://www.sakuratears.top/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring循环依赖问题</title>
    <link href="https://www.sakuratears.top/blog/pring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98.html"/>
    <id>https://www.sakuratears.top/blog/pring循环依赖问题.html</id>
    <published>2019-08-03T12:59:14.000Z</published>
    <updated>2019-08-03T13:10:58.795Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近对Spring的循环依赖比较感兴趣，特地研究了一下并分享给大家。</p><p>要说循环依赖，先理解循环引用，如果一个Class如TestA，需要引用TestB，而同时TestB又引用TestA，则可以称这两个类循环引用。</p><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TestB testB;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestA</span><span class="params">(TestB testB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testB = testB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestB</span><span class="params">(TestB testB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testB = testB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestB <span class="title">getTestB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> testB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TestA testA;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestB</span><span class="params">(TestA testA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testA = testA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestA</span><span class="params">(TestA testA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testA = testA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestA <span class="title">getTestA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> testA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这两个类被Spring管理，成为Spring的Bean，就会有循环依赖问题。</p><p>对于循环依赖问题，可能会有问题导致Bean创建不成功，我们来看一下。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>我们知道，对于Spring的Bean，有singleton（单例）和prototype（多例）两种模式。</p><p>对于SpringBean的创建，我们有构造器注入和Setter注入两种方式。</p><p>它们都会对循环依赖问题造成影响，我们分别讨论。</p><h2 id="Bean都为singleton模式，都通过构造器注入"><a href="#Bean都为singleton模式，都通过构造器注入" class="headerlink" title="Bean都为singleton模式，都通过构造器注入"></a>Bean都为singleton模式，都通过构造器注入</h2><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(value = BeanDefinition.SCOPE_SINGLETON)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TestB testB;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestA</span><span class="params">(TestB testB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testB = testB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestB</span><span class="params">(TestB testB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testB = testB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Scope</span>(value = BeanDefinition.SCOPE_SINGLETON)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TestA testA;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestB</span><span class="params">(TestA testA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testA = testA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestA</span><span class="params">(TestA testA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testA = testA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用下面的测试类观测Bean创建情况，后面的都可以使用这个测试类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            TestA a = SpringUtils.getBean(TestA.class);</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            TestB b = SpringUtils.getBean(TestB.class);</span><br><span class="line">            System.out.println(b);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面的TestA和TestB我们运行后发现出现异常，Bean创建不成功，部分异常如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Caused by: org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name &apos;testA&apos;: Requested bean is currently in creation: Is there an unresolvable circular reference?</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="Bean都为prototype模式，都通过构造器注入"><a href="#Bean都为prototype模式，都通过构造器注入" class="headerlink" title="Bean都为prototype模式，都通过构造器注入"></a>Bean都为prototype模式，都通过构造器注入</h2><p>我们再看看把Bean改为prototype模式后如何。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(value = BeanDefinition.SCOPE_PROTOTYPE)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TestB testB;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestA</span><span class="params">(TestB testB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testB = testB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestB</span><span class="params">(TestB testB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testB = testB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Scope</span>(value = BeanDefinition.SCOPE_PROTOTYPE)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TestA testA;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestB</span><span class="params">(TestA testA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testA = testA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestA</span><span class="params">(TestA testA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testA = testA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过测试可以发现也是不成功的，抛出BeanCurrentlyInCreationException异常。</p><p>其实上面两个例子是比较好理解的，通过构造器注入，也就是Bean TestA在创建的时候就需要TestB，TestB在创建的时候就需要TestA，显然，Spring无法解决这种情况，我们也无法解决这种情况。</p><h2 id="Bean都为singleton模式，都通过Setter注入"><a href="#Bean都为singleton模式，都通过Setter注入" class="headerlink" title="Bean都为singleton模式，都通过Setter注入"></a>Bean都为singleton模式，都通过Setter注入</h2><p>我们再来看下这种情况，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(value = BeanDefinition.SCOPE_SINGLETON)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TestB testB;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestA</span><span class="params">(TestB testB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testB = testB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestB</span><span class="params">(TestB testB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testB = testB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Scope</span>(value = BeanDefinition.SCOPE_SINGLETON)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TestA testA;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestB</span><span class="params">(TestA testA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testA = testA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestA</span><span class="params">(TestA testA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testA = testA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们测试一下可以发现运行成功了，成功输出两个Bean对象信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.zwt.demo.circularreference.TestA@2cc04358</span><br><span class="line">com.zwt.demo.circularreference.TestB@68b58644</span><br></pre></td></tr></table></figure><p>其实这种情况也是比较好理解的：</p><ul><li>当Bean TestA创建的时候需要TestB，TestB会创建一个默认的使用无参构造器的Bean对象，此时TestB里的TestA为空，我们称为TestB（空）；</li><li>TestA使用TestB（空）完成依赖注入，生成Bean TestA；</li><li>TestA构造完成，其返回给TestB（空），这时候TestB里的TestA不在为空，TestB构造完成。</li></ul><p>其过程犹如如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.生成1个TestB对象</span></span><br><span class="line">    TestB testB = <span class="keyword">new</span> TestB();</span><br><span class="line">    <span class="comment">//2.将TestB注入到TestA</span></span><br><span class="line">    TestA testA = <span class="keyword">new</span> TestA();</span><br><span class="line">    testA.setTestB(testB);</span><br><span class="line">    <span class="comment">//3.将TestA注入到TestB</span></span><br><span class="line">    testB.setTestA(testA);</span><br><span class="line">    <span class="comment">//4.最后两者完成循环依赖</span></span><br><span class="line">    System.out.println(testA.getTestB());</span><br><span class="line">    System.out.println(testB.getTestA());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实可以看到最关键的还是TestA、TestB的无参构造函数，其实这个无参构造函数指的是无TestA或者TestB参与的构造函数，这样初始化实例时不涉及循环依赖类，而在创建成功后通过参数注入。</p><p>我们把上面TestA和TestB的无参构造函数删去，只保留有参构造，测试运行可以看到出现了BeanCurrentlyInCreationException异常。</p><h2 id="Bean都为prototype模式，都通过Setter注入"><a href="#Bean都为prototype模式，都通过Setter注入" class="headerlink" title="Bean都为prototype模式，都通过Setter注入"></a>Bean都为prototype模式，都通过Setter注入</h2><p>这种情况貌似也可以？？我们来看下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(value = BeanDefinition.SCOPE_PROTOTYPE)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TestB testB;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestA</span><span class="params">(TestB testB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testB = testB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestB</span><span class="params">(TestB testB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testB = testB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Scope</span>(value = BeanDefinition.SCOPE_PROTOTYPE)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TestA testA;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestB</span><span class="params">(TestA testA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testA = testA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestA</span><span class="params">(TestA testA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testA = testA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们测试后发现它也抛出BeanCurrentlyInCreationException异常，证明是不可以的。</p><p>这种情况如何理解呢？我先上段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    TestB testB1 = <span class="keyword">new</span> TestB();</span><br><span class="line">    TestA testA1 = <span class="keyword">new</span> TestA();</span><br><span class="line">    testA1.setTestB(testB);</span><br><span class="line">    testB1.setTestA(testA);</span><br><span class="line">    System.out.println(testA1.getTestB());</span><br><span class="line">    System.out.println(testB1.getTestA());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们明显看到上述代码是错的，明显不存在testB和testA对象，testA1和testB1如何set？</p><p>是的，Spring就是这样，对于prototype（多例）模式，它不会保存已经创建的TestA或者TestB对象的引用。</p><p>也就是在注入时，我们可以认为完成了若干个（多例）TestA，但是都是“半成品”（没有TestB的注入），这时候TestB（多例）创建，需要TestA，即使拿到TestA（空），也无法将创建好的TestB反作用于TestA（空），使其成为TestA。</p><p>我们来看下Spring相关源码。</p><p>我们在<code>AbstractBeanFactory</code>的<code>doGetBean</code>方法看起，如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-459.png" alt="upload successful"></p><p>可以看到拿Bean前会先检查单例Bean，如果拿到了<code>sharedInstance</code>并且参数为空，并判断这个Singleton是不是正在被创建中，如果是的话那么就存在循环引用，拿到的是个Bean“半成品”。</p><p>如果拿不到，它就是个多例，判断下是不是正在创建中，是的话就直接抛出异常了。</p><p>再来看下调用的<code>DefaultSingletonBeanRegistry</code>类的<code>getSingleton</code>方法。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-460.png" alt="upload successful"></p><p>可以看到这种Bean都会保存在一个叫<code>earlySingletonObjects</code>的<code>HashMap</code>里，如果没有就尝试去一个叫<code>singletonFactories</code>的<code>HashMap</code>里去获取。</p><p>然后可以看到这个<code>HashMap</code>的值是通过<code>addSingletonFactory</code>方法获得的。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-461.png" alt="upload successful"></p><p>继续跟踪可以看到放入条件：单例、允许循环依赖、当前Bean正在被创建，如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-462.png" alt="upload successful"></p><p>最后<code>getEarlyBeanReference</code>返回了一个比较特殊的Object。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-463.png" alt="upload successful"></p><p>我们也可以通过debug观察代码运行情况，这儿不再过多叙述。</p><h2 id="Bean一个为prototype模式，一个为singleton模式，都通过构造器注入"><a href="#Bean一个为prototype模式，一个为singleton模式，都通过构造器注入" class="headerlink" title="Bean一个为prototype模式，一个为singleton模式，都通过构造器注入"></a>Bean一个为prototype模式，一个为singleton模式，都通过构造器注入</h2><p>这个根据我们上面等判断应该是不可以的。我们看到代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(value = BeanDefinition.SCOPE_SINGLETON)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TestB testB;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestA</span><span class="params">(TestB testB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testB = testB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestB</span><span class="params">(TestB testB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testB = testB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Scope</span>(value = BeanDefinition.SCOPE_PROTOTYPE)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TestA testA;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestB</span><span class="params">(TestA testA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testA = testA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestA</span><span class="params">(TestA testA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testA = testA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以测试同样抛出异常，实际上如果循环依赖的Bean都是通过构造器注入的，那么无论如何都是创建不成功的，与Bean创建顺序和Bean类型没有任何关系。</p><h2 id="Bean一个为prototype模式，一个为singleton模式，都通过Setter注入"><a href="#Bean一个为prototype模式，一个为singleton模式，都通过Setter注入" class="headerlink" title="Bean一个为prototype模式，一个为singleton模式，都通过Setter注入"></a>Bean一个为prototype模式，一个为singleton模式，都通过Setter注入</h2><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(value = BeanDefinition.SCOPE_SINGLETON)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TestB testB;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestA</span><span class="params">(TestB testB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testB = testB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestB</span><span class="params">(TestB testB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testB = testB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Scope</span>(value = BeanDefinition.SCOPE_PROTOTYPE)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TestA testA;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestB</span><span class="params">(TestA testA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testA = testA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestA</span><span class="params">(TestA testA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testA = testA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.zwt.demo.circularreference.TestA@327ed9f5</span><br><span class="line">com.zwt.demo.circularreference.TestB@67594471</span><br></pre></td></tr></table></figure><p>我们可以看到这种情况下运行成功，TestA或者TestB有一个为Singleton的，通过参数注入，就能成功创建Bean。</p><h2 id="Bean一个为prototype模式，通过构造器注入，一个为singleton模式，通过Setter注入"><a href="#Bean一个为prototype模式，通过构造器注入，一个为singleton模式，通过Setter注入" class="headerlink" title="Bean一个为prototype模式，通过构造器注入，一个为singleton模式，通过Setter注入"></a>Bean一个为prototype模式，通过构造器注入，一个为singleton模式，通过Setter注入</h2><p>如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(value = BeanDefinition.SCOPE_SINGLETON)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TestB testB;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestA</span><span class="params">(TestB testB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testB = testB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestB</span><span class="params">(TestB testB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testB = testB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Scope</span>(value = BeanDefinition.SCOPE_PROTOTYPE)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TestA testA;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestB</span><span class="params">(TestA testA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testA = testA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestA</span><span class="params">(TestA testA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testA = testA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到运行成功，单例的TestA会先创建，名为TestA（空），然后创建TestB，使用了TestA（空），TestB创建成功后，TestA（空）里的testB被属性赋值。</p><h2 id="Bean一个为prototype模式，通过Setter注入，一个为singleton模式，通过构造器注入"><a href="#Bean一个为prototype模式，通过Setter注入，一个为singleton模式，通过构造器注入" class="headerlink" title="Bean一个为prototype模式，通过Setter注入，一个为singleton模式，通过构造器注入"></a>Bean一个为prototype模式，通过Setter注入，一个为singleton模式，通过构造器注入</h2><p>这种情况根据上面经验，应该是不可以的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(value = BeanDefinition.SCOPE_SINGLETON)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TestB testB;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestA</span><span class="params">(TestB testB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testB = testB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestB</span><span class="params">(TestB testB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testB = testB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Scope</span>(value = BeanDefinition.SCOPE_PROTOTYPE)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TestA testA;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestB</span><span class="params">(TestA testA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testA = testA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestA</span><span class="params">(TestA testA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testA = testA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们测试一下，确实也是不可以的，抛出BeanCurrentlyInCreationException异常。</p><p>这种情况可以认为TestA（单例）创建需要TestB，但是TestB是多例的，Spring中无法形成TestB的唯一引用作用于TestA（形成了TestB就是单例的了），也就无法创建TestA Bean。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面说了很多情况，我们简单总结下。</p><p>对于TestA和TestB两个类，如果存在循环依赖：</p><table><thead><tr><th>TestA</th><th>TestB</th><th>Spring创建结果</th></tr></thead><tbody><tr><td>Singleton模式<br>Constructor注入</td><td>Singleton模式<br>Constructor注入</td><td>失败</td></tr><tr><td>Prototype模式<br>Constructor注入</td><td>Prototype模式<br>Constructor注入</td><td>失败</td></tr><tr><td>Singleton模式<br>Setter注入</td><td>Singleton模式<br>Setter注入</td><td>成功</td></tr><tr><td>Prototype模式<br>Setter注入</td><td>Prototype模式<br>Setter注入</td><td>失败</td></tr><tr><td>Singleton模式<br>Constructor注入</td><td>Prototype模式<br>Constructor注入</td><td>失败</td></tr><tr><td>Prototype模式<br>Constructor注入</td><td>Singleton模式<br>Constructor注入</td><td>同上（失败）</td></tr><tr><td>Singleton模式<br>Setter注入</td><td>Prototype模式<br>Setter注入</td><td>成功</td></tr><tr><td>Prototype模式<br>Setter注入</td><td>Singleton模式<br>Setter注入</td><td>同上（成功）</td></tr><tr><td>Prototype模式<br>Constructor注入</td><td>Singleton模式<br>Setter注入</td><td>成功</td></tr><tr><td>Singleton模式<br>Setter注入</td><td>Prototype模式<br>Constructor注入</td><td>同上（成功）</td></tr><tr><td>Singleton模式<br>Constructor注入</td><td>Prototype模式<br>Setter注入</td><td>失败</td></tr><tr><td>Prototype模式<br>Setter注入</td><td>Singleton模式<br>Constructor注入</td><td>同上（失败）</td></tr></tbody></table><p>以上列举了所有情况，根据表格我们可以看出创建成功的，一定至少有一个Bean为Singleton模式且Setter注入。</p><p>这个结论也与我们刚才分析的一部分Spring源码是一致的，首先构造一个未完全初始化的Bean，这个Bean要求为单例的，而后通过实例化另一个循环依赖Bean，成功后通过Setter完成原来单例Bean的初始化。</p><p>以上就是Spring循环依赖的全部内容。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>搭建自己的Hexo博客（4）</title>
    <link href="https://www.sakuratears.top/blog/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2%EF%BC%884%EF%BC%89.html"/>
    <id>https://www.sakuratears.top/blog/搭建自己的Hexo博客（4）.html</id>
    <published>2019-07-31T14:37:00.000Z</published>
    <updated>2019-07-31T14:47:46.259Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>接 <a href="https://www.sakuratears.top/blog/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2%EF%BC%883%EF%BC%89.html">搭建自己的Hexo博客（3）</a>这篇文章，最近又对博客进行了一些简单优化，特地分享下。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="音乐问题"><a href="#音乐问题" class="headerlink" title="音乐问题"></a>音乐问题</h2><p>原来是直接使用的网易云音乐外链，考虑到音乐版权问题，可能以后外链失效影响到音乐播放。</p><p>故我将要使用的音乐文件迁移到了云服务器上，同时我们使用一款Hexo的音乐播放插件<code>hexo-tag-aplayer</code>。</p><p>我们直接在<code>package.json</code>文件里添加<code>hexo-tag-aplayer</code>并使用npm install命令进行安装。</p><p>在 <code>themes/next/layout/_custom/sidebar.swig</code>文件里，我们原来使用的网易云外链，注释掉。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--网易云音乐外链，已废弃--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=70 src="//music.163.com/outchain/player?type=2&amp;id=509313150&amp;auto=0&amp;height=66"&gt;&lt;/iframe&gt;</span></span><br><span class="line"><span class="comment">&lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=70 src="//music.163.com/outchain/player?type=2&amp;id=34723470&amp;auto=0&amp;height=66"&gt;&lt;/iframe&gt;</span></span><br><span class="line"><span class="comment">&lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=70 src="//music.163.com/outchain/player?type=2&amp;id=640866&amp;auto=0&amp;height=66"&gt;&lt;/iframe&gt;</span></span><br><span class="line"><span class="comment">&lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=70 src="//music.163.com/outchain/player?type=2&amp;id=35345243&amp;auto=0&amp;height=66"&gt;&lt;/iframe&gt;</span></span><br><span class="line"><span class="comment">&lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=70 src="//music.163.com/outchain/player?type=2&amp;id=512733081&amp;auto=0&amp;height=66"&gt;&lt;/iframe&gt;--&gt;</span></span><br></pre></td></tr></table></figure><p>使用如下Aplayer相关加载代码。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--基于hexo-tag-aplayer的音乐播放器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"aplayer-rWUYQYrx"</span> <span class="attr">class</span>=<span class="string">"aplayer aplayer-tag-marker"</span> <span class="attr">style</span>=<span class="string">"margin: 30px 0px 30px 0px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> options = &#123;</span></span><br><span class="line"><span class="javascript">    <span class="string">"narrow"</span>: <span class="literal">false</span>,<span class="comment">//样式</span></span></span><br><span class="line"><span class="javascript">    <span class="string">"autoplay"</span>: <span class="literal">false</span>,<span class="comment">//是否自动播放</span></span></span><br><span class="line"><span class="javascript">    <span class="string">"showlrc"</span>: <span class="number">0</span>,<span class="comment">//是否显示歌词，需要有歌词文件</span></span></span><br><span class="line"><span class="javascript">    <span class="string">"mutex"</span>: <span class="literal">true</span>,<span class="comment">//true的话播放时会暂停其它播放器</span></span></span><br><span class="line"><span class="javascript">    <span class="string">"theme"</span>: <span class="string">"#e6d0b2"</span>,<span class="comment">//主题</span></span></span><br><span class="line"><span class="javascript">    <span class="string">"preload"</span>: <span class="string">"none"</span>, <span class="comment">//预加载模式</span></span></span><br><span class="line"><span class="javascript">    <span class="string">"listmaxheight"</span>: <span class="string">"500px"</span>,<span class="comment">//列表最大高度</span></span></span><br><span class="line"><span class="javascript">    <span class="string">"music"</span>: [</span></span><br><span class="line"><span class="undefined">        &#123;</span></span><br><span class="line"><span class="javascript">            <span class="string">"title"</span>: <span class="string">"Sakura Tears"</span>,<span class="comment">//显示的音乐名</span></span></span><br><span class="line"><span class="javascript">            <span class="string">"author"</span>: <span class="string">"Nigel Silin"</span>,<span class="comment">//作家</span></span></span><br><span class="line"><span class="javascript">            <span class="string">"url"</span>: <span class="string">"http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/Nigel%20Silin%20-%20Sakura%20Tears.mp3"</span>,<span class="comment">//音乐文件路径</span></span></span><br><span class="line"><span class="javascript">            <span class="string">"pic"</span>: <span class="string">"http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/music1.jpeg"</span><span class="comment">//音乐图片</span></span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="undefined">        &#123;</span></span><br><span class="line"><span class="javascript">            <span class="string">"title"</span>: <span class="string">"东京不太热"</span>,</span></span><br><span class="line"><span class="javascript">            <span class="string">"author"</span>: <span class="string">"封茗囧菌"</span>,</span></span><br><span class="line"><span class="javascript">            <span class="string">"url"</span>: <span class="string">"http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/%E5%B0%81%E8%8C%97%E5%9B%A7%E8%8F%8C%20-%20%E4%B8%9C%E4%BA%AC%E4%B8%8D%E5%A4%AA%E7%83%AD.mp3"</span>,</span></span><br><span class="line"><span class="javascript">            <span class="string">"pic"</span>: <span class="string">"http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/music2.jpeg"</span></span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="undefined">        &#123;</span></span><br><span class="line"><span class="javascript">            <span class="string">"title"</span>: <span class="string">"春风吹"</span>,</span></span><br><span class="line"><span class="javascript">            <span class="string">"author"</span>: <span class="string">"锦零"</span>,</span></span><br><span class="line"><span class="javascript">            <span class="string">"url"</span>: <span class="string">"http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/%E9%94%A6%E9%9B%B6%20-%20%E6%98%A5%E9%A3%8E%E5%90%B9%EF%BC%88Cover%20%E6%96%B9%E5%A4%A7%E5%90%8C%EF%BC%89.mp3"</span>,</span></span><br><span class="line"><span class="javascript">            <span class="string">"pic"</span>: <span class="string">"http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/music3.jpeg"</span></span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="undefined">        &#123;</span></span><br><span class="line"><span class="javascript">            <span class="string">"title"</span>: <span class="string">"Secret"</span>,</span></span><br><span class="line"><span class="javascript">            <span class="string">"author"</span>: <span class="string">"茶太"</span>,</span></span><br><span class="line"><span class="javascript">            <span class="string">"url"</span>: <span class="string">"https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/%E8%8C%B6%E5%A4%AA%20-%20Secret.mp3"</span>,</span></span><br><span class="line"><span class="javascript">            <span class="string">"pic"</span>: <span class="string">"http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/music4.jpeg"</span></span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="undefined">        &#123;</span></span><br><span class="line"><span class="javascript">            <span class="string">"title"</span>: <span class="string">"secret base ~君がくれたもの~"</span>,</span></span><br><span class="line"><span class="javascript">            <span class="string">"author"</span>: <span class="string">"茅野愛衣,戸松遥,早見沙織"</span>,</span></span><br><span class="line"><span class="javascript">            <span class="string">"url"</span>: <span class="string">"https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/%E8%8C%85%E9%87%8E%E6%84%9B%E8%A1%A3%2C%E6%88%B8%E6%9D%BE%E9%81%A5%2C%E6%97%A9%E8%A6%8B%E6%B2%99%E7%B9%94%20-%20secret%20base%20%7E%E5%90%9B%E3%81%8B%E3%82%99%E3%81%8F%E3%82%8C%E3%81%9F%E3%82%82%E3%81%AE%7E%20%2810%20years%20after%20Ver.%29.mp3"</span>,</span></span><br><span class="line"><span class="javascript">            <span class="string">"pic"</span>: <span class="string">"http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/music5.jpeg"</span></span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="undefined">        &#123;</span></span><br><span class="line"><span class="javascript">            <span class="string">"title"</span>: <span class="string">"ファンファーレ"</span>,</span></span><br><span class="line"><span class="javascript">            <span class="string">"author"</span>: <span class="string">"sumika"</span>,</span></span><br><span class="line"><span class="javascript">            <span class="string">"url"</span>: <span class="string">"https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/sumika%20-%20%E3%83%95%E3%82%A1%E3%83%B3%E3%83%95%E3%82%A1%E3%83%BC%E3%83%AC.mp3"</span>,</span></span><br><span class="line"><span class="javascript">            <span class="string">"pic"</span>: <span class="string">"http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/music6.jpeg"</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    ]</span></span><br><span class="line"><span class="undefined">&#125;;</span></span><br><span class="line"><span class="javascript">    options.element = <span class="built_in">document</span>.getElementById(<span class="string">"aplayer-rWUYQYrx"</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> ap = <span class="keyword">new</span> APlayer(options);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.aplayers || (<span class="built_in">window</span>.aplayers = []);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.aplayers.push(ap);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样我们部署后会看到音乐栏如下图所示，也是比较美观的。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-458.png" alt="upload successful"></p><p>我们使用<code>hexo-tag-aplayer</code>还有一个好处，当我们想向一些文章里添加音乐时，只需在文章markdown文章中添加如下代码即可。</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% aplayer "Caffeine" "Jeff Williams" "caffeine.mp3" "picture.jpg" "lrc:caffeine.txt" %&#125;</span><br></pre></td></tr></table></figure><p><code>hexo-tag-aplayer</code>是基于APlayer而构建的，有兴趣的同学可以看下<a href="https://aplayer.js.org/#/" rel="external nofollow noopener noreferrer" target="_blank">APlayer</a>，一款非常漂亮的H5音乐播放器。</p><h2 id="相册问题"><a href="#相册问题" class="headerlink" title="相册问题"></a>相册问题</h2><p>上篇文章简单制作了一个相册，但是不是很满意，最近又对相册做了些优化。大致想法如下：</p><ul><li>相册页应该支持Tab切换，可以按照不同类别进行区分</li><li>原来瀑布流下拉加载有些问题，需要修复下</li><li>照片处理时手动操作步骤应该尽量少且简单</li></ul><p>根据以上问题，优化后的相册如下动图，可以看到更美观实用一些了。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-459.gif" alt="upload successful"></p><p>我简单把自己改动的代码分享下。</p><p>photo 文件夹下的<code>index.md</code>文件如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">"ImageGrid"</span> <span class="attr">class</span>=<span class="string">"photo-record"</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tab"</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tab-item active"</span>&gt;</span>动漫<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tab-item"</span>&gt;</span>风景<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tab-item"</span>&gt;</span>TODO<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"photoContent"</span>&gt;</span><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"img-box-ul1 mainCont selected"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"img-box-ul2 mainCont"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"img-box-ul3 mainCont"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"height:100px"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>样式如下，放在<code>custom.styl</code>里。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.photo-record</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.photo-record</span> <span class="selector-class">.tab</span>&#123;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>:<span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.photo-record</span> <span class="selector-class">.tab</span> <span class="selector-class">.tab-item</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>:inline-block;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">60px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>:center;</span><br><span class="line">  <span class="attribute">font-size</span>:<span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.photo-record</span> <span class="selector-class">.tab</span> <span class="selector-class">.tab-item</span><span class="selector-class">.active</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ff9a22</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">3px</span> solid <span class="number">#ffc472</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.photoContent</span> <span class="selector-class">.mainCont</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: auto;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.photoContent</span> <span class="selector-class">.mainCont</span><span class="selector-class">.selected</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>photos.js</code>的改动较大，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> photo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.page = <span class="number">1</span>,</span><br><span class="line">    <span class="keyword">this</span>.offset = <span class="number">10</span>,</span><br><span class="line">    <span class="keyword">this</span>.flag = <span class="literal">false</span>,</span><br><span class="line">    <span class="keyword">this</span>.init = <span class="function"><span class="keyword">function</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.flag) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.flag = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">      $.getJSON(<span class="string">"../js/src/photos.json"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (i + <span class="number">1</span> === index) &#123;</span><br><span class="line">            that.render(that.page, data[i], index);</span><br><span class="line">            that.scroll(data[i], index);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">this</span>.render = <span class="function"><span class="keyword">function</span>(<span class="params">page, data, index</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> begin = (page - <span class="number">1</span>) * <span class="keyword">this</span>.offset;</span><br><span class="line">      <span class="keyword">var</span> end = page * <span class="keyword">this</span>.offset;</span><br><span class="line">      <span class="keyword">if</span> (begin &gt;= data.length) <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">var</span> imgNameWithPattern, imgName, imageSize, imageX, imageY, li = <span class="string">""</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = begin; i &lt; end &amp;&amp; i &lt; data.length; i++) &#123;</span><br><span class="line">        imgNameWithPattern = data[i].split(<span class="string">' '</span>)[<span class="number">1</span>];</span><br><span class="line">        imgName = imgNameWithPattern.split(<span class="string">'.'</span>)[<span class="number">0</span>]</span><br><span class="line">        imageSize = data[i].split(<span class="string">' '</span>)[<span class="number">0</span>];</span><br><span class="line">        imageX = imageSize.split(<span class="string">'.'</span>)[<span class="number">0</span>];</span><br><span class="line">        imageY = imageSize.split(<span class="string">'.'</span>)[<span class="number">1</span>];</span><br><span class="line">        li += <span class="string">'&lt;div class="card" style="width:330px"&gt;'</span> +</span><br><span class="line">          <span class="string">'&lt;div class="img-box" style="height:'</span> + <span class="number">330</span> * imageY / imageX + <span class="string">'px"&gt;'</span> +</span><br><span class="line">          <span class="string">'&lt;a data-fancybox="gallery" class="fancybox fancybox.image" href="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/photos/'</span> + index + <span class="string">"/"</span> + imgNameWithPattern + <span class="string">'?raw=true" data-caption="'</span> + imgName + <span class="string">'"&gt;'</span> +</span><br><span class="line">          <span class="string">'&lt;img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/photos/'</span> + index + <span class="string">"/"</span> + imgNameWithPattern + <span class="string">'?raw=true"/&gt;'</span> +</span><br><span class="line">          <span class="string">'&lt;/a&gt;'</span> +</span><br><span class="line">          <span class="string">'&lt;/div&gt;'</span> +</span><br><span class="line">          <span class="string">'&lt;/div&gt;'</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">var</span> box = $(<span class="string">".img-box-ul"</span> + index);</span><br><span class="line">      box.append(li);</span><br><span class="line">      box.lazyload();</span><br><span class="line">      <span class="keyword">this</span>.minigrid(index);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">this</span>.minigrid = <span class="function"><span class="keyword">function</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> grid = <span class="keyword">new</span> Minigrid(&#123;</span><br><span class="line">        container: <span class="string">".img-box-ul"</span> + index,</span><br><span class="line">        item: <span class="string">'.card'</span>,</span><br><span class="line">        gutter: <span class="number">12</span></span><br><span class="line">      &#125;);</span><br><span class="line">      grid.mount();</span><br><span class="line">      <span class="comment">// $(window).resize(function() &#123;</span></span><br><span class="line">      <span class="comment">//   grid.mount();</span></span><br><span class="line">      <span class="comment">// &#125;);</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">this</span>.scroll = <span class="function"><span class="keyword">function</span>(<span class="params">data, index</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">      $(<span class="built_in">window</span>).scroll(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> windowPageYOffset = <span class="built_in">window</span>.pageYOffset;</span><br><span class="line">        <span class="keyword">var</span> windowPageYOffsetAddHeight = windowPageYOffset + <span class="built_in">window</span>.innerHeight;</span><br><span class="line">        <span class="keyword">var</span> sensitivity = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">var</span> grid = $(<span class="string">"#ImageGrid"</span>);</span><br><span class="line">        <span class="keyword">var</span> offsetTop = grid.offset().top + grid.height();</span><br><span class="line">        <span class="keyword">if</span> (offsetTop &gt;= windowPageYOffset &amp;&amp; offsetTop &lt; windowPageYOffsetAddHeight + sensitivity) &#123;</span><br><span class="line">          that.render(++that.page, data, index);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">".photo-record .tab .tab-item"</span>).each(<span class="function"><span class="keyword">function</span> (<span class="params">i,e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tempPhoto = <span class="keyword">new</span> photo();</span><br><span class="line">    $(e).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      $(<span class="keyword">this</span>).addClass(<span class="string">"active"</span>).siblings().removeClass(<span class="string">"active"</span>);</span><br><span class="line">      $(<span class="string">".photo-record .photoContent .mainCont"</span>).eq(i).addClass(<span class="string">"selected"</span>).siblings().removeClass(<span class="string">"selected"</span>);</span><br><span class="line">      tempPhoto.init(i + <span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  $(<span class="string">".photo-record .tab .tab-item.active"</span>).click();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>从上面的<code>photos.js</code>我们可以看到<code>photos.json</code>应该为下面这种格式。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">[</span><br><span class="line"><span class="string">"3200.2000 photo-1-10.jpg"</span>,</span><br><span class="line"><span class="string">"1920.1080 photo-1-1.jpg"</span>,</span><br><span class="line"><span class="string">"1920.1080 photo-1-12.jpg"</span>,</span><br><span class="line"><span class="string">"1920.1200 photo-1-11.jpg"</span>,</span><br><span class="line"><span class="string">"1920.1200 photo-1-13.jpg"</span>,</span><br><span class="line"><span class="string">"1920.1080 photo-1-14.jpg"</span>,</span><br><span class="line"><span class="string">"1920.1200 photo-1-16.jpg"</span>,</span><br><span class="line"><span class="string">"1920.1080 photo-1-15.jpg"</span>,</span><br><span class="line"><span class="string">"1920.1186 photo-1-18.jpg"</span>,</span><br><span class="line"><span class="string">"1920.1080 photo-1-19.jpg"</span>,</span><br><span class="line"><span class="string">"1920.1080 photo-1-17.jpg"</span>,</span><br><span class="line"><span class="string">"1024.610 photo-1-2.jpg"</span>,</span><br><span class="line"><span class="string">"3160.2560 photo-1-20.jpg"</span>,</span><br><span class="line"><span class="string">"2560.1440 photo-1-21.jpg"</span>,</span><br><span class="line"><span class="string">"1920.1080 photo-1-22.jpg"</span>,</span><br><span class="line"><span class="string">"3139.2203 photo-1-23.jpg"</span>,</span><br><span class="line"><span class="string">"1024.1024 photo-1-24.jpeg"</span>,</span><br><span class="line"><span class="string">"2200.1400 photo-1-3.jpg"</span>,</span><br><span class="line"><span class="string">"1200.750 photo-1-4.jpg"</span>,</span><br><span class="line"><span class="string">"3500.1898 photo-1-5.jpg"</span>,</span><br><span class="line"><span class="string">"1080.1920 photo-1-6.jpg"</span>,</span><br><span class="line"><span class="string">"1600.1120 photo-1-7.jpg"</span>,</span><br><span class="line"><span class="string">"1728.1080 photo-1-8.jpg"</span>,</span><br><span class="line"><span class="string">"1920.1080 photo-1-9.jpg"</span></span><br><span class="line">],</span><br><span class="line">[</span><br><span class="line"><span class="string">"3968.2976 photo-2-1.jpg"</span>,</span><br><span class="line"><span class="string">"2976.3968 photo-2-2.jpg"</span></span><br><span class="line">],</span><br><span class="line">[]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这就需要我们使用<code>photosTools.js</code>来进行生成了，原来的这个文件是不满足要求的，我们改造如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">const</span> sizeOf = <span class="built_in">require</span>(<span class="string">'image-size'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="string">"source/images_backup/photos"</span>;</span><br><span class="line"><span class="keyword">const</span> output = <span class="string">"themes/next/source/js/src/photos.json"</span>;</span><br><span class="line"><span class="keyword">var</span> dimensions;</span><br><span class="line">fs.readdir(path, <span class="function"><span class="keyword">function</span>(<span class="params">err, dirents</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dirents.length; i++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(dirents);</span><br><span class="line">        <span class="keyword">if</span>(dirents[i]===<span class="string">".DS_Store"</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fs.readdir(path + <span class="string">"/"</span> + dirents[i], <span class="function"><span class="keyword">function</span>(<span class="params">err, files</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(files);</span><br><span class="line">            <span class="keyword">let</span> tempArr = [];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; files.length; j++) &#123;</span><br><span class="line">                fs.stat(path + <span class="string">"/"</span> + dirents[i] + <span class="string">"/"</span> + files[j], <span class="function"><span class="keyword">function</span>(<span class="params">err, stats</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (!files[j].endsWith(<span class="string">".jpg"</span>) || files[j].endsWith(<span class="string">".jpeg"</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (stats.isFile()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (files[j].endsWith(<span class="string">".jpg"</span>) || files[j].endsWith(<span class="string">".jpeg"</span>) ||</span><br><span class="line">                            files[j].endsWith(<span class="string">".mp4"</span>) || files[j].endsWith(<span class="string">".png"</span>) || files[j].endsWith(<span class="string">".gif"</span>)) &#123;</span><br><span class="line">                            dimensions = sizeOf(path + <span class="string">"/"</span> + dirents[i] + <span class="string">"/"</span> + files[j]);</span><br><span class="line">                            <span class="built_in">console</span>.log(dimensions.width, dimensions.height);</span><br><span class="line">                            tempArr.push(dimensions.width + <span class="string">'.'</span> + dimensions.height + <span class="string">' '</span> + files[j]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            arr.push(tempArr);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (i === dirents.length - <span class="number">1</span>) &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                fs.writeFile(output, <span class="built_in">JSON</span>.stringify(arr, <span class="literal">null</span>, <span class="string">"\t"</span>), <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;);</span><br><span class="line">            &#125;, <span class="number">10000</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>同时原来的photos图片文件夹里，应该使用1，2，3…等文件夹，并将图片放入到这些文件夹中，至于1，2，3…和图片类型的对应关系，就需要自己配置就行了。</p><p>以上就是新的图片标签页面的一些设计。</p><p>可以看到我们创建了3个Tab页切换（如需更多，可以继续进行配置），每个Tab页对应一个photo对象，该对象会加载并渲染图片信息，每次加载10个，使用向下滚动我们可以加载更多，并使用fancbox美化图片样式。</p><p>由于需要知道图片宽高来美化图片样式，因此我们使用了NodeJs的fs和imagesize模块，用来读取文件并生成photos.json文件。</p><p>PS：弄完相册后，突然想到了视频相关的一些展示，这个在后面我会考虑美观等特性，考虑是否为博客添加视频功能，及添加的位置等一些要素。</p><h2 id="屏蔽相关"><a href="#屏蔽相关" class="headerlink" title="屏蔽相关"></a>屏蔽相关</h2><p>我们为博客添加一些屏蔽功能，先上代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 屏蔽f12 审查元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">document</span>.onkeydown = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.event)&#123;</span><br><span class="line">        <span class="keyword">var</span> e = <span class="built_in">window</span>.event;</span><br><span class="line">        <span class="keyword">if</span>(e.keyCode == <span class="number">123</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"禁用F12键"</span>);</span><br><span class="line">            e.keyCode=<span class="number">0</span>;</span><br><span class="line">            e.returnValue=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if(e.keyCode == 13) &#123;</span></span><br><span class="line">        <span class="comment">//     console.log("禁用Enter键");</span></span><br><span class="line">        <span class="comment">//     e.keyCode = 0;</span></span><br><span class="line">        <span class="comment">//     e.returnValue=false;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// if(e.keyCode == 8) &#123;</span></span><br><span class="line">        <span class="comment">//     console.log("禁用Backspace键");</span></span><br><span class="line">        <span class="comment">//     e.returnValue=false;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">var</span> ctrlKey = e.ctrlKey || e.metaKey;</span><br><span class="line">        <span class="keyword">var</span> shiftKey = e.shiftKey;</span><br><span class="line">        <span class="keyword">if</span>(ctrlKey &amp;&amp; shiftKey &amp;&amp; e.keyCode == <span class="number">73</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"禁用Ctrl+Shift+I键"</span>);</span><br><span class="line">            e.keyCode=<span class="number">0</span>;</span><br><span class="line">            e.returnValue=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 屏蔽右键菜单</span></span><br><span class="line"><span class="comment"> * @param event</span></span><br><span class="line"><span class="comment"> * @returns &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">document</span>.oncontextmenu = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.event)&#123;</span><br><span class="line">        event = <span class="built_in">window</span>.event;</span><br><span class="line">    &#125;<span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> the = event.srcElement;</span><br><span class="line">        <span class="keyword">if</span> (!((the.tagName == <span class="string">"INPUT"</span> &amp;&amp; the.type.toLowerCase() == <span class="string">"text"</span>) || the.tagName == <span class="string">"TEXTAREA"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (e)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 屏蔽粘贴</span></span><br><span class="line"><span class="comment"> * @param event</span></span><br><span class="line"><span class="comment"> * @returns &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">document</span>.onpaste = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.event)&#123;</span><br><span class="line">        event = <span class="built_in">window</span>.event;</span><br><span class="line">    &#125;<span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> the = event.srcElement;</span><br><span class="line">        <span class="keyword">if</span> (!((the.tagName == <span class="string">"INPUT"</span> &amp;&amp; the.type.toLowerCase() == <span class="string">"text"</span>) || the.tagName == <span class="string">"TEXTAREA"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (e)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 屏蔽复制</span></span><br><span class="line"><span class="comment"> * @param event</span></span><br><span class="line"><span class="comment"> * @returns &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">document</span>.oncopy = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.event)&#123;</span><br><span class="line">        event = <span class="built_in">window</span>.event;</span><br><span class="line">    &#125;<span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> the = event.srcElement;</span><br><span class="line">        <span class="keyword">if</span>(!((the.tagName == <span class="string">"INPUT"</span> &amp;&amp; the.type.toLowerCase() == <span class="string">"text"</span>) || the.tagName == <span class="string">"TEXTAREA"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (e)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 屏蔽剪切</span></span><br><span class="line"><span class="comment"> * @param event</span></span><br><span class="line"><span class="comment"> * @returns &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">document</span>.oncut = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.event)&#123;</span><br><span class="line">        event = <span class="built_in">window</span>.event;</span><br><span class="line">    &#125;<span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> the = event.srcElement;</span><br><span class="line">        <span class="keyword">if</span>(!((the.tagName == <span class="string">"INPUT"</span> &amp;&amp; the.type.toLowerCase() == <span class="string">"text"</span>) || the.tagName == <span class="string">"TEXTAREA"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (e)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 屏蔽选中</span></span><br><span class="line"><span class="comment"> * @param event</span></span><br><span class="line"><span class="comment"> * @returns &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">document</span>.onselectstart = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.event)&#123;</span><br><span class="line">        event = <span class="built_in">window</span>.event;</span><br><span class="line">    &#125;<span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> the = event.srcElement;</span><br><span class="line">        <span class="keyword">if</span> (!((the.tagName == <span class="string">"INPUT"</span> &amp;&amp; the.type.toLowerCase() == <span class="string">"text"</span>) || the.tagName == <span class="string">"TEXTAREA"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尝试阻止开发者模式</span></span><br><span class="line"><span class="comment"> * @type &#123;HTMLElement&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> fuck = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(fuck, <span class="string">'id'</span>, &#123;</span><br><span class="line">    get:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Hello World!"</span>);</span><br><span class="line">        location.href=<span class="string">"about:blank"</span>;</span><br><span class="line">        history.replaceState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(fuck);</span><br></pre></td></tr></table></figure><p>我们将上述代码引入到博客代码中，就会欣然发现：</p><p>在博客页面上：</p><ul><li>鼠标右键审查元素失效</li><li>F12失效，Chrome浏览器下<code>Ctrl+Shift+I</code>启动开发者模式快捷键失效</li><li>复制、粘贴、剪贴、鼠标选中元素失效</li><li>开发者模式和博客页面是无法共存的</li></ul><p>当然这并不能阻止大家获取到网站运行的代码，因为js、html或者图片等资源，一旦被加载到客户端，客户端就已经拿到代码了。</p><p>然而这仍然是有趣的一件事情。</p><p>我们这里主要就是监听一些键盘事件来对某些按键行为进行阻止，对于屏蔽了开发者模式，主要和<code>Object.defineProperty</code>这个属性相关，但这个属性一些低版本浏览器是不支持的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>今天到这里就差不多了，我们对博客进行了一些优化操作，及简单介绍了如何进行这些操作，接下来我仍将去探寻博客一些可以优化的地方。</p><p>我的博客地址：<a href="https://www.sakuratears.top">https://www.sakuratears.top</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="博客" scheme="https://www.sakuratears.top/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>关于.DS_Store文件的一些问题</title>
    <link href="https://www.sakuratears.top/blog/%E5%85%B3%E4%BA%8E-DS-Store%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98.html"/>
    <id>https://www.sakuratears.top/blog/关于-DS-Store文件的一些问题.html</id>
    <published>2019-07-27T14:40:00.000Z</published>
    <updated>2019-07-28T01:15:03.165Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前在Mac电脑上拷贝文件到Windows电脑时，文件夹里会额外多出文件，就是我们今天要说的.DS_Store文件，当时并没有在意。</p><p>昨天在写一个文件流读取功能时，解析一直出问题，后面发现是文件夹里多了.DS_Store文件，导致文件遍历解析出了些问题，过程我就不再详述。</p><p>因此也对这个.DS_Store文件产生了一些兴趣，特地分享记录下。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>.DS_Store，全称 Desktop Services Store，是Mac OS中保存文件夹自定义属性的隐藏文件，目的在于存储文件夹的自定义属性，例如文件图标位置、视图设置，或背景色等，相当于Windows下的 desktop.ini。.DS_Store 默认放在每个文件夹的下面。</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>当我们尝试用文本打开时可以发现它是乱码的，我们接下来尝试解读一下它。</p><p>我们使用Notepad++，在其 插件-插件管理 添加Hex-Editor插件，安装好此插件后Notepad++可以以十六进制形式打开指定文件。</p><p>我们使用Notepad++借助此插件可以打开.DS_Store，可以看到它的十六进制格式。</p><p>当然我们也可以使用VSCode，安装hexdump for vscode插件，来显示十六进制格式。</p><p>两种方式插件的安装过程略，有兴趣的可以查看相关文章等。</p><p>这儿我们使用VSCode结合插件来打开该文件，如下图，我们尝试解析一下该十六进制数据。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-454.png" alt="upload successful"><br><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-455.png" alt="upload successful"><br><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-456.png" alt="upload successful"></p><p>关于该文件二进制的结构说明我们可以参考这篇文章 <a href="http://dy.163.com/v2/article/detail/DD4ELAP40511CJ6O.html" rel="external nofollow noopener noreferrer" target="_blank">解析.DS_Store文件格式</a>。</p><p>.DS_Store文件转为二进制树后，根据上面这篇文章，它的结构大致如下：</p><ul><li>文件头部（Header）</li><li>根块<ul><li>偏移部分（Offsets）</li><li>内容表（Toc）</li><li>空闲表（FreeList）</li></ul></li></ul><p><strong>文件头部：</strong> 通常文件头部用来进行校验，判断这个文件是不是.DS_Store文件（详见代码readHeader方法）。</p><p><strong>偏移部分：</strong> 偏移部分记录了有关文件中树(叶)块的偏移量信息，这些块存储的都是目录的实际信息，如文件名。获得偏移量需要遍历这个树（详见代码readOffsets方法）。</p><p><strong>内容表：</strong> 在偏移部分结束后，内容表部分就会呈现出来。他通常存在只有一个名为DSDB的表,并且值为1。这个特殊的表通常引用了我们将要遍历的第一个块的ID（详见代码readTOC方法）。</p><p><strong>空闲表：</strong> 最后一部分是空闲表，也就是在树中还有哪些地方是没有使用的或者是空闲的模块（详见代码readFreelist方法）。</p><p>然后我们使用Java来解析下这个二进制结构数据。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataBlock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pos;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> debug;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an byte array of length from data at the given offset or pos.</span></span><br><span class="line"><span class="comment">     * If offset==0 (no offset is given) , pos will be increased by length.</span></span><br><span class="line"><span class="comment">     * Throws Exception if offset+length &gt; this.data.length</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Params</span>: [length, offset]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Return</span>: byte[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] offsetRead(<span class="keyword">int</span> length,<span class="keyword">int</span> offset)&#123;</span><br><span class="line">        <span class="keyword">int</span> offsetPosition;</span><br><span class="line">        <span class="keyword">if</span>(offset==<span class="number">0</span>)&#123;</span><br><span class="line">            offsetPosition = <span class="keyword">this</span>.pos;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            offsetPosition = offset;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.data.length &lt; offsetPosition +length)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Offset+Length &gt; this.data.length"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(offset==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.pos+=length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] value =<span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">        System.arraycopy(<span class="keyword">this</span>.data,offsetPosition,value,<span class="number">0</span>,length);</span><br><span class="line">        <span class="keyword">if</span>(debug)&#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"Reading: %s-%s =&gt; %s"</span>,offsetPosition, offsetPosition+length, value));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Increases pos by length without reading data!</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Params</span>: [length]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Return</span>: void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">skip</span><span class="params">(<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pos+=length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Extracts a file name from the current position.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Params</span>: []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Return</span>: java.lang.String</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readFileName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//The length of the file name in bytes.</span></span><br><span class="line">        <span class="keyword">int</span> length = ByteBuffer.wrap(offsetRead(<span class="number">4</span>,<span class="number">0</span>)).getInt();</span><br><span class="line">        <span class="comment">//The file name in UTF-16, which is two bytes per character.</span></span><br><span class="line">        String fileName = <span class="keyword">new</span> String(offsetRead(<span class="number">2</span> * length,<span class="number">0</span>), StandardCharsets.UTF_16BE);</span><br><span class="line">        <span class="comment">//A structure ID that I haven't found any use of.</span></span><br><span class="line">        <span class="keyword">int</span> structureId = ByteBuffer.wrap(offsetRead(<span class="number">4</span>,<span class="number">0</span>)).getInt();</span><br><span class="line">        <span class="comment">//Now read the structure type as a string of four characters and decode it to ascii.</span></span><br><span class="line">        String structureType = <span class="keyword">new</span> String(offsetRead(<span class="number">4</span>,<span class="number">0</span>), StandardCharsets.US_ASCII);</span><br><span class="line">        <span class="keyword">if</span>(debug)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Structure type "</span>+ structureType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//If we don't find a match, skip stays &lt; 0 and we will do some magic to find the right skip due to somehow broken .DS_Store files..</span></span><br><span class="line">        <span class="keyword">int</span> skip = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//Source: http://search.cpan.org/~wiml/Mac-Finder-DSStore/DSStoreFormat.pod</span></span><br><span class="line">        <span class="keyword">while</span> (skip &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(structureType.equals(<span class="string">"bool"</span>))&#123;</span><br><span class="line">                skip = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(structureType.equals(<span class="string">"type"</span>) || structureType.equals(<span class="string">"long"</span>)  || structureType.equals(<span class="string">"shor"</span>)</span><br><span class="line">            || structureType.equals(<span class="string">"fwsw"</span>) || structureType.equals(<span class="string">"fwvh"</span>) || structureType.equals(<span class="string">"icvt"</span>)</span><br><span class="line">            || structureType.equals(<span class="string">"lsvt"</span>) || structureType.equals(<span class="string">"vSrn"</span>) || structureType.equals(<span class="string">"vstl"</span>))&#123;</span><br><span class="line">                skip = <span class="number">4</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(structureType.equals(<span class="string">"comp"</span>) || structureType.equals(<span class="string">"dutc"</span>) || structureType.equals(<span class="string">"icgo"</span>)</span><br><span class="line">            || structureType.equals(<span class="string">"icsp"</span>) || structureType.equals(<span class="string">"logS"</span>) || structureType.equals(<span class="string">"lg1S"</span>)</span><br><span class="line">            || structureType.equals(<span class="string">"lssp"</span>) || structureType.equals(<span class="string">"modD"</span>) || structureType.equals(<span class="string">"moDD"</span>)</span><br><span class="line">            || structureType.equals(<span class="string">"phyS"</span>) || structureType.equals(<span class="string">"ph1S"</span>))&#123;</span><br><span class="line">                skip = <span class="number">8</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(structureType.equals(<span class="string">"blob"</span>))&#123;</span><br><span class="line">                skip = ByteBuffer.wrap(offsetRead(<span class="number">4</span>,<span class="number">0</span>)).getInt();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(structureType.equals(<span class="string">"ustr"</span>) || structureType.equals(<span class="string">"cmmt"</span>) || structureType.equals(<span class="string">"extn"</span>)</span><br><span class="line">            || structureType.equals(<span class="string">"GRP0"</span>))&#123;</span><br><span class="line">                skip = <span class="number">2</span> * ByteBuffer.wrap(offsetRead(<span class="number">4</span>,<span class="number">0</span>)).getInt();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(structureType.equals(<span class="string">"BKGD"</span>))&#123;</span><br><span class="line">                skip = <span class="number">12</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(structureType.equals(<span class="string">"ICVO"</span>) || structureType.equals(<span class="string">"LSVO"</span>) || structureType.equals(<span class="string">"dscl"</span>))&#123;</span><br><span class="line">                skip = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(structureType.equals(<span class="string">"Iloc"</span>) || structureType.equals(<span class="string">"fwi0"</span>))&#123;</span><br><span class="line">                skip = <span class="number">16</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(structureType.equals(<span class="string">"dilc"</span>))&#123;</span><br><span class="line">                skip = <span class="number">32</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(structureType.equals(<span class="string">"lsvo"</span>))&#123;</span><br><span class="line">                skip = <span class="number">76</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(structureType.equals(<span class="string">"icvo"</span>))&#123;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(structureType.equals(<span class="string">"info"</span>))&#123;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(skip &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//We somehow didn't find a matching type. Maybe this file name's length value is broken. Try to fix it!</span></span><br><span class="line">                <span class="comment">//This is a bit voodoo and probably not the nicest way. Beware, there by dragons!</span></span><br><span class="line">                <span class="keyword">if</span>(debug)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"Re-reading!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Rewind 8 bytes, so that we can re-read structure_id and structure_type</span></span><br><span class="line">                skip(-<span class="number">1</span> * <span class="number">2</span> * <span class="number">0x4</span>);</span><br><span class="line">                fileName = <span class="keyword">new</span> String(offsetRead(<span class="number">0x2</span>,<span class="number">0</span>), StandardCharsets.UTF_16BE);</span><br><span class="line">                <span class="comment">//re-read structure_id and structure_type</span></span><br><span class="line">                structureId = ByteBuffer.wrap(offsetRead(<span class="number">4</span>,<span class="number">0</span>)).getInt();</span><br><span class="line">                structureType = <span class="keyword">new</span> String(offsetRead(<span class="number">4</span>,<span class="number">0</span>), StandardCharsets.US_ASCII);</span><br><span class="line">                <span class="comment">//Look-ahead and check if we have  structure_type==Iloc followed by blob.</span></span><br><span class="line">                <span class="comment">//If so, we're interested in blob, not Iloc. Otherwise continue!</span></span><br><span class="line">                String futureStructureType = <span class="keyword">new</span> String(offsetRead(<span class="number">4</span>,<span class="keyword">this</span>.pos), StandardCharsets.US_ASCII);</span><br><span class="line">                <span class="keyword">if</span>(debug)&#123;</span><br><span class="line">                    System.out.println(String.format(<span class="string">"Re-read structure_id %s / structure_type %s"</span>,structureId, structureType));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((!structureType.equals(<span class="string">"blob"</span>)) &amp;&amp; (!futureStructureType.equals(<span class="string">"blob"</span>)))&#123;</span><br><span class="line">                    structureType = <span class="string">""</span>;</span><br><span class="line">                    <span class="keyword">if</span>(debug)&#123;</span><br><span class="line">                        System.out.println(<span class="string">"Forcing another round!"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Skip bytes until the next (file name) block</span></span><br><span class="line">        skip(skip);</span><br><span class="line">        <span class="keyword">if</span>(debug)&#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"Filename %s"</span>,fileName));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fileName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DataBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DataBlock</span><span class="params">(<span class="keyword">byte</span>[] data, <span class="keyword">int</span> pos, <span class="keyword">boolean</span> debug)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.pos = pos;</span><br><span class="line">        <span class="keyword">this</span>.debug = debug;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getData() &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPos</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPos</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pos = pos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDebug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> debug;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDebug</span><span class="params">(<span class="keyword">boolean</span> debug)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.debug = debug;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DS_Store</span> <span class="keyword">extends</span> <span class="title">DataBlock</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> debug;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DataBlock root;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; offsets;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Integer&gt; toc;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer,List&lt;Integer&gt;&gt; freeList;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructor of DS_Store</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Params</span>: [data, debug]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Return</span>:</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DS_Store</span><span class="params">(<span class="keyword">byte</span>[] data, <span class="keyword">boolean</span> debug)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(data,<span class="number">0</span>,debug);</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.debug = debug;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.debug = debug;</span><br><span class="line">        <span class="keyword">this</span>.root = readHeader();</span><br><span class="line">        <span class="keyword">this</span>.offsets = readOffsets();</span><br><span class="line">        <span class="keyword">this</span>.toc = readTOC();</span><br><span class="line">        <span class="keyword">this</span>.freeList = readFreelist();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Checks if this.data is actually a .DS_Store file by checking the magic bytes.</span></span><br><span class="line"><span class="comment">     * It returns the file's root block.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Params</span>: []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Return</span>: com.zwt.framework.utils.util.dsstore.DataBlock</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> DataBlock <span class="title">readHeader</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We read at least 32+4 bytes for the header!</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.data.length &lt; <span class="number">36</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Length of data is too short!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Check the magic bytes for .DS_Store</span></span><br><span class="line">        <span class="keyword">int</span> magic1 = ByteBuffer.wrap(<span class="keyword">this</span>.offsetRead(<span class="number">4</span>,<span class="number">0</span>)).getInt();</span><br><span class="line">        <span class="keyword">int</span> magic2 = ByteBuffer.wrap(<span class="keyword">this</span>.offsetRead(<span class="number">4</span>,<span class="number">0</span>)).getInt();</span><br><span class="line">        <span class="keyword">if</span>(magic1 != <span class="number">0x1</span> &amp;&amp; magic2 != <span class="number">0x42756431</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Magic byte 1 does not match!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// After the magic bytes, the offset follows two times with block's size in between.</span></span><br><span class="line">        <span class="comment">// Both offsets have to match and are the starting point of the root block</span></span><br><span class="line">        <span class="keyword">int</span> offset = ByteBuffer.wrap(<span class="keyword">this</span>.offsetRead(<span class="number">4</span>,<span class="number">0</span>)).getInt();</span><br><span class="line">        <span class="keyword">int</span> size = ByteBuffer.wrap(<span class="keyword">this</span>.offsetRead(<span class="number">4</span>,<span class="number">0</span>)).getInt();</span><br><span class="line">        <span class="keyword">int</span> offset2 = ByteBuffer.wrap(<span class="keyword">this</span>.offsetRead(<span class="number">4</span>,<span class="number">0</span>)).getInt();</span><br><span class="line">        <span class="keyword">if</span>(debug)&#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"Offset 1: %s"</span>,offset));</span><br><span class="line">            System.out.println(String.format(<span class="string">"Size: %s"</span>,size));</span><br><span class="line">            System.out.println(String.format(<span class="string">"Offset 2: %s"</span>,offset2));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(offset!=offset2)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Offsets do not match!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Skip 16 bytes of unknown data...</span></span><br><span class="line">        skip(<span class="number">4</span>*<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataBlock(<span class="keyword">this</span>.offsetRead(size, offset+<span class="number">4</span>),<span class="number">0</span>, <span class="keyword">this</span>.debug);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reads the offsets which follow the header</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Params</span>: []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Return</span>: java.util.List&lt;java.lang.Integer&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title">readOffsets</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> startPos = <span class="keyword">this</span>.root.getPos();</span><br><span class="line">        <span class="comment">// First get the number of offsets in this file.</span></span><br><span class="line">        <span class="keyword">int</span> count = ByteBuffer.wrap(<span class="keyword">this</span>.root.offsetRead(<span class="number">4</span>,<span class="number">0</span>)).getInt();</span><br><span class="line">        <span class="keyword">if</span>(debug)&#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"Offset count: %s"</span>,count));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Always appears to be zero!</span></span><br><span class="line">        <span class="keyword">this</span>.root.skip(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Iterate over the offsets and get the offset addresses.</span></span><br><span class="line">        List&lt;Integer&gt; offsets = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">            <span class="comment">// Address of the offset.</span></span><br><span class="line">            <span class="keyword">int</span> address = ByteBuffer.wrap(<span class="keyword">this</span>.root.offsetRead(<span class="number">4</span>,<span class="number">0</span>)).getInt();</span><br><span class="line">            <span class="keyword">if</span>(debug)&#123;</span><br><span class="line">                System.out.println(String.format(<span class="string">"Offset %s is %s"</span>,i, address));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (address == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// We're only interested in non-zero values</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            offsets.add(address);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Calculate the end of the address space (filled with zeroes) instead of dumbly reading zero values...</span></span><br><span class="line">        <span class="keyword">int</span> sectionEnd = startPos + (count / <span class="number">256</span> + <span class="number">1</span>) * <span class="number">256</span> * <span class="number">4</span> - count*<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Skip to the end of the section</span></span><br><span class="line">        <span class="keyword">this</span>.root.skip(sectionEnd);</span><br><span class="line">        <span class="keyword">if</span>(debug)&#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"Skipped %s to %s"</span>,(<span class="keyword">this</span>.root.getPos() + sectionEnd),<span class="keyword">this</span>.root.getPos()));</span><br><span class="line">            System.out.println(String.format(<span class="string">"Offsets: %s"</span>,offsets));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> offsets;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reads the table of contents (TOCs) from the file.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Params</span>: []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Return</span>: java.util.Map&lt;java.lang.String,java.lang.Integer&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Map&lt;String,Integer&gt; <span class="title">readTOC</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(debug)&#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"POS %s"</span>,<span class="keyword">this</span>.root.getPos()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// First get the number of ToC entries.</span></span><br><span class="line">        <span class="keyword">int</span> count = ByteBuffer.wrap(<span class="keyword">this</span>.root.offsetRead(<span class="number">4</span>,<span class="number">0</span>)).getInt();</span><br><span class="line">        <span class="keyword">if</span>(debug)&#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"Toc count: %s"</span>,count));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;String,Integer&gt; toc = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// Iterate over all ToCs</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">            <span class="comment">// Get the length of a ToC's name</span></span><br><span class="line">            <span class="keyword">int</span> tocLen = <span class="keyword">this</span>.root.offsetRead(<span class="number">1</span>,<span class="number">0</span>)[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">// Read the ToC's name</span></span><br><span class="line">            String tocName = <span class="keyword">new</span> String(<span class="keyword">this</span>.root.offsetRead(tocLen,<span class="number">0</span>), StandardCharsets.UTF_8);</span><br><span class="line">            <span class="comment">// Read the address (block id) in the data section</span></span><br><span class="line">            <span class="keyword">int</span> blockId = ByteBuffer.wrap(<span class="keyword">this</span>.root.offsetRead(<span class="number">4</span>,<span class="number">0</span>)).getInt();</span><br><span class="line">            <span class="comment">// Add all values to the dictionary</span></span><br><span class="line">            toc.put(tocName,blockId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(debug)&#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"Toc %s"</span>,toc));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> toc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Read the free list from the header.</span></span><br><span class="line"><span class="comment">     * The free list has n=0..31 buckets with the index 2^n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Params</span>: []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Return</span>: java.util.Map&lt;java.lang.Integer,java.util.List&lt;java.lang.Integer&gt;&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer,List&lt;Integer&gt;&gt; readFreelist()&#123;</span><br><span class="line">        Map&lt;Integer,List&lt;Integer&gt;&gt; freelist = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">            freelist.put(<span class="number">1</span>&lt;&lt;i,<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            <span class="comment">// Read the amount of blocks in the specific free list.</span></span><br><span class="line">            <span class="keyword">int</span> blkcount = ByteBuffer.wrap(<span class="keyword">this</span>.root.offsetRead(<span class="number">4</span>,<span class="number">0</span>)).getInt();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;blkcount;j++)&#123;</span><br><span class="line">                <span class="comment">// Read blkcount block offsets.</span></span><br><span class="line">                <span class="keyword">int</span> freeOffset = ByteBuffer.wrap(<span class="keyword">this</span>.root.offsetRead(<span class="number">4</span>,<span class="number">0</span>)).getInt();</span><br><span class="line">                freelist.get(<span class="number">1</span>&lt;&lt;i).add(freeOffset);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(debug)&#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"Freelist: %s"</span>,freelist));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> freelist;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create a DataBlock from a given block ID (e.g. from the ToC)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Params</span>: [blockId]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Return</span>: com.zwt.framework.utils.util.dsstore.DataBlock</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataBlock <span class="title">blockById</span><span class="params">(<span class="keyword">int</span> blockId)</span></span>&#123;</span><br><span class="line">        <span class="comment">// First check if the block_id is within the offsets range</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.offsets.size() &lt; blockId)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"BlockID out of range!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the address of the block</span></span><br><span class="line">        <span class="keyword">int</span> addr = <span class="keyword">this</span>.offsets.get(blockId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do some necessary bit operations to extract the offset and the size of the block.</span></span><br><span class="line">        <span class="comment">// The address without the last 5 bits is the offset in the file</span></span><br><span class="line">        <span class="keyword">int</span> offset = addr &gt;&gt; <span class="number">0x5</span> &lt;&lt; <span class="number">0x5</span>;</span><br><span class="line">        <span class="comment">//The address' last five bits are the block's size.</span></span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">1</span> &lt;&lt; (addr &amp; <span class="number">0x1f</span>);</span><br><span class="line">        <span class="keyword">if</span>(debug)&#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"New block: addr %s offset %s size %s"</span>,addr, offset + <span class="number">0x4</span>, size));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Return the new block</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataBlock(<span class="keyword">this</span>.offsetRead(size, offset + <span class="number">0x4</span>),<span class="number">0</span>, <span class="keyword">this</span>.debug);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Traverses a block identified by the given block_id and extracts the file names.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Params</span>: [blockId]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Return</span>: java.util.List&lt;java.lang.String&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">traverse</span><span class="params">(<span class="keyword">int</span> blockId)</span></span>&#123;</span><br><span class="line">        <span class="comment">// Get the responsible block by it's ID</span></span><br><span class="line">        DataBlock node = <span class="keyword">this</span>.blockById(blockId);</span><br><span class="line">        <span class="comment">// Extract the pointer to the next block</span></span><br><span class="line">        <span class="keyword">int</span> nextPointer =  ByteBuffer.wrap(node.offsetRead(<span class="number">4</span>,<span class="number">0</span>)).getInt();</span><br><span class="line">        <span class="comment">// Get the number of next blocks or records</span></span><br><span class="line">        <span class="keyword">int</span> count =  ByteBuffer.wrap(node.offsetRead(<span class="number">4</span>,<span class="number">0</span>)).getInt();</span><br><span class="line">        <span class="keyword">if</span>(debug)&#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"Next Ptr %s with %s "</span>,nextPointer,count));</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; filenames =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If a next_pointer exists (&gt;0), iterate through the next blocks recursively</span></span><br><span class="line">        <span class="comment">// If not, we extract all file names from the current block</span></span><br><span class="line">        <span class="keyword">if</span>(nextPointer &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">                <span class="comment">// Get the block_id for the next block</span></span><br><span class="line">                <span class="keyword">int</span> nextId =  ByteBuffer.wrap(node.offsetRead(<span class="number">4</span>,<span class="number">0</span>)).getInt();</span><br><span class="line">                <span class="keyword">if</span>(debug)&#123;</span><br><span class="line">                    System.out.println(String.format(<span class="string">"Child: %s"</span>,nextId));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Traverse it recursively</span></span><br><span class="line">                List&lt;String&gt;  files = <span class="keyword">this</span>.traverse(nextId);</span><br><span class="line">                filenames.addAll(files);</span><br><span class="line">                <span class="comment">// Also get the filename for the current block.</span></span><br><span class="line">                String filename = node.readFileName();</span><br><span class="line">                <span class="keyword">if</span>(debug)&#123;</span><br><span class="line">                    System.out.println(String.format(<span class="string">"Filename: %s"</span>, filename));</span><br><span class="line">                &#125;</span><br><span class="line">                filenames.add(filename);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Now that we traversed all childs of the next_pointer, traverse the pointer itself.</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Check if that is really necessary as the last child should be the current node... (or so?)</span></span><br><span class="line">            List&lt;String&gt; files = <span class="keyword">this</span>.traverse(nextPointer);</span><br><span class="line">            filenames.addAll(files);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// We're probably in a leaf node, so extract the file names.</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">                String f = node.readFileName();</span><br><span class="line">                filenames.add(f);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> filenames;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Traverse from the root block and extract all file names.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Params</span>: []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Return</span>: java.util.List&lt;java.lang.String&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">traverseRoot</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// Get the root block from the ToC 'DSDB'</span></span><br><span class="line">        DataBlock root = <span class="keyword">this</span>.blockById(<span class="keyword">this</span>.toc.get(<span class="string">"DSDB"</span>));</span><br><span class="line">        <span class="comment">// Read the following root block's ID, so that we can traverse it.</span></span><br><span class="line">        <span class="keyword">int</span> rootId =  ByteBuffer.wrap(root.offsetRead(<span class="number">4</span>,<span class="number">0</span>)).getInt();</span><br><span class="line">        <span class="keyword">if</span>(debug)&#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"Root-ID %s"</span>, rootId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Read other values that we might be useful, but we're not interested in... (at least right now)</span></span><br><span class="line">        <span class="keyword">int</span> internalBlockCount =  ByteBuffer.wrap(root.offsetRead(<span class="number">4</span>,<span class="number">0</span>)).getInt();</span><br><span class="line">        <span class="keyword">int</span> recordCount =  ByteBuffer.wrap(root.offsetRead(<span class="number">4</span>,<span class="number">0</span>)).getInt();</span><br><span class="line">        <span class="keyword">int</span> blockCount =  ByteBuffer.wrap(root.offsetRead(<span class="number">4</span>,<span class="number">0</span>)).getInt();</span><br><span class="line">        <span class="keyword">int</span> unknown =  ByteBuffer.wrap(root.offsetRead(<span class="number">4</span>,<span class="number">0</span>)).getInt();</span><br><span class="line">        <span class="comment">// traverse from the extracted root block id.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.traverse(rootId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DS_Store</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getData() &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDebug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> debug;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDebug</span><span class="params">(<span class="keyword">boolean</span> debug)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.debug = debug;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DS_StoreParser</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return bytes by reading .DS_Store File</span></span><br><span class="line"><span class="comment">     * Throw Exception if file not exist</span></span><br><span class="line"><span class="comment">     * Throw Exception if Reading Error</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Params</span>: [fileName]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Return</span>: byte[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] readFile(String fileName)&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(fileName);</span><br><span class="line">        <span class="keyword">if</span>((!file.exists())||(!file.isFile()))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">".DS_Store File not exist ！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">             ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream())&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = fis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> bos.toByteArray();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Reading .DS_Store File Error!"</span>+e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] data = readFile(<span class="string">"/Users/zhangwentong/Desktop/DS_Store/bak.DS_Store"</span>);</span><br><span class="line">        DS_Store store = <span class="keyword">new</span> DS_Store(data,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; files = store.traverseRoot();</span><br><span class="line">        System.out.println(<span class="string">"Count: "</span>+ files.size());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;files.size();i++)&#123;</span><br><span class="line">            System.out.println(files.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码过程较复杂，有兴趣的可以参考最后面的<strong>参考资料</strong>部分，先对.DS_Store文件结构有些了解，在看代码就比较容易了。</p><p>我们运行上述代码后会看到如下输出：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-457.png" alt="upload successful"></p><p>可以看到这里面包含着我们的一些文件目录信息等，这些文件信息时是当前目录下的所有文件信息。这就可能造成一些安全问题。</p><p>有什么安全问题呢？我们来看下。</p><h2 id="信息安全问题"><a href="#信息安全问题" class="headerlink" title="信息安全问题"></a>信息安全问题</h2><p>当这一文件上传到了web服务器时，往往会带来一定的危害。</p><p>它带来的危害是它包含的文件名。MacOs在几乎所有文件夹都创建了一个.DS_Store文件。</p><p>信息泄漏(敏感文件)问题：</p><blockquote><p>我们可以在<a href="https://en.internetwache.org/scanning-the-alexa-top-1m-for-ds-store-files-12-03-2018/" rel="external nofollow noopener noreferrer" target="_blank">https://en.internetwache.org/scanning-the-alexa-top-1m-for-ds-store-files-12-03-2018/</a> 这里查看。这篇文章涉及的Internetwache.org网站项目，对Alexa Top 1000的网站的根目录进行扫描，证明在有的网站中的确存在这一文件，导致信息泄漏。通过解析这一文件，他们发现了数据库备份，配置文件，以及一些缓存文件，甚至是密钥。</p></blockquote><p>产生这种情况的原因就是我们在Git合作中，将.DS_Store进行了上传，而后对项目进行了部署。</p><p>PS：需要说明的一个事实是，存储在.DS_Store文件中的文件名仅代表本地MacOS系统上的目录内容。这就意味着解析出来的文件列表中有些文件可能不存在于我们的服务器或者要查找的机器上。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>尽管这样，我们在使用MacOS系统传输文件或者上传文件时，还是要尽量避免该文件的产生。</p><p>这个文件除了会记录目录信息，我们在使用程序遍历文件读取时也可能遇到它引起的问题（如我开头所说），我们在版本协作时，也有可能产生由此文件产生的不必要的冲突问题等。</p><p>我们处理.DS_Store文件大概有以下一些方法。</p><ul><li><p>通常，在传输文件时，我们可以直接删除文件目录下的.DS_Store文件，如在MacOS上传输文件给Windows系统，这些.DS_Store文件就成了垃圾文件，对我们是毫无用处的。</p></li><li><p>对于提交给版本控制系统的文件，我们可以将.DS_Store文件加入到.gitignore文件中以达到忽略提交的目的。</p></li><li><p>如果我们想查询服务器（Linux）或者MacOS上有多少.DS_Store文件，可以使用下面的命令。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name <span class="string">'*.DS_Store'</span></span><br></pre></td></tr></table></figure><p>  如果要删除它们，可以使用下面的指令。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name <span class="string">'*.DS_Store'</span> -<span class="built_in">type</span> f -delete</span><br></pre></td></tr></table></figure><p>  上面的两个命令可以查询和删除当前目录下的.DS_Store文件。</p><p>  PS：在MacOS上删除后会影响到如文件图标位置等问题，需要注意。</p></li><li><p>我们也可以让.DS_Store文件不在MacOS外接设备上（U盘等）继续生成，如下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.desktopservices DSDontWriteNetworkStores -bool TRUE</span><br></pre></td></tr></table></figure><p>如果要开启外接设备继续生成.DS_Store文件，指令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.desktopservices DSDontWriteNetworkStores -bool FALSE</span><br></pre></td></tr></table></figure></li><li><p>如果想直接禁止.DS_Store在MacOS上生成，可以使用Asepsis。</p><p>Asepsis的工作原理是拦截所有.DS_Store文件的创建或写入，并将它们重定向到 /usr/local/.dscage。 这样 Finder 如常工作，且不会有这种无用文件污染文件系统。</p><p>不幸的是，在 OS X 10.11 El Capitan 发布之后，Apple 启用了 System Integrity Protection (SIP)，它会阻止 Asepsis 的安装和正常运行。Asepsis 的作者已经放弃了对它的后续支持，因为他不希望用户为了使用这个工具而禁用系统关键安全服务。</p><p>然而网上也有相关可以继续使用Asepsis的方法，如这篇文章<a href="https://www.jianshu.com/p/f83e85443c50" rel="external nofollow noopener noreferrer" target="_blank">禁止.DS_store生成</a>，有兴趣的可以看一看。</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>.DS_Store文件一般情况下是无用文件，也不会造成多大问题，但我们也应该对其存在提高警惕，尤其是在服务器上出现时，我是因为遇到了它造成的一个bug才决定研究下它，同时用程序解析一下锻炼自己，网上关于该文件的解析文章不算多，下面我把一些参考资料分享给大家，希望大家对其有更深的了解。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://metacpan.org/pod/distribution/Mac-Finder-DSStore/DSStoreFormat.pod" rel="external nofollow noopener noreferrer" target="_blank">DS_Store Format</a></li><li><a href="https://wiki.mozilla.org/DS_Store_File_Format" rel="external nofollow noopener noreferrer" target="_blank">DS_Store_File_Format</a></li><li><a href="https://digi.ninja/projects/fdb.php" rel="external nofollow noopener noreferrer" target="_blank">fdb.php</a></li><li><a href="http://dy.163.com/v2/article/detail/DD4ELAP40511CJ6O.html" rel="external nofollow noopener noreferrer" target="_blank">解析.DS_Store文件格式</a></li><li><a href="https://en.internetwache.org/scanning-the-alexa-top-1m-for-ds-store-files-12-03-2018/" rel="external nofollow noopener noreferrer" target="_blank">Scanning the Alexa Top 1M for .DS_Store files</a></li><li><a href="https://ponderthebits.com/2017/01/mac-dumpster-diving-identifying-deleted-file-references-in-the-trash-ds_store-files-part-1/" rel="external nofollow noopener noreferrer" target="_blank">mac-dumpster-diving-identifying-deleted-file-references-in-the-trash-ds_store-files-part-1</a></li><li><a href="https://ponderthebits.com/2017/02/mac-dumpster-diving-identifying-deleted-file-references-in-the-trash-ds_store-files-part-2/" rel="external nofollow noopener noreferrer" target="_blank">mac-dumpster-diving-identifying-deleted-file-references-in-the-trash-ds_store-files-part-2</a></li></ul><h1 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h1><p>上述代码地址： <a href="https://github.com/JavaZWT/framework-base/tree/master/framework-utils/src/main/java/com/zwt/framework/utils/util/dsstore" rel="external nofollow noopener noreferrer" target="_blank">GitHub .DS_Store Parser</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term=".DS_Store" scheme="https://www.sakuratears.top/tags/DS-Store/"/>
    
  </entry>
  
  <entry>
    <title>Redis功能文档（转）</title>
    <link href="https://www.sakuratears.top/blog/Redis%E5%8A%9F%E8%83%BD%E6%96%87%E6%A1%A3%EF%BC%88%E8%BD%AC%EF%BC%89.html"/>
    <id>https://www.sakuratears.top/blog/Redis功能文档（转）.html</id>
    <published>2019-07-21T01:59:52.000Z</published>
    <updated>2019-07-21T02:34:35.371Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文转载自 <a href="http://redisdoc.com/topic/index.html" rel="external nofollow noopener noreferrer" target="_blank">Redis命令参考-功能文档</a></p><h1 id="功能文档"><a href="#功能文档" class="headerlink" title="功能文档"></a>功能文档</h1><h2 id="Redis-集群规范"><a href="#Redis-集群规范" class="headerlink" title="Redis 集群规范"></a>Redis 集群规范</h2><h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>这个文档是正在开发中的 Redis 集群功能的规范（specification）文档， 文档分为两个部分：</p><ul><li>第一部分介绍目前已经在 unstable 分支中实现了的那些功能。</li><li>第二部分介绍目前仍未实现的那些功能。</li></ul><p>文档各个部分的内容可能会随着集群功能的设计修改而发生改变， 其中， 未实现功能发生修改的几率比已实现功能发生修改的几率要高。</p><p>这个规范包含了编写客户端库（client library）所需的全部知识， 不过请注意， 这里列出的一部分细节可能会在未来发生变化。</p><h4 id="什么是-Redis-集群？"><a href="#什么是-Redis-集群？" class="headerlink" title="什么是 Redis 集群？"></a>什么是 Redis 集群？</h4><p>Redis 集群是一个分布式（distributed）、容错（fault-tolerant）的 Redis 实现， 集群可以使用的功能是普通单机 Redis 所能使用的功能的一个子集（subset）。</p><p>Redis 集群中不存在中心（central）节点或者代理（proxy）节点， 集群的其中一个主要设计目标是达到线性可扩展性（linear scalability）。</p><p>Redis 集群为了保证一致性（consistency）而牺牲了一部分容错性： 系统会在保证对网络断线（net split）和节点失效（node failure）具有有限（limited）抵抗力的前提下， 尽可能地保持数据的一致性。</p><p><strong>Note</strong></p><pre><code>集群将节点失效视为网络断线的其中一种特殊情况。</code></pre><p>集群的容错功能是通过使用主节点（master）和从节点（slave）两种角色（role）的节点（node）来实现的：</p><ul><li>主节点和从节点使用完全相同的服务器实现， 它们的功能（functionally）也完全一样， 但从节点通常仅用于替换失效的主节点。</li><li>不过， 如果不需要保证“先写入，后读取”操作的一致性（read-after-write consistency）， 那么可以使用从节点来执行只读查询。</li></ul><h4 id="Redis-集群实现的功能子集"><a href="#Redis-集群实现的功能子集" class="headerlink" title="Redis 集群实现的功能子集"></a>Redis 集群实现的功能子集</h4><p>Redis 集群实现了单机 Redis 中， 所有处理单个数据库键的命令。</p><p>针对多个数据库键的复杂计算操作， 比如集合的并集操作、合集操作没有被实现， 那些理论上需要使用多个节点的多个数据库键才能完成的命令也没有被实现。</p><p>在将来， 用户也许可以通过 MIGRATE COPY 命令， 在集群的计算节点（computation node）中执行针对多个数据库键的只读操作， 但集群本身不会去实现那些需要将多个数据库键在多个节点中移来移去的复杂多键命令。</p><p>Redis 集群不像单机 Redis 那样支持多数据库功能， 集群只使用默认的 0 号数据库， 并且不能使用 SELECT index 命令。</p><h4 id="Redis-集群协议中的客户端和服务器"><a href="#Redis-集群协议中的客户端和服务器" class="headerlink" title="Redis 集群协议中的客户端和服务器"></a>Redis 集群协议中的客户端和服务器</h4><p>Redis 集群中的节点有以下责任：</p><ul><li>持有键值对数据。</li><li>记录集群的状态，包括键到正确节点的映射（mapping keys to right nodes）。</li><li>自动发现其他节点，识别工作不正常的节点，并在有需要时，在从节点中选举出新的主节点。</li></ul><p>为了执行以上列出的任务， 集群中的每个节点都与其他节点建立起了“集群连接（cluster bus）”， 该连接是一个 TCP 连接， 使用二进制协议进行通讯。</p><p>节点之间使用 Gossip 协议 来进行以下工作：</p><ul><li>传播（propagate）关于集群的信息，以此来发现新的节点。</li><li>向其他节点发送 PING 数据包，以此来检查目标节点是否正常运作。</li><li>在特定事件发生时，发送集群信息。</li></ul><p>除此之外， 集群连接还用于在集群中发布或订阅信息。</p><p>因为集群节点不能代理（proxy）命令请求， 所以客户端应该在节点返回 -MOVED 或者 -ASK 转向（redirection）错误时， 自行将命令请求转发至其他节点。</p><p>因为客户端可以自由地向集群中的任何一个节点发送命令请求， 并可以在有需要时， 根据转向错误所提供的信息， 将命令转发至正确的节点， 所以在理论上来说， 客户端是无须保存集群状态信息的。</p><p>不过， 如果客户端可以将键和节点之间的映射信息保存起来， 可以有效地减少可能出现的转向次数， 籍此提升命令执行的效率。</p><h4 id="键分布模型"><a href="#键分布模型" class="headerlink" title="键分布模型"></a>键分布模型</h4><p>Redis 集群的键空间被分割为 16384 个槽（slot）， 集群的最大节点数量也是 16384 个。</p><p><strong>Note</strong></p><pre><code>推荐的最大节点数量为 1000 个左右。</code></pre><p>每个主节点都负责处理 16384 个哈希槽的其中一部分。</p><p>当我们说一个集群处于“稳定”（stable）状态时， 指的是集群没有在执行重配置（reconfiguration）操作， 每个哈希槽都只由一个节点进行处理。</p><p><strong>Note</strong></p><pre><code>重配置指的是将某个/某些槽从一个节点移动到另一个节点。</code></pre><p><strong>Note</strong></p><pre><code>一个主节点可以有任意多个从节点， 这些从节点用于在主节点发生网络断线或者节点失效时， 对主节点进行替换。</code></pre><p>以下是负责将键映射到槽的算法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HASH_SLOT = CRC16(key) mod 16384</span><br></pre></td></tr></table></figure></p><p>以下是该算法所使用的参数：</p><ul><li>算法的名称: XMODEM (又称 ZMODEM 或者 CRC-16/ACORN)</li><li>结果的长度: 16 位</li><li>多项数（poly）: 1021 (也即是 x16 + x12 + x5 + 1)</li><li>初始化值: 0000</li><li>反射输入字节（Reflect Input byte）: False</li><li>发射输出 CRC （Reflect Output CRC）: False</li><li>用于 CRC 输出值的异或常量（Xor constant to output CRC）: 0000</li><li>该算法对于输入 “123456789” 的输出: 31C3</li></ul><p>附录 A 中给出了集群所使用的 CRC16 算法的实现。</p><p>CRC16 算法所产生的 16 位输出中的 14 位会被用到。</p><p>在我们的测试中， CRC16 算法可以很好地将各种不同类型的键平稳地分布到 16384 个槽里面。</p><h4 id="集群节点属性"><a href="#集群节点属性" class="headerlink" title="集群节点属性"></a>集群节点属性</h4><p>每个节点在集群中都有一个独一无二的 ID ， 该 ID 是一个十六进制表示的 160 位随机数， 在节点第一次启动时由 /dev/urandom 生成。</p><p>节点会将它的 ID 保存到配置文件， 只要这个配置文件不被删除， 节点就会一直沿用这个 ID 。</p><p>节点 ID 用于标识集群中的每个节点。 一个节点可以改变它的 IP 和端口号， 而不改变节点 ID 。 集群可以自动识别出 IP/端口号的变化， 并将这一信息通过 Gossip 协议广播给其他节点知道。</p><p>以下是每个节点都有的关联信息， 并且节点会将这些信息发送给其他节点：</p><ul><li>节点所使用的 IP 地址和 TCP 端口号。</li><li>节点的标志（flags）。</li><li>节点负责处理的哈希槽。</li><li>节点最近一次使用集群连接发送 PING 数据包（packet）的时间。</li><li>节点最近一次在回复中接收到 PONG 数据包的时间。</li><li>集群将该节点标记为下线的时间。</li><li>该节点的从节点数量。</li><li>如果该节点是从节点的话，那么它会记录主节点的节点 ID 。 如果这是一个主节点的话，那么主节点 ID 这一栏的值为 0000000 。</li></ul><p>以上信息的其中一部分可以通过向集群中的任意节点（主节点或者从节点都可以）发送 CLUSTER NODES 命令来获得。</p><p>以下是一个向集群中的主节点发送 CLUSTER NODES 命令的例子， 该集群由三个节点组成：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli cluster nodes</span><br><span class="line">d1861060fe6a534d42d8a19aeb36600e18785e04 :0 myself - 0 1318428930 connected 0-1364</span><br><span class="line">3886e65cc906bfd9b1f7e7bde468726a052d1dae 127.0.0.1:6380 master - 1318428930 1318428931 connected 1365-2729</span><br><span class="line">d289c575dcbc4bdd2931585fd4339089e461a27d 127.0.0.1:6381 master - 1318428931 1318428931 connected 2730-4095</span><br></pre></td></tr></table></figure></p><p>在上面列出的三行信息中， 从左到右的各个域分别是： 节点 ID ， IP 地址和端口号， 标志（flag）， 最后发送 PING 的时间， 最后接收 PONG 的时间， 连接状态， 节点负责处理的槽。</p><h4 id="节点握手（已实现）"><a href="#节点握手（已实现）" class="headerlink" title="节点握手（已实现）"></a>节点握手（已实现）</h4><p>节点总是应答（accept）来自集群连接端口的连接请求， 并对接收到的 PING 数据包进行回复， 即使这个 PING 数据包来自不可信的节点。</p><p>然而， 除了 PING 之外， 节点会拒绝其他所有并非来自集群节点的数据包。</p><p>要让一个节点承认另一个节点同属于一个集群， 只有以下两种方法：</p><ul><li>一个节点可以通过向另一个节点发送 MEET 信息， 来强制让接收信息的节点承认发送信息的节点为集群中的一份子。 一个节点仅在管理员显式地向它发送 CLUSTER MEET ip port 命令时， 才会向另一个节点发送 MEET 信息。</li><li>另外， 如果一个可信节点向另一个节点传播第三者节点的信息， 那么接收信息的那个节点也会将第三者节点识别为集群中的一份子。 也即是说， 如果 A 认识 B ， B 认识 C ， 并且 B 向 A 传播关于 C 的信息， 那么 A 也会将 C 识别为集群中的一份子， 并尝试连接 C 。</li></ul><p>这意味着如果我们将一个/一些新节点添加到一个集群中， 那么这个/这些新节点最终会和集群中已有的其他所有节点连接起来。</p><p>这说明只要管理员使用 CLUSTER MEET 命令显式地指定了可信关系， 集群就可以自动发现其他节点。</p><p>这种节点识别机制通过防止不同的 Redis 集群因为 IP 地址变更或者其他网络事件的发生而产生意料之外的联合（mix）， 从而使得集群更具健壮性。</p><p>当节点的网络连接断开时， 它会主动连接其他已知的节点。</p><h4 id="MOVED-转向"><a href="#MOVED-转向" class="headerlink" title="MOVED 转向"></a>MOVED 转向</h4><p>一个 Redis 客户端可以向集群中的任意节点（包括从节点）发送命令请求。 节点会对命令请求进行分析， 如果该命令是集群可以执行的命令， 那么节点会查找这个命令所要处理的键所在的槽。</p><p>如果要查找的哈希槽正好就由接收到命令的节点负责处理， 那么节点就直接执行这个命令。</p><p>另一方面， 如果所查找的槽不是由该节点处理的话， 节点将查看自身内部所保存的哈希槽到节点 ID 的映射记录， 并向客户端回复一个 MOVED 错误。</p><p>以下是一个 MOVED 错误的例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET x</span><br><span class="line"></span><br><span class="line">-MOVED 3999 127.0.0.1:6381</span><br></pre></td></tr></table></figure></p><p>错误信息包含键 x 所属的哈希槽 3999 ， 以及负责处理这个槽的节点的 IP 和端口号 127.0.0.1:6381 。 客户端需要根据这个 IP 和端口号， 向所属的节点重新发送一次 GET key 命令请求。</p><p>注意， 即使客户端在重新发送 GET key 命令之前， 等待了非常久的时间， 以至于集群又再次更改了配置， 使得节点 127.0.0.1:6381 已经不再处理槽 3999 ， 那么当客户端向节点 127.0.0.1:6381 发送 GET key 命令的时候， 节点将再次向客户端返回 MOVED 错误， 指示现在负责处理槽 3999 的节点。</p><p>虽然我们用 ID 来标识集群中的节点， 但是为了让客户端的转向操作尽可能地简单， 节点在 MOVED 错误中直接返回目标节点的 IP 和端口号， 而不是目标节点的 ID 。</p><p>虽然不是必须的， 但一个客户端应该记录（memorize）下“槽 3999 由节点 127.0.0.1:6381 负责处理“这一信息， 这样当再次有命令需要对槽 3999 执行时， 客户端就可以加快寻找正确节点的速度。</p><p>注意， 当集群处于稳定状态时， 所有客户端最终都会保存有一个哈希槽至节点的映射记录（map of hash slots to nodes）， 使得集群非常高效： 客户端可以直接向正确的节点发送命令请求， 无须转向、代理或者其他任何可能发生单点故障（single point failure）的实体（entiy）。</p><p>除了 MOVED 转向错误之外， 一个客户端还应该可以处理稍后介绍的 ASK 转向错误。</p><h4 id="集群在线重配置（live-reconfiguration）"><a href="#集群在线重配置（live-reconfiguration）" class="headerlink" title="集群在线重配置（live reconfiguration）"></a>集群在线重配置（live reconfiguration）</h4><p>Redis 集群支持在集群运行的过程中添加或者移除节点。</p><p>实际上， 节点的添加操作和节点的删除操作可以抽象成同一个操作， 那就是， 将哈希槽从一个节点移动到另一个节点：</p><ul><li>添加一个新节点到集群， 等于将其他已存在节点的槽移动到一个空白的新节点里面。</li><li>从集群中移除一个节点， 等于将被移除节点的所有槽移动到集群的其他节点上面去。</li></ul><p>因此， 实现 Redis 集群在线重配置的核心就是将槽从一个节点移动到另一个节点的能力。 因为一个哈希槽实际上就是一些键的集合， 所以 Redis 集群在重哈希（rehash）时真正要做的， 就是将一些键从一个节点移动到另一个节点。</p><p>要理解 Redis 集群如何将槽从一个节点移动到另一个节点， 我们需要对 CLUSTER 命令的各个子命令进行介绍， 这些命理负责管理集群节点的槽转换表（slots translation table）。</p><p>以下是 CLUSTER 命令可用的子命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER ADDSLOTS slot1 [slot2] ... [slotN]</span><br><span class="line">CLUSTER DELSLOTS slot1 [slot2] ... [slotN]</span><br><span class="line">CLUSTER SETSLOT slot NODE node</span><br><span class="line">CLUSTER SETSLOT slot MIGRATING node</span><br><span class="line">CLUSTER SETSLOT slot IMPORTING node</span><br></pre></td></tr></table></figure></p><p>最开头的两条命令 ADDSLOTS 和 DELSLOTS 分别用于向节点指派（assign）或者移除节点， 当槽被指派或者移除之后， 节点会将这一信息通过 Gossip 协议传播到整个集群。 ADDSLOTS 命令通常在新创建集群时， 作为一种快速地将各个槽指派给各个节点的手段来使用。</p><p>CLUSTER SETSLOT slot NODE node 子命令可以将指定的槽 slot 指派给节点 node 。</p><p>至于 CLUSTER SETSLOT slot MIGRATING node 命令和 CLUSTER SETSLOT slot IMPORTING node 命令， 前者用于将给定节点 node 中的槽 slot 迁移出节点， 而后者用于将给定槽 slot 导入到节点 node ：</p><ul><li><p>当一个槽被设置为 MIGRATING 状态时， 原来持有这个槽的节点仍然会继续接受关于这个槽的命令请求， 但只有命令所处理的键仍然存在于节点时， 节点才会处理这个命令请求。</p><p>  如果命令所使用的键不存在与该节点， 那么节点将向客户端返回一个 -ASK 转向（redirection）错误， 告知客户端， 要将命令请求发送到槽的迁移目标节点。</p></li><li><p>当一个槽被设置为 IMPORTING 状态时， 节点仅在接收到 ASKING 命令之后， 才会接受关于这个槽的命令请求。</p><p>  如果客户端没有向节点发送 ASKING 命令， 那么节点会使用 -MOVED 转向错误将命令请求转向至真正负责处理这个槽的节点。</p></li></ul><p>上面关于 MIGRATING 和 IMPORTING 的说明有些难懂， 让我们用一个实际的实例来说明一下。</p><p>假设现在， 我们有 A 和 B 两个节点， 并且我们想将槽 8 从节点 A 移动到节点 B ， 于是我们：</p><ul><li>向节点 B 发送命令 CLUSTER SETSLOT 8 IMPORTING A</li><li>向节点 A 发送命令 CLUSTER SETSLOT 8 MIGRATING B</li></ul><p>每当客户端向其他节点发送关于哈希槽 8 的命令请求时， 这些节点都会向客户端返回指向节点 A 的转向信息：</p><ul><li>如果命令要处理的键已经存在于槽 8 里面， 那么这个命令将由节点 A 处理。</li><li>如果命令要处理的键未存在于槽 8 里面（比如说，要向槽添加一个新的键）， 那么这个命令由节点 B 处理。</li></ul><p>这种机制将使得节点 A 不再创建关于槽 8 的任何新键。</p><p>与此同时， 一个特殊的客户端 redis-trib 以及 Redis 集群配置程序（configuration utility）会将节点 A 中槽 8 里面的键移动到节点 B 。</p><p>键的移动操作由以下两个命令执行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER GETKEYSINSLOT slot count</span><br></pre></td></tr></table></figure></p><p>上面的命令会让节点返回 count 个 slot 槽中的键， 对于命令所返回的每个键， redis-trib 都会向节点 A 发送一条 MIGRATE host port key destination-db timeout [COPY] [REPLACE] 命令， 该命令会将所指定的键原子地（atomic）从节点 A 移动到节点 B （在移动键期间，两个节点都会处于阻塞状态，以免出现竞争条件）。</p><p>以下为 MIGRATE host port key destination-db timeout [COPY] [REPLACE] 命令的运作原理：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MIGRATE target_host target_port key target_database id timeout</span><br></pre></td></tr></table></figure></p><p>执行 MIGRATE host port key destination-db timeout [COPY] [REPLACE] 命令的节点会连接到 target 节点， 并将序列化后的 key 数据发送给 target ， 一旦 target 返回 OK ， 节点就将自己的 key 从数据库中删除。</p><p>从一个外部客户端的视角来看， 在某个时间点上， 键 key 要么存在于节点 A ， 要么存在于节点 B ， 但不会同时存在于节点 A 和节点 B 。</p><p>因为 Redis 集群只使用 0 号数据库， 所以当 MIGRATE host port key destination-db timeout [COPY] [REPLACE] 命令被用于执行集群操作时， target_database 的值总是 0 。</p><p>target_database 参数的存在是为了让 MIGRATE host port key destination-db timeout [COPY] [REPLACE] 命令成为一个通用命令， 从而可以作用于集群以外的其他功能。</p><p>我们对 MIGRATE host port key destination-db timeout [COPY] [REPLACE] 命令做了优化， 使得它即使在传输包含多个元素的列表键这样的复杂数据时， 也可以保持高效。</p><p>不过， 尽管 MIGRATE host port key destination-db timeout [COPY] [REPLACE] 非常高效， 对一个键非常多、并且键的数据量非常大的集群来说， 集群重配置还是会占用大量的时间， 可能会导致集群没办法适应那些对于响应时间有严格要求的应用程序。</p><h4 id="ASK-转向"><a href="#ASK-转向" class="headerlink" title="ASK 转向"></a>ASK 转向</h4><p>在之前介绍 MOVED 转向的时候， 我们说除了 MOVED 转向之外， 还有另一种 ASK 转向。</p><p>当节点需要让一个客户端长期地（permanently）将针对某个槽的命令请求发送至另一个节点时， 节点向客户端返回 MOVED 转向。</p><p>另一方面， 当节点需要让客户端仅仅在下一个命令请求中转向至另一个节点时， 节点向客户端返回 ASK 转向。</p><p>比如说， 在我们上一节列举的槽 8 的例子中， 因为槽 8 所包含的各个键分散在节点 A 和节点 B 中， 所以当客户端在节点 A 中没找到某个键时， 它应该转向到节点 B 中去寻找， 但是这种转向应该仅仅影响一次命令查询， 而不是让客户端每次都直接去查找节点 B ： 在节点 A 所持有的属于槽 8 的键没有全部被迁移到节点 B 之前， 客户端应该先访问节点 A ， 然后再访问节点 B 。</p><p>因为这种转向只针对 16384 个槽中的其中一个槽， 所以转向对集群造成的性能损耗属于可接受的范围。</p><p>因为上述原因， 如果我们要在查找节点 A 之后， 继续查找节点 B ， 那么客户端在向节点 B 发送命令请求之前， 应该先发送一个 ASKING 命令， 否则这个针对带有 IMPORTING 状态的槽的命令请求将被节点 B 拒绝执行。</p><p>接收到客户端 ASKING 命令的节点将为客户端设置一个一次性的标志（flag）， 使得客户端可以执行一次针对 IMPORTING 状态的槽的命令请求。</p><p>从客户端的角度来看， ASK 转向的完整语义（semantics）如下：</p><ul><li>如果客户端接收到 ASK 转向， 那么将命令请求的发送对象调整为转向所指定的节点。</li><li>先发送一个 ASKING 命令，然后再发送真正的命令请求。</li><li>不必更新客户端所记录的槽 8 至节点的映射： 槽 8 应该仍然映射到节点 A ， 而不是节点 B 。</li></ul><p>一旦节点 A 针对槽 8 的迁移工作完成， 节点 A 在再次收到针对槽 8 的命令请求时， 就会向客户端返回 MOVED 转向， 将关于槽 8 的命令请求长期地转向到节点 B 。</p><p>注意， 即使客户端出现 Bug ， 过早地将槽 8 映射到了节点 B 上面， 但只要这个客户端不发送 ASKING 命令， 客户端发送命令请求的时候就会遇上 MOVED 错误， 并将它转向回节点 A 。</p><h4 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h4><h5 id="节点失效检测"><a href="#节点失效检测" class="headerlink" title="节点失效检测"></a>节点失效检测</h5><p>以下是节点失效检查的实现方法：</p><ul><li><p>当一个节点向另一个节点发送 PING 命令， 但是目标节点未能在给定的时限内返回 PING 命令的回复时， 那么发送命令的节点会将目标节点标记为 PFAIL （possible failure，可能已失效）。</p><p>等待 PING 命令回复的时限称为“节点超时时限（node timeout）”， 是一个节点选项（node-wise setting）。</p></li><li><p>每次当节点对其他节点发送 PING 命令的时候， 它都会随机地广播三个它所知道的节点的信息， 这些信息里面的其中一项就是说明节点是否已经被标记为 PFAIL 或者 FAIL 。</p></li><li><p>当节点接收到其他节点发来的信息时， 它会记下那些被其他节点标记为失效的节点。 这称为失效报告（failure report）。</p></li><li><p>如果节点已经将某个节点标记为 PFAIL ， 并且根据节点所收到的失效报告显式， 集群中的大部分其他主节点也认为那个节点进入了失效状态， 那么节点会将那个失效节点的状态标记为 FAIL 。</p></li><li><p>一旦某个节点被标记为 FAIL ， 关于这个节点已失效的信息就会被广播到整个集群， 所有接收到这条信息的节点都会将失效节点标记为 FAIL 。</p></li></ul><p>简单来说， 一个节点要将另一个节点标记为失效， 必须先询问其他节点的意见， 并且得到大部分主节点的同意才行。</p><p>因为过期的失效报告会被移除， 所以主节点要将某个节点标记为 FAIL 的话， 必须以最近接收到的失效报告作为根据。</p><p>在以下两种情况中， 节点的 FAIL 状态会被移除：</p><ul><li><p>如果被标记为 FAIL 的是从节点， 那么当这个节点重新上线时， FAIL 标记就会被移除。</p><p>保持（retaning）从节点的 FAIL 状态是没有意义的， 因为它不处理任何槽， 一个从节点是否处于 FAIL 状态， 决定了这个从节点在有需要时能否被提升为主节点。</p></li><li><p>如果一个主节点被打上 FAIL 标记之后， 经过了节点超时时限的四倍时间， 再加上十秒钟之后， 针对这个主节点的槽的故障转移操作仍未完成， 并且这个主节点已经重新上线的话， 那么移除对这个节点的 FAIL 标记。</p></li></ul><p>在第二种情况中， 如果故障转移未能顺利完成， 并且主节点重新上线， 那么集群就继续使用原来的主节点， 从而免去管理员介入的必要。</p><h5 id="集群状态检测（已部分实现）"><a href="#集群状态检测（已部分实现）" class="headerlink" title="集群状态检测（已部分实现）"></a>集群状态检测（已部分实现）</h5><p>每当集群发生配置变化时（可能是哈希槽更新，也可能是某个节点进入失效状态）， 集群中的每个节点都会对它所知道的节点进行扫描（scan）。</p><p>一旦配置处理完毕， 集群会进入以下两种状态的其中一种：</p><ul><li>FAIL ： 集群不能正常工作。 当集群中有某个节点进入失效状态时， 集群不能处理任何命令请求， 对于每个命令请求， 集群节点都返回错误回复。</li><li>OK ： 集群可以正常工作， 负责处理全部 16384 个槽的节点中， 没有一个节点被标记为 FAIL 状态。</li></ul><p>这说明即使集群中只有一部分哈希槽不能正常使用， 整个集群也会停止处理任何命令。</p><p>不过节点从出现问题到被标记为 FAIL 状态的这段时间里， 集群仍然会正常运作， 所以集群在某些时候， 仍然有可能只能处理针对 16384 个槽的其中一个子集的命令请求。</p><p>以下是集群进入 FAIL 状态的两种情况：</p><ol><li>至少有一个哈希槽不可用，因为负责处理这个槽的节点进入了 FAIL 状态。</li><li>集群中的大部分主节点都进入下线状态。当大部分主节点都进入 PFAIL 状态时，集群也会进入 FAIL 状态。</li></ol><p>第二个检查是必须的， 因为要将一个节点从 PFAIL 状态改变为 FAIL 状态， 必须要有大部分主节点进行投票表决， 但是， 当集群中的大部分主节点都进入失效状态时， 单凭一个两个节点是没有办法将一个节点标记为 FAIL 状态的。</p><p>因此， 有了第二个检查条件， 只要集群中的大部分主节点进入了下线状态， 那么集群就可以在不请求这些主节点的意见下， 将某个节点判断为 FAIL 状态， 从而让整个集群停止处理命令请求。</p><h5 id="从节点选举"><a href="#从节点选举" class="headerlink" title="从节点选举"></a>从节点选举</h5><p>一旦某个主节点进入 FAIL 状态， 如果这个主节点有一个或多个从节点存在， 那么其中一个从节点会被升级为新的主节点， 而其他从节点则会开始对这个新的主节点进行复制。</p><p>新的主节点由已下线主节点属下的所有从节点中自行选举产生， 以下是选举的条件：</p><ul><li>这个节点是已下线主节点的从节点。</li><li>已下线主节点负责处理的槽数量非空。</li><li>从节点的数据被认为是可靠的， 也即是， 主从节点之间的复制连接（replication link）的断线时长不能超过节点超时时限（node timeout）乘以 REDIS_CLUSTER_SLAVE_VALIDITY_MULT 常量得出的积。</li></ul><p>如果一个从节点满足了以上的所有条件， 那么这个从节点将向集群中的其他主节点发送授权请求， 询问它们， 是否允许自己（从节点）升级为新的主节点。</p><p>如果发送授权请求的从节点满足以下属性， 那么主节点将向从节点返回 FAILOVER_AUTH_GRANTED 授权， 同意从节点的升级要求：</p><ul><li>发送授权请求的是一个从节点， 并且它所属的主节点处于 FAIL 状态。</li><li>在已下线主节点的所有从节点中， 这个从节点的节点 ID 在排序中是最小的。</li><li>这个从节点处于正常的运行状态： 它没有被标记为 FAIL 状态， 也没有被标记为 PFAIL 状态。</li></ul><p>一旦某个从节点在给定的时限内得到大部分主节点的授权， 它就会开始执行以下故障转移操作：</p><ul><li>通过 PONG 数据包（packet）告知其他节点， 这个节点现在是主节点了。</li><li>通过 PONG 数据包告知其他节点， 这个节点是一个已升级的从节点（promoted slave）。</li><li>接管（claiming）所有由已下线主节点负责处理的哈希槽。</li><li>显式地向所有节点广播一个 PONG 数据包， 加速其他节点识别这个节点的进度， 而不是等待定时的 PING / PONG 数据包。</li></ul><p>所有其他节点都会根据新的主节点对配置进行相应的更新，特别地：</p><ul><li>所有被新的主节点接管的槽会被更新。</li><li>已下线主节点的所有从节点会察觉到 PROMOTED 标志， 并开始对新的主节点进行复制。</li><li>如果已下线的主节点重新回到上线状态， 那么它会察觉到 PROMOTED 标志， 并将自身调整为现任主节点的从节点。</li></ul><p>在集群的生命周期中， 如果一个带有 PROMOTED 标识的主节点因为某些原因转变成了从节点， 那么该节点将丢失它所带有的 PROMOTED 标识。</p><h4 id="发布-订阅（已实现，但仍然需要改善）"><a href="#发布-订阅（已实现，但仍然需要改善）" class="headerlink" title="发布/订阅（已实现，但仍然需要改善）"></a>发布/订阅（已实现，但仍然需要改善）</h4><p>在一个 Redis 集群中， 客户端可以订阅任意一个节点， 也可以向任意一个节点发送信息， 节点会对客户端所发送的信息进行转发。</p><p>在目前的实现中， 节点会将接收到的信息广播至集群中的其他所有节点， 在将来的实现中， 可能会使用 bloom filter 或者其他算法来优化这一操作。</p><h4 id="附录-A：-CRC16-算法的-ANSI-实现参考"><a href="#附录-A：-CRC16-算法的-ANSI-实现参考" class="headerlink" title="附录 A： CRC16 算法的 ANSI 实现参考"></a>附录 A： CRC16 算法的 ANSI 实现参考</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright 2001-2010 Georges Menie (www.menie.org)</span></span><br><span class="line"><span class="comment"> * Copyright 2010 Salvatore Sanfilippo (adapted to Redis coding style)</span></span><br><span class="line"><span class="comment"> * All rights reserved.</span></span><br><span class="line"><span class="comment"> * Redistribution and use in source and binary forms, with or without</span></span><br><span class="line"><span class="comment"> * modification, are permitted provided that the following conditions are met:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     * Redistributions of source code must retain the above copyright</span></span><br><span class="line"><span class="comment"> *       notice, this list of conditions and the following disclaimer.</span></span><br><span class="line"><span class="comment"> *     * Redistributions in binary form must reproduce the above copyright</span></span><br><span class="line"><span class="comment"> *       notice, this list of conditions and the following disclaimer in the</span></span><br><span class="line"><span class="comment"> *       documentation and/or other materials provided with the distribution.</span></span><br><span class="line"><span class="comment"> *     * Neither the name of the University of California, Berkeley nor the</span></span><br><span class="line"><span class="comment"> *       names of its contributors may be used to endorse or promote products</span></span><br><span class="line"><span class="comment"> *       derived from this software without specific prior written permission.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY</span></span><br><span class="line"><span class="comment"> * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED</span></span><br><span class="line"><span class="comment"> * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span></span><br><span class="line"><span class="comment"> * DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY</span></span><br><span class="line"><span class="comment"> * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES</span></span><br><span class="line"><span class="comment"> * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;</span></span><br><span class="line"><span class="comment"> * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND</span></span><br><span class="line"><span class="comment"> * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span></span><br><span class="line"><span class="comment"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS</span></span><br><span class="line"><span class="comment"> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* CRC16 implementation acording to CCITT standards.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note by @antirez: this is actually the XMODEM CRC 16 algorithm, using the</span></span><br><span class="line"><span class="comment"> * following parameters:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Name                       : "XMODEM", also known as "ZMODEM", "CRC-16/ACORN"</span></span><br><span class="line"><span class="comment"> * Width                      : 16 bit</span></span><br><span class="line"><span class="comment"> * Poly                       : 1021 (That is actually x^16 + x^12 + x^5 + 1)</span></span><br><span class="line"><span class="comment"> * Initialization             : 0000</span></span><br><span class="line"><span class="comment"> * Reflect Input byte         : False</span></span><br><span class="line"><span class="comment"> * Reflect Output CRC         : False</span></span><br><span class="line"><span class="comment"> * Xor constant to output CRC : 0000</span></span><br><span class="line"><span class="comment"> * Output for "123456789"     : 31C3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint16_t</span> crc16tab[<span class="number">256</span>]= &#123;</span><br><span class="line">    <span class="number">0x0000</span>,<span class="number">0x1021</span>,<span class="number">0x2042</span>,<span class="number">0x3063</span>,<span class="number">0x4084</span>,<span class="number">0x50a5</span>,<span class="number">0x60c6</span>,<span class="number">0x70e7</span>,</span><br><span class="line">    <span class="number">0x8108</span>,<span class="number">0x9129</span>,<span class="number">0xa14a</span>,<span class="number">0xb16b</span>,<span class="number">0xc18c</span>,<span class="number">0xd1ad</span>,<span class="number">0xe1ce</span>,<span class="number">0xf1ef</span>,</span><br><span class="line">    <span class="number">0x1231</span>,<span class="number">0x0210</span>,<span class="number">0x3273</span>,<span class="number">0x2252</span>,<span class="number">0x52b5</span>,<span class="number">0x4294</span>,<span class="number">0x72f7</span>,<span class="number">0x62d6</span>,</span><br><span class="line">    <span class="number">0x9339</span>,<span class="number">0x8318</span>,<span class="number">0xb37b</span>,<span class="number">0xa35a</span>,<span class="number">0xd3bd</span>,<span class="number">0xc39c</span>,<span class="number">0xf3ff</span>,<span class="number">0xe3de</span>,</span><br><span class="line">    <span class="number">0x2462</span>,<span class="number">0x3443</span>,<span class="number">0x0420</span>,<span class="number">0x1401</span>,<span class="number">0x64e6</span>,<span class="number">0x74c7</span>,<span class="number">0x44a4</span>,<span class="number">0x5485</span>,</span><br><span class="line">    <span class="number">0xa56a</span>,<span class="number">0xb54b</span>,<span class="number">0x8528</span>,<span class="number">0x9509</span>,<span class="number">0xe5ee</span>,<span class="number">0xf5cf</span>,<span class="number">0xc5ac</span>,<span class="number">0xd58d</span>,</span><br><span class="line">    <span class="number">0x3653</span>,<span class="number">0x2672</span>,<span class="number">0x1611</span>,<span class="number">0x0630</span>,<span class="number">0x76d7</span>,<span class="number">0x66f6</span>,<span class="number">0x5695</span>,<span class="number">0x46b4</span>,</span><br><span class="line">    <span class="number">0xb75b</span>,<span class="number">0xa77a</span>,<span class="number">0x9719</span>,<span class="number">0x8738</span>,<span class="number">0xf7df</span>,<span class="number">0xe7fe</span>,<span class="number">0xd79d</span>,<span class="number">0xc7bc</span>,</span><br><span class="line">    <span class="number">0x48c4</span>,<span class="number">0x58e5</span>,<span class="number">0x6886</span>,<span class="number">0x78a7</span>,<span class="number">0x0840</span>,<span class="number">0x1861</span>,<span class="number">0x2802</span>,<span class="number">0x3823</span>,</span><br><span class="line">    <span class="number">0xc9cc</span>,<span class="number">0xd9ed</span>,<span class="number">0xe98e</span>,<span class="number">0xf9af</span>,<span class="number">0x8948</span>,<span class="number">0x9969</span>,<span class="number">0xa90a</span>,<span class="number">0xb92b</span>,</span><br><span class="line">    <span class="number">0x5af5</span>,<span class="number">0x4ad4</span>,<span class="number">0x7ab7</span>,<span class="number">0x6a96</span>,<span class="number">0x1a71</span>,<span class="number">0x0a50</span>,<span class="number">0x3a33</span>,<span class="number">0x2a12</span>,</span><br><span class="line">    <span class="number">0xdbfd</span>,<span class="number">0xcbdc</span>,<span class="number">0xfbbf</span>,<span class="number">0xeb9e</span>,<span class="number">0x9b79</span>,<span class="number">0x8b58</span>,<span class="number">0xbb3b</span>,<span class="number">0xab1a</span>,</span><br><span class="line">    <span class="number">0x6ca6</span>,<span class="number">0x7c87</span>,<span class="number">0x4ce4</span>,<span class="number">0x5cc5</span>,<span class="number">0x2c22</span>,<span class="number">0x3c03</span>,<span class="number">0x0c60</span>,<span class="number">0x1c41</span>,</span><br><span class="line">    <span class="number">0xedae</span>,<span class="number">0xfd8f</span>,<span class="number">0xcdec</span>,<span class="number">0xddcd</span>,<span class="number">0xad2a</span>,<span class="number">0xbd0b</span>,<span class="number">0x8d68</span>,<span class="number">0x9d49</span>,</span><br><span class="line">    <span class="number">0x7e97</span>,<span class="number">0x6eb6</span>,<span class="number">0x5ed5</span>,<span class="number">0x4ef4</span>,<span class="number">0x3e13</span>,<span class="number">0x2e32</span>,<span class="number">0x1e51</span>,<span class="number">0x0e70</span>,</span><br><span class="line">    <span class="number">0xff9f</span>,<span class="number">0xefbe</span>,<span class="number">0xdfdd</span>,<span class="number">0xcffc</span>,<span class="number">0xbf1b</span>,<span class="number">0xaf3a</span>,<span class="number">0x9f59</span>,<span class="number">0x8f78</span>,</span><br><span class="line">    <span class="number">0x9188</span>,<span class="number">0x81a9</span>,<span class="number">0xb1ca</span>,<span class="number">0xa1eb</span>,<span class="number">0xd10c</span>,<span class="number">0xc12d</span>,<span class="number">0xf14e</span>,<span class="number">0xe16f</span>,</span><br><span class="line">    <span class="number">0x1080</span>,<span class="number">0x00a1</span>,<span class="number">0x30c2</span>,<span class="number">0x20e3</span>,<span class="number">0x5004</span>,<span class="number">0x4025</span>,<span class="number">0x7046</span>,<span class="number">0x6067</span>,</span><br><span class="line">    <span class="number">0x83b9</span>,<span class="number">0x9398</span>,<span class="number">0xa3fb</span>,<span class="number">0xb3da</span>,<span class="number">0xc33d</span>,<span class="number">0xd31c</span>,<span class="number">0xe37f</span>,<span class="number">0xf35e</span>,</span><br><span class="line">    <span class="number">0x02b1</span>,<span class="number">0x1290</span>,<span class="number">0x22f3</span>,<span class="number">0x32d2</span>,<span class="number">0x4235</span>,<span class="number">0x5214</span>,<span class="number">0x6277</span>,<span class="number">0x7256</span>,</span><br><span class="line">    <span class="number">0xb5ea</span>,<span class="number">0xa5cb</span>,<span class="number">0x95a8</span>,<span class="number">0x8589</span>,<span class="number">0xf56e</span>,<span class="number">0xe54f</span>,<span class="number">0xd52c</span>,<span class="number">0xc50d</span>,</span><br><span class="line">    <span class="number">0x34e2</span>,<span class="number">0x24c3</span>,<span class="number">0x14a0</span>,<span class="number">0x0481</span>,<span class="number">0x7466</span>,<span class="number">0x6447</span>,<span class="number">0x5424</span>,<span class="number">0x4405</span>,</span><br><span class="line">    <span class="number">0xa7db</span>,<span class="number">0xb7fa</span>,<span class="number">0x8799</span>,<span class="number">0x97b8</span>,<span class="number">0xe75f</span>,<span class="number">0xf77e</span>,<span class="number">0xc71d</span>,<span class="number">0xd73c</span>,</span><br><span class="line">    <span class="number">0x26d3</span>,<span class="number">0x36f2</span>,<span class="number">0x0691</span>,<span class="number">0x16b0</span>,<span class="number">0x6657</span>,<span class="number">0x7676</span>,<span class="number">0x4615</span>,<span class="number">0x5634</span>,</span><br><span class="line">    <span class="number">0xd94c</span>,<span class="number">0xc96d</span>,<span class="number">0xf90e</span>,<span class="number">0xe92f</span>,<span class="number">0x99c8</span>,<span class="number">0x89e9</span>,<span class="number">0xb98a</span>,<span class="number">0xa9ab</span>,</span><br><span class="line">    <span class="number">0x5844</span>,<span class="number">0x4865</span>,<span class="number">0x7806</span>,<span class="number">0x6827</span>,<span class="number">0x18c0</span>,<span class="number">0x08e1</span>,<span class="number">0x3882</span>,<span class="number">0x28a3</span>,</span><br><span class="line">    <span class="number">0xcb7d</span>,<span class="number">0xdb5c</span>,<span class="number">0xeb3f</span>,<span class="number">0xfb1e</span>,<span class="number">0x8bf9</span>,<span class="number">0x9bd8</span>,<span class="number">0xabbb</span>,<span class="number">0xbb9a</span>,</span><br><span class="line">    <span class="number">0x4a75</span>,<span class="number">0x5a54</span>,<span class="number">0x6a37</span>,<span class="number">0x7a16</span>,<span class="number">0x0af1</span>,<span class="number">0x1ad0</span>,<span class="number">0x2ab3</span>,<span class="number">0x3a92</span>,</span><br><span class="line">    <span class="number">0xfd2e</span>,<span class="number">0xed0f</span>,<span class="number">0xdd6c</span>,<span class="number">0xcd4d</span>,<span class="number">0xbdaa</span>,<span class="number">0xad8b</span>,<span class="number">0x9de8</span>,<span class="number">0x8dc9</span>,</span><br><span class="line">    <span class="number">0x7c26</span>,<span class="number">0x6c07</span>,<span class="number">0x5c64</span>,<span class="number">0x4c45</span>,<span class="number">0x3ca2</span>,<span class="number">0x2c83</span>,<span class="number">0x1ce0</span>,<span class="number">0x0cc1</span>,</span><br><span class="line">    <span class="number">0xef1f</span>,<span class="number">0xff3e</span>,<span class="number">0xcf5d</span>,<span class="number">0xdf7c</span>,<span class="number">0xaf9b</span>,<span class="number">0xbfba</span>,<span class="number">0x8fd9</span>,<span class="number">0x9ff8</span>,</span><br><span class="line">    <span class="number">0x6e17</span>,<span class="number">0x7e36</span>,<span class="number">0x4e55</span>,<span class="number">0x5e74</span>,<span class="number">0x2e93</span>,<span class="number">0x3eb2</span>,<span class="number">0x0ed1</span>,<span class="number">0x1ef0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint16_t</span> crc16(<span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> len) &#123;</span><br><span class="line">    <span class="keyword">int</span> counter;</span><br><span class="line">    <span class="keyword">uint16_t</span> crc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (counter = <span class="number">0</span>; counter &lt; len; counter++)</span><br><span class="line">            crc = (crc&lt;&lt;<span class="number">8</span>) ^ crc16tab[((crc&gt;&gt;<span class="number">8</span>) ^ *buf++)&amp;<span class="number">0x00FF</span>];</span><br><span class="line">    <span class="keyword">return</span> crc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="持久化（persistence）"><a href="#持久化（persistence）" class="headerlink" title="持久化（persistence）"></a>持久化（persistence）</h2><p>这篇文章提供了 Redis 持久化的技术性描述， 推荐所有 Redis 用户阅读。</p><p>要更广泛地了解 Redis 持久化， 以及这种持久化所保证的耐久性（durability）， 请参考文章 Redis persistence demystified （中文）。</p><h3 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h3><p>Redis 提供了多种不同级别的持久化方式：</p><ul><li>RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）。</li><li>AOF 持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。 AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写（rewrite），使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小。</li><li>Redis 还可以同时使用 AOF 持久化和 RDB 持久化。 在这种情况下， 当 Redis 重启时， 它会优先使用 AOF 文件来还原数据集， 因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。</li><li>你甚至可以关闭持久化功能，让数据只在服务器运行时存在。</li></ul><p>了解 RDB 持久化和 AOF 持久化之间的异同是非常重要的， 以下几个小节将详细地介绍这这两种持久化功能， 并对它们的相同和不同之处进行说明。</p><h3 id="RDB-的优点"><a href="#RDB-的优点" class="headerlink" title="RDB 的优点"></a>RDB 的优点</h3><ul><li>RDB 是一个非常紧凑（compact）的文件，它保存了 Redis 在某个时间点上的数据集。 这种文件非常适合用于进行备份： 比如说，你可以在最近的 24 小时内，每小时备份一次 RDB 文件，并且在每个月的每一天，也备份一个 RDB 文件。 这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。</li><li>RDB 非常适用于灾难恢复（disaster recovery）：它只有一个文件，并且内容都非常紧凑，可以（在加密后）将它传送到别的数据中心，或者亚马逊 S3 中。</li><li>RDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。</li><li>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</li></ul><h3 id="RDB-的缺点"><a href="#RDB-的缺点" class="headerlink" title="RDB 的缺点"></a>RDB 的缺点</h3><ul><li>如果你需要尽量避免在服务器故障时丢失数据，那么 RDB 不适合你。 虽然 Redis 允许你设置不同的保存点（save point）来控制保存 RDB 文件的频率， 但是， 因为RDB 文件需要保存整个数据集的状态， 所以它并不是一个轻松的操作。 因此你可能会至少 5 分钟才保存一次 RDB 文件。 在这种情况下， 一旦发生故障停机， 你就可能会丢失好几分钟的数据。</li><li>每次保存 RDB 的时候，Redis 都要 fork() 出一个子进程，并由子进程来进行实际的持久化工作。 在数据集比较庞大时， fork() 可能会非常耗时，造成服务器在某某毫秒内停止处理客户端； 如果数据集非常巨大，并且 CPU 时间非常紧张的话，那么这种停止时间甚至可能会长达整整一秒。 虽然 AOF 重写也需要进行 fork() ，但无论 AOF 重写的执行间隔有多长，数据的耐久性都不会有任何损失。</li></ul><h3 id="AOF-的优点"><a href="#AOF-的优点" class="headerlink" title="AOF 的优点"></a>AOF 的优点</h3><ul><li>使用 AOF 持久化会让 Redis 变得非常耐久（much more durable）：你可以设置不同的 fsync 策略，比如无 fsync ，每秒钟一次 fsync ，或者每次执行写入命令时 fsync 。 AOF 的默认策略为每秒钟 fsync 一次，在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据（ fsync 会在后台线程执行，所以主线程可以继续努力地处理命令请求）。</li><li>AOF 文件是一个只进行追加操作的日志文件（append only log）， 因此对 AOF 文件的写入不需要进行 seek ， 即使日志因为某些原因而包含了未写入完整的命令（比如写入时磁盘已满，写入中途停机，等等）， redis-check-aof 工具也可以轻易地修复这种问题。</li><li>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。</li><li>AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单： 举个例子， 如果你不小心执行了 FLUSHALL 命令， 但只要 AOF 文件未被重写， 那么只要停止服务器， 移除 AOF 文件末尾的 FLUSHALL 命令， 并重启 Redis ， 就可以将数据集恢复到 FLUSHALL 执行之前的状态。</li></ul><h3 id="AOF-的缺点"><a href="#AOF-的缺点" class="headerlink" title="AOF 的缺点"></a>AOF 的缺点</h3><ul><li>对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。</li><li>根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）。</li><li>AOF 在过去曾经发生过这样的 bug ： 因为个别命令的原因，导致 AOF 文件在重新载入时，无法将数据集恢复成保存时的原样。 （举个例子，阻塞命令 BRPOPLPUSH source destination timeout 就曾经引起过这样的 bug 。） 测试套件里为这种情况添加了测试： 它们会自动生成随机的、复杂的数据集， 并通过重新载入这些数据来确保一切正常。 虽然这种 bug 在 AOF 文件中并不常见， 但是对比来说， RDB 几乎是不可能出现这种 bug 的。</li></ul><h3 id="RDB-和-AOF-，我应该用哪一个？"><a href="#RDB-和-AOF-，我应该用哪一个？" class="headerlink" title="RDB 和 AOF ，我应该用哪一个？"></a>RDB 和 AOF ，我应该用哪一个？</h3><p>一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。</p><p>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。</p><p>有很多用户都只使用 AOF 持久化， 但我们并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快， 除此之外， 使用 RDB 还可以避免之前提到的 AOF 程序的 bug 。</p><p><strong>Note</strong></p><pre><code>因为以上提到的种种原因， 未来可能会将 AOF 和 RDB 整合成单个持久化模型。 （这是一个长期计划。）</code></pre><p>接下来的几个小节将介绍 RDB 和 AOF 的更多细节。</p><h3 id="RDB-快照"><a href="#RDB-快照" class="headerlink" title="RDB 快照"></a>RDB 快照</h3><p>在默认情况下， Redis 将数据库快照保存在名字为 dump.rdb 的二进制文件中。</p><p>你可以对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动保存一次数据集。</p><p>你也可以通过调用 SAVE 或者 BGSAVE ， 手动让 Redis 进行数据集保存操作。</p><p>比如说， 以下设置会让 Redis 在满足“ 60 秒内有至少有 1000 个键被改动”这一条件时， 自动保存一次数据集：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save 60 1000</span><br></pre></td></tr></table></figure></p><p>这种持久化方式被称为快照（snapshot）。</p><h3 id="快照的运作方式"><a href="#快照的运作方式" class="headerlink" title="快照的运作方式"></a>快照的运作方式</h3><p>当 Redis 需要保存 dump.rdb 文件时， 服务器执行以下操作：</p><ol><li>Redis 调用 fork() ，同时拥有父进程和子进程。</li><li>子进程将数据集写入到一个临时 RDB 文件中。</li><li>当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。</li></ol><p>这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益。</p><h3 id="只进行追加操作的文件（append-only-file，AOF）"><a href="#只进行追加操作的文件（append-only-file，AOF）" class="headerlink" title="只进行追加操作的文件（append-only file，AOF）"></a>只进行追加操作的文件（append-only file，AOF）</h3><p>快照功能并不是非常耐久（durable）： 如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、且仍未保存到快照中的那些数据。</p><p>尽管对于某些程序来说， 数据的耐久性并不是最重要的考虑因素， 但是对于那些追求完全耐久能力（full durability）的程序来说， 快照功能就不太适用了。</p><p>从 1.1 版本开始， Redis 增加了一种完全耐久的持久化方式： AOF 持久化。</p><p>你可以通过修改配置文件来打开 AOF 功能：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure></p><p>从现在开始， 每当 Redis 执行一个改变数据集的命令时（比如 SET key value [EX seconds] [PX milliseconds] [NX|XX]）， 这个命令就会被追加到 AOF 文件的末尾。</p><p>这样的话， 当 Redis 重新启时， 程序就可以通过重新执行 AOF 文件中的命令来达到重建数据集的目的。</p><h3 id="AOF-重写"><a href="#AOF-重写" class="headerlink" title="AOF 重写"></a>AOF 重写</h3><p>因为 AOF 的运作方式是不断地将命令追加到文件的末尾， 所以随着写入命令的不断增加， AOF 文件的体积也会变得越来越大。</p><p>举个例子， 如果你对一个计数器调用了 100 次 INCR key ， 那么仅仅是为了保存这个计数器的当前值， AOF 文件就需要使用 100 条记录（entry）。</p><p>然而在实际上， 只使用一条 SET key value [EX seconds] [PX milliseconds] [NX|XX] 命令已经足以保存计数器的当前值了， 其余 99 条记录实际上都是多余的。</p><p>为了处理这种情况， Redis 支持一种有趣的特性： 可以在不打断服务客户端的情况下， 对 AOF 文件进行重建（rebuild）。</p><p>执行 BGREWRITEAOF 命令， Redis 将生成一个新的 AOF 文件， 这个文件包含重建当前数据集所需的最少命令。</p><p>Redis 2.2 需要自己手动执行 BGREWRITEAOF 命令； Redis 2.4 则可以自动触发 AOF 重写， 具体信息请查看 2.4 的示例配置文件。</p><h3 id="AOF-的耐久性如何？"><a href="#AOF-的耐久性如何？" class="headerlink" title="AOF 的耐久性如何？"></a>AOF 的耐久性如何？</h3><p>你可以配置 Redis 多久才将数据 fsync 到磁盘一次。</p><p>有三个选项：</p><ul><li>每次有新命令追加到 AOF 文件时就执行一次 fsync ：非常慢，也非常安全。</li><li>每秒 fsync 一次：足够快（和使用 RDB 持久化差不多），并且在故障时只会丢失 1 秒钟的数据。</li><li>从不 fsync ：将数据交给操作系统来处理。更快，也更不安全的选择。</li></ul><p>推荐（并且也是默认）的措施为每秒 fsync 一次， 这种 fsync 策略可以兼顾速度和安全性。</p><p>总是 fsync 的策略在实际使用中非常慢， 即使在 Redis 2.0 对相关的程序进行了改进之后仍是如此 —— 频繁调用 fsync 注定了这种策略不可能快得起来。</p><h3 id="如果-AOF-文件出错了，怎么办？"><a href="#如果-AOF-文件出错了，怎么办？" class="headerlink" title="如果 AOF 文件出错了，怎么办？"></a>如果 AOF 文件出错了，怎么办？</h3><p>服务器可能在程序正在对 AOF 文件进行写入时停机， 如果停机造成了 AOF 文件出错（corrupt）， 那么 Redis 在重启时会拒绝载入这个 AOF 文件， 从而确保数据的一致性不会被破坏。</p><p>当发生这种情况时， 可以用以下方法来修复出错的 AOF 文件：</p><ol><li>为现有的 AOF 文件创建一个备份。</li><li><p>使用 Redis 附带的 redis-check-aof 程序，对原来的 AOF 文件进行修复。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-check-aof --fix</span><br></pre></td></tr></table></figure></li><li><p>（可选）使用 diff -u 对比修复后的 AOF 文件和原始 AOF 文件的备份，查看两个文件之间的不同之处。</p></li><li>重启 Redis 服务器，等待服务器载入修复后的 AOF 文件，并进行数据恢复。</li></ol><h3 id="AOF-的运作方式"><a href="#AOF-的运作方式" class="headerlink" title="AOF 的运作方式"></a>AOF 的运作方式</h3><p>AOF 重写和 RDB 创建快照一样，都巧妙地利用了写时复制机制。</p><p>以下是 AOF 重写的执行步骤：</p><ol><li>Redis 执行 fork() ，现在同时拥有父进程和子进程。</li><li>子进程开始将新 AOF 文件的内容写入到临时文件。</li><li>对于所有新执行的写入命令，父进程一边将它们累积到一个内存缓存中，一边将这些改动追加到现有 AOF 文件的末尾： 这样即使在重写的中途发生停机，现有的 AOF 文件也还是安全的。</li><li>当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据追加到新 AOF 文件的末尾。</li><li>搞定！现在 Redis 原子地用新文件替换旧文件，之后所有命令都会直接追加到新 AOF 文件的末尾。</li></ol><h3 id="怎么从-RDB-持久化切换到-AOF-持久化"><a href="#怎么从-RDB-持久化切换到-AOF-持久化" class="headerlink" title="怎么从 RDB 持久化切换到 AOF 持久化"></a>怎么从 RDB 持久化切换到 AOF 持久化</h3><p>在 Redis 2.2 或以上版本，可以在不重启的情况下，从 RDB 切换到 AOF ：</p><ol><li>为最新的 dump.rdb 文件创建一个备份。</li><li>将备份放到一个安全的地方。</li><li><p>执行以下两条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli&gt; CONFIG SET appendonly yes</span><br><span class="line"></span><br><span class="line">redis-cli&gt; CONFIG SET save <span class="string">""</span></span><br></pre></td></tr></table></figure></li><li><p>确保命令执行之后，数据库的键的数量没有改变。</p></li><li>确保写命令会被正确地追加到 AOF 文件的末尾。</li></ol><p>步骤 3 执行的第一条命令开启了 AOF 功能： Redis 会阻塞直到初始 AOF 文件创建完成为止， 之后 Redis 会继续处理命令请求， 并开始将写入命令追加到 AOF 文件末尾。</p><p>步骤 3 执行的第二条命令用于关闭 RDB 功能。 这一步是可选的， 如果你愿意的话， 也可以同时使用 RDB 和 AOF 这两种持久化功能。</p><p><strong>Note</strong></p><pre><code>别忘了在 redis.conf 中打开 AOF 功能！ 否则的话， 服务器重启之后， 之前通过 CONFIG SET 设置的配置就会被遗忘， 程序会按原来的配置来启动服务器。</code></pre><h3 id="RDB-和-AOF-之间的相互作用"><a href="#RDB-和-AOF-之间的相互作用" class="headerlink" title="RDB 和 AOF 之间的相互作用"></a>RDB 和 AOF 之间的相互作用</h3><p>在版本号大于等于 2.4 的 Redis 中， BGSAVE 执行的过程中， 不可以执行 BGREWRITEAOF 。 反过来说， 在 BGREWRITEAOF 执行的过程中， 也不可以执行 BGSAVE 。</p><p>这可以防止两个 Redis 后台进程同时对磁盘进行大量的 I/O 操作。</p><p>如果 BGSAVE 正在执行， 并且用户显示地调用 BGREWRITEAOF 命令， 那么服务器将向用户回复一个 OK 状态， 并告知用户， BGREWRITEAOF 已经被预定执行： 一旦 BGSAVE 执行完毕， BGREWRITEAOF 就会正式开始。</p><p>当 Redis 启动时， 如果 RDB 持久化和 AOF 持久化都被打开了， 那么程序会优先使用 AOF 文件来恢复数据集， 因为 AOF 文件所保存的数据通常是最完整的。</p><h3 id="备份-Redis-数据"><a href="#备份-Redis-数据" class="headerlink" title="备份 Redis 数据"></a>备份 Redis 数据</h3><p>在阅读这个小节前， 先将下面这句话铭记于心： 一定要备份你的数据库！</p><p>磁盘故障， 节点失效， 诸如此类的问题都可能让你的数据消失不见， 不进行备份是非常危险的。</p><p>Redis 对于数据备份是非常友好的， 因为你可以在服务器运行的时候对 RDB 文件进行复制： RDB 文件一旦被创建， 就不会进行任何修改。 当服务器要创建一个新的 RDB 文件时， 它先将文件的内容保存在一个临时文件里面， 当临时文件写入完毕时， 程序才使用 rename(2) 原子地用临时文件替换原来的 RDB 文件。</p><p>这也就是说， 无论何时， 复制 RDB 文件都是绝对安全的。</p><p>以下是我们的建议：</p><ul><li>创建一个定期任务（cron job）， 每小时将一个 RDB 文件备份到一个文件夹， 并且每天将一个 RDB 文件备份到另一个文件夹。</li><li>确保快照的备份都带有相应的日期和时间信息， 每次执行定期任务脚本时， 使用 find 命令来删除过期的快照： 比如说， 你可以保留最近 48 小时内的每小时快照， 还可以保留最近一两个月的每日快照。</li><li>至少每天一次， 将 RDB 备份到你的数据中心之外， 或者至少是备份到你运行 Redis 服务器的物理机器之外。</li></ul><h3 id="容灾备份"><a href="#容灾备份" class="headerlink" title="容灾备份"></a>容灾备份</h3><p>Redis 的容灾备份基本上就是对数据进行备份， 并将这些备份传送到多个不同的外部数据中心。</p><p>容灾备份可以在 Redis 运行并产生快照的主数据中心发生严重的问题时， 仍然让数据处于安全状态。</p><p>因为很多 Redis 用户都是创业者， 他们没有大把大把的钱可以浪费， 所以下面介绍的都是一些实用又便宜的容灾备份方法：</p><ul><li>Amazon S3 ，以及其他类似 S3 的服务，是一个构建灾难备份系统的好地方。 最简单的方法就是将你的每小时或者每日 RDB 备份加密并传送到 S3 。 对数据的加密可以通过 gpg -c 命令来完成（对称加密模式）。 记得把你的密码放到几个不同的、安全的地方去（比如你可以把密码复制给你组织里最重要的人物）。 同时使用多个储存服务来保存数据文件，可以提升数据的安全性。</li><li>传送快照可以使用 SCP 来完成（SSH 的组件）。 以下是简单并且安全的传送方法： 买一个离你的数据中心非常远的 VPS ， 装上 SSH ， 创建一个无口令的 SSH 客户端 key ， 并将这个 key 添加到 VPS 的 authorized_keys 文件中， 这样就可以向这个 VPS 传送快照备份文件了。 为了达到最好的数据安全性，至少要从两个不同的提供商那里各购买一个 VPS 来进行数据容灾备份。</li></ul><p>需要注意的是， 这类容灾系统如果没有小心地进行处理的话， 是很容易失效的。</p><p>最低限度下， 你应该在文件传送完毕之后， 检查所传送备份文件的体积和原始快照文件的体积是否相同。 如果你使用的是 VPS ， 那么还可以通过比对文件的 SHA1 校验和来确认文件是否传送完整。</p><p>另外， 你还需要一个独立的警报系统， 让它在负责传送备份文件的传送器（transfer）失灵时通知你。</p><h2 id="发布与订阅（pub-sub）"><a href="#发布与订阅（pub-sub）" class="headerlink" title="发布与订阅（pub/sub）"></a>发布与订阅（pub/sub）</h2><p>SUBSCRIBE channel [channel …] 、 UNSUBSCRIBE [channel [channel …]] 和 PUBLISH channel message 三个命令实现了发布与订阅信息泛型（Publish/Subscribe messaging paradigm）， 在这个实现中， 发送者（发送信息的客户端）不是将信息直接发送给特定的接收者（接收信息的客户端）， 而是将信息发送给频道（channel）， 然后由频道将信息转发给所有对这个频道感兴趣的订阅者。</p><p>发送者无须知道任何关于订阅者的信息， 而订阅者也无须知道是那个客户端给它发送信息， 它只要关注自己感兴趣的频道即可。</p><p>对发布者和订阅者进行解构（decoupling）， 可以极大地提高系统的扩展性（scalability）， 并得到一个更动态的网络拓扑（network topology）。</p><p>比如说， 要订阅频道 foo 和 bar ， 客户端可以使用频道名字作为参数来调用 SUBSCRIBE channel [channel …] 命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SUBSCRIBE foo bar</span><br></pre></td></tr></table></figure></p><p>当有客户端发送信息到这些频道时， Redis 会将传入的信息推送到所有订阅这些频道的客户端里面。</p><p>正在订阅频道的客户端不应该发送除 SUBSCRIBE channel [channel …] 和 UNSUBSCRIBE [channel [channel …]] 之外的其他命令。 其中， SUBSCRIBE channel [channel …] 可以用于订阅更多频道， 而 UNSUBSCRIBE [channel [channel …]] 则可以用于退订已订阅的一个或多个频道。</p><p>SUBSCRIBE channel [channel …] 和 UNSUBSCRIBE [channel [channel …]] 的执行结果会以信息的形式返回， 客户端可以通过分析所接收信息的第一个元素， 从而判断所收到的内容是一条真正的信息， 还是 SUBSCRIBE channel [channel …] 或 UNSUBSCRIBE [channel [channel …]] 命令的操作结果。</p><h3 id="信息的格式"><a href="#信息的格式" class="headerlink" title="信息的格式"></a>信息的格式</h3><p>频道转发的每条信息都是一条带有三个元素的多条批量回复（multi-bulk reply）。</p><p>信息的第一个元素标识了信息的类型：</p><ul><li>subscribe ： 表示当前客户端成功地订阅了信息第二个元素所指示的频道。 而信息的第三个元素则记录了目前客户端已订阅频道的总数。</li><li>unsubscribe ： 表示当前客户端成功地退订了信息第二个元素所指示的频道。 信息的第三个元素记录了客户端目前仍在订阅的频道数量。 当客户端订阅的频道数量降为 0 时， 客户端不再订阅任何频道， 它可以像往常一样， 执行任何 Redis 命令。</li><li>message ： 表示这条信息是由某个客户端执行 PUBLISH channel message 命令所发送的， 真正的信息。 信息的第二个元素是信息来源的频道， 而第三个元素则是信息的内容。</li></ul><p>举个例子， 如果客户端执行以下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SUBSCRIBE first second</span><br></pre></td></tr></table></figure></p><p>那么它将收到以下回复：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1) <span class="string">"subscribe"</span></span><br><span class="line">2) <span class="string">"first"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">4) <span class="string">"subscribe"</span></span><br><span class="line">5) <span class="string">"second"</span></span><br><span class="line">6) (<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure></p><p>如果在这时， 另一个客户端执行以下 PUBLISH channel message 命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; PUBLISH second Hello</span><br></pre></td></tr></table></figure></p><p>那么之前订阅了 second 频道的客户端将收到以下信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1) <span class="string">"message"</span></span><br><span class="line">2) <span class="string">"second"</span></span><br><span class="line">3) <span class="string">"hello"</span></span><br></pre></td></tr></table></figure></p><p>当订阅者决定退订所有频道时， 它可以执行一个无参数的 UNSUBSCRIBE [channel [channel …]] 命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; UNSUBSCRIBE</span><br></pre></td></tr></table></figure></p><p>这个命令将接到以下回复：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1) <span class="string">"unsubscribe"</span></span><br><span class="line">2) <span class="string">"second"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">1) <span class="string">"unsubscribe"</span></span><br><span class="line">2) <span class="string">"first"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure></p><h3 id="订阅模式"><a href="#订阅模式" class="headerlink" title="订阅模式"></a>订阅模式</h3><p>Redis 的发布与订阅实现支持模式匹配（pattern matching）： 客户端可以订阅一个带 * 号的模式， 如果某个/某些频道的名字和这个模式匹配， 那么当有信息发送给这个/这些频道的时候， 客户端也会收到这个/这些频道的信息。</p><p>比如说，执行命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; PSUBSCRIBE news.*</span><br></pre></td></tr></table></figure></p><p>的客户端将收到来自 news.art.figurative 、 news.music.jazz 等频道的信息。</p><p>客户端订阅的模式里面可以包含多个 glob 风格的通配符， 比如 * 、 ? 和 […] ， 等等。</p><p>执行命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; PUNSUBSCRIBE news.*</span><br></pre></td></tr></table></figure></p><p>将退订 news.* 模式， 其他已订阅的模式不会被影响。</p><p>通过订阅模式接收到的信息， 和通过订阅频道接收到的信息， 这两者的格式不太一样：</p><ul><li>通过订阅模式而接收到的信息的类型为 pmessage ： 这代表有某个客户端通过 PUBLISH channel message 向某个频道发送了信息， 而这个频道刚好匹配了当前客户端所订阅的某个模式。 信息的第二个元素记录了被匹配的模式， 第三个元素记录了被匹配的频道的名字， 最后一个元素则记录了信息的实际内容。</li></ul><p>客户端处理 PSUBSCRIBE pattern [pattern …] 和 PUNSUBSCRIBE [pattern [pattern …]] 返回值的方式， 和客户端处理 SUBSCRIBE channel [channel …] 和 UNSUBSCRIBE [channel [channel …]] 的方式类似： 通过对信息的第一个元素进行分析， 客户端可以判断接收到的信息是一个真正的信息， 还是 PSUBSCRIBE pattern [pattern …] 或 PUNSUBSCRIBE [pattern [pattern …]] 命令的返回值。</p><h3 id="通过频道和模式接收同一条信息"><a href="#通过频道和模式接收同一条信息" class="headerlink" title="通过频道和模式接收同一条信息"></a>通过频道和模式接收同一条信息</h3><p>如果客户端订阅的多个模式匹配了同一个频道， 或者客户端同时订阅了某个频道、以及匹配这个频道的某个模式， 那么它可能会多次接收到同一条信息。</p><p>举个例子， 如果客户端执行了以下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SUBSCRIBE foo</span><br><span class="line">PSUBSCRIBE f*</span><br></pre></td></tr></table></figure></p><p>那么当有信息发送到频道 foo 时， 客户端将收到两条信息： 一条来自频道 foo ，信息类型为 message ； 另一条来自模式 f* ，信息类型为 pmessage 。</p><h3 id="订阅总数"><a href="#订阅总数" class="headerlink" title="订阅总数"></a>订阅总数</h3><p>在执行 SUBSCRIBE channel [channel …] 、 UNSUBSCRIBE [channel [channel …]] 、 PSUBSCRIBE pattern [pattern …] 和 PUNSUBSCRIBE [pattern [pattern …]] 命令时， 返回结果的最后一个元素是客户端目前仍在订阅的频道和模式总数。</p><p>当客户端退订所有频道和模式， 也即是这个总数值下降为 0 的时候， 客户端将退出订阅与发布状态。</p><h3 id="编程示例"><a href="#编程示例" class="headerlink" title="编程示例"></a>编程示例</h3><p>Pieter Noordhuis 提供了一个使用 EventMachine 和 Redis 编写的 高性能多用户网页聊天软件 ， 这个软件很好地展示了发布与订阅功能的用法。</p><h3 id="客户端库实现提示"><a href="#客户端库实现提示" class="headerlink" title="客户端库实现提示"></a>客户端库实现提示</h3><p>因为所有接收到的信息都会包含一个信息来源：</p><ul><li>当信息来自频道时，来源是某个频道；</li><li>当信息来自模式时，来源是某个模式。</li></ul><p>因此， 客户端可以用一个哈希表， 将特定来源和处理该来源的回调函数关联起来。 当有新信息到达时， 程序就可以根据信息的来源， 在 O(1) 复杂度内， 将信息交给正确的回调函数来处理。</p><h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><p>Redis 的 Sentinel 系统用于管理多个 Redis 服务器（instance）， 该系统执行以下三个任务：</p><ul><li>监控（Monitoring）： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。</li><li>提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</li><li>自动故障迁移（Automatic failover）： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。</li></ul><p>Redis Sentinel 是一个分布式系统， 你可以在一个架构中运行多个 Sentinel 进程（progress）， 这些进程使用流言协议（gossip protocols)来接收关于主服务器是否下线的信息， 并使用投票协议（agreement protocols）来决定是否执行自动故障迁移， 以及选择哪个从服务器作为新的主服务器。</p><p>虽然 Redis Sentinel 释出为一个单独的可执行文件 redis-sentinel ， 但实际上它只是一个运行在特殊模式下的 Redis 服务器， 你可以在启动一个普通 Redis 服务器时通过给定 –sentinel 选项来启动 Redis Sentinel 。</p><p><strong>Warning</strong></p><pre><code>Redis Sentinel 目前仍在开发中， 这个文档的内容可能随着 Sentinel 实现的修改而变更。Redis Sentinel 兼容 Redis 2.4.16 或以上版本， 推荐使用 Redis 2.8.0 或以上的版本。</code></pre><h3 id="获取-Sentinel"><a href="#获取-Sentinel" class="headerlink" title="获取 Sentinel"></a>获取 Sentinel</h3><p>目前 Sentinel 系统是 Redis 的 unstable 分支的一部分， 你必须到 Redis 项目的 Github 页面 克隆一份 unstable 分值， 然后通过编译来获得 Sentinel 系统。</p><p>Sentinel 程序可以在编译后的 src 文档中发现， 它是一个命名为 redis-sentinel 的程序。</p><p>你也可以通过下一节介绍的方法， 让 redis-server 程序运行在 Sentinel 模式之下。</p><p>另外， 一个新版本的 Sentinel 已经包含在了 Redis 2.8.0 版本的释出文件中。</p><h3 id="启动-Sentinel"><a href="#启动-Sentinel" class="headerlink" title="启动 Sentinel"></a>启动 Sentinel</h3><p>对于 redis-sentinel 程序， 你可以用以下命令来启动 Sentinel 系统：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel /path/to/sentinel.conf</span><br></pre></td></tr></table></figure></p><p>对于 redis-server 程序， 你可以用以下命令来启动一个运行在 Sentinel 模式下的 Redis 服务器：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /path/to/sentinel.conf --sentinel</span><br></pre></td></tr></table></figure></p><p>两种方法都可以启动一个 Sentinel 实例。</p><p>启动 Sentinel 实例必须指定相应的配置文件， 系统会使用配置文件来保存 Sentinel 的当前状态， 并在 Sentinel 重启时通过载入配置文件来进行状态还原。</p><p>如果启动 Sentinel 时没有指定相应的配置文件， 或者指定的配置文件不可写（not writable）， 那么 Sentinel 会拒绝启动。</p><h3 id="配置-Sentinel"><a href="#配置-Sentinel" class="headerlink" title="配置 Sentinel"></a>配置 Sentinel</h3><p>Redis 源码中包含了一个名为 sentinel.conf 的文件， 这个文件是一个带有详细注释的 Sentinel 配置文件示例。</p><p>运行一个 Sentinel 所需的最少配置如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 60000</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"></span><br><span class="line">sentinel monitor resque 192.168.1.3 6380 4</span><br><span class="line">sentinel down-after-milliseconds resque 10000</span><br><span class="line">sentinel failover-timeout resque 180000</span><br><span class="line">sentinel parallel-syncs resque 5</span><br></pre></td></tr></table></figure></p><p>第一行配置指示 Sentinel 去监视一个名为 mymaster 的主服务器， 这个主服务器的 IP 地址为 127.0.0.1 ， 端口号为 6379 ， 而将这个主服务器判断为失效至少需要 2 个 Sentinel 同意 （只要同意 Sentinel 的数量不达标，自动故障迁移就不会执行）。</p><p>不过要注意， 无论你设置要多少个 Sentinel 同意才能判断一个服务器失效， 一个 Sentinel 都需要获得系统中多数（majority） Sentinel 的支持， 才能发起一次自动故障迁移， 并预留一个给定的配置纪元 （configuration Epoch ，一个配置纪元就是一个新主服务器配置的版本号）。</p><p>换句话说， 在只有少数（minority） Sentinel 进程正常运作的情况下， Sentinel 是不能执行自动故障迁移的。</p><p>其他选项的基本格式如下：</p><pre><code>sentinel &lt;选项的名字&gt; &lt;主服务器的名字&gt; &lt;选项的值&gt;</code></pre><p>各个选项的功能如下：</p><ul><li><p>down-after-milliseconds 选项指定了 Sentinel 认为服务器已经断线所需的毫秒数。</p><p>  如果服务器在给定的毫秒数之内， 没有返回 Sentinel 发送的 PING 命令的回复， 或者返回一个错误， 那么 Sentinel 将这个服务器标记为主观下线（subjectively down，简称 SDOWN ）。</p><p>  不过只有一个 Sentinel 将服务器标记为主观下线并不一定会引起服务器的自动故障迁移： 只有在足够数量的 Sentinel 都将一个服务器标记为主观下线之后， 服务器才会被标记为客观下线（objectively down， 简称 ODOWN ）， 这时自动故障迁移才会执行。</p><p>  将服务器标记为客观下线所需的 Sentinel 数量由对主服务器的配置决定。</p></li><li><p>parallel-syncs 选项指定了在执行故障转移时， 最多可以有多少个从服务器同时对新的主服务器进行同步， 这个数字越小， 完成故障转移所需的时间就越长。</p><p>  如果从服务器被设置为允许使用过期数据集（参见对 redis.conf 文件中对 slave-serve-stale-data 选项的说明）， 那么你可能不希望所有从服务器都在同一时间向新的主服务器发送同步请求， 因为尽管复制过程的绝大部分步骤都不会阻塞从服务器， 但从服务器在载入主服务器发来的 RDB 文件时， 仍然会造成从服务器在一段时间内不能处理命令请求： 如果全部从服务器一起对新的主服务器进行同步， 那么就可能会造成所有从服务器在短时间内全部不可用的情况出现。</p><p>  你可以通过将这个值设为 1 来保证每次只有一个从服务器处于不能处理命令请求的状态。</p></li></ul><p>本文档剩余的内容将对 Sentinel 系统的其他选项进行介绍， 示例配置文件 sentinel.conf 也对相关的选项进行了完整的注释。</p><h3 id="主观下线和客观下线"><a href="#主观下线和客观下线" class="headerlink" title="主观下线和客观下线"></a>主观下线和客观下线</h3><p>前面说过， Redis 的 Sentinel 中关于下线（down）有两个不同的概念：</p><ul><li>主观下线（Subjectively Down， 简称 SDOWN）指的是单个 Sentinel 实例对服务器做出的下线判断。</li><li>客观下线（Objectively Down， 简称 ODOWN）指的是多个 Sentinel 实例在对同一个服务器做出 SDOWN 判断， 并且通过 SENTINEL is-master-down-by-addr 命令互相交流之后， 得出的服务器下线判断。 （一个 Sentinel 可以通过向另一个 Sentinel 发送 SENTINEL is-master-down-by-addr 命令来询问对方是否认为给定的服务器已下线。）</li></ul><p>如果一个服务器没有在 master-down-after-milliseconds 选项所指定的时间内， 对向它发送 PING 命令的 Sentinel 返回一个有效回复（valid reply）， 那么 Sentinel 就会将这个服务器标记为主观下线。</p><p>服务器对 PING 命令的有效回复可以是以下三种回复的其中一种：</p><ul><li>返回 +PONG 。</li><li>返回 -LOADING 错误。</li><li>返回 -MASTERDOWN 错误。</li></ul><p>如果服务器返回除以上三种回复之外的其他回复， 又或者在指定时间内没有回复 PING 命令， 那么 Sentinel 认为服务器返回的回复无效（non-valid）。</p><p>注意， 一个服务器必须在 master-down-after-milliseconds 毫秒内， 一直返回无效回复才会被 Sentinel 标记为主观下线。</p><p>举个例子， 如果 master-down-after-milliseconds 选项的值为 30000 毫秒（30 秒）， 那么只要服务器能在每 29 秒之内返回至少一次有效回复， 这个服务器就仍然会被认为是处于正常状态的。</p><p>从主观下线状态切换到客观下线状态并没有使用严格的法定人数算法（strong quorum algorithm）， 而是使用了流言协议： 如果 Sentinel 在给定的时间范围内， 从其他 Sentinel 那里接收到了足够数量的主服务器下线报告， 那么 Sentinel 就会将主服务器的状态从主观下线改变为客观下线。 如果之后其他 Sentinel 不再报告主服务器已下线， 那么客观下线状态就会被移除。</p><p>客观下线条件只适用于主服务器： 对于任何其他类型的 Redis 实例， Sentinel 在将它们判断为下线前不需要进行协商， 所以从服务器或者其他 Sentinel 永远不会达到客观下线条件。</p><p>只要一个 Sentinel 发现某个主服务器进入了客观下线状态， 这个 Sentinel 就可能会被其他 Sentinel 推选出， 并对失效的主服务器执行自动故障迁移操作。</p><h3 id="每个-Sentinel-都需要定期执行的任务"><a href="#每个-Sentinel-都需要定期执行的任务" class="headerlink" title="每个 Sentinel 都需要定期执行的任务"></a>每个 Sentinel 都需要定期执行的任务</h3><ul><li>每个 Sentinel 以每秒钟一次的频率向它所知的主服务器、从服务器以及其他 Sentinel 实例发送一个 PING 命令。</li><li>如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 那么这个实例会被 Sentinel 标记为主观下线。 一个有效回复可以是： +PONG 、 -LOADING 或者 -MASTERDOWN 。</li><li>如果一个主服务器被标记为主观下线， 那么正在监视这个主服务器的所有 Sentinel 要以每秒一次的频率确认主服务器的确进入了主观下线状态。</li><li>如果一个主服务器被标记为主观下线， 并且有足够数量的 Sentinel （至少要达到配置文件指定的数量）在指定的时间范围内同意这一判断， 那么这个主服务器被标记为客观下线。</li><li>在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率向它已知的所有主服务器和从服务器发送 INFO [section] 命令。 当一个主服务器被 Sentinel 标记为客观下线时， Sentinel 向下线主服务器的所有从服务器发送 INFO [section] 命令的频率会从 10 秒一次改为每秒一次。</li><li>当没有足够数量的 Sentinel 同意主服务器已经下线， 主服务器的客观下线状态就会被移除。 当主服务器重新向 Sentinel 的 PING 命令返回有效回复时， 主服务器的主管下线状态就会被移除。</li></ul><h3 id="自动发现-Sentinel-和从服务器"><a href="#自动发现-Sentinel-和从服务器" class="headerlink" title="自动发现 Sentinel 和从服务器"></a>自动发现 Sentinel 和从服务器</h3><p>一个 Sentinel 可以与其他多个 Sentinel 进行连接， 各个 Sentinel 之间可以互相检查对方的可用性， 并进行信息交换。</p><p>你无须为运行的每个 Sentinel 分别设置其他 Sentinel 的地址， 因为 Sentinel 可以通过发布与订阅功能来自动发现正在监视相同主服务器的其他 Sentinel ， 这一功能是通过向频道 <strong>sentinel</strong>:hello 发送信息来实现的。</p><p>与此类似， 你也不必手动列出主服务器属下的所有从服务器， 因为 Sentinel 可以通过询问主服务器来获得所有从服务器的信息。</p><ul><li>每个 Sentinel 会以每两秒一次的频率， 通过发布与订阅功能， 向被它监视的所有主服务器和从服务器的 <strong>sentinel</strong>:hello 频道发送一条信息， 信息中包含了 Sentinel 的 IP 地址、端口号和运行 ID （runid）。</li><li>每个 Sentinel 都订阅了被它监视的所有主服务器和从服务器的 <strong>sentinel</strong>:hello 频道， 查找之前未出现过的 sentinel （looking for unknown sentinels）。 当一个 Sentinel 发现一个新的 Sentinel 时， 它会将新的 Sentinel 添加到一个列表中， 这个列表保存了 Sentinel 已知的， 监视同一个主服务器的所有其他 Sentinel 。</li><li>Sentinel 发送的信息中还包括完整的主服务器当前配置（configuration）。 如果一个 Sentinel 包含的主服务器配置比另一个 Sentinel 发送的配置要旧， 那么这个 Sentinel 会立即升级到新配置上。</li><li>在将一个新 Sentinel 添加到监视主服务器的列表上面之前， Sentinel 会先检查列表中是否已经包含了和要添加的 Sentinel 拥有相同运行 ID 或者相同地址（包括 IP 地址和端口号）的 Sentinel ， 如果是的话， Sentinel 会先移除列表中已有的那些拥有相同运行 ID 或者相同地址的 Sentinel ， 然后再添加新 Sentinel 。</li></ul><h3 id="Sentinel-API"><a href="#Sentinel-API" class="headerlink" title="Sentinel API"></a>Sentinel API</h3><p>在默认情况下， Sentinel 使用 TCP 端口 26379 （普通 Redis 服务器使用的是 6379 ）。</p><p>Sentinel 接受 Redis 协议格式的命令请求， 所以你可以使用 redis-cli 或者任何其他 Redis 客户端来与 Sentinel 进行通讯。</p><p>有两种方式可以和 Sentinel 进行通讯：</p><ul><li>第一种方法是通过直接发送命令来查询被监视 Redis 服务器的当前状态， 以及 Sentinel 所知道的关于其他 Sentinel 的信息， 诸如此类。</li><li>另一种方法是使用发布与订阅功能， 通过接收 Sentinel 发送的通知： 当执行故障转移操作， 或者某个被监视的服务器被判断为主观下线或者客观下线时， Sentinel 就会发送相应的信息。</li></ul><h3 id="Sentinel-命令"><a href="#Sentinel-命令" class="headerlink" title="Sentinel 命令"></a>Sentinel 命令</h3><p>以下列出的是 Sentinel 接受的命令：</p><ul><li>PING ：返回 PONG 。</li><li>SENTINEL masters ：列出所有被监视的主服务器，以及这些主服务器的当前状态。</li><li>SENTINEL slaves \<master name\=""> ：列出给定主服务器的所有从服务器，以及这些从服务器的当前状态。</master></li><li>SENTINEL get-master-addr-by-name \<master name\=""> ： 返回给定名字的主服务器的 IP 地址和端口号。 如果这个主服务器正在执行故障转移操作， 或者针对这个主服务器的故障转移操作已经完成， 那么这个命令返回新的主服务器的 IP 地址和端口号。</master></li><li>SENTINEL reset \&lt;pattern> ： 重置所有名字和给定模式 pattern 相匹配的主服务器。 pattern 参数是一个 Glob 风格的模式。 重置操作清除主服务器目前的所有状态， 包括正在执行中的故障转移， 并移除目前已经发现和关联的， 主服务器的所有从服务器和 Sentinel 。</li><li>SENTINEL failover \<master name\=""> ： 当主服务器失效时， 在不询问其他 Sentinel 意见的情况下， 强制开始一次自动故障迁移 （不过发起故障转移的 Sentinel 会向其他 Sentinel 发送一个新的配置，其他 Sentinel 会根据这个配置进行相应的更新）。</master></li></ul><h3 id="发布与订阅信息"><a href="#发布与订阅信息" class="headerlink" title="发布与订阅信息"></a>发布与订阅信息</h3><p>客户端可以将 Sentinel 看作是一个只提供了订阅功能的 Redis 服务器： 你不可以使用 PUBLISH channel message 命令向这个服务器发送信息， 但你可以用 SUBSCRIBE channel [channel …] 命令或者 PSUBSCRIBE pattern [pattern …] 命令， 通过订阅给定的频道来获取相应的事件提醒。</p><p>一个频道能够接收和这个频道的名字相同的事件。 比如说， 名为 +sdown 的频道就可以接收所有实例进入主观下线（SDOWN）状态的事件。</p><p>通过执行 PSUBSCRIBE * 命令可以接收所有事件信息。</p><p>以下列出的是客户端可以通过订阅来获得的频道和信息的格式： 第一个英文单词是频道/事件的名字， 其余的是数据的格式。</p><p>注意， 当格式中包含 instance details 字样时， 表示频道所返回的信息中包含了以下用于识别目标实例的内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;instance-type&gt; &lt;name&gt; &lt;ip&gt; &lt;port&gt; @ &lt;master-name&gt; &lt;master-ip&gt; &lt;master-port&gt;</span><br></pre></td></tr></table></figure></p><p>@ 字符之后的内容用于指定主服务器， 这些内容是可选的， 它们仅在 @ 字符之前的内容指定的实例不是主服务器时使用。</p><ul><li>+reset-master \<instance details\=""> ：主服务器已被重置。</instance></li><li>+slave \<instance details\=""> ：一个新的从服务器已经被 Sentinel 识别并关联。</instance></li><li>+failover-state-reconf-slaves \<instance details\=""> ：故障转移状态切换到了 reconf-slaves 状态。</instance></li><li>+failover-detected \<instance details\=""> ：另一个 Sentinel 开始了一次故障转移操作，或者一个从服务器转换成了主服务器。</instance></li><li>+slave-reconf-sent \<instance details\=""> ：领头（leader）的 Sentinel 向实例发送了 SLAVEOF host port 命令，为实例设置新的主服务器。</instance></li><li>+slave-reconf-inprog \<instance details\=""> ：实例正在将自己设置为指定主服务器的从服务器，但相应的同步过程仍未完成。</instance></li><li>+slave-reconf-done \<instance details\=""> ：从服务器已经成功完成对新主服务器的同步。</instance></li><li>-dup-sentinel \<instance details\=""> ：对给定主服务器进行监视的一个或多个 Sentinel 已经因为重复出现而被移除 —— 当 Sentinel 实例重启的时候，就会出现这种情况。</instance></li><li>+sentinel \<instance details\=""> ：一个监视给定主服务器的新 Sentinel 已经被识别并添加。</instance></li><li>+sdown \<instance details\=""> ：给定的实例现在处于主观下线状态。</instance></li><li>-sdown \<instance details\=""> ：给定的实例已经不再处于主观下线状态。</instance></li><li>+odown \<instance details\=""> ：给定的实例现在处于客观下线状态。</instance></li><li>-odown \<instance details\=""> ：给定的实例已经不再处于客观下线状态。</instance></li><li>+new-epoch \<instance details\=""> ：当前的纪元（epoch）已经被更新。</instance></li><li>+try-failover \<instance details\=""> ：一个新的故障迁移操作正在执行中，等待被大多数 Sentinel 选中（waiting to be elected by the majority）。</instance></li><li>+elected-leader \<instance details\=""> ：赢得指定纪元的选举，可以进行故障迁移操作了。</instance></li><li>+failover-state-select-slave \<instance details\=""> ：故障转移操作现在处于 select-slave 状态 —— Sentinel 正在寻找可以升级为主服务器的从服务器。</instance></li><li>no-good-slave \<instance details\=""> ：Sentinel 操作未能找到适合进行升级的从服务器。Sentinel 会在一段时间之后再次尝试寻找合适的从服务器来进行升级，又或者直接放弃执行故障转移操作。</instance></li><li>selected-slave \<instance details\=""> ：Sentinel 顺利找到适合进行升级的从服务器。</instance></li><li>failover-state-send-slaveof-noone \<instance details\=""> ：Sentinel 正在将指定的从服务器升级为主服务器，等待升级功能完成。</instance></li><li>failover-end-for-timeout \<instance details\=""> ：故障转移因为超时而中止，不过最终所有从服务器都会开始复制新的主服务器（slaves will eventually be configured to replicate with the new master anyway）。</instance></li><li>failover-end \<instance details\=""> ：故障转移操作顺利完成。所有从服务器都开始复制新的主服务器了。</instance></li><li>+switch-master \<master name\=""> \&lt;oldip> \&lt;oldport> \&lt;newip> \&lt;newport> ：配置变更，主服务器的 IP 和地址已经改变。 这是绝大多数外部用户都关心的信息。</master></li><li>+tilt ：进入 tilt 模式。</li><li>-tilt ：退出 tilt 模式。</li></ul><h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><p>一次故障转移操作由以下步骤组成：</p><ul><li>发现主服务器已经进入客观下线状态。</li><li>对我们的当前纪元进行自增（详情请参考 Raft leader election ）， 并尝试在这个纪元中当选。</li><li>如果当选失败， 那么在设定的故障迁移超时时间的两倍之后， 重新尝试当选。 如果当选成功， 那么执行以下步骤。</li><li>选出一个从服务器，并将它升级为主服务器。</li><li>向被选中的从服务器发送 SLAVEOF NO ONE 命令，让它转变为主服务器。</li><li>通过发布与订阅功能， 将更新后的配置传播给所有其他 Sentinel ， 其他 Sentinel 对它们自己的配置进行更新。</li><li>向已下线主服务器的从服务器发送 SLAVEOF host port 命令， 让它们去复制新的主服务器。</li><li>当所有从服务器都已经开始复制新的主服务器时， 领头 Sentinel 终止这次故障迁移操作。</li></ul><p><strong>Note</strong></p><pre><code>每当一个 Redis 实例被重新配置（reconfigured） —— 无论是被设置成主服务器、从服务器、又或者被设置成其他主服务器的从服务器 —— Sentinel 都会向被重新配置的实例发送一个 CONFIG REWRITE 命令， 从而确保这些配置会持久化在硬盘里。</code></pre><p>Sentinel 使用以下规则来选择新的主服务器：</p><ul><li>在失效主服务器属下的从服务器当中， 那些被标记为主观下线、已断线、或者最后一次回复 PING 命令的时间大于五秒钟的从服务器都会被淘汰。</li><li>在失效主服务器属下的从服务器当中， 那些与失效主服务器连接断开的时长超过 down-after 选项指定的时长十倍的从服务器都会被淘汰。</li><li>在经历了以上两轮淘汰之后剩下来的从服务器中， 我们选出复制偏移量（replication offset）最大的那个从服务器作为新的主服务器； 如果复制偏移量不可用， 或者从服务器的复制偏移量相同， 那么带有最小运行 ID 的那个从服务器成为新的主服务器。</li></ul><h3 id="Sentinel-自动故障迁移的一致性特质"><a href="#Sentinel-自动故障迁移的一致性特质" class="headerlink" title="Sentinel 自动故障迁移的一致性特质"></a>Sentinel 自动故障迁移的一致性特质</h3><p>Sentinel 自动故障迁移使用 Raft 算法来选举领头（leader） Sentinel ， 从而确保在一个给定的纪元（epoch）里， 只有一个领头产生。</p><p>这表示在同一个纪元中， 不会有两个 Sentinel 同时被选中为领头， 并且各个 Sentinel 在同一个纪元中只会对一个领头进行投票。</p><p>更高的配置纪元总是优于较低的纪元， 因此每个 Sentinel 都会主动使用更新的纪元来代替自己的配置。</p><p>简单来说， 我们可以将 Sentinel 配置看作是一个带有版本号的状态。 一个状态会以最后写入者胜出（last-write-wins）的方式（也即是，最新的配置总是胜出）传播至所有其他 Sentinel 。</p><p>举个例子， 当出现网络分割（network partitions）时， 一个 Sentinel 可能会包含了较旧的配置， 而当这个 Sentinel 接到其他 Sentinel 发来的版本更新的配置时， Sentinel 就会对自己的配置进行更新。</p><p>如果要在网络分割出现的情况下仍然保持一致性， 那么应该使用 min-slaves-to-write 选项， 让主服务器在连接的从实例少于给定数量时停止执行写操作， 与此同时， 应该在每个运行 Redis 主服务器或从服务器的机器上运行 Redis Sentinel 进程。</p><h3 id="Sentinel-状态的持久化"><a href="#Sentinel-状态的持久化" class="headerlink" title="Sentinel 状态的持久化"></a>Sentinel 状态的持久化</h3><p>Sentinel 的状态会被持久化在 Sentinel 配置文件里面。</p><p>每当 Sentinel 接收到一个新的配置， 或者当领头 Sentinel 为主服务器创建一个新的配置时， 这个配置会与配置纪元一起被保存到磁盘里面。</p><p>这意味着停止和重启 Sentinel 进程都是安全的。</p><h3 id="Sentinel-在非故障迁移的情况下对实例进行重新配置"><a href="#Sentinel-在非故障迁移的情况下对实例进行重新配置" class="headerlink" title="Sentinel 在非故障迁移的情况下对实例进行重新配置"></a>Sentinel 在非故障迁移的情况下对实例进行重新配置</h3><p>即使没有自动故障迁移操作在进行， Sentinel 总会尝试将当前的配置设置到被监视的实例上面。 特别是：</p><ul><li>根据当前的配置， 如果一个从服务器被宣告为主服务器， 那么它会代替原有的主服务器， 成为新的主服务器， 并且成为原有主服务器的所有从服务器的复制对象。</li><li>那些连接了错误主服务器的从服务器会被重新配置， 使得这些从服务器会去复制正确的主服务器。<br>不过， 在以上这些条件满足之后， Sentinel 在对实例进行重新配置之前仍然会等待一段足够长的时间， 确保可以接收到其他 Sentinel 发来的配置更新， 从而避免自身因为保存了过期的配置而对实例进行了不必要的重新配置。</li></ul><h3 id="TILT-模式"><a href="#TILT-模式" class="headerlink" title="TILT 模式"></a>TILT 模式</h3><p>Redis Sentinel 严重依赖计算机的时间功能： 比如说， 为了判断一个实例是否可用， Sentinel 会记录这个实例最后一次相应 PING 命令的时间， 并将这个时间和当前时间进行对比， 从而知道这个实例有多长时间没有和 Sentinel 进行任何成功通讯。</p><p>不过， 一旦计算机的时间功能出现故障， 或者计算机非常忙碌， 又或者进程因为某些原因而被阻塞时， Sentinel 可能也会跟着出现故障。</p><p>TILT 模式是一种特殊的保护模式： 当 Sentinel 发现系统有些不对劲时， Sentinel 就会进入 TILT 模式。</p><p>因为 Sentinel 的时间中断器默认每秒执行 10 次， 所以我们预期时间中断器的两次执行之间的间隔为 100 毫秒左右。 Sentinel 的做法是， 记录上一次时间中断器执行时的时间， 并将它和这一次时间中断器执行的时间进行对比：</p><ul><li>如果两次调用时间之间的差距为负值， 或者非常大（超过 2 秒钟）， 那么 Sentinel 进入 TILT 模式。</li><li>如果 Sentinel 已经进入 TILT 模式， 那么 Sentinel 延迟退出 TILT 模式的时间。</li></ul><p>当 Sentinel 进入 TILT 模式时， 它仍然会继续监视所有目标， 但是：</p><ul><li>它不再执行任何操作，比如故障转移。</li><li>当有实例向这个 Sentinel 发送 SENTINEL is-master-down-by-addr 命令时， Sentinel 返回负值： 因为这个 Sentinel 所进行的下线判断已经不再准确。</li></ul><p>如果 TILT 可以正常维持 30 秒钟， 那么 Sentinel 退出 TILT 模式。</p><h3 id="处理-BUSY-状态"><a href="#处理-BUSY-状态" class="headerlink" title="处理 -BUSY 状态"></a>处理 -BUSY 状态</h3><p><strong>Warning</strong></p><pre><code>该功能尚未实现</code></pre><p>当 Lua 脚本的运行时间超过指定时限时， Redis 就会返回 -BUSY 错误。</p><p>当出现这种情况时， Sentinel 在尝试执行故障转移操作之前， 会先向服务器发送一个 SCRIPT KILL 命令， 如果服务器正在执行的是一个只读脚本的话， 那么这个脚本就会被杀死， 服务器就会回到正常状态。</p><h3 id="Sentinel-的客户端实现"><a href="#Sentinel-的客户端实现" class="headerlink" title="Sentinel 的客户端实现"></a>Sentinel 的客户端实现</h3><p>关于 Sentinel 客户端的实现信息可以参考 Sentinel 客户端指引手册 。</p><h2 id="集群教程"><a href="#集群教程" class="headerlink" title="集群教程"></a>集群教程</h2><p>本文档是 Redis 集群的入门教程， 从用户的角度介绍了设置、测试和操作集群的方法。</p><p>本教程不包含晦涩难懂的分布式概念， 也没有像 Redis 集群规范 那样包含 Redis 集群的实现细节， 如果你打算深入地学习 Redis 集群的部署方法， 那么推荐你在阅读完这个教程之后， 再去看一看集群规范。</p><p>Redis 集群目前仍处于 Alpha 测试版本， 如果在使用过程中发现任何问题， 请到 Redis 的邮件列表 发贴， 或者到 Redis 的 Github 页面 报告错误。</p><h3 id="集群简介"><a href="#集群简介" class="headerlink" title="集群简介"></a>集群简介</h3><p>Redis 集群是一个可以在多个 Redis 节点之间进行数据共享的设施（installation）。</p><p>Redis 集群不支持那些需要同时处理多个键的 Redis 命令， 因为执行这些命令需要在多个 Redis 节点之间移动数据， 并且在高负载的情况下， 这些命令将降低 Redis 集群的性能， 并导致不可预测的行为。</p><p>Redis 集群通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。</p><p>Redis 集群提供了以下两个好处：</p><ul><li>将数据自动切分（split）到多个节点的能力。</li><li>当集群中的一部分节点失效或者无法进行通讯时， 仍然可以继续处理命令请求的能力。</li></ul><h3 id="Redis-集群数据共享。"><a href="#Redis-集群数据共享。" class="headerlink" title="Redis 集群数据共享。"></a>Redis 集群数据共享。</h3><p>Redis 集群使用数据分片（sharding）而非一致性哈希（consistency hashing）来实现： 一个 Redis 集群包含 16384 个哈希槽（hash slot）， 数据库中的每个键都属于这 16384 个哈希槽的其中一个， 集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。</p><p>集群中的每个节点负责处理一部分哈希槽。 举个例子， 一个集群可以有三个哈希槽， 其中：</p><ul><li>节点 A 负责处理 0 号至 5500 号哈希槽。</li><li>节点 B 负责处理 5501 号至 11000 号哈希槽。</li><li>节点 C 负责处理 11001 号至 16384 号哈希槽。</li></ul><p>这种将哈希槽分布到不同节点的做法使得用户可以很容易地向集群中添加或者删除节点。 比如说：</p><ul><li>如果用户将新节点 D 添加到集群中， 那么集群只需要将节点 A 、B 、 C 中的某些槽移动到节点 D 就可以了。</li><li>与此类似， 如果用户要从集群中移除节点 A ， 那么集群只需要将节点 A 中的所有哈希槽移动到节点 B 和节点 C ， 然后再移除空白（不包含任何哈希槽）的节点 A 就可以了。</li></ul><p>因为将一个哈希槽从一个节点移动到另一个节点不会造成节点阻塞， 所以无论是添加新节点还是移除已存在节点， 又或者改变某个节点包含的哈希槽数量， 都不会造成集群下线。</p><h3 id="Redis-集群中的主从复制"><a href="#Redis-集群中的主从复制" class="headerlink" title="Redis 集群中的主从复制"></a>Redis 集群中的主从复制</h3><p>为了使得集群在一部分节点下线或者无法与集群的大多数（majority）节点进行通讯的情况下， 仍然可以正常运作， Redis 集群对节点使用了主从复制功能： 集群中的每个节点都有 1 个至 N 个复制品（replica）， 其中一个复制品为主节点（master）， 而其余的 N-1 个复制品为从节点（slave）。</p><p>在之前列举的节点 A 、B 、C 的例子中， 如果节点 B 下线了， 那么集群将无法正常运行， 因为集群找不到节点来处理 5501 号至 11000 号的哈希槽。</p><p>另一方面， 假如在创建集群的时候（或者至少在节点 B 下线之前）， 我们为主节点 B 添加了从节点 B1 ， 那么当主节点 B 下线的时候， 集群就会将 B1 设置为新的主节点， 并让它代替下线的主节点 B ， 继续处理 5501 号至 11000 号的哈希槽， 这样集群就不会因为主节点 B 的下线而无法正常运作了。</p><p>不过如果节点 B 和 B1 都下线的话， Redis 集群还是会停止运作。</p><h3 id="Redis-集群的一致性保证（guarantee）"><a href="#Redis-集群的一致性保证（guarantee）" class="headerlink" title="Redis 集群的一致性保证（guarantee）"></a>Redis 集群的一致性保证（guarantee）</h3><p>Redis 集群不保证数据的强一致性（strong consistency）： 在特定条件下， Redis 集群可能会丢失已经被执行过的写命令。</p><p>使用异步复制（asynchronous replication）是 Redis 集群可能会丢失写命令的其中一个原因。 考虑以下这个写命令的例子：</p><ul><li>客户端向主节点 B 发送一条写命令。</li><li>主节点 B 执行写命令，并向客户端返回命令回复。</li><li>主节点 B 将刚刚执行的写命令复制给它的从节点 B1 、 B2 和 B3 。</li></ul><p>如你所见， 主节点对命令的复制工作发生在返回命令回复之后， 因为如果每次处理命令请求都需要等待复制操作完成的话， 那么主节点处理命令请求的速度将极大地降低 —— 我们必须在性能和一致性之间做出权衡。</p><p><strong>Note</strong></p><pre><code>如果真的有必要的话， Redis 集群可能会在将来提供同步地（synchronou）执行写命令的方法。</code></pre><p>Redis 集群另外一种可能会丢失命令的情况是， 集群出现网络分裂（network partition）， 并且一个客户端与至少包括一个主节点在内的少数（minority）实例被孤立。</p><p>举个例子， 假设集群包含 A 、 B 、 C 、 A1 、 B1 、 C1 六个节点， 其中 A 、B 、C 为主节点， 而 A1 、B1 、C1 分别为三个主节点的从节点， 另外还有一个客户端 Z1 。</p><p>假设集群中发生网络分裂， 那么集群可能会分裂为两方， 大多数（majority）的一方包含节点 A 、C 、A1 、B1 和 C1 ， 而少数（minority）的一方则包含节点 B 和客户端 Z1 。</p><p>在网络分裂期间， 主节点 B 仍然会接受 Z1 发送的写命令：</p><ul><li>如果网络分裂出现的时间很短， 那么集群会继续正常运行；</li><li>但是， 如果网络分裂出现的时间足够长， 使得大多数一方将从节点 B1 设置为新的主节点， 并使用 B1 来代替原来的主节点 B ， 那么 Z1 发送给主节点 B 的写命令将丢失。</li></ul><p>注意， 在网络分裂出现期间， 客户端 Z1 可以向主节点 B 发送写命令的最大时间是有限制的， 这一时间限制称为节点超时时间（node timeout）， 是 Redis 集群的一个重要的配置选项：</p><ul><li>对于大多数一方来说， 如果一个主节点未能在节点超时时间所设定的时限内重新联系上集群， 那么集群会将这个主节点视为下线， 并使用从节点来代替这个主节点继续工作。</li><li>对于少数一方， 如果一个主节点未能在节点超时时间所设定的时限内重新联系上集群， 那么它将停止处理写命令， 并向客户端报告错误。</li></ul><h3 id="创建并使用-Redis-集群"><a href="#创建并使用-Redis-集群" class="headerlink" title="创建并使用 Redis 集群"></a>创建并使用 Redis 集群</h3><p>Redis 集群由多个运行在集群模式（cluster mode）下的 Redis 实例组成， 实例的集群模式需要通过配置来开启， 开启集群模式的实例将可以使用集群特有的功能和命令。</p><p>以下是一个包含了最少选项的集群配置文件示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">port 7000</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes.conf</span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure><p>文件中的 cluster-enabled 选项用于开实例的集群模式， 而 cluster-conf-file 选项则设定了保存节点配置文件的路径， 默认值为 nodes.conf 。</p><p>节点配置文件无须人为修改， 它由 Redis 集群在启动时创建， 并在有需要时自动进行更新。</p><p>要让集群正常运作至少需要三个主节点， 不过在刚开始试用集群功能时， 强烈建议使用六个节点： 其中三个为主节点， 而其余三个则是各个主节点的从节点。</p><p>首先， 让我们进入一个新目录， 并创建六个以端口号为名字的子目录， 稍后我们在将每个目录中运行一个 Redis 实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir cluster-test</span><br><span class="line"><span class="built_in">cd</span> cluster-test</span><br><span class="line">mkdir 7000 7001 7002 7003 7004 7005</span><br></pre></td></tr></table></figure><p>在文件夹 7000 至 7005 中， 各创建一个 redis.conf 文件， 文件的内容可以使用上面的示例配置文件， 但记得将配置中的端口号从 7000 改为与文件夹名字相同的号码。</p><p>现在， 从 Redis Github 页面 的 unstable 分支中取出最新的 Redis 源码， 编译出可执行文件 redis-server ， 并将文件复制到 cluster-test 文件夹， 然后使用类似以下命令， 在每个标签页中打开一个实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> 7000</span><br><span class="line">../redis-server ./redis.conf</span><br></pre></td></tr></table></figure><p>实例打印的日志显示， 因为 nodes.conf 文件不存在， 所以每个节点都为它自身指定了一个新的 ID ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[82462] 26 Nov 11:56:55.329 * No cluster configuration found, I<span class="string">'m 97a3a64667477371c4479320d683e4c8db5858b1</span></span><br></pre></td></tr></table></figure><p>实例会一直使用同一个 ID ， 从而在集群中保持一个独一无二（unique）的名字。</p><p>每个节点都使用 ID 而不是 IP 或者端口号来记录其他节点， 因为 IP 地址和端口号都可能会改变， 而这个独一无二的标识符（identifier）则会在节点的整个生命周期中一直保持不变。</p><p>我们将这个标识符称为节点 ID。</p><h3 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h3><p>现在我们已经有了六个正在运行中的 Redis 实例， 接下来我们需要使用这些实例来创建集群， 并为每个节点编写配置文件。</p><p>通过使用 Redis 集群命令行工具 redis-trib ， 编写节点配置文件的工作可以非常容易地完成： redis-trib 位于 Redis 源码的 src 文件夹中， 它是一个 Ruby 程序， 这个程序通过向实例发送特殊命令来完成创建新集群， 检查集群， 或者对集群进行重新分片（reshared）等工作。</p><p>我们需要执行以下命令来创建集群：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 \</span><br><span class="line">127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005</span><br></pre></td></tr></table></figure><p>命令的意义如下：</p><ul><li>给定 redis-trib.rb 程序的命令是 create ， 这表示我们希望创建一个新的集群。</li><li>选项 –replicas 1 表示我们希望为集群中的每个主节点创建一个从节点。</li><li>之后跟着的其他参数则是实例的地址列表， 我们希望程序使用这些地址所指示的实例来创建新集群。</li></ul><p>简单来说， 以上命令的意思就是让 redis-trib 程序创建一个包含三个主节点和三个从节点的集群。</p><p>接着， redis-trib 会打印出一份预想中的配置给你看， 如果你觉得没问题的话， 就可以输入 yes ， redis-trib 就会将这份配置应用到集群当中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Creating cluster</span><br><span class="line">Connecting to node 127.0.0.1:7000: OK</span><br><span class="line">Connecting to node 127.0.0.1:7001: OK</span><br><span class="line">Connecting to node 127.0.0.1:7002: OK</span><br><span class="line">Connecting to node 127.0.0.1:7003: OK</span><br><span class="line">Connecting to node 127.0.0.1:7004: OK</span><br><span class="line">Connecting to node 127.0.0.1:7005: OK</span><br><span class="line">&gt;&gt;&gt; Performing <span class="built_in">hash</span> slots allocation on 6 nodes...</span><br><span class="line">Using 3 masters:</span><br><span class="line">127.0.0.1:7000</span><br><span class="line">127.0.0.1:7001</span><br><span class="line">127.0.0.1:7002</span><br><span class="line">127.0.0.1:7000 replica <span class="comment">#1 is 127.0.0.1:7003</span></span><br><span class="line">127.0.0.1:7001 replica <span class="comment">#1 is 127.0.0.1:7004</span></span><br><span class="line">127.0.0.1:7002 replica <span class="comment">#1 is 127.0.0.1:7005</span></span><br><span class="line">M: 9991306f0e50640a5684f1958fd754b38fa034c9 127.0.0.1:7000</span><br><span class="line">slots:0-5460 (5461 slots) master</span><br><span class="line">M: e68e52cee0550f558b03b342f2f0354d2b8a083b 127.0.0.1:7001</span><br><span class="line">slots:5461-10921 (5461 slots) master</span><br><span class="line">M: 393c6df5eb4b4cec323f0e4ca961c8b256e3460a 127.0.0.1:7002</span><br><span class="line">slots:10922-16383 (5462 slots) master</span><br><span class="line">S: 48b728dbcedff6bf056231eb44990b7d1c35c3e0 127.0.0.1:7003</span><br><span class="line">S: 345ede084ac784a5c030a0387f8aaa9edfc59af3 127.0.0.1:7004</span><br><span class="line">S: 3375be2ccc321932e8853234ffa87ee9fde973ff 127.0.0.1:7005</span><br><span class="line">Can I <span class="built_in">set</span> the above configuration? (<span class="built_in">type</span> <span class="string">'yes'</span> to accept): yes</span><br></pre></td></tr></table></figure><p>输入 yes 并按下回车确认之后， 集群就会将配置应用到各个节点， 并连接起（join）各个节点 —— 也即是， 让各个节点开始互相通讯：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Nodes configuration updated</span><br><span class="line">&gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster</span><br><span class="line">Waiting <span class="keyword">for</span> the cluster to join...</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7000)</span><br><span class="line">M: 9991306f0e50640a5684f1958fd754b38fa034c9 127.0.0.1:7000</span><br><span class="line">slots:0-5460 (5461 slots) master</span><br><span class="line">M: e68e52cee0550f558b03b342f2f0354d2b8a083b 127.0.0.1:7001</span><br><span class="line">slots:5461-10921 (5461 slots) master</span><br><span class="line">M: 393c6df5eb4b4cec323f0e4ca961c8b256e3460a 127.0.0.1:7002</span><br><span class="line">slots:10922-16383 (5462 slots) master</span><br><span class="line">M: 48b728dbcedff6bf056231eb44990b7d1c35c3e0 127.0.0.1:7003</span><br><span class="line">slots: (0 slots) master</span><br><span class="line">M: 345ede084ac784a5c030a0387f8aaa9edfc59af3 127.0.0.1:7004</span><br><span class="line">slots: (0 slots) master</span><br><span class="line">M: 3375be2ccc321932e8853234ffa87ee9fde973ff 127.0.0.1:7005</span><br><span class="line">slots: (0 slots) master</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br></pre></td></tr></table></figure><p>如果一切正常的话， redis-trib 将输出以下信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure><p>这表示集群中的 16384 个槽都有至少一个主节点在处理， 集群运作正常。</p><h3 id="集群的客户端"><a href="#集群的客户端" class="headerlink" title="集群的客户端"></a>集群的客户端</h3><p>Redis 集群现阶段的一个问题是客户端实现很少。 以下是一些我知道的实现：</p><ul><li>redis-rb-cluster 是我（@antirez）编写的 Ruby 实现， 用于作为其他实现的参考。 该实现是对 redis-rb 的一个简单包装， 高效地实现了与集群进行通讯所需的最少语义（semantic）。</li><li>redis-py-cluster 看上去是 redis-rb-cluster 的一个 Python 版本， 这个项目有一段时间没有更新了（最后一次提交是在六个月之前）， 不过可以将这个项目用作学习集群的起点。</li><li>流行的 Predis 曾经对早期的 Redis 集群有过一定的支持， 但我不确定它对集群的支持是否完整， 也不清楚它是否和最新版本的 Redis 集群兼容 （因为新版的 Redis 集群将槽的数量从 4k 改为 16k 了）。</li><li>Redis unstable 分支中的 redis-cli 程序实现了非常基本的集群支持， 可以使用命令 redis-cli -c 来启动。</li></ul><p>测试 Redis 集群比较简单的办法就是使用 redis-rb-cluster 或者 redis-cli ， 接下来我们将使用 redis-cli 为例来进行演示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -c -p 7000</span><br><span class="line">redis 127.0.0.1:7000&gt; <span class="built_in">set</span> foo bar</span><br><span class="line">-&gt; Redirected to slot [12182] located at 127.0.0.1:7002</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:7002&gt; <span class="built_in">set</span> hello world</span><br><span class="line">-&gt; Redirected to slot [866] located at 127.0.0.1:7000</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:7000&gt; get foo</span><br><span class="line">-&gt; Redirected to slot [12182] located at 127.0.0.1:7002</span><br><span class="line"><span class="string">"bar"</span></span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:7000&gt; get hello</span><br><span class="line">-&gt; Redirected to slot [866] located at 127.0.0.1:7000</span><br><span class="line"><span class="string">"world"</span></span><br></pre></td></tr></table></figure><p>redis-cli 对集群的支持是非常基本的， 所以它总是依靠 Redis 集群节点来将它转向（redirect）至正确的节点。</p><p>一个真正的（serious）集群客户端应该做得比这更好： 它应该用缓存记录起哈希槽与节点地址之间的映射（map）， 从而直接将命令发送到正确的节点上面。</p><p>这种映射只会在集群的配置出现某些修改时变化， 比如说， 在一次故障转移（failover）之后， 或者系统管理员通过添加节点或移除节点来修改了集群的布局（layout）之后， 诸如此类。</p><h3 id="使用-redis-rb-cluster-编写一个示例应用"><a href="#使用-redis-rb-cluster-编写一个示例应用" class="headerlink" title="使用 redis-rb-cluster 编写一个示例应用"></a>使用 redis-rb-cluster 编写一个示例应用</h3><p>在展示如何使用集群进行故障转移、重新分片等操作之前， 我们需要创建一个示例应用， 了解一些与 Redis 集群客户端进行交互的基本方法。</p><p>在运行示例应用的过程中， 我们会尝试让节点进入失效状态， 又或者开始一次重新分片， 以此来观察 Redis 集群在真实世界运行时的表现， 并且为了让这个示例尽可能地有用， 我们会让这个应用向集群进行写操作。</p><p>本节将通过两个示例应用来展示 redis-rb-cluster 的基本用法， 以下是本节的第一个示例应用， 它是一个名为 example.rb 的文件， 包含在redis-rb-cluster 项目里面：</p><figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'./cluster'</span></span><br><span class="line"></span><br><span class="line">startup_nodes = [</span><br><span class="line">    &#123;<span class="symbol">:host</span> =&gt; <span class="string">"127.0.0.1"</span>, <span class="symbol">:port</span> =&gt; <span class="number">7000</span>&#125;,</span><br><span class="line">    &#123;<span class="symbol">:host</span> =&gt; <span class="string">"127.0.0.1"</span>, <span class="symbol">:port</span> =&gt; <span class="number">7001</span>&#125;</span><br><span class="line">]</span><br><span class="line">rc = RedisCluster.new(startup_nodes,<span class="number">32</span>,<span class="symbol">:timeout</span> =&gt; <span class="number">0</span>.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">last = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> last</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        last = rc.get(<span class="string">"__last__"</span>)</span><br><span class="line">        last = <span class="number">0</span> <span class="keyword">if</span> !last</span><br><span class="line">    <span class="keyword">rescue</span> =&gt; e</span><br><span class="line">        puts <span class="string">"error <span class="subst">#&#123;e.to_s&#125;</span>"</span></span><br><span class="line">        sleep <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">((last.to_i+<span class="number">1</span>)..<span class="number">1000000000</span>).each&#123;<span class="params">|x|</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        rc.set(<span class="string">"foo<span class="subst">#&#123;x&#125;</span>"</span>,x)</span><br><span class="line">        puts rc.get(<span class="string">"foo<span class="subst">#&#123;x&#125;</span>"</span>)</span><br><span class="line">        rc.set(<span class="string">"__last__"</span>,x)</span><br><span class="line">    <span class="keyword">rescue</span> =&gt; e</span><br><span class="line">        puts <span class="string">"error <span class="subst">#&#123;e.to_s&#125;</span>"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    sleep <span class="number">0</span>.<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个应用所做的工作非常简单： 它不断地以 foo<number> 为键， number 为值， 使用 SET key value [EX seconds] [PX milliseconds] [NX|XX] 命令向数据库设置键值对。</number></p><p>如果我们执行这个应用的话， 应用将按顺序执行以下命令：</p><ul><li>SET foo0 0</li><li>SET foo1 1</li><li>SET foo2 2</li><li>诸如此类。。。</li></ul><p>代码中的每个集群操作都使用一个 begin 和 rescue 代码块（block）包裹着， 因为我们希望在代码出错时， 将错误打印到终端上面， 而不希望应用因为异常（exception）而退出。</p><p>代码的第七行是代码中第一个有趣的地方， 它创建了一个 Redis 集群对象， 其中创建对象所使用的参数及其意义如下：</p><ul><li>第一个参数是记录了启动节点的 startup_nodes 列表， 列表中包含了两个集群节点的地址。</li><li>第二个参数指定了对于集群中的各个不同的节点， Redis 集群对象可以获得（take）的最大连接数 （maximum number of connections this object is allowed to take）。</li><li>第三个参数 timeout 指定了一个命令在执行多久之后， 才会被看作是执行失败。</li></ul><p>记住， 启动列表中并不需要包含所有集群节点的地址， 但这些地址中至少要有一个是有效的（reachable）： 一旦 redis-rb-cluster 成功连接上集群中的某个节点时， 集群节点列表就会被自动更新， 任何真正的（serious）的集群客户端都应该这样做。</p><p>现在， 程序创建的 Redis 集群对象实例被保存到 rc 变量里面， 我们可以将这个对象当作普通 Redis 对象实例来使用。</p><p>在十一至十九行， 我们先尝试阅读计数器中的值， 如果计数器不存在的话， 我们才将计数器初始化为 0 ： 通过将计数值保存到 Redis 的计数器里面， 我们可以在示例重启之后， 仍然继续之前的执行过程， 而不必每次重启之后都从 foo0 开始重新设置键值对。</p><p>为了让程序在集群下线的情况下， 仍然不断地尝试读取计数器的值， 我们将读取操作包含在了一个 while 循环里面， 一般的应用程序并不需要如此小心。</p><p>二十一至三十行是程序的主循环， 这个循环负责设置键值对， 并在设置出错时打印错误信息。</p><p>程序在主循环的末尾添加了一个 sleep 调用， 让写操作的执行速度变慢， 帮助执行示例的人更容易看清程序的输出。</p><p>执行 example.rb 程序将产生以下输出：</p><figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ruby ./example.rb</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这个程序并不是十分有趣， 稍后我们就会看到一个更有趣的集群应用示例， 不过在此之前， 让我们先使用这个示例来演示集群的重新分片操作。</p><h3 id="对集群进行重新分片"><a href="#对集群进行重新分片" class="headerlink" title="对集群进行重新分片"></a>对集群进行重新分片</h3><p>现在， 让我们来试试对集群进行重新分片操作。</p><p>在执行重新分片的过程中， 请让你的 example.rb 程序处于运行状态， 这样你就会看到， 重新分片并不会对正在运行的集群程序产生任何影响， 你也可以考虑将 example.rb 中的 sleep 调用删掉， 从而让重新分片操作在近乎真实的写负载下执行。</p><p>重新分片操作基本上就是将某些节点上的哈希槽移动到另外一些节点上面， 和创建集群一样， 重新分片也可以使用 redis-trib 程序来执行。</p><p>执行以下命令可以开始一次重新分片操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-trib.rb reshard 127.0.0.1:7000</span><br></pre></td></tr></table></figure><p>你只需要指定集群中其中一个节点的地址， redis-trib 就会自动找到集群中的其他节点。</p><p>目前 redis-trib 只能在管理员的协助下完成重新分片的工作， 要让 redis-trib 自动将哈希槽从一个节点移动到另一个节点， 目前来说还做不到 （不过实现这个功能并不难）。</p><p>执行 redis-trib 的第一步就是设定你打算移动的哈希槽的数量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-trib.rb reshard 127.0.0.1:7000</span><br><span class="line">Connecting to node 127.0.0.1:7000: OK</span><br><span class="line">Connecting to node 127.0.0.1:7002: OK</span><br><span class="line">Connecting to node 127.0.0.1:7005: OK</span><br><span class="line">Connecting to node 127.0.0.1:7001: OK</span><br><span class="line">Connecting to node 127.0.0.1:7003: OK</span><br><span class="line">Connecting to node 127.0.0.1:7004: OK</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7000)</span><br><span class="line">M: 9991306f0e50640a5684f1958fd754b38fa034c9 127.0.0.1:7000</span><br><span class="line">slots:0-5460 (5461 slots) master</span><br><span class="line">M: 393c6df5eb4b4cec323f0e4ca961c8b256e3460a 127.0.0.1:7002</span><br><span class="line">slots:10922-16383 (5462 slots) master</span><br><span class="line">S: 3375be2ccc321932e8853234ffa87ee9fde973ff 127.0.0.1:7005</span><br><span class="line">slots: (0 slots) slave</span><br><span class="line">M: e68e52cee0550f558b03b342f2f0354d2b8a083b 127.0.0.1:7001</span><br><span class="line">slots:5461-10921 (5461 slots) master</span><br><span class="line">S: 48b728dbcedff6bf056231eb44990b7d1c35c3e0 127.0.0.1:7003</span><br><span class="line">slots: (0 slots) slave</span><br><span class="line">S: 345ede084ac784a5c030a0387f8aaa9edfc59af3 127.0.0.1:7004</span><br><span class="line">slots: (0 slots) slave</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br><span class="line">How many slots <span class="keyword">do</span> you want to move (from 1 to 16384)? 1000</span><br></pre></td></tr></table></figure><p>我们将打算移动的槽数量设置为 1000 个， 如果 example.rb 程序一直运行着的话， 现在 1000 个槽里面应该有不少键了。</p><p>除了移动的哈希槽数量之外， redis-trib 还需要知道重新分片的目标（target node）， 也即是， 负责接收这 1000 个哈希槽的节点。</p><p>指定目标需要使用节点的 ID ， 而不是 IP 地址和端口。 比如说， 我们打算使用集群的第一个主节点来作为目标， 它的 IP 地址和端口是 127.0.0.1:7000 ， 而节点 ID 则是 9991306f0e50640a5684f1958fd754b38fa034c9 ， 那么我们应该向 redis-trib 提供节点的 ID ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-trib.rb reshard 127.0.0.1:7000</span><br><span class="line">...</span><br><span class="line">What is the receiving node ID? 9991306f0e50640a5684f1958fd754b38fa034c9</span><br></pre></td></tr></table></figure><p><strong>Note</strong></p><pre><code>redis-trib 会打印出集群中所有节点的 ID ， 并且我们也可以通过执行以下命令来获得节点的运行 ID ：</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-cli -p 7000 cluster nodes | grep myself</span><br><span class="line">9991306f0e50640a5684f1958fd754b38fa034c9 :0 myself,master - 0 0 0 connected 0-5460</span><br></pre></td></tr></table></figure><p>接着， redis-trib 会向你询问重新分片的源节点（source node）， 也即是， 要从哪个节点中取出 1000 个哈希槽， 并将这些槽移动到目标节点上面。</p><p>如果我们不打算从特定的节点上取出指定数量的哈希槽， 那么可以向 redis-trib 输入 all ， 这样的话， 集群中的所有主节点都会成为源节点， redis-trib 将从各个源节点中各取出一部分哈希槽， 凑够 1000 个， 然后移动到目标节点上面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-trib.rb reshard 127.0.0.1:7000</span><br><span class="line">...</span><br><span class="line">Please enter all the <span class="built_in">source</span> node IDs.</span><br><span class="line">Type <span class="string">'all'</span> to use all the nodes as <span class="built_in">source</span> nodes <span class="keyword">for</span> the <span class="built_in">hash</span> slots.</span><br><span class="line">Type <span class="string">'done'</span> once you entered all the <span class="built_in">source</span> nodes IDs.</span><br><span class="line">Source node <span class="comment">#1:all</span></span><br></pre></td></tr></table></figure><p>输入 all 并按下回车之后， redis-trib 将打印出哈希槽的移动计划， 如果你觉得没问题的话， 就可以输入 yes 并再次按下回车：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-trib.rb reshard 127.0.0.1:7000</span><br><span class="line">...</span><br><span class="line">Moving slot 11421 from 393c6df5eb4b4cec323f0e4ca961c8b256e3460a</span><br><span class="line">Moving slot 11422 from 393c6df5eb4b4cec323f0e4ca961c8b256e3460a</span><br><span class="line">Moving slot 5461 from e68e52cee0550f558b03b342f2f0354d2b8a083b</span><br><span class="line">Moving slot 5469 from e68e52cee0550f558b03b342f2f0354d2b8a083b</span><br><span class="line">...</span><br><span class="line">Moving slot 5959 from e68e52cee0550f558b03b342f2f0354d2b8a083b</span><br><span class="line">Do you want to proceed with the proposed reshard plan (yes/no)? yes</span><br></pre></td></tr></table></figure><p>输入 yes 并使用按下回车之后， redis-trib 就会正式开始执行重新分片操作， 将指定的哈希槽从源节点一个个地移动到目标节点上面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-trib.rb reshard 127.0.0.1:7000</span><br><span class="line">...</span><br><span class="line">Moving slot 5934 from 127.0.0.1:7001 to 127.0.0.1:7000:</span><br><span class="line">Moving slot 5935 from 127.0.0.1:7001 to 127.0.0.1:7000:</span><br><span class="line">Moving slot 5936 from 127.0.0.1:7001 to 127.0.0.1:7000:</span><br><span class="line">Moving slot 5937 from 127.0.0.1:7001 to 127.0.0.1:7000:</span><br><span class="line">...</span><br><span class="line">Moving slot 5959 from 127.0.0.1:7001 to 127.0.0.1:7000:</span><br></pre></td></tr></table></figure><p>在重新分片的过程中， example.rb 应该可以继续正常运行， 不会出现任何问题。</p><p>在重新分片操作执行完毕之后， 可以使用以下命令来检查集群是否正常：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-trib.rb check 127.0.0.1:7000</span><br><span class="line">Connecting to node 127.0.0.1:7000: OK</span><br><span class="line">Connecting to node 127.0.0.1:7002: OK</span><br><span class="line">Connecting to node 127.0.0.1:7005: OK</span><br><span class="line">Connecting to node 127.0.0.1:7001: OK</span><br><span class="line">Connecting to node 127.0.0.1:7003: OK</span><br><span class="line">Connecting to node 127.0.0.1:7004: OK</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7000)</span><br><span class="line">M: 9991306f0e50640a5684f1958fd754b38fa034c9 127.0.0.1:7000</span><br><span class="line">slots:0-5959,10922-11422 (6461 slots) master</span><br><span class="line">M: 393c6df5eb4b4cec323f0e4ca961c8b256e3460a 127.0.0.1:7002</span><br><span class="line">slots:11423-16383 (4961 slots) master</span><br><span class="line">S: 3375be2ccc321932e8853234ffa87ee9fde973ff 127.0.0.1:7005</span><br><span class="line">slots: (0 slots) slave</span><br><span class="line">M: e68e52cee0550f558b03b342f2f0354d2b8a083b 127.0.0.1:7001</span><br><span class="line">slots:5960-10921 (4962 slots) master</span><br><span class="line">S: 48b728dbcedff6bf056231eb44990b7d1c35c3e0 127.0.0.1:7003</span><br><span class="line">slots: (0 slots) slave</span><br><span class="line">S: 345ede084ac784a5c030a0387f8aaa9edfc59af3 127.0.0.1:7004</span><br><span class="line">slots: (0 slots) slave</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure><p>根据检查结果显示， 集群运作正常。</p><p>需要注意的就是， 在三个主节点中， 节点 127.0.0.1:7000 包含了 6461 个哈希槽， 而节点 127.0.0.1:7001 和节点 127.0.0.1:7002 都只包含了 4961 个哈希槽， 因为后两者都将自己的 500 个哈希槽移动到了节点 127.0.0.1:7000 。</p><h3 id="一个更有趣的示例应用"><a href="#一个更有趣的示例应用" class="headerlink" title="一个更有趣的示例应用"></a>一个更有趣的示例应用</h3><p>我们在前面使用的示例程序 example.rb 并不是十分有趣， 因为它只是不断地对集群进行写入， 但并不检查写入结果是否正确。 比如说， 集群可能会错误地将 example.rb 发送的所有 SET key value [EX seconds] [PX milliseconds] [NX|XX] 命令都改成了 SET foo 42 ， 但因为 example.rb 并不检查写入后的值， 所以它不会意识到集群实际上写入的值是错误的。</p><p>因为这个原因， redis-rb-cluster 项目包含了一个名为 consistency-test.rb 的示例应用， 这个应用比起 example.rb 有趣得多： 它创建了多个计数器（默认为 1000 个）， 并通过发送 INCR key 命令来增加这些计数器的值。</p><p>在增加计数器值的同时， consistency-test.rb 还执行以下操作：</p><ul><li>每次使用 INCR key 命令更新一个计数器时， 应用会记录下计数器执行 INCR key 命令之后应该有的值。 举个例子， 如果计数器的起始值为 0 ， 而这次是程序第 50 次向它发送 INCR key 命令， 那么计数器的值应该是 50 。</li><li>在每次发送 INCR key 命令之前， 程序会随机从集群中读取一个计数器的值， 并将它与自己记录的值进行对比， 看两个值是否相同。</li></ul><p>换句话说， 这个程序是一个一致性检查器（consistency checker）： 如果集群在执行 INCR key 命令的过程中， 丢失了某条 INCR key 命令， 又或者多执行了某条客户端没有确认到的 INCR key 命令， 那么检查器将察觉到这一点 —— 在前一种情况中， consistency-test.rb 记录的计数器值将比集群记录的计数器值要大； 而在后一种情况中， consistency-test.rb 记录的计数器值将比集群记录的计数器值要小。</p><p>运行 consistency-test 程序将产生类似以下的输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ruby consistency-test.rb</span><br><span class="line">925 R (0 err) | 925 W (0 err) |</span><br><span class="line">5030 R (0 err) | 5030 W (0 err) |</span><br><span class="line">9261 R (0 err) | 9261 W (0 err) |</span><br><span class="line">13517 R (0 err) | 13517 W (0 err) |</span><br><span class="line">17780 R (0 err) | 17780 W (0 err) |</span><br><span class="line">22025 R (0 err) | 22025 W (0 err) |</span><br><span class="line">25818 R (0 err) | 25818 W (0 err) |</span><br></pre></td></tr></table></figure><p>每行输出都打印了程序执行的读取次数和写入次数， 以及执行操作的过程中因为集群不可用而产生的错误数。</p><p>如果程序察觉了不一致的情况出现， 它将在输出行的末尾显式不一致的详细情况。</p><p>比如说， 如果我们在 consistency-test.rb 运行的过程中， 手动修改某个计数器的值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ redis 127.0.0.1:7000&gt; <span class="built_in">set</span> key_217 0</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>那么 consistency-test.rb 将向我们报告不一致情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">in</span> the other tab I see...)</span><br><span class="line"></span><br><span class="line">94774 R (0 err) | 94774 W (0 err) |</span><br><span class="line">98821 R (0 err) | 98821 W (0 err) |</span><br><span class="line">102886 R (0 err) | 102886 W (0 err) | 114 lost |</span><br><span class="line">107046 R (0 err) | 107046 W (0 err) | 114 lost |</span><br></pre></td></tr></table></figure><p>在我们修改计数器值的时候， 计数器的正确值是 114 （执行了 114 次 INCR key 命令）， 因为我们将计数器的值设成了 0 ， 所以 consistency-test.rb 会向我们报告说丢失了 114 个 INCR key 命令。</p><p>因为这个示例程序具有一致性检查功能， 所以我们用它来测试 Redis 集群的故障转移操作。</p><h3 id="故障转移测试"><a href="#故障转移测试" class="headerlink" title="故障转移测试"></a>故障转移测试</h3><p><strong>Note</strong></p><pre><code>在执行本节操作的过程中， 请一直运行 consistency-test 程序。</code></pre><p>要触发一次故障转移， 最简单的办法就是令集群中的某个主节点进入下线状态。</p><p>首先用以下命令列出集群中的所有主节点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -p 7000 cluster nodes | grep master</span><br><span class="line">3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 127.0.0.1:7001 master - 0 1385482984082 0 connected 5960-10921</span><br><span class="line">2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 master - 0 1385482983582 0 connected 11423-16383</span><br><span class="line">97a3a64667477371c4479320d683e4c8db5858b1 :0 myself,master - 0 0 0 connected 0-5959 10922-11422</span><br></pre></td></tr></table></figure><p>通过命令输出， 我们知道端口号为 7000 、 7001 和 7002 的节点都是主节点， 然后我们可以通过向端口号为 7002 的主节点发送 DEBUG SEGFAULT 命令， 让这个主节点崩溃：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -p 7002 debug segfault</span><br><span class="line">Error: Server closed the connection</span><br></pre></td></tr></table></figure><p>现在， 切换到运行着 consistency-test 的标签页， 可以看到， consistency-test 在 7002 下线之后的一段时间里将产生大量的错误警告信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">18849 R (0 err) | 18849 W (0 err) |</span><br><span class="line">23151 R (0 err) | 23151 W (0 err) |</span><br><span class="line">27302 R (0 err) | 27302 W (0 err) |</span><br><span class="line"></span><br><span class="line">... many error warnings here ...</span><br><span class="line"></span><br><span class="line">29659 R (578 err) | 29660 W (577 err) |</span><br><span class="line">33749 R (578 err) | 33750 W (577 err) |</span><br><span class="line">37918 R (578 err) | 37919 W (577 err) |</span><br><span class="line">42077 R (578 err) | 42078 W (577 err) |</span><br></pre></td></tr></table></figure><p>从 consistency-test 的这段输出可以看到， 集群在执行故障转移期间， 总共丢失了 578 个读命令和 577 个写命令， 但是并没有产生任何数据不一致。</p><p>这听上去可能有点奇怪， 因为在教程的开头我们提到过， Redis 使用的是异步复制， 在执行故障转移期间， 集群可能会丢失写命令。</p><p>但是在实际上， 丢失命令的情况并不常见， 因为 Redis 几乎是同时执行将命令回复发送给客户端， 以及将命令复制给从节点这两个操作， 所以实际上造成命令丢失的时间窗口是非常小的。</p><p>不过， 尽管出现的几率不高， 但丢失命令的情况还是有可能会出现的， 所以我们对 Redis 集群不能提供强一致性的这一描述仍然是正确的。</p><p>现在， 让我们使用 cluster nodes 命令， 查看集群在执行故障转移操作之后， 主从节点的布局情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -p 7000 cluster nodes</span><br><span class="line">3fc783611028b1707fd65345e763befb36454d73 127.0.0.1:7004 slave 3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 0 1385503418521 0 connected</span><br><span class="line">a211e242fc6b22a9427fed61285e85892fa04e08 127.0.0.1:7003 slave 97a3a64667477371c4479320d683e4c8db5858b1 0 1385503419023 0 connected</span><br><span class="line">97a3a64667477371c4479320d683e4c8db5858b1 :0 myself,master - 0 0 0 connected 0-5959 10922-11422</span><br><span class="line">3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7005 master - 0 1385503419023 3 connected 11423-16383</span><br><span class="line">3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 127.0.0.1:7001 master - 0 1385503417005 0 connected 5960-10921</span><br><span class="line">2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385503418016 3 connected</span><br></pre></td></tr></table></figure><p>我重启了之前下线的 127.0.0.1:7002 节点， 该节点已经从原来的主节点变成了从节点， 而现在集群中的三个主节点分别是 127.0.0.1:7000 、 127.0.0.1:7001 和 127.0.0.1:7005 ， 其中 127.0.0.1:7005 就是因为 127.0.0.1:7002 下线而变成主节点的。</p><p>cluster nodes 命令的输出有点儿复杂， 它的每一行都是由以下信息组成的：</p><ul><li>节点 ID ：例如 3fc783611028b1707fd65345e763befb36454d73 。</li><li>ip:port ：节点的 IP 地址和端口号， 例如 127.0.0.1:7000 ， 其中 :0 表示的是客户端当前连接的 IP 地址和端口号。</li><li>flags ：节点的角色（例如 master 、 slave 、 myself ）以及状态（例如 fail ，等等）。</li><li>如果节点是一个从节点的话， 那么跟在 flags 之后的将是主节点的节点 ID ： 例如 127.0.0.1:7002 的主节点的节点 ID 就是 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 。</li><li>集群最近一次向节点发送 PING 命令之后， 过去了多长时间还没接到回复。</li><li>节点最近一次返回 PONG 回复的时间。</li><li>节点的配置纪元（configuration epoch）：详细信息请参考 Redis 集群规范 。</li><li>本节点的网络连接情况：例如 connected 。</li><li>节点目前包含的槽：例如 127.0.0.1:7001 目前包含号码为 5960 至 10921 的哈希槽。</li></ul><h3 id="添加新节点到集群"><a href="#添加新节点到集群" class="headerlink" title="添加新节点到集群"></a>添加新节点到集群</h3><p>根据新添加节点的种类， 我们需要用两种方法来将新节点添加到集群里面：</p><ul><li>如果要添加的新节点是一个主节点， 那么我们需要创建一个空节点（empty node）， 然后将某些哈希桶移动到这个空节点里面。</li><li>另一方面， 如果要添加的新节点是一个从节点， 那么我们需要将这个新节点设置为集群中某个节点的复制品（replica）。</li></ul><p>本节将对以上两种情况进行介绍， 首先介绍主节点的添加方法， 然后再介绍从节点的添加方法。</p><p>无论添加的是那种节点， 第一步要做的总是添加一个空节点。</p><p>我们可以继续使用之前启动 127.0.0.1:7000 、 127.0.0.1:7001 等节点的方法， 创建一个端口号为 7006 的新节点， 使用的配置文件也和之前一样， 只是记得要将配置中的端口号改为 7000 。</p><p>以下是启动端口号为 7006 的新节点的详细步骤：</p><ol><li>在终端里创建一个新的标签页。</li><li>进入 cluster-test 文件夹。</li><li>创建并进入 7006 文件夹。</li><li>将 redis.conf 文件复制到 7006 文件夹里面，然后将配置中的端口号选项改为 7006 。</li><li>使用命令 ../../redis-server redis.conf 启动节点。</li></ol><p>如果一切正常， 那么节点应该会正确地启动。</p><p>接下来， 执行以下命令， 将这个新节点添加到集群里面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-trib.rb add-node 127.0.0.1:7006 127.0.0.1:7000</span><br></pre></td></tr></table></figure><p>命令中的 add-node 表示我们要让 redis-trib 将一个节点添加到集群里面， add-node 之后跟着的是新节点的 IP 地址和端口号， 再之后跟着的是集群中任意一个已存在节点的 IP 地址和端口号， 这里我们使用的是 127.0.0.1:7000 。</p><p>通过 cluster nodes 命令， 我们可以确认新节点 127.0.0.1:7006 已经被添加到集群里面了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:7006&gt; cluster nodes</span><br><span class="line">3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 127.0.0.1:7001 master - 0 1385543178575 0 connected 5960-10921</span><br><span class="line">3fc783611028b1707fd65345e763befb36454d73 127.0.0.1:7004 slave 3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 0 1385543179583 0 connected</span><br><span class="line">f093c80dde814da99c5cf72a7dd01590792b783b :0 myself,master - 0 0 0 connected</span><br><span class="line">2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385543178072 3 connected</span><br><span class="line">a211e242fc6b22a9427fed61285e85892fa04e08 127.0.0.1:7003 slave 97a3a64667477371c4479320d683e4c8db5858b1 0 1385543178575 0 connected</span><br><span class="line">97a3a64667477371c4479320d683e4c8db5858b1 127.0.0.1:7000 master - 0 1385543179080 0 connected 0-5959 10922-11422</span><br><span class="line">3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7005 master - 0 1385543177568 3 connected 11423-16383</span><br></pre></td></tr></table></figure><p>新节点现在已经连接上了集群， 成为集群的一份子， 并且可以对客户端的命令请求进行转向了， 但是和其他主节点相比， 新节点还有两点区别：</p><ul><li>新节点没有包含任何数据， 因为它没有包含任何哈希桶。</li><li>尽管新节点没有包含任何哈希桶， 但它仍然是一个主节点， 所以在集群需要将某个从节点升级为新的主节点时， 这个新节点不会被选中。</li></ul><p>接下来， 只要使用 redis-trib 程序， 将集群中的某些哈希桶移动到新节点里面， 新节点就会成为真正的主节点了。</p><p>因为使用 redis-trib 移动哈希桶的方法在前面已经介绍过， 所以这里就不再重复介绍了。</p><p>现在， 让我们来看看， 将一个新节点转变为某个主节点的复制品（也即是从节点）的方法。</p><p>举个例子， 如果我们打算让新节点成为 127.0.0.1:7005 的从节点， 那么我们只要用客户端连接上新节点， 然后执行以下命令就可以了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:7006&gt; cluster replicate 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e</span><br></pre></td></tr></table></figure><p>其中命令提供的 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 就是主节点 127.0.0.1:7005 的节点 ID 。</p><p>执行 cluster replicate 命令之后， 我们可以使用以下命令来确认 127.0.0.1:7006 已经成为了 ID 为 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 的节点的从节点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -p 7000 cluster nodes | grep slave | grep 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e</span><br><span class="line">f093c80dde814da99c5cf72a7dd01590792b783b 127.0.0.1:7006 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385543617702 3 connected</span><br><span class="line">2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385543617198 3 connected</span><br></pre></td></tr></table></figure><p>3c3a0c… 现在有两个从节点， 一个从节点的端口号为 7002 ， 而另一个从节点的端口号为 7006 。</p><h3 id="移除一个节点"><a href="#移除一个节点" class="headerlink" title="移除一个节点"></a>移除一个节点</h3><p>未完待续。</p><h2 id="键空间通知（keyspace-notification）"><a href="#键空间通知（keyspace-notification）" class="headerlink" title="键空间通知（keyspace notification）"></a>键空间通知（keyspace notification）</h2><h3 id="功能概览"><a href="#功能概览" class="headerlink" title="功能概览"></a>功能概览</h3><p>键空间通知使得客户端可以通过订阅频道或模式， 来接收那些以某种方式改动了 Redis 数据集的事件。</p><p>以下是一些键空间通知发送的事件的例子：</p><ul><li>所有修改键的命令。</li><li>所有接收到 LPUSH key value [value …] 命令的键。</li><li>0 号数据库中所有已过期的键。</li></ul><p>事件通过 Redis 的订阅与发布功能（pub/sub）来进行分发， 因此所有支持订阅与发布功能的客户端都可以在无须做任何修改的情况下， 直接使用键空间通知功能。</p><p>因为 Redis 目前的订阅与发布功能采取的是发送即忘（fire and forget）策略， 所以如果你的程序需要可靠事件通知（reliable notification of events）， 那么目前的键空间通知可能并不适合你： 当订阅事件的客户端断线时， 它会丢失所有在断线期间分发给它的事件。</p><p>未来将会支持更可靠的事件分发， 这种支持可能会通过让订阅与发布功能本身变得更可靠来实现， 也可能会在 Lua 脚本中对消息（message）的订阅与发布进行监听， 从而实现类似将事件推入到列表这样的操作。</p><h3 id="事件的类型"><a href="#事件的类型" class="headerlink" title="事件的类型"></a>事件的类型</h3><p>对于每个修改数据库的操作，键空间通知都会发送两种不同类型的事件。</p><p>比如说，对 0 号数据库的键 mykey 执行 DEL key [key …] 命令时， 系统将分发两条消息， 相当于执行以下两个 PUBLISH channel message 命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH __keyspace@0__:mykey del</span><br><span class="line">PUBLISH __keyevent@0__:del mykey</span><br></pre></td></tr></table></figure></p><p>订阅第一个频道 __keyspace@0__:mykey 可以接收 0 号数据库中所有修改键 mykey 的事件， 而订阅第二个频道 __keyevent@0__:del 则可以接收 0 号数据库中所有执行 del 命令的键。</p><p>以 keyspace 为前缀的频道被称为键空间通知（key-space notification）， 而以 keyevent 为前缀的频道则被称为键事件通知（key-event notification）。</p><p>当 del mykey 命令执行时：</p><ul><li>键空间频道的订阅者将接收到被执行的事件的名字，在这个例子中，就是 del 。</li><li>键事件频道的订阅者将接收到被执行事件的键的名字，在这个例子中，就是 mykey 。</li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>因为开启键空间通知功能需要消耗一些 CPU ， 所以在默认配置下， 该功能处于关闭状态。</p><p>可以通过修改 redis.conf 文件， 或者直接使用 CONFIG SET 命令来开启或关闭键空间通知功能：</p><ul><li>当 notify-keyspace-events 选项的参数为空字符串时，功能关闭。</li><li>另一方面，当参数不是空字符串时，功能开启。</li></ul><p>notify-keyspace-events 的参数可以是以下字符的任意组合， 它指定了服务器该发送哪些类型的通知：</p><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">发送的通知</th></tr></thead><tbody><tr><td style="text-align:left">K</td><td style="text-align:left">键空间通知，所有通知以 __keyspace@\&lt;db>__ 为前缀</td></tr><tr><td style="text-align:left">E</td><td style="text-align:left">键事件通知，所有通知以 __keyevent@\&lt;db>__ 为前缀</td></tr><tr><td style="text-align:left">g</td><td style="text-align:left">DEL 、 EXPIRE 、 RENAME 等类型无关的通用命令的通知</td></tr><tr><td style="text-align:left">$</td><td style="text-align:left">字符串命令的通知</td></tr><tr><td style="text-align:left">l</td><td style="text-align:left">列表命令的通知</td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">集合命令的通知</td></tr><tr><td style="text-align:left">h</td><td style="text-align:left">哈希命令的通知</td></tr><tr><td style="text-align:left">z</td><td style="text-align:left">有序集合命令的通知</td></tr><tr><td style="text-align:left">x</td><td style="text-align:left">过期事件：每当有过期键被删除时发送</td></tr><tr><td style="text-align:left">e</td><td style="text-align:left">驱逐(evict)事件：每当有键因为 maxmemory 政策而被删除时发送</td></tr><tr><td style="text-align:left">A</td><td style="text-align:left">参数 g$lshzxe 的别名</td></tr></tbody></table><p>输入的参数中至少要有一个 K 或者 E ， 否则的话， 不管其余的参数是什么， 都不会有任何通知被分发。</p><p>举个例子， 如果只想订阅键空间中和列表相关的通知， 那么参数就应该设为 Kl ， 诸如此类。</p><p>将参数设为字符串 “AKE” 表示发送所有类型的通知。</p><h3 id="命令产生的通知"><a href="#命令产生的通知" class="headerlink" title="命令产生的通知"></a>命令产生的通知</h3><p>以下列表记录了不同命令所产生的不同通知：</p><ul><li>DEL key [key …] 命令为每个被删除的键产生一个 del 通知。</li><li>RENAME key newkey 产生两个通知：为来源键（source key）产生一个 rename_from 通知，并为目标键（destination key）产生一个 rename_to 通知。</li><li>EXPIRE key seconds 和 EXPIREAT key timestamp 在键被正确设置过期时间时产生一个 expire 通知。当 EXPIREAT key timestamp 设置的时间已经过期，或者 EXPIRE key seconds 传入的时间为负数值时，键被删除，并产生一个 del 通知。</li><li>SORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern …]] [ASC | DESC] [ALPHA] [STORE destination] 在命令带有 STORE 参数时产生一个 sortstore 事件。如果 STORE 指示的用于保存排序结果的键已经存在，那么程序还会发送一个 del 事件。</li><li>SET key value [EX seconds] [PX milliseconds] [NX|XX] 以及它的所有变种（SETEX key seconds value 、 SETNX key value 和 GETSET key value）都产生 set 通知。其中 SETEX key seconds value 还会产生 expire 通知。</li><li>MSET key value [key value …] 为每个键产生一个 set 通知。</li><li>SETRANGE key offset value 产生一个 setrange 通知。</li><li>INCR key 、 DECR key 、 INCRBY key increment 和 DECRBY key decrement 都产生 incrby 通知。</li><li>INCRBYFLOAT key increment 产生 incrbyfloat 通知。</li><li>APPEND key value 产生 append 通知。</li><li>LPUSH key value [value …] 和 LPUSHX key value 都产生单个 lpush 通知，即使有多个输入元素时，也是如此。</li><li>RPUSH key value [value …] 和 RPUSHX key value 都产生单个 rpush 通知，即使有多个输入元素时，也是如此。</li><li>RPOP key 产生 rpop 通知。如果被弹出的元素是列表的最后一个元素，那么还会产生一个 del 通知。</li><li>LPOP key 产生 lpop 通知。如果被弹出的元素是列表的最后一个元素，那么还会产生一个 del 通知。</li><li>LINSERT key BEFORE|AFTER pivot value 产生一个 linsert 通知。</li><li>LSET key index value 产生一个 lset 通知。</li><li>LTRIM key start stop 产生一个 ltrim 通知。如果 LTRIM key start stop 执行之后，列表键被清空，那么还会产生一个 del 通知。</li><li>RPOPLPUSH source destination 和 BRPOPLPUSH source destination timeout 产生一个 rpop 通知，以及一个 lpush 通知。两个命令都会保证 rpop 的通知在 lpush 的通知之前分发。如果从键弹出元素之后，被弹出的列表键被清空，那么还会产生一个 del 通知。</li><li>HSET hash field value 、 HSETNX hash field value 和 HMSET 都只产生一个 hset 通知。</li><li>HINCRBY 产生一个 hincrby 通知。</li><li>HINCRBYFLOAT 产生一个 hincrbyfloat 通知。</li><li>HDEL 产生一个 hdel 通知。如果执行 HDEL 之后，哈希键被清空，那么还会产生一个 del 通知。</li><li>SADD key member [member …] 产生一个 sadd 通知，即使有多个输入元素时，也是如此。</li><li>SREM key member [member …] 产生一个 srem 通知，如果执行 SREM key member [member …] 之后，集合键被清空，那么还会产生一个 del 通知。</li><li>SMOVE source destination member 为来源键（source key）产生一个 srem 通知，并为目标键（destination key）产生一个 sadd 事件。</li><li>SPOP key 产生一个 spop 事件。如果执行 SPOP key 之后，集合键被清空，那么还会产生一个 del 通知。</li><li>SINTERSTORE destination key [key …] 、 SUNIONSTORE destination key [key …] 和 SDIFFSTORE destination key [key …] 分别产生 sinterstore 、 sunionostore 和 sdiffstore 三种通知。如果用于保存结果的键已经存在，那么还会产生一个 del 通知。</li><li>ZINCRBY key increment member 产生一个 zincr 通知。（译注：非对称，请注意。）</li><li>ZADD key score member [[score member] [score member] …] 产生一个 zadd 通知，即使有多个输入元素时，也是如此。</li><li>ZREM key member [member …] 产生一个 zrem 通知，即使有多个输入元素时，也是如此。如果执行 ZREM key member [member …] 之后，有序集合键被清空，那么还会产生一个 del 通知。</li><li>ZREMRANGEBYSCORE key min max 产生一个 zrembyscore 通知。（译注：非对称，请注意。）如果用于保存结果的键已经存在，那么还会产生一个 del 通知。</li><li>ZREMRANGEBYRANK key start stop 产生一个 zrembyrank 通知。（译注：非对称，请注意。）如果用于保存结果的键已经存在，那么还会产生一个 del 通知。</li><li>ZINTERSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX] 和 ZUNIONSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX] 分别产生 zinterstore 和 zunionstore 两种通知。如果用于保存结果的键已经存在，那么还会产生一个 del 通知。</li><li>每当一个键因为过期而被删除时，产生一个 expired 通知。</li><li>每当一个键因为 maxmemory 政策而被删除以回收内存时，产生一个 evicted 通知。</li></ul><p><strong>Note</strong></p><pre><code>所有命令都只在键真的被改动了之后，才会产生通知。</code></pre><p>比如说，当 SREM key member [member …] 试图删除不存在于集合的元素时，删除操作会执行失败，因为没有真正的改动键，所以这一操作不会发送通知。</p><p>如果对命令所产生的通知有疑问， 最好还是使用以下命令， 自己来验证一下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli config <span class="built_in">set</span> notify-keyspace-events KEA</span><br><span class="line">$ redis-cli --csv psubscribe <span class="string">'__key*__:*'</span></span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line"><span class="string">"psubscribe"</span>,<span class="string">"__key*__:*"</span>,1</span><br></pre></td></tr></table></figure></p><p>然后， 只要在其他终端里用 Redis 客户端发送命令， 就可以看到产生的通知了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"pmessage"</span>,<span class="string">"__key*__:*"</span>,<span class="string">"__keyspace@0__:foo"</span>,<span class="string">"set"</span></span><br><span class="line"><span class="string">"pmessage"</span>,<span class="string">"__key*__:*"</span>,<span class="string">"__keyevent@0__:set"</span>,<span class="string">"foo"</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h3 id="过期通知的发送时间"><a href="#过期通知的发送时间" class="headerlink" title="过期通知的发送时间"></a>过期通知的发送时间</h3><p>Redis 使用以下两种方式删除过期的键：</p><ul><li>当一个键被访问时，程序会对这个键进行检查，如果键已经过期，那么该键将被删除。</li><li>底层系统会在后台渐进地查找并删除那些过期的键，从而处理那些已经过期、但是不会被访问到的键。</li></ul><p>当过期键被以上两个程序的任意一个发现、 并且将键从数据库中删除时， Redis 会产生一个 expired 通知。</p><p>Redis 并不保证生存时间（TTL）变为 0 的键会立即被删除： 如果程序没有访问这个过期键， 或者带有生存时间的键非常多的话， 那么在键的生存时间变为 0 ， 直到键真正被删除这中间， 可能会有一段比较显著的时间间隔。</p><p>因此， Redis 产生 expired 通知的时间为过期键被删除的时候， 而不是键的生存时间变为 0 的时候。</p><h2 id="通信协议（protocol）"><a href="#通信协议（protocol）" class="headerlink" title="通信协议（protocol）"></a>通信协议（protocol）</h2><p>Redis 协议在以下三个目标之间进行折中：</p><ul><li>易于实现</li><li>可以高效地被计算机分析（parse）</li><li>可以很容易地被人类读懂</li></ul><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>客户端和服务器通过 TCP 连接来进行数据交互， 服务器默认的端口号为 6379 。</p><p>客户端和服务器发送的命令或数据一律以 \r\n （CRLF）结尾。</p><h3 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h3><p>Redis 服务器接受命令以及命令的参数。</p><p>服务器会在接到命令之后，对命令进行处理，并将命令的回复传送回客户端。</p><h3 id="新版统一请求协议"><a href="#新版统一请求协议" class="headerlink" title="新版统一请求协议"></a>新版统一请求协议</h3><p>新版统一请求协议在 Redis 1.2 版本中引入， 并最终在 Redis 2.0 版本成为 Redis 服务器通信的标准方式。</p><p>你的 Redis 客户端应该按照这个新版协议来进行实现。</p><p>在这个协议中， 所有发送至 Redis 服务器的参数都是二进制安全（binary safe）的。</p><p>以下是这个协议的一般形式：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*&lt;参数数量&gt; CR LF</span><br><span class="line">$&lt;参数 1 的字节数量&gt; CR LF</span><br><span class="line">&lt;参数 1 的数据&gt; CR LF</span><br><span class="line">...</span><br><span class="line">$&lt;参数 N 的字节数量&gt; CR LF</span><br><span class="line">&lt;参数 N 的数据&gt; CR LF</span><br></pre></td></tr></table></figure></p><p><strong>Note</strong></p><pre><code>译注：命令本身也作为协议的其中一个参数来发送。</code></pre><p>举个例子， 以下是一个命令协议的打印版本：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*3</span><br><span class="line"><span class="variable">$3</span></span><br><span class="line">SET</span><br><span class="line"><span class="variable">$5</span></span><br><span class="line">mykey</span><br><span class="line"><span class="variable">$7</span></span><br><span class="line">myvalue</span><br></pre></td></tr></table></figure></p><p>这个命令的实际协议值如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"*3\r\n<span class="variable">$3</span>\r\nSET\r\n<span class="variable">$5</span>\r\nmykey\r\n<span class="variable">$7</span>\r\nmyvalue\r\n"</span></span><br></pre></td></tr></table></figure></p><p>稍后我们会看到， 这种格式除了用作命令请求协议之外， 也用在命令的回复协议中： 这种只有一个参数的回复格式被称为批量回复（Bulk Reply）。</p><p>统一协议请求原本是用在回复协议中， 用于将列表的多个项返回给客户端的， 这种回复格式被称为多条批量回复（Multi Bulk Reply）。</p><p>一个多条批量回复以 *\&lt;argc>\r\n 为前缀， 后跟多条不同的批量回复， 其中 argc 为这些批量回复的数量。</p><h3 id="回复"><a href="#回复" class="headerlink" title="回复"></a>回复</h3><p>Redis 命令会返回多种不同类型的回复。</p><p>通过检查服务器发回数据的第一个字节， 可以确定这个回复是什么类型：</p><ul><li>状态回复（status reply）的第一个字节是 “+”</li><li>错误回复（error reply）的第一个字节是 “-“</li><li>整数回复（integer reply）的第一个字节是 “:”</li><li>批量回复（bulk reply）的第一个字节是 “$”</li><li>多条批量回复（multi bulk reply）的第一个字节是 “*”</li></ul><h3 id="状态回复"><a href="#状态回复" class="headerlink" title="状态回复"></a>状态回复</h3><p>一个状态回复（或者单行回复，single line reply）是一段以 “+” 开始、 “\r\n” 结尾的单行字符串。</p><p>以下是一个状态回复的例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+OK</span><br></pre></td></tr></table></figure></p><p>客户端库应该返回 “+” 号之后的所有内容。 比如在在上面的这个例子中， 客户端就应该返回字符串 “OK” 。</p><p>状态回复通常由那些不需要返回数据的命令返回，这种回复不是二进制安全的，它也不能包含新行。</p><p>状态回复的额外开销非常少，只需要三个字节（开头的 “+” 和结尾的 CRLF）。</p><h3 id="错误回复"><a href="#错误回复" class="headerlink" title="错误回复"></a>错误回复</h3><p>错误回复和状态回复非常相似， 它们之间的唯一区别是， 错误回复的第一个字节是 “-“ ， 而状态回复的第一个字节是 “+” 。</p><p>错误回复只在某些地方出现问题时发送： 比如说， 当用户对不正确的数据类型执行命令， 或者执行一个不存在的命令， 等等。</p><p>一个客户端库应该在收到错误回复时产生一个异常。</p><p>以下是两个错误回复的例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-ERR unknown <span class="built_in">command</span> <span class="string">'foobar'</span></span><br><span class="line">-WRONGTYPE Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure></p><p>在 “-“ 之后，直到遇到第一个空格或新行为止，这中间的内容表示所返回错误的类型。</p><p>ERR 是一个通用错误，而 WRONGTYPE 则是一个更特定的错误。 一个客户端实现可以为不同类型的错误产生不同类型的异常， 或者提供一种通用的方式， 让调用者可以通过提供字符串形式的错误名来捕捉（trap）不同的错误。</p><p>不过这些特性用得并不多， 所以并不是特别重要， 一个受限的（limited）客户端可以通过简单地返回一个逻辑假（false）来表示一个通用的错误条件。</p><h3 id="整数回复"><a href="#整数回复" class="headerlink" title="整数回复"></a>整数回复</h3><p>整数回复就是一个以 “:” 开头， CRLF 结尾的字符串表示的整数。</p><p>比如说， “:0\r\n” 和 “:1000\r\n” 都是整数回复。</p><p>返回整数回复的其中两个命令是 INCR key 和 LASTSAVE 。 被返回的整数没有什么特殊的含义， INCR key 返回键的一个自增后的整数值， 而 LASTSAVE 则返回一个 UNIX 时间戳， 返回值的唯一限制是这些数必须能够用 64 位有符号整数表示。</p><p>整数回复也被广泛地用于表示逻辑真和逻辑假： 比如 EXISTS key 和 SISMEMBER key member 都用返回值 1 表示真， 0 表示假。</p><p>其他一些命令， 比如 SADD key member [member …] 、 SREM key member [member …] 和 SETNX key value ， 只在操作真正被执行了的时候， 才返回 1 ， 否则返回 0 。</p><p>以下命令都返回整数回复： SETNX key value 、 DEL key [key …] 、 EXISTS key 、 INCR key 、 INCRBY key increment 、 DECR key 、 DECRBY key decrement 、 DBSIZE 、 LASTSAVE 、 RENAMENX key newkey 、 MOVE key db 、 LLEN key 、 SADD key member [member …] 、 SREM key member [member …] 、 SISMEMBER key member 、 SCARD key 。</p><h3 id="批量回复"><a href="#批量回复" class="headerlink" title="批量回复"></a>批量回复</h3><p>服务器使用批量回复来返回二进制安全的字符串，字符串的最大长度为 512 MB 。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">客户端：GET mykey</span><br><span class="line">服务器：foobar</span><br></pre></td></tr></table></figure></p><p>服务器发送的内容中：</p><ul><li>第一字节为 “$” 符号</li><li>接下来跟着的是表示实际回复长度的数字值</li><li>之后跟着一个 CRLF</li><li>再后面跟着的是实际回复数据</li><li>最末尾是另一个 CRLF</li></ul><p>对于前面的 GET key 命令，服务器实际发送的内容为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"<span class="variable">$6</span>\r\nfoobar\r\n"</span></span><br></pre></td></tr></table></figure></p><p>如果被请求的值不存在， 那么批量回复会将特殊值 -1 用作回复的长度值， 就像这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">客户端：GET non-existing-key</span><br><span class="line">服务器：$-1</span><br></pre></td></tr></table></figure></p><p>这种回复称为空批量回复（NULL Bulk Reply）。</p><p>当请求对象不存在时，客户端应该返回空对象，而不是空字符串： 比如 Ruby 库应该返回 nil ， 而 C 库应该返回 NULL （或者在回复对象中设置一个特殊标志）， 诸如此类。</p><h3 id="多条批量回复"><a href="#多条批量回复" class="headerlink" title="多条批量回复"></a>多条批量回复</h3><p>像 LRANGE key start stop 这样的命令需要返回多个值， 这一目标可以通过多条批量回复来完成。</p><p>多条批量回复是由多个回复组成的数组， 数组中的每个元素都可以是任意类型的回复， 包括多条批量回复本身。</p><p>多条批量回复的第一个字节为 “*” ， 后跟一个字符串表示的整数值， 这个值记录了多条批量回复所包含的回复数量， 再后面是一个 CRLF 。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">客户端： LRANGE mylist 0 3</span><br><span class="line">服务器： *4</span><br><span class="line">服务器： <span class="variable">$3</span></span><br><span class="line">服务器： foo</span><br><span class="line">服务器： <span class="variable">$3</span></span><br><span class="line">服务器： bar</span><br><span class="line">服务器： <span class="variable">$5</span></span><br><span class="line">服务器： Hello</span><br><span class="line">服务器： <span class="variable">$5</span></span><br><span class="line">服务器： World</span><br></pre></td></tr></table></figure></p><p>在上面的示例中，服务器发送的所有字符串都由 CRLF 结尾。</p><p>正如你所见到的那样， 多条批量回复所使用的格式， 和客户端发送命令时使用的统一请求协议的格式一模一样。 它们之间的唯一区别是：</p><ul><li>统一请求协议只发送批量回复。</li><li>而服务器应答命令时所发送的多条批量回复，则可以包含任意类型的回复。</li></ul><p>以下例子展示了一个多条批量回复， 回复中包含四个整数值， 以及一个二进制安全字符串：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*5\r\n</span><br><span class="line">:1\r\n</span><br><span class="line">:2\r\n</span><br><span class="line">:3\r\n</span><br><span class="line">:4\r\n</span><br><span class="line"><span class="variable">$6</span>\r\n</span><br><span class="line">foobar\r\n</span><br></pre></td></tr></table></figure></p><p>在回复的第一行， 服务器发送 *5\r\n ， 表示这个多条批量回复包含 5 条回复， 再后面跟着的则是 5 条回复的正文。</p><p>多条批量回复也可以是空白的（empty）， 就像这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">客户端： LRANGE nokey 0 1</span><br><span class="line">服务器： *0\r\n</span><br></pre></td></tr></table></figure></p><p>无内容的多条批量回复（null multi bulk reply）也是存在的， 比如当 BLPOP key [key …] timeout 命令的阻塞时间超过最大时限时， 它就返回一个无内容的多条批量回复， 这个回复的计数值为 -1 ：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">客户端： BLPOP key 1</span><br><span class="line">服务器： *-1\r\n</span><br></pre></td></tr></table></figure></p><p>客户端库应该区别对待空白多条回复和无内容多条回复： 当 Redis 返回一个无内容多条回复时， 客户端库应该返回一个 null 对象， 而不是一个空数组。</p><h3 id="多条批量回复中的空元素"><a href="#多条批量回复中的空元素" class="headerlink" title="多条批量回复中的空元素"></a>多条批量回复中的空元素</h3><p>多条批量回复中的元素可以将自身的长度设置为 -1 ， 从而表示该元素不存在， 并且也不是一个空白字符串（empty string）。</p><p>当 SORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern …]] [ASC | DESC] [ALPHA] [STORE destination] 命令使用 GET pattern 选项对一个不存在的键进行操作时， 就会发生多条批量回复中带有空白元素的情况。</p><p>以下例子展示了一个包含空元素的多重批量回复：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">服务器： *3</span><br><span class="line">服务器： <span class="variable">$3</span></span><br><span class="line">服务器： foo</span><br><span class="line">服务器： $-1</span><br><span class="line">服务器： <span class="variable">$3</span></span><br><span class="line">服务器： bar</span><br></pre></td></tr></table></figure></p><p>其中， 回复中的第二个元素为空。</p><p>对于这个回复， 客户端库应该返回类似于这样的回复：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"foo"</span>, nil, <span class="string">"bar"</span>]</span><br></pre></td></tr></table></figure></p><h3 id="多命令和流水线"><a href="#多命令和流水线" class="headerlink" title="多命令和流水线"></a>多命令和流水线</h3><p>客户端可以通过流水线， 在一次写入操作中发送多个命令：</p><ul><li>在发送新命令之前， 无须阅读前一个命令的回复。</li><li>多个命令的回复会在最后一并返回。</li></ul><h3 id="内联命令"><a href="#内联命令" class="headerlink" title="内联命令"></a>内联命令</h3><p>当你需要和 Redis 服务器进行沟通， 但又找不到 redis-cli ， 而手上只有 telnet 的时候， 你可以通过 Redis 特别为这种情形而设的内联命令格式来发送命令。</p><p>以下是一个客户端和服务器使用内联命令来进行交互的例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">客户端： PING</span><br><span class="line">服务器： +PONG</span><br></pre></td></tr></table></figure></p><p>以下另一个返回整数值的内联命令的例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">客户端： EXISTS somekey</span><br><span class="line">服务器： :0</span><br></pre></td></tr></table></figure></p><p>因为没有了统一请求协议中的 “*” 项来声明参数的数量， 所以在 telnet 会话输入命令的时候， 必须使用空格来分割各个参数， 服务器在接收到数据之后， 会按空格对用户的输入进行分析（parse）， 并获取其中的命令参数。</p><h3 id="高性能-Redis-协议分析器"><a href="#高性能-Redis-协议分析器" class="headerlink" title="高性能 Redis 协议分析器"></a>高性能 Redis 协议分析器</h3><p>尽管 Redis 的协议非常利于人类阅读， 定义也很简单， 但这个协议的实现性能仍然可以和二进制协议一样快。</p><p>因为 Redis 协议将数据的长度放在数据正文之前， 所以程序无须像 JSON 那样， 为了寻找某个特殊字符而扫描整个 payload ， 也无须对发送至服务器的 payload 进行转义（quote）。</p><p>程序可以在对协议文本中的各个字符进行处理的同时， 查找 CR 字符， 并计算出批量回复或多条批量回复的长度， 就像这样：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = <span class="string">"$123\r\n"</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    p++;</span><br><span class="line">    <span class="keyword">while</span>(*p != <span class="string">'\r'</span>) &#123;</span><br><span class="line">        len = (len*<span class="number">10</span>)+(*p - <span class="string">'0'</span>);</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Now p points at '\r', and the len is in bulk_len. */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>得到了批量回复或多条批量回复的长度之后， 程序只需调用一次 read 函数， 就可以将回复的正文数据全部读入到内存中， 而无须对这些数据做任何的处理。</p><p>在回复最末尾的 CR 和 LF 不作处理，丢弃它们。</p><p>Redis 协议的实现性能可以和二进制协议的实现性能相媲美， 并且由于 Redis 协议的简单性， 大部分高级语言都可以轻易地实现这个协议， 这使得客户端软件的 bug 数量大大减少。</p><h2 id="复制（Replication）"><a href="#复制（Replication）" class="headerlink" title="复制（Replication）"></a>复制（Replication）</h2><p>Redis 支持简单且易用的主从复制（master-slave replication）功能， 该功能可以让从服务器(slave server)成为主服务器(master server)的精确复制品。</p><p>以下是关于 Redis 复制功能的几个重要方面：</p><ul><li><p>Redis 使用异步复制。 从 Redis 2.8 开始， 从服务器会以每秒一次的频率向主服务器报告复制流（replication stream）的处理进度。</p></li><li><p>一个主服务器可以有多个从服务器。</p></li><li><p>不仅主服务器可以有从服务器， 从服务器也可以有自己的从服务器， 多个从服务器之间可以构成一个图状结构。</p></li><li><p>复制功能不会阻塞主服务器： 即使有一个或多个从服务器正在进行初次同步， 主服务器也可以继续处理命令请求。</p></li><li><p>复制功能也不会阻塞从服务器： 只要在 redis.conf 文件中进行了相应的设置， 即使从服务器正在进行初次同步， 服务器也可以使用旧版本的数据集来处理命令查询。</p><p>  不过， 在从服务器删除旧版本数据集并载入新版本数据集的那段时间内， 连接请求会被阻塞。</p><p>  你还可以配置从服务器， 让它在与主服务器之间的连接断开时， 向客户端发送一个错误。</p></li><li><p>复制功能可以单纯地用于数据冗余（data redundancy）， 也可以通过让多个从服务器处理只读命令请求来提升扩展性（scalability）： 比如说， 繁重的 SORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern …]] [ASC | DESC] [ALPHA] [STORE destination] 命令可以交给附属节点去运行。</p></li><li><p>可以通过复制功能来让主服务器免于执行持久化操作： 只要关闭主服务器的持久化功能， 然后由从服务器去执行持久化操作即可。</p></li></ul><h3 id="关闭主服务器持久化时，复制功能的数据安全"><a href="#关闭主服务器持久化时，复制功能的数据安全" class="headerlink" title="关闭主服务器持久化时，复制功能的数据安全"></a>关闭主服务器持久化时，复制功能的数据安全</h3><p>当配置Redis复制功能时，强烈建议打开主服务器的持久化功能。 否则的话，由于延迟等问题，部署的服务应该要避免自动拉起。</p><p>为了帮助理解主服务器关闭持久化时自动拉起的危险性，参考一下以下会导致主从服务器数据全部丢失的例子：</p><ol><li><p>假设节点A为主服务器，并且关闭了持久化。 并且节点B和节点C从节点A复制数据</p></li><li><p>节点A崩溃，然后由自动拉起服务重启了节点A. 由于节点A的持久化被关闭了，所以重启之后没有任何数据</p></li><li><p>节点B和节点C将从节点A复制数据，但是A的数据是空的， 于是就把自身保存的数据副本删除。</p></li></ol><p>在关闭主服务器上的持久化，并同时开启自动拉起进程的情况下，即便使用Sentinel来实现Redis的高可用性，也是非常危险的。 因为主服务器可能拉起得非常快，以至于Sentinel在配置的心跳时间间隔内没有检测到主服务器已被重启，然后还是会执行上面的数据丢失的流程。</p><p>无论何时，数据安全都是极其重要的，所以应该禁止主服务器关闭持久化的同时自动拉起。</p><h3 id="复制功能的运作原理"><a href="#复制功能的运作原理" class="headerlink" title="复制功能的运作原理"></a>复制功能的运作原理</h3><p>无论是初次连接还是重新连接， 当建立一个从服务器时， 从服务器都将向主服务器发送一个 SYNC 命令。</p><p>接到 SYNC 命令的主服务器将开始执行 BGSAVE ， 并在保存操作执行期间， 将所有新执行的写入命令都保存到一个缓冲区里面。</p><p>当 BGSAVE 执行完毕后， 主服务器将执行保存操作所得的 .rdb 文件发送给从服务器， 从服务器接收这个 .rdb 文件， 并将文件中的数据载入到内存中。</p><p>之后主服务器会以 Redis 命令协议的格式， 将写命令缓冲区中积累的所有内容都发送给从服务器。</p><p>你可以通过 telnet 命令来亲自验证这个同步过程： 首先连上一个正在处理命令请求的 Redis 服务器， 然后向它发送 SYNC 命令， 过一阵子， 你将看到 telnet 会话（session）接收到服务器发来的大段数据（.rdb 文件）， 之后还会看到， 所有在服务器执行过的写命令， 都会重新发送到 telnet 会话来。</p><p>即使有多个从服务器同时向主服务器发送 SYNC ， 主服务器也只需执行一次 BGSAVE 命令， 就可以处理所有这些从服务器的同步请求。</p><p>从服务器可以在主从服务器之间的连接断开时进行自动重连， 在 Redis 2.8 版本之前， 断线之后重连的从服务器总要执行一次完整重同步（full resynchronization）操作， 但是从 Redis 2.8 版本开始， 从服务器可以根据主服务器的情况来选择执行完整重同步还是部分重同步（partial resynchronization）。</p><h3 id="部分重同步"><a href="#部分重同步" class="headerlink" title="部分重同步"></a>部分重同步</h3><p>从 Redis 2.8 开始， 在网络连接短暂性失效之后， 主从服务器可以尝试继续执行原有的复制进程（process）， 而不一定要执行完整重同步操作。</p><p>这个特性需要主服务器为被发送的复制流创建一个内存缓冲区（in-memory backlog）， 并且主服务器和所有从服务器之间都记录一个复制偏移量（replication offset）和一个主服务器 ID （master run id）， 当出现网络连接断开时， 从服务器会重新连接， 并且向主服务器请求继续执行原来的复制进程：</p><ul><li>如果从服务器记录的主服务器 ID 和当前要连接的主服务器的 ID 相同， 并且从服务器记录的偏移量所指定的数据仍然保存在主服务器的复制流缓冲区里面， 那么主服务器会向从服务器发送断线时缺失的那部分数据， 然后复制工作可以继续执行。</li><li>否则的话， 从服务器就要执行完整重同步操作。</li></ul><p>Redis 2.8 的这个部分重同步特性会用到一个新增的 PSYNC master_run_id offset 内部命令， 而 Redis 2.8 以前的旧版本只有 SYNC 命令， 不过， 只要从服务器是 Redis 2.8 或以上的版本， 它就会根据主服务器的版本来决定到底是使用 PSYNC master_run_id offset 还是 SYNC ：</p><ul><li>如果主服务器是 Redis 2.8 或以上版本，那么从服务器使用 PSYNC master_run_id offset 命令来进行同步。</li><li>如果主服务器是 Redis 2.8 之前的版本，那么从服务器使用 SYNC 命令来进行同步。</li></ul><h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><p>配置一个从服务器非常简单， 只要在配置文件中增加以下的这一行就可以了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof 192.168.1.1 6379</span><br></pre></td></tr></table></figure></p><p>当然， 你需要将代码中的 192.168.1.1 和 6379 替换成你的主服务器的 IP 和端口号。</p><p>另外一种方法是调用 SLAVEOF host port 命令， 输入主服务器的 IP 和端口， 然后同步就会开始：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SLAVEOF 192.168.1.1 10086</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p><h3 id="只读从服务器"><a href="#只读从服务器" class="headerlink" title="只读从服务器"></a>只读从服务器</h3><p>从 Redis 2.6 开始， 从服务器支持只读模式， 并且该模式为从服务器的默认模式。</p><p>只读模式由 redis.conf 文件中的 slave-read-only 选项控制， 也可以通过 CONFIG SET parameter value 命令来开启或关闭这个模式。</p><p>只读从服务器会拒绝执行任何写命令， 所以不会出现因为操作失误而将数据不小心写入到了从服务器的情况。</p><p>即使从服务器是只读的， DEBUG 和 CONFIG 等管理式命令仍然是可以使用的， 所以我们还是不应该将服务器暴露给互联网或者任何不可信网络。 不过， 使用 redis.conf 中的命令改名选项， 我们可以通过禁止执行某些命令来提升只读从服务器的安全性。</p><p>你可能会感到好奇， 既然从服务器上的写数据会被重同步数据覆盖， 也可能在从服务器重启时丢失， 那么为什么要让一个从服务器变得可写呢？</p><p>原因是， 一些不重要的临时数据， 仍然是可以保存在从服务器上面的。 比如说， 客户端可以在从服务器上保存主服务器的可达性（reachability）信息， 从而实现故障转移（failover）策略。</p><h3 id="从服务器相关配置"><a href="#从服务器相关配置" class="headerlink" title="从服务器相关配置"></a>从服务器相关配置</h3><p>如果主服务器通过 requirepass 选项设置了密码， 那么为了让从服务器的同步操作可以顺利进行， 我们也必须为从服务器进行相应的身份验证设置。</p><p>对于一个正在运行的服务器， 可以使用客户端输入以下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config <span class="built_in">set</span> masterauth &lt;password&gt;</span><br></pre></td></tr></table></figure></p><p>要永久地设置这个密码， 那么可以将它加入到配置文件中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">masterauth &lt;password&gt;</span><br></pre></td></tr></table></figure></p><p>另外还有几个选项， 它们和主服务器执行部分重同步时所使用的复制流缓冲区有关， 详细的信息可以参考 Redis 源码中附带的 redis.conf 示例文件。</p><p>主服务器只在有至少 N 个从服务器的情况下，才执行写操作<br>从 Redis 2.8 开始， 为了保证数据的安全性， 可以通过配置， 让主服务器只在有至少 N 个当前已连接从服务器的情况下， 才执行写命令。</p><p>不过， 因为 Redis 使用异步复制， 所以主服务器发送的写数据并不一定会被从服务器接收到， 因此， 数据丢失的可能性仍然是存在的。</p><p>以下是这个特性的运作原理：</p><ul><li>从服务器以每秒一次的频率 PING 主服务器一次， 并报告复制流的处理情况。</li><li>主服务器会记录各个从服务器最后一次向它发送 PING 的时间。</li><li>用户可以通过配置， 指定网络延迟的最大值 min-slaves-max-lag ， 以及执行写操作所需的至少从服务器数量 min-slaves-to-write 。</li></ul><p>如果至少有 min-slaves-to-write 个从服务器， 并且这些服务器的延迟值都少于 min-slaves-max-lag 秒， 那么主服务器就会执行客户端请求的写操作。</p><p>你可以将这个特性看作 CAP 理论中的 C 的条件放宽版本： 尽管不能保证写操作的持久性， 但起码丢失数据的窗口会被严格限制在指定的秒数中。</p><p>另一方面， 如果条件达不到 min-slaves-to-write 和 min-slaves-max-lag 所指定的条件， 那么写操作就不会被执行， 主服务器会向请求执行写操作的客户端返回一个错误。</p><p>以下是这个特性的两个选项和它们所需的参数：</p><ul><li>min-slaves-to-write \<number of="" slaves\=""></number></li><li>min-slaves-max-lag \<number of="" seconds\=""></number></li></ul><p>详细的信息可以参考 Redis 源码中附带的 redis.conf 示例文件。</p><h2 id="事务（transaction）"><a href="#事务（transaction）" class="headerlink" title="事务（transaction）"></a>事务（transaction）</h2><p>MULTI 、 EXEC 、 DISCARD 和 WATCH 是 Redis 事务的基础。</p><p>事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p><ul><li><p>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p></li><li><p>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p><p>  EXEC 命令负责触发并执行事务中的所有命令：</p><ul><li>如果客户端在使用 MULTI 开启了一个事务之后，却因为断线而没有成功执行 EXEC ，那么事务中的所有命令都不会被执行。</li><li><p>另一方面，如果客户端成功在开启事务之后执行 EXEC ，那么事务中的所有命令都会被执行。</p><p>当使用 AOF 方式做持久化的时候， Redis 会使用单个 write(2) 命令将事务写入到磁盘中。</p><p>然而，如果 Redis 服务器因为某些原因被管理员杀死，或者遇上某种硬件故障，那么可能只有部分事务命令会被成功写入到磁盘中。</p><p>如果 Redis 在重新启动时发现 AOF 文件出了这样的问题，那么它会退出，并汇报一个错误。</p><p>使用 redis-check-aof 程序可以修复这一问题：它会移除 AOF 文件中不完整事务的信息，确保服务器可以顺利启动。</p></li></ul></li></ul><p>从 2.2 版本开始，Redis 还可以通过乐观锁（optimistic lock）实现 CAS （check-and-set）操作，具体信息请参考文档的后半部分。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>MULTI 命令用于开启一个事务，它总是返回 OK 。</p><p>MULTI 执行之后， 客户端可以继续向服务器发送任意多条命令， 这些命令不会立即被执行， 而是被放到一个队列中， 当 EXEC 命令被调用时， 所有队列中的命令才会被执行。</p><p>另一方面， 通过调用 DISCARD ， 客户端可以清空事务队列， 并放弃执行事务。</p><p>以下是一个事务例子， 它原子地增加了 foo 和 bar 两个键的值：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">&gt; INCR foo</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">&gt; INCR bar</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">&gt; EXEC</span><br><span class="line">1) (<span class="built_in">integer</span>) 1</span><br><span class="line">2) (<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure></p><p>EXEC 命令的回复是一个数组， 数组中的每个元素都是执行事务中的命令所产生的回复。 其中， 回复元素的先后顺序和命令发送的先后顺序一致。</p><p>当客户端处于事务状态时， 所有传入的命令都会返回一个内容为 QUEUED 的状态回复（status reply）， 这些被入队的命令将在 EXEC 命令被调用时执行。</p><h3 id="事务中的错误"><a href="#事务中的错误" class="headerlink" title="事务中的错误"></a>事务中的错误</h3><p>使用事务时可能会遇上以下两种错误：</p><ul><li>事务在执行 EXEC 之前，入队的命令可能会出错。比如说，命令可能会产生语法错误（参数数量错误，参数名错误，等等），或者其他更严重的错误，比如内存不足（如果服务器使用 maxmemory 设置了最大内存限制的话）。</li><li>命令可能在 EXEC 调用之后失败。举个例子，事务中的命令可能处理了错误类型的键，比如将列表命令用在了字符串键上面，诸如此类。</li></ul><p>对于发生在 EXEC 执行之前的错误，客户端以前的做法是检查命令入队所得的返回值：如果命令入队时返回 QUEUED ，那么入队成功；否则，就是入队失败。如果有命令在入队时失败，那么大部分客户端都会停止并取消这个事务。</p><p>不过，从 Redis 2.6.5 开始，服务器会对命令入队失败的情况进行记录，并在客户端调用 EXEC 命令时，拒绝执行并自动放弃这个事务。</p><p>在 Redis 2.6.5 以前， Redis 只执行事务中那些入队成功的命令，而忽略那些入队失败的命令。 而新的处理方式则使得在流水线（pipeline）中包含事务变得简单，因为发送事务和读取事务的回复都只需要和服务器进行一次通讯。</p><p>至于那些在 EXEC 命令执行之后所产生的错误， 并没有对它们进行特别处理： 即使事务中有某个/某些命令在执行时产生了错误， 事务中的其他命令仍然会继续执行。</p><p>从协议的角度来看这个问题，会更容易理解一些。 以下例子中， LPOP key 命令的执行将出错， 尽管调用它的语法是正确的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Trying 127.0.0.1...</span><br><span class="line">Connected to localhost.</span><br><span class="line">Escape character is <span class="string">'^]'</span>.</span><br><span class="line"></span><br><span class="line">MULTI</span><br><span class="line">+OK</span><br><span class="line"></span><br><span class="line">SET a 3</span><br><span class="line">abc</span><br><span class="line"></span><br><span class="line">+QUEUED</span><br><span class="line">LPOP a</span><br><span class="line"></span><br><span class="line">+QUEUED</span><br><span class="line">EXEC</span><br><span class="line"></span><br><span class="line">*2</span><br><span class="line">+OK</span><br><span class="line">-ERR Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure></p><p>EXEC 返回两条批量回复（bulk reply）： 第一条是 OK ，而第二条是 -ERR 。 至于怎样用合适的方法来表示事务中的错误， 则是由客户端自己决定的。</p><p>最重要的是记住这样一条， 即使事务中有某条/某些命令执行失败了， 事务队列中的其他命令仍然会继续执行 —— Redis 不会停止执行事务中的命令。</p><p>以下例子展示的是另一种情况， 当命令在入队时产生错误， 错误会立即被返回给客户端：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MULTI</span><br><span class="line">+OK</span><br><span class="line"></span><br><span class="line">INCR a b c</span><br><span class="line">-ERR wrong number of arguments <span class="keyword">for</span> <span class="string">'incr'</span> <span class="built_in">command</span></span><br></pre></td></tr></table></figure></p><p>因为调用 INCR key 命令的参数格式不正确， 所以这个 INCR key 命令入队失败。</p><h3 id="为什么-Redis-不支持回滚（roll-back）"><a href="#为什么-Redis-不支持回滚（roll-back）" class="headerlink" title="为什么 Redis 不支持回滚（roll back）"></a>为什么 Redis 不支持回滚（roll back）</h3><p>如果你有使用关系式数据库的经验， 那么 “Redis 在事务失败时不进行回滚，而是继续执行余下的命令”这种做法可能会让你觉得有点奇怪。</p><p>以下是这种做法的优点：</p><ul><li>Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。</li><li>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</li></ul><p>有种观点认为 Redis 处理事务的做法会产生 bug ， 然而需要注意的是， 在通常情况下， 回滚并不能解决编程错误带来的问题。 举个例子， 如果你本来想通过 INCR key 命令将键的值加上 1 ， 却不小心加上了 2 ， 又或者对错误类型的键执行了 INCR key ， 回滚是没有办法处理这些情况的。</p><p>鉴于没有任何机制能避免程序员自己造成的错误， 并且这类错误通常不会在生产环境中出现， 所以 Redis 选择了更简单、更快速的无回滚方式来处理事务。</p><h3 id="放弃事务"><a href="#放弃事务" class="headerlink" title="放弃事务"></a>放弃事务</h3><p>当执行 DISCARD 命令时， 事务会被放弃， 事务队列会被清空， 并且客户端会从事务状态中退出：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET foo 1</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; INCR foo</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; DISCARD</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET foo</span><br><span class="line"><span class="string">"1"</span></span><br></pre></td></tr></table></figure></p><h3 id="使用-check-and-set-操作实现乐观锁"><a href="#使用-check-and-set-操作实现乐观锁" class="headerlink" title="使用 check-and-set 操作实现乐观锁"></a>使用 check-and-set 操作实现乐观锁</h3><p>WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。</p><p>被 WATCH 的键会被监视，并会发觉这些键是否被改动过了。 如果有至少一个被监视的键在 EXEC 执行之前被修改了， 那么整个事务都会被取消， EXEC 返回空多条批量回复（null multi-bulk reply）来表示事务已经失败。</p><p>举个例子， 假设我们需要原子性地为某个值进行增 1 操作（假设 INCR key 不存在）。</p><p>首先我们可能会这样做：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val = GET mykey</span><br><span class="line">val = val + 1</span><br><span class="line">SET mykey val</span><br></pre></td></tr></table></figure></p><p>上面的这个实现在只有一个客户端的时候可以执行得很好。 但是， 当多个客户端同时对同一个键进行这样的操作时， 就会产生竞争条件。</p><p>举个例子， 如果客户端 A 和 B 都读取了键原来的值， 比如 10 ， 那么两个客户端都会将键的值设为 11 ， 但正确的结果应该是 12 才对。</p><p>有了 WATCH ， 我们就可以轻松地解决这类问题了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WATCH mykey</span><br><span class="line"></span><br><span class="line">val = GET mykey</span><br><span class="line">val = val + 1</span><br><span class="line"></span><br><span class="line">MULTI</span><br><span class="line">SET mykey val</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure></p><p>使用上面的代码， 如果在 WATCH 执行之后， EXEC 执行之前， 有其他客户端修改了 mykey 的值， 那么当前客户端的事务就会失败。 程序需要做的， 就是不断重试这个操作， 直到没有发生碰撞为止。</p><p>这种形式的锁被称作乐观锁， 它是一种非常强大的锁机制。 并且因为大多数情况下， 不同的客户端会访问不同的键， 碰撞的情况一般都很少， 所以通常并不需要进行重试。</p><h3 id="了解-WATCH"><a href="#了解-WATCH" class="headerlink" title="了解 WATCH"></a>了解 WATCH</h3><p>WATCH 使得 EXEC 命令需要有条件地执行： 事务只能在所有被监视键都没有被修改的前提下执行， 如果这个前提不能满足的话，事务就不会被执行。</p><p><strong>Note</strong></p><pre><code>如果你使用 WATCH 监视了一个带过期时间的键， 那么即使这个键过期了， 事务仍然可以正常执行， 关于这方面的详细情况，请看这个帖子： http://code.google.com/p/redis/issues/detail?id=270</code></pre><p>WATCH 命令可以被调用多次。 对键的监视从 WATCH 执行之后开始生效， 直到调用 EXEC 为止。</p><p>用户还可以在单个 WATCH 命令中监视任意多个键， 就像这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; WATCH key1 key2 key3</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p><p>当 EXEC 被调用时， 不管事务是否成功执行， 对所有键的监视都会被取消。</p><p>另外， 当客户端断开连接时， 该客户端对键的监视也会被取消。</p><p>使用无参数的 UNWATCH 命令可以手动取消对所有键的监视。 对于一些需要改动多个键的事务， 有时候程序需要同时对多个键进行加锁， 然后检查这些键的当前值是否符合程序的要求。 当值达不到要求时， 就可以使用 UNWATCH 命令来取消目前对键的监视， 中途放弃这个事务， 并等待事务的下次尝试。</p><h3 id="使用-WATCH-实现-ZPOP"><a href="#使用-WATCH-实现-ZPOP" class="headerlink" title="使用 WATCH 实现 ZPOP"></a>使用 WATCH 实现 ZPOP</h3><p>WATCH 可以用于创建 Redis 没有内置的原子操作。</p><p>举个例子， 以下代码实现了原创的 ZPOP 命令， 它可以原子地弹出有序集合中分值（score）最小的元素：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WATCH zset</span><br><span class="line">element = ZRANGE zset 0 0</span><br><span class="line">MULTI</span><br><span class="line">    ZREM zset element</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure></p><p>程序只要重复执行这段代码， 直到 EXEC 的返回值不是空多条回复（null multi-bulk reply）即可。</p><h3 id="Redis-脚本和事务"><a href="#Redis-脚本和事务" class="headerlink" title="Redis 脚本和事务"></a>Redis 脚本和事务</h3><p>从定义上来说， Redis 中的脚本本身就是一种事务， 所以任何在事务里可以完成的事， 在脚本里面也能完成。 并且一般来说， 使用脚本要来得更简单，并且速度更快。</p><p>因为脚本功能是 Redis 2.6 才引入的， 而事务功能则更早之前就存在了， 所以 Redis 才会同时存在两种处理事务的方法。</p><p>不过我们并不打算在短时间内就移除事务功能， 因为事务提供了一种即使不使用脚本， 也可以避免竞争条件的方法， 而且事务本身的实现并不复杂。</p><p>不过在不远的将来， 可能所有用户都会只使用脚本来实现事务也说不定。 如果真的发生这种情况的话， 那么我们将废弃并最终移除事务功能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>跨域问题及解决方案</title>
    <link href="https://www.sakuratears.top/blog/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html"/>
    <id>https://www.sakuratears.top/blog/跨域问题及解决方案.html</id>
    <published>2019-07-17T14:28:00.000Z</published>
    <updated>2019-07-17T14:35:30.616Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>要了解跨域问题，我们先来了解下浏览器的同源策略。</p><p>浏览器的同源策略限制了从同一个源加载的文档或脚本与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。</p><p>同源的定义：</p><blockquote><p>如果两个URL的协议、端口、IP（域名）都相同，则这两个URL具有相同的源。</p></blockquote><p>根据这个定义，我们给出了下面的表格，可以简单看一下。</p><table><thead><tr><th>URL A</th><th>URL B</th><th>是否同源</th><th>原因</th></tr></thead><tbody><tr><td><a href="http://abc.xyz.kk:8080/index.html" rel="external nofollow noopener noreferrer" target="_blank">http://abc.xyz.kk:8080/index.html</a></td><td><a href="http://abc.xyz.kk:8080/demo/demo.html" rel="external nofollow noopener noreferrer" target="_blank">http://abc.xyz.kk:8080/demo/demo.html</a></td><td>是</td><td>协议、端口、域名均相同</td></tr><tr><td><a href="http://abc.xyz.kk:8080/api" rel="external nofollow noopener noreferrer" target="_blank">http://abc.xyz.kk:8080/api</a></td><td><a href="http://abc.xyz.kk:8888/index.html" rel="external nofollow noopener noreferrer" target="_blank">http://abc.xyz.kk:8888/index.html</a></td><td>否</td><td>端口不相同</td></tr><tr><td><a href="http://abc.xyz.kk:8080/api" rel="external nofollow noopener noreferrer" target="_blank">http://abc.xyz.kk:8080/api</a></td><td><a href="http://xyz.abc.kk:8080/index.html" rel="external nofollow noopener noreferrer" target="_blank">http://xyz.abc.kk:8080/index.html</a></td><td>否</td><td>域名（IP）不相同</td></tr><tr><td><a href="http://abc.xyz.kk:8080/index.html" rel="external nofollow noopener noreferrer" target="_blank">http://abc.xyz.kk:8080/index.html</a></td><td><a href="https://abc.xyz.kk:8888/index.html" rel="external nofollow noopener noreferrer" target="_blank">https://abc.xyz.kk:8888/index.html</a></td><td>否</td><td>协议不相同</td></tr><tr><td><a href="http://abc.xyz.kk:8080/hello" rel="external nofollow noopener noreferrer" target="_blank">http://abc.xyz.kk:8080/hello</a></td><td><a href="https://mmm.sss.ll:8888/hello" rel="external nofollow noopener noreferrer" target="_blank">https://mmm.sss.ll:8888/hello</a></td><td>否</td><td>协议、端口、域名均不相同</td></tr></tbody></table><h1 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h1><p>看到前言所说，同源策略提高了数据安全性，为什么我们还要研究跨域问题呢？</p><p>如果单纯的Web网站，页面资源（html、js或jsp等）在服务端，我们是不用考虑跨域问题的，因为它们就在一个域下。</p><p>但是现在很多项目是前后端分离的，无论原生APP还是WebApp，由于IP、端口或者协议等的不同，它们的请求在访问后端系统时，如果不做些处理，就会受到浏览器同源策略的约束，进而出现403错误。</p><h1 id="跨域方法"><a href="#跨域方法" class="headerlink" title="跨域方法"></a>跨域方法</h1><p>我们目前有以下几种方法解决跨域问题，我们分别来看下吧。</p><h2 id="Cross-Origin-Resource-Sharing-CORS"><a href="#Cross-Origin-Resource-Sharing-CORS" class="headerlink" title="Cross-Origin Resource Sharing (CORS)"></a>Cross-Origin Resource Sharing (CORS)</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>CORS是一个跨域资源共享方案，为了解决跨域问题，通过增加一系列HTTP请求头和响应头，规范安全地进行跨站数据传输。</p><p>请求头主要包括以下参数：</p><table><thead><tr><th>参数名</th><th>说明</th></tr></thead><tbody><tr><td>Origin</td><td>用于在跨域请求或预先请求中，标明发起跨域请求的源域名</td></tr><tr><td>Access-Control-Request-Method</td><td>用于表明跨域请求使用的实际HTTP方法</td></tr><tr><td>Access-Control-Request-Headers</td><td>用于在预先请求时，告知服务器要发起的跨域请求中会携带的请求头信息</td></tr><tr><td>withCredentials</td><td>跨域请求是否携带凭据信息，如果设置为true，响应头的Access-Control-Allow-Origin必须指定具体域名，且Access-Control-Allow-Credentials参数为true</td></tr></tbody></table><p>响应头主要包括以下参数：</p><table><thead><tr><th>参数名</th><th>说明</th></tr></thead><tbody><tr><td>Access-Control-Allow-Origin</td><td>该参数中携带了服务器端验证后的允许的跨域请求域名，可以是一个具体的域名或是一个*（表示任意域名）</td></tr><tr><td>Access-Control-Expose-Headers</td><td>该参数用于允许返回给跨域请求的响应头列表，在列表中的响应头的内容，才可以被浏览器访问</td></tr><tr><td>Access-Control-Max-Age</td><td>该参数用于告知浏览器可以将预先检查请求返回结果缓存的时间，在缓存有效期内，浏览器会使用缓存的预先检查结果判断是否发送跨域请求</td></tr><tr><td>Access-Control-Allow-Methods</td><td>该参数用于告知浏览器可以在实际发送跨域请求时，可以支持的请求方法，可以是一个具体的方法列表或是一个*（表示任意方法）</td></tr><tr><td>Access-Control-Allow-Credentials</td><td>是否允许携带凭据信息。默认凭据信息 不包括在 CORS 请求之中</td></tr></tbody></table><p>当我们给客户端添加符合的上述请求头参数，给服务端添加符合的响应头参数后，客户端对服务端的请求便可以实现跨越访问。</p><p>对CORS有更多兴趣的同学可以参考MDN的这篇文章。</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" rel="external nofollow noopener noreferrer" target="_blank">Cross-Origin Resource Sharing (CORS)</a></li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>我们使用前端JS+后台SpringBoot的例子来看一下。</p><p>前端部分代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#test"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        type: <span class="string">"POST"</span>,</span><br><span class="line">        url: <span class="string">"http://abc.xyz.kk/hello"</span>,</span><br><span class="line">        data:&#123;</span><br><span class="line">            name:<span class="string">"hello"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">            alert(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>后端部分代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsFilter <span class="title">corsFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UrlBasedCorsConfigurationSource source = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">        CorsConfiguration corsConfiguration = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">        <span class="comment">//允许所有类型请求头</span></span><br><span class="line">        corsConfiguration.addAllowedHeader(<span class="string">"*"</span>);</span><br><span class="line">        <span class="comment">//允许HEAD、POST和OPTIONS方法</span></span><br><span class="line">        corsConfiguration.setAllowedMethods(Arrays.asList(<span class="string">"HEAD"</span>,<span class="string">"POST"</span>, <span class="string">"OPTIONS"</span>));</span><br><span class="line">        <span class="comment">//允许携带Cookie</span></span><br><span class="line">        corsConfiguration.setAllowCredentials(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//允许所有的源</span></span><br><span class="line">        corsConfiguration.setAllowedOrigins(Arrays.asList(<span class="string">"*"</span>));</span><br><span class="line">        <span class="comment">//时间设置为3600s</span></span><br><span class="line">        corsConfiguration.setMaxAge(<span class="number">3600L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//跨域设置</span></span><br><span class="line">        <span class="comment">//所有请求都允许跨域</span></span><br><span class="line">        source.registerCorsConfiguration(<span class="string">"/**"</span>, corsConfiguration);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsFilter(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般出现跨域问题，如果使用CORS，只需要后台配置CORS过滤器（如上）即可实现跨域访问。</p><h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>JSONP(JSON with Padding)是JSON的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题。</p><p>JSONP的原理就是借助HTML中的&lt;script&gt;标签可以跨域引入资源。所以动态创建一个&lt;srcipt&gt;标签，src为目的接口 + get数据包 + 处理数据的函数名。后台收到GET请求后解析并返回函数名(数据)给前端，前端&lt;script&gt;标签动态执行处理函数。</p><p>&lt;script&gt;标签的src属性是没有跨域的限制的。这样说来，这种跨域方式其实与Ajax XmlHttpRequest协议无关了。</p><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>我们看一下JSONP方式实现跨域的前后端大致代码：</p><p>前端部分代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">//jsonp回调方法，一定要写在jsonp请求之前</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">jsonptest</span>(<span class="params">result</span>)</span>&#123;</span></span><br><span class="line"><span class="undefined">        alert(result);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span> =<span class="string">"/hello/test?callback=jsonptest"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> &gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>后端部分代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span></span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"test"</span>,method=RequestMethod.GET)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">jsonpTest</span><span class="params">(String callback)</span></span>&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    <span class="keyword">return</span> callback +<span class="string">"('Hello World!');"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到如果客户期望返回Hello World！ 实际收到的请求为 <code>jsonptest(‘Hello World!’)</code>，然后调用jsonptest函数获得实际想要的结果。</p><p>因为JSONP使用js的&lt;script&gt;标签进行传参，故该种方式只支持GET请求，这也是JSONP的一个缺点。</p><h2 id="Nginx反向代理"><a href="#Nginx反向代理" class="headerlink" title="Nginx反向代理"></a>Nginx反向代理</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>出现跨域限制的根本原因是浏览器同源问题的限制。</p><p>我们如果把前端项目和前端要请求的后台API接口地址放在同源下不就可以实现跨域请求了么？</p><p>这样我们前后端都不需要做任何跨域配置处理。</p><h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><p>比如我们有一个H5项目，部署在 <a href="http://abc.xyz.kk:8088" rel="external nofollow noopener noreferrer" target="_blank">http://abc.xyz.kk:8088</a> Nginx服务器上，后台地址为 <a href="http://abc.123.ss:8888" rel="external nofollow noopener noreferrer" target="_blank">http://abc.123.ss:8888</a> ，后台项目API接口地址为 <a href="http://abc.123.ss:8888/api/" rel="external nofollow noopener noreferrer" target="_blank">http://abc.123.ss:8888/api/</a> 。</p><p>则Nginx的配置文件 nginx.conf 的 server部分配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    #charset koi8-r;</span><br><span class="line"></span><br><span class="line">    #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">        proxy_pass http://localhost:8000/; # 前端本机地址，实现自动更新</span><br><span class="line">        autoindex on;</span><br><span class="line">        autoindex_exact_size on;</span><br><span class="line">        autoindex_localtime on;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /api/ &#123;</span><br><span class="line">            proxy_pass http://abc.123.ss:8888; # 后台API接口地址</span><br><span class="line">            proxy_redirect off;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">    # redirect server error pages to the static page /50x.html</span><br><span class="line">    #</span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">    #</span><br><span class="line">    #location ~ \.php$ &#123;</span><br><span class="line">    #    proxy_pass   http://127.0.0.1;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line">    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">    #</span><br><span class="line">    #location ~ \.php$ &#123;</span><br><span class="line">    #    root           html;</span><br><span class="line">    #    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">    #    fastcgi_index  index.php;</span><br><span class="line">    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br><span class="line">    #    include        fastcgi_params;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line">    # deny access to .htaccess files, if Apache&apos;s document root</span><br><span class="line">    # concurs with nginx&apos;s one</span><br><span class="line">    #</span><br><span class="line">    #location ~ /\.ht &#123;</span><br><span class="line">    #    deny  all;</span><br><span class="line">    #&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们访问了 <a href="http://abc.xyz.kk:8088" rel="external nofollow noopener noreferrer" target="_blank">http://abc.xyz.kk:8088</a> 地址（代理前端地址），访问后台API时，通过反向代理，相当于访问 <a href="http://abc.xyz.kk:8088/api/" rel="external nofollow noopener noreferrer" target="_blank">http://abc.xyz.kk:8088/api/</a> 这个地址，就不会出现跨域问题了。</p><h2 id="其他跨域解决方案"><a href="#其他跨域解决方案" class="headerlink" title="其他跨域解决方案"></a>其他跨域解决方案</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>如果我们要通过A网页访问另一个域的B网页时，根据同源策略，也会出现跨域问题。</p><p>这种情况我们可以通过<code>window.postMessage</code>、<code>window.name</code>共享、<code>window.location.hash</code>共享等方法来解决，关于这块，我们简单的用<code>window.postMessage</code>来看下，其他的大家可以查询相关资料进行了解。</p><p>使用WebSocket也可以实现资源跨域访问，WebSocket是长连接，资源消耗较大，除在一些即时通讯等特殊场景，专门用来解决跨域问题还是少之又少的，这一块我们也不在详述。</p><h3 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h3><p>我们用<code>window.postMessage</code>来进行举例。</p><p>下面是两个HTML，<a href="http://aaa.aaa.aa/A.html" rel="external nofollow noopener noreferrer" target="_blank">http://aaa.aaa.aa/A.html</a> 和 <a href="http://bbb.bbb.bb/B.html" rel="external nofollow noopener noreferrer" target="_blank">http://bbb.bbb.bb/B.html</a> 用 postMessage进行交互的例子。</p><p>A.html (发送端)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>A.html<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"test"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"B.html"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"send"</span> &gt;</span>A发送消息给B<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"receiver"</span> <span class="attr">src</span>=<span class="string">"http://bbb.bbb.bb/B.html"</span> <span class="attr">width</span>=<span class="string">"500"</span> <span class="attr">height</span>=<span class="string">"60"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>你的浏览器不支持IFrame。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> receiver = <span class="built_in">document</span>.getElementById(<span class="string">'receiver'</span>).contentWindow;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'send'</span>);</span></span><br><span class="line"><span class="javascript">        btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">            e.preventDefault();</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> val = <span class="built_in">document</span>.getElementById(<span class="string">'test'</span>).value;</span></span><br><span class="line"><span class="javascript">            receiver.postMessage(<span class="string">"Hello "</span>+val+<span class="string">"！"</span>, <span class="string">"http://aaa.aaa.aa/A.html"</span>);</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>B.html (接收端)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>B.html<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"message"</span>&gt;</span></span><br><span class="line">    Hello World!</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> messageEle = <span class="built_in">document</span>.getElementById(<span class="string">'message'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">            alert(e.origin);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (e.origin !== <span class="string">"http://aaa.aaa.aa/A.html"</span>) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span>;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="javascript">            messageEle.innerHTML = <span class="string">"从"</span>+ e.origin +<span class="string">"收到消息： "</span> + e.data;</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上跨域解决方案，最常用的还是CORS和反向代理，其次是JSONP，其他很少会被使用。</p><p>在允许Ajax XmlHttpRequest的浏览器（高版本浏览器）并与后端交互的场景，CORS和反向代理应用最广。</p><p>如果浏览器不支持XmlHttpRequest（IE6、IE7….），可以考虑使用JSONP。</p><p>如果涉及到不同源网页交互，支持H5的浏览器可以采用<code>window.postMessage</code>，不支持的可以使用<code>window.name</code>共享、<code>window.location.hash</code>共享等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="跨域" scheme="https://www.sakuratears.top/tags/%E8%B7%A8%E5%9F%9F/"/>
    
      <category term="CORS" scheme="https://www.sakuratears.top/tags/CORS/"/>
    
      <category term="JSONP" scheme="https://www.sakuratears.top/tags/JSONP/"/>
    
  </entry>
  
  <entry>
    <title>JDK里那些有趣的代码（2）</title>
    <link href="https://www.sakuratears.top/blog/JDK%E9%87%8C%E9%82%A3%E4%BA%9B%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%882%EF%BC%89.html"/>
    <id>https://www.sakuratears.top/blog/JDK里那些有趣的代码（2）.html</id>
    <published>2019-07-09T13:55:00.000Z</published>
    <updated>2019-07-09T14:32:53.028Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>接 <a href="https://www.sakuratears.top/blog/JDK%E9%87%8C%E9%82%A3%E4%BA%9B%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%881%EF%BC%89.html">JDK里那些有趣的代码</a>这篇文章。</p><p>今天我们来看下另一个比较有意思的代码部分。</p><p>在说这个之前，我们先来研究一道比较有意思的题目。</p><blockquote><p>使用Java程序 获取下一个最小的比入参n大的2的高次幂</p></blockquote><p>这个题的意思就是：比如入参为10，则最小的比入参大的2的高次幂为 ${2}^{4} = {16}$；入参为100，则最小的比入参大的2的高次幂为${2}^{7}={128}$。</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>对于这种题目，我们如何处理呢？</p><p>最简单的是想到循环，2，4，8…..逐渐增大值，并与入参进行对比，相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNum1</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;= <span class="number">31</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">1</span>&lt;&lt;i;</span><br><span class="line">        <span class="keyword">if</span>(b &gt; n)&#123;</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上方法 <code>1&lt;&lt;i</code> 是把1左移i位，每次左移一位就是乘以2，所以<code> 1&lt;&lt;i </code>的结果是1乘以2的i次方。</p><p>当然我们也可以使用Java自带的<code>Math.pow</code>或者乘法算法方法，不过显然这种方法效率要低。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNum2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;= <span class="number">31</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">double</span> b = Math.pow(<span class="number">2</span>,i);</span><br><span class="line">        <span class="keyword">if</span>(b &gt; n)&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>)b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNum3</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;= <span class="number">31</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k &gt; n)&#123;</span><br><span class="line">            <span class="keyword">return</span> k;</span><br><span class="line">        &#125;</span><br><span class="line">        k *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者我们可以想到将入参每次除以2，直到小于1，记录次数i，然后2的i次方即是我们所要求的值。</p><p>相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNum4</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>&lt;&lt;i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们仍使用了移位运算，<code> n = n &gt;&gt; 1 </code>每次将n向右移一位即除以2，当n &lt;= 0 时记录次数 i,并使用<code> 1&lt;&lt;i </code>算出要求的值。</p><p>当然我们也可以使用普通的除法算法，但这种效率要低些，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNum5</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        n /=<span class="number">2</span>;</span><br><span class="line">       i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>&lt;&lt;i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实上面几种情况原理都是类似的。</p><p>还有什么别的方法么？</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>很巧，在JDK相关源码中也有类似的问题，即<em>获取下一个最小的比入参n大的2的高次幂</em>。</p><p>在哪儿会用到呢？</p><p>当然是HashMap了，HashMap在扩容时，扩容指定的大小就是<em>下一个最小的比入参n大的2的高次幂</em>。</p><p>下面是具体tableSizeFor方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以在CourrentHashMap、ForkJoinPool中发现类似的处理逻辑，这种处理的优点体现在哪儿呢？</p><p>我们把上面的代码在整理下，如下，对于入参n，该方法可以计算出最小的比入参n大的2的高次幂。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNum6</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> n &lt; <span class="number">0</span> ? <span class="number">1</span> : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：我们忽略源码中的<code>int n = cap - 1;</code> 这一步的作用是对于入参比如8，<code>tableSizeFor</code>方法会返回8，而<code>getNum6</code>会返回16，其实主要看题目怎么出，这儿我们找的是比入参n大的数，不包括n。</p><p>我们先来手动计算一下，以32和2000为例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 32 = 100000 = 0100000</span></span><br><span class="line">n|=n&gt;&gt;&gt;<span class="number">1</span>;<span class="comment">//  n=n|(n&gt;&gt;&gt;1)  = 0100000|0010000 = 0110000 = 48</span></span><br><span class="line">n|=n&gt;&gt;&gt;<span class="number">2</span>;<span class="comment">//  n=n|(n&gt;&gt;&gt;2)  = 0110000|0001100 = 0111100 = 60</span></span><br><span class="line">n|=n&gt;&gt;&gt;<span class="number">4</span>;<span class="comment">//  n=n|(n&gt;&gt;&gt;4)  = 0111100|0000011 = 0111111 = 63</span></span><br><span class="line">n|=n&gt;&gt;&gt;<span class="number">8</span>;<span class="comment">//  n=n|(n&gt;&gt;&gt;8)  = 0111111|0000000 = 0111111 = 63</span></span><br><span class="line">n|=n&gt;&gt;&gt;<span class="number">16</span>;<span class="comment">// n=n|(n&gt;&gt;&gt;16) = 0111111|0000000 = 0111111 = 63</span></span><br><span class="line"><span class="comment">// n + 1 =64</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2000 = 11111010000 = 11111010000</span></span><br><span class="line">n|=n&gt;&gt;&gt;<span class="number">1</span>;<span class="comment">//  n=n|(n&gt;&gt;&gt;1)  = 11111010000|01111101000 = 11111111000 = 2040</span></span><br><span class="line">n|=n&gt;&gt;&gt;<span class="number">2</span>;<span class="comment">//  n=n|(n&gt;&gt;&gt;2)  = 11111111000|00111111110 = 11111111110 = 2046</span></span><br><span class="line">n|=n&gt;&gt;&gt;<span class="number">4</span>;<span class="comment">//  n=n|(n&gt;&gt;&gt;4)  = 11111111110|00001111111 = 11111111111 = 2047</span></span><br><span class="line">n|=n&gt;&gt;&gt;<span class="number">8</span>;<span class="comment">//  n=n|(n&gt;&gt;&gt;8)  = 11111111111|00000000111 = 11111111111 = 2047</span></span><br><span class="line">n|=n&gt;&gt;&gt;<span class="number">16</span>;<span class="comment">// n=n|(n&gt;&gt;&gt;16) = 11111111111|00000000000 = 11111111111 = 2047</span></span><br><span class="line"><span class="comment">// n + 1 =2048</span></span><br></pre></td></tr></table></figure><p>计算过程比较简单，只要明白以下两点：</p><ul><li><p><code>n&gt;&gt;&gt;i</code> 是指二进制的n的值向右移i位；</p></li><li><p><code>i|k</code>指的是i和k进行位或运算，| 是把某两个二进制数中, 只要其中一个的某一位为1，则结果的该位就为1，与&amp;运算相反。</p></li></ul><p>我们来分析一下：</p><ul><li>首先，如果是2的整数次方数，其除最高位（指第一个不为0的数）外，其他位必然是0。比如 ${2}^{11}={2048}$，其二进制为 $100000000000$。</li><li><p>则2的整数次方数-1必定最高位为0，其他位必然为1。大致如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>   -<span class="number">1</span>   =    <span class="number">000000010</span> -<span class="number">1</span>   =  <span class="number">000000001</span></span><br><span class="line"><span class="number">4</span>   -<span class="number">1</span>   =    <span class="number">000000100</span> -<span class="number">1</span>   =  <span class="number">000000011</span></span><br><span class="line"><span class="number">8</span>   -<span class="number">1</span>   =    <span class="number">000001000</span> -<span class="number">1</span>   =  <span class="number">000000111</span></span><br><span class="line"><span class="number">16</span>  -<span class="number">1</span>   =    <span class="number">000010000</span> -<span class="number">1</span>   =  <span class="number">000001111</span></span><br><span class="line"><span class="number">32</span>  -<span class="number">1</span>   =    <span class="number">000100000</span> -<span class="number">1</span>   =  <span class="number">000011111</span></span><br><span class="line"><span class="number">64</span>  -<span class="number">1</span>   =    <span class="number">001000000</span> -<span class="number">1</span>   =  <span class="number">000111111</span></span><br><span class="line"><span class="number">128</span> -<span class="number">1</span>   =    <span class="number">010000000</span> -<span class="number">1</span>   =  <span class="number">001111111</span></span><br><span class="line"><span class="number">256</span> -<span class="number">1</span>   =    <span class="number">100000000</span> -<span class="number">1</span>   =  <span class="number">011111111</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure></li><li><p>我们对于任意数，如21，二进制为 000010101，当使用移位+位或运算时，最终该值会逐渐增大到 000011111，而这个值加1就是我们要找的值。其实质是右传播最左侧的一位，来找到最大值。</p></li><li><p>问：为什么右移位要按照1、2、4、8、16这样移动呢？而不是其他数字呢？</p><p>答：这很好理解，我们拿 $128 （010000000）$来举例，比它大的最小的2的高次幂是256，则需要得到255。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">010000000</span></span><br><span class="line"><span class="number">011000000</span>   右移<span class="number">1</span>位+位或</span><br><span class="line"><span class="number">011110000</span>   右移<span class="number">2</span>位+位或</span><br><span class="line"><span class="number">011111111</span>   右移<span class="number">4</span>位+位或</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>可以看到我们用了一个最小值128，得到255，只需要最左侧的1右移（1、2、4）并进行位或操作。int最大32位，故右移最大16位即可保证最高位的1对右边的0进行全覆盖（位或操作）。</p></li></ul><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>到底高不高效还是取决于测试结果，我们写一个简单的测试方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//生成若干数量的随机数，找到它们的最小的2的高次幂</span></span><br><span class="line">    <span class="keyword">int</span> [] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100000000</span>];</span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">        a[i] = random.nextInt(<span class="number">1073741824</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法1</span></span><br><span class="line">    <span class="keyword">long</span> start1 = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">        getNum1(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"方法1耗时:"</span>+(System.currentTimeMillis()-start1)+<span class="string">"ms"</span>);</span><br><span class="line">    <span class="comment">//方法2</span></span><br><span class="line">    <span class="keyword">long</span> start2 = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">        getNum2(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"方法2耗时:"</span>+(System.currentTimeMillis()-start2)+<span class="string">"ms"</span>);</span><br><span class="line">    <span class="comment">//方法3</span></span><br><span class="line">    <span class="keyword">long</span> start3 = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">        getNum3(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"方法3耗时:"</span>+(System.currentTimeMillis()-start3)+<span class="string">"ms"</span>);</span><br><span class="line">    <span class="comment">//方法4</span></span><br><span class="line">    <span class="keyword">long</span> start4 = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">        getNum4(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"方法4耗时:"</span>+(System.currentTimeMillis()-start4)+<span class="string">"ms"</span>);</span><br><span class="line">    <span class="comment">//方法5</span></span><br><span class="line">    <span class="keyword">long</span> start5 = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">        getNum5(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"方法5耗时:"</span>+(System.currentTimeMillis()-start5)+<span class="string">"ms"</span>);</span><br><span class="line">    <span class="comment">//方法6</span></span><br><span class="line">    <span class="keyword">long</span> start6 = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">        getNum6(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"方法6耗时:"</span>+(System.currentTimeMillis()-start6)+<span class="string">"ms"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>某次结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">方法<span class="number">1</span>耗时:<span class="number">1064</span>ms</span><br><span class="line"><span class="comment">//由于方法2耗时实在无法接受，便不再展示。调用Math.pow方法，同学们可实际测试下。</span></span><br><span class="line">方法<span class="number">3</span>耗时:<span class="number">1097</span>ms</span><br><span class="line">方法<span class="number">4</span>耗时:<span class="number">2232</span>ms</span><br><span class="line">方法<span class="number">5</span>耗时:<span class="number">3885</span>ms</span><br><span class="line">方法<span class="number">6</span>耗时:<span class="number">155</span>ms</span><br></pre></td></tr></table></figure><p>经过多次测试其结果相差不大。可以看到方法6（也就是JDK里的tableSizeFor方法）确实高效。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>该方法在 <a href="">Hacker’s Delight （高效程序的奥秘）</a>一书 3.2节中有一些介绍，有兴趣的同学也可以去看看。</p><p>通过上面的讲解，我们可以看到JDK源码中使用高效算法的艺术，多读源码，对我们也受益匪浅。</p><p>今天就先到这里，有时间我们在分析JDK源码中比较有趣的一些代码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JDK1.7与JDK1.8中ConcurrentHashMap的一些变化</title>
    <link href="https://www.sakuratears.top/blog/JDK1-7%E4%B8%8EJDK1-8%E4%B8%ADConcurrentHashMap%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8F%98%E5%8C%96.html"/>
    <id>https://www.sakuratears.top/blog/JDK1-7与JDK1-8中ConcurrentHashMap的一些变化.html</id>
    <published>2019-07-07T02:50:00.000Z</published>
    <updated>2019-07-07T03:19:01.181Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天我们来了解下<code>ConcurrentHashMap</code>的设计，并看下它在JDK1.7和JDK1.8中的一些改变。</p><p>说到<code>ConcurrentHashMap</code>，或许大家并不陌生，都知道它可以在并发访问的情况下使用，可以保证线程数据安全，相对于<code>Hashtable</code>和线程同步的<code>HashMap</code>-&gt;<code>Collections.synchronizedMap(new HashMap&lt;&gt;())</code>,它的效率更高。</p><p>在学习<code>ConcurrentHashMap</code>时，大家最好先对<code>HashMap</code>有一些认识，可以看一下我之前的一篇文章。<a href="https://www.sakuratears.top/blog/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html">HashMap实现原理</a></p><p>JDK1.7和JDK1.8 <code>ConcurrentHashMap</code>的设计实现是不同的，我们分别来看下，以进行对比。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="JDK1-7的ConcurrentHashMap"><a href="#JDK1-7的ConcurrentHashMap" class="headerlink" title="JDK1.7的ConcurrentHashMap"></a>JDK1.7的ConcurrentHashMap</h2><h3 id="1-7的ConcurrentHashMap设计思路"><a href="#1-7的ConcurrentHashMap设计思路" class="headerlink" title="1.7的ConcurrentHashMap设计思路"></a>1.7的ConcurrentHashMap设计思路</h3><p>1.7的 <code>ConcurrentHashMap</code>的设计是通过分段锁的方式实现的，提高了并发度。分段是一开始就确定的了，后期不能再进行扩容。</p><p>所谓分段锁，主要是根据<code>Segment</code>段来实现的。</p><p>其中的段<code>Segment</code>继承了重入锁<code>ReentrantLock</code>，有了锁的功能，同时含有类似<code>HashMap</code>中的数组加链表结构（这里没有使用红黑树）。</p><p>虽然<code>Segment</code>的个数是不能扩容的，但是单个<code>Segment</code>里面的数组是可以扩容的。</p><h3 id="整体概览"><a href="#整体概览" class="headerlink" title="整体概览"></a>整体概览</h3><p><code>ConcurrentHashMap</code>有3个参数：</p><ul><li>initialCapacity：初始总容量，默认16</li><li>loadFactor：加载因子，默认0.75</li><li>concurrencyLevel：并发级别，默认16</li></ul><p>然后我们需要知道的是：</p><ul><li><p><code>Segment</code>的个数即ssize：取大于等于并发级别的最小的2的幂次。如concurrencyLevel=16，那么sszie=16,如concurrencyLevel=10，那么ssize=16。</p></li><li><p>单个<code>Segment</code>的初始容量cap：c=initialCapacity/ssize,并且可能需要+1。如15/7=2，那么c要取3，如16/8=2，那么c取2，c可能是一个任意值，那么同上述一样，cap取的值就是大于等于c的最下2的幂次。最小值要求是MIN_SEGMENT_TABLE_CAPACITY = 2。</p></li><li><p>单个<code>Segment</code>的阈值threshold：threshold=cap*loadFactor。</p></li></ul><p>所以默认情况下，<code>Segment</code>的个数sszie=16,每个<code>Segment</code>的初始容量cap=2，单个<code>Segment</code>的阈值threshold=1。</p><p>如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-433.png" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-434.png" alt="upload successful"></p><p>通过上图我们可以算出上述数据。</p><h3 id="put过程"><a href="#put过程" class="headerlink" title="put过程"></a>put过程</h3><ol><li>首先根据key计算出一个hash值，找到对应的<code>Segment</code>；</li><li>调用<code>Segment</code>的lock方法，为后面的put操作加锁；</li><li>根据key计算出hash值，找到<code>Segment</code>中数组中对应index的链表，并将该数据放置到该链表中；</li><li>判断当前<code>Segment</code>包含元素的数量大于阈值，则<code>Segment</code>进行扩容。</li></ol><p>代码逻辑如下图源码：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-435.png" alt="upload successful"></p><p>其中<code>Segment</code>的put过程源码如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-436.png" alt="upload successful"></p><p>我们看一下加锁方法：</p><p>可以看到如果不成功会尝试进行重试直到成功，同时如果找不到key，会返回一个新的node节点，如果key存在，会返回null。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-437.png" alt="upload successful"></p><h3 id="扩容过程（rehash）"><a href="#扩容过程（rehash）" class="headerlink" title="扩容过程（rehash）"></a>扩容过程（rehash）</h3><p>这个扩容是在<code>Segment</code>的锁的保护下进行扩容的，不需要关注并发问题。</p><p>我们来看下相关源码：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-438.png" alt="upload successful"></p><p>我们看红框部分的内容，扩容的重点在于：</p><ul><li><p>首先找到一个lastRun，lastRun之后的元素和lastRun是在同一个桶中，所以后面的不需要进行变动。</p></li><li><p>然后对开始到lastRun部分的元素，重新计算下设置到newTable中，每次都是将当前元素作为newTable的首元素，之前老的链表作为该首元素的next部分。</p></li></ul><h3 id="get过程"><a href="#get过程" class="headerlink" title="get过程"></a>get过程</h3><ol><li>根据key计算出对应的<code>Segment</code>；</li><li>再根据key计算出对应<code>Segment</code>中数组的index；</li><li>最终遍历上述index位置的链表，查找出对应的key的value；</li></ol><p>源码如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-439.png" alt="upload successful"></p><h3 id="remove过程"><a href="#remove过程" class="headerlink" title="remove过程"></a>remove过程</h3><ol><li>根据key值计算hash找到对应的<code>Segment</code>；</li><li>如果<code>Segment</code>不为空就调用<code>Segment</code>的remove方法；</li><li>对<code>Segment</code>段进行加锁，根据hash计算出index，找到链表（如果存在的话）；</li><li>对于找到的链表，循环找到key对应的值，并进行删除。</li></ol><p>相关代码如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-440.png" alt="upload successful"></p><h3 id="size方法"><a href="#size方法" class="headerlink" title="size方法"></a>size方法</h3><p>我们先来看下源码：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-441.png" alt="upload successful"></p><p>其大致原理如下：</p><ol><li>使用一个循环，循环的退出条件是sum = last， 这次总数 = 上次总数，即<code>Segment</code>没有变化了；</li><li>每次循环，都记录 sum += modCount 和 size，如果超了int长度就返回最大int值；</li><li>循环一定次数（RETRIES_BEFORE_LOCK = 2）后如果<code>Segment</code>大小还在改变，就尝试对所有<code>Segment</code>加锁，来获取size；</li><li>最后要判断下所试次数（retries）是否大于RETRIES_BEFORE_LOCK，如果大于说明加过锁，还要对它们进行解锁。</li></ol><p>其他方法大家可以参考下源码，不再详述。</p><h2 id="JDK1-8的ConcurrentHashMap"><a href="#JDK1-8的ConcurrentHashMap" class="headerlink" title="JDK1.8的ConcurrentHashMap"></a>JDK1.8的ConcurrentHashMap</h2><h3 id="1-8的ConcurrentHashMap设计思路"><a href="#1-8的ConcurrentHashMap设计思路" class="headerlink" title="1.8的ConcurrentHashMap设计思路"></a>1.8的ConcurrentHashMap设计思路</h3><p>1.8的<code>ConcurrentHashMap</code>摒弃了1.7的<code>Segment</code>设计，而是在1.8<code>HashMap</code>的基础上实现了线程安全的版本，即也是采用数组+链表+红黑树的形式。</p><p>数组可以扩容，链表可以转化为红黑树。</p><h3 id="整体概览-1"><a href="#整体概览-1" class="headerlink" title="整体概览"></a>整体概览</h3><p>有一个重要的参数sizeCtl，代表数组的大小；</p><p>用户可以设置一个初始容量initialCapacity给<code>ConcurrentHashMap</code>；</p><p>sizeCtl = 大于（1.5倍initialCapacity+1）的最小的2的幂次，</p><p>即initialCapacity=20，则sizeCtl=32,如initialCapacity=24，则sizeCtl=64。</p><p>初始化的时候，会按照sizeCtl的大小创建出对应大小的数组。</p><p>相关代码如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-442.png" alt="upload successful"></p><h3 id="put过程-1"><a href="#put过程-1" class="headerlink" title="put过程"></a>put过程</h3><ol><li><p>如果数组还未初始化，那么进行初始化，这里会通过一个CAS操作将sizeCtl设置为-1，设置成功的，可以进行初始化操作；</p></li><li><p>根据key的hash值找到对应的桶，如果桶还不存在，那么通过一个CAS操作来设置桶的第一个元素，失败的继续执行下面的逻辑即向桶中插入或更新；</p></li><li><p>如果找到的桶存在，但是桶中第一个元素的hash值是-1，说明此时该桶正在进行迁移操作，这一块会在下面的扩容中详细介绍；</p></li><li><p>如果找到的桶存在，那么要么是链表结构要么是红黑树结构，此时需要获取该桶的锁，在锁定的情况下执行链表或者红黑树的插入或更新；</p><ul><li><p>如果桶中第一个元素的hash值大于0，说明是链表结构，则对链表插入或者更新；</p></li><li><p>如果桶中的第一个元素类型是TreeBin，说明是红黑树结构，则按照红黑树的方式进行插入或者更新；</p></li></ul></li><li><p>在锁的保护下插入或者更新完毕后，如果是链表结构，需要判断链表中元素的数量是否超过8（默认），一旦超过就要考虑进行数组扩容或者是链表转红黑树。</p></li></ol><p>如下图源码：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-443.png" alt="upload successful"></p><p>initTable方法代码如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-444.png" alt="upload successful"></p><p>我们再来看下扩容过程。</p><h3 id="扩容过程"><a href="#扩容过程" class="headerlink" title="扩容过程"></a>扩容过程</h3><p>一旦链表中的元素个数超过了8个，那么可以执行数组扩容或者链表转为红黑树，这里依据的策略跟<code>HashMap</code>依据的策略是一致的。</p><p>当数组长度还未达到64个时，优先数组的扩容，否则选择链表转为红黑树。</p><p>源码如下所示：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-445.png" alt="upload successful"></p><p>重点来看看这个扩容过程，即看下上述tryPresize方法，也可以看到上述是2倍扩容的方式。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-446.png" alt="upload successful"></p><p>第一个执行的线程会首先设置sizeCtl属性为一个负值，然后执行transfer(tab, null)，其他晚进来的线程会检查当前扩容是否已经完成，没完成则帮助进行扩容，完成了则直接退出。</p><p>该<code>ConcurrentHashMap</code>的扩容操作可以允许多个线程并发执行，那么就要处理好任务的分配工作。每个线程获取一部分桶的迁移任务，如果当前线程的任务完成，查看是否还有未迁移的桶，若有则继续领取任务执行，若没有则退出。在退出时需要检查是否还有其他线程在参与迁移工作，如果有则自己什么也不做直接退出，如果没有了则执行最终的收尾工作。</p><p>Q1：当前线程如何感知其他线程也在参与迁移工作？</p><p>A1: 靠sizeCtl的值，它初始值是一个负值=(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)，每当一个线程参与进来执行迁移工作，则该值进行CAS自增，该线程的任务执行完毕要退出时对该值进行CAS自减操作，所以当sizeCtl的值等于上述初值则说明了此时未有其他线程还在执行迁移工作，可以去执行收尾工作了。见如下代码:</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-447.png" alt="upload successful"></p><p>Q2: 任务按照什么规则进行分片？</p><p>A2： 下图stride即是每个分片的大小，目前有最低要求16，即每个分片至少需要16个桶。stride的计算依赖于CPU的核数，如果只有1个核，那么此时就不用分片，即stride=n。其他情况就是 (n &gt;&gt;&gt; 3) / NCPU。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-448.png" alt="upload successful"></p><p>Q3：如何记录目前已经分出去的任务？</p><p>A3: <code>ConcurrentHashMap</code>含有一个属性transferIndex（初值为最后一个桶），表示从transferIndex开始到后面所有的桶的迁移任务已经被分配出去了。所以每次线程领取扩容任务，则需要对该属性进行CAS的减操作，即一般是transferIndex-stride。</p><p>Q4：每个线程如何处理分到的部分桶的迁移工作？</p><p>A4：第一个获取到分片的线程会创建一个新的数组，容量是之前的2倍。</p><p>遍历自己所分到的桶：</p><ul><li><p>桶中元素不存在，则通过CAS操作设置桶中第一个元素为ForwardingNode，其Hash值为MOVED（-1）,同时该元素含有新的数组引用</p><p>此时若其他线程进行put操作，发现第一个元素的hash值为-1则代表正在进行扩容操作（并且表明该桶已经完成扩容操作了，可以直接在新的数组中重新进行hash和插入操作），该线程就可以去参与进去，或者没有任务则不用参与，此时可以去直接操作新的数组了</p></li><li><p>桶中元素存在且hash值为-1，则说明该桶已经被处理了（本不会出现多个线程任务重叠的情况，这里主要是该线程在执行完所有的任务后会再次进行检查，再次核对）</p></li><li><p>桶中为链表或者红黑树结构，则需要获取桶锁，防止其他线程对该桶进行put操作，然后处理方式同HashMap的处理方式一样，对桶中元素分为2类，分别代表当前桶中和要迁移到新桶中的元素。设置完毕后代表桶迁移工作已经完成，旧数组中该桶可以设置成ForwardingNode了</p></li></ul><p>下面来看下详细的代码：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-449.png" alt="upload successful"></p><h3 id="get过程-1"><a href="#get过程-1" class="headerlink" title="get过程"></a>get过程</h3><ul><li><p>根据k计算出hash值，找到对应的数组index;</p></li><li><p>如果该index位置无元素则直接返回null;</p></li><li><p>如果该index位置有元素:</p><ul><li><p>如果第一个元素的hash值小于0，则该节点可能为ForwardingNode或者红黑树节点TreeBin;</p><ul><li><p>如果是ForwardingNode（表示当前正在进行扩容），使用新的数组来进行查找;</p></li><li><p>如果是红黑树节点TreeBin，使用红黑树的查找方式来进行查找;</p></li></ul></li><li><p>如果第一个元素的hash大于等于0，则为链表结构，依次遍历即可找到对应的元素。</p></li></ul></li></ul><p>详细代码如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-450.png" alt="upload successful"></p><h3 id="其他方法过程"><a href="#其他方法过程" class="headerlink" title="其他方法过程"></a>其他方法过程</h3><p><code>ConcurrentHashMap</code>的一些其它方法，如remove，size等也是十分复杂的。我们后面在详聊JDK1.8 <code>ConcurrentHashMap</code>的一些其它方法。</p><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><h2 id="ConcurrentHashMap读为什么不需要锁？"><a href="#ConcurrentHashMap读为什么不需要锁？" class="headerlink" title="ConcurrentHashMap读为什么不需要锁？"></a>ConcurrentHashMap读为什么不需要锁？</h2><p>我们通常使用读写锁来保护对一堆数据的读写操作。读时加读锁，写时加写锁。在什么样的情况下可以不需要读锁呢？</p><p>如果对数据的读写是一个原子操作，那么此时是可以不需要读锁的。如<code>ConcurrentHashMap</code>对数据的读写，写操作是不需要分2次写的（没有中间状态），读操作也是不需要2次读取的。假如一个写操作需要分多次写，必然会有中间状态，如果读不加锁，那么可能就会读到中间状态，那就不对了。</p><p>假如<code>ConcurrentHashMap</code>提供put(key1,value1,key2,value2)，写入的时候必然会存在中间状态即key1写完成，但是key2还未写，此时如果读不加锁，那么就可能读到key1是新数据而key2是老数据的中间状态。</p><p>虽然<code>ConcurrentHashMap</code>的读不需要锁，但是需要保证能读到最新数据，所以必须加volatile。即数组的引用需要加volatile，同时一个Node节点中的val和next属性也必须要加volatile。</p><h2 id="ConcurrentHashMap是否可以在无锁的情况下进行迁移？"><a href="#ConcurrentHashMap是否可以在无锁的情况下进行迁移？" class="headerlink" title="ConcurrentHashMap是否可以在无锁的情况下进行迁移？"></a>ConcurrentHashMap是否可以在无锁的情况下进行迁移？</h2><p>目前1.8的<code>ConcurrentHashMap</code>迁移是在锁定旧桶的前提下进行迁移的，然而并没有去锁定新桶。那么就可能提出如下问题：</p><p>Q1：在某个桶的迁移过程中，别的线程想要对该桶进行put操作怎么办？</p><p>A1: 一旦某个桶在迁移过程中了，必然要获取该桶的锁，所以其他线程的put操作要被阻塞，一旦迁移完毕，该桶中第一个元素就会被设置成ForwardingNode节点，所以其他线程put时需要重新判断下桶中第一个元素是否被更改了，如果被改了重新获取重新执行逻辑，如下代码：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-451.png" alt="upload successful"></p><p>Q2: 某个桶已经迁移完成（其他桶还未完成），别的线程想要对该桶进行put操作怎么办？</p><p>A2: 该线程会首先检查是否还有未分配的迁移任务，如果有则先去执行迁移任务，如果没有即全部任务已经分发出去了，那么此时该线程可以直接对新的桶进行插入操作（映射到的新桶必然已经完成了迁移，所以可以放心执行操作）。</p><p>Q3: 从上面看到我们在迁移的时候还是需要对旧桶锁定的，能否在无锁的情况下实现迁移？</p><p>A3: 一旦扩容就涉及到迁移桶中元素的操作，将一个桶中的元素迁移到另一个桶中的操作不是一个原子操作，所以需要在锁的保护下进行迁移。如果扩容操作是移动桶的指向，那么就可以通过一个CAS操作来完成扩容操作。可以参考参考这篇论文<a href="http://people.csail.mit.edu/shanir/publications/Split-Ordered_Lists.pdf" rel="external nofollow noopener noreferrer" target="_blank">Split-Ordered Lists: Lock-Free Extensible Hash Tables</a></p><h2 id="ConcurrentHashMap曾经的弱一致性"><a href="#ConcurrentHashMap曾经的弱一致性" class="headerlink" title="ConcurrentHashMap曾经的弱一致性"></a>ConcurrentHashMap曾经的弱一致性</h2><p>曾经老版本的<code>ConcurrentHashMap</code>是弱一致的，大家可以参考相关文档或者较早的<code>ConcurrentHashMap</code>源码。</p><p>曾经引发弱一致性的原因：</p><pre><code>对数组的引用是volatile来修饰的，但是数组中的元素并不是。即读取数组的引用总是能读取到最新的值，但是读取数组中某一个元素的时候并不一定能读到最新的值。所以说是弱一致性的。</code></pre><p>要实现强一致性，可以这样：</p><ul><li><p>对于新加的key，通过写入到链表的末尾即可。因为一个元素的next属性是volatile的，可以保证写入后立马看的到，如下1.8的方式；</p></li><li><p>或者对数组中元素的更新采用volatile写的方式，如下1.7的形式。</p></li></ul><p>但是现在1.7版本的<code>ConcurrentHashMap</code>对于数组中元素的写也是加了volatile的，如下代码：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-452.png" alt="upload successful"></p><p>1.8的方式就是直接将新加入的元素写入next属性（含有volatile修饰）中而不是修改桶中的第一个元素，如下代码：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-453.png" alt="upload successful"></p><p>所以在1.7和1.8版本的<code>ConcurrentHashMap</code>中不再是弱一致性，写入的数据是可以立即被读到的。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本文介绍了JDK1.7和JDK1.8版本下的<code>ConcurrentHashMap</code>的一些差异，也了解了1.7和1.8下<code>ConcurrentHashMap</code>的一些原理及方法，让我们对<code>ConcurrentHashMap</code>有了更深刻的一些认识。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://my.oschina.net/pingpangkuangmo/blog/817973" rel="external nofollow noopener noreferrer" target="_blank">jdk1.8的HashMap和ConcurrentHashMap</a> (有改动)</li><li>JDK1.8 ConcurrentHashMap源码</li><li>JDK1.7 ConcurrentHashMap源码</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="ConcurrentHashMap" scheme="https://www.sakuratears.top/tags/ConcurrentHashMap/"/>
    
  </entry>
  
</feed>
